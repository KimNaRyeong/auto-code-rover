2025-10-18 14:25:21.072 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 14:25:25.034 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=543, output_tokens=12, cost=0.005790
2025-10-18 14:25:35.640 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=723, output_tokens=530, cost=0.023130
2025-10-18 14:25:36.939 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:25:44.735 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=845, output_tokens=298, cost=0.017390
2025-10-18 14:25:44.740 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:25:49.056 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=652, output_tokens=70, cost=0.008620
2025-10-18 14:25:49.058 | DEBUG    | Extracted a valid json.
2025-10-18 14:25:49.063 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"bar\")",
        "search_method(\"barh\")",
        "search_code(\"plt.rcParams['date.converter'] = 'concise'\")",
        "search_code(\"ax.barh\")",
        "search_code(\"ax.bar\")"
    ],
    "bug_locations": []
}
2025-10-18 14:25:49.266 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:25:49.267 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:26:06.411 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4974, output_tokens=732, cost=0.071700
2025-10-18 14:26:06.423 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:26:13.578 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5922, output_tokens=296, cost=0.068100
2025-10-18 14:26:13.584 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:26:21.594 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=650, output_tokens=263, cost=0.014390
2025-10-18 14:26:21.595 | DEBUG    | Extracted a valid json.
2025-10-18 14:26:21.595 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/axes/_axes.py",
            "class": "Axes",
            "method": "bar",
            "intended_behavior": "This method should include a mechanism to detect if the `bottom` parameter is supplied with datetime objects, and if so, ensure proper conversion to the appropriate format that the Axes object can understand and correctly display. This behavior should preserve all existing functionality for other types of data while enhancing the method to handle datetime units effectively, thus ensuring that when `bottom` is a datetime object, the x-axis (for vertical bars) dynamically adjusts to represent time scales accurately."
        },
        {
            "file": "lib/matplotlib/axes/_axes.py",
            "class": "Axes",
            "method": "barh",
            "intended_behavior": "Similarly to the `bar` method, `barh` should be enhanced to identify when the `left` parameter receives datetime objects and perform necessary conversions or adjustments to ensure the y-axis (for horizontal bars) adequately represents datetime scales. This preserves the method's current capabilities while extending its functionality to support datetime objects, addressing the reported issue of incorrect datetime units representation in horizontal bar plots."
        }
    ]
}
2025-10-18 14:26:21.643 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>bar</method>
<code>
2267     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2268             **kwargs):
2269         r"""
2270         Make a bar plot.
2271 
2272         The bars are positioned at *x* with the given *align*\ment. Their
2273         dimensions are given by *height* and *width*. The vertical baseline
2274         is *bottom* (default 0).
2275 
2276         Many parameters can take either a single value applying to all bars
2277         or a sequence of values, one for each bar.
2278 
2279         Parameters
2280         ----------
2281         x : float or array-like
2282             The x coordinates of the bars. See also *align* for the
2283             alignment of the bars to the coordinates.
2284 
2285         height : float or array-like
2286             The height(s) of the bars.
2287 
2288         width : float or array-like, default: 0.8
2289             The width(s) of the bars.
2290 
2291         bottom : float or array-like, default: 0
2292             The y coordinate(s) of the bottom side(s) of the bars.
2293 
2294         align : {'center', 'edge'}, default: 'center'
2295             Alignment of the bars to the *x* coordinates:
2296 
2297             - 'center': Center the base on the *x* positions.
2298             - 'edge': Align the left edges of the bars with the *x* positions.
2299 
2300             To align the bars on the right edge pass a negative *width* and
2301             ``align='edge'``.
2302 
2303         Returns
2304         -------
2305         `.BarContainer`
2306             Container with all the bars and optionally errorbars.
2307 
2308         Other Parameters
2309         ----------------
2310         color : color or list of color, optional
2311             The colors of the bar faces.
2312 
2313         edgecolor : color or list of color, optional
2314             The colors of the bar edges.
2315 
2316         linewidth : float or array-like, optional
2317             Width of the bar edge(s). If 0, don't draw edges.
2318 
2319         tick_label : str or list of str, optional
2320             The tick labels of the bars.
2321             Default: None (Use default numeric labels.)
2322 
2323         label : str or list of str, optional
2324             A single label is attached to the resulting `.BarContainer` as a
2325             label for the whole dataset.
2326             If a list is provided, it must be the same length as *x* and
2327             labels the individual bars. Repeated labels are not de-duplicated
2328             and will cause repeated label entries, so this is best used when
2329             bars also differ in style (e.g., by passing a list to *color*.)
2330 
2331         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2332             If not *None*, add horizontal / vertical errorbars to the bar tips.
2333             The values are +/- sizes relative to the data:
2334 
2335             - scalar: symmetric +/- values for all bars
2336             - shape(N,): symmetric +/- values for each bar
2337             - shape(2, N): Separate - and + values for each bar. First row
2338               contains the lower errors, the second row contains the upper
2339               errors.
2340             - *None*: No errorbar. (Default)
2341 
2342             See :doc:`/gallery/statistics/errorbar_features` for an example on
2343             the usage of *xerr* and *yerr*.
2344 
2345         ecolor : color or list of color, default: 'black'
2346             The line color of the errorbars.
2347 
2348         capsize : float, default: :rc:`errorbar.capsize`
2349            The length of the error bar caps in points.
2350 
2351         error_kw : dict, optional
2352             Dictionary of keyword arguments to be passed to the
2353             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2354             here take precedence over the independent keyword arguments.
2355 
2356         log : bool, default: False
2357             If *True*, set the y-axis to be log scale.
2358 
2359         data : indexable object, optional
2360             DATA_PARAMETER_PLACEHOLDER
2361 
2362         **kwargs : `.Rectangle` properties
2363 
2364         %(Rectangle:kwdoc)s
2365 
2366         See Also
2367         --------
2368         barh : Plot a horizontal bar plot.
2369 
2370         Notes
2371         -----
2372         Stacked bars can be achieved by passing individual *bottom* values per
2373         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2374         """
2375         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2376         color = kwargs.pop('color', None)
2377         if color is None:
2378             color = self._get_patches_for_fill.get_next_color()
2379         edgecolor = kwargs.pop('edgecolor', None)
2380         linewidth = kwargs.pop('linewidth', None)
2381         hatch = kwargs.pop('hatch', None)
2382 
2383         # Because xerr and yerr will be passed to errorbar, most dimension
2384         # checking and processing will be left to the errorbar method.
2385         xerr = kwargs.pop('xerr', None)
2386         yerr = kwargs.pop('yerr', None)
2387         error_kw = kwargs.pop('error_kw', {})
2388         ezorder = error_kw.pop('zorder', None)
2389         if ezorder is None:
2390             ezorder = kwargs.get('zorder', None)
2391             if ezorder is not None:
2392                 # If using the bar zorder, increment slightly to make sure
2393                 # errorbars are drawn on top of bars
2394                 ezorder += 0.01
2395         error_kw.setdefault('zorder', ezorder)
2396         ecolor = kwargs.pop('ecolor', 'k')
2397         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2398         error_kw.setdefault('ecolor', ecolor)
2399         error_kw.setdefault('capsize', capsize)
2400 
2401         # The keyword argument *orientation* is used by barh() to defer all
2402         # logic and drawing to bar(). It is considered internal and is
2403         # intentionally not mentioned in the docstring.
2404         orientation = kwargs.pop('orientation', 'vertical')
2405         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2406         log = kwargs.pop('log', False)
2407         label = kwargs.pop('label', '')
2408         tick_labels = kwargs.pop('tick_label', None)
2409 
2410         y = bottom  # Matches barh call signature.
2411         if orientation == 'vertical':
2412             if y is None:
2413                 y = 0
2414         else:  # horizontal
2415             if x is None:
2416                 x = 0
2417 
2418         if orientation == 'vertical':
2419             self._process_unit_info(
2420                 [("x", x), ("y", height)], kwargs, convert=False)
2421             if log:
2422                 self.set_yscale('log', nonpositive='clip')
2423         else:  # horizontal
2424             self._process_unit_info(
2425                 [("x", width), ("y", y)], kwargs, convert=False)
2426             if log:
2427                 self.set_xscale('log', nonpositive='clip')
2428 
2429         # lets do some conversions now since some types cannot be
2430         # subtracted uniformly
2431         if self.xaxis is not None:
2432             x0 = x
2433             x = np.asarray(self.convert_xunits(x))
2434             width = self._convert_dx(width, x0, x, self.convert_xunits)
2435             if xerr is not None:
2436                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2437         if self.yaxis is not None:
2438             y0 = y
2439             y = np.asarray(self.convert_yunits(y))
2440             height = self._convert_dx(height, y0, y, self.convert_yunits)
2441             if yerr is not None:
2442                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2443 
2444         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2445             # Make args iterable too.
2446             np.atleast_1d(x), height, width, y, linewidth, hatch)
2447 
2448         # Now that units have been converted, set the tick locations.
2449         if orientation == 'vertical':
2450             tick_label_axis = self.xaxis
2451             tick_label_position = x
2452         else:  # horizontal
2453             tick_label_axis = self.yaxis
2454             tick_label_position = y
2455 
2456         if not isinstance(label, str) and np.iterable(label):
2457             bar_container_label = '_nolegend_'
2458             patch_labels = label
2459         else:
2460             bar_container_label = label
2461             patch_labels = ['_nolegend_'] * len(x)
2462         if len(patch_labels) != len(x):
2463             raise ValueError(f'number of labels ({len(patch_labels)}) '
2464                              f'does not match number of bars ({len(x)}).')
2465 
2466         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2467         hatch = itertools.cycle(np.atleast_1d(hatch))
2468         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2469                                 # Fallback if color == "none".
2470                                 itertools.repeat('none'))
2471         if edgecolor is None:
2472             edgecolor = itertools.repeat(None)
2473         else:
2474             edgecolor = itertools.chain(
2475                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2476                 # Fallback if edgecolor == "none".
2477                 itertools.repeat('none'))
2478 
2479         # We will now resolve the alignment and really have
2480         # left, bottom, width, height vectors
2481         _api.check_in_list(['center', 'edge'], align=align)
2482         if align == 'center':
2483             if orientation == 'vertical':
2484                 try:
2485                     left = x - width / 2
2486                 except TypeError as e:
2487                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2488                                     f'and width ({width.dtype}) '
2489                                     f'are incompatible') from e
2490                 bottom = y
2491             else:  # horizontal
2492                 try:
2493                     bottom = y - height / 2
2494                 except TypeError as e:
2495                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2496                                     f'and height ({height.dtype}) '
2497                                     f'are incompatible') from e
2498                 left = x
2499         else:  # edge
2500             left = x
2501             bottom = y
2502 
2503         patches = []
2504         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2505                    hatch, patch_labels)
2506         for l, b, w, h, c, e, lw, htch, lbl in args:
2507             r = mpatches.Rectangle(
2508                 xy=(l, b), width=w, height=h,
2509                 facecolor=c,
2510                 edgecolor=e,
2511                 linewidth=lw,
2512                 label=lbl,
2513                 hatch=htch,
2514                 )
2515             r._internal_update(kwargs)
2516             r.get_path()._interpolation_steps = 100
2517             if orientation == 'vertical':
2518                 r.sticky_edges.y.append(b)
2519             else:  # horizontal
2520                 r.sticky_edges.x.append(l)
2521             self.add_patch(r)
2522             patches.append(r)
2523 
2524         if xerr is not None or yerr is not None:
2525             if orientation == 'vertical':
2526                 # using list comps rather than arrays to preserve unit info
2527                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2528                 ey = [b + h for b, h in zip(bottom, height)]
2529 
2530             else:  # horizontal
2531                 # using list comps rather than arrays to preserve unit info
2532                 ex = [l + w for l, w in zip(left, width)]
2533                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2534 
2535             error_kw.setdefault("label", '_nolegend_')
2536 
2537             errorbar = self.errorbar(ex, ey,
2538                                      yerr=yerr, xerr=xerr,
2539                                      fmt='none', **error_kw)
2540         else:
2541             errorbar = None
2542 
2543         self._request_autoscale_view()
2544 
2545         if orientation == 'vertical':
2546             datavalues = height
2547         else:  # horizontal
2548             datavalues = width
2549 
2550         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2551                                      orientation=orientation,
2552                                      label=bar_container_label)
2553         self.add_container(bar_container)
2554 
2555         if tick_labels is not None:
2556             tick_labels = np.broadcast_to(tick_labels, len(patches))
2557             tick_label_axis.set_ticks(tick_label_position)
2558             tick_label_axis.set_ticklabels(tick_labels)
2559 
2560         return bar_container

</code><intended_behavior>This method should include a mechanism to detect if the `bottom` parameter is supplied with datetime objects, and if so, ensure proper conversion to the appropriate format that the Axes object can understand and correctly display. This behavior should preserve all existing functionality for other types of data while enhancing the method to handle datetime units effectively, thus ensuring that when `bottom` is a datetime object, the x-axis (for vertical bars) dynamically adjusts to represent time scales accurately.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
320                 [self],
321                 *args,
322                 **kwargs)
323         if len(extra_args):
324             raise _api.nargs_error('legend', '0-2', len(args))
325         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
326         self.legend_._remove_method = self._remove_legend
327         return self.legend_
328 
329     def _remove_legend(self, legend):
330         self.legend_ = None
331 
332     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
333         """
334         Add a child inset Axes to this existing Axes.
335 
336         Warnings
337         --------
338         This method is experimental as of 3.0, and the API may change.
339 
340         Parameters
341         ----------
342         bounds : [x0, y0, width, height]
343             Lower-left corner of inset Axes, and its width and height.
344 
345         transform : `.Transform`
346             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
347             Axes-relative coordinates.
348 
349         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
350 'polar', 'rectilinear', str}, optional
351             The projection type of the inset `~.axes.Axes`. *str* is the name
352             of a custom projection, see `~matplotlib.projections`. The default
353             None results in a 'rectilinear' projection.
354 
355         polar : bool, default: False
356             If True, equivalent to projection='polar'.
357 
358         axes_class : subclass type of `~.axes.Axes`, optional
359             The `.axes.Axes` subclass that is instantiated.  This parameter
360             is incompatible with *projection* and *polar*.  See
361             :ref:`axisartist_users-guide-index` for examples.
362 
363         zorder : number
364             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
365             to change whether it is above or below data plotted on the
366             parent Axes.
367 
368         **kwargs
369             Other keyword arguments are passed on to the inset Axes class.
370 
371         Returns
372         -------
373         ax
374             The created `~.axes.Axes` instance.
375 
376         Examples
377         --------
378         This example makes two inset Axes, the first is in Axes-relative
379         coordinates, and the second in data-coordinates::
380 
381             fig, ax = plt.subplots()
382             ax.plot(range(10))
383             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
384             axin2 = ax.inset_axes(
385                     [5, 7, 2.3, 2.3], transform=ax.transData)
386 
387         """
388         if transform is None:
389             transform = self.transAxes
390         kwargs.setdefault('label', 'inset_axes')
391 
392         # This puts the rectangle into figure-relative coordinates.
393         inset_locator = _TransformedBoundsLocator(bounds, transform)
394         bounds = inset_locator(self, None).bounds
395         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
396         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
397 
398         # this locator lets the axes move if in data coordinates.
399         # it gets called in `ax.apply_aspect() (of all places)
400         inset_ax.set_axes_locator(inset_locator)
401 
402         self.add_child_axes(inset_ax)
403 
404         return inset_ax
405 
406     @_docstring.dedent_interpd
407     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
408                        facecolor='none', edgecolor='0.5', alpha=0.5,
409                        zorder=4.99, **kwargs):
410         """
411         Add an inset indicator to the Axes.  This is a rectangle on the plot
412         at the position indicated by *bounds* that optionally has lines that
413         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
414 
415         Warnings
416         --------
417         This method is experimental as of 3.0, and the API may change.
418 
419         Parameters
420         ----------
421         bounds : [x0, y0, width, height]
422             Lower-left corner of rectangle to be marked, and its width
423             and height.
424 
425         inset_ax : `.Axes`
426             An optional inset Axes to draw connecting lines to.  Two lines are
427             drawn connecting the indicator box to the inset Axes on corners
428             chosen so as to not overlap with the indicator box.
429 
430         transform : `.Transform`
431             Transform for the rectangle coordinates. Defaults to
432             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
433             coordinates.
434 
435         facecolor : color, default: 'none'
436             Facecolor of the rectangle.
437 
438         edgecolor : color, default: '0.5'
439             Color of the rectangle and color of the connecting lines.
440 
441         alpha : float, default: 0.5
442             Transparency of the rectangle and connector lines.
443 
444         zorder : float, default: 4.99
445             Drawing order of the rectangle and connector lines.  The default,
446             4.99, is just below the default level of inset Axes.
447 
448         **kwargs
449             Other keyword arguments are passed on to the `.Rectangle` patch:
450 
451             %(Rectangle:kwdoc)s
452 
453         Returns
454         -------
455         rectangle_patch : `.patches.Rectangle`
456              The indicator frame.
457 
458         connector_lines : 4-tuple of `.patches.ConnectionPatch`
459             The four connector lines connecting to (lower_left, upper_left,
460             lower_right upper_right) corners of *inset_ax*. Two lines are
461             set with visibility to *False*,  but the user can set the
462             visibility to True if the automatic choice is not deemed correct.
463 
464         """
465         # to make the axes connectors work, we need to apply the aspect to
466         # the parent axes.
467         self.apply_aspect()
468 
469         if transform is None:
470             transform = self.transData
471         kwargs.setdefault('label', '_indicate_inset')
472 
473         x, y, width, height = bounds
474         rectangle_patch = mpatches.Rectangle(
475             (x, y), width, height,
476             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
477             zorder=zorder, transform=transform, **kwargs)
478         self.add_patch(rectangle_patch)
479 
480         connects = []
481 
482         if inset_ax is not None:
483             # connect the inset_axes to the rectangle
484             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
485                 # inset_ax positions are in axes coordinates
486                 # The 0, 1 values define the four edges if the inset_ax
487                 # lower_left, upper_left, lower_right upper_right.
488                 ex, ey = xy_inset_ax
489                 if self.xaxis.get_inverted():
490                     ex = 1 - ex
491                 if self.yaxis.get_inverted():
492                     ey = 1 - ey
493                 xy_data = x + ex * width, y + ey * height
494                 p = mpatches.ConnectionPatch(
495                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
496                     xyB=xy_data, coordsB=self.transData,
497                     arrowstyle="-", zorder=zorder,
498                     edgecolor=edgecolor, alpha=alpha)
499                 connects.append(p)
500                 self.add_patch(p)
501 
502             # decide which two of the lines to keep visible....
503             pos = inset_ax.get_position()
504             bboxins = pos.transformed(self.figure.transSubfigure)
505             rectbbox = mtransforms.Bbox.from_bounds(
506                 *bounds
507             ).transformed(transform)
508             x0 = rectbbox.x0 < bboxins.x0
509             x1 = rectbbox.x1 < bboxins.x1
510             y0 = rectbbox.y0 < bboxins.y0
511             y1 = rectbbox.y1 < bboxins.y1
512             connects[0].set_visible(x0 ^ y0)
513             connects[1].set_visible(x0 == y1)
514             connects[2].set_visible(x1 == y0)
515             connects[3].set_visible(x1 ^ y1)
516 
517         return rectangle_patch, tuple(connects) if connects else None
518 
519     def indicate_inset_zoom(self, inset_ax, **kwargs):
520         """
521         Add an inset indicator rectangle to the Axes based on the axis
522         limits for an *inset_ax* and draw connectors between *inset_ax*
523         and the rectangle.
524 
525         Warnings
526         --------
527         This method is experimental as of 3.0, and the API may change.
528 
529         Parameters
530         ----------
531         inset_ax : `.Axes`
532             Inset Axes to draw connecting lines to.  Two lines are
533             drawn connecting the indicator box to the inset Axes on corners
534             chosen so as to not overlap with the indicator box.
535 
536         **kwargs
537             Other keyword arguments are passed on to `.Axes.indicate_inset`
538 
539         Returns
540         -------
541         rectangle_patch : `.patches.Rectangle`
542              Rectangle artist.
543 
544         connector_lines : 4-tuple of `.patches.ConnectionPatch`
545             Each of four connector lines coming from the rectangle drawn on
546             this axis, in the order lower left, upper left, lower right,
547             upper right.
548             Two are set with visibility to *False*,  but the user can
549             set the visibility to *True* if the automatic choice is not deemed
550             correct.
551         """
552 
553         xlim = inset_ax.get_xlim()
554         ylim = inset_ax.get_ylim()
555         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
556         return self.indicate_inset(rect, inset_ax, **kwargs)
557 
558     @_docstring.dedent_interpd
559     def secondary_xaxis(self, location, *, functions=None, **kwargs):
560         """
561         Add a second x-axis to this `~.axes.Axes`.
562 
563         For example if we want to have a second scale for the data plotted on
564         the xaxis.
565 
566         %(_secax_docstring)s
567 
568         Examples
569         --------
570         The main axis shows frequency, and the secondary axis shows period.
571 
572         .. plot::
573 
574             fig, ax = plt.subplots()
575             ax.loglog(range(1, 360, 5), range(1, 360, 5))
576             ax.set_xlabel('frequency [Hz]')
577 
578             def invert(x):
579                 # 1/x with special treatment of x == 0
580                 x = np.array(x).astype(float)
581                 near_zero = np.isclose(x, 0)
582                 x[near_zero] = np.inf
583                 x[~near_zero] = 1 / x[~near_zero]
584                 return x
585 
586             # the inverse of 1/x is itself
587             secax = ax.secondary_xaxis('top', functions=(invert, invert))
588             secax.set_xlabel('Period [s]')
589             plt.show()
590         """
591         if location in ['top', 'bottom'] or isinstance(location, Real):
592             secondary_ax = SecondaryAxis(self, 'x', location, functions,
593                                          **kwargs)
594             self.add_child_axes(secondary_ax)
595             return secondary_ax
596         else:
597             raise ValueError('secondary_xaxis location must be either '
598                              'a float or "top"/"bottom"')
599 
600     @_docstring.dedent_interpd
601     def secondary_yaxis(self, location, *, functions=None, **kwargs):
602         """
603         Add a second y-axis to this `~.axes.Axes`.
604 
605         For example if we want to have a second scale for the data plotted on
606         the yaxis.
607 
608         %(_secax_docstring)s
609 
610         Examples
611         --------
612         Add a secondary Axes that converts from radians to degrees
613 
614         .. plot::
615 
616             fig, ax = plt.subplots()
617             ax.plot(range(1, 360, 5), range(1, 360, 5))
618             ax.set_ylabel('degrees')
619             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
620                                                            np.rad2deg))
621             secax.set_ylabel('radians')
622         """
623         if location in ['left', 'right'] or isinstance(location, Real):
624             secondary_ax = SecondaryAxis(self, 'y', location,
625                                          functions, **kwargs)
626             self.add_child_axes(secondary_ax)
627             return secondary_ax
628         else:
629             raise ValueError('secondary_yaxis location must be either '
630                              'a float or "left"/"right"')
631 
632     @_docstring.dedent_interpd
633     def text(self, x, y, s, fontdict=None, **kwargs):
634         """
635         Add text to the Axes.
636 
637         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
638 
639         Parameters
640         ----------
641         x, y : float
642             The position to place the text. By default, this is in data
643             coordinates. The coordinate system can be changed using the
644             *transform* parameter.
645 
646         s : str
647             The text.
648 
649         fontdict : dict, default: None
650 
651             .. admonition:: Discouraged
652 
653                The use of *fontdict* is discouraged. Parameters should be passed as
654                individual keyword arguments or using dictionary-unpacking
655                ``text(..., **fontdict)``.
656 
657             A dictionary to override the default text properties. If fontdict
658             is None, the defaults are determined by `.rcParams`.
659 
660         Returns
661         -------
662         `.Text`
663             The created `.Text` instance.
664 
665         Other Parameters
666         ----------------
667         **kwargs : `~matplotlib.text.Text` properties.
668             Other miscellaneous text parameters.
669 
670             %(Text:kwdoc)s
671 
672         Examples
673         --------
674         Individual keyword arguments can be used to override any given
675         parameter::
676 
677             >>> text(x, y, s, fontsize=12)
678 
679         The default transform specifies that text is in data coords,
680         alternatively, you can specify text in axis coords ((0, 0) is
681         lower-left and (1, 1) is upper-right).  The example below places
682         text in the center of the Axes::
683 
684             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
685             ...      verticalalignment='center', transform=ax.transAxes)
686 
687         You can put a rectangular box around the text instance (e.g., to
688         set a background color) by using the keyword *bbox*.  *bbox* is
689         a dictionary of `~matplotlib.patches.Rectangle`
690         properties.  For example::
691 
692             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
693         """
694         effective_kwargs = {
695             'verticalalignment': 'baseline',
696             'horizontalalignment': 'left',
697             'transform': self.transData,
698             'clip_on': False,
699             **(fontdict if fontdict is not None else {}),
700             **kwargs,
701         }
702         t = mtext.Text(x, y, text=s, **effective_kwargs)
703         if t.get_clip_path() is None:
704             t.set_clip_path(self.patch)
705         self._add_text(t)
706         return t
707 
708     @_docstring.dedent_interpd
709     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
710                  arrowprops=None, annotation_clip=None, **kwargs):
711         # Signature must match Annotation. This is verified in
712         # test_annotate_signature().
713         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
714                              textcoords=textcoords, arrowprops=arrowprops,
715                              annotation_clip=annotation_clip, **kwargs)
716         a.set_transform(mtransforms.IdentityTransform())
717         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
718             a.set_clip_path(self.patch)
719         self._add_text(a)
720         return a
721     annotate.__doc__ = mtext.Annotation.__init__.__doc__
722     #### Lines and spans
723 
724     @_docstring.dedent_interpd
725     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
726         """
727         Add a horizontal line across the Axes.
728 
729         Parameters
730         ----------
731         y : float, default: 0
732             y position in data coordinates of the horizontal line.
733 
734         xmin : float, default: 0
735             Should be between 0 and 1, 0 being the far left of the plot, 1 the
736             far right of the plot.
737 
738         xmax : float, default: 1
739             Should be between 0 and 1, 0 being the far left of the plot, 1 the
740             far right of the plot.
741 
742         Returns
743         -------
744         `~matplotlib.lines.Line2D`
745 
746         Other Parameters
747         ----------------
748         **kwargs
749             Valid keyword arguments are `.Line2D` properties, except for
750             'transform':
751 
752             %(Line2D:kwdoc)s
753 
754         See Also
755         --------
756         hlines : Add horizontal lines in data coordinates.
757         axhspan : Add a horizontal span (rectangle) across the axis.
758         axline : Add a line with an arbitrary slope.
759 
760         Examples
761         --------
762         * draw a thick red hline at 'y' = 0 that spans the xrange::
763 
764             >>> axhline(linewidth=4, color='r')
765 
766         * draw a default hline at 'y' = 1 that spans the xrange::
767 
768             >>> axhline(y=1)
769 
770         * draw a default hline at 'y' = .5 that spans the middle half of
771           the xrange::
772 
773             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
774         """
775         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
776         if "transform" in kwargs:
777             raise ValueError("'transform' is not allowed as a keyword "
778                              "argument; axhline generates its own transform.")
779         ymin, ymax = self.get_ybound()
780 
781         # Strip away the units for comparison with non-unitized bounds.
782         yy, = self._process_unit_info([("y", y)], kwargs)
783         scaley = (yy < ymin) or (yy > ymax)
784 
785         trans = self.get_yaxis_transform(which='grid')
786         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
787         self.add_line(l)
788         if scaley:
789             self._request_autoscale_view("y")
790         return l
791 
792     @_docstring.dedent_interpd
793     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
794         """
795         Add a vertical line across the Axes.
796 
797         Parameters
798         ----------
799         x : float, default: 0
800             x position in data coordinates of the vertical line.
801 
802         ymin : float, default: 0
803             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
804             top of the plot.
805 
806         ymax : float, default: 1
807             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
808             top of the plot.
809 
810         Returns
811         -------
812         `~matplotlib.lines.Line2D`
813 
814         Other Parameters
815         ----------------
816         **kwargs
817             Valid keyword arguments are `.Line2D` properties, except for
818             'transform':
819 
820             %(Line2D:kwdoc)s
821 
822         See Also
823         --------
824         vlines : Add vertical lines in data coordinates.
825         axvspan : Add a vertical span (rectangle) across the axis.
826         axline : Add a line with an arbitrary slope.
827 
828         Examples
829         --------
830         * draw a thick red vline at *x* = 0 that spans the yrange::
831 
832             >>> axvline(linewidth=4, color='r')
833 
834         * draw a default vline at *x* = 1 that spans the yrange::
835 
836             >>> axvline(x=1)
837 
838         * draw a default vline at *x* = .5 that spans the middle half of
839           the yrange::
840 
841             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
842         """
843         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
844         if "transform" in kwargs:
845             raise ValueError("'transform' is not allowed as a keyword "
846                              "argument; axvline generates its own transform.")
847         xmin, xmax = self.get_xbound()
848 
849         # Strip away the units for comparison with non-unitized bounds.
850         xx, = self._process_unit_info([("x", x)], kwargs)
851         scalex = (xx < xmin) or (xx > xmax)
852 
853         trans = self.get_xaxis_transform(which='grid')
854         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
855         self.add_line(l)
856         if scalex:
857             self._request_autoscale_view("x")
858         return l
859 
860     @staticmethod
861     def _check_no_units(vals, names):
862         # Helper method to check that vals are not unitized
863         for val, name in zip(vals, names):
864             if not munits._is_natively_supported(val):
865                 raise ValueError(f"{name} must be a single scalar value, "
866                                  f"but got {val}")
867 
868     @_docstring.dedent_interpd
869     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
870         """
871         Add an infinitely long straight line.
872 
873         The line can be defined either by two points *xy1* and *xy2*, or
874         by one point *xy1* and a *slope*.
875 
876         This draws a straight line "on the screen", regardless of the x and y
877         scales, and is thus also suitable for drawing exponential decays in
878         semilog plots, power laws in loglog plots, etc. However, *slope*
879         should only be used with linear scales; It has no clear meaning for
880         all other scales, and thus the behavior is undefined. Please specify
881         the line using the points *xy1*, *xy2* for non-linear scales.
882 
883         The *transform* keyword argument only applies to the points *xy1*,
884         *xy2*. The *slope* (if given) is always in data coordinates. This can
885         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
886         slope.
887 
888         Parameters
889         ----------
890         xy1, xy2 : (float, float)
891             Points for the line to pass through.
892             Either *xy2* or *slope* has to be given.
893         slope : float, optional
894             The slope of the line. Either *xy2* or *slope* has to be given.
895 
896         Returns
897         -------
898         `.Line2D`
899 
900         Other Parameters
901         ----------------
902         **kwargs
903             Valid kwargs are `.Line2D` properties
904 
905             %(Line2D:kwdoc)s
906 
907         See Also
908         --------
909         axhline : for horizontal lines
910         axvline : for vertical lines
911 
912         Examples
913         --------
914         Draw a thick red line passing through (0, 0) and (1, 1)::
915 
916             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
917         """
918         if slope is not None and (self.get_xscale() != 'linear' or
919                                   self.get_yscale() != 'linear'):
920             raise TypeError("'slope' cannot be used with non-linear scales")
921 
922         datalim = [xy1] if xy2 is None else [xy1, xy2]
923         if "transform" in kwargs:
924             # if a transform is passed (i.e. line points not in data space),
925             # data limits should not be adjusted.
926             datalim = []
927 
928         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
929         # Like add_line, but correctly handling data limits.
930         self._set_artist_props(line)
931         if line.get_clip_path() is None:
932             line.set_clip_path(self.patch)
933         if not line.get_label():
934             line.set_label(f"_child{len(self._children)}")
935         self._children.append(line)
936         line._remove_method = self._children.remove
937         self.update_datalim(datalim)
938 
939         self._request_autoscale_view()
940         return line
941 
942     @_docstring.dedent_interpd
943     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
944         """
945         Add a horizontal span (rectangle) across the Axes.
946 
947         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
948         the whole x-axis horizontally.  The x-span can be set using *xmin*
949         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
950         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
951         the limits set by `~.Axes.set_xlim`.
952 
953         Parameters
954         ----------
955         ymin : float
956             Lower y-coordinate of the span, in data units.
957         ymax : float
958             Upper y-coordinate of the span, in data units.
959         xmin : float, default: 0
960             Lower x-coordinate of the span, in x-axis (0-1) units.
961         xmax : float, default: 1
962             Upper x-coordinate of the span, in x-axis (0-1) units.
963 
964         Returns
965         -------
966         `~matplotlib.patches.Polygon`
967             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
968 
969         Other Parameters
970         ----------------
971         **kwargs : `~matplotlib.patches.Polygon` properties
972 
973         %(Polygon:kwdoc)s
974 
975         See Also
976         --------
977         axvspan : Add a vertical span across the Axes.
978         """
979         # Strip units away.
980         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
981         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
982 
983         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
984         p = mpatches.Polygon(verts, **kwargs)
985         p.set_transform(self.get_yaxis_transform(which="grid"))
986         self.add_patch(p)
987         self._request_autoscale_view("y")
988         return p
989 
990     @_docstring.dedent_interpd
991     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
992         """
993         Add a vertical span (rectangle) across the Axes.
994 
995         The rectangle spans from *xmin* to *xmax* horizontally, and, by
996         default, the whole y-axis vertically.  The y-span can be set using
997         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
998         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
999         regardless of the limits set by `~.Axes.set_ylim`.
1000 
1001         Parameters
1002         ----------
1003         xmin : float
1004             Lower x-coordinate of the span, in data units.
1005         xmax : float
1006             Upper x-coordinate of the span, in data units.
1007         ymin : float, default: 0
1008             Lower y-coordinate of the span, in y-axis units (0-1).
1009         ymax : float, default: 1
1010             Upper y-coordinate of the span, in y-axis units (0-1).
1011 
1012         Returns
1013         -------
1014         `~matplotlib.patches.Polygon`
1015             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1016 
1017         Other Parameters
1018         ----------------
1019         **kwargs : `~matplotlib.patches.Polygon` properties
1020 
1021         %(Polygon:kwdoc)s
1022 
1023         See Also
1024         --------
1025         axhspan : Add a horizontal span across the Axes.
1026 
1027         Examples
1028         --------
1029         Draw a vertical, green, translucent rectangle from x = 1.25 to
1030         x = 1.55 that spans the yrange of the Axes.
1031 
1032         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1033 
1034         """
1035         # Strip units away.
1036         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1037         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1038 
1039         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1040         p = mpatches.Polygon(verts, **kwargs)
1041         p.set_transform(self.get_xaxis_transform(which="grid"))
1042         p.get_path()._interpolation_steps = 100
1043         self.add_patch(p)
1044         self._request_autoscale_view("x")
1045         return p
1046 
1047     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1048                       label_namer="y")
1049     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1050                label='', **kwargs):
1051         """
1052         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1053 
1054         Parameters
1055         ----------
1056         y : float or array-like
1057             y-indexes where to plot the lines.
1058 
1059         xmin, xmax : float or array-like
1060             Respective beginning and end of each line. If scalars are
1061             provided, all lines will have the same length.
1062 
1063         colors : color or list of colors, default: :rc:`lines.color`
1064 
1065         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1066 
1067         label : str, default: ''
1068 
1069         Returns
1070         -------
1071         `~matplotlib.collections.LineCollection`
1072 
1073         Other Parameters
1074         ----------------
1075         data : indexable object, optional
1076             DATA_PARAMETER_PLACEHOLDER
1077         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1078 
1079         See Also
1080         --------
1081         vlines : vertical lines
1082         axhline : horizontal line across the Axes
1083         """
1084 
1085         # We do the conversion first since not all unitized data is uniform
1086         xmin, xmax, y = self._process_unit_info(
1087             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1088 
1089         if not np.iterable(y):
1090             y = [y]
1091         if not np.iterable(xmin):
1092             xmin = [xmin]
1093         if not np.iterable(xmax):
1094             xmax = [xmax]
1095 
1096         # Create and combine masked_arrays from input
1097         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1098         y = np.ravel(y)
1099         xmin = np.ravel(xmin)
1100         xmax = np.ravel(xmax)
1101 
1102         masked_verts = np.ma.empty((len(y), 2, 2))
1103         masked_verts[:, 0, 0] = xmin
1104         masked_verts[:, 0, 1] = y
1105         masked_verts[:, 1, 0] = xmax
1106         masked_verts[:, 1, 1] = y
1107 
1108         lines = mcoll.LineCollection(masked_verts, colors=colors,
1109                                      linestyles=linestyles, label=label)
1110         self.add_collection(lines, autolim=False)
1111         lines._internal_update(kwargs)
1112 
1113         if len(y) > 0:
1114             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1115             # the case of y being a masked *object* array (as can be generated
1116             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1117             updatex = True
1118             updatey = True
1119             if self.name == "rectilinear":
1120                 datalim = lines.get_datalim(self.transData)
1121                 t = lines.get_transform()
1122                 updatex, updatey = t.contains_branch_seperately(self.transData)
1123                 minx = np.nanmin(datalim.xmin)
1124                 maxx = np.nanmax(datalim.xmax)
1125                 miny = np.nanmin(datalim.ymin)
1126                 maxy = np.nanmax(datalim.ymax)
1127             else:
1128                 minx = np.nanmin(masked_verts[..., 0])
1129                 maxx = np.nanmax(masked_verts[..., 0])
1130                 miny = np.nanmin(masked_verts[..., 1])
1131                 maxy = np.nanmax(masked_verts[..., 1])
1132 
1133             corners = (minx, miny), (maxx, maxy)
1134             self.update_datalim(corners, updatex, updatey)
1135             self._request_autoscale_view()
1136         return lines
1137 
1138     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1139                       label_namer="x")
1140     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1141                label='', **kwargs):
1142         """
1143         Plot vertical lines at each *x* from *ymin* to *ymax*.
1144 
1145         Parameters
1146         ----------
1147         x : float or array-like
1148             x-indexes where to plot the lines.
1149 
1150         ymin, ymax : float or array-like
1151             Respective beginning and end of each line. If scalars are
1152             provided, all lines will have the same length.
1153 
1154         colors : color or list of colors, default: :rc:`lines.color`
1155 
1156         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1157 
1158         label : str, default: ''
1159 
1160         Returns
1161         -------
1162         `~matplotlib.collections.LineCollection`
1163 
1164         Other Parameters
1165         ----------------
1166         data : indexable object, optional
1167             DATA_PARAMETER_PLACEHOLDER
1168         **kwargs : `~matplotlib.collections.LineCollection` properties.
1169 
1170         See Also
1171         --------
1172         hlines : horizontal lines
1173         axvline : vertical line across the Axes
1174         """
1175 
1176         # We do the conversion first since not all unitized data is uniform
1177         x, ymin, ymax = self._process_unit_info(
1178             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1179 
1180         if not np.iterable(x):
1181             x = [x]
1182         if not np.iterable(ymin):
1183             ymin = [ymin]
1184         if not np.iterable(ymax):
1185             ymax = [ymax]
1186 
1187         # Create and combine masked_arrays from input
1188         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1189         x = np.ravel(x)
1190         ymin = np.ravel(ymin)
1191         ymax = np.ravel(ymax)
1192 
1193         masked_verts = np.ma.empty((len(x), 2, 2))
1194         masked_verts[:, 0, 0] = x
1195         masked_verts[:, 0, 1] = ymin
1196         masked_verts[:, 1, 0] = x
1197         masked_verts[:, 1, 1] = ymax
1198 
1199         lines = mcoll.LineCollection(masked_verts, colors=colors,
1200                                      linestyles=linestyles, label=label)
1201         self.add_collection(lines, autolim=False)
1202         lines._internal_update(kwargs)
1203 
1204         if len(x) > 0:
1205             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1206             # the case of x being a masked *object* array (as can be generated
1207             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1208             updatex = True
1209             updatey = True
1210             if self.name == "rectilinear":
1211                 datalim = lines.get_datalim(self.transData)
1212                 t = lines.get_transform()
1213                 updatex, updatey = t.contains_branch_seperately(self.transData)
1214                 minx = np.nanmin(datalim.xmin)
1215                 maxx = np.nanmax(datalim.xmax)
1216                 miny = np.nanmin(datalim.ymin)
1217                 maxy = np.nanmax(datalim.ymax)
1218             else:
1219                 minx = np.nanmin(masked_verts[..., 0])
1220                 maxx = np.nanmax(masked_verts[..., 0])
1221                 miny = np.nanmin(masked_verts[..., 1])
1222                 maxy = np.nanmax(masked_verts[..., 1])
1223 
1224             corners = (minx, miny), (maxx, maxy)
1225             self.update_datalim(corners, updatex, updatey)
1226             self._request_autoscale_view()
1227         return lines
1228 
1229     @_preprocess_data(replace_names=["positions", "lineoffsets",
1230                                      "linelengths", "linewidths",
1231                                      "colors", "linestyles"])
1232     @_docstring.dedent_interpd
1233     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1234                   linelengths=1, linewidths=None, colors=None, alpha=None,
1235                   linestyles='solid', **kwargs):
1236         """
1237         Plot identical parallel lines at the given positions.
1238 
1239         This type of plot is commonly used in neuroscience for representing
1240         neural events, where it is usually called a spike raster, dot raster,
1241         or raster plot.
1242 
1243         However, it is useful in any situation where you wish to show the
1244         timing or position of multiple sets of discrete events, such as the
1245         arrival times of people to a business on each day of the month or the
1246         date of hurricanes each year of the last century.
1247 
1248         Parameters
1249         ----------
1250         positions : array-like or list of array-like
1251             A 1D array-like defines the positions of one sequence of events.
1252 
1253             Multiple groups of events may be passed as a list of array-likes.
1254             Each group can be styled independently by passing lists of values
1255             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1256             *linestyles*.
1257 
1258             Note that *positions* can be a 2D array, but in practice different
1259             event groups usually have different counts so that one will use a
1260             list of different-length arrays rather than a 2D array.
1261 
1262         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1263             The direction of the event sequence:
1264 
1265             - 'horizontal': the events are arranged horizontally.
1266               The indicator lines are vertical.
1267             - 'vertical': the events are arranged vertically.
1268               The indicator lines are horizontal.
1269 
1270         lineoffsets : float or array-like, default: 1
1271             The offset of the center of the lines from the origin, in the
1272             direction orthogonal to *orientation*.
1273 
1274             If *positions* is 2D, this can be a sequence with length matching
1275             the length of *positions*.
1276 
1277         linelengths : float or array-like, default: 1
1278             The total height of the lines (i.e. the lines stretches from
1279             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1280 
1281             If *positions* is 2D, this can be a sequence with length matching
1282             the length of *positions*.
1283 
1284         linewidths : float or array-like, default: :rc:`lines.linewidth`
1285             The line width(s) of the event lines, in points.
1286 
1287             If *positions* is 2D, this can be a sequence with length matching
1288             the length of *positions*.
1289 
1290         colors : color or list of colors, default: :rc:`lines.color`
1291             The color(s) of the event lines.
1292 
1293             If *positions* is 2D, this can be a sequence with length matching
1294             the length of *positions*.
1295 
1296         alpha : float or array-like, default: 1
1297             The alpha blending value(s), between 0 (transparent) and 1
1298             (opaque).
1299 
1300             If *positions* is 2D, this can be a sequence with length matching
1301             the length of *positions*.
1302 
1303         linestyles : str or tuple or list of such values, default: 'solid'
1304             Default is 'solid'. Valid strings are ['solid', 'dashed',
1305             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1306             should be of the form::
1307 
1308                 (offset, onoffseq),
1309 
1310             where *onoffseq* is an even length tuple of on and off ink
1311             in points.
1312 
1313             If *positions* is 2D, this can be a sequence with length matching
1314             the length of *positions*.
1315 
1316         data : indexable object, optional
1317             DATA_PARAMETER_PLACEHOLDER
1318 
1319         **kwargs
1320             Other keyword arguments are line collection properties.  See
1321             `.LineCollection` for a list of the valid properties.
1322 
1323         Returns
1324         -------
1325         list of `.EventCollection`
1326             The `.EventCollection` that were added.
1327 
1328         Notes
1329         -----
1330         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1331         only a single value is given, that value is applied to all lines. If an
1332         array-like is given, it must have the same length as *positions*, and
1333         each value will be applied to the corresponding row of the array.
1334 
1335         Examples
1336         --------
1337         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1338         """
1339 
1340         lineoffsets, linelengths = self._process_unit_info(
1341                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1342 
1343         # fix positions, noting that it can be a list of lists:
1344         if not np.iterable(positions):
1345             positions = [positions]
1346         elif any(np.iterable(position) for position in positions):
1347             positions = [np.asanyarray(position) for position in positions]
1348         else:
1349             positions = [np.asanyarray(positions)]
1350 
1351         poss = []
1352         for position in positions:
1353             poss += self._process_unit_info([("x", position)], kwargs)
1354         positions = poss
1355 
1356         # prevent 'singular' keys from **kwargs dict from overriding the effect
1357         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1358         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1359         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1360         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1361 
1362         if not np.iterable(lineoffsets):
1363             lineoffsets = [lineoffsets]
1364         if not np.iterable(linelengths):
1365             linelengths = [linelengths]
1366         if not np.iterable(linewidths):
1367             linewidths = [linewidths]
1368         if not np.iterable(colors):
1369             colors = [colors]
1370         if not np.iterable(alpha):
1371             alpha = [alpha]
1372         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1373             linestyles = [linestyles]
1374 
1375         lineoffsets = np.asarray(lineoffsets)
1376         linelengths = np.asarray(linelengths)
1377         linewidths = np.asarray(linewidths)
1378 
1379         if len(lineoffsets) == 0:
1380             raise ValueError('lineoffsets cannot be empty')
1381         if len(linelengths) == 0:
1382             raise ValueError('linelengths cannot be empty')
1383         if len(linestyles) == 0:
1384             raise ValueError('linestyles cannot be empty')
1385         if len(linewidths) == 0:
1386             raise ValueError('linewidths cannot be empty')
1387         if len(alpha) == 0:
1388             raise ValueError('alpha cannot be empty')
1389         if len(colors) == 0:
1390             colors = [None]
1391         try:
1392             # Early conversion of the colors into RGBA values to take care
1393             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1394             colors = mcolors.to_rgba_array(colors)
1395         except ValueError:
1396             # Will fail if any element of *colors* is None. But as long
1397             # as len(colors) == 1 or len(positions), the rest of the
1398             # code should process *colors* properly.
1399             pass
1400 
1401         if len(lineoffsets) == 1 and len(positions) != 1:
1402             lineoffsets = np.tile(lineoffsets, len(positions))
1403             lineoffsets[0] = 0
1404             lineoffsets = np.cumsum(lineoffsets)
1405         if len(linelengths) == 1:
1406             linelengths = np.tile(linelengths, len(positions))
1407         if len(linewidths) == 1:
1408             linewidths = np.tile(linewidths, len(positions))
1409         if len(colors) == 1:
1410             colors = list(colors) * len(positions)
1411         if len(alpha) == 1:
1412             alpha = list(alpha) * len(positions)
1413         if len(linestyles) == 1:
1414             linestyles = [linestyles] * len(positions)
1415 
1416         if len(lineoffsets) != len(positions):
1417             raise ValueError('lineoffsets and positions are unequal sized '
1418                              'sequences')
1419         if len(linelengths) != len(positions):
1420             raise ValueError('linelengths and positions are unequal sized '
1421                              'sequences')
1422         if len(linewidths) != len(positions):
1423             raise ValueError('linewidths and positions are unequal sized '
1424                              'sequences')
1425         if len(colors) != len(positions):
1426             raise ValueError('colors and positions are unequal sized '
1427                              'sequences')
1428         if len(alpha) != len(positions):
1429             raise ValueError('alpha and positions are unequal sized '
1430                              'sequences')
1431         if len(linestyles) != len(positions):
1432             raise ValueError('linestyles and positions are unequal sized '
1433                              'sequences')
1434 
1435         colls = []
1436         for position, lineoffset, linelength, linewidth, color, alpha_, \
1437             linestyle in \
1438                 zip(positions, lineoffsets, linelengths, linewidths,
1439                     colors, alpha, linestyles):
1440             coll = mcoll.EventCollection(position,
1441                                          orientation=orientation,
1442                                          lineoffset=lineoffset,
1443                                          linelength=linelength,
1444                                          linewidth=linewidth,
1445                                          color=color,
1446                                          alpha=alpha_,
1447                                          linestyle=linestyle)
1448             self.add_collection(coll, autolim=False)
1449             coll._internal_update(kwargs)
1450             colls.append(coll)
1451 
1452         if len(positions) > 0:
1453             # try to get min/max
1454             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1455                        if len(_p) > 0]
1456             # if we have any non-empty positions, try to autoscale
1457             if len(min_max) > 0:
1458                 mins, maxes = zip(*min_max)
1459                 minpos = np.min(mins)
1460                 maxpos = np.max(maxes)
1461 
1462                 minline = (lineoffsets - linelengths).min()
1463                 maxline = (lineoffsets + linelengths).max()
1464 
1465                 if orientation == "vertical":
1466                     corners = (minline, minpos), (maxline, maxpos)
1467                 else:  # "horizontal"
1468                     corners = (minpos, minline), (maxpos, maxline)
1469                 self.update_datalim(corners)
1470                 self._request_autoscale_view()
1471 
1472         return colls
1473 
1474     #### Basic plotting
1475 
1476     # Uses a custom implementation of data-kwarg handling in
1477     # _process_plot_var_args.
1478     @_docstring.dedent_interpd
1479     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1480         """
1481         Plot y versus x as lines and/or markers.
1482 
1483         Call signatures::
1484 
1485             plot([x], y, [fmt], *, data=None, **kwargs)
1486             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1487 
1488         The coordinates of the points or line nodes are given by *x*, *y*.
1489 
1490         The optional parameter *fmt* is a convenient way for defining basic
1491         formatting like color, marker and linestyle. It's a shortcut string
1492         notation described in the *Notes* section below.
1493 
1494         >>> plot(x, y)        # plot x and y using default line style and color
1495         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1496         >>> plot(y)           # plot y using x as index array 0..N-1
1497         >>> plot(y, 'r+')     # ditto, but with red plusses
1498 
1499         You can use `.Line2D` properties as keyword arguments for more
1500         control on the appearance. Line properties and *fmt* can be mixed.
1501         The following two calls yield identical results:
1502 
1503         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1504         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1505         ...      linewidth=2, markersize=12)
1506 
1507         When conflicting with *fmt*, keyword arguments take precedence.
1508 
1509 
1510         **Plotting labelled data**
1511 
1512         There's a convenient way for plotting objects with labelled data (i.e.
1513         data that can be accessed by index ``obj['y']``). Instead of giving
1514         the data in *x* and *y*, you can provide the object in the *data*
1515         parameter and just give the labels for *x* and *y*::
1516 
1517         >>> plot('xlabel', 'ylabel', data=obj)
1518 
1519         All indexable objects are supported. This could e.g. be a `dict`, a
1520         `pandas.DataFrame` or a structured numpy array.
1521 
1522 
1523         **Plotting multiple sets of data**
1524 
1525         There are various ways to plot multiple sets of data.
1526 
1527         - The most straight forward way is just to call `plot` multiple times.
1528           Example:
1529 
1530           >>> plot(x1, y1, 'bo')
1531           >>> plot(x2, y2, 'go')
1532 
1533         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1534           for every column. If both *x* and *y* are 2D, they must have the
1535           same shape. If only one of them is 2D with shape (N, m) the other
1536           must have length N and will be used for every data set m.
1537 
1538           Example:
1539 
1540           >>> x = [1, 2, 3]
1541           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1542           >>> plot(x, y)
1543 
1544           is equivalent to:
1545 
1546           >>> for col in range(y.shape[1]):
1547           ...     plot(x, y[:, col])
1548 
1549         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1550           groups::
1551 
1552           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1553 
1554           In this case, any additional keyword argument applies to all
1555           datasets. Also, this syntax cannot be combined with the *data*
1556           parameter.
1557 
1558         By default, each line is assigned a different style specified by a
1559         'style cycle'. The *fmt* and line property parameters are only
1560         necessary if you want explicit deviations from these defaults.
1561         Alternatively, you can also change the style cycle using
1562         :rc:`axes.prop_cycle`.
1563 
1564 
1565         Parameters
1566         ----------
1567         x, y : array-like or scalar
1568             The horizontal / vertical coordinates of the data points.
1569             *x* values are optional and default to ``range(len(y))``.
1570 
1571             Commonly, these parameters are 1D arrays.
1572 
1573             They can also be scalars, or two-dimensional (in that case, the
1574             columns represent separate data sets).
1575 
1576             These arguments cannot be passed as keywords.
1577 
1578         fmt : str, optional
1579             A format string, e.g. 'ro' for red circles. See the *Notes*
1580             section for a full description of the format strings.
1581 
1582             Format strings are just an abbreviation for quickly setting
1583             basic line properties. All of these and more can also be
1584             controlled by keyword arguments.
1585 
1586             This argument cannot be passed as keyword.
1587 
1588         data : indexable object, optional
1589             An object with labelled data. If given, provide the label names to
1590             plot in *x* and *y*.
1591 
1592             .. note::
1593                 Technically there's a slight ambiguity in calls where the
1594                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1595                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1596                 the former interpretation is chosen, but a warning is issued.
1597                 You may suppress the warning by adding an empty format string
1598                 ``plot('n', 'o', '', data=obj)``.
1599 
1600         Returns
1601         -------
1602         list of `.Line2D`
1603             A list of lines representing the plotted data.
1604 
1605         Other Parameters
1606         ----------------
1607         scalex, scaley : bool, default: True
1608             These parameters determine if the view limits are adapted to the
1609             data limits. The values are passed on to
1610             `~.axes.Axes.autoscale_view`.
1611 
1612         **kwargs : `.Line2D` properties, optional
1613             *kwargs* are used to specify properties like a line label (for
1614             auto legends), linewidth, antialiasing, marker face color.
1615             Example::
1616 
1617             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1618             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1619 
1620             If you specify multiple lines with one plot call, the kwargs apply
1621             to all those lines. In case the label object is iterable, each
1622             element is used as labels for each set of data.
1623 
1624             Here is a list of available `.Line2D` properties:
1625 
1626             %(Line2D:kwdoc)s
1627 
1628         See Also
1629         --------
1630         scatter : XY scatter plot with markers of varying size and/or color (
1631             sometimes also called bubble chart).
1632 
1633         Notes
1634         -----
1635         **Format Strings**
1636 
1637         A format string consists of a part for color, marker and line::
1638 
1639             fmt = '[marker][line][color]'
1640 
1641         Each of them is optional. If not provided, the value from the style
1642         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1643         the data will be a line without markers.
1644 
1645         Other combinations such as ``[color][marker][line]`` are also
1646         supported, but note that their parsing may be ambiguous.
1647 
1648         **Markers**
1649 
1650         =============   ===============================
1651         character       description
1652         =============   ===============================
1653         ``'.'``         point marker
1654         ``','``         pixel marker
1655         ``'o'``         circle marker
1656         ``'v'``         triangle_down marker
1657         ``'^'``         triangle_up marker
1658         ``'<'``         triangle_left marker
1659         ``'>'``         triangle_right marker
1660         ``'1'``         tri_down marker
1661         ``'2'``         tri_up marker
1662         ``'3'``         tri_left marker
1663         ``'4'``         tri_right marker
1664         ``'8'``         octagon marker
1665         ``'s'``         square marker
1666         ``'p'``         pentagon marker
1667         ``'P'``         plus (filled) marker
1668         ``'*'``         star marker
1669         ``'h'``         hexagon1 marker
1670         ``'H'``         hexagon2 marker
1671         ``'+'``         plus marker
1672         ``'x'``         x marker
1673         ``'X'``         x (filled) marker
1674         ``'D'``         diamond marker
1675         ``'d'``         thin_diamond marker
1676         ``'|'``         vline marker
1677         ``'_'``         hline marker
1678         =============   ===============================
1679 
1680         **Line Styles**
1681 
1682         =============    ===============================
1683         character        description
1684         =============    ===============================
1685         ``'-'``          solid line style
1686         ``'--'``         dashed line style
1687         ``'-.'``         dash-dot line style
1688         ``':'``          dotted line style
1689         =============    ===============================
1690 
1691         Example format strings::
1692 
1693             'b'    # blue markers with default shape
1694             'or'   # red circles
1695             '-g'   # green solid line
1696             '--'   # dashed line with default color
1697             '^k:'  # black triangle_up markers connected by a dotted line
1698 
1699         **Colors**
1700 
1701         The supported color abbreviations are the single letter codes
1702 
1703         =============    ===============================
1704         character        color
1705         =============    ===============================
1706         ``'b'``          blue
1707         ``'g'``          green
1708         ``'r'``          red
1709         ``'c'``          cyan
1710         ``'m'``          magenta
1711         ``'y'``          yellow
1712         ``'k'``          black
1713         ``'w'``          white
1714         =============    ===============================
1715 
1716         and the ``'CN'`` colors that index into the default property cycle.
1717 
1718         If the color is the only part of the format string, you can
1719         additionally use any  `matplotlib.colors` spec, e.g. full names
1720         (``'green'``) or hex strings (``'#008000'``).
1721         """
1722         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1723         lines = [*self._get_lines(*args, data=data, **kwargs)]
1724         for line in lines:
1725             self.add_line(line)
1726         if scalex:
1727             self._request_autoscale_view("x")
1728         if scaley:
1729             self._request_autoscale_view("y")
1730         return lines
1731 
1732     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1733     @_docstring.dedent_interpd
1734     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1735                   **kwargs):
1736         """
1737         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1738 
1739         .. admonition:: Discouraged
1740 
1741             This method exists for historic reasons and will be deprecated in
1742             the future.
1743 
1744             - ``datetime``-like data should directly be plotted using
1745               `~.Axes.plot`.
1746             -  If you need to plot plain numeric data as :ref:`date-format` or
1747                need to set a timezone, call ``ax.xaxis.axis_date`` /
1748                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1749                `.Axis.axis_date`.
1750 
1751         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1752         However, the axis labels are formatted as dates depending on *xdate*
1753         and *ydate*.  Note that `.plot` will work with `datetime` and
1754         `numpy.datetime64` objects without resorting to this method.
1755 
1756         Parameters
1757         ----------
1758         x, y : array-like
1759             The coordinates of the data points. If *xdate* or *ydate* is
1760             *True*, the respective values *x* or *y* are interpreted as
1761             :ref:`Matplotlib dates <date-format>`.
1762 
1763         fmt : str, optional
1764             The plot format string. For details, see the corresponding
1765             parameter in `.plot`.
1766 
1767         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1768             The time zone to use in labeling dates.
1769 
1770         xdate : bool, default: True
1771             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1772 
1773         ydate : bool, default: False
1774             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1775 
1776         Returns
1777         -------
1778         list of `.Line2D`
1779             Objects representing the plotted data.
1780 
1781         Other Parameters
1782         ----------------
1783         data : indexable object, optional
1784             DATA_PARAMETER_PLACEHOLDER
1785         **kwargs
1786             Keyword arguments control the `.Line2D` properties:
1787 
1788             %(Line2D:kwdoc)s
1789 
1790         See Also
1791         --------
1792         matplotlib.dates : Helper functions on dates.
1793         matplotlib.dates.date2num : Convert dates to num.
1794         matplotlib.dates.num2date : Convert num to dates.
1795         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1796 
1797         Notes
1798         -----
1799         If you are using custom date tickers and formatters, it may be
1800         necessary to set the formatters/locators after the call to
1801         `.plot_date`. `.plot_date` will set the default tick locator to
1802         `.AutoDateLocator` (if the tick locator is not already set to a
1803         `.DateLocator` instance) and the default tick formatter to
1804         `.AutoDateFormatter` (if the tick formatter is not already set to a
1805         `.DateFormatter` instance).
1806         """
1807         if xdate:
1808             self.xaxis_date(tz)
1809         if ydate:
1810             self.yaxis_date(tz)
1811         return self.plot(x, y, fmt, **kwargs)
1812 
1813     # @_preprocess_data() # let 'plot' do the unpacking..
1814     @_docstring.dedent_interpd
1815     def loglog(self, *args, **kwargs):
1816         """
1817         Make a plot with log scaling on both the x- and y-axis.
1818 
1819         Call signatures::
1820 
1821             loglog([x], y, [fmt], data=None, **kwargs)
1822             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1823 
1824         This is just a thin wrapper around `.plot` which additionally changes
1825         both the x-axis and the y-axis to log scaling. All the concepts and
1826         parameters of plot can be used here as well.
1827 
1828         The additional parameters *base*, *subs* and *nonpositive* control the
1829         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1830         `.Axes.set_yscale`. To use different properties on the x-axis and the
1831         y-axis, use e.g.
1832         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1833 
1834         Parameters
1835         ----------
1836         base : float, default: 10
1837             Base of the logarithm.
1838 
1839         subs : sequence, optional
1840             The location of the minor ticks. If *None*, reasonable locations
1841             are automatically chosen depending on the number of decades in the
1842             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1843 
1844         nonpositive : {'mask', 'clip'}, default: 'clip'
1845             Non-positive values can be masked as invalid, or clipped to a very
1846             small positive number.
1847 
1848         **kwargs
1849             All parameters supported by `.plot`.
1850 
1851         Returns
1852         -------
1853         list of `.Line2D`
1854             Objects representing the plotted data.
1855         """
1856         dx = {k: v for k, v in kwargs.items()
1857               if k in ['base', 'subs', 'nonpositive',
1858                        'basex', 'subsx', 'nonposx']}
1859         self.set_xscale('log', **dx)
1860         dy = {k: v for k, v in kwargs.items()
1861               if k in ['base', 'subs', 'nonpositive',
1862                        'basey', 'subsy', 'nonposy']}
1863         self.set_yscale('log', **dy)
1864         return self.plot(
1865             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1866 
1867     # @_preprocess_data() # let 'plot' do the unpacking..
1868     @_docstring.dedent_interpd
1869     def semilogx(self, *args, **kwargs):
1870         """
1871         Make a plot with log scaling on the x-axis.
1872 
1873         Call signatures::
1874 
1875             semilogx([x], y, [fmt], data=None, **kwargs)
1876             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1877 
1878         This is just a thin wrapper around `.plot` which additionally changes
1879         the x-axis to log scaling. All the concepts and parameters of plot can
1880         be used here as well.
1881 
1882         The additional parameters *base*, *subs*, and *nonpositive* control the
1883         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1884 
1885         Parameters
1886         ----------
1887         base : float, default: 10
1888             Base of the x logarithm.
1889 
1890         subs : array-like, optional
1891             The location of the minor xticks. If *None*, reasonable locations
1892             are automatically chosen depending on the number of decades in the
1893             plot. See `.Axes.set_xscale` for details.
1894 
1895         nonpositive : {'mask', 'clip'}, default: 'mask'
1896             Non-positive values in x can be masked as invalid, or clipped to a
1897             very small positive number.
1898 
1899         **kwargs
1900             All parameters supported by `.plot`.
1901 
1902         Returns
1903         -------
1904         list of `.Line2D`
1905             Objects representing the plotted data.
1906         """
1907         d = {k: v for k, v in kwargs.items()
1908              if k in ['base', 'subs', 'nonpositive',
1909                       'basex', 'subsx', 'nonposx']}
1910         self.set_xscale('log', **d)
1911         return self.plot(
1912             *args, **{k: v for k, v in kwargs.items() if k not in d})
1913 
1914     # @_preprocess_data() # let 'plot' do the unpacking..
1915     @_docstring.dedent_interpd
1916     def semilogy(self, *args, **kwargs):
1917         """
1918         Make a plot with log scaling on the y-axis.
1919 
1920         Call signatures::
1921 
1922             semilogy([x], y, [fmt], data=None, **kwargs)
1923             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1924 
1925         This is just a thin wrapper around `.plot` which additionally changes
1926         the y-axis to log scaling. All the concepts and parameters of plot can
1927         be used here as well.
1928 
1929         The additional parameters *base*, *subs*, and *nonpositive* control the
1930         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1931 
1932         Parameters
1933         ----------
1934         base : float, default: 10
1935             Base of the y logarithm.
1936 
1937         subs : array-like, optional
1938             The location of the minor yticks. If *None*, reasonable locations
1939             are automatically chosen depending on the number of decades in the
1940             plot. See `.Axes.set_yscale` for details.
1941 
1942         nonpositive : {'mask', 'clip'}, default: 'mask'
1943             Non-positive values in y can be masked as invalid, or clipped to a
1944             very small positive number.
1945 
1946         **kwargs
1947             All parameters supported by `.plot`.
1948 
1949         Returns
1950         -------
1951         list of `.Line2D`
1952             Objects representing the plotted data.
1953         """
1954         d = {k: v for k, v in kwargs.items()
1955              if k in ['base', 'subs', 'nonpositive',
1956                       'basey', 'subsy', 'nonposy']}
1957         self.set_yscale('log', **d)
1958         return self.plot(
1959             *args, **{k: v for k, v in kwargs.items() if k not in d})
1960 
1961     @_preprocess_data(replace_names=["x"], label_namer="x")
1962     def acorr(self, x, **kwargs):
1963         """
1964         Plot the autocorrelation of *x*.
1965 
1966         Parameters
1967         ----------
1968         x : array-like
1969 
1970         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1971             A detrending function applied to *x*.  It must have the
1972             signature ::
1973 
1974                 detrend(x: np.ndarray) -> np.ndarray
1975 
1976         normed : bool, default: True
1977             If ``True``, input vectors are normalised to unit length.
1978 
1979         usevlines : bool, default: True
1980             Determines the plot style.
1981 
1982             If ``True``, vertical lines are plotted from 0 to the acorr value
1983             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1984             at y=0 using `.Axes.axhline`.
1985 
1986             If ``False``, markers are plotted at the acorr values using
1987             `.Axes.plot`.
1988 
1989         maxlags : int, default: 10
1990             Number of lags to show. If ``None``, will return all
1991             ``2 * len(x) - 1`` lags.
1992 
1993         Returns
1994         -------
1995         lags : array (length ``2*maxlags+1``)
1996             The lag vector.
1997         c : array  (length ``2*maxlags+1``)
1998             The auto correlation vector.
1999         line : `.LineCollection` or `.Line2D`
2000             `.Artist` added to the Axes of the correlation:
2001 
2002             - `.LineCollection` if *usevlines* is True.
2003             - `.Line2D` if *usevlines* is False.
2004         b : `.Line2D` or None
2005             Horizontal line at 0 if *usevlines* is True
2006             None *usevlines* is False.
2007 
2008         Other Parameters
2009         ----------------
2010         linestyle : `.Line2D` property, optional
2011             The linestyle for plotting the data points.
2012             Only used if *usevlines* is ``False``.
2013 
2014         marker : str, default: 'o'
2015             The marker for plotting the data points.
2016             Only used if *usevlines* is ``False``.
2017 
2018         data : indexable object, optional
2019             DATA_PARAMETER_PLACEHOLDER
2020 
2021         **kwargs
2022             Additional parameters are passed to `.Axes.vlines` and
2023             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2024             passed to `.Axes.plot`.
2025 
2026         Notes
2027         -----
2028         The cross correlation is performed with `numpy.correlate` with
2029         ``mode = "full"``.
2030         """
2031         return self.xcorr(x, x, **kwargs)
2032 
2033     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2034     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2035               usevlines=True, maxlags=10, **kwargs):
2036         r"""
2037         Plot the cross correlation between *x* and *y*.
2038 
2039         The correlation with lag k is defined as
2040         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2041         conjugate of :math:`y`.
2042 
2043         Parameters
2044         ----------
2045         x, y : array-like of length n
2046 
2047         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2048             A detrending function applied to *x* and *y*.  It must have the
2049             signature ::
2050 
2051                 detrend(x: np.ndarray) -> np.ndarray
2052 
2053         normed : bool, default: True
2054             If ``True``, input vectors are normalised to unit length.
2055 
2056         usevlines : bool, default: True
2057             Determines the plot style.
2058 
2059             If ``True``, vertical lines are plotted from 0 to the xcorr value
2060             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2061             at y=0 using `.Axes.axhline`.
2062 
2063             If ``False``, markers are plotted at the xcorr values using
2064             `.Axes.plot`.
2065 
2066         maxlags : int, default: 10
2067             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2068             lags.
2069 
2070         Returns
2071         -------
2072         lags : array (length ``2*maxlags+1``)
2073             The lag vector.
2074         c : array  (length ``2*maxlags+1``)
2075             The auto correlation vector.
2076         line : `.LineCollection` or `.Line2D`
2077             `.Artist` added to the Axes of the correlation:
2078 
2079             - `.LineCollection` if *usevlines* is True.
2080             - `.Line2D` if *usevlines* is False.
2081         b : `.Line2D` or None
2082             Horizontal line at 0 if *usevlines* is True
2083             None *usevlines* is False.
2084 
2085         Other Parameters
2086         ----------------
2087         linestyle : `.Line2D` property, optional
2088             The linestyle for plotting the data points.
2089             Only used if *usevlines* is ``False``.
2090 
2091         marker : str, default: 'o'
2092             The marker for plotting the data points.
2093             Only used if *usevlines* is ``False``.
2094 
2095         data : indexable object, optional
2096             DATA_PARAMETER_PLACEHOLDER
2097 
2098         **kwargs
2099             Additional parameters are passed to `.Axes.vlines` and
2100             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2101             passed to `.Axes.plot`.
2102 
2103         Notes
2104         -----
2105         The cross correlation is performed with `numpy.correlate` with
2106         ``mode = "full"``.
2107         """
2108         Nx = len(x)
2109         if Nx != len(y):
2110             raise ValueError('x and y must be equal length')
2111 
2112         x = detrend(np.asarray(x))
2113         y = detrend(np.asarray(y))
2114 
2115         correls = np.correlate(x, y, mode="full")
2116 
2117         if normed:
2118             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2119 
2120         if maxlags is None:
2121             maxlags = Nx - 1
2122 
2123         if maxlags >= Nx or maxlags < 1:
2124             raise ValueError('maxlags must be None or strictly '
2125                              'positive < %d' % Nx)
2126 
2127         lags = np.arange(-maxlags, maxlags + 1)
2128         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2129 
2130         if usevlines:
2131             a = self.vlines(lags, [0], correls, **kwargs)
2132             # Make label empty so only vertical lines get a legend entry
2133             kwargs.pop('label', '')
2134             b = self.axhline(**kwargs)
2135         else:
2136             kwargs.setdefault('marker', 'o')
2137             kwargs.setdefault('linestyle', 'None')
2138             a, = self.plot(lags, correls, **kwargs)
2139             b = None
2140         return lags, correls, a, b
2141 
2142     #### Specialized plotting
2143 
2144     # @_preprocess_data() # let 'plot' do the unpacking..
2145     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2146         """
2147         Make a step plot.
2148 
2149         Call signatures::
2150 
2151             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2152             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2153 
2154         This is just a thin wrapper around `.plot` which changes some
2155         formatting options. Most of the concepts and parameters of plot can be
2156         used here as well.
2157 
2158         .. note::
2159 
2160             This method uses a standard plot with a step drawstyle: The *x*
2161             values are the reference positions and steps extend left/right/both
2162             directions depending on *where*.
2163 
2164             For the common case where you know the values and edges of the
2165             steps, use `~.Axes.stairs` instead.
2166 
2167         Parameters
2168         ----------
2169         x : array-like
2170             1D sequence of x positions. It is assumed, but not checked, that
2171             it is uniformly increasing.
2172 
2173         y : array-like
2174             1D sequence of y levels.
2175 
2176         fmt : str, optional
2177             A format string, e.g. 'g' for a green line. See `.plot` for a more
2178             detailed description.
2179 
2180             Note: While full format strings are accepted, it is recommended to
2181             only specify the color. Line styles are currently ignored (use
2182             the keyword argument *linestyle* instead). Markers are accepted
2183             and plotted on the given positions, however, this is a rarely
2184             needed feature for step plots.
2185 
2186         where : {'pre', 'post', 'mid'}, default: 'pre'
2187             Define where the steps should be placed:
2188 
2189             - 'pre': The y value is continued constantly to the left from
2190               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2191               value ``y[i]``.
2192             - 'post': The y value is continued constantly to the right from
2193               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2194               value ``y[i]``.
2195             - 'mid': Steps occur half-way between the *x* positions.
2196 
2197         data : indexable object, optional
2198             An object with labelled data. If given, provide the label names to
2199             plot in *x* and *y*.
2200 
2201         **kwargs
2202             Additional parameters are the same as those for `.plot`.
2203 
2204         Returns
2205         -------
2206         list of `.Line2D`
2207             Objects representing the plotted data.
2208         """
2209         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2210         kwargs['drawstyle'] = 'steps-' + where
2211         return self.plot(x, y, *args, data=data, **kwargs)
2212 
2213     @staticmethod
2214     def _convert_dx(dx, x0, xconv, convert):
2215         """
2216         Small helper to do logic of width conversion flexibly.
2217 
2218         *dx* and *x0* have units, but *xconv* has already been converted
2219         to unitless (and is an ndarray).  This allows the *dx* to have units
2220         that are different from *x0*, but are still accepted by the
2221         ``__add__`` operator of *x0*.
2222         """
2223 
2224         # x should be an array...
2225         assert type(xconv) is np.ndarray
2226 
2227         if xconv.size == 0:
2228             # xconv has already been converted, but maybe empty...
2229             return convert(dx)
2230 
2231         try:
2232             # attempt to add the width to x0; this works for
2233             # datetime+timedelta, for instance
2234 
2235             # only use the first element of x and x0.  This saves
2236             # having to be sure addition works across the whole
2237             # vector.  This is particularly an issue if
2238             # x0 and dx are lists so x0 + dx just concatenates the lists.
2239             # We can't just cast x0 and dx to numpy arrays because that
2240             # removes the units from unit packages like `pint` that
2241             # wrap numpy arrays.
2242             try:
2243                 x0 = cbook._safe_first_finite(x0)
2244             except (TypeError, IndexError, KeyError):
2245                 pass
2246 
2247             try:
2248                 x = cbook._safe_first_finite(xconv)
2249             except (TypeError, IndexError, KeyError):
2250                 x = xconv
2251 
2252             delist = False
2253             if not np.iterable(dx):
2254                 dx = [dx]
2255                 delist = True
2256             dx = [convert(x0 + ddx) - x for ddx in dx]
2257             if delist:
2258                 dx = dx[0]
2259         except (ValueError, TypeError, AttributeError):
2260             # if the above fails (for any reason) just fallback to what
2261             # we do by default and convert dx by itself.
2262             dx = convert(dx)
2263         return dx
2264 
2265     @_preprocess_data()
2266     @_docstring.dedent_interpd
2267     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2268             **kwargs):
2269         r"""
2270         Make a bar plot.
2271 
2272         The bars are positioned at *x* with the given *align*\ment. Their
2273         dimensions are given by *height* and *width*. The vertical baseline
2274         is *bottom* (default 0).
2275 
2276         Many parameters can take either a single value applying to all bars
2277         or a sequence of values, one for each bar.
2278 
2279         Parameters
2280         ----------
2281         x : float or array-like
2282             The x coordinates of the bars. See also *align* for the
2283             alignment of the bars to the coordinates.
2284 
2285         height : float or array-like
2286             The height(s) of the bars.
2287 
2288         width : float or array-like, default: 0.8
2289             The width(s) of the bars.
2290 
2291         bottom : float or array-like, default: 0
2292             The y coordinate(s) of the bottom side(s) of the bars.
2293 
2294         align : {'center', 'edge'}, default: 'center'
2295             Alignment of the bars to the *x* coordinates:
2296 
2297             - 'center': Center the base on the *x* positions.
2298             - 'edge': Align the left edges of the bars with the *x* positions.
2299 
2300             To align the bars on the right edge pass a negative *width* and
2301             ``align='edge'``.
2302 
2303         Returns
2304         -------
2305         `.BarContainer`
2306             Container with all the bars and optionally errorbars.
2307 
2308         Other Parameters
2309         ----------------
2310         color : color or list of color, optional
2311             The colors of the bar faces.
2312 
2313         edgecolor : color or list of color, optional
2314             The colors of the bar edges.
2315 
2316         linewidth : float or array-like, optional
2317             Width of the bar edge(s). If 0, don't draw edges.
2318 
2319         tick_label : str or list of str, optional
2320             The tick labels of the bars.
2321             Default: None (Use default numeric labels.)
2322 
2323         label : str or list of str, optional
2324             A single label is attached to the resulting `.BarContainer` as a
2325             label for the whole dataset.
2326             If a list is provided, it must be the same length as *x* and
2327             labels the individual bars. Repeated labels are not de-duplicated
2328             and will cause repeated label entries, so this is best used when
2329             bars also differ in style (e.g., by passing a list to *color*.)
2330 
2331         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2332             If not *None*, add horizontal / vertical errorbars to the bar tips.
2333             The values are +/- sizes relative to the data:
2334 
2335             - scalar: symmetric +/- values for all bars
2336             - shape(N,): symmetric +/- values for each bar
2337             - shape(2, N): Separate - and + values for each bar. First row
2338               contains the lower errors, the second row contains the upper
2339               errors.
2340             - *None*: No errorbar. (Default)
2341 
2342             See :doc:`/gallery/statistics/errorbar_features` for an example on
2343             the usage of *xerr* and *yerr*.
2344 
2345         ecolor : color or list of color, default: 'black'
2346             The line color of the errorbars.
2347 
2348         capsize : float, default: :rc:`errorbar.capsize`
2349            The length of the error bar caps in points.
2350 
2351         error_kw : dict, optional
2352             Dictionary of keyword arguments to be passed to the
2353             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2354             here take precedence over the independent keyword arguments.
2355 
2356         log : bool, default: False
2357             If *True*, set the y-axis to be log scale.
2358 
2359         data : indexable object, optional
2360             DATA_PARAMETER_PLACEHOLDER
2361 
2362         **kwargs : `.Rectangle` properties
2363 
2364         %(Rectangle:kwdoc)s
2365 
2366         See Also
2367         --------
2368         barh : Plot a horizontal bar plot.
2369 
2370         Notes
2371         -----
2372         Stacked bars can be achieved by passing individual *bottom* values per
2373         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2374         """
2375         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2376         color = kwargs.pop('color', None)
2377         if color is None:
2378             color = self._get_patches_for_fill.get_next_color()
2379         edgecolor = kwargs.pop('edgecolor', None)
2380         linewidth = kwargs.pop('linewidth', None)
2381         hatch = kwargs.pop('hatch', None)
2382 
2383         # Because xerr and yerr will be passed to errorbar, most dimension
2384         # checking and processing will be left to the errorbar method.
2385         xerr = kwargs.pop('xerr', None)
2386         yerr = kwargs.pop('yerr', None)
2387         error_kw = kwargs.pop('error_kw', {})
2388         ezorder = error_kw.pop('zorder', None)
2389         if ezorder is None:
2390             ezorder = kwargs.get('zorder', None)
2391             if ezorder is not None:
2392                 # If using the bar zorder, increment slightly to make sure
2393                 # errorbars are drawn on top of bars
2394                 ezorder += 0.01
2395         error_kw.setdefault('zorder', ezorder)
2396         ecolor = kwargs.pop('ecolor', 'k')
2397         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2398         error_kw.setdefault('ecolor', ecolor)
2399         error_kw.setdefault('capsize', capsize)
2400 
2401         # The keyword argument *orientation* is used by barh() to defer all
2402         # logic and drawing to bar(). It is considered internal and is
2403         # intentionally not mentioned in the docstring.
2404         orientation = kwargs.pop('orientation', 'vertical')
2405         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2406         log = kwargs.pop('log', False)
2407         label = kwargs.pop('label', '')
2408         tick_labels = kwargs.pop('tick_label', None)
2409 
2410         y = bottom  # Matches barh call signature.
2411         if orientation == 'vertical':
2412             if y is None:
2413                 y = 0
2414         else:  # horizontal
2415             if x is None:
2416                 x = 0
2417 
2418         if orientation == 'vertical':
2419             self._process_unit_info(
2420                 [("x", x), ("y", height)], kwargs, convert=False)
2421             if log:
2422                 self.set_yscale('log', nonpositive='clip')
2423         else:  # horizontal
2424             self._process_unit_info(
2425                 [("x", width), ("y", y)], kwargs, convert=False)
2426             if log:
2427                 self.set_xscale('log', nonpositive='clip')
2428 
2429         # lets do some conversions now since some types cannot be
2430         # subtracted uniformly
2431         if self.xaxis is not None:
2432             x0 = x
2433             x = np.asarray(self.convert_xunits(x))
2434             width = self._convert_dx(width, x0, x, self.convert_xunits)
2435             if xerr is not None:
2436                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2437         if self.yaxis is not None:
2438             y0 = y
2439             y = np.asarray(self.convert_yunits(y))
2440             height = self._convert_dx(height, y0, y, self.convert_yunits)
2441             if yerr is not None:
2442                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2443 
2444         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2445             # Make args iterable too.
2446             np.atleast_1d(x), height, width, y, linewidth, hatch)
2447 
2448         # Now that units have been converted, set the tick locations.
2449         if orientation == 'vertical':
2450             tick_label_axis = self.xaxis
2451             tick_label_position = x
2452         else:  # horizontal
2453             tick_label_axis = self.yaxis
2454             tick_label_position = y
2455 
2456         if not isinstance(label, str) and np.iterable(label):
2457             bar_container_label = '_nolegend_'
2458             patch_labels = label
2459         else:
2460             bar_container_label = label
2461             patch_labels = ['_nolegend_'] * len(x)
2462         if len(patch_labels) != len(x):
2463             raise ValueError(f'number of labels ({len(patch_labels)}) '
2464                              f'does not match number of bars ({len(x)}).')
2465 
2466         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2467         hatch = itertools.cycle(np.atleast_1d(hatch))
2468         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2469                                 # Fallback if color == "none".
2470                                 itertools.repeat('none'))
2471         if edgecolor is None:
2472             edgecolor = itertools.repeat(None)
2473         else:
2474             edgecolor = itertools.chain(
2475                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2476                 # Fallback if edgecolor == "none".
2477                 itertools.repeat('none'))
2478 
2479         # We will now resolve the alignment and really have
2480         # left, bottom, width, height vectors
2481         _api.check_in_list(['center', 'edge'], align=align)
2482         if align == 'center':
2483             if orientation == 'vertical':
2484                 try:
2485                     left = x - width / 2
2486                 except TypeError as e:
2487                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2488                                     f'and width ({width.dtype}) '
2489                                     f'are incompatible') from e
2490                 bottom = y
2491             else:  # horizontal
2492                 try:
2493                     bottom = y - height / 2
2494                 except TypeError as e:
2495                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2496                                     f'and height ({height.dtype}) '
2497                                     f'are incompatible') from e
2498                 left = x
2499         else:  # edge
2500             left = x
2501             bottom = y
2502 
2503         patches = []
2504         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2505                    hatch, patch_labels)
2506         for l, b, w, h, c, e, lw, htch, lbl in args:
2507             r = mpatches.Rectangle(
2508                 xy=(l, b), width=w, height=h,
2509                 facecolor=c,
2510                 edgecolor=e,
2511                 linewidth=lw,
2512                 label=lbl,
2513                 hatch=htch,
2514                 )
2515             r._internal_update(kwargs)
2516             r.get_path()._interpolation_steps = 100
2517             if orientation == 'vertical':
2518                 r.sticky_edges.y.append(b)
2519             else:  # horizontal
2520                 r.sticky_edges.x.append(l)
2521             self.add_patch(r)
2522             patches.append(r)
2523 
2524         if xerr is not None or yerr is not None:
2525             if orientation == 'vertical':
2526                 # using list comps rather than arrays to preserve unit info
2527                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2528                 ey = [b + h for b, h in zip(bottom, height)]
2529 
2530             else:  # horizontal
2531                 # using list comps rather than arrays to preserve unit info
2532                 ex = [l + w for l, w in zip(left, width)]
2533                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2534 
2535             error_kw.setdefault("label", '_nolegend_')
2536 
2537             errorbar = self.errorbar(ex, ey,
2538                                      yerr=yerr, xerr=xerr,
2539                                      fmt='none', **error_kw)
2540         else:
2541             errorbar = None
2542 
2543         self._request_autoscale_view()
2544 
2545         if orientation == 'vertical':
2546             datavalues = height
2547         else:  # horizontal
2548             datavalues = width
2549 
2550         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2551                                      orientation=orientation,
2552                                      label=bar_container_label)
2553         self.add_container(bar_container)
2554 
2555         if tick_labels is not None:
2556             tick_labels = np.broadcast_to(tick_labels, len(patches))
2557             tick_label_axis.set_ticks(tick_label_position)
2558             tick_label_axis.set_ticklabels(tick_labels)
2559 
2560         return bar_container
2561 
2562     # @_preprocess_data() # let 'bar' do the unpacking..
2563     @_docstring.dedent_interpd
2564     def barh(self, y, width, height=0.8, left=None, *, align="center",
2565              data=None, **kwargs):
2566         r"""
2567         Make a horizontal bar plot.
2568 
2569         The bars are positioned at *y* with the given *align*\ment. Their
2570         dimensions are given by *width* and *height*. The horizontal baseline
2571         is *left* (default 0).
2572 
2573         Many parameters can take either a single value applying to all bars
2574         or a sequence of values, one for each bar.
2575 
2576         Parameters
2577         ----------
2578         y : float or array-like
2579             The y coordinates of the bars. See also *align* for the
2580             alignment of the bars to the coordinates.
2581 
2582         width : float or array-like
2583             The width(s) of the bars.
2584 
2585         height : float or array-like, default: 0.8
2586             The heights of the bars.
2587 
2588         left : float or array-like, default: 0
2589             The x coordinates of the left side(s) of the bars.
2590 
2591         align : {'center', 'edge'}, default: 'center'
2592             Alignment of the base to the *y* coordinates*:
2593 
2594             - 'center': Center the bars on the *y* positions.
2595             - 'edge': Align the bottom edges of the bars with the *y*
2596               positions.
2597 
2598             To align the bars on the top edge pass a negative *height* and
2599             ``align='edge'``.
2600 
2601         Returns
2602         -------
2603         `.BarContainer`
2604             Container with all the bars and optionally errorbars.
2605 
2606         Other Parameters
2607         ----------------
2608         color : color or list of color, optional
2609             The colors of the bar faces.
2610 
2611         edgecolor : color or list of color, optional
2612             The colors of the bar edges.
2613 
2614         linewidth : float or array-like, optional
2615             Width of the bar edge(s). If 0, don't draw edges.
2616 
2617         tick_label : str or list of str, optional
2618             The tick labels of the bars.
2619             Default: None (Use default numeric labels.)
2620 
2621         label : str or list of str, optional
2622             A single label is attached to the resulting `.BarContainer` as a
2623             label for the whole dataset.
2624             If a list is provided, it must be the same length as *y* and
2625             labels the individual bars. Repeated labels are not de-duplicated
2626             and will cause repeated label entries, so this is best used when
2627             bars also differ in style (e.g., by passing a list to *color*.)
2628 
2629         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2630             If not *None*, add horizontal / vertical errorbars to the bar tips.
2631             The values are +/- sizes relative to the data:
2632 
2633             - scalar: symmetric +/- values for all bars
2634             - shape(N,): symmetric +/- values for each bar
2635             - shape(2, N): Separate - and + values for each bar. First row
2636               contains the lower errors, the second row contains the upper
2637               errors.
2638             - *None*: No errorbar. (default)
2639 
2640             See :doc:`/gallery/statistics/errorbar_features` for an example on
2641             the usage of *xerr* and *yerr*.
2642 
2643         ecolor : color or list of color, default: 'black'
2644             The line color of the errorbars.
2645 
2646         capsize : float, default: :rc:`errorbar.capsize`
2647            The length of the error bar caps in points.
2648 
2649         error_kw : dict, optional
2650             Dictionary of keyword arguments to be passed to the
2651             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2652             here take precedence over the independent keyword arguments.
2653 
2654         log : bool, default: False
2655             If ``True``, set the x-axis to be log scale.
2656 
2657         data : indexable object, optional
2658             If given, all parameters also accept a string ``s``, which is
2659             interpreted as ``data[s]`` (unless this raises an exception).
2660 
2661         **kwargs : `.Rectangle` properties
2662 
2663         %(Rectangle:kwdoc)s
2664 
2665         See Also
2666         --------
2667         bar : Plot a vertical bar plot.
2668 
2669         Notes
2670         -----
2671         Stacked bars can be achieved by passing individual *left* values per
2672         bar. See
2673         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2674         """
2675         kwargs.setdefault('orientation', 'horizontal')
2676         patches = self.bar(x=left, height=height, width=width, bottom=y,
2677                            align=align, data=data, **kwargs)
2678         return patches
2679 
2680     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2681                   padding=0, **kwargs):
2682         """
2683         Label a bar plot.
2684 
2685         Adds labels to bars in the given `.BarContainer`.
2686         You may need to adjust the axis limits to fit the labels.
2687 
2688         Parameters
2689         ----------
2690         container : `.BarContainer`
2691             Container with all the bars and optionally errorbars, likely
2692             returned from `.bar` or `.barh`.
2693 
2694         labels : array-like, optional
2695             A list of label texts, that should be displayed. If not given, the
2696             label texts will be the data values formatted with *fmt*.
2697 
2698         fmt : str or callable, default: '%g'
2699             An unnamed %-style or {}-style format string for the label or a
2700             function to call with the value as the first argument.
2701             When *fmt* is a string and can be interpreted in both formats,
2702             %-style takes precedence over {}-style.
2703 
2704             .. versionadded:: 3.7
2705                Support for {}-style format string and callables.
2706 
2707         label_type : {'edge', 'center'}, default: 'edge'
2708             The label type. Possible values:
2709 
2710             - 'edge': label placed at the end-point of the bar segment, and the
2711               value displayed will be the position of that end-point.
2712             - 'center': label placed in the center of the bar segment, and the
2713               value displayed will be the length of that segment.
2714               (useful for stacked bars, i.e.,
2715               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2716 
2717         padding : float, default: 0
2718             Distance of label from the end of the bar, in points.
2719 
2720         **kwargs
2721             Any remaining keyword arguments are passed through to
2722             `.Axes.annotate`. The alignment parameters (
2723             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2724             not supported because the labels are automatically aligned to
2725             the bars.
2726 
2727         Returns
2728         -------
2729         list of `.Text`
2730             A list of `.Text` instances for the labels.
2731         """
2732         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2733             if key in kwargs:
2734                 raise ValueError(
2735                     f"Passing {key!r} to bar_label() is not supported.")
2736 
2737         a, b = self.yaxis.get_view_interval()
2738         y_inverted = a > b
2739         c, d = self.xaxis.get_view_interval()
2740         x_inverted = c > d
2741 
2742         # want to know whether to put label on positive or negative direction
2743         # cannot use np.sign here because it will return 0 if x == 0
2744         def sign(x):
2745             return 1 if x >= 0 else -1
2746 
2747         _api.check_in_list(['edge', 'center'], label_type=label_type)
2748 
2749         bars = container.patches
2750         errorbar = container.errorbar
2751         datavalues = container.datavalues
2752         orientation = container.orientation
2753 
2754         if errorbar:
2755             # check "ErrorbarContainer" for the definition of these elements
2756             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2757             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2758             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2759             errs = barlinecol.get_segments()
2760         else:
2761             errs = []
2762 
2763         if labels is None:
2764             labels = []
2765 
2766         annotations = []
2767 
2768         for bar, err, dat, lbl in itertools.zip_longest(
2769                 bars, errs, datavalues, labels
2770         ):
2771             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2772             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2773 
2774             if orientation == "vertical":
2775                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2776                 length = abs(y0 - y1)
2777             else:  # horizontal
2778                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2779                 length = abs(x0 - x1)
2780 
2781             if err is None or np.size(err) == 0:
2782                 endpt = extrema
2783             elif orientation == "vertical":
2784                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2785             else:  # horizontal
2786                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2787 
2788             if label_type == "center":
2789                 value = sign(dat) * length
2790             else:  # edge
2791                 value = extrema
2792 
2793             if label_type == "center":
2794                 xy = (0.5, 0.5)
2795                 kwargs["xycoords"] = (
2796                     lambda r, b=bar:
2797                         mtransforms.Bbox.intersection(
2798                             b.get_window_extent(r), b.get_clip_box()
2799                         ) or mtransforms.Bbox.null()
2800                 )
2801             else:  # edge
2802                 if orientation == "vertical":
2803                     xy = xc, endpt
2804                 else:  # horizontal
2805                     xy = endpt, yc
2806 
2807             if orientation == "vertical":
2808                 y_direction = -1 if y_inverted else 1
2809                 xytext = 0, y_direction * sign(dat) * padding
2810             else:  # horizontal
2811                 x_direction = -1 if x_inverted else 1
2812                 xytext = x_direction * sign(dat) * padding, 0
2813 
2814             if label_type == "center":
2815                 ha, va = "center", "center"
2816             else:  # edge
2817                 if orientation == "vertical":
2818                     ha = 'center'
2819                     if y_inverted:
2820                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2821                     else:
2822                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2823                 else:  # horizontal
2824                     if x_inverted:
2825                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2826                     else:
2827                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2828                     va = 'center'
2829 
2830             if np.isnan(dat):
2831                 lbl = ''
2832 
2833             if lbl is None:
2834                 if isinstance(fmt, str):
2835                     lbl = cbook._auto_format_str(fmt, value)
2836                 elif callable(fmt):
2837                     lbl = fmt(value)
2838                 else:
2839                     raise TypeError("fmt must be a str or callable")
2840             annotation = self.annotate(lbl,
2841                                        xy, xytext, textcoords="offset points",
2842                                        ha=ha, va=va, **kwargs)
2843             annotations.append(annotation)
2844 
2845         return annotations
2846 
2847     @_preprocess_data()
2848     @_docstring.dedent_interpd
2849     def broken_barh(self, xranges, yrange, **kwargs):
2850         """
2851         Plot a horizontal sequence of rectangles.
2852 
2853         A rectangle is drawn for each element of *xranges*. All rectangles
2854         have the same vertical position and size defined by *yrange*.
2855 
2856         Parameters
2857         ----------
2858         xranges : sequence of tuples (*xmin*, *xwidth*)
2859             The x-positions and extents of the rectangles. For each tuple
2860             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2861             *xwidth*.
2862         yrange : (*ymin*, *yheight*)
2863             The y-position and extent for all the rectangles.
2864 
2865         Returns
2866         -------
2867         `~.collections.PolyCollection`
2868 
2869         Other Parameters
2870         ----------------
2871         data : indexable object, optional
2872             DATA_PARAMETER_PLACEHOLDER
2873         **kwargs : `.PolyCollection` properties
2874 
2875             Each *kwarg* can be either a single argument applying to all
2876             rectangles, e.g.::
2877 
2878                 facecolors='black'
2879 
2880             or a sequence of arguments over which is cycled, e.g.::
2881 
2882                 facecolors=('black', 'blue')
2883 
2884             would create interleaving black and blue rectangles.
2885 
2886             Supported keywords:
2887 
2888             %(PolyCollection:kwdoc)s
2889         """
2890         # process the unit information
2891         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2892         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2893         self._process_unit_info(
2894             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2895 
2896         vertices = []
2897         y0, dy = yrange
2898         y0, y1 = self.convert_yunits((y0, y0 + dy))
2899         for xr in xranges:  # convert the absolute values, not the x and dx
2900             try:
2901                 x0, dx = xr
2902             except Exception:
2903                 raise ValueError(
2904                     "each range in xrange must be a sequence with two "
2905                     "elements (i.e. xrange must be an (N, 2) array)") from None
2906             x0, x1 = self.convert_xunits((x0, x0 + dx))
2907             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2908 
2909         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2910         self.add_collection(col, autolim=True)
2911         self._request_autoscale_view()
2912 
2913         return col
2914 
2915     @_preprocess_data()
2916     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2917              label=None, orientation='vertical'):
2918         """
2919         Create a stem plot.
2920 
2921         A stem plot draws lines perpendicular to a baseline at each location
2922         *locs* from the baseline to *heads*, and places a marker there. For
2923         vertical stem plots (the default), the *locs* are *x* positions, and
2924         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2925         *y* positions, and the *heads* are *x* values.
2926 
2927         Call signature::
2928 
2929           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2930 
2931         The *locs*-positions are optional. *linefmt* may be provided as
2932         positional, but all other formats must be provided as keyword
2933         arguments.
2934 
2935         Parameters
2936         ----------
2937         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2938             For vertical stem plots, the x-positions of the stems.
2939             For horizontal stem plots, the y-positions of the stems.
2940 
2941         heads : array-like
2942             For vertical stem plots, the y-values of the stem heads.
2943             For horizontal stem plots, the x-values of the stem heads.
2944 
2945         linefmt : str, optional
2946             A string defining the color and/or linestyle of the vertical lines:
2947 
2948             =========  =============
2949             Character  Line Style
2950             =========  =============
2951             ``'-'``    solid line
2952             ``'--'``   dashed line
2953             ``'-.'``   dash-dot line
2954             ``':'``    dotted line
2955             =========  =============
2956 
2957             Default: 'C0-', i.e. solid line with the first color of the color
2958             cycle.
2959 
2960             Note: Markers specified through this parameter (e.g. 'x') will be
2961             silently ignored. Instead, markers should be specified using
2962             *markerfmt*.
2963 
2964         markerfmt : str, optional
2965             A string defining the color and/or shape of the markers at the stem
2966             heads. If the marker is not given, use the marker 'o', i.e. filled
2967             circles. If the color is not given, use the color from *linefmt*.
2968 
2969         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2970             A format string defining the properties of the baseline.
2971 
2972         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2973             If 'vertical', will produce a plot with stems oriented vertically,
2974             If 'horizontal', the stems will be oriented horizontally.
2975 
2976         bottom : float, default: 0
2977             The y/x-position of the baseline (depending on orientation).
2978 
2979         label : str, default: None
2980             The label to use for the stems in legends.
2981 
2982         data : indexable object, optional
2983             DATA_PARAMETER_PLACEHOLDER
2984 
2985         Returns
2986         -------
2987         `.StemContainer`
2988             The container may be treated like a tuple
2989             (*markerline*, *stemlines*, *baseline*)
2990 
2991         Notes
2992         -----
2993         .. seealso::
2994             The MATLAB function
2995             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2996             which inspired this method.
2997         """
2998         if not 1 <= len(args) <= 3:
2999             raise _api.nargs_error('stem', '1-3', len(args))
3000         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3001 
3002         if len(args) == 1:
3003             heads, = args
3004             locs = np.arange(len(heads))
3005             args = ()
3006         elif isinstance(args[1], str):
3007             heads, *args = args
3008             locs = np.arange(len(heads))
3009         else:
3010             locs, heads, *args = args
3011 
3012         if orientation == 'vertical':
3013             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3014         else:  # horizontal
3015             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3016 
3017         # resolve line format
3018         if linefmt is None:
3019             linefmt = args[0] if len(args) > 0 else "C0-"
3020         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3021 
3022         # resolve marker format
3023         if markerfmt is None:
3024             # if not given as kwarg, fall back to 'o'
3025             markerfmt = "o"
3026         if markerfmt == '':
3027             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3028         markerstyle, markermarker, markercolor = \
3029             _process_plot_format(markerfmt)
3030         if markermarker is None:
3031             markermarker = 'o'
3032         if markerstyle is None:
3033             markerstyle = 'None'
3034         if markercolor is None:
3035             markercolor = linecolor
3036 
3037         # resolve baseline format
3038         if basefmt is None:
3039             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3040                        "C3-")
3041         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3042 
3043         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3044         if linestyle is None:
3045             linestyle = mpl.rcParams['lines.linestyle']
3046         xlines = self.vlines if orientation == "vertical" else self.hlines
3047         stemlines = xlines(
3048             locs, bottom, heads,
3049             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3050 
3051         if orientation == 'horizontal':
3052             marker_x = heads
3053             marker_y = locs
3054             baseline_x = [bottom, bottom]
3055             baseline_y = [np.min(locs), np.max(locs)]
3056         else:
3057             marker_x = locs
3058             marker_y = heads
3059             baseline_x = [np.min(locs), np.max(locs)]
3060             baseline_y = [bottom, bottom]
3061 
3062         markerline, = self.plot(marker_x, marker_y,
3063                                 color=markercolor, linestyle=markerstyle,
3064                                 marker=markermarker, label="_nolegend_")
3065 
3066         baseline, = self.plot(baseline_x, baseline_y,
3067                               color=basecolor, linestyle=basestyle,
3068                               marker=basemarker, label="_nolegend_")
3069 
3070         stem_container = StemContainer((markerline, stemlines, baseline),
3071                                        label=label)
3072         self.add_container(stem_container)
3073         return stem_container
3074 
3075     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3076     def pie(self, x, explode=None, labels=None, colors=None,
3077             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3078             startangle=0, radius=1, counterclock=True,
3079             wedgeprops=None, textprops=None, center=(0, 0),
3080             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3081         """
3082         Plot a pie chart.
3083 
3084         Make a pie chart of array *x*.  The fractional area of each wedge is
3085         given by ``x/sum(x)``.
3086 
3087         The wedges are plotted counterclockwise, by default starting from the
3088         x-axis.
3089 
3090         Parameters
3091         ----------
3092         x : 1D array-like
3093             The wedge sizes.
3094 
3095         explode : array-like, default: None
3096             If not *None*, is a ``len(x)`` array which specifies the fraction
3097             of the radius with which to offset each wedge.
3098 
3099         labels : list, default: None
3100             A sequence of strings providing the labels for each wedge
3101 
3102         colors : color or array-like of color, default: None
3103             A sequence of colors through which the pie chart will cycle.  If
3104             *None*, will use the colors in the currently active cycle.
3105 
3106         hatch : str or list, default: None
3107             Hatching pattern applied to all pie wedges or sequence of patterns
3108             through which the chart will cycle. For a list of valid patterns,
3109             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3110 
3111             .. versionadded:: 3.7
3112 
3113         autopct : None or str or callable, default: None
3114             If not *None*, *autopct* is a string or function used to label the
3115             wedges with their numeric value. The label will be placed inside
3116             the wedge. If *autopct* is a format string, the label will be
3117             ``fmt % pct``. If *autopct* is a function, then it will be called.
3118 
3119         pctdistance : float, default: 0.6
3120             The relative distance along the radius at which the text
3121             generated by *autopct* is drawn. To draw the text outside the pie,
3122             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3123             ``None``.
3124 
3125         labeldistance : float or None, default: 1.1
3126             The relative distance along the radius at which the labels are
3127             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3128             If set to ``None``, labels are not drawn but are still stored for
3129             use in `.legend`.
3130 
3131         shadow : bool or dict, default: False
3132             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3133             passing the properties in the dict to `.Shadow`.
3134 
3135             .. versionadded:: 3.8
3136                 *shadow* can be a dict.
3137 
3138         startangle : float, default: 0 degrees
3139             The angle by which the start of the pie is rotated,
3140             counterclockwise from the x-axis.
3141 
3142         radius : float, default: 1
3143             The radius of the pie.
3144 
3145         counterclock : bool, default: True
3146             Specify fractions direction, clockwise or counterclockwise.
3147 
3148         wedgeprops : dict, default: None
3149             Dict of arguments passed to each `.patches.Wedge` of the pie.
3150             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3151             the wedge border lines equal to 3. By default, ``clip_on=False``.
3152             When there is a conflict between these properties and other
3153             keywords, properties passed to *wedgeprops* take precedence.
3154 
3155         textprops : dict, default: None
3156             Dict of arguments to pass to the text objects.
3157 
3158         center : (float, float), default: (0, 0)
3159             The coordinates of the center of the chart.
3160 
3161         frame : bool, default: False
3162             Plot Axes frame with the chart if true.
3163 
3164         rotatelabels : bool, default: False
3165             Rotate each label to the angle of the corresponding slice if true.
3166 
3167         normalize : bool, default: True
3168             When *True*, always make a full pie by normalizing x so that
3169             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3170             and raises a `ValueError` for ``sum(x) > 1``.
3171 
3172         data : indexable object, optional
3173             DATA_PARAMETER_PLACEHOLDER
3174 
3175         Returns
3176         -------
3177         patches : list
3178             A sequence of `matplotlib.patches.Wedge` instances
3179 
3180         texts : list
3181             A list of the label `.Text` instances.
3182 
3183         autotexts : list
3184             A list of `.Text` instances for the numeric labels. This will only
3185             be returned if the parameter *autopct* is not *None*.
3186 
3187         Notes
3188         -----
3189         The pie chart will probably look best if the figure and Axes are
3190         square, or the Axes aspect is equal.
3191         This method sets the aspect ratio of the axis to "equal".
3192         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3193         """
3194         self.set_aspect('equal')
3195         # The use of float32 is "historical", but can't be changed without
3196         # regenerating the test baselines.
3197         x = np.asarray(x, np.float32)
3198         if x.ndim > 1:
3199             raise ValueError("x must be 1D")
3200 
3201         if np.any(x < 0):
3202             raise ValueError("Wedge sizes 'x' must be non negative values")
3203 
3204         sx = x.sum()
3205 
3206         if normalize:
3207             x = x / sx
3208         elif sx > 1:
3209             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3210         if labels is None:
3211             labels = [''] * len(x)
3212         if explode is None:
3213             explode = [0] * len(x)
3214         if len(x) != len(labels):
3215             raise ValueError("'label' must be of length 'x'")
3216         if len(x) != len(explode):
3217             raise ValueError("'explode' must be of length 'x'")
3218         if colors is None:
3219             get_next_color = self._get_patches_for_fill.get_next_color
3220         else:
3221             color_cycle = itertools.cycle(colors)
3222 
3223             def get_next_color():
3224                 return next(color_cycle)
3225 
3226         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3227 
3228         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3229         if radius <= 0:
3230             raise ValueError(f'radius must be a positive number, not {radius}')
3231 
3232         # Starting theta1 is the start fraction of the circle
3233         theta1 = startangle / 360
3234 
3235         if wedgeprops is None:
3236             wedgeprops = {}
3237         if textprops is None:
3238             textprops = {}
3239 
3240         texts = []
3241         slices = []
3242         autotexts = []
3243 
3244         for frac, label, expl in zip(x, labels, explode):
3245             x, y = center
3246             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3247             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3248             x += expl * math.cos(thetam)
3249             y += expl * math.sin(thetam)
3250 
3251             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3252                                360. * max(theta1, theta2),
3253                                facecolor=get_next_color(),
3254                                hatch=next(hatch_cycle),
3255                                clip_on=False,
3256                                label=label)
3257             w.set(**wedgeprops)
3258             slices.append(w)
3259             self.add_patch(w)
3260 
3261             if shadow:
3262                 # Make sure to add a shadow after the call to add_patch so the
3263                 # figure and transform props will be set.
3264                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3265                 if isinstance(shadow, dict):
3266                     shadow_dict.update(shadow)
3267                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3268 
3269             if labeldistance is not None:
3270                 xt = x + labeldistance * radius * math.cos(thetam)
3271                 yt = y + labeldistance * radius * math.sin(thetam)
3272                 label_alignment_h = 'left' if xt > 0 else 'right'
3273                 label_alignment_v = 'center'
3274                 label_rotation = 'horizontal'
3275                 if rotatelabels:
3276                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3277                     label_rotation = (np.rad2deg(thetam)
3278                                       + (0 if xt > 0 else 180))
3279                 t = self.text(xt, yt, label,
3280                               clip_on=False,
3281                               horizontalalignment=label_alignment_h,
3282                               verticalalignment=label_alignment_v,
3283                               rotation=label_rotation,
3284                               size=mpl.rcParams['xtick.labelsize'])
3285                 t.set(**textprops)
3286                 texts.append(t)
3287 
3288             if autopct is not None:
3289                 xt = x + pctdistance * radius * math.cos(thetam)
3290                 yt = y + pctdistance * radius * math.sin(thetam)
3291                 if isinstance(autopct, str):
3292                     s = autopct % (100. * frac)
3293                 elif callable(autopct):
3294                     s = autopct(100. * frac)
3295                 else:
3296                     raise TypeError(
3297                         'autopct must be callable or a format string')
3298                 t = self.text(xt, yt, s,
3299                               clip_on=False,
3300                               horizontalalignment='center',
3301                               verticalalignment='center')
3302                 t.set(**textprops)
3303                 autotexts.append(t)
3304 
3305             theta1 = theta2
3306 
3307         if frame:
3308             self._request_autoscale_view()
3309         else:
3310             self.set(frame_on=False, xticks=[], yticks=[],
3311                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3312                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3313 
3314         if autopct is None:
3315             return slices, texts
3316         else:
3317             return slices, texts, autotexts
3318 
3319     @staticmethod
3320     def _errorevery_to_mask(x, errorevery):
3321         """
3322         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3323 
3324         This function is split out to be usable both by 2D and 3D errorbars.
3325         """
3326         if isinstance(errorevery, Integral):
3327             errorevery = (0, errorevery)
3328         if isinstance(errorevery, tuple):
3329             if (len(errorevery) == 2 and
3330                     isinstance(errorevery[0], Integral) and
3331                     isinstance(errorevery[1], Integral)):
3332                 errorevery = slice(errorevery[0], None, errorevery[1])
3333             else:
3334                 raise ValueError(
3335                     f'{errorevery=!r} is a not a tuple of two integers')
3336         elif isinstance(errorevery, slice):
3337             pass
3338         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3339             try:
3340                 x[errorevery]  # fancy indexing
3341             except (ValueError, IndexError) as err:
3342                 raise ValueError(
3343                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3344                     "index to match 'xerr'/'yerr'") from err
3345         else:
3346             raise ValueError(f"{errorevery=!r} is not a recognized value")
3347         everymask = np.zeros(len(x), bool)
3348         everymask[errorevery] = True
3349         return everymask
3350 
3351     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3352                       label_namer="y")
3353     @_docstring.dedent_interpd
3354     def errorbar(self, x, y, yerr=None, xerr=None,
3355                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3356                  barsabove=False, lolims=False, uplims=False,
3357                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3358                  **kwargs):
3359         """
3360         Plot y versus x as lines and/or markers with attached errorbars.
3361 
3362         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3363         sizes. By default, this draws the data markers/lines as well the
3364         errorbars. Use fmt='none' to draw errorbars without any data markers.
3365 
3366         .. versionadded:: 3.7
3367            Caps and error lines are drawn in polar coordinates on polar plots.
3368 
3369 
3370         Parameters
3371         ----------
3372         x, y : float or array-like
3373             The data positions.
3374 
3375         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3376             The errorbar sizes:
3377 
3378             - scalar: Symmetric +/- values for all data points.
3379             - shape(N,): Symmetric +/-values for each data point.
3380             - shape(2, N): Separate - and + values for each bar. First row
3381               contains the lower errors, the second row contains the upper
3382               errors.
3383             - *None*: No errorbar.
3384 
3385             All values must be >= 0.
3386 
3387             See :doc:`/gallery/statistics/errorbar_features`
3388             for an example on the usage of ``xerr`` and ``yerr``.
3389 
3390         fmt : str, default: ''
3391             The format for the data points / data lines. See `.plot` for
3392             details.
3393 
3394             Use 'none' (case-insensitive) to plot errorbars without any data
3395             markers.
3396 
3397         ecolor : color, default: None
3398             The color of the errorbar lines.  If None, use the color of the
3399             line connecting the markers.
3400 
3401         elinewidth : float, default: None
3402             The linewidth of the errorbar lines. If None, the linewidth of
3403             the current style is used.
3404 
3405         capsize : float, default: :rc:`errorbar.capsize`
3406             The length of the error bar caps in points.
3407 
3408         capthick : float, default: None
3409             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3410             This setting is a more sensible name for the property that
3411             controls the thickness of the error bar cap in points. For
3412             backwards compatibility, if *mew* or *markeredgewidth* are given,
3413             then they will over-ride *capthick*. This may change in future
3414             releases.
3415 
3416         barsabove : bool, default: False
3417             If True, will plot the errorbars above the plot
3418             symbols. Default is below.
3419 
3420         lolims, uplims, xlolims, xuplims : bool, default: False
3421             These arguments can be used to indicate that a value gives only
3422             upper/lower limits.  In that case a caret symbol is used to
3423             indicate this. *lims*-arguments may be scalars, or array-likes of
3424             the same length as *xerr* and *yerr*.  To use limits with inverted
3425             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3426             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3427             *lolims* to True means that the y-value is a *lower* limit of the
3428             True value, so, only an *upward*-pointing arrow will be drawn!
3429 
3430         errorevery : int or (int, int), default: 1
3431             draws error bars on a subset of the data. *errorevery* =N draws
3432             error bars on the points (x[::N], y[::N]).
3433             *errorevery* =(start, N) draws error bars on the points
3434             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3435             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3436             Used to avoid overlapping error bars when two series share x-axis
3437             values.
3438 
3439         Returns
3440         -------
3441         `.ErrorbarContainer`
3442             The container contains:
3443 
3444             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3445             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3446             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3447               vertical error ranges.
3448 
3449         Other Parameters
3450         ----------------
3451         data : indexable object, optional
3452             DATA_PARAMETER_PLACEHOLDER
3453 
3454         **kwargs
3455             All other keyword arguments are passed on to the `~.Axes.plot` call
3456             drawing the markers. For example, this code makes big red squares
3457             with thick green edges::
3458 
3459                 x, y, yerr = rand(3, 10)
3460                 errorbar(x, y, yerr, marker='s', mfc='red',
3461                          mec='green', ms=20, mew=4)
3462 
3463             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3464             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3465             and *markeredgewidth*.
3466 
3467             Valid kwargs for the marker properties are:
3468 
3469             - *dashes*
3470             - *dash_capstyle*
3471             - *dash_joinstyle*
3472             - *drawstyle*
3473             - *fillstyle*
3474             - *linestyle*
3475             - *marker*
3476             - *markeredgecolor*
3477             - *markeredgewidth*
3478             - *markerfacecolor*
3479             - *markerfacecoloralt*
3480             - *markersize*
3481             - *markevery*
3482             - *solid_capstyle*
3483             - *solid_joinstyle*
3484 
3485             Refer to the corresponding `.Line2D` property for more details:
3486 
3487             %(Line2D:kwdoc)s
3488         """
3489         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3490         # Drop anything that comes in as None to use the default instead.
3491         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3492         kwargs.setdefault('zorder', 2)
3493 
3494         # Casting to object arrays preserves units.
3495         if not isinstance(x, np.ndarray):
3496             x = np.asarray(x, dtype=object)
3497         if not isinstance(y, np.ndarray):
3498             y = np.asarray(y, dtype=object)
3499 
3500         def _upcast_err(err):
3501             """
3502             Safely handle tuple of containers that carry units.
3503 
3504             This function covers the case where the input to the xerr/yerr is a
3505             length 2 tuple of equal length ndarray-subclasses that carry the
3506             unit information in the container.
3507 
3508             If we have a tuple of nested numpy array (subclasses), we defer
3509             coercing the units to be consistent to the underlying unit
3510             library (and implicitly the broadcasting).
3511 
3512             Otherwise, fallback to casting to an object array.
3513             """
3514 
3515             if (
3516                     # make sure it is not a scalar
3517                     np.iterable(err) and
3518                     # and it is not empty
3519                     len(err) > 0 and
3520                     # and the first element is an array sub-class use
3521                     # safe_first_element because getitem is index-first not
3522                     # location first on pandas objects so err[0] almost always
3523                     # fails.
3524                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3525             ):
3526                 # Get the type of the first element
3527                 atype = type(cbook._safe_first_finite(err))
3528                 # Promote the outer container to match the inner container
3529                 if atype is np.ndarray:
3530                     # Converts using np.asarray, because data cannot
3531                     # be directly passed to init of np.ndarray
3532                     return np.asarray(err, dtype=object)
3533                 # If atype is not np.ndarray, directly pass data to init.
3534                 # This works for types such as unyts and astropy units
3535                 return atype(err)
3536             # Otherwise wrap it in an object array
3537             return np.asarray(err, dtype=object)
3538 
3539         if xerr is not None and not isinstance(xerr, np.ndarray):
3540             xerr = _upcast_err(xerr)
3541         if yerr is not None and not isinstance(yerr, np.ndarray):
3542             yerr = _upcast_err(yerr)
3543         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3544         if len(x) != len(y):
3545             raise ValueError("'x' and 'y' must have the same size")
3546 
3547         everymask = self._errorevery_to_mask(x, errorevery)
3548 
3549         label = kwargs.pop("label", None)
3550         kwargs['label'] = '_nolegend_'
3551 
3552         # Create the main line and determine overall kwargs for child artists.
3553         # We avoid calling self.plot() directly, or self._get_lines(), because
3554         # that would call self._process_unit_info again, and do other indirect
3555         # data processing.
3556         (data_line, base_style), = self._get_lines._plot_args(
3557             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3558 
3559         # Do this after creating `data_line` to avoid modifying `base_style`.
3560         if barsabove:
3561             data_line.set_zorder(kwargs['zorder'] - .1)
3562         else:
3563             data_line.set_zorder(kwargs['zorder'] + .1)
3564 
3565         # Add line to plot, or throw it away and use it to determine kwargs.
3566         if fmt.lower() != 'none':
3567             self.add_line(data_line)
3568         else:
3569             data_line = None
3570             # Remove alpha=0 color that _get_lines._plot_args returns for
3571             # 'none' format, and replace it with user-specified color, if
3572             # supplied.
3573             base_style.pop('color')
3574             if 'color' in kwargs:
3575                 base_style['color'] = kwargs.pop('color')
3576 
3577         if 'color' not in base_style:
3578             base_style['color'] = 'C0'
3579         if ecolor is None:
3580             ecolor = base_style['color']
3581 
3582         # Eject any line-specific information from format string, as it's not
3583         # needed for bars or caps.
3584         for key in ['marker', 'markersize', 'markerfacecolor',
3585                     'markerfacecoloralt',
3586                     'markeredgewidth', 'markeredgecolor', 'markevery',
3587                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3588                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3589                     'dashes']:
3590             base_style.pop(key, None)
3591 
3592         # Make the style dict for the line collections (the bars).
3593         eb_lines_style = {**base_style, 'color': ecolor}
3594 
3595         if elinewidth is not None:
3596             eb_lines_style['linewidth'] = elinewidth
3597         elif 'linewidth' in kwargs:
3598             eb_lines_style['linewidth'] = kwargs['linewidth']
3599 
3600         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3601             if key in kwargs:
3602                 eb_lines_style[key] = kwargs[key]
3603 
3604         # Make the style dict for caps (the "hats").
3605         eb_cap_style = {**base_style, 'linestyle': 'none'}
3606         if capsize is None:
3607             capsize = mpl.rcParams["errorbar.capsize"]
3608         if capsize > 0:
3609             eb_cap_style['markersize'] = 2. * capsize
3610         if capthick is not None:
3611             eb_cap_style['markeredgewidth'] = capthick
3612 
3613         # For backwards-compat, allow explicit setting of
3614         # 'markeredgewidth' to over-ride capthick.
3615         for key in ('markeredgewidth', 'transform', 'alpha',
3616                     'zorder', 'rasterized'):
3617             if key in kwargs:
3618                 eb_cap_style[key] = kwargs[key]
3619         eb_cap_style['color'] = ecolor
3620 
3621         barcols = []
3622         caplines = {'x': [], 'y': []}
3623 
3624         # Vectorized fancy-indexer.
3625         def apply_mask(arrays, mask):
3626             return [array[mask] for array in arrays]
3627 
3628         # dep: dependent dataset, indep: independent dataset
3629         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3630              marker, lomarker, himarker) in [
3631                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3632                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3633                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3634                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3635         ]:
3636             if err is None:
3637                 continue
3638             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3639             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3640             try:
3641                 np.broadcast_to(err, (2, len(dep)))
3642             except ValueError:
3643                 raise ValueError(
3644                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3645                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3646                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3647             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3648             if np.any(np.less(err, -err, out=res, where=(err == err))):
3649                 # like err<0, but also works for timedelta and nan.
3650                 raise ValueError(
3651                     f"'{dep_axis}err' must not contain negative values")
3652             # This is like
3653             #     elow, ehigh = np.broadcast_to(...)
3654             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3655             # except that broadcast_to would strip units.
3656             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3657             barcols.append(lines_func(
3658                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3659             if self.name == "polar" and dep_axis == "x":
3660                 for b in barcols:
3661                     for p in b.get_paths():
3662                         p._interpolation_steps = 2
3663             # Normal errorbars for points without upper/lower limits.
3664             nolims = ~(lolims | uplims)
3665             if nolims.any() and capsize > 0:
3666                 indep_masked, lo_masked, hi_masked = apply_mask(
3667                     [indep, low, high], nolims & everymask)
3668                 for lh_masked in [lo_masked, hi_masked]:
3669                     # Since this has to work for x and y as dependent data, we
3670                     # first set both x and y to the independent variable and
3671                     # overwrite the respective dependent data in a second step.
3672                     line = mlines.Line2D(indep_masked, indep_masked,
3673                                          marker=marker, **eb_cap_style)
3674                     line.set(**{f"{dep_axis}data": lh_masked})
3675                     caplines[dep_axis].append(line)
3676             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3677                 if not lims.any():
3678                     continue
3679                 hlmarker = (
3680                     himarker
3681                     if self._axis_map[dep_axis].get_inverted() ^ idx
3682                     else lomarker)
3683                 x_masked, y_masked, hl_masked = apply_mask(
3684                     [x, y, hl], lims & everymask)
3685                 # As above, we set the dependent data in a second step.
3686                 line = mlines.Line2D(x_masked, y_masked,
3687                                      marker=hlmarker, **eb_cap_style)
3688                 line.set(**{f"{dep_axis}data": hl_masked})
3689                 caplines[dep_axis].append(line)
3690                 if capsize > 0:
3691                     caplines[dep_axis].append(mlines.Line2D(
3692                         x_masked, y_masked, marker=marker, **eb_cap_style))
3693         if self.name == 'polar':
3694             for axis in caplines:
3695                 for l in caplines[axis]:
3696                     # Rotate caps to be perpendicular to the error bars
3697                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3698                         rotation = mtransforms.Affine2D().rotate(theta)
3699                         if axis == 'y':
3700                             rotation.rotate(-np.pi / 2)
3701                         ms = mmarkers.MarkerStyle(marker=marker,
3702                                                   transform=rotation)
3703                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3704                                                     **eb_cap_style))
3705         else:
3706             for axis in caplines:
3707                 for l in caplines[axis]:
3708                     self.add_line(l)
3709 
3710         self._request_autoscale_view()
3711         caplines = caplines['x'] + caplines['y']
3712         errorbar_container = ErrorbarContainer(
3713             (data_line, tuple(caplines), tuple(barcols)),
3714             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3715             label=label)
3716         self.containers.append(errorbar_container)
3717 
3718         return errorbar_container  # (l0, caplines, barcols)
3719 
3720     @_preprocess_data()
3721     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3722                 positions=None, widths=None, patch_artist=None,
3723                 bootstrap=None, usermedians=None, conf_intervals=None,
3724                 meanline=None, showmeans=None, showcaps=None,
3725                 showbox=None, showfliers=None, boxprops=None,
3726                 labels=None, flierprops=None, medianprops=None,
3727                 meanprops=None, capprops=None, whiskerprops=None,
3728                 manage_ticks=True, autorange=False, zorder=None,
3729                 capwidths=None):
3730         """
3731         Draw a box and whisker plot.
3732 
3733         The box extends from the first quartile (Q1) to the third
3734         quartile (Q3) of the data, with a line at the median.
3735         The whiskers extend from the box to the farthest data point
3736         lying within 1.5x the inter-quartile range (IQR) from the box.
3737         Flier points are those past the end of the whiskers.
3738         See https://en.wikipedia.org/wiki/Box_plot for reference.
3739 
3740         .. code-block:: none
3741 
3742                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3743                                |-----:-----|
3744                o      |--------|     :     |--------|    o  o
3745                                |-----:-----|
3746              flier             <----------->            fliers
3747                                     IQR
3748 
3749 
3750         Parameters
3751         ----------
3752         x : Array or a sequence of vectors.
3753             The input data.  If a 2D array, a boxplot is drawn for each column
3754             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3755             array in *x*.
3756 
3757         notch : bool, default: False
3758             Whether to draw a notched boxplot (`True`), or a rectangular
3759             boxplot (`False`).  The notches represent the confidence interval
3760             (CI) around the median.  The documentation for *bootstrap*
3761             describes how the locations of the notches are computed by
3762             default, but their locations may also be overridden by setting the
3763             *conf_intervals* parameter.
3764 
3765             .. note::
3766 
3767                 In cases where the values of the CI are less than the
3768                 lower quartile or greater than the upper quartile, the
3769                 notches will extend beyond the box, giving it a
3770                 distinctive "flipped" appearance. This is expected
3771                 behavior and consistent with other statistical
3772                 visualization packages.
3773 
3774         sym : str, optional
3775             The default symbol for flier points.  An empty string ('') hides
3776             the fliers.  If `None`, then the fliers default to 'b+'.  More
3777             control is provided by the *flierprops* parameter.
3778 
3779         vert : bool, default: True
3780             If `True`, draws vertical boxes.
3781             If `False`, draw horizontal boxes.
3782 
3783         whis : float or (float, float), default: 1.5
3784             The position of the whiskers.
3785 
3786             If a float, the lower whisker is at the lowest datum above
3787             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3788             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3789             third quartiles.  The default value of ``whis = 1.5`` corresponds
3790             to Tukey's original definition of boxplots.
3791 
3792             If a pair of floats, they indicate the percentiles at which to
3793             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3794             (0, 100) results in whiskers covering the whole range of the data.
3795 
3796             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3797             to (0, 100) (cover the whole range of the data) if *autorange* is
3798             True.
3799 
3800             Beyond the whiskers, data are considered outliers and are plotted
3801             as individual points.
3802 
3803         bootstrap : int, optional
3804             Specifies whether to bootstrap the confidence intervals
3805             around the median for notched boxplots. If *bootstrap* is
3806             None, no bootstrapping is performed, and notches are
3807             calculated using a Gaussian-based asymptotic approximation
3808             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3809             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3810             the number of times to bootstrap the median to determine its
3811             95% confidence intervals. Values between 1000 and 10000 are
3812             recommended.
3813 
3814         usermedians : 1D array-like, optional
3815             A 1D array-like of length ``len(x)``.  Each entry that is not
3816             `None` forces the value of the median for the corresponding
3817             dataset.  For entries that are `None`, the medians are computed
3818             by Matplotlib as normal.
3819 
3820         conf_intervals : array-like, optional
3821             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3822             None forces the location of the corresponding notch (which is
3823             only drawn if *notch* is `True`).  For entries that are `None`,
3824             the notches are computed by the method specified by the other
3825             parameters (e.g., *bootstrap*).
3826 
3827         positions : array-like, optional
3828             The positions of the boxes. The ticks and limits are
3829             automatically set to match the positions. Defaults to
3830             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3831 
3832         widths : float or array-like
3833             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3834             between extreme positions)``, if that is smaller.
3835 
3836         patch_artist : bool, default: False
3837             If `False` produces boxes with the Line2D artist. Otherwise,
3838             boxes are drawn with Patch artists.
3839 
3840         labels : sequence, optional
3841             Labels for each dataset (one per dataset).
3842 
3843         manage_ticks : bool, default: True
3844             If True, the tick locations and labels will be adjusted to match
3845             the boxplot positions.
3846 
3847         autorange : bool, default: False
3848             When `True` and the data are distributed such that the 25th and
3849             75th percentiles are equal, *whis* is set to (0, 100) such
3850             that the whisker ends are at the minimum and maximum of the data.
3851 
3852         meanline : bool, default: False
3853             If `True` (and *showmeans* is `True`), will try to render the
3854             mean as a line spanning the full width of the box according to
3855             *meanprops* (see below).  Not recommended if *shownotches* is also
3856             True.  Otherwise, means will be shown as points.
3857 
3858         zorder : float, default: ``Line2D.zorder = 2``
3859             The zorder of the boxplot.
3860 
3861         Returns
3862         -------
3863         dict
3864           A dictionary mapping each component of the boxplot to a list
3865           of the `.Line2D` instances created. That dictionary has the
3866           following keys (assuming vertical boxplots):
3867 
3868           - ``boxes``: the main body of the boxplot showing the
3869             quartiles and the median's confidence intervals if
3870             enabled.
3871 
3872           - ``medians``: horizontal lines at the median of each box.
3873 
3874           - ``whiskers``: the vertical lines extending to the most
3875             extreme, non-outlier data points.
3876 
3877           - ``caps``: the horizontal lines at the ends of the
3878             whiskers.
3879 
3880           - ``fliers``: points representing data that extend beyond
3881             the whiskers (fliers).
3882 
3883           - ``means``: points or lines representing the means.
3884 
3885         Other Parameters
3886         ----------------
3887         showcaps : bool, default: True
3888             Show the caps on the ends of whiskers.
3889         showbox : bool, default: True
3890             Show the central box.
3891         showfliers : bool, default: True
3892             Show the outliers beyond the caps.
3893         showmeans : bool, default: False
3894             Show the arithmetic means.
3895         capprops : dict, default: None
3896             The style of the caps.
3897         capwidths : float or array, default: None
3898             The widths of the caps.
3899         boxprops : dict, default: None
3900             The style of the box.
3901         whiskerprops : dict, default: None
3902             The style of the whiskers.
3903         flierprops : dict, default: None
3904             The style of the fliers.
3905         medianprops : dict, default: None
3906             The style of the median.
3907         meanprops : dict, default: None
3908             The style of the mean.
3909         data : indexable object, optional
3910             DATA_PARAMETER_PLACEHOLDER
3911 
3912         See Also
3913         --------
3914         violinplot : Draw an estimate of the probability density function.
3915         """
3916 
3917         # Missing arguments default to rcParams.
3918         if whis is None:
3919             whis = mpl.rcParams['boxplot.whiskers']
3920         if bootstrap is None:
3921             bootstrap = mpl.rcParams['boxplot.bootstrap']
3922 
3923         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3924                                        labels=labels, autorange=autorange)
3925         if notch is None:
3926             notch = mpl.rcParams['boxplot.notch']
3927         if vert is None:
3928             vert = mpl.rcParams['boxplot.vertical']
3929         if patch_artist is None:
3930             patch_artist = mpl.rcParams['boxplot.patchartist']
3931         if meanline is None:
3932             meanline = mpl.rcParams['boxplot.meanline']
3933         if showmeans is None:
3934             showmeans = mpl.rcParams['boxplot.showmeans']
3935         if showcaps is None:
3936             showcaps = mpl.rcParams['boxplot.showcaps']
3937         if showbox is None:
3938             showbox = mpl.rcParams['boxplot.showbox']
3939         if showfliers is None:
3940             showfliers = mpl.rcParams['boxplot.showfliers']
3941 
3942         if boxprops is None:
3943             boxprops = {}
3944         if whiskerprops is None:
3945             whiskerprops = {}
3946         if capprops is None:
3947             capprops = {}
3948         if medianprops is None:
3949             medianprops = {}
3950         if meanprops is None:
3951             meanprops = {}
3952         if flierprops is None:
3953             flierprops = {}
3954 
3955         if patch_artist:
3956             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3957             if 'color' in boxprops:
3958                 boxprops['edgecolor'] = boxprops.pop('color')
3959 
3960         # if non-default sym value, put it into the flier dictionary
3961         # the logic for providing the default symbol ('b+') now lives
3962         # in bxp in the initial value of flierkw
3963         # handle all of the *sym* related logic here so we only have to pass
3964         # on the flierprops dict.
3965         if sym is not None:
3966             # no-flier case, which should really be done with
3967             # 'showfliers=False' but none-the-less deal with it to keep back
3968             # compatibility
3969             if sym == '':
3970                 # blow away existing dict and make one for invisible markers
3971                 flierprops = dict(linestyle='none', marker='', color='none')
3972                 # turn the fliers off just to be safe
3973                 showfliers = False
3974             # now process the symbol string
3975             else:
3976                 # process the symbol string
3977                 # discarded linestyle
3978                 _, marker, color = _process_plot_format(sym)
3979                 # if we have a marker, use it
3980                 if marker is not None:
3981                     flierprops['marker'] = marker
3982                 # if we have a color, use it
3983                 if color is not None:
3984                     # assume that if color is passed in the user want
3985                     # filled symbol, if the users want more control use
3986                     # flierprops
3987                     flierprops['color'] = color
3988                     flierprops['markerfacecolor'] = color
3989                     flierprops['markeredgecolor'] = color
3990 
3991         # replace medians if necessary:
3992         if usermedians is not None:
3993             if (len(np.ravel(usermedians)) != len(bxpstats) or
3994                     np.shape(usermedians)[0] != len(bxpstats)):
3995                 raise ValueError(
3996                     "'usermedians' and 'x' have different lengths")
3997             else:
3998                 # reassign medians as necessary
3999                 for stats, med in zip(bxpstats, usermedians):
4000                     if med is not None:
4001                         stats['med'] = med
4002 
4003         if conf_intervals is not None:
4004             if len(conf_intervals) != len(bxpstats):
4005                 raise ValueError(
4006                     "'conf_intervals' and 'x' have different lengths")
4007             else:
4008                 for stats, ci in zip(bxpstats, conf_intervals):
4009                     if ci is not None:
4010                         if len(ci) != 2:
4011                             raise ValueError('each confidence interval must '
4012                                              'have two values')
4013                         else:
4014                             if ci[0] is not None:
4015                                 stats['cilo'] = ci[0]
4016                             if ci[1] is not None:
4017                                 stats['cihi'] = ci[1]
4018 
4019         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4020                            vert=vert, patch_artist=patch_artist,
4021                            shownotches=notch, showmeans=showmeans,
4022                            showcaps=showcaps, showbox=showbox,
4023                            boxprops=boxprops, flierprops=flierprops,
4024                            medianprops=medianprops, meanprops=meanprops,
4025                            meanline=meanline, showfliers=showfliers,
4026                            capprops=capprops, whiskerprops=whiskerprops,
4027                            manage_ticks=manage_ticks, zorder=zorder,
4028                            capwidths=capwidths)
4029         return artists
4030 
4031     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4032             patch_artist=False, shownotches=False, showmeans=False,
4033             showcaps=True, showbox=True, showfliers=True,
4034             boxprops=None, whiskerprops=None, flierprops=None,
4035             medianprops=None, capprops=None, meanprops=None,
4036             meanline=False, manage_ticks=True, zorder=None,
4037             capwidths=None):
4038         """
4039         Drawing function for box and whisker plots.
4040 
4041         Make a box and whisker plot for each column of *x* or each
4042         vector in sequence *x*.  The box extends from the lower to
4043         upper quartile values of the data, with a line at the median.
4044         The whiskers extend from the box to show the range of the
4045         data.  Flier points are those past the end of the whiskers.
4046 
4047         Parameters
4048         ----------
4049         bxpstats : list of dicts
4050           A list of dictionaries containing stats for each boxplot.
4051           Required keys are:
4052 
4053           - ``med``: Median (scalar).
4054           - ``q1``, ``q3``: First & third quartiles (scalars).
4055           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4056 
4057           Optional keys are:
4058 
4059           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4060           - ``fliers``: Data beyond the whiskers (array-like).
4061             Needed if ``showfliers=True``.
4062           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4063             about the median. Needed if ``shownotches=True``.
4064           - ``label``: Name of the dataset (str).  If available,
4065             this will be used a tick label for the boxplot
4066 
4067         positions : array-like, default: [1, 2, ..., n]
4068           The positions of the boxes. The ticks and limits
4069           are automatically set to match the positions.
4070 
4071         widths : float or array-like, default: None
4072           The widths of the boxes.  The default is
4073           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4074 
4075         capwidths : float or array-like, default: None
4076           Either a scalar or a vector and sets the width of each cap.
4077           The default is ``0.5*(with of the box)``, see *widths*.
4078 
4079         vert : bool, default: True
4080           If `True` (default), makes the boxes vertical.
4081           If `False`, makes horizontal boxes.
4082 
4083         patch_artist : bool, default: False
4084           If `False` produces boxes with the `.Line2D` artist.
4085           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4086 
4087         shownotches, showmeans, showcaps, showbox, showfliers : bool
4088           Whether to draw the CI notches, the mean value (both default to
4089           False), the caps, the box, and the fliers (all three default to
4090           True).
4091 
4092         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4093  dict, optional
4094           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4095           means.
4096 
4097         meanline : bool, default: False
4098           If `True` (and *showmeans* is `True`), will try to render the mean
4099           as a line spanning the full width of the box according to
4100           *meanprops*. Not recommended if *shownotches* is also True.
4101           Otherwise, means will be shown as points.
4102 
4103         manage_ticks : bool, default: True
4104           If True, the tick locations and labels will be adjusted to match the
4105           boxplot positions.
4106 
4107         zorder : float, default: ``Line2D.zorder = 2``
4108           The zorder of the resulting boxplot.
4109 
4110         Returns
4111         -------
4112         dict
4113           A dictionary mapping each component of the boxplot to a list
4114           of the `.Line2D` instances created. That dictionary has the
4115           following keys (assuming vertical boxplots):
4116 
4117           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4118             the median's confidence intervals if enabled.
4119           - ``medians``: horizontal lines at the median of each box.
4120           - ``whiskers``: vertical lines up to the last non-outlier data.
4121           - ``caps``: horizontal lines at the ends of the whiskers.
4122           - ``fliers``: points representing data beyond the whiskers (fliers).
4123           - ``means``: points or lines representing the means.
4124 
4125         Examples
4126         --------
4127         .. plot:: gallery/statistics/bxp.py
4128         """
4129 
4130         # lists of artists to be output
4131         whiskers = []
4132         caps = []
4133         boxes = []
4134         medians = []
4135         means = []
4136         fliers = []
4137 
4138         # empty list of xticklabels
4139         datalabels = []
4140 
4141         # Use default zorder if none specified
4142         if zorder is None:
4143             zorder = mlines.Line2D.zorder
4144 
4145         zdelta = 0.1
4146 
4147         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4148             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4149                  if k.startswith(f'boxplot.{subkey}props')}
4150             d['zorder'] = zorder + zdelta
4151             if not usemarker:
4152                 d['marker'] = ''
4153             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4154             return d
4155 
4156         box_kw = {
4157             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4158             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4159             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4160             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4161                           else mpl.rcParams['patch.facecolor']),
4162             'zorder': zorder,
4163             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4164         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4165         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4166         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4167         flier_kw = merge_kw_rc('flier', flierprops)
4168         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4169         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4170         removed_prop = 'marker' if meanline else 'linestyle'
4171         # Only remove the property if it's not set explicitly as a parameter.
4172         if meanprops is None or removed_prop not in meanprops:
4173             mean_kw[removed_prop] = ''
4174 
4175         # vertical or horizontal plot?
4176         maybe_swap = slice(None) if vert else slice(None, None, -1)
4177 
4178         def do_plot(xs, ys, **kwargs):
4179             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4180 
4181         def do_patch(xs, ys, **kwargs):
4182             path = mpath.Path._create_closed(
4183                 np.column_stack([xs, ys][maybe_swap]))
4184             patch = mpatches.PathPatch(path, **kwargs)
4185             self.add_artist(patch)
4186             return patch
4187 
4188         # input validation
4189         N = len(bxpstats)
4190         datashape_message = ("List of boxplot statistics and `{0}` "
4191                              "values must have same the length")
4192         # check position
4193         if positions is None:
4194             positions = list(range(1, N + 1))
4195         elif len(positions) != N:
4196             raise ValueError(datashape_message.format("positions"))
4197 
4198         positions = np.array(positions)
4199         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4200             raise TypeError("positions should be an iterable of numbers")
4201 
4202         # width
4203         if widths is None:
4204             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4205         elif np.isscalar(widths):
4206             widths = [widths] * N
4207         elif len(widths) != N:
4208             raise ValueError(datashape_message.format("widths"))
4209 
4210         # capwidth
4211         if capwidths is None:
4212             capwidths = 0.5 * np.array(widths)
4213         elif np.isscalar(capwidths):
4214             capwidths = [capwidths] * N
4215         elif len(capwidths) != N:
4216             raise ValueError(datashape_message.format("capwidths"))
4217 
4218         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4219                                                capwidths):
4220             # try to find a new label
4221             datalabels.append(stats.get('label', pos))
4222 
4223             # whisker coords
4224             whis_x = [pos, pos]
4225             whislo_y = [stats['q1'], stats['whislo']]
4226             whishi_y = [stats['q3'], stats['whishi']]
4227             # cap coords
4228             cap_left = pos - capwidth * 0.5
4229             cap_right = pos + capwidth * 0.5
4230             cap_x = [cap_left, cap_right]
4231             cap_lo = np.full(2, stats['whislo'])
4232             cap_hi = np.full(2, stats['whishi'])
4233             # box and median coords
4234             box_left = pos - width * 0.5
4235             box_right = pos + width * 0.5
4236             med_y = [stats['med'], stats['med']]
4237             # notched boxes
4238             if shownotches:
4239                 notch_left = pos - width * 0.25
4240                 notch_right = pos + width * 0.25
4241                 box_x = [box_left, box_right, box_right, notch_right,
4242                          box_right, box_right, box_left, box_left, notch_left,
4243                          box_left, box_left]
4244                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4245                          stats['med'], stats['cihi'], stats['q3'],
4246                          stats['q3'], stats['cihi'], stats['med'],
4247                          stats['cilo'], stats['q1']]
4248                 med_x = [notch_left, notch_right]
4249             # plain boxes
4250             else:
4251                 box_x = [box_left, box_right, box_right, box_left, box_left]
4252                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4253                          stats['q1']]
4254                 med_x = [box_left, box_right]
4255 
4256             # maybe draw the box
4257             if showbox:
4258                 do_box = do_patch if patch_artist else do_plot
4259                 boxes.append(do_box(box_x, box_y, **box_kw))
4260             # draw the whiskers
4261             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4262             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4263             # maybe draw the caps
4264             if showcaps:
4265                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4266                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4267             # draw the medians
4268             medians.append(do_plot(med_x, med_y, **median_kw))
4269             # maybe draw the means
4270             if showmeans:
4271                 if meanline:
4272                     means.append(do_plot(
4273                         [box_left, box_right], [stats['mean'], stats['mean']],
4274                         **mean_kw
4275                     ))
4276                 else:
4277                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4278             # maybe draw the fliers
4279             if showfliers:
4280                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4281                 flier_y = stats['fliers']
4282                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4283 
4284         if manage_ticks:
4285             axis_name = "x" if vert else "y"
4286             interval = getattr(self.dataLim, f"interval{axis_name}")
4287             axis = self._axis_map[axis_name]
4288             positions = axis.convert_units(positions)
4289             # The 0.5 additional padding ensures reasonable-looking boxes
4290             # even when drawing a single box.  We set the sticky edge to
4291             # prevent margins expansion, in order to match old behavior (back
4292             # when separate calls to boxplot() would completely reset the axis
4293             # limits regardless of what was drawn before).  The sticky edges
4294             # are attached to the median lines, as they are always present.
4295             interval[:] = (min(interval[0], min(positions) - .5),
4296                            max(interval[1], max(positions) + .5))
4297             for median, position in zip(medians, positions):
4298                 getattr(median.sticky_edges, axis_name).extend(
4299                     [position - .5, position + .5])
4300             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4301             locator = axis.get_major_locator()
4302             if not isinstance(axis.get_major_locator(),
4303                               mticker.FixedLocator):
4304                 locator = mticker.FixedLocator([])
4305                 axis.set_major_locator(locator)
4306             locator.locs = np.array([*locator.locs, *positions])
4307             formatter = axis.get_major_formatter()
4308             if not isinstance(axis.get_major_formatter(),
4309                               mticker.FixedFormatter):
4310                 formatter = mticker.FixedFormatter([])
4311                 axis.set_major_formatter(formatter)
4312             formatter.seq = [*formatter.seq, *datalabels]
4313 
4314             self._request_autoscale_view()
4315 
4316         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4317                     medians=medians, fliers=fliers, means=means)
4318 
4319     @staticmethod
4320     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4321                                   get_next_color_func):
4322         """
4323         Helper function to process color related arguments of `.Axes.scatter`.
4324 
4325         Argument precedence for facecolors:
4326 
4327         - c (if not None)
4328         - kwargs['facecolor']
4329         - kwargs['facecolors']
4330         - kwargs['color'] (==kwcolor)
4331         - 'b' if in classic mode else the result of ``get_next_color_func()``
4332 
4333         Argument precedence for edgecolors:
4334 
4335         - kwargs['edgecolor']
4336         - edgecolors (is an explicit kw argument in scatter())
4337         - kwargs['color'] (==kwcolor)
4338         - 'face' if not in classic mode else None
4339 
4340         Parameters
4341         ----------
4342         c : color or sequence or sequence of color or None
4343             See argument description of `.Axes.scatter`.
4344         edgecolors : color or sequence of color or {'face', 'none'} or None
4345             See argument description of `.Axes.scatter`.
4346         kwargs : dict
4347             Additional kwargs. If these keys exist, we pop and process them:
4348             'facecolors', 'facecolor', 'edgecolor', 'color'
4349             Note: The dict is modified by this function.
4350         xsize : int
4351             The size of the x and y arrays passed to `.Axes.scatter`.
4352         get_next_color_func : callable
4353             A callable that returns a color. This color is used as facecolor
4354             if no other color is provided.
4355 
4356             Note, that this is a function rather than a fixed color value to
4357             support conditional evaluation of the next color.  As of the
4358             current implementation obtaining the next color from the
4359             property cycle advances the cycle. This must only happen if we
4360             actually use the color, which will only be decided within this
4361             method.
4362 
4363         Returns
4364         -------
4365         c
4366             The input *c* if it was not *None*, else a color derived from the
4367             other inputs or defaults.
4368         colors : array(N, 4) or None
4369             The facecolors as RGBA values, or *None* if a colormap is used.
4370         edgecolors
4371             The edgecolor.
4372 
4373         """
4374         facecolors = kwargs.pop('facecolors', None)
4375         facecolors = kwargs.pop('facecolor', facecolors)
4376         edgecolors = kwargs.pop('edgecolor', edgecolors)
4377 
4378         kwcolor = kwargs.pop('color', None)
4379 
4380         if kwcolor is not None and c is not None:
4381             raise ValueError("Supply a 'c' argument or a 'color'"
4382                              " kwarg but not both; they differ but"
4383                              " their functionalities overlap.")
4384 
4385         if kwcolor is not None:
4386             try:
4387                 mcolors.to_rgba_array(kwcolor)
4388             except ValueError as err:
4389                 raise ValueError(
4390                     "'color' kwarg must be a color or sequence of color "
4391                     "specs.  For a sequence of values to be color-mapped, use "
4392                     "the 'c' argument instead.") from err
4393             if edgecolors is None:
4394                 edgecolors = kwcolor
4395             if facecolors is None:
4396                 facecolors = kwcolor
4397 
4398         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4399             edgecolors = mpl.rcParams['scatter.edgecolors']
4400 
4401         c_was_none = c is None
4402         if c is None:
4403             c = (facecolors if facecolors is not None
4404                  else "b" if mpl.rcParams['_internal.classic_mode']
4405                  else get_next_color_func())
4406         c_is_string_or_strings = (
4407             isinstance(c, str)
4408             or (np.iterable(c) and len(c) > 0
4409                 and isinstance(cbook._safe_first_finite(c), str)))
4410 
4411         def invalid_shape_exception(csize, xsize):
4412             return ValueError(
4413                 f"'c' argument has {csize} elements, which is inconsistent "
4414                 f"with 'x' and 'y' with size {xsize}.")
4415 
4416         c_is_mapped = False  # Unless proven otherwise below.
4417         valid_shape = True  # Unless proven otherwise below.
4418         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4419             try:  # First, does 'c' look suitable for value-mapping?
4420                 c = np.asanyarray(c, dtype=float)
4421             except ValueError:
4422                 pass  # Failed to convert to float array; must be color specs.
4423             else:
4424                 # handle the documented special case of a 2D array with 1
4425                 # row which as RGB(A) to broadcast.
4426                 if c.shape == (1, 4) or c.shape == (1, 3):
4427                     c_is_mapped = False
4428                     if c.size != xsize:
4429                         valid_shape = False
4430                 # If c can be either mapped values or an RGB(A) color, prefer
4431                 # the former if shapes match, the latter otherwise.
4432                 elif c.size == xsize:
4433                     c = c.ravel()
4434                     c_is_mapped = True
4435                 else:  # Wrong size; it must not be intended for mapping.
4436                     if c.shape in ((3,), (4,)):
4437                         _api.warn_external(
4438                             "*c* argument looks like a single numeric RGB or "
4439                             "RGBA sequence, which should be avoided as value-"
4440                             "mapping will have precedence in case its length "
4441                             "matches with *x* & *y*.  Please use the *color* "
4442                             "keyword-argument or provide a 2D array "
4443                             "with a single row if you intend to specify "
4444                             "the same RGB or RGBA value for all points.")
4445                     valid_shape = False
4446         if not c_is_mapped:
4447             try:  # Is 'c' acceptable as PathCollection facecolors?
4448                 colors = mcolors.to_rgba_array(c)
4449             except (TypeError, ValueError) as err:
4450                 if "RGBA values should be within 0-1 range" in str(err):
4451                     raise
4452                 else:
4453                     if not valid_shape:
4454                         raise invalid_shape_exception(c.size, xsize) from err
4455                     # Both the mapping *and* the RGBA conversion failed: pretty
4456                     # severe failure => one may appreciate a verbose feedback.
4457                     raise ValueError(
4458                         f"'c' argument must be a color, a sequence of colors, "
4459                         f"or a sequence of numbers, not {c!r}") from err
4460             else:
4461                 if len(colors) not in (0, 1, xsize):
4462                     # NB: remember that a single color is also acceptable.
4463                     # Besides *colors* will be an empty array if c == 'none'.
4464                     raise invalid_shape_exception(len(colors), xsize)
4465         else:
4466             colors = None  # use cmap, norm after collection is created
4467         return c, colors, edgecolors
4468 
4469     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4470                                      "edgecolors", "c", "facecolor",
4471                                      "facecolors", "color"],
4472                       label_namer="y")
4473     @_docstring.interpd
4474     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4475                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4476                 edgecolors=None, plotnonfinite=False, **kwargs):
4477         """
4478         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4479 
4480         Parameters
4481         ----------
4482         x, y : float or array-like, shape (n, )
4483             The data positions.
4484 
4485         s : float or array-like, shape (n, ), optional
4486             The marker size in points**2 (typographic points are 1/72 in.).
4487             Default is ``rcParams['lines.markersize'] ** 2``.
4488 
4489             The linewidth and edgecolor can visually interact with the marker
4490             size, and can lead to artifacts if the marker size is smaller than
4491             the linewidth.
4492 
4493             If the linewidth is greater than 0 and the edgecolor is anything
4494             but *'none'*, then the effective size of the marker will be
4495             increased by half the linewidth because the stroke will be centered
4496             on the edge of the shape.
4497 
4498             To eliminate the marker edge either set *linewidth=0* or
4499             *edgecolor='none'*.
4500 
4501         c : array-like or list of colors or color, optional
4502             The marker colors. Possible values:
4503 
4504             - A scalar or sequence of n numbers to be mapped to colors using
4505               *cmap* and *norm*.
4506             - A 2D array in which the rows are RGB or RGBA.
4507             - A sequence of colors of length n.
4508             - A single color format string.
4509 
4510             Note that *c* should not be a single numeric RGB or RGBA sequence
4511             because that is indistinguishable from an array of values to be
4512             colormapped. If you want to specify the same RGB or RGBA value for
4513             all points, use a 2D array with a single row.  Otherwise,
4514             value-matching will have precedence in case of a size matching with
4515             *x* and *y*.
4516 
4517             If you wish to specify a single color for all points
4518             prefer the *color* keyword argument.
4519 
4520             Defaults to `None`. In that case the marker color is determined
4521             by the value of *color*, *facecolor* or *facecolors*. In case
4522             those are not specified or `None`, the marker color is determined
4523             by the next color of the ``Axes``' current "shape and fill" color
4524             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4525 
4526         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4527             The marker style. *marker* can be either an instance of the class
4528             or the text shorthand for a particular marker.
4529             See :mod:`matplotlib.markers` for more information about marker
4530             styles.
4531 
4532         %(cmap_doc)s
4533 
4534             This parameter is ignored if *c* is RGB(A).
4535 
4536         %(norm_doc)s
4537 
4538             This parameter is ignored if *c* is RGB(A).
4539 
4540         %(vmin_vmax_doc)s
4541 
4542             This parameter is ignored if *c* is RGB(A).
4543 
4544         alpha : float, default: None
4545             The alpha blending value, between 0 (transparent) and 1 (opaque).
4546 
4547         linewidths : float or array-like, default: :rc:`lines.linewidth`
4548             The linewidth of the marker edges. Note: The default *edgecolors*
4549             is 'face'. You may want to change this as well.
4550 
4551         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4552 default: :rc:`scatter.edgecolors`
4553             The edge color of the marker. Possible values:
4554 
4555             - 'face': The edge color will always be the same as the face color.
4556             - 'none': No patch boundary will be drawn.
4557             - A color or sequence of colors.
4558 
4559             For non-filled markers, *edgecolors* is ignored. Instead, the color
4560             is determined like with 'face', i.e. from *c*, *colors*, or
4561             *facecolors*.
4562 
4563         plotnonfinite : bool, default: False
4564             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4565             or ``nan``). If ``True`` the points are drawn with the *bad*
4566             colormap color (see `.Colormap.set_bad`).
4567 
4568         Returns
4569         -------
4570         `~matplotlib.collections.PathCollection`
4571 
4572         Other Parameters
4573         ----------------
4574         data : indexable object, optional
4575             DATA_PARAMETER_PLACEHOLDER
4576         **kwargs : `~matplotlib.collections.Collection` properties
4577 
4578         See Also
4579         --------
4580         plot : To plot scatter plots when markers are identical in size and
4581             color.
4582 
4583         Notes
4584         -----
4585         * The `.plot` function will be faster for scatterplots where markers
4586           don't vary in size or color.
4587 
4588         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4589           case all masks will be combined and only unmasked points will be
4590           plotted.
4591 
4592         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4593           may be input as N-D arrays, but within scatter they will be
4594           flattened. The exception is *c*, which will be flattened only if its
4595           size matches the size of *x* and *y*.
4596 
4597         """
4598         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4599         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4600         # np.ma.ravel yields an ndarray, not a masked array,
4601         # unless its argument is a masked array.
4602         x = np.ma.ravel(x)
4603         y = np.ma.ravel(y)
4604         if x.size != y.size:
4605             raise ValueError("x and y must be the same size")
4606 
4607         if s is None:
4608             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4609                  mpl.rcParams['lines.markersize'] ** 2.0)
4610         s = np.ma.ravel(s)
4611         if (len(s) not in (1, x.size) or
4612                 (not np.issubdtype(s.dtype, np.floating) and
4613                  not np.issubdtype(s.dtype, np.integer))):
4614             raise ValueError(
4615                 "s must be a scalar, "
4616                 "or float array-like with the same size as x and y")
4617 
4618         # get the original edgecolor the user passed before we normalize
4619         orig_edgecolor = edgecolors
4620         if edgecolors is None:
4621             orig_edgecolor = kwargs.get('edgecolor', None)
4622         c, colors, edgecolors = \
4623             self._parse_scatter_color_args(
4624                 c, edgecolors, kwargs, x.size,
4625                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4626 
4627         if plotnonfinite and colors is None:
4628             c = np.ma.masked_invalid(c)
4629             x, y, s, edgecolors, linewidths = \
4630                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4631         else:
4632             x, y, s, c, colors, edgecolors, linewidths = \
4633                 cbook._combine_masks(
4634                     x, y, s, c, colors, edgecolors, linewidths)
4635         # Unmask edgecolors if it was actually a single RGB or RGBA.
4636         if (x.size in (3, 4)
4637                 and np.ma.is_masked(edgecolors)
4638                 and not np.ma.is_masked(orig_edgecolor)):
4639             edgecolors = edgecolors.data
4640 
4641         scales = s   # Renamed for readability below.
4642 
4643         # load default marker from rcParams
4644         if marker is None:
4645             marker = mpl.rcParams['scatter.marker']
4646 
4647         if isinstance(marker, mmarkers.MarkerStyle):
4648             marker_obj = marker
4649         else:
4650             marker_obj = mmarkers.MarkerStyle(marker)
4651 
4652         path = marker_obj.get_path().transformed(
4653             marker_obj.get_transform())
4654         if not marker_obj.is_filled():
4655             if orig_edgecolor is not None:
4656                 _api.warn_external(
4657                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4658                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4659                     "ignoring the edgecolor in favor of the facecolor.  This "
4660                     "behavior may change in the future."
4661                 )
4662             # We need to handle markers that cannot be filled (like
4663             # '+' and 'x') differently than markers that can be
4664             # filled, but have their fillstyle set to 'none'.  This is
4665             # to get:
4666             #
4667             #  - respecting the fillestyle if set
4668             #  - maintaining back-compatibility for querying the facecolor of
4669             #    the un-fillable markers.
4670             #
4671             # While not an ideal situation, but is better than the
4672             # alternatives.
4673             if marker_obj.get_fillstyle() == 'none':
4674                 # promote the facecolor to be the edgecolor
4675                 edgecolors = colors
4676                 # set the facecolor to 'none' (at the last chance) because
4677                 # we cannot fill a path if the facecolor is non-null
4678                 # (which is defendable at the renderer level).
4679                 colors = 'none'
4680             else:
4681                 # if we are not nulling the face color we can do this
4682                 # simpler
4683                 edgecolors = 'face'
4684 
4685             if linewidths is None:
4686                 linewidths = mpl.rcParams['lines.linewidth']
4687             elif np.iterable(linewidths):
4688                 linewidths = [
4689                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4690                     for lw in linewidths]
4691 
4692         offsets = np.ma.column_stack([x, y])
4693 
4694         collection = mcoll.PathCollection(
4695             (path,), scales,
4696             facecolors=colors,
4697             edgecolors=edgecolors,
4698             linewidths=linewidths,
4699             offsets=offsets,
4700             offset_transform=kwargs.pop('transform', self.transData),
4701             alpha=alpha,
4702         )
4703         collection.set_transform(mtransforms.IdentityTransform())
4704         if colors is None:
4705             collection.set_array(c)
4706             collection.set_cmap(cmap)
4707             collection.set_norm(norm)
4708             collection._scale_norm(norm, vmin, vmax)
4709         else:
4710             extra_kwargs = {
4711                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4712                     }
4713             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4714             if any(extra_keys):
4715                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4716                 _api.warn_external(
4717                     "No data for colormapping provided via 'c'. "
4718                     f"Parameters {keys_str} will be ignored")
4719         collection._internal_update(kwargs)
4720 
4721         # Classic mode only:
4722         # ensure there are margins to allow for the
4723         # finite size of the symbols.  In v2.x, margins
4724         # are present by default, so we disable this
4725         # scatter-specific override.
4726         if mpl.rcParams['_internal.classic_mode']:
4727             if self._xmargin < 0.05 and x.size > 0:
4728                 self.set_xmargin(0.05)
4729             if self._ymargin < 0.05 and x.size > 0:
4730                 self.set_ymargin(0.05)
4731 
4732         self.add_collection(collection)
4733         self._request_autoscale_view()
4734 
4735         return collection
4736 
4737     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4738     @_docstring.dedent_interpd
4739     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4740                xscale='linear', yscale='linear', extent=None,
4741                cmap=None, norm=None, vmin=None, vmax=None,
4742                alpha=None, linewidths=None, edgecolors='face',
4743                reduce_C_function=np.mean, mincnt=None, marginals=False,
4744                **kwargs):
4745         """
4746         Make a 2D hexagonal binning plot of points *x*, *y*.
4747 
4748         If *C* is *None*, the value of the hexagon is determined by the number
4749         of points in the hexagon. Otherwise, *C* specifies values at the
4750         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4751         using *reduce_C_function*.
4752 
4753         Parameters
4754         ----------
4755         x, y : array-like
4756             The data positions. *x* and *y* must be of the same length.
4757 
4758         C : array-like, optional
4759             If given, these values are accumulated in the bins. Otherwise,
4760             every point has a value of 1. Must be of the same length as *x*
4761             and *y*.
4762 
4763         gridsize : int or (int, int), default: 100
4764             If a single int, the number of hexagons in the *x*-direction.
4765             The number of hexagons in the *y*-direction is chosen such that
4766             the hexagons are approximately regular.
4767 
4768             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4769             in the *x*-direction and the *y*-direction. In the
4770             *y*-direction, counting is done along vertically aligned
4771             hexagons, not along the zig-zag chains of hexagons; see the
4772             following illustration.
4773 
4774             .. plot::
4775 
4776                import numpy
4777                import matplotlib.pyplot as plt
4778 
4779                np.random.seed(19680801)
4780                n= 300
4781                x = np.random.standard_normal(n)
4782                y = np.random.standard_normal(n)
4783 
4784                fig, ax = plt.subplots(figsize=(4, 4))
4785                h = ax.hexbin(x, y, gridsize=(5, 3))
4786                hx, hy = h.get_offsets().T
4787                ax.plot(hx[24::3], hy[24::3], 'ro-')
4788                ax.plot(hx[-3:], hy[-3:], 'ro-')
4789                ax.set_title('gridsize=(5, 3)')
4790                ax.axis('off')
4791 
4792             To get approximately regular hexagons, choose
4793             :math:`n_x = \\sqrt{3}\\,n_y`.
4794 
4795         bins : 'log' or int or sequence, default: None
4796             Discretization of the hexagon values.
4797 
4798             - If *None*, no binning is applied; the color of each hexagon
4799               directly corresponds to its count value.
4800             - If 'log', use a logarithmic scale for the colormap.
4801               Internally, :math:`log_{10}(i+1)` is used to determine the
4802               hexagon color. This is equivalent to ``norm=LogNorm()``.
4803             - If an integer, divide the counts in the specified number
4804               of bins, and color the hexagons accordingly.
4805             - If a sequence of values, the values of the lower bound of
4806               the bins to be used.
4807 
4808         xscale : {'linear', 'log'}, default: 'linear'
4809             Use a linear or log10 scale on the horizontal axis.
4810 
4811         yscale : {'linear', 'log'}, default: 'linear'
4812             Use a linear or log10 scale on the vertical axis.
4813 
4814         mincnt : int > 0, default: *None*
4815             If not *None*, only display cells with more than *mincnt*
4816             number of points in the cell.
4817 
4818         marginals : bool, default: *False*
4819             If marginals is *True*, plot the marginal density as
4820             colormapped rectangles along the bottom of the x-axis and
4821             left of the y-axis.
4822 
4823         extent : 4-tuple of float, default: *None*
4824             The limits of the bins (xmin, xmax, ymin, ymax).
4825             The default assigns the limits based on
4826             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4827 
4828             If *xscale* or *yscale* is set to 'log', the limits are
4829             expected to be the exponent for a power of 10. E.g. for
4830             x-limits of 1 and 50 in 'linear' scale and y-limits
4831             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4832 
4833         Returns
4834         -------
4835         `~matplotlib.collections.PolyCollection`
4836             A `.PolyCollection` defining the hexagonal bins.
4837 
4838             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4839               the x, y positions of the M hexagon centers.
4840             - `.PolyCollection.get_array` contains the values of the M
4841               hexagons.
4842 
4843             If *marginals* is *True*, horizontal
4844             bar and vertical bar (both PolyCollections) will be attached
4845             to the return collection as attributes *hbar* and *vbar*.
4846 
4847         Other Parameters
4848         ----------------
4849         %(cmap_doc)s
4850 
4851         %(norm_doc)s
4852 
4853         %(vmin_vmax_doc)s
4854 
4855         alpha : float between 0 and 1, optional
4856             The alpha blending value, between 0 (transparent) and 1 (opaque).
4857 
4858         linewidths : float, default: *None*
4859             If *None*, defaults to 1.0.
4860 
4861         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4862             The color of the hexagon edges. Possible values are:
4863 
4864             - 'face': Draw the edges in the same color as the fill color.
4865             - 'none': No edges are drawn. This can sometimes lead to unsightly
4866               unpainted pixels between the hexagons.
4867             - *None*: Draw outlines in the default color.
4868             - An explicit color.
4869 
4870         reduce_C_function : callable, default: `numpy.mean`
4871             The function to aggregate *C* within the bins. It is ignored if
4872             *C* is not given. This must have the signature::
4873 
4874                 def reduce_C_function(C: array) -> float
4875 
4876             Commonly used functions are:
4877 
4878             - `numpy.mean`: average of the points
4879             - `numpy.sum`: integral of the point values
4880             - `numpy.amax`: value taken from the largest point
4881 
4882         data : indexable object, optional
4883             DATA_PARAMETER_PLACEHOLDER
4884 
4885         **kwargs : `~matplotlib.collections.PolyCollection` properties
4886             All other keyword arguments are passed on to `.PolyCollection`:
4887 
4888             %(PolyCollection:kwdoc)s
4889 
4890         See Also
4891         --------
4892         hist2d : 2D histogram rectangular bins
4893         """
4894         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4895 
4896         x, y, C = cbook.delete_masked_points(x, y, C)
4897 
4898         # Set the size of the hexagon grid
4899         if np.iterable(gridsize):
4900             nx, ny = gridsize
4901         else:
4902             nx = gridsize
4903             ny = int(nx / math.sqrt(3))
4904         # Count the number of data in each hexagon
4905         x = np.asarray(x, float)
4906         y = np.asarray(y, float)
4907 
4908         # Will be log()'d if necessary, and then rescaled.
4909         tx = x
4910         ty = y
4911 
4912         if xscale == 'log':
4913             if np.any(x <= 0.0):
4914                 raise ValueError(
4915                     "x contains non-positive values, so cannot be log-scaled")
4916             tx = np.log10(tx)
4917         if yscale == 'log':
4918             if np.any(y <= 0.0):
4919                 raise ValueError(
4920                     "y contains non-positive values, so cannot be log-scaled")
4921             ty = np.log10(ty)
4922         if extent is not None:
4923             xmin, xmax, ymin, ymax = extent
4924         else:
4925             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4926             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4927 
4928             # to avoid issues with singular data, expand the min/max pairs
4929             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4930             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4931 
4932         nx1 = nx + 1
4933         ny1 = ny + 1
4934         nx2 = nx
4935         ny2 = ny
4936         n = nx1 * ny1 + nx2 * ny2
4937 
4938         # In the x-direction, the hexagons exactly cover the region from
4939         # xmin to xmax. Need some padding to avoid roundoff errors.
4940         padding = 1.e-9 * (xmax - xmin)
4941         xmin -= padding
4942         xmax += padding
4943         sx = (xmax - xmin) / nx
4944         sy = (ymax - ymin) / ny
4945         # Positions in hexagon index coordinates.
4946         ix = (tx - xmin) / sx
4947         iy = (ty - ymin) / sy
4948         ix1 = np.round(ix).astype(int)
4949         iy1 = np.round(iy).astype(int)
4950         ix2 = np.floor(ix).astype(int)
4951         iy2 = np.floor(iy).astype(int)
4952         # flat indices, plus one so that out-of-range points go to position 0.
4953         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4954                       ix1 * ny1 + iy1 + 1, 0)
4955         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4956                       ix2 * ny2 + iy2 + 1, 0)
4957 
4958         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4959         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4960         bdist = (d1 < d2)
4961 
4962         if C is None:  # [1:] drops out-of-range points.
4963             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4964             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4965             accum = np.concatenate([counts1, counts2]).astype(float)
4966             if mincnt is not None:
4967                 accum[accum < mincnt] = np.nan
4968             C = np.ones(len(x))
4969         else:
4970             # store the C values in a list per hexagon index
4971             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4972             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4973             for i in range(len(x)):
4974                 if bdist[i]:
4975                     Cs_at_i1[i1[i]].append(C[i])
4976                 else:
4977                     Cs_at_i2[i2[i]].append(C[i])
4978             if mincnt is None:
4979                 mincnt = 0
4980             accum = np.array(
4981                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4982                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4983                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4984                 float)
4985 
4986         good_idxs = ~np.isnan(accum)
4987 
4988         offsets = np.zeros((n, 2), float)
4989         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4990         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4991         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4992         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4993         offsets[:, 0] *= sx
4994         offsets[:, 1] *= sy
4995         offsets[:, 0] += xmin
4996         offsets[:, 1] += ymin
4997         # remove accumulation bins with no data
4998         offsets = offsets[good_idxs, :]
4999         accum = accum[good_idxs]
5000 
5001         polygon = [sx, sy / 3] * np.array(
5002             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5003 
5004         if linewidths is None:
5005             linewidths = [1.0]
5006 
5007         if xscale == 'log' or yscale == 'log':
5008             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5009             if xscale == 'log':
5010                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5011                 xmin = 10.0 ** xmin
5012                 xmax = 10.0 ** xmax
5013                 self.set_xscale(xscale)
5014             if yscale == 'log':
5015                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5016                 ymin = 10.0 ** ymin
5017                 ymax = 10.0 ** ymax
5018                 self.set_yscale(yscale)
5019             collection = mcoll.PolyCollection(
5020                 polygons,
5021                 edgecolors=edgecolors,
5022                 linewidths=linewidths,
5023                 )
5024         else:
5025             collection = mcoll.PolyCollection(
5026                 [polygon],
5027                 edgecolors=edgecolors,
5028                 linewidths=linewidths,
5029                 offsets=offsets,
5030                 offset_transform=mtransforms.AffineDeltaTransform(
5031                     self.transData),
5032             )
5033 
5034         # Set normalizer if bins is 'log'
5035         if bins == 'log':
5036             if norm is not None:
5037                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5038                                    f"can be supplied, ignoring bins={bins}")
5039             else:
5040                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5041                 vmin = vmax = None
5042             bins = None
5043 
5044         # autoscale the norm with current accum values if it hasn't been set
5045         if norm is not None:
5046             if norm.vmin is None and norm.vmax is None:
5047                 norm.autoscale(accum)
5048 
5049         if bins is not None:
5050             if not np.iterable(bins):
5051                 minimum, maximum = min(accum), max(accum)
5052                 bins -= 1  # one less edge than bins
5053                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5054             bins = np.sort(bins)
5055             accum = bins.searchsorted(accum)
5056 
5057         collection.set_array(accum)
5058         collection.set_cmap(cmap)
5059         collection.set_norm(norm)
5060         collection.set_alpha(alpha)
5061         collection._internal_update(kwargs)
5062         collection._scale_norm(norm, vmin, vmax)
5063 
5064         corners = ((xmin, ymin), (xmax, ymax))
5065         self.update_datalim(corners)
5066         self._request_autoscale_view(tight=True)
5067 
5068         # add the collection last
5069         self.add_collection(collection, autolim=False)
5070         if not marginals:
5071             return collection
5072 
5073         # Process marginals
5074         bars = []
5075         for zname, z, zmin, zmax, zscale, nbins in [
5076                 ("x", x, xmin, xmax, xscale, nx),
5077                 ("y", y, ymin, ymax, yscale, 2 * ny),
5078         ]:
5079 
5080             if zscale == "log":
5081                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5082             else:
5083                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5084 
5085             verts = np.empty((nbins, 4, 2))
5086             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5087             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5088             verts[:, 0, 1] = verts[:, 3, 1] = .00
5089             verts[:, 1, 1] = verts[:, 2, 1] = .05
5090             if zname == "y":
5091                 verts = verts[:, :, ::-1]  # Swap x and y.
5092 
5093             # Sort z-values into bins defined by bin_edges.
5094             bin_idxs = np.searchsorted(bin_edges, z) - 1
5095             values = np.empty(nbins)
5096             for i in range(nbins):
5097                 # Get C-values for each bin, and compute bin value with
5098                 # reduce_C_function.
5099                 ci = C[bin_idxs == i]
5100                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5101 
5102             mask = ~np.isnan(values)
5103             verts = verts[mask]
5104             values = values[mask]
5105 
5106             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5107             bar = mcoll.PolyCollection(
5108                 verts, transform=trans, edgecolors="face")
5109             bar.set_array(values)
5110             bar.set_cmap(cmap)
5111             bar.set_norm(norm)
5112             bar.set_alpha(alpha)
5113             bar._internal_update(kwargs)
5114             bars.append(self.add_collection(bar, autolim=False))
5115 
5116         collection.hbar, collection.vbar = bars
5117 
5118         def on_changed(collection):
5119             collection.hbar.set_cmap(collection.get_cmap())
5120             collection.hbar.set_cmap(collection.get_cmap())
5121             collection.vbar.set_clim(collection.get_clim())
5122             collection.vbar.set_clim(collection.get_clim())
5123 
5124         collection.callbacks.connect('changed', on_changed)
5125 
5126         return collection
5127 
5128     @_docstring.dedent_interpd
5129     def arrow(self, x, y, dx, dy, **kwargs):
5130         """
5131         Add an arrow to the Axes.
5132 
5133         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5134 
5135         Parameters
5136         ----------
5137         %(FancyArrow)s
5138 
5139         Returns
5140         -------
5141         `.FancyArrow`
5142             The created `.FancyArrow` object.
5143 
5144         Notes
5145         -----
5146         The resulting arrow is affected by the Axes aspect ratio and limits.
5147         This may produce an arrow whose head is not square with its stem. To
5148         create an arrow whose head is square with its stem,
5149         use :meth:`annotate` for example:
5150 
5151         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5152         ...             arrowprops=dict(arrowstyle="->"))
5153 
5154         """
5155         # Strip away units for the underlying patch since units
5156         # do not make sense to most patch-like code
5157         x = self.convert_xunits(x)
5158         y = self.convert_yunits(y)
5159         dx = self.convert_xunits(dx)
5160         dy = self.convert_yunits(dy)
5161 
5162         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5163         self.add_patch(a)
5164         self._request_autoscale_view()
5165         return a
5166 
5167     @_docstring.copy(mquiver.QuiverKey.__init__)
5168     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5169         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5170         self.add_artist(qk)
5171         return qk
5172 
5173     # Handle units for x and y, if they've been passed
5174     def _quiver_units(self, args, kwargs):
5175         if len(args) > 3:
5176             x, y = args[0:2]
5177             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5178             return (x, y) + args[2:]
5179         return args
5180 
5181     # args can be a combination of X, Y, U, V, C and all should be replaced
5182     @_preprocess_data()
5183     @_docstring.dedent_interpd
5184     def quiver(self, *args, **kwargs):
5185         """%(quiver_doc)s"""
5186         # Make sure units are handled for x and y values
5187         args = self._quiver_units(args, kwargs)
5188         q = mquiver.Quiver(self, *args, **kwargs)
5189         self.add_collection(q, autolim=True)
5190         self._request_autoscale_view()
5191         return q
5192 
5193     # args can be some combination of X, Y, U, V, C and all should be replaced
5194     @_preprocess_data()
5195     @_docstring.dedent_interpd
5196     def barbs(self, *args, **kwargs):
5197         """%(barbs_doc)s"""
5198         # Make sure units are handled for x and y values
5199         args = self._quiver_units(args, kwargs)
5200         b = mquiver.Barbs(self, *args, **kwargs)
5201         self.add_collection(b, autolim=True)
5202         self._request_autoscale_view()
5203         return b
5204 
5205     # Uses a custom implementation of data-kwarg handling in
5206     # _process_plot_var_args.
5207     def fill(self, *args, data=None, **kwargs):
5208         """
5209         Plot filled polygons.
5210 
5211         Parameters
5212         ----------
5213         *args : sequence of x, y, [color]
5214             Each polygon is defined by the lists of *x* and *y* positions of
5215             its nodes, optionally followed by a *color* specifier. See
5216             :mod:`matplotlib.colors` for supported color specifiers. The
5217             standard color cycle is used for polygons without a color
5218             specifier.
5219 
5220             You can plot multiple polygons by providing multiple *x*, *y*,
5221             *[color]* groups.
5222 
5223             For example, each of the following is legal::
5224 
5225                 ax.fill(x, y)                    # a polygon with default color
5226                 ax.fill(x, y, "b")               # a blue polygon
5227                 ax.fill(x, y, x2, y2)            # two polygons
5228                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5229 
5230         data : indexable object, optional
5231             An object with labelled data. If given, provide the label names to
5232             plot in *x* and *y*, e.g.::
5233 
5234                 ax.fill("time", "signal",
5235                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5236 
5237         Returns
5238         -------
5239         list of `~matplotlib.patches.Polygon`
5240 
5241         Other Parameters
5242         ----------------
5243         **kwargs : `~matplotlib.patches.Polygon` properties
5244 
5245         Notes
5246         -----
5247         Use :meth:`fill_between` if you would like to fill the region between
5248         two curves.
5249         """
5250         # For compatibility(!), get aliases from Line2D rather than Patch.
5251         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5252         # _get_patches_for_fill returns a generator, convert it to a list.
5253         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5254         for poly in patches:
5255             self.add_patch(poly)
5256         self._request_autoscale_view()
5257         return patches
5258 
5259     def _fill_between_x_or_y(
5260             self, ind_dir, ind, dep1, dep2=0, *,
5261             where=None, interpolate=False, step=None, **kwargs):
5262         # Common implementation between fill_between (*ind_dir*="x") and
5263         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5264         # *dep* the dependent variable.  The docstring below is interpolated
5265         # to generate both methods' docstrings.
5266         """
5267         Fill the area between two {dir} curves.
5268 
5269         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5270         *{dep}2*).  This creates one or multiple polygons describing the filled
5271         area.
5272 
5273         You may exclude some {dir} sections from filling using *where*.
5274 
5275         By default, the edges connect the given points directly.  Use *step*
5276         if the filling should be a step function, i.e. constant in between
5277         *{ind}*.
5278 
5279         Parameters
5280         ----------
5281         {ind} : array (length N)
5282             The {ind} coordinates of the nodes defining the curves.
5283 
5284         {dep}1 : array (length N) or scalar
5285             The {dep} coordinates of the nodes defining the first curve.
5286 
5287         {dep}2 : array (length N) or scalar, default: 0
5288             The {dep} coordinates of the nodes defining the second curve.
5289 
5290         where : array of bool (length N), optional
5291             Define *where* to exclude some {dir} regions from being filled.
5292             The filled regions are defined by the coordinates ``{ind}[where]``.
5293             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5294             ``where[i] and where[i+1]``.  Note that this definition implies
5295             that an isolated *True* value between two *False* values in *where*
5296             will not result in filling.  Both sides of the *True* position
5297             remain unfilled due to the adjacent *False* values.
5298 
5299         interpolate : bool, default: False
5300             This option is only relevant if *where* is used and the two curves
5301             are crossing each other.
5302 
5303             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5304             similar.  By default, the nodes of the polygon defining the filled
5305             region will only be placed at the positions in the *{ind}* array.
5306             Such a polygon cannot describe the above semantics close to the
5307             intersection.  The {ind}-sections containing the intersection are
5308             simply clipped.
5309 
5310             Setting *interpolate* to *True* will calculate the actual
5311             intersection point and extend the filled region up to this point.
5312 
5313         step : {{'pre', 'post', 'mid'}}, optional
5314             Define *step* if the filling should be a step function,
5315             i.e. constant in between *{ind}*.  The value determines where the
5316             step will occur:
5317 
5318             - 'pre': The y value is continued constantly to the left from
5319               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5320               value ``y[i]``.
5321             - 'post': The y value is continued constantly to the right from
5322               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5323               value ``y[i]``.
5324             - 'mid': Steps occur half-way between the *x* positions.
5325 
5326         Returns
5327         -------
5328         `.PolyCollection`
5329             A `.PolyCollection` containing the plotted polygons.
5330 
5331         Other Parameters
5332         ----------------
5333         data : indexable object, optional
5334             DATA_PARAMETER_PLACEHOLDER
5335 
5336         **kwargs
5337             All other keyword arguments are passed on to `.PolyCollection`.
5338             They control the `.Polygon` properties:
5339 
5340             %(PolyCollection:kwdoc)s
5341 
5342         See Also
5343         --------
5344         fill_between : Fill between two sets of y-values.
5345         fill_betweenx : Fill between two sets of x-values.
5346         """
5347 
5348         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5349 
5350         if not mpl.rcParams["_internal.classic_mode"]:
5351             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5352             if not any(c in kwargs for c in ("color", "facecolor")):
5353                 kwargs["facecolor"] = \
5354                     self._get_patches_for_fill.get_next_color()
5355 
5356         # Handle united data, such as dates
5357         ind, dep1, dep2 = map(
5358             ma.masked_invalid, self._process_unit_info(
5359                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5360 
5361         for name, array in [
5362                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5363             if array.ndim > 1:
5364                 raise ValueError(f"{name!r} is not 1-dimensional")
5365 
5366         if where is None:
5367             where = True
5368         else:
5369             where = np.asarray(where, dtype=bool)
5370             if where.size != ind.size:
5371                 raise ValueError(f"where size ({where.size}) does not match "
5372                                  f"{ind_dir} size ({ind.size})")
5373         where = where & ~functools.reduce(
5374             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5375 
5376         ind, dep1, dep2 = np.broadcast_arrays(
5377             np.atleast_1d(ind), dep1, dep2, subok=True)
5378 
5379         polys = []
5380         for idx0, idx1 in cbook.contiguous_regions(where):
5381             indslice = ind[idx0:idx1]
5382             dep1slice = dep1[idx0:idx1]
5383             dep2slice = dep2[idx0:idx1]
5384             if step is not None:
5385                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5386                 indslice, dep1slice, dep2slice = \
5387                     step_func(indslice, dep1slice, dep2slice)
5388 
5389             if not len(indslice):
5390                 continue
5391 
5392             N = len(indslice)
5393             pts = np.zeros((2 * N + 2, 2))
5394 
5395             if interpolate:
5396                 def get_interp_point(idx):
5397                     im1 = max(idx - 1, 0)
5398                     ind_values = ind[im1:idx+1]
5399                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5400                     dep1_values = dep1[im1:idx+1]
5401 
5402                     if len(diff_values) == 2:
5403                         if np.ma.is_masked(diff_values[1]):
5404                             return ind[im1], dep1[im1]
5405                         elif np.ma.is_masked(diff_values[0]):
5406                             return ind[idx], dep1[idx]
5407 
5408                     diff_order = diff_values.argsort()
5409                     diff_root_ind = np.interp(
5410                         0, diff_values[diff_order], ind_values[diff_order])
5411                     ind_order = ind_values.argsort()
5412                     diff_root_dep = np.interp(
5413                         diff_root_ind,
5414                         ind_values[ind_order], dep1_values[ind_order])
5415                     return diff_root_ind, diff_root_dep
5416 
5417                 start = get_interp_point(idx0)
5418                 end = get_interp_point(idx1)
5419             else:
5420                 # Handle scalar dep2 (e.g. 0): the fill should go all
5421                 # the way down to 0 even if none of the dep1 sample points do.
5422                 start = indslice[0], dep2slice[0]
5423                 end = indslice[-1], dep2slice[-1]
5424 
5425             pts[0] = start
5426             pts[N + 1] = end
5427 
5428             pts[1:N+1, 0] = indslice
5429             pts[1:N+1, 1] = dep1slice
5430             pts[N+2:, 0] = indslice[::-1]
5431             pts[N+2:, 1] = dep2slice[::-1]
5432 
5433             if ind_dir == "y":
5434                 pts = pts[:, ::-1]
5435 
5436             polys.append(pts)
5437 
5438         collection = mcoll.PolyCollection(polys, **kwargs)
5439 
5440         # now update the datalim and autoscale
5441         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5442                             np.column_stack([ind[where], dep2[where]])])
5443         if ind_dir == "y":
5444             pts = pts[:, ::-1]
5445 
5446         up_x = up_y = True
5447         if "transform" in kwargs:
5448             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5449         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5450 
5451         self.add_collection(collection, autolim=False)
5452         self._request_autoscale_view()
5453         return collection
5454 
5455     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5456                      step=None, **kwargs):
5457         return self._fill_between_x_or_y(
5458             "x", x, y1, y2,
5459             where=where, interpolate=interpolate, step=step, **kwargs)
5460 
5461     if _fill_between_x_or_y.__doc__:
5462         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5463             dir="horizontal", ind="x", dep="y"
5464         )
5465     fill_between = _preprocess_data(
5466         _docstring.dedent_interpd(fill_between),
5467         replace_names=["x", "y1", "y2", "where"])
5468 
5469     def fill_betweenx(self, y, x1, x2=0, where=None,
5470                       step=None, interpolate=False, **kwargs):
5471         return self._fill_between_x_or_y(
5472             "y", y, x1, x2,
5473             where=where, interpolate=interpolate, step=step, **kwargs)
5474 
5475     if _fill_between_x_or_y.__doc__:
5476         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5477             dir="vertical", ind="y", dep="x"
5478         )
5479     fill_betweenx = _preprocess_data(
5480         _docstring.dedent_interpd(fill_betweenx),
5481         replace_names=["y", "x1", "x2", "where"])
5482 
5483     #### plotting z(x, y): imshow, pcolor and relatives, contour
5484 
5485     @_preprocess_data()
5486     @_docstring.interpd
5487     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5488                interpolation=None, alpha=None,
5489                vmin=None, vmax=None, origin=None, extent=None,
5490                interpolation_stage=None, filternorm=True, filterrad=4.0,
5491                resample=None, url=None, **kwargs):
5492         """
5493         Display data as an image, i.e., on a 2D regular raster.
5494 
5495         The input may either be actual RGB(A) data, or 2D scalar data, which
5496         will be rendered as a pseudocolor image. For displaying a grayscale
5497         image set up the colormapping using the parameters
5498         ``cmap='gray', vmin=0, vmax=255``.
5499 
5500         The number of pixels used to render an image is set by the Axes size
5501         and the *dpi* of the figure. This can lead to aliasing artifacts when
5502         the image is resampled because the displayed image size will usually
5503         not match the size of *X* (see
5504         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5505         The resampling can be controlled via the *interpolation* parameter
5506         and/or :rc:`image.interpolation`.
5507 
5508         Parameters
5509         ----------
5510         X : array-like or PIL image
5511             The image data. Supported array shapes are:
5512 
5513             - (M, N): an image with scalar data. The values are mapped to
5514               colors using normalization and a colormap. See parameters *norm*,
5515               *cmap*, *vmin*, *vmax*.
5516             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5517             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5518               i.e. including transparency.
5519 
5520             The first two dimensions (M, N) define the rows and columns of
5521             the image.
5522 
5523             Out-of-range RGB(A) values are clipped.
5524 
5525         %(cmap_doc)s
5526 
5527             This parameter is ignored if *X* is RGB(A).
5528 
5529         %(norm_doc)s
5530 
5531             This parameter is ignored if *X* is RGB(A).
5532 
5533         %(vmin_vmax_doc)s
5534 
5535             This parameter is ignored if *X* is RGB(A).
5536 
5537         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5538             The aspect ratio of the Axes.  This parameter is particularly
5539             relevant for images since it determines whether data pixels are
5540             square.
5541 
5542             This parameter is a shortcut for explicitly calling
5543             `.Axes.set_aspect`. See there for further details.
5544 
5545             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5546               (unless pixel sizes are explicitly made non-square in data
5547               coordinates using *extent*).
5548             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5549               that the data fit in the Axes. In general, this will result in
5550               non-square pixels.
5551 
5552         interpolation : str, default: :rc:`image.interpolation`
5553             The interpolation method used.
5554 
5555             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5556             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5557             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5558             'sinc', 'lanczos', 'blackman'.
5559 
5560             The data *X* is resampled to the pixel size of the image on the
5561             figure canvas, using the interpolation method to either up- or
5562             downsample the data.
5563 
5564             If *interpolation* is 'none', then for the ps, pdf, and svg
5565             backends no down- or upsampling occurs, and the image data is
5566             passed to the backend as a native image.  Note that different ps,
5567             pdf, and svg viewers may display these raw pixels differently. On
5568             other backends, 'none' is the same as 'nearest'.
5569 
5570             If *interpolation* is the default 'antialiased', then 'nearest'
5571             interpolation is used if the image is upsampled by more than a
5572             factor of three (i.e. the number of display pixels is at least
5573             three times the size of the data array).  If the upsampling rate is
5574             smaller than 3, or the image is downsampled, then 'hanning'
5575             interpolation is used to act as an anti-aliasing filter, unless the
5576             image happens to be upsampled by exactly a factor of two or one.
5577 
5578             See
5579             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5580             for an overview of the supported interpolation methods, and
5581             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5582             a discussion of image antialiasing.
5583 
5584             Some interpolation methods require an additional radius parameter,
5585             which can be set by *filterrad*. Additionally, the antigrain image
5586             resize filter is controlled by the parameter *filternorm*.
5587 
5588         interpolation_stage : {'data', 'rgba'}, default: 'data'
5589             If 'data', interpolation
5590             is carried out on the data provided by the user.  If 'rgba', the
5591             interpolation is carried out after the colormapping has been
5592             applied (visual interpolation).
5593 
5594         alpha : float or array-like, optional
5595             The alpha blending value, between 0 (transparent) and 1 (opaque).
5596             If *alpha* is an array, the alpha blending values are applied pixel
5597             by pixel, and *alpha* must have the same shape as *X*.
5598 
5599         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5600             Place the [0, 0] index of the array in the upper left or lower
5601             left corner of the Axes. The convention (the default) 'upper' is
5602             typically used for matrices and images.
5603 
5604             Note that the vertical axis points upward for 'lower'
5605             but downward for 'upper'.
5606 
5607             See the :ref:`imshow_extent` tutorial for
5608             examples and a more detailed description.
5609 
5610         extent : floats (left, right, bottom, top), optional
5611             The bounding box in data coordinates that the image will fill.
5612             These values may be unitful and match the units of the Axes.
5613             The image is stretched individually along x and y to fill the box.
5614 
5615             The default extent is determined by the following conditions.
5616             Pixels have unit size in data coordinates. Their centers are on
5617             integer coordinates, and their center coordinates range from 0 to
5618             columns-1 horizontally and from 0 to rows-1 vertically.
5619 
5620             Note that the direction of the vertical axis and thus the default
5621             values for top and bottom depend on *origin*:
5622 
5623             - For ``origin == 'upper'`` the default is
5624               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5625             - For ``origin == 'lower'`` the default is
5626               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5627 
5628             See the :ref:`imshow_extent` tutorial for
5629             examples and a more detailed description.
5630 
5631         filternorm : bool, default: True
5632             A parameter for the antigrain image resize filter (see the
5633             antigrain documentation).  If *filternorm* is set, the filter
5634             normalizes integer values and corrects the rounding errors. It
5635             doesn't do anything with the source floating point values, it
5636             corrects only integers according to the rule of 1.0 which means
5637             that any sum of pixel weights must be equal to 1.0.  So, the
5638             filter function must produce a graph of the proper shape.
5639 
5640         filterrad : float > 0, default: 4.0
5641             The filter radius for filters that have a radius parameter, i.e.
5642             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5643 
5644         resample : bool, default: :rc:`image.resample`
5645             When *True*, use a full resampling method.  When *False*, only
5646             resample when the output image is larger than the input image.
5647 
5648         url : str, optional
5649             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5650 
5651         Returns
5652         -------
5653         `~matplotlib.image.AxesImage`
5654 
5655         Other Parameters
5656         ----------------
5657         data : indexable object, optional
5658             DATA_PARAMETER_PLACEHOLDER
5659 
5660         **kwargs : `~matplotlib.artist.Artist` properties
5661             These parameters are passed on to the constructor of the
5662             `.AxesImage` artist.
5663 
5664         See Also
5665         --------
5666         matshow : Plot a matrix or an array as an image.
5667 
5668         Notes
5669         -----
5670         Unless *extent* is used, pixel centers will be located at integer
5671         coordinates. In other words: the origin will coincide with the center
5672         of pixel (0, 0).
5673 
5674         There are two common representations for RGB images with an alpha
5675         channel:
5676 
5677         -   Straight (unassociated) alpha: R, G, and B channels represent the
5678             color of the pixel, disregarding its opacity.
5679         -   Premultiplied (associated) alpha: R, G, and B channels represent
5680             the color of the pixel, adjusted for its opacity by multiplication.
5681 
5682         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5683         (unassociated) alpha representation.
5684         """
5685         if aspect is None:
5686             aspect = mpl.rcParams['image.aspect']
5687         self.set_aspect(aspect)
5688         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5689                               interpolation=interpolation, origin=origin,
5690                               extent=extent, filternorm=filternorm,
5691                               filterrad=filterrad, resample=resample,
5692                               interpolation_stage=interpolation_stage,
5693                               **kwargs)
5694 
5695         im.set_data(X)
5696         im.set_alpha(alpha)
5697         if im.get_clip_path() is None:
5698             # image does not already have clipping set, clip to axes patch
5699             im.set_clip_path(self.patch)
5700         im._scale_norm(norm, vmin, vmax)
5701         im.set_url(url)
5702 
5703         # update ax.dataLim, and, if autoscaling, set viewLim
5704         # to tightly fit the image, regardless of dataLim.
5705         im.set_extent(im.get_extent())
5706 
5707         self.add_image(im)
5708         return im
5709 
5710     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5711         # - create X and Y if not present;
5712         # - reshape X and Y as needed if they are 1-D;
5713         # - check for proper sizes based on `shading` kwarg;
5714         # - reset shading if shading='auto' to flat or nearest
5715         #   depending on size;
5716 
5717         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5718         try:
5719             _api.check_in_list(_valid_shading, shading=shading)
5720         except ValueError:
5721             _api.warn_external(f"shading value '{shading}' not in list of "
5722                                f"valid values {_valid_shading}. Setting "
5723                                "shading='auto'.")
5724             shading = 'auto'
5725 
5726         if len(args) == 1:
5727             C = np.asanyarray(args[0])
5728             nrows, ncols = C.shape[:2]
5729             if shading in ['gouraud', 'nearest']:
5730                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5731             else:
5732                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5733                 shading = 'flat'
5734             C = cbook.safe_masked_invalid(C)
5735             return X, Y, C, shading
5736 
5737         if len(args) == 3:
5738             # Check x and y for bad data...
5739             C = np.asanyarray(args[2])
5740             # unit conversion allows e.g. datetime objects as axis values
5741             X, Y = args[:2]
5742             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5743             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5744 
5745             if funcname == 'pcolormesh':
5746                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5747                     raise ValueError(
5748                         'x and y arguments to pcolormesh cannot have '
5749                         'non-finite values or be of type '
5750                         'numpy.ma.core.MaskedArray with masked values')
5751                 # safe_masked_invalid() returns an ndarray for dtypes other
5752                 # than floating point.
5753                 if isinstance(X, np.ma.core.MaskedArray):
5754                     X = X.data  # strip mask as downstream doesn't like it...
5755                 if isinstance(Y, np.ma.core.MaskedArray):
5756                     Y = Y.data
5757             nrows, ncols = C.shape[:2]
5758         else:
5759             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5760 
5761         Nx = X.shape[-1]
5762         Ny = Y.shape[0]
5763         if X.ndim != 2 or X.shape[0] == 1:
5764             x = X.reshape(1, Nx)
5765             X = x.repeat(Ny, axis=0)
5766         if Y.ndim != 2 or Y.shape[1] == 1:
5767             y = Y.reshape(Ny, 1)
5768             Y = y.repeat(Nx, axis=1)
5769         if X.shape != Y.shape:
5770             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5771                             f'see help({funcname})')
5772 
5773         if shading == 'auto':
5774             if ncols == Nx and nrows == Ny:
5775                 shading = 'nearest'
5776             else:
5777                 shading = 'flat'
5778 
5779         if shading == 'flat':
5780             if (Nx, Ny) != (ncols + 1, nrows + 1):
5781                 raise TypeError(f"Dimensions of C {C.shape} should"
5782                                 f" be one smaller than X({Nx}) and Y({Ny})"
5783                                 f" while using shading='flat'"
5784                                 f" see help({funcname})")
5785         else:    # ['nearest', 'gouraud']:
5786             if (Nx, Ny) != (ncols, nrows):
5787                 raise TypeError('Dimensions of C %s are incompatible with'
5788                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5789                                     C.shape, Nx, Ny, funcname))
5790             if shading == 'nearest':
5791                 # grid is specified at the center, so define corners
5792                 # at the midpoints between the grid centers and then use the
5793                 # flat algorithm.
5794                 def _interp_grid(X):
5795                     # helper for below
5796                     if np.shape(X)[1] > 1:
5797                         dX = np.diff(X, axis=1)/2.
5798                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5799                             _api.warn_external(
5800                                 f"The input coordinates to {funcname} are "
5801                                 "interpreted as cell centers, but are not "
5802                                 "monotonically increasing or decreasing. "
5803                                 "This may lead to incorrectly calculated cell "
5804                                 "edges, in which case, please supply "
5805                                 f"explicit cell edges to {funcname}.")
5806                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5807                                        X[:, :-1] + dX,
5808                                        X[:, [-1]] + dX[:, [-1]]))
5809                     else:
5810                         # This is just degenerate, but we can't reliably guess
5811                         # a dX if there is just one value.
5812                         X = np.hstack((X, X))
5813                     return X
5814 
5815                 if ncols == Nx:
5816                     X = _interp_grid(X)
5817                     Y = _interp_grid(Y)
5818                 if nrows == Ny:
5819                     X = _interp_grid(X.T).T
5820                     Y = _interp_grid(Y.T).T
5821                 shading = 'flat'
5822 
5823         C = cbook.safe_masked_invalid(C)
5824         return X, Y, C, shading
5825 
5826     @_preprocess_data()
5827     @_docstring.dedent_interpd
5828     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5829                vmin=None, vmax=None, **kwargs):
5830         r"""
5831         Create a pseudocolor plot with a non-regular rectangular grid.
5832 
5833         Call signature::
5834 
5835             pcolor([X, Y,] C, **kwargs)
5836 
5837         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5838 
5839         .. hint::
5840 
5841             ``pcolor()`` can be very slow for large arrays. In most
5842             cases you should use the similar but much faster
5843             `~.Axes.pcolormesh` instead. See
5844             :ref:`Differences between pcolor() and pcolormesh()
5845             <differences-pcolor-pcolormesh>` for a discussion of the
5846             differences.
5847 
5848         Parameters
5849         ----------
5850         C : 2D array-like
5851             The color-mapped values.  Color-mapping is controlled by *cmap*,
5852             *norm*, *vmin*, and *vmax*.
5853 
5854         X, Y : array-like, optional
5855             The coordinates of the corners of quadrilaterals of a pcolormesh::
5856 
5857                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5858                                       ●╶───╴●
5859                                       │     │
5860                                       ●╶───╴●
5861                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5862 
5863             Note that the column index corresponds to the x-coordinate, and
5864             the row index corresponds to y. For details, see the
5865             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5866 
5867             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5868             greater than those of *C*, and the quadrilateral is colored due
5869             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5870             dimensions, a warning will be raised and the last row and column
5871             of *C* will be ignored.
5872 
5873             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5874             the same as those of *C* (if not, a ValueError will be raised). The
5875             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5876 
5877             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5878             expanded as needed into the appropriate 2D arrays, making a
5879             rectangular grid.
5880 
5881         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5882             The fill style for the quadrilateral. Possible values:
5883 
5884             - 'flat': A solid color is used for each quad. The color of the
5885               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5886               ``C[i, j]``. The dimensions of *X* and *Y* should be
5887               one greater than those of *C*; if they are the same as *C*,
5888               then a deprecation warning is raised, and the last row
5889               and column of *C* are dropped.
5890             - 'nearest': Each grid point will have a color centered on it,
5891               extending halfway between the adjacent grid centers.  The
5892               dimensions of *X* and *Y* must be the same as *C*.
5893             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5894               larger than *C*.  Choose 'nearest' if dimensions are the same.
5895 
5896             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5897             for more description.
5898 
5899         %(cmap_doc)s
5900 
5901         %(norm_doc)s
5902 
5903         %(vmin_vmax_doc)s
5904 
5905         edgecolors : {'none', None, 'face', color, color sequence}, optional
5906             The color of the edges. Defaults to 'none'. Possible values:
5907 
5908             - 'none' or '': No edge.
5909             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5910               :rc:`patch.force_edgecolor` has to be True for this to work.
5911             - 'face': Use the adjacent face color.
5912             - A color or sequence of colors will set the edge color.
5913 
5914             The singular form *edgecolor* works as an alias.
5915 
5916         alpha : float, default: None
5917             The alpha blending value of the face color, between 0 (transparent)
5918             and 1 (opaque). Note: The edgecolor is currently not affected by
5919             this.
5920 
5921         snap : bool, default: False
5922             Whether to snap the mesh to pixel boundaries.
5923 
5924         Returns
5925         -------
5926         `matplotlib.collections.Collection`
5927 
5928         Other Parameters
5929         ----------------
5930         antialiaseds : bool, default: False
5931             The default *antialiaseds* is False if the default
5932             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5933             at patch boundaries, and works regardless of the value of alpha.
5934             If *edgecolors* is not "none", then the default *antialiaseds*
5935             is taken from :rc:`patch.antialiased`.
5936             Stroking the edges may be preferred if *alpha* is 1, but will
5937             cause artifacts otherwise.
5938 
5939         data : indexable object, optional
5940             DATA_PARAMETER_PLACEHOLDER
5941 
5942         **kwargs
5943             Additionally, the following arguments are allowed. They are passed
5944             along to the `~matplotlib.collections.PolyCollection` constructor:
5945 
5946         %(PolyCollection:kwdoc)s
5947 
5948         See Also
5949         --------
5950         pcolormesh : for an explanation of the differences between
5951             pcolor and pcolormesh.
5952         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5953             faster alternative.
5954 
5955         Notes
5956         -----
5957         **Masked arrays**
5958 
5959         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5960         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5961         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5962         plotted.
5963 
5964         .. _axes-pcolor-grid-orientation:
5965 
5966         **Grid orientation**
5967 
5968         The grid orientation follows the standard matrix convention: An array
5969         *C* with shape (nrows, ncolumns) is plotted with the column number as
5970         *X* and the row number as *Y*.
5971         """
5972 
5973         if shading is None:
5974             shading = mpl.rcParams['pcolor.shading']
5975         shading = shading.lower()
5976         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5977                                             kwargs=kwargs)
5978         Ny, Nx = X.shape
5979 
5980         # convert to MA, if necessary.
5981         C = ma.asarray(C)
5982         X = ma.asarray(X)
5983         Y = ma.asarray(Y)
5984 
5985         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5986         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5987                   mask[0:-1, 1:] + mask[1:, 0:-1])
5988         # don't plot if C or any of the surrounding vertices are masked.
5989         mask = ma.getmaskarray(C) + xymask
5990 
5991         unmask = ~mask
5992         X1 = ma.filled(X[:-1, :-1])[unmask]
5993         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5994         X2 = ma.filled(X[1:, :-1])[unmask]
5995         Y2 = ma.filled(Y[1:, :-1])[unmask]
5996         X3 = ma.filled(X[1:, 1:])[unmask]
5997         Y3 = ma.filled(Y[1:, 1:])[unmask]
5998         X4 = ma.filled(X[:-1, 1:])[unmask]
5999         Y4 = ma.filled(Y[:-1, 1:])[unmask]
6000         npoly = len(X1)
6001 
6002         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
6003         verts = xy.reshape((npoly, 5, 2))
6004 
6005         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
6006 
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiased' in kwargs:
6021             kwargs['antialiaseds'] = kwargs.pop('antialiased')
6022         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiaseds'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         collection = mcoll.PolyCollection(
6028             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6029         collection._scale_norm(norm, vmin, vmax)
6030 
6031         x = X.compressed()
6032         y = Y.compressed()
6033 
6034         # Transform from native to data coordinates?
6035         t = collection._transform
6036         if (not isinstance(t, mtransforms.Transform) and
6037                 hasattr(t, '_as_mpl_transform')):
6038             t = t._as_mpl_transform(self.axes)
6039 
6040         if t and any(t.contains_branch_seperately(self.transData)):
6041             trans_to_data = t - self.transData
6042             pts = np.vstack([x, y]).T.astype(float)
6043             transformed_pts = trans_to_data.transform(pts)
6044             x = transformed_pts[..., 0]
6045             y = transformed_pts[..., 1]
6046 
6047         self.add_collection(collection, autolim=False)
6048 
6049         minx = np.min(x)
6050         maxx = np.max(x)
6051         miny = np.min(y)
6052         maxy = np.max(y)
6053         collection.sticky_edges.x[:] = [minx, maxx]
6054         collection.sticky_edges.y[:] = [miny, maxy]
6055         corners = (minx, miny), (maxx, maxy)
6056         self.update_datalim(corners)
6057         self._request_autoscale_view()
6058         return collection
6059 
6060     @_preprocess_data()
6061     @_docstring.dedent_interpd
6062     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6063                    vmax=None, shading=None, antialiased=False, **kwargs):
6064         """
6065         Create a pseudocolor plot with a non-regular rectangular grid.
6066 
6067         Call signature::
6068 
6069             pcolormesh([X, Y,] C, **kwargs)
6070 
6071         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6072 
6073         .. hint::
6074 
6075            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6076            and preferred in most cases. For a detailed discussion on the
6077            differences see :ref:`Differences between pcolor() and pcolormesh()
6078            <differences-pcolor-pcolormesh>`.
6079 
6080         Parameters
6081         ----------
6082         C : array-like
6083             The mesh data. Supported array shapes are:
6084 
6085             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6086               colors using normalization and a colormap. See parameters *norm*,
6087               *cmap*, *vmin*, *vmax*.
6088             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6089             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6090               i.e. including transparency.
6091 
6092             The first two dimensions (M, N) define the rows and columns of
6093             the mesh data.
6094 
6095         X, Y : array-like, optional
6096             The coordinates of the corners of quadrilaterals of a pcolormesh::
6097 
6098                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6099                                       ●╶───╴●
6100                                       │     │
6101                                       ●╶───╴●
6102                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6103 
6104             Note that the column index corresponds to the x-coordinate, and
6105             the row index corresponds to y. For details, see the
6106             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6107 
6108             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6109             greater than those of *C*, and the quadrilateral is colored due
6110             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6111             dimensions, a warning will be raised and the last row and column
6112             of *C* will be ignored.
6113 
6114             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6115             and *Y* should be the same as those of *C* (if not, a ValueError
6116             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6117             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6118             interpolation is caried out between the quadrilateral corners.
6119 
6120             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6121             expanded as needed into the appropriate 2D arrays, making a
6122             rectangular grid.
6123 
6124         %(cmap_doc)s
6125 
6126         %(norm_doc)s
6127 
6128         %(vmin_vmax_doc)s
6129 
6130         edgecolors : {'none', None, 'face', color, color sequence}, optional
6131             The color of the edges. Defaults to 'none'. Possible values:
6132 
6133             - 'none' or '': No edge.
6134             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6135               :rc:`patch.force_edgecolor` has to be True for this to work.
6136             - 'face': Use the adjacent face color.
6137             - A color or sequence of colors will set the edge color.
6138 
6139             The singular form *edgecolor* works as an alias.
6140 
6141         alpha : float, default: None
6142             The alpha blending value, between 0 (transparent) and 1 (opaque).
6143 
6144         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6145             The fill style for the quadrilateral; defaults to
6146             :rc:`pcolor.shading`. Possible values:
6147 
6148             - 'flat': A solid color is used for each quad. The color of the
6149               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6150               ``C[i, j]``. The dimensions of *X* and *Y* should be
6151               one greater than those of *C*; if they are the same as *C*,
6152               then a deprecation warning is raised, and the last row
6153               and column of *C* are dropped.
6154             - 'nearest': Each grid point will have a color centered on it,
6155               extending halfway between the adjacent grid centers.  The
6156               dimensions of *X* and *Y* must be the same as *C*.
6157             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6158               corners (i', j') are given by ``C[i', j']``. The color values of
6159               the area in between is interpolated from the corner values.
6160               The dimensions of *X* and *Y* must be the same as *C*. When
6161               Gouraud shading is used, *edgecolors* is ignored.
6162             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6163               larger than *C*.  Choose 'nearest' if dimensions are the same.
6164 
6165             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6166             for more description.
6167 
6168         snap : bool, default: False
6169             Whether to snap the mesh to pixel boundaries.
6170 
6171         rasterized : bool, optional
6172             Rasterize the pcolormesh when drawing vector graphics.  This can
6173             speed up rendering and produce smaller files for large data sets.
6174             See also :doc:`/gallery/misc/rasterization_demo`.
6175 
6176         Returns
6177         -------
6178         `matplotlib.collections.QuadMesh`
6179 
6180         Other Parameters
6181         ----------------
6182         data : indexable object, optional
6183             DATA_PARAMETER_PLACEHOLDER
6184 
6185         **kwargs
6186             Additionally, the following arguments are allowed. They are passed
6187             along to the `~matplotlib.collections.QuadMesh` constructor:
6188 
6189         %(QuadMesh:kwdoc)s
6190 
6191         See Also
6192         --------
6193         pcolor : An alternative implementation with slightly different
6194             features. For a detailed discussion on the differences see
6195             :ref:`Differences between pcolor() and pcolormesh()
6196             <differences-pcolor-pcolormesh>`.
6197         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6198             faster alternative.
6199 
6200         Notes
6201         -----
6202         **Masked arrays**
6203 
6204         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6205         quadrilateral will be transparent. Masking of *X* and *Y* is not
6206         supported. Use `~.Axes.pcolor` if you need this functionality.
6207 
6208         .. _axes-pcolormesh-grid-orientation:
6209 
6210         **Grid orientation**
6211 
6212         The grid orientation follows the standard matrix convention: An array
6213         *C* with shape (nrows, ncolumns) is plotted with the column number as
6214         *X* and the row number as *Y*.
6215 
6216         .. _differences-pcolor-pcolormesh:
6217 
6218         **Differences between pcolor() and pcolormesh()**
6219 
6220         Both methods are used to create a pseudocolor plot of a 2D array
6221         using quadrilaterals.
6222 
6223         The main difference lies in the created object and internal data
6224         handling:
6225         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6226         returns a `.QuadMesh`. The latter is more specialized for the given
6227         purpose and thus is faster. It should almost always be preferred.
6228 
6229         There is also a slight difference in the handling of masked arrays.
6230         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6231         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6232         and *Y*. The reason lies in the internal handling of the masked values.
6233         `~.Axes.pcolor` leaves out the respective polygons from the
6234         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6235         elements to transparent. You can see the difference when using
6236         edgecolors. While all edges are drawn irrespective of masking in a
6237         QuadMesh, the edge between two adjacent masked quadrilaterals in
6238         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6239         exist in the PolyCollection.
6240 
6241         Another difference is the support of Gouraud shading in
6242         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6243 
6244         """
6245         if shading is None:
6246             shading = mpl.rcParams['pcolor.shading']
6247         shading = shading.lower()
6248         kwargs.setdefault('edgecolors', 'none')
6249 
6250         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6251                                             shading=shading, kwargs=kwargs)
6252         coords = np.stack([X, Y], axis=-1)
6253 
6254         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6255 
6256         collection = mcoll.QuadMesh(
6257             coords, antialiased=antialiased, shading=shading,
6258             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6259         collection._scale_norm(norm, vmin, vmax)
6260 
6261         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6262 
6263         # Transform from native to data coordinates?
6264         t = collection._transform
6265         if (not isinstance(t, mtransforms.Transform) and
6266                 hasattr(t, '_as_mpl_transform')):
6267             t = t._as_mpl_transform(self.axes)
6268 
6269         if t and any(t.contains_branch_seperately(self.transData)):
6270             trans_to_data = t - self.transData
6271             coords = trans_to_data.transform(coords)
6272 
6273         self.add_collection(collection, autolim=False)
6274 
6275         minx, miny = np.min(coords, axis=0)
6276         maxx, maxy = np.max(coords, axis=0)
6277         collection.sticky_edges.x[:] = [minx, maxx]
6278         collection.sticky_edges.y[:] = [miny, maxy]
6279         corners = (minx, miny), (maxx, maxy)
6280         self.update_datalim(corners)
6281         self._request_autoscale_view()
6282         return collection
6283 
6284     @_preprocess_data()
6285     @_docstring.dedent_interpd
6286     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6287                    vmax=None, **kwargs):
6288         """
6289         Create a pseudocolor plot with a non-regular rectangular grid.
6290 
6291         Call signature::
6292 
6293           ax.pcolorfast([X, Y], C, /, **kwargs)
6294 
6295         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6296         It's designed to provide the fastest pcolor-type plotting with the
6297         Agg backend. To achieve this, it uses different algorithms internally
6298         depending on the complexity of the input grid (regular rectangular,
6299         non-regular rectangular or arbitrary quadrilateral).
6300 
6301         .. warning::
6302 
6303            This method is experimental. Compared to `~.Axes.pcolor` or
6304            `~.Axes.pcolormesh` it has some limitations:
6305 
6306            - It supports only flat shading (no outlines)
6307            - It lacks support for log scaling of the axes.
6308            - It does not have a pyplot wrapper.
6309 
6310         Parameters
6311         ----------
6312         C : array-like
6313             The image data. Supported array shapes are:
6314 
6315             - (M, N): an image with scalar data.  Color-mapping is controlled
6316               by *cmap*, *norm*, *vmin*, and *vmax*.
6317             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6318             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6319               i.e. including transparency.
6320 
6321             The first two dimensions (M, N) define the rows and columns of
6322             the image.
6323 
6324             This parameter can only be passed positionally.
6325 
6326         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6327             *X* and *Y* are used to specify the coordinates of the
6328             quadrilaterals. There are different ways to do this:
6329 
6330             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6331               a *uniform rectangular grid*.
6332 
6333               The tuples define the outer edges of the grid. All individual
6334               quadrilaterals will be of the same size. This is the fastest
6335               version.
6336 
6337             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6338               grid*.
6339 
6340               In this case *X* and *Y* have to be monotonic 1D arrays of length
6341               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6342 
6343               The speed is intermediate. Note: The grid is checked, and if
6344               found to be uniform the fast version is used.
6345 
6346             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6347               grid* (i.e. if the quadrilaterals are not rectangular).
6348 
6349               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6350               specifying the x and y coordinates of the corners of the colored
6351               quadrilaterals.
6352 
6353               This is the most general, but the slowest to render.  It may
6354               produce faster and more compact output using ps, pdf, and
6355               svg backends, however.
6356 
6357             These arguments can only be passed positionally.
6358 
6359         %(cmap_doc)s
6360 
6361             This parameter is ignored if *C* is RGB(A).
6362 
6363         %(norm_doc)s
6364 
6365             This parameter is ignored if *C* is RGB(A).
6366 
6367         %(vmin_vmax_doc)s
6368 
6369             This parameter is ignored if *C* is RGB(A).
6370 
6371         alpha : float, default: None
6372             The alpha blending value, between 0 (transparent) and 1 (opaque).
6373 
6374         snap : bool, default: False
6375             Whether to snap the mesh to pixel boundaries.
6376 
6377         Returns
6378         -------
6379         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6380             The return type depends on the type of grid:
6381 
6382             - `.AxesImage` for a regular rectangular grid.
6383             - `.PcolorImage` for a non-regular rectangular grid.
6384             - `.QuadMesh` for a non-rectangular grid.
6385 
6386         Other Parameters
6387         ----------------
6388         data : indexable object, optional
6389             DATA_PARAMETER_PLACEHOLDER
6390 
6391         **kwargs
6392             Supported additional parameters depend on the type of grid.
6393             See return types of *image* for further description.
6394         """
6395 
6396         C = args[-1]
6397         nr, nc = np.shape(C)[:2]
6398         if len(args) == 1:
6399             style = "image"
6400             x = [0, nc]
6401             y = [0, nr]
6402         elif len(args) == 3:
6403             x, y = args[:2]
6404             x = np.asarray(x)
6405             y = np.asarray(y)
6406             if x.ndim == 1 and y.ndim == 1:
6407                 if x.size == 2 and y.size == 2:
6408                     style = "image"
6409                 else:
6410                     dx = np.diff(x)
6411                     dy = np.diff(y)
6412                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6413                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6414                         style = "image"
6415                     else:
6416                         style = "pcolorimage"
6417             elif x.ndim == 2 and y.ndim == 2:
6418                 style = "quadmesh"
6419             else:
6420                 raise TypeError("arguments do not match valid signatures")
6421         else:
6422             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6423 
6424         if style == "quadmesh":
6425             # data point in each cell is value at lower left corner
6426             coords = np.stack([x, y], axis=-1)
6427             if np.ndim(C) not in {2, 3}:
6428                 raise ValueError("C must be 2D or 3D")
6429             collection = mcoll.QuadMesh(
6430                 coords, array=C,
6431                 alpha=alpha, cmap=cmap, norm=norm,
6432                 antialiased=False, edgecolors="none")
6433             self.add_collection(collection, autolim=False)
6434             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6435             ret = collection
6436 
6437         else:  # It's one of the two image styles.
6438             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6439             if style == "image":
6440                 im = mimage.AxesImage(
6441                     self, cmap=cmap, norm=norm,
6442                     data=C, alpha=alpha, extent=extent,
6443                     interpolation='nearest', origin='lower',
6444                     **kwargs)
6445             elif style == "pcolorimage":
6446                 im = mimage.PcolorImage(
6447                     self, x, y, C,
6448                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6449                     **kwargs)
6450             self.add_image(im)
6451             ret = im
6452 
6453         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6454             ret._scale_norm(norm, vmin, vmax)
6455 
6456         if ret.get_clip_path() is None:
6457             # image does not already have clipping set, clip to axes patch
6458             ret.set_clip_path(self.patch)
6459 
6460         ret.sticky_edges.x[:] = [xl, xr]
6461         ret.sticky_edges.y[:] = [yb, yt]
6462         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6463         self._request_autoscale_view(tight=True)
6464         return ret
6465 
6466     @_preprocess_data()
6467     @_docstring.dedent_interpd
6468     def contour(self, *args, **kwargs):
6469         """
6470         Plot contour lines.
6471 
6472         Call signature::
6473 
6474             contour([X, Y,] Z, [levels], **kwargs)
6475         %(contour_doc)s
6476         """
6477         kwargs['filled'] = False
6478         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6479         self._request_autoscale_view()
6480         return contours
6481 
6482     @_preprocess_data()
6483     @_docstring.dedent_interpd
6484     def contourf(self, *args, **kwargs):
6485         """
6486         Plot filled contours.
6487 
6488         Call signature::
6489 
6490             contourf([X, Y,] Z, [levels], **kwargs)
6491         %(contour_doc)s
6492         """
6493         kwargs['filled'] = True
6494         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6495         self._request_autoscale_view()
6496         return contours
6497 
6498     def clabel(self, CS, levels=None, **kwargs):
6499         """
6500         Label a contour plot.
6501 
6502         Adds labels to line contours in given `.ContourSet`.
6503 
6504         Parameters
6505         ----------
6506         CS : `.ContourSet` instance
6507             Line contours to label.
6508 
6509         levels : array-like, optional
6510             A list of level values, that should be labeled. The list must be
6511             a subset of ``CS.levels``. If not given, all levels are labeled.
6512 
6513         **kwargs
6514             All other parameters are documented in `~.ContourLabeler.clabel`.
6515         """
6516         return CS.clabel(levels, **kwargs)
6517 
6518     #### Data analysis
6519 
6520     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6521     def hist(self, x, bins=None, range=None, density=False, weights=None,
6522              cumulative=False, bottom=None, histtype='bar', align='mid',
6523              orientation='vertical', rwidth=None, log=False,
6524              color=None, label=None, stacked=False, **kwargs):
6525         """
6526         Compute and plot a histogram.
6527 
6528         This method uses `numpy.histogram` to bin the data in *x* and count the
6529         number of values in each bin, then draws the distribution either as a
6530         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6531         *weights* parameters are forwarded to `numpy.histogram`.
6532 
6533         If the data has already been binned and counted, use `~.bar` or
6534         `~.stairs` to plot the distribution::
6535 
6536             counts, bins = np.histogram(x)
6537             plt.stairs(counts, bins)
6538 
6539         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6540         treating each bin as a single point with a weight equal to its count::
6541 
6542             plt.hist(bins[:-1], bins, weights=counts)
6543 
6544         The data input *x* can be a singular array, a list of datasets of
6545         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6546         which each column is a dataset. Note that the ndarray form is
6547         transposed relative to the list form. If the input is an array, then
6548         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6549         sequence of arrays, then the return value is a tuple
6550         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6551 
6552         Masked arrays are not supported.
6553 
6554         Parameters
6555         ----------
6556         x : (n,) array or sequence of (n,) arrays
6557             Input values, this takes either a single array or a sequence of
6558             arrays which are not required to be of the same length.
6559 
6560         bins : int or sequence or str, default: :rc:`hist.bins`
6561             If *bins* is an integer, it defines the number of equal-width bins
6562             in the range.
6563 
6564             If *bins* is a sequence, it defines the bin edges, including the
6565             left edge of the first bin and the right edge of the last bin;
6566             in this case, bins may be unequally spaced.  All but the last
6567             (righthand-most) bin is half-open.  In other words, if *bins* is::
6568 
6569                 [1, 2, 3, 4]
6570 
6571             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6572             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6573             *includes* 4.
6574 
6575             If *bins* is a string, it is one of the binning strategies
6576             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6577             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6578 
6579         range : tuple or None, default: None
6580             The lower and upper range of the bins. Lower and upper outliers
6581             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6582             Range has no effect if *bins* is a sequence.
6583 
6584             If *bins* is a sequence or *range* is specified, autoscaling
6585             is based on the specified bin range instead of the
6586             range of x.
6587 
6588         density : bool, default: False
6589             If ``True``, draw and return a probability density: each bin
6590             will display the bin's raw count divided by the total number of
6591             counts *and the bin width*
6592             (``density = counts / (sum(counts) * np.diff(bins))``),
6593             so that the area under the histogram integrates to 1
6594             (``np.sum(density * np.diff(bins)) == 1``).
6595 
6596             If *stacked* is also ``True``, the sum of the histograms is
6597             normalized to 1.
6598 
6599         weights : (n,) array-like or None, default: None
6600             An array of weights, of the same shape as *x*.  Each value in
6601             *x* only contributes its associated weight towards the bin count
6602             (instead of 1).  If *density* is ``True``, the weights are
6603             normalized, so that the integral of the density over the range
6604             remains 1.
6605 
6606         cumulative : bool or -1, default: False
6607             If ``True``, then a histogram is computed where each bin gives the
6608             counts in that bin plus all bins for smaller values. The last bin
6609             gives the total number of datapoints.
6610 
6611             If *density* is also ``True`` then the histogram is normalized such
6612             that the last bin equals 1.
6613 
6614             If *cumulative* is a number less than 0 (e.g., -1), the direction
6615             of accumulation is reversed.  In this case, if *density* is also
6616             ``True``, then the histogram is normalized such that the first bin
6617             equals 1.
6618 
6619         bottom : array-like, scalar, or None, default: None
6620             Location of the bottom of each bin, i.e. bins are drawn from
6621             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6622             of each bin is shifted by the same amount. If an array, each bin
6623             is shifted independently and the length of bottom must match the
6624             number of bins. If None, defaults to 0.
6625 
6626         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6627             The type of histogram to draw.
6628 
6629             - 'bar' is a traditional bar-type histogram.  If multiple data
6630               are given the bars are arranged side by side.
6631             - 'barstacked' is a bar-type histogram where multiple
6632               data are stacked on top of each other.
6633             - 'step' generates a lineplot that is by default unfilled.
6634             - 'stepfilled' generates a lineplot that is by default filled.
6635 
6636         align : {'left', 'mid', 'right'}, default: 'mid'
6637             The horizontal alignment of the histogram bars.
6638 
6639             - 'left': bars are centered on the left bin edges.
6640             - 'mid': bars are centered between the bin edges.
6641             - 'right': bars are centered on the right bin edges.
6642 
6643         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6644             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6645             and the *bottom* kwarg will be the left edges.
6646 
6647         rwidth : float or None, default: None
6648             The relative width of the bars as a fraction of the bin width.  If
6649             ``None``, automatically compute the width.
6650 
6651             Ignored if *histtype* is 'step' or 'stepfilled'.
6652 
6653         log : bool, default: False
6654             If ``True``, the histogram axis will be set to a log scale.
6655 
6656         color : color or array-like of colors or None, default: None
6657             Color or sequence of colors, one per dataset.  Default (``None``)
6658             uses the standard line color sequence.
6659 
6660         label : str or None, default: None
6661             String, or sequence of strings to match multiple datasets.  Bar
6662             charts yield multiple patches per dataset, but only the first gets
6663             the label, so that `~.Axes.legend` will work as expected.
6664 
6665         stacked : bool, default: False
6666             If ``True``, multiple data are stacked on top of each other If
6667             ``False`` multiple data are arranged side by side if histtype is
6668             'bar' or on top of each other if histtype is 'step'
6669 
6670         Returns
6671         -------
6672         n : array or list of arrays
6673             The values of the histogram bins. See *density* and *weights* for a
6674             description of the possible semantics.  If input *x* is an array,
6675             then this is an array of length *nbins*. If input is a sequence of
6676             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6677             the values of the histograms for each of the arrays in the same
6678             order.  The dtype of the array *n* (or of its element arrays) will
6679             always be float even if no weighting or normalization is used.
6680 
6681         bins : array
6682             The edges of the bins. Length nbins + 1 (nbins left edges and right
6683             edge of last bin).  Always a single array even when multiple data
6684             sets are passed in.
6685 
6686         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6687 such objects
6688             Container of individual artists used to create the histogram
6689             or list of such containers if there are multiple input datasets.
6690 
6691         Other Parameters
6692         ----------------
6693         data : indexable object, optional
6694             DATA_PARAMETER_PLACEHOLDER
6695 
6696         **kwargs
6697             `~matplotlib.patches.Patch` properties
6698 
6699         See Also
6700         --------
6701         hist2d : 2D histogram with rectangular bins
6702         hexbin : 2D histogram with hexagonal bins
6703         stairs : Plot a pre-computed histogram
6704         bar : Plot a pre-computed histogram
6705 
6706         Notes
6707         -----
6708         For large numbers of bins (>1000), plotting can be significantly
6709         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6710         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6711         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6712         """
6713         # Avoid shadowing the builtin.
6714         bin_range = range
6715         from builtins import range
6716 
6717         if np.isscalar(x):
6718             x = [x]
6719 
6720         if bins is None:
6721             bins = mpl.rcParams['hist.bins']
6722 
6723         # Validate string inputs here to avoid cluttering subsequent code.
6724         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6725                            histtype=histtype)
6726         _api.check_in_list(['left', 'mid', 'right'], align=align)
6727         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6728 
6729         if histtype == 'barstacked' and not stacked:
6730             stacked = True
6731 
6732         # Massage 'x' for processing.
6733         x = cbook._reshape_2D(x, 'x')
6734         nx = len(x)  # number of datasets
6735 
6736         # Process unit information.  _process_unit_info sets the unit and
6737         # converts the first dataset; then we convert each following dataset
6738         # one at a time.
6739         if orientation == "vertical":
6740             convert_units = self.convert_xunits
6741             x = [*self._process_unit_info([("x", x[0])], kwargs),
6742                  *map(convert_units, x[1:])]
6743         else:  # horizontal
6744             convert_units = self.convert_yunits
6745             x = [*self._process_unit_info([("y", x[0])], kwargs),
6746                  *map(convert_units, x[1:])]
6747 
6748         if bin_range is not None:
6749             bin_range = convert_units(bin_range)
6750 
6751         if not cbook.is_scalar_or_string(bins):
6752             bins = convert_units(bins)
6753 
6754         # We need to do to 'weights' what was done to 'x'
6755         if weights is not None:
6756             w = cbook._reshape_2D(weights, 'weights')
6757         else:
6758             w = [None] * nx
6759 
6760         if len(w) != nx:
6761             raise ValueError('weights should have the same shape as x')
6762 
6763         input_empty = True
6764         for xi, wi in zip(x, w):
6765             len_xi = len(xi)
6766             if wi is not None and len(wi) != len_xi:
6767                 raise ValueError('weights should have the same shape as x')
6768             if len_xi:
6769                 input_empty = False
6770 
6771         if color is None:
6772             colors = [self._get_lines.get_next_color() for i in range(nx)]
6773         else:
6774             colors = mcolors.to_rgba_array(color)
6775             if len(colors) != nx:
6776                 raise ValueError(f"The 'color' keyword argument must have one "
6777                                  f"color per dataset, but {nx} datasets and "
6778                                  f"{len(colors)} colors were provided")
6779 
6780         hist_kwargs = dict()
6781 
6782         # if the bin_range is not given, compute without nan numpy
6783         # does not do this for us when guessing the range (but will
6784         # happily ignore nans when computing the histogram).
6785         if bin_range is None:
6786             xmin = np.inf
6787             xmax = -np.inf
6788             for xi in x:
6789                 if len(xi):
6790                     # python's min/max ignore nan,
6791                     # np.minnan returns nan for all nan input
6792                     xmin = min(xmin, np.nanmin(xi))
6793                     xmax = max(xmax, np.nanmax(xi))
6794             if xmin <= xmax:  # Only happens if we have seen a finite value.
6795                 bin_range = (xmin, xmax)
6796 
6797         # If bins are not specified either explicitly or via range,
6798         # we need to figure out the range required for all datasets,
6799         # and supply that to np.histogram.
6800         if not input_empty and len(x) > 1:
6801             if weights is not None:
6802                 _w = np.concatenate(w)
6803             else:
6804                 _w = None
6805             bins = np.histogram_bin_edges(
6806                 np.concatenate(x), bins, bin_range, _w)
6807         else:
6808             hist_kwargs['range'] = bin_range
6809 
6810         density = bool(density)
6811         if density and not stacked:
6812             hist_kwargs['density'] = density
6813 
6814         # List to store all the top coordinates of the histograms
6815         tops = []  # Will have shape (n_datasets, n_bins).
6816         # Loop through datasets
6817         for i in range(nx):
6818             # this will automatically overwrite bins,
6819             # so that each histogram uses the same bins
6820             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6821             tops.append(m)
6822         tops = np.array(tops, float)  # causes problems later if it's an int
6823         bins = np.array(bins, float)  # causes problems if float16
6824         if stacked:
6825             tops = tops.cumsum(axis=0)
6826             # If a stacked density plot, normalize so the area of all the
6827             # stacked histograms together is 1
6828             if density:
6829                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6830         if cumulative:
6831             slc = slice(None)
6832             if isinstance(cumulative, Number) and cumulative < 0:
6833                 slc = slice(None, None, -1)
6834             if density:
6835                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6836             else:
6837                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6838 
6839         patches = []
6840 
6841         if histtype.startswith('bar'):
6842 
6843             totwidth = np.diff(bins)
6844 
6845             if rwidth is not None:
6846                 dr = np.clip(rwidth, 0, 1)
6847             elif (len(tops) > 1 and
6848                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6849                 dr = 0.8
6850             else:
6851                 dr = 1.0
6852 
6853             if histtype == 'bar' and not stacked:
6854                 width = dr * totwidth / nx
6855                 dw = width
6856                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6857             elif histtype == 'barstacked' or stacked:
6858                 width = dr * totwidth
6859                 boffset, dw = 0.0, 0.0
6860 
6861             if align == 'mid':
6862                 boffset += 0.5 * totwidth
6863             elif align == 'right':
6864                 boffset += totwidth
6865 
6866             if orientation == 'horizontal':
6867                 _barfunc = self.barh
6868                 bottom_kwarg = 'left'
6869             else:  # orientation == 'vertical'
6870                 _barfunc = self.bar
6871                 bottom_kwarg = 'bottom'
6872 
6873             for top, color in zip(tops, colors):
6874                 if bottom is None:
6875                     bottom = np.zeros(len(top))
6876                 if stacked:
6877                     height = top - bottom
6878                 else:
6879                     height = top
6880                 bars = _barfunc(bins[:-1]+boffset, height, width,
6881                                 align='center', log=log,
6882                                 color=color, **{bottom_kwarg: bottom})
6883                 patches.append(bars)
6884                 if stacked:
6885                     bottom = top
6886                 boffset += dw
6887             # Remove stickies from all bars but the lowest ones, as otherwise
6888             # margin expansion would be unable to cross the stickies in the
6889             # middle of the bars.
6890             for bars in patches[1:]:
6891                 for patch in bars:
6892                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6893 
6894         elif histtype.startswith('step'):
6895             # these define the perimeter of the polygon
6896             x = np.zeros(4 * len(bins) - 3)
6897             y = np.zeros(4 * len(bins) - 3)
6898 
6899             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6900             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6901 
6902             if bottom is None:
6903                 bottom = 0
6904 
6905             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6906             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6907 
6908             if log:
6909                 if orientation == 'horizontal':
6910                     self.set_xscale('log', nonpositive='clip')
6911                 else:  # orientation == 'vertical'
6912                     self.set_yscale('log', nonpositive='clip')
6913 
6914             if align == 'left':
6915                 x -= 0.5*(bins[1]-bins[0])
6916             elif align == 'right':
6917                 x += 0.5*(bins[1]-bins[0])
6918 
6919             # If fill kwarg is set, it will be passed to the patch collection,
6920             # overriding this
6921             fill = (histtype == 'stepfilled')
6922 
6923             xvals, yvals = [], []
6924             for top in tops:
6925                 if stacked:
6926                     # top of the previous polygon becomes the bottom
6927                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6928                 # set the top of this polygon
6929                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6930 
6931                 # The starting point of the polygon has not yet been
6932                 # updated. So far only the endpoint was adjusted. This
6933                 # assignment closes the polygon. The redundant endpoint is
6934                 # later discarded (for step and stepfilled).
6935                 y[0] = y[-1]
6936 
6937                 if orientation == 'horizontal':
6938                     xvals.append(y.copy())
6939                     yvals.append(x.copy())
6940                 else:
6941                     xvals.append(x.copy())
6942                     yvals.append(y.copy())
6943 
6944             # stepfill is closed, step is not
6945             split = -1 if fill else 2 * len(bins)
6946             # add patches in reverse order so that when stacking,
6947             # items lower in the stack are plotted on top of
6948             # items higher in the stack
6949             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6950                 patches.append(self.fill(
6951                     x[:split], y[:split],
6952                     closed=True if fill else None,
6953                     facecolor=color,
6954                     edgecolor=None if fill else color,
6955                     fill=fill if fill else None,
6956                     zorder=None if fill else mlines.Line2D.zorder))
6957             for patch_list in patches:
6958                 for patch in patch_list:
6959                     if orientation == 'vertical':
6960                         patch.sticky_edges.y.append(0)
6961                     elif orientation == 'horizontal':
6962                         patch.sticky_edges.x.append(0)
6963 
6964             # we return patches, so put it back in the expected order
6965             patches.reverse()
6966 
6967         # If None, make all labels None (via zip_longest below); otherwise,
6968         # cast each element to str, but keep a single str as it.
6969         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6970         for patch, lbl in itertools.zip_longest(patches, labels):
6971             if patch:
6972                 p = patch[0]
6973                 p._internal_update(kwargs)
6974                 if lbl is not None:
6975                     p.set_label(lbl)
6976                 for p in patch[1:]:
6977                     p._internal_update(kwargs)
6978                     p.set_label('_nolegend_')
6979 
6980         if nx == 1:
6981             return tops[0], bins, patches[0]
6982         else:
6983             patch_type = ("BarContainer" if histtype.startswith("bar")
6984                           else "list[Polygon]")
6985             return tops, bins, cbook.silent_list(patch_type, patches)
6986 
6987     @_preprocess_data()
6988     def stairs(self, values, edges=None, *,
6989                orientation='vertical', baseline=0, fill=False, **kwargs):
6990         """
6991         A stepwise constant function as a line with bounding edges
6992         or a filled plot.
6993 
6994         Parameters
6995         ----------
6996         values : array-like
6997             The step heights.
6998 
6999         edges : array-like
7000             The edge positions, with ``len(edges) == len(vals) + 1``,
7001             between which the curve takes on vals values.
7002 
7003         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7004             The direction of the steps. Vertical means that *values* are along
7005             the y-axis, and edges are along the x-axis.
7006 
7007         baseline : float, array-like or None, default: 0
7008             The bottom value of the bounding edges or when
7009             ``fill=True``, position of lower edge. If *fill* is
7010             True or an array is passed to *baseline*, a closed
7011             path is drawn.
7012 
7013         fill : bool, default: False
7014             Whether the area under the step curve should be filled.
7015 
7016         Returns
7017         -------
7018         StepPatch : `matplotlib.patches.StepPatch`
7019 
7020         Other Parameters
7021         ----------------
7022         data : indexable object, optional
7023             DATA_PARAMETER_PLACEHOLDER
7024 
7025         **kwargs
7026             `~matplotlib.patches.StepPatch` properties
7027 
7028         """
7029 
7030         if 'color' in kwargs:
7031             _color = kwargs.pop('color')
7032         else:
7033             _color = self._get_lines.get_next_color()
7034         if fill:
7035             kwargs.setdefault('linewidth', 0)
7036             kwargs.setdefault('facecolor', _color)
7037         else:
7038             kwargs.setdefault('edgecolor', _color)
7039 
7040         if edges is None:
7041             edges = np.arange(len(values) + 1)
7042 
7043         edges, values, baseline = self._process_unit_info(
7044             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7045 
7046         patch = mpatches.StepPatch(values,
7047                                    edges,
7048                                    baseline=baseline,
7049                                    orientation=orientation,
7050                                    fill=fill,
7051                                    **kwargs)
7052         self.add_patch(patch)
7053         if baseline is None:
7054             baseline = 0
7055         if orientation == 'vertical':
7056             patch.sticky_edges.y.append(np.min(baseline))
7057             self.update_datalim([(edges[0], np.min(baseline))])
7058         else:
7059             patch.sticky_edges.x.append(np.min(baseline))
7060             self.update_datalim([(np.min(baseline), edges[0])])
7061         self._request_autoscale_view()
7062         return patch
7063 
7064     @_preprocess_data(replace_names=["x", "y", "weights"])
7065     @_docstring.dedent_interpd
7066     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7067                cmin=None, cmax=None, **kwargs):
7068         """
7069         Make a 2D histogram plot.
7070 
7071         Parameters
7072         ----------
7073         x, y : array-like, shape (n, )
7074             Input values
7075 
7076         bins : None or int or [int, int] or array-like or [array, array]
7077 
7078             The bin specification:
7079 
7080             - If int, the number of bins for the two dimensions
7081               (nx=ny=bins).
7082             - If ``[int, int]``, the number of bins in each dimension
7083               (nx, ny = bins).
7084             - If array-like, the bin edges for the two dimensions
7085               (x_edges=y_edges=bins).
7086             - If ``[array, array]``, the bin edges in each dimension
7087               (x_edges, y_edges = bins).
7088 
7089             The default value is 10.
7090 
7091         range : array-like shape(2, 2), optional
7092             The leftmost and rightmost edges of the bins along each dimension
7093             (if not specified explicitly in the bins parameters): ``[[xmin,
7094             xmax], [ymin, ymax]]``. All values outside of this range will be
7095             considered outliers and not tallied in the histogram.
7096 
7097         density : bool, default: False
7098             Normalize histogram.  See the documentation for the *density*
7099             parameter of `~.Axes.hist` for more details.
7100 
7101         weights : array-like, shape (n, ), optional
7102             An array of values w_i weighing each sample (x_i, y_i).
7103 
7104         cmin, cmax : float, default: None
7105             All bins that has count less than *cmin* or more than *cmax* will
7106             not be displayed (set to NaN before passing to imshow) and these
7107             count values in the return value count histogram will also be set
7108             to nan upon return.
7109 
7110         Returns
7111         -------
7112         h : 2D array
7113             The bi-dimensional histogram of samples x and y. Values in x are
7114             histogrammed along the first dimension and values in y are
7115             histogrammed along the second dimension.
7116         xedges : 1D array
7117             The bin edges along the x-axis.
7118         yedges : 1D array
7119             The bin edges along the y-axis.
7120         image : `~.matplotlib.collections.QuadMesh`
7121 
7122         Other Parameters
7123         ----------------
7124         %(cmap_doc)s
7125 
7126         %(norm_doc)s
7127 
7128         %(vmin_vmax_doc)s
7129 
7130         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7131             The alpha blending value.
7132 
7133         data : indexable object, optional
7134             DATA_PARAMETER_PLACEHOLDER
7135 
7136         **kwargs
7137             Additional parameters are passed along to the
7138             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7139             constructor.
7140 
7141         See Also
7142         --------
7143         hist : 1D histogram plotting
7144         hexbin : 2D histogram with hexagonal bins
7145 
7146         Notes
7147         -----
7148         - Currently ``hist2d`` calculates its own axis limits, and any limits
7149           previously set are ignored.
7150         - Rendering the histogram with a logarithmic color scale is
7151           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7152           keyword argument. Likewise, power-law normalization (similar
7153           in effect to gamma correction) can be accomplished with
7154           `.colors.PowerNorm`.
7155         """
7156 
7157         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7158                                            density=density, weights=weights)
7159 
7160         if cmin is not None:
7161             h[h < cmin] = None
7162         if cmax is not None:
7163             h[h > cmax] = None
7164 
7165         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7166         self.set_xlim(xedges[0], xedges[-1])
7167         self.set_ylim(yedges[0], yedges[-1])
7168 
7169         return h, xedges, yedges, pc
7170 
7171     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7172     @_docstring.dedent_interpd
7173     def ecdf(self, x, weights=None, *, complementary=False,
7174              orientation="vertical", compress=False, **kwargs):
7175         """
7176         Compute and plot the empirical cumulative distribution function of *x*.
7177 
7178         .. versionadded:: 3.8
7179 
7180         Parameters
7181         ----------
7182         x : 1d array-like
7183             The input data.  Infinite entries are kept (and move the relevant
7184             end of the ecdf from 0/1), but NaNs and masked values are errors.
7185 
7186         weights : 1d array-like or None, default: None
7187             The weights of the entries; must have the same shape as *x*.
7188             Weights corresponding to NaN data points are dropped, and then the
7189             remaining weights are normalized to sum to 1.  If unset, all
7190             entries have the same weight.
7191 
7192         complementary : bool, default: False
7193             Whether to plot a cumulative distribution function, which increases
7194             from 0 to 1 (the default), or a complementary cumulative
7195             distribution function, which decreases from 1 to 0.
7196 
7197         orientation : {"vertical", "horizontal"}, default: "vertical"
7198             Whether the entries are plotted along the x-axis ("vertical", the
7199             default) or the y-axis ("horizontal").  This parameter takes the
7200             same values as in `~.Axes.hist`.
7201 
7202         compress : bool, default: False
7203             Whether multiple entries with the same values are grouped together
7204             (with a summed weight) before plotting.  This is mainly useful if
7205             *x* contains many identical data points, to decrease the rendering
7206             complexity of the plot. If *x* contains no duplicate points, this
7207             has no effect and just uses some time and memory.
7208 
7209         Other Parameters
7210         ----------------
7211         data : indexable object, optional
7212             DATA_PARAMETER_PLACEHOLDER
7213 
7214         **kwargs
7215             Keyword arguments control the `.Line2D` properties:
7216 
7217             %(Line2D:kwdoc)s
7218 
7219         Returns
7220         -------
7221         `.Line2D`
7222 
7223         Notes
7224         -----
7225         The ecdf plot can be thought of as a cumulative histogram with one bin
7226         per data entry; i.e. it reports on the entire dataset without any
7227         arbitrary binning.
7228 
7229         If *x* contains NaNs or masked entries, either remove them first from
7230         the array (if they should not taken into account), or replace them by
7231         -inf or +inf (if they should be sorted at the beginning or the end of
7232         the array).
7233         """
7234         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7235         if "drawstyle" in kwargs or "ds" in kwargs:
7236             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7237         if np.ma.getmask(x).any():
7238             raise ValueError("ecdf() does not support masked entries")
7239         x = np.asarray(x)
7240         if np.isnan(x).any():
7241             raise ValueError("ecdf() does not support NaNs")
7242         argsort = np.argsort(x)
7243         x = x[argsort]
7244         if weights is None:
7245             # Ensure that we end at exactly 1, avoiding floating point errors.
7246             cum_weights = (1 + np.arange(len(x))) / len(x)
7247         else:
7248             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7249             cum_weights = np.cumsum(weights / np.sum(weights))
7250         if compress:
7251             # Get indices of unique x values.
7252             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7253             x = x[compress_idxs]
7254             cum_weights = cum_weights[compress_idxs]
7255         if orientation == "vertical":
7256             if not complementary:
7257                 line, = self.plot([x[0], *x], [0, *cum_weights],
7258                                   drawstyle="steps-post", **kwargs)
7259             else:
7260                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7261                                   drawstyle="steps-pre", **kwargs)
7262             line.sticky_edges.y[:] = [0, 1]
7263         else:  # orientation == "horizontal":
7264             if not complementary:
7265                 line, = self.plot([0, *cum_weights], [x[0], *x],
7266                                   drawstyle="steps-pre", **kwargs)
7267             else:
7268                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7269                                   drawstyle="steps-post", **kwargs)
7270             line.sticky_edges.x[:] = [0, 1]
7271         return line
7272 
7273     @_preprocess_data(replace_names=["x"])
7274     @_docstring.dedent_interpd
7275     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7276             window=None, noverlap=None, pad_to=None,
7277             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7278         r"""
7279         Plot the power spectral density.
7280 
7281         The power spectral density :math:`P_{xx}` by Welch's average
7282         periodogram method.  The vector *x* is divided into *NFFT* length
7283         segments.  Each segment is detrended by function *detrend* and
7284         windowed by function *window*.  *noverlap* gives the length of
7285         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7286         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7287         with a scaling to correct for power loss due to windowing.
7288 
7289         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7290 
7291         Parameters
7292         ----------
7293         x : 1-D array or sequence
7294             Array or sequence containing the data
7295 
7296         %(Spectral)s
7297 
7298         %(PSD)s
7299 
7300         noverlap : int, default: 0 (no overlap)
7301             The number of points of overlap between segments.
7302 
7303         Fc : int, default: 0
7304             The center frequency of *x*, which offsets the x extents of the
7305             plot to reflect the frequency range used when a signal is acquired
7306             and then filtered and downsampled to baseband.
7307 
7308         return_line : bool, default: False
7309             Whether to include the line object plotted in the returned values.
7310 
7311         Returns
7312         -------
7313         Pxx : 1-D array
7314             The values for the power spectrum :math:`P_{xx}` before scaling
7315             (real valued).
7316 
7317         freqs : 1-D array
7318             The frequencies corresponding to the elements in *Pxx*.
7319 
7320         line : `~matplotlib.lines.Line2D`
7321             The line created by this function.
7322             Only returned if *return_line* is True.
7323 
7324         Other Parameters
7325         ----------------
7326         data : indexable object, optional
7327             DATA_PARAMETER_PLACEHOLDER
7328 
7329         **kwargs
7330             Keyword arguments control the `.Line2D` properties:
7331 
7332             %(Line2D:kwdoc)s
7333 
7334         See Also
7335         --------
7336         specgram
7337             Differs in the default overlap; in not returning the mean of the
7338             segment periodograms; in returning the times of the segments; and
7339             in plotting a colormap instead of a line.
7340         magnitude_spectrum
7341             Plots the magnitude spectrum.
7342         csd
7343             Plots the spectral density between two signals.
7344 
7345         Notes
7346         -----
7347         For plotting, the power is plotted as
7348         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7349         is returned.
7350 
7351         References
7352         ----------
7353         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7354         John Wiley & Sons (1986)
7355         """
7356         if Fc is None:
7357             Fc = 0
7358 
7359         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7360                               window=window, noverlap=noverlap, pad_to=pad_to,
7361                               sides=sides, scale_by_freq=scale_by_freq)
7362         freqs += Fc
7363 
7364         if scale_by_freq in (None, True):
7365             psd_units = 'dB/Hz'
7366         else:
7367             psd_units = 'dB'
7368 
7369         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7370         self.set_xlabel('Frequency')
7371         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7372         self.grid(True)
7373 
7374         vmin, vmax = self.get_ybound()
7375         step = max(10 * int(np.log10(vmax - vmin)), 1)
7376         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7377         self.set_yticks(ticks)
7378 
7379         if return_line is None or not return_line:
7380             return pxx, freqs
7381         else:
7382             return pxx, freqs, line
7383 
7384     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7385     @_docstring.dedent_interpd
7386     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7387             window=None, noverlap=None, pad_to=None,
7388             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7389         r"""
7390         Plot the cross-spectral density.
7391 
7392         The cross spectral density :math:`P_{xy}` by Welch's average
7393         periodogram method.  The vectors *x* and *y* are divided into
7394         *NFFT* length segments.  Each segment is detrended by function
7395         *detrend* and windowed by function *window*.  *noverlap* gives
7396         the length of the overlap between segments.  The product of
7397         the direct FFTs of *x* and *y* are averaged over each segment
7398         to compute :math:`P_{xy}`, with a scaling to correct for power
7399         loss due to windowing.
7400 
7401         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7402         padded to *NFFT*.
7403 
7404         Parameters
7405         ----------
7406         x, y : 1-D arrays or sequences
7407             Arrays or sequences containing the data.
7408 
7409         %(Spectral)s
7410 
7411         %(PSD)s
7412 
7413         noverlap : int, default: 0 (no overlap)
7414             The number of points of overlap between segments.
7415 
7416         Fc : int, default: 0
7417             The center frequency of *x*, which offsets the x extents of the
7418             plot to reflect the frequency range used when a signal is acquired
7419             and then filtered and downsampled to baseband.
7420 
7421         return_line : bool, default: False
7422             Whether to include the line object plotted in the returned values.
7423 
7424         Returns
7425         -------
7426         Pxy : 1-D array
7427             The values for the cross spectrum :math:`P_{xy}` before scaling
7428             (complex valued).
7429 
7430         freqs : 1-D array
7431             The frequencies corresponding to the elements in *Pxy*.
7432 
7433         line : `~matplotlib.lines.Line2D`
7434             The line created by this function.
7435             Only returned if *return_line* is True.
7436 
7437         Other Parameters
7438         ----------------
7439         data : indexable object, optional
7440             DATA_PARAMETER_PLACEHOLDER
7441 
7442         **kwargs
7443             Keyword arguments control the `.Line2D` properties:
7444 
7445             %(Line2D:kwdoc)s
7446 
7447         See Also
7448         --------
7449         psd : is equivalent to setting ``y = x``.
7450 
7451         Notes
7452         -----
7453         For plotting, the power is plotted as
7454         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7455         is returned.
7456 
7457         References
7458         ----------
7459         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7460         John Wiley & Sons (1986)
7461         """
7462         if Fc is None:
7463             Fc = 0
7464 
7465         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7466                               window=window, noverlap=noverlap, pad_to=pad_to,
7467                               sides=sides, scale_by_freq=scale_by_freq)
7468         # pxy is complex
7469         freqs += Fc
7470 
7471         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7472         self.set_xlabel('Frequency')
7473         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7474         self.grid(True)
7475 
7476         vmin, vmax = self.get_ybound()
7477         step = max(10 * int(np.log10(vmax - vmin)), 1)
7478         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7479         self.set_yticks(ticks)
7480 
7481         if return_line is None or not return_line:
7482             return pxy, freqs
7483         else:
7484             return pxy, freqs, line
7485 
7486     @_preprocess_data(replace_names=["x"])
7487     @_docstring.dedent_interpd
7488     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7489                            pad_to=None, sides=None, scale=None,
7490                            **kwargs):
7491         """
7492         Plot the magnitude spectrum.
7493 
7494         Compute the magnitude spectrum of *x*.  Data is padded to a
7495         length of *pad_to* and the windowing function *window* is applied to
7496         the signal.
7497 
7498         Parameters
7499         ----------
7500         x : 1-D array or sequence
7501             Array or sequence containing the data.
7502 
7503         %(Spectral)s
7504 
7505         %(Single_Spectrum)s
7506 
7507         scale : {'default', 'linear', 'dB'}
7508             The scaling of the values in the *spec*.  'linear' is no scaling.
7509             'dB' returns the values in dB scale, i.e., the dB amplitude
7510             (20 * log10). 'default' is 'linear'.
7511 
7512         Fc : int, default: 0
7513             The center frequency of *x*, which offsets the x extents of the
7514             plot to reflect the frequency range used when a signal is acquired
7515             and then filtered and downsampled to baseband.
7516 
7517         Returns
7518         -------
7519         spectrum : 1-D array
7520             The values for the magnitude spectrum before scaling (real valued).
7521 
7522         freqs : 1-D array
7523             The frequencies corresponding to the elements in *spectrum*.
7524 
7525         line : `~matplotlib.lines.Line2D`
7526             The line created by this function.
7527 
7528         Other Parameters
7529         ----------------
7530         data : indexable object, optional
7531             DATA_PARAMETER_PLACEHOLDER
7532 
7533         **kwargs
7534             Keyword arguments control the `.Line2D` properties:
7535 
7536             %(Line2D:kwdoc)s
7537 
7538         See Also
7539         --------
7540         psd
7541             Plots the power spectral density.
7542         angle_spectrum
7543             Plots the angles of the corresponding frequencies.
7544         phase_spectrum
7545             Plots the phase (unwrapped angle) of the corresponding frequencies.
7546         specgram
7547             Can plot the magnitude spectrum of segments within the signal in a
7548             colormap.
7549         """
7550         if Fc is None:
7551             Fc = 0
7552 
7553         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7554                                               pad_to=pad_to, sides=sides)
7555         freqs += Fc
7556 
7557         yunits = _api.check_getitem(
7558             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7559              'dB': 'dB'},
7560             scale=scale)
7561         if yunits == 'energy':
7562             Z = spec
7563         else:  # yunits == 'dB'
7564             Z = 20. * np.log10(spec)
7565 
7566         line, = self.plot(freqs, Z, **kwargs)
7567         self.set_xlabel('Frequency')
7568         self.set_ylabel('Magnitude (%s)' % yunits)
7569 
7570         return spec, freqs, line
7571 
7572     @_preprocess_data(replace_names=["x"])
7573     @_docstring.dedent_interpd
7574     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7575                        pad_to=None, sides=None, **kwargs):
7576         """
7577         Plot the angle spectrum.
7578 
7579         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7580         Data is padded to a length of *pad_to* and the windowing function
7581         *window* is applied to the signal.
7582 
7583         Parameters
7584         ----------
7585         x : 1-D array or sequence
7586             Array or sequence containing the data.
7587 
7588         %(Spectral)s
7589 
7590         %(Single_Spectrum)s
7591 
7592         Fc : int, default: 0
7593             The center frequency of *x*, which offsets the x extents of the
7594             plot to reflect the frequency range used when a signal is acquired
7595             and then filtered and downsampled to baseband.
7596 
7597         Returns
7598         -------
7599         spectrum : 1-D array
7600             The values for the angle spectrum in radians (real valued).
7601 
7602         freqs : 1-D array
7603             The frequencies corresponding to the elements in *spectrum*.
7604 
7605         line : `~matplotlib.lines.Line2D`
7606             The line created by this function.
7607 
7608         Other Parameters
7609         ----------------
7610         data : indexable object, optional
7611             DATA_PARAMETER_PLACEHOLDER
7612 
7613         **kwargs
7614             Keyword arguments control the `.Line2D` properties:
7615 
7616             %(Line2D:kwdoc)s
7617 
7618         See Also
7619         --------
7620         magnitude_spectrum
7621             Plots the magnitudes of the corresponding frequencies.
7622         phase_spectrum
7623             Plots the unwrapped version of this function.
7624         specgram
7625             Can plot the angle spectrum of segments within the signal in a
7626             colormap.
7627         """
7628         if Fc is None:
7629             Fc = 0
7630 
7631         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7632                                           pad_to=pad_to, sides=sides)
7633         freqs += Fc
7634 
7635         lines = self.plot(freqs, spec, **kwargs)
7636         self.set_xlabel('Frequency')
7637         self.set_ylabel('Angle (radians)')
7638 
7639         return spec, freqs, lines[0]
7640 
7641     @_preprocess_data(replace_names=["x"])
7642     @_docstring.dedent_interpd
7643     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7644                        pad_to=None, sides=None, **kwargs):
7645         """
7646         Plot the phase spectrum.
7647 
7648         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7649         Data is padded to a length of *pad_to* and the windowing function
7650         *window* is applied to the signal.
7651 
7652         Parameters
7653         ----------
7654         x : 1-D array or sequence
7655             Array or sequence containing the data
7656 
7657         %(Spectral)s
7658 
7659         %(Single_Spectrum)s
7660 
7661         Fc : int, default: 0
7662             The center frequency of *x*, which offsets the x extents of the
7663             plot to reflect the frequency range used when a signal is acquired
7664             and then filtered and downsampled to baseband.
7665 
7666         Returns
7667         -------
7668         spectrum : 1-D array
7669             The values for the phase spectrum in radians (real valued).
7670 
7671         freqs : 1-D array
7672             The frequencies corresponding to the elements in *spectrum*.
7673 
7674         line : `~matplotlib.lines.Line2D`
7675             The line created by this function.
7676 
7677         Other Parameters
7678         ----------------
7679         data : indexable object, optional
7680             DATA_PARAMETER_PLACEHOLDER
7681 
7682         **kwargs
7683             Keyword arguments control the `.Line2D` properties:
7684 
7685             %(Line2D:kwdoc)s
7686 
7687         See Also
7688         --------
7689         magnitude_spectrum
7690             Plots the magnitudes of the corresponding frequencies.
7691         angle_spectrum
7692             Plots the wrapped version of this function.
7693         specgram
7694             Can plot the phase spectrum of segments within the signal in a
7695             colormap.
7696         """
7697         if Fc is None:
7698             Fc = 0
7699 
7700         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7701                                           pad_to=pad_to, sides=sides)
7702         freqs += Fc
7703 
7704         lines = self.plot(freqs, spec, **kwargs)
7705         self.set_xlabel('Frequency')
7706         self.set_ylabel('Phase (radians)')
7707 
7708         return spec, freqs, lines[0]
7709 
7710     @_preprocess_data(replace_names=["x", "y"])
7711     @_docstring.dedent_interpd
7712     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7713                window=mlab.window_hanning, noverlap=0, pad_to=None,
7714                sides='default', scale_by_freq=None, **kwargs):
7715         r"""
7716         Plot the coherence between *x* and *y*.
7717 
7718         Coherence is the normalized cross spectral density:
7719 
7720         .. math::
7721 
7722           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7723 
7724         Parameters
7725         ----------
7726         %(Spectral)s
7727 
7728         %(PSD)s
7729 
7730         noverlap : int, default: 0 (no overlap)
7731             The number of points of overlap between blocks.
7732 
7733         Fc : int, default: 0
7734             The center frequency of *x*, which offsets the x extents of the
7735             plot to reflect the frequency range used when a signal is acquired
7736             and then filtered and downsampled to baseband.
7737 
7738         Returns
7739         -------
7740         Cxy : 1-D array
7741             The coherence vector.
7742 
7743         freqs : 1-D array
7744             The frequencies for the elements in *Cxy*.
7745 
7746         Other Parameters
7747         ----------------
7748         data : indexable object, optional
7749             DATA_PARAMETER_PLACEHOLDER
7750 
7751         **kwargs
7752             Keyword arguments control the `.Line2D` properties:
7753 
7754             %(Line2D:kwdoc)s
7755 
7756         References
7757         ----------
7758         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7759         John Wiley & Sons (1986)
7760         """
7761         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7762                                  window=window, noverlap=noverlap,
7763                                  scale_by_freq=scale_by_freq, sides=sides,
7764                                  pad_to=pad_to)
7765         freqs += Fc
7766 
7767         self.plot(freqs, cxy, **kwargs)
7768         self.set_xlabel('Frequency')
7769         self.set_ylabel('Coherence')
7770         self.grid(True)
7771 
7772         return cxy, freqs
7773 
7774     @_preprocess_data(replace_names=["x"])
7775     @_docstring.dedent_interpd
7776     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7777                  window=None, noverlap=None,
7778                  cmap=None, xextent=None, pad_to=None, sides=None,
7779                  scale_by_freq=None, mode=None, scale=None,
7780                  vmin=None, vmax=None, **kwargs):
7781         """
7782         Plot a spectrogram.
7783 
7784         Compute and plot a spectrogram of data in *x*.  Data are split into
7785         *NFFT* length segments and the spectrum of each section is
7786         computed.  The windowing function *window* is applied to each
7787         segment, and the amount of overlap of each segment is
7788         specified with *noverlap*. The spectrogram is plotted as a colormap
7789         (using imshow).
7790 
7791         Parameters
7792         ----------
7793         x : 1-D array or sequence
7794             Array or sequence containing the data.
7795 
7796         %(Spectral)s
7797 
7798         %(PSD)s
7799 
7800         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7801             What sort of spectrum to use.  Default is 'psd', which takes the
7802             power spectral density.  'magnitude' returns the magnitude
7803             spectrum.  'angle' returns the phase spectrum without unwrapping.
7804             'phase' returns the phase spectrum with unwrapping.
7805 
7806         noverlap : int, default: 128
7807             The number of points of overlap between blocks.
7808 
7809         scale : {'default', 'linear', 'dB'}
7810             The scaling of the values in the *spec*.  'linear' is no scaling.
7811             'dB' returns the values in dB scale.  When *mode* is 'psd',
7812             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7813             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7814             'magnitude' and 'linear' otherwise.  This must be 'linear'
7815             if *mode* is 'angle' or 'phase'.
7816 
7817         Fc : int, default: 0
7818             The center frequency of *x*, which offsets the x extents of the
7819             plot to reflect the frequency range used when a signal is acquired
7820             and then filtered and downsampled to baseband.
7821 
7822         cmap : `.Colormap`, default: :rc:`image.cmap`
7823 
7824         xextent : *None* or (xmin, xmax)
7825             The image extent along the x-axis. The default sets *xmin* to the
7826             left border of the first bin (*spectrum* column) and *xmax* to the
7827             right border of the last bin. Note that for *noverlap>0* the width
7828             of the bins is smaller than those of the segments.
7829 
7830         data : indexable object, optional
7831             DATA_PARAMETER_PLACEHOLDER
7832 
7833         **kwargs
7834             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7835             which makes the specgram image. The origin keyword argument
7836             is not supported.
7837 
7838         Returns
7839         -------
7840         spectrum : 2D array
7841             Columns are the periodograms of successive segments.
7842 
7843         freqs : 1-D array
7844             The frequencies corresponding to the rows in *spectrum*.
7845 
7846         t : 1-D array
7847             The times corresponding to midpoints of segments (i.e., the columns
7848             in *spectrum*).
7849 
7850         im : `.AxesImage`
7851             The image created by imshow containing the spectrogram.
7852 
7853         See Also
7854         --------
7855         psd
7856             Differs in the default overlap; in returning the mean of the
7857             segment periodograms; in not returning times; and in generating a
7858             line plot instead of colormap.
7859         magnitude_spectrum
7860             A single spectrum, similar to having a single segment when *mode*
7861             is 'magnitude'. Plots a line instead of a colormap.
7862         angle_spectrum
7863             A single spectrum, similar to having a single segment when *mode*
7864             is 'angle'. Plots a line instead of a colormap.
7865         phase_spectrum
7866             A single spectrum, similar to having a single segment when *mode*
7867             is 'phase'. Plots a line instead of a colormap.
7868 
7869         Notes
7870         -----
7871         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7872         is set to 'psd'.
7873         """
7874         if NFFT is None:
7875             NFFT = 256  # same default as in mlab.specgram()
7876         if Fc is None:
7877             Fc = 0  # same default as in mlab._spectral_helper()
7878         if noverlap is None:
7879             noverlap = 128  # same default as in mlab.specgram()
7880         if Fs is None:
7881             Fs = 2  # same default as in mlab._spectral_helper()
7882 
7883         if mode == 'complex':
7884             raise ValueError('Cannot plot a complex specgram')
7885 
7886         if scale is None or scale == 'default':
7887             if mode in ['angle', 'phase']:
7888                 scale = 'linear'
7889             else:
7890                 scale = 'dB'
7891         elif mode in ['angle', 'phase'] and scale == 'dB':
7892             raise ValueError('Cannot use dB scale with angle or phase mode')
7893 
7894         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7895                                        detrend=detrend, window=window,
7896                                        noverlap=noverlap, pad_to=pad_to,
7897                                        sides=sides,
7898                                        scale_by_freq=scale_by_freq,
7899                                        mode=mode)
7900 
7901         if scale == 'linear':
7902             Z = spec
7903         elif scale == 'dB':
7904             if mode is None or mode == 'default' or mode == 'psd':
7905                 Z = 10. * np.log10(spec)
7906             else:
7907                 Z = 20. * np.log10(spec)
7908         else:
7909             raise ValueError(f'Unknown scale {scale!r}')
7910 
7911         Z = np.flipud(Z)
7912 
7913         if xextent is None:
7914             # padding is needed for first and last segment:
7915             pad_xextent = (NFFT-noverlap) / Fs / 2
7916             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7917         xmin, xmax = xextent
7918         freqs += Fc
7919         extent = xmin, xmax, freqs[0], freqs[-1]
7920 
7921         if 'origin' in kwargs:
7922             raise _api.kwarg_error("specgram", "origin")
7923 
7924         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7925                          origin='upper', **kwargs)
7926         self.axis('auto')
7927 
7928         return spec, freqs, t, im
7929 
7930     @_docstring.dedent_interpd
7931     def spy(self, Z, precision=0, marker=None, markersize=None,
7932             aspect='equal', origin="upper", **kwargs):
7933         """
7934         Plot the sparsity pattern of a 2D array.
7935 
7936         This visualizes the non-zero values of the array.
7937 
7938         Two plotting styles are available: image and marker. Both
7939         are available for full arrays, but only the marker style
7940         works for `scipy.sparse.spmatrix` instances.
7941 
7942         **Image style**
7943 
7944         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7945         extra remaining keyword arguments are passed to this method.
7946 
7947         **Marker style**
7948 
7949         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7950         *None*, a `.Line2D` object will be returned with the value of marker
7951         determining the marker type, and any remaining keyword arguments
7952         passed to `~.Axes.plot`.
7953 
7954         Parameters
7955         ----------
7956         Z : (M, N) array-like
7957             The array to be plotted.
7958 
7959         precision : float or 'present', default: 0
7960             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7961             values of :math:`|Z| > precision` will be plotted.
7962 
7963             For `scipy.sparse.spmatrix` instances, you can also
7964             pass 'present'. In this case any value present in the array
7965             will be plotted, even if it is identically zero.
7966 
7967         aspect : {'equal', 'auto', None} or float, default: 'equal'
7968             The aspect ratio of the Axes.  This parameter is particularly
7969             relevant for images since it determines whether data pixels are
7970             square.
7971 
7972             This parameter is a shortcut for explicitly calling
7973             `.Axes.set_aspect`. See there for further details.
7974 
7975             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7976             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7977               that the data fit in the Axes. In general, this will result in
7978               non-square pixels.
7979             - *None*: Use :rc:`image.aspect`.
7980 
7981         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7982             Place the [0, 0] index of the array in the upper left or lower left
7983             corner of the Axes. The convention 'upper' is typically used for
7984             matrices and images.
7985 
7986         Returns
7987         -------
7988         `~matplotlib.image.AxesImage` or `.Line2D`
7989             The return type depends on the plotting style (see above).
7990 
7991         Other Parameters
7992         ----------------
7993         **kwargs
7994             The supported additional parameters depend on the plotting style.
7995 
7996             For the image style, you can pass the following additional
7997             parameters of `~.Axes.imshow`:
7998 
7999             - *cmap*
8000             - *alpha*
8001             - *url*
8002             - any `.Artist` properties (passed on to the `.AxesImage`)
8003 
8004             For the marker style, you can pass any `.Line2D` property except
8005             for *linestyle*:
8006 
8007             %(Line2D:kwdoc)s
8008         """
8009         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8010             marker = 's'
8011         _api.check_in_list(["upper", "lower"], origin=origin)
8012         if marker is None and markersize is None:
8013             Z = np.asarray(Z)
8014             mask = np.abs(Z) > precision
8015 
8016             if 'cmap' not in kwargs:
8017                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8018                                                         name='binary')
8019             if 'interpolation' in kwargs:
8020                 raise _api.kwarg_error("spy", "interpolation")
8021             if 'norm' not in kwargs:
8022                 kwargs['norm'] = mcolors.NoNorm()
8023             ret = self.imshow(mask, interpolation='nearest',
8024                               aspect=aspect, origin=origin,
8025                               **kwargs)
8026         else:
8027             if hasattr(Z, 'tocoo'):
8028                 c = Z.tocoo()
8029                 if precision == 'present':
8030                     y = c.row
8031                     x = c.col
8032                 else:
8033                     nonzero = np.abs(c.data) > precision
8034                     y = c.row[nonzero]
8035                     x = c.col[nonzero]
8036             else:
8037                 Z = np.asarray(Z)
8038                 nonzero = np.abs(Z) > precision
8039                 y, x = np.nonzero(nonzero)
8040             if marker is None:
8041                 marker = 's'
8042             if markersize is None:
8043                 markersize = 10
8044             if 'linestyle' in kwargs:
8045                 raise _api.kwarg_error("spy", "linestyle")
8046             ret = mlines.Line2D(
8047                 x, y, linestyle='None', marker=marker, markersize=markersize,
8048                 **kwargs)
8049             self.add_line(ret)
8050             nr, nc = Z.shape
8051             self.set_xlim(-0.5, nc - 0.5)
8052             if origin == "upper":
8053                 self.set_ylim(nr - 0.5, -0.5)
8054             else:
8055                 self.set_ylim(-0.5, nr - 0.5)
8056             self.set_aspect(aspect)
8057         self.title.set_y(1.05)
8058         if origin == "upper":
8059             self.xaxis.tick_top()
8060         else:  # lower
8061             self.xaxis.tick_bottom()
8062         self.xaxis.set_ticks_position('both')
8063         self.xaxis.set_major_locator(
8064             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8065         self.yaxis.set_major_locator(
8066             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8067         return ret
8068 
8069     def matshow(self, Z, **kwargs):
8070         """
8071         Plot the values of a 2D matrix or array as color-coded image.
8072 
8073         The matrix will be shown the way it would be printed, with the first
8074         row at the top.  Row and column numbering is zero-based.
8075 
8076         Parameters
8077         ----------
8078         Z : (M, N) array-like
8079             The matrix to be displayed.
8080 
8081         Returns
8082         -------
8083         `~matplotlib.image.AxesImage`
8084 
8085         Other Parameters
8086         ----------------
8087         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8088 
8089         See Also
8090         --------
8091         imshow : More general function to plot data on a 2D regular raster.
8092 
8093         Notes
8094         -----
8095         This is just a convenience function wrapping `.imshow` to set useful
8096         defaults for displaying a matrix. In particular:
8097 
8098         - Set ``origin='upper'``.
8099         - Set ``interpolation='nearest'``.
8100         - Set ``aspect='equal'``.
8101         - Ticks are placed to the left and above.
8102         - Ticks are formatted to show integer indices.
8103 
8104         """
8105         Z = np.asanyarray(Z)
8106         kw = {'origin': 'upper',
8107               'interpolation': 'nearest',
8108               'aspect': 'equal',          # (already the imshow default)
8109               **kwargs}
8110         im = self.imshow(Z, **kw)
8111         self.title.set_y(1.05)
8112         self.xaxis.tick_top()
8113         self.xaxis.set_ticks_position('both')
8114         self.xaxis.set_major_locator(
8115             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8116         self.yaxis.set_major_locator(
8117             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8118         return im
8119 
8120     @_preprocess_data(replace_names=["dataset"])
8121     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8122                    showmeans=False, showextrema=True, showmedians=False,
8123                    quantiles=None, points=100, bw_method=None):
8124         """
8125         Make a violin plot.
8126 
8127         Make a violin plot for each column of *dataset* or each vector in
8128         sequence *dataset*.  Each filled area extends to represent the
8129         entire data range, with optional lines at the mean, the median,
8130         the minimum, the maximum, and user-specified quantiles.
8131 
8132         Parameters
8133         ----------
8134         dataset : Array or a sequence of vectors.
8135           The input data.
8136 
8137         positions : array-like, default: [1, 2, ..., n]
8138           The positions of the violins. The ticks and limits are
8139           automatically set to match the positions.
8140 
8141         vert : bool, default: True.
8142           If true, creates a vertical violin plot.
8143           Otherwise, creates a horizontal violin plot.
8144 
8145         widths : array-like, default: 0.5
8146           Either a scalar or a vector that sets the maximal width of
8147           each violin. The default is 0.5, which uses about half of the
8148           available horizontal space.
8149 
8150         showmeans : bool, default: False
8151           If `True`, will toggle rendering of the means.
8152 
8153         showextrema : bool, default: True
8154           If `True`, will toggle rendering of the extrema.
8155 
8156         showmedians : bool, default: False
8157           If `True`, will toggle rendering of the medians.
8158 
8159         quantiles : array-like, default: None
8160           If not None, set a list of floats in interval [0, 1] for each violin,
8161           which stands for the quantiles that will be rendered for that
8162           violin.
8163 
8164         points : int, default: 100
8165           Defines the number of points to evaluate each of the
8166           gaussian kernel density estimations at.
8167 
8168         bw_method : str, scalar or callable, optional
8169           The method used to calculate the estimator bandwidth.  This can be
8170           'scott', 'silverman', a scalar constant or a callable.  If a
8171           scalar, this will be used directly as `kde.factor`.  If a
8172           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8173           its only parameter and return a scalar. If None (default), 'scott'
8174           is used.
8175 
8176         data : indexable object, optional
8177             DATA_PARAMETER_PLACEHOLDER
8178 
8179         Returns
8180         -------
8181         dict
8182           A dictionary mapping each component of the violinplot to a
8183           list of the corresponding collection instances created. The
8184           dictionary has the following keys:
8185 
8186           - ``bodies``: A list of the `~.collections.PolyCollection`
8187             instances containing the filled area of each violin.
8188 
8189           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8190             the mean values of each of the violin's distribution.
8191 
8192           - ``cmins``: A `~.collections.LineCollection` instance that marks
8193             the bottom of each violin's distribution.
8194 
8195           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8196             the top of each violin's distribution.
8197 
8198           - ``cbars``: A `~.collections.LineCollection` instance that marks
8199             the centers of each violin's distribution.
8200 
8201           - ``cmedians``: A `~.collections.LineCollection` instance that
8202             marks the median values of each of the violin's distribution.
8203 
8204           - ``cquantiles``: A `~.collections.LineCollection` instance created
8205             to identify the quantile values of each of the violin's
8206             distribution.
8207 
8208         """
8209 
8210         def _kde_method(X, coords):
8211             # Unpack in case of e.g. Pandas or xarray object
8212             X = cbook._unpack_to_numpy(X)
8213             # fallback gracefully if the vector contains only one value
8214             if np.all(X[0] == X):
8215                 return (X[0] == coords).astype(float)
8216             kde = mlab.GaussianKDE(X, bw_method)
8217             return kde.evaluate(coords)
8218 
8219         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8220                                      quantiles=quantiles)
8221         return self.violin(vpstats, positions=positions, vert=vert,
8222                            widths=widths, showmeans=showmeans,
8223                            showextrema=showextrema, showmedians=showmedians)
8224 
8225     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8226                showmeans=False, showextrema=True, showmedians=False):
8227         """
8228         Drawing function for violin plots.
8229 
8230         Draw a violin plot for each column of *vpstats*. Each filled area
8231         extends to represent the entire data range, with optional lines at the
8232         mean, the median, the minimum, the maximum, and the quantiles values.
8233 
8234         Parameters
8235         ----------
8236         vpstats : list of dicts
8237           A list of dictionaries containing stats for each violin plot.
8238           Required keys are:
8239 
8240           - ``coords``: A list of scalars containing the coordinates that
8241             the violin's kernel density estimate were evaluated at.
8242 
8243           - ``vals``: A list of scalars containing the values of the
8244             kernel density estimate at each of the coordinates given
8245             in *coords*.
8246 
8247           - ``mean``: The mean value for this violin's dataset.
8248 
8249           - ``median``: The median value for this violin's dataset.
8250 
8251           - ``min``: The minimum value for this violin's dataset.
8252 
8253           - ``max``: The maximum value for this violin's dataset.
8254 
8255           Optional keys are:
8256 
8257           - ``quantiles``: A list of scalars containing the quantile values
8258             for this violin's dataset.
8259 
8260         positions : array-like, default: [1, 2, ..., n]
8261           The positions of the violins. The ticks and limits are
8262           automatically set to match the positions.
8263 
8264         vert : bool, default: True.
8265           If true, plots the violins vertically.
8266           Otherwise, plots the violins horizontally.
8267 
8268         widths : array-like, default: 0.5
8269           Either a scalar or a vector that sets the maximal width of
8270           each violin. The default is 0.5, which uses about half of the
8271           available horizontal space.
8272 
8273         showmeans : bool, default: False
8274           If true, will toggle rendering of the means.
8275 
8276         showextrema : bool, default: True
8277           If true, will toggle rendering of the extrema.
8278 
8279         showmedians : bool, default: False
8280           If true, will toggle rendering of the medians.
8281 
8282         Returns
8283         -------
8284         dict
8285           A dictionary mapping each component of the violinplot to a
8286           list of the corresponding collection instances created. The
8287           dictionary has the following keys:
8288 
8289           - ``bodies``: A list of the `~.collections.PolyCollection`
8290             instances containing the filled area of each violin.
8291 
8292           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8293             the mean values of each of the violin's distribution.
8294 
8295           - ``cmins``: A `~.collections.LineCollection` instance that marks
8296             the bottom of each violin's distribution.
8297 
8298           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8299             the top of each violin's distribution.
8300 
8301           - ``cbars``: A `~.collections.LineCollection` instance that marks
8302             the centers of each violin's distribution.
8303 
8304           - ``cmedians``: A `~.collections.LineCollection` instance that
8305             marks the median values of each of the violin's distribution.
8306 
8307           - ``cquantiles``: A `~.collections.LineCollection` instance created
8308             to identify the quantiles values of each of the violin's
8309             distribution.
8310         """
8311 
8312         # Statistical quantities to be plotted on the violins
8313         means = []
8314         mins = []
8315         maxes = []
8316         medians = []
8317         quantiles = []
8318 
8319         qlens = []  # Number of quantiles in each dataset.
8320 
8321         artists = {}  # Collections to be returned
8322 
8323         N = len(vpstats)
8324         datashape_message = ("List of violinplot statistics and `{0}` "
8325                              "values must have the same length")
8326 
8327         # Validate positions
8328         if positions is None:
8329             positions = range(1, N + 1)
8330         elif len(positions) != N:
8331             raise ValueError(datashape_message.format("positions"))
8332 
8333         # Validate widths
8334         if np.isscalar(widths):
8335             widths = [widths] * N
8336         elif len(widths) != N:
8337             raise ValueError(datashape_message.format("widths"))
8338 
8339         # Calculate ranges for statistics lines (shape (2, N)).
8340         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8341 
8342         # Colors.
8343         if mpl.rcParams['_internal.classic_mode']:
8344             fillcolor = 'y'
8345             linecolor = 'r'
8346         else:
8347             fillcolor = linecolor = self._get_lines.get_next_color()
8348 
8349         # Check whether we are rendering vertically or horizontally
8350         if vert:
8351             fill = self.fill_betweenx
8352             perp_lines = functools.partial(self.hlines, colors=linecolor)
8353             par_lines = functools.partial(self.vlines, colors=linecolor)
8354         else:
8355             fill = self.fill_between
8356             perp_lines = functools.partial(self.vlines, colors=linecolor)
8357             par_lines = functools.partial(self.hlines, colors=linecolor)
8358 
8359         # Render violins
8360         bodies = []
8361         for stats, pos, width in zip(vpstats, positions, widths):
8362             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8363             vals = np.array(stats['vals'])
8364             vals = 0.5 * width * vals / vals.max()
8365             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8366                             facecolor=fillcolor, alpha=0.3)]
8367             means.append(stats['mean'])
8368             mins.append(stats['min'])
8369             maxes.append(stats['max'])
8370             medians.append(stats['median'])
8371             q = stats.get('quantiles')  # a list of floats, or None
8372             if q is None:
8373                 q = []
8374             quantiles.extend(q)
8375             qlens.append(len(q))
8376         artists['bodies'] = bodies
8377 
8378         if showmeans:  # Render means
8379             artists['cmeans'] = perp_lines(means, *line_ends)
8380         if showextrema:  # Render extrema
8381             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8382             artists['cmins'] = perp_lines(mins, *line_ends)
8383             artists['cbars'] = par_lines(positions, mins, maxes)
8384         if showmedians:  # Render medians
8385             artists['cmedians'] = perp_lines(medians, *line_ends)
8386         if quantiles:  # Render quantiles: each width is repeated qlen times.
8387             artists['cquantiles'] = perp_lines(
8388                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8389 
8390         return artists
8391 
8392     # Methods that are entirely implemented in other modules.
8393 
8394     table = mtable.table
8395 
8396     # args can be either Y or y1, y2, ... and all should be replaced
8397     stackplot = _preprocess_data()(mstack.stackplot)
8398 
8399     streamplot = _preprocess_data(
8400         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8401 
8402     tricontour = mtri.tricontour
8403     tricontourf = mtri.tricontourf
8404     tripcolor = mtri.tripcolor
8405     triplot = mtri.triplot
8406 
8407     def _get_aspect_ratio(self):
8408         """
8409         Convenience method to calculate the aspect ratio of the axes in
8410         the display coordinate system.
8411         """
8412         figure_size = self.get_figure().get_size_inches()
8413         ll, ur = self.get_position() * figure_size
8414         width, height = ur - ll
8415         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>barh</method>
<code>
2564     def barh(self, y, width, height=0.8, left=None, *, align="center",
2565              data=None, **kwargs):
2566         r"""
2567         Make a horizontal bar plot.
2568 
2569         The bars are positioned at *y* with the given *align*\ment. Their
2570         dimensions are given by *width* and *height*. The horizontal baseline
2571         is *left* (default 0).
2572 
2573         Many parameters can take either a single value applying to all bars
2574         or a sequence of values, one for each bar.
2575 
2576         Parameters
2577         ----------
2578         y : float or array-like
2579             The y coordinates of the bars. See also *align* for the
2580             alignment of the bars to the coordinates.
2581 
2582         width : float or array-like
2583             The width(s) of the bars.
2584 
2585         height : float or array-like, default: 0.8
2586             The heights of the bars.
2587 
2588         left : float or array-like, default: 0
2589             The x coordinates of the left side(s) of the bars.
2590 
2591         align : {'center', 'edge'}, default: 'center'
2592             Alignment of the base to the *y* coordinates*:
2593 
2594             - 'center': Center the bars on the *y* positions.
2595             - 'edge': Align the bottom edges of the bars with the *y*
2596               positions.
2597 
2598             To align the bars on the top edge pass a negative *height* and
2599             ``align='edge'``.
2600 
2601         Returns
2602         -------
2603         `.BarContainer`
2604             Container with all the bars and optionally errorbars.
2605 
2606         Other Parameters
2607         ----------------
2608         color : color or list of color, optional
2609             The colors of the bar faces.
2610 
2611         edgecolor : color or list of color, optional
2612             The colors of the bar edges.
2613 
2614         linewidth : float or array-like, optional
2615             Width of the bar edge(s). If 0, don't draw edges.
2616 
2617         tick_label : str or list of str, optional
2618             The tick labels of the bars.
2619             Default: None (Use default numeric labels.)
2620 
2621         label : str or list of str, optional
2622             A single label is attached to the resulting `.BarContainer` as a
2623             label for the whole dataset.
2624             If a list is provided, it must be the same length as *y* and
2625             labels the individual bars. Repeated labels are not de-duplicated
2626             and will cause repeated label entries, so this is best used when
2627             bars also differ in style (e.g., by passing a list to *color*.)
2628 
2629         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2630             If not *None*, add horizontal / vertical errorbars to the bar tips.
2631             The values are +/- sizes relative to the data:
2632 
2633             - scalar: symmetric +/- values for all bars
2634             - shape(N,): symmetric +/- values for each bar
2635             - shape(2, N): Separate - and + values for each bar. First row
2636               contains the lower errors, the second row contains the upper
2637               errors.
2638             - *None*: No errorbar. (default)
2639 
2640             See :doc:`/gallery/statistics/errorbar_features` for an example on
2641             the usage of *xerr* and *yerr*.
2642 
2643         ecolor : color or list of color, default: 'black'
2644             The line color of the errorbars.
2645 
2646         capsize : float, default: :rc:`errorbar.capsize`
2647            The length of the error bar caps in points.
2648 
2649         error_kw : dict, optional
2650             Dictionary of keyword arguments to be passed to the
2651             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2652             here take precedence over the independent keyword arguments.
2653 
2654         log : bool, default: False
2655             If ``True``, set the x-axis to be log scale.
2656 
2657         data : indexable object, optional
2658             If given, all parameters also accept a string ``s``, which is
2659             interpreted as ``data[s]`` (unless this raises an exception).
2660 
2661         **kwargs : `.Rectangle` properties
2662 
2663         %(Rectangle:kwdoc)s
2664 
2665         See Also
2666         --------
2667         bar : Plot a vertical bar plot.
2668 
2669         Notes
2670         -----
2671         Stacked bars can be achieved by passing individual *left* values per
2672         bar. See
2673         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2674         """
2675         kwargs.setdefault('orientation', 'horizontal')
2676         patches = self.bar(x=left, height=height, width=width, bottom=y,
2677                            align=align, data=data, **kwargs)
2678         return patches

</code><intended_behavior>Similarly to the `bar` method, `barh` should be enhanced to identify when the `left` parameter receives datetime objects and perform necessary conversions or adjustments to ensure the y-axis (for horizontal bars) adequately represents datetime scales. This preserves the method's current capabilities while extending its functionality to support datetime objects, addressing the reported issue of incorrect datetime units representation in horizontal bar plots.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
320                 [self],
321                 *args,
322                 **kwargs)
323         if len(extra_args):
324             raise _api.nargs_error('legend', '0-2', len(args))
325         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
326         self.legend_._remove_method = self._remove_legend
327         return self.legend_
328 
329     def _remove_legend(self, legend):
330         self.legend_ = None
331 
332     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
333         """
334         Add a child inset Axes to this existing Axes.
335 
336         Warnings
337         --------
338         This method is experimental as of 3.0, and the API may change.
339 
340         Parameters
341         ----------
342         bounds : [x0, y0, width, height]
343             Lower-left corner of inset Axes, and its width and height.
344 
345         transform : `.Transform`
346             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
347             Axes-relative coordinates.
348 
349         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
350 'polar', 'rectilinear', str}, optional
351             The projection type of the inset `~.axes.Axes`. *str* is the name
352             of a custom projection, see `~matplotlib.projections`. The default
353             None results in a 'rectilinear' projection.
354 
355         polar : bool, default: False
356             If True, equivalent to projection='polar'.
357 
358         axes_class : subclass type of `~.axes.Axes`, optional
359             The `.axes.Axes` subclass that is instantiated.  This parameter
360             is incompatible with *projection* and *polar*.  See
361             :ref:`axisartist_users-guide-index` for examples.
362 
363         zorder : number
364             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
365             to change whether it is above or below data plotted on the
366             parent Axes.
367 
368         **kwargs
369             Other keyword arguments are passed on to the inset Axes class.
370 
371         Returns
372         -------
373         ax
374             The created `~.axes.Axes` instance.
375 
376         Examples
377         --------
378         This example makes two inset Axes, the first is in Axes-relative
379         coordinates, and the second in data-coordinates::
380 
381             fig, ax = plt.subplots()
382             ax.plot(range(10))
383             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
384             axin2 = ax.inset_axes(
385                     [5, 7, 2.3, 2.3], transform=ax.transData)
386 
387         """
388         if transform is None:
389             transform = self.transAxes
390         kwargs.setdefault('label', 'inset_axes')
391 
392         # This puts the rectangle into figure-relative coordinates.
393         inset_locator = _TransformedBoundsLocator(bounds, transform)
394         bounds = inset_locator(self, None).bounds
395         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
396         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
397 
398         # this locator lets the axes move if in data coordinates.
399         # it gets called in `ax.apply_aspect() (of all places)
400         inset_ax.set_axes_locator(inset_locator)
401 
402         self.add_child_axes(inset_ax)
403 
404         return inset_ax
405 
406     @_docstring.dedent_interpd
407     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
408                        facecolor='none', edgecolor='0.5', alpha=0.5,
409                        zorder=4.99, **kwargs):
410         """
411         Add an inset indicator to the Axes.  This is a rectangle on the plot
412         at the position indicated by *bounds* that optionally has lines that
413         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
414 
415         Warnings
416         --------
417         This method is experimental as of 3.0, and the API may change.
418 
419         Parameters
420         ----------
421         bounds : [x0, y0, width, height]
422             Lower-left corner of rectangle to be marked, and its width
423             and height.
424 
425         inset_ax : `.Axes`
426             An optional inset Axes to draw connecting lines to.  Two lines are
427             drawn connecting the indicator box to the inset Axes on corners
428             chosen so as to not overlap with the indicator box.
429 
430         transform : `.Transform`
431             Transform for the rectangle coordinates. Defaults to
432             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
433             coordinates.
434 
435         facecolor : color, default: 'none'
436             Facecolor of the rectangle.
437 
438         edgecolor : color, default: '0.5'
439             Color of the rectangle and color of the connecting lines.
440 
441         alpha : float, default: 0.5
442             Transparency of the rectangle and connector lines.
443 
444         zorder : float, default: 4.99
445             Drawing order of the rectangle and connector lines.  The default,
446             4.99, is just below the default level of inset Axes.
447 
448         **kwargs
449             Other keyword arguments are passed on to the `.Rectangle` patch:
450 
451             %(Rectangle:kwdoc)s
452 
453         Returns
454         -------
455         rectangle_patch : `.patches.Rectangle`
456              The indicator frame.
457 
458         connector_lines : 4-tuple of `.patches.ConnectionPatch`
459             The four connector lines connecting to (lower_left, upper_left,
460             lower_right upper_right) corners of *inset_ax*. Two lines are
461             set with visibility to *False*,  but the user can set the
462             visibility to True if the automatic choice is not deemed correct.
463 
464         """
465         # to make the axes connectors work, we need to apply the aspect to
466         # the parent axes.
467         self.apply_aspect()
468 
469         if transform is None:
470             transform = self.transData
471         kwargs.setdefault('label', '_indicate_inset')
472 
473         x, y, width, height = bounds
474         rectangle_patch = mpatches.Rectangle(
475             (x, y), width, height,
476             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
477             zorder=zorder, transform=transform, **kwargs)
478         self.add_patch(rectangle_patch)
479 
480         connects = []
481 
482         if inset_ax is not None:
483             # connect the inset_axes to the rectangle
484             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
485                 # inset_ax positions are in axes coordinates
486                 # The 0, 1 values define the four edges if the inset_ax
487                 # lower_left, upper_left, lower_right upper_right.
488                 ex, ey = xy_inset_ax
489                 if self.xaxis.get_inverted():
490                     ex = 1 - ex
491                 if self.yaxis.get_inverted():
492                     ey = 1 - ey
493                 xy_data = x + ex * width, y + ey * height
494                 p = mpatches.ConnectionPatch(
495                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
496                     xyB=xy_data, coordsB=self.transData,
497                     arrowstyle="-", zorder=zorder,
498                     edgecolor=edgecolor, alpha=alpha)
499                 connects.append(p)
500                 self.add_patch(p)
501 
502             # decide which two of the lines to keep visible....
503             pos = inset_ax.get_position()
504             bboxins = pos.transformed(self.figure.transSubfigure)
505             rectbbox = mtransforms.Bbox.from_bounds(
506                 *bounds
507             ).transformed(transform)
508             x0 = rectbbox.x0 < bboxins.x0
509             x1 = rectbbox.x1 < bboxins.x1
510             y0 = rectbbox.y0 < bboxins.y0
511             y1 = rectbbox.y1 < bboxins.y1
512             connects[0].set_visible(x0 ^ y0)
513             connects[1].set_visible(x0 == y1)
514             connects[2].set_visible(x1 == y0)
515             connects[3].set_visible(x1 ^ y1)
516 
517         return rectangle_patch, tuple(connects) if connects else None
518 
519     def indicate_inset_zoom(self, inset_ax, **kwargs):
520         """
521         Add an inset indicator rectangle to the Axes based on the axis
522         limits for an *inset_ax* and draw connectors between *inset_ax*
523         and the rectangle.
524 
525         Warnings
526         --------
527         This method is experimental as of 3.0, and the API may change.
528 
529         Parameters
530         ----------
531         inset_ax : `.Axes`
532             Inset Axes to draw connecting lines to.  Two lines are
533             drawn connecting the indicator box to the inset Axes on corners
534             chosen so as to not overlap with the indicator box.
535 
536         **kwargs
537             Other keyword arguments are passed on to `.Axes.indicate_inset`
538 
539         Returns
540         -------
541         rectangle_patch : `.patches.Rectangle`
542              Rectangle artist.
543 
544         connector_lines : 4-tuple of `.patches.ConnectionPatch`
545             Each of four connector lines coming from the rectangle drawn on
546             this axis, in the order lower left, upper left, lower right,
547             upper right.
548             Two are set with visibility to *False*,  but the user can
549             set the visibility to *True* if the automatic choice is not deemed
550             correct.
551         """
552 
553         xlim = inset_ax.get_xlim()
554         ylim = inset_ax.get_ylim()
555         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
556         return self.indicate_inset(rect, inset_ax, **kwargs)
557 
558     @_docstring.dedent_interpd
559     def secondary_xaxis(self, location, *, functions=None, **kwargs):
560         """
561         Add a second x-axis to this `~.axes.Axes`.
562 
563         For example if we want to have a second scale for the data plotted on
564         the xaxis.
565 
566         %(_secax_docstring)s
567 
568         Examples
569         --------
570         The main axis shows frequency, and the secondary axis shows period.
571 
572         .. plot::
573 
574             fig, ax = plt.subplots()
575             ax.loglog(range(1, 360, 5), range(1, 360, 5))
576             ax.set_xlabel('frequency [Hz]')
577 
578             def invert(x):
579                 # 1/x with special treatment of x == 0
580                 x = np.array(x).astype(float)
581                 near_zero = np.isclose(x, 0)
582                 x[near_zero] = np.inf
583                 x[~near_zero] = 1 / x[~near_zero]
584                 return x
585 
586             # the inverse of 1/x is itself
587             secax = ax.secondary_xaxis('top', functions=(invert, invert))
588             secax.set_xlabel('Period [s]')
589             plt.show()
590         """
591         if location in ['top', 'bottom'] or isinstance(location, Real):
592             secondary_ax = SecondaryAxis(self, 'x', location, functions,
593                                          **kwargs)
594             self.add_child_axes(secondary_ax)
595             return secondary_ax
596         else:
597             raise ValueError('secondary_xaxis location must be either '
598                              'a float or "top"/"bottom"')
599 
600     @_docstring.dedent_interpd
601     def secondary_yaxis(self, location, *, functions=None, **kwargs):
602         """
603         Add a second y-axis to this `~.axes.Axes`.
604 
605         For example if we want to have a second scale for the data plotted on
606         the yaxis.
607 
608         %(_secax_docstring)s
609 
610         Examples
611         --------
612         Add a secondary Axes that converts from radians to degrees
613 
614         .. plot::
615 
616             fig, ax = plt.subplots()
617             ax.plot(range(1, 360, 5), range(1, 360, 5))
618             ax.set_ylabel('degrees')
619             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
620                                                            np.rad2deg))
621             secax.set_ylabel('radians')
622         """
623         if location in ['left', 'right'] or isinstance(location, Real):
624             secondary_ax = SecondaryAxis(self, 'y', location,
625                                          functions, **kwargs)
626             self.add_child_axes(secondary_ax)
627             return secondary_ax
628         else:
629             raise ValueError('secondary_yaxis location must be either '
630                              'a float or "left"/"right"')
631 
632     @_docstring.dedent_interpd
633     def text(self, x, y, s, fontdict=None, **kwargs):
634         """
635         Add text to the Axes.
636 
637         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
638 
639         Parameters
640         ----------
641         x, y : float
642             The position to place the text. By default, this is in data
643             coordinates. The coordinate system can be changed using the
644             *transform* parameter.
645 
646         s : str
647             The text.
648 
649         fontdict : dict, default: None
650 
651             .. admonition:: Discouraged
652 
653                The use of *fontdict* is discouraged. Parameters should be passed as
654                individual keyword arguments or using dictionary-unpacking
655                ``text(..., **fontdict)``.
656 
657             A dictionary to override the default text properties. If fontdict
658             is None, the defaults are determined by `.rcParams`.
659 
660         Returns
661         -------
662         `.Text`
663             The created `.Text` instance.
664 
665         Other Parameters
666         ----------------
667         **kwargs : `~matplotlib.text.Text` properties.
668             Other miscellaneous text parameters.
669 
670             %(Text:kwdoc)s
671 
672         Examples
673         --------
674         Individual keyword arguments can be used to override any given
675         parameter::
676 
677             >>> text(x, y, s, fontsize=12)
678 
679         The default transform specifies that text is in data coords,
680         alternatively, you can specify text in axis coords ((0, 0) is
681         lower-left and (1, 1) is upper-right).  The example below places
682         text in the center of the Axes::
683 
684             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
685             ...      verticalalignment='center', transform=ax.transAxes)
686 
687         You can put a rectangular box around the text instance (e.g., to
688         set a background color) by using the keyword *bbox*.  *bbox* is
689         a dictionary of `~matplotlib.patches.Rectangle`
690         properties.  For example::
691 
692             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
693         """
694         effective_kwargs = {
695             'verticalalignment': 'baseline',
696             'horizontalalignment': 'left',
697             'transform': self.transData,
698             'clip_on': False,
699             **(fontdict if fontdict is not None else {}),
700             **kwargs,
701         }
702         t = mtext.Text(x, y, text=s, **effective_kwargs)
703         if t.get_clip_path() is None:
704             t.set_clip_path(self.patch)
705         self._add_text(t)
706         return t
707 
708     @_docstring.dedent_interpd
709     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
710                  arrowprops=None, annotation_clip=None, **kwargs):
711         # Signature must match Annotation. This is verified in
712         # test_annotate_signature().
713         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
714                              textcoords=textcoords, arrowprops=arrowprops,
715                              annotation_clip=annotation_clip, **kwargs)
716         a.set_transform(mtransforms.IdentityTransform())
717         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
718             a.set_clip_path(self.patch)
719         self._add_text(a)
720         return a
721     annotate.__doc__ = mtext.Annotation.__init__.__doc__
722     #### Lines and spans
723 
724     @_docstring.dedent_interpd
725     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
726         """
727         Add a horizontal line across the Axes.
728 
729         Parameters
730         ----------
731         y : float, default: 0
732             y position in data coordinates of the horizontal line.
733 
734         xmin : float, default: 0
735             Should be between 0 and 1, 0 being the far left of the plot, 1 the
736             far right of the plot.
737 
738         xmax : float, default: 1
739             Should be between 0 and 1, 0 being the far left of the plot, 1 the
740             far right of the plot.
741 
742         Returns
743         -------
744         `~matplotlib.lines.Line2D`
745 
746         Other Parameters
747         ----------------
748         **kwargs
749             Valid keyword arguments are `.Line2D` properties, except for
750             'transform':
751 
752             %(Line2D:kwdoc)s
753 
754         See Also
755         --------
756         hlines : Add horizontal lines in data coordinates.
757         axhspan : Add a horizontal span (rectangle) across the axis.
758         axline : Add a line with an arbitrary slope.
759 
760         Examples
761         --------
762         * draw a thick red hline at 'y' = 0 that spans the xrange::
763 
764             >>> axhline(linewidth=4, color='r')
765 
766         * draw a default hline at 'y' = 1 that spans the xrange::
767 
768             >>> axhline(y=1)
769 
770         * draw a default hline at 'y' = .5 that spans the middle half of
771           the xrange::
772 
773             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
774         """
775         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
776         if "transform" in kwargs:
777             raise ValueError("'transform' is not allowed as a keyword "
778                              "argument; axhline generates its own transform.")
779         ymin, ymax = self.get_ybound()
780 
781         # Strip away the units for comparison with non-unitized bounds.
782         yy, = self._process_unit_info([("y", y)], kwargs)
783         scaley = (yy < ymin) or (yy > ymax)
784 
785         trans = self.get_yaxis_transform(which='grid')
786         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
787         self.add_line(l)
788         if scaley:
789             self._request_autoscale_view("y")
790         return l
791 
792     @_docstring.dedent_interpd
793     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
794         """
795         Add a vertical line across the Axes.
796 
797         Parameters
798         ----------
799         x : float, default: 0
800             x position in data coordinates of the vertical line.
801 
802         ymin : float, default: 0
803             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
804             top of the plot.
805 
806         ymax : float, default: 1
807             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
808             top of the plot.
809 
810         Returns
811         -------
812         `~matplotlib.lines.Line2D`
813 
814         Other Parameters
815         ----------------
816         **kwargs
817             Valid keyword arguments are `.Line2D` properties, except for
818             'transform':
819 
820             %(Line2D:kwdoc)s
821 
822         See Also
823         --------
824         vlines : Add vertical lines in data coordinates.
825         axvspan : Add a vertical span (rectangle) across the axis.
826         axline : Add a line with an arbitrary slope.
827 
828         Examples
829         --------
830         * draw a thick red vline at *x* = 0 that spans the yrange::
831 
832             >>> axvline(linewidth=4, color='r')
833 
834         * draw a default vline at *x* = 1 that spans the yrange::
835 
836             >>> axvline(x=1)
837 
838         * draw a default vline at *x* = .5 that spans the middle half of
839           the yrange::
840 
841             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
842         """
843         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
844         if "transform" in kwargs:
845             raise ValueError("'transform' is not allowed as a keyword "
846                              "argument; axvline generates its own transform.")
847         xmin, xmax = self.get_xbound()
848 
849         # Strip away the units for comparison with non-unitized bounds.
850         xx, = self._process_unit_info([("x", x)], kwargs)
851         scalex = (xx < xmin) or (xx > xmax)
852 
853         trans = self.get_xaxis_transform(which='grid')
854         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
855         self.add_line(l)
856         if scalex:
857             self._request_autoscale_view("x")
858         return l
859 
860     @staticmethod
861     def _check_no_units(vals, names):
862         # Helper method to check that vals are not unitized
863         for val, name in zip(vals, names):
864             if not munits._is_natively_supported(val):
865                 raise ValueError(f"{name} must be a single scalar value, "
866                                  f"but got {val}")
867 
868     @_docstring.dedent_interpd
869     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
870         """
871         Add an infinitely long straight line.
872 
873         The line can be defined either by two points *xy1* and *xy2*, or
874         by one point *xy1* and a *slope*.
875 
876         This draws a straight line "on the screen", regardless of the x and y
877         scales, and is thus also suitable for drawing exponential decays in
878         semilog plots, power laws in loglog plots, etc. However, *slope*
879         should only be used with linear scales; It has no clear meaning for
880         all other scales, and thus the behavior is undefined. Please specify
881         the line using the points *xy1*, *xy2* for non-linear scales.
882 
883         The *transform* keyword argument only applies to the points *xy1*,
884         *xy2*. The *slope* (if given) is always in data coordinates. This can
885         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
886         slope.
887 
888         Parameters
889         ----------
890         xy1, xy2 : (float, float)
891             Points for the line to pass through.
892             Either *xy2* or *slope* has to be given.
893         slope : float, optional
894             The slope of the line. Either *xy2* or *slope* has to be given.
895 
896         Returns
897         -------
898         `.Line2D`
899 
900         Other Parameters
901         ----------------
902         **kwargs
903             Valid kwargs are `.Line2D` properties
904 
905             %(Line2D:kwdoc)s
906 
907         See Also
908         --------
909         axhline : for horizontal lines
910         axvline : for vertical lines
911 
912         Examples
913         --------
914         Draw a thick red line passing through (0, 0) and (1, 1)::
915 
916             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
917         """
918         if slope is not None and (self.get_xscale() != 'linear' or
919                                   self.get_yscale() != 'linear'):
920             raise TypeError("'slope' cannot be used with non-linear scales")
921 
922         datalim = [xy1] if xy2 is None else [xy1, xy2]
923         if "transform" in kwargs:
924             # if a transform is passed (i.e. line points not in data space),
925             # data limits should not be adjusted.
926             datalim = []
927 
928         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
929         # Like add_line, but correctly handling data limits.
930         self._set_artist_props(line)
931         if line.get_clip_path() is None:
932             line.set_clip_path(self.patch)
933         if not line.get_label():
934             line.set_label(f"_child{len(self._children)}")
935         self._children.append(line)
936         line._remove_method = self._children.remove
937         self.update_datalim(datalim)
938 
939         self._request_autoscale_view()
940         return line
941 
942     @_docstring.dedent_interpd
943     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
944         """
945         Add a horizontal span (rectangle) across the Axes.
946 
947         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
948         the whole x-axis horizontally.  The x-span can be set using *xmin*
949         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
950         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
951         the limits set by `~.Axes.set_xlim`.
952 
953         Parameters
954         ----------
955         ymin : float
956             Lower y-coordinate of the span, in data units.
957         ymax : float
958             Upper y-coordinate of the span, in data units.
959         xmin : float, default: 0
960             Lower x-coordinate of the span, in x-axis (0-1) units.
961         xmax : float, default: 1
962             Upper x-coordinate of the span, in x-axis (0-1) units.
963 
964         Returns
965         -------
966         `~matplotlib.patches.Polygon`
967             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
968 
969         Other Parameters
970         ----------------
971         **kwargs : `~matplotlib.patches.Polygon` properties
972 
973         %(Polygon:kwdoc)s
974 
975         See Also
976         --------
977         axvspan : Add a vertical span across the Axes.
978         """
979         # Strip units away.
980         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
981         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
982 
983         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
984         p = mpatches.Polygon(verts, **kwargs)
985         p.set_transform(self.get_yaxis_transform(which="grid"))
986         self.add_patch(p)
987         self._request_autoscale_view("y")
988         return p
989 
990     @_docstring.dedent_interpd
991     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
992         """
993         Add a vertical span (rectangle) across the Axes.
994 
995         The rectangle spans from *xmin* to *xmax* horizontally, and, by
996         default, the whole y-axis vertically.  The y-span can be set using
997         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
998         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
999         regardless of the limits set by `~.Axes.set_ylim`.
1000 
1001         Parameters
1002         ----------
1003         xmin : float
1004             Lower x-coordinate of the span, in data units.
1005         xmax : float
1006             Upper x-coordinate of the span, in data units.
1007         ymin : float, default: 0
1008             Lower y-coordinate of the span, in y-axis units (0-1).
1009         ymax : float, default: 1
1010             Upper y-coordinate of the span, in y-axis units (0-1).
1011 
1012         Returns
1013         -------
1014         `~matplotlib.patches.Polygon`
1015             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1016 
1017         Other Parameters
1018         ----------------
1019         **kwargs : `~matplotlib.patches.Polygon` properties
1020 
1021         %(Polygon:kwdoc)s
1022 
1023         See Also
1024         --------
1025         axhspan : Add a horizontal span across the Axes.
1026 
1027         Examples
1028         --------
1029         Draw a vertical, green, translucent rectangle from x = 1.25 to
1030         x = 1.55 that spans the yrange of the Axes.
1031 
1032         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1033 
1034         """
1035         # Strip units away.
1036         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1037         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1038 
1039         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1040         p = mpatches.Polygon(verts, **kwargs)
1041         p.set_transform(self.get_xaxis_transform(which="grid"))
1042         p.get_path()._interpolation_steps = 100
1043         self.add_patch(p)
1044         self._request_autoscale_view("x")
1045         return p
1046 
1047     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1048                       label_namer="y")
1049     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1050                label='', **kwargs):
1051         """
1052         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1053 
1054         Parameters
1055         ----------
1056         y : float or array-like
1057             y-indexes where to plot the lines.
1058 
1059         xmin, xmax : float or array-like
1060             Respective beginning and end of each line. If scalars are
1061             provided, all lines will have the same length.
1062 
1063         colors : color or list of colors, default: :rc:`lines.color`
1064 
1065         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1066 
1067         label : str, default: ''
1068 
1069         Returns
1070         -------
1071         `~matplotlib.collections.LineCollection`
1072 
1073         Other Parameters
1074         ----------------
1075         data : indexable object, optional
1076             DATA_PARAMETER_PLACEHOLDER
1077         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1078 
1079         See Also
1080         --------
1081         vlines : vertical lines
1082         axhline : horizontal line across the Axes
1083         """
1084 
1085         # We do the conversion first since not all unitized data is uniform
1086         xmin, xmax, y = self._process_unit_info(
1087             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1088 
1089         if not np.iterable(y):
1090             y = [y]
1091         if not np.iterable(xmin):
1092             xmin = [xmin]
1093         if not np.iterable(xmax):
1094             xmax = [xmax]
1095 
1096         # Create and combine masked_arrays from input
1097         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1098         y = np.ravel(y)
1099         xmin = np.ravel(xmin)
1100         xmax = np.ravel(xmax)
1101 
1102         masked_verts = np.ma.empty((len(y), 2, 2))
1103         masked_verts[:, 0, 0] = xmin
1104         masked_verts[:, 0, 1] = y
1105         masked_verts[:, 1, 0] = xmax
1106         masked_verts[:, 1, 1] = y
1107 
1108         lines = mcoll.LineCollection(masked_verts, colors=colors,
1109                                      linestyles=linestyles, label=label)
1110         self.add_collection(lines, autolim=False)
1111         lines._internal_update(kwargs)
1112 
1113         if len(y) > 0:
1114             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1115             # the case of y being a masked *object* array (as can be generated
1116             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1117             updatex = True
1118             updatey = True
1119             if self.name == "rectilinear":
1120                 datalim = lines.get_datalim(self.transData)
1121                 t = lines.get_transform()
1122                 updatex, updatey = t.contains_branch_seperately(self.transData)
1123                 minx = np.nanmin(datalim.xmin)
1124                 maxx = np.nanmax(datalim.xmax)
1125                 miny = np.nanmin(datalim.ymin)
1126                 maxy = np.nanmax(datalim.ymax)
1127             else:
1128                 minx = np.nanmin(masked_verts[..., 0])
1129                 maxx = np.nanmax(masked_verts[..., 0])
1130                 miny = np.nanmin(masked_verts[..., 1])
1131                 maxy = np.nanmax(masked_verts[..., 1])
1132 
1133             corners = (minx, miny), (maxx, maxy)
1134             self.update_datalim(corners, updatex, updatey)
1135             self._request_autoscale_view()
1136         return lines
1137 
1138     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1139                       label_namer="x")
1140     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1141                label='', **kwargs):
1142         """
1143         Plot vertical lines at each *x* from *ymin* to *ymax*.
1144 
1145         Parameters
1146         ----------
1147         x : float or array-like
1148             x-indexes where to plot the lines.
1149 
1150         ymin, ymax : float or array-like
1151             Respective beginning and end of each line. If scalars are
1152             provided, all lines will have the same length.
1153 
1154         colors : color or list of colors, default: :rc:`lines.color`
1155 
1156         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1157 
1158         label : str, default: ''
1159 
1160         Returns
1161         -------
1162         `~matplotlib.collections.LineCollection`
1163 
1164         Other Parameters
1165         ----------------
1166         data : indexable object, optional
1167             DATA_PARAMETER_PLACEHOLDER
1168         **kwargs : `~matplotlib.collections.LineCollection` properties.
1169 
1170         See Also
1171         --------
1172         hlines : horizontal lines
1173         axvline : vertical line across the Axes
1174         """
1175 
1176         # We do the conversion first since not all unitized data is uniform
1177         x, ymin, ymax = self._process_unit_info(
1178             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1179 
1180         if not np.iterable(x):
1181             x = [x]
1182         if not np.iterable(ymin):
1183             ymin = [ymin]
1184         if not np.iterable(ymax):
1185             ymax = [ymax]
1186 
1187         # Create and combine masked_arrays from input
1188         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1189         x = np.ravel(x)
1190         ymin = np.ravel(ymin)
1191         ymax = np.ravel(ymax)
1192 
1193         masked_verts = np.ma.empty((len(x), 2, 2))
1194         masked_verts[:, 0, 0] = x
1195         masked_verts[:, 0, 1] = ymin
1196         masked_verts[:, 1, 0] = x
1197         masked_verts[:, 1, 1] = ymax
1198 
1199         lines = mcoll.LineCollection(masked_verts, colors=colors,
1200                                      linestyles=linestyles, label=label)
1201         self.add_collection(lines, autolim=False)
1202         lines._internal_update(kwargs)
1203 
1204         if len(x) > 0:
1205             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1206             # the case of x being a masked *object* array (as can be generated
1207             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1208             updatex = True
1209             updatey = True
1210             if self.name == "rectilinear":
1211                 datalim = lines.get_datalim(self.transData)
1212                 t = lines.get_transform()
1213                 updatex, updatey = t.contains_branch_seperately(self.transData)
1214                 minx = np.nanmin(datalim.xmin)
1215                 maxx = np.nanmax(datalim.xmax)
1216                 miny = np.nanmin(datalim.ymin)
1217                 maxy = np.nanmax(datalim.ymax)
1218             else:
1219                 minx = np.nanmin(masked_verts[..., 0])
1220                 maxx = np.nanmax(masked_verts[..., 0])
1221                 miny = np.nanmin(masked_verts[..., 1])
1222                 maxy = np.nanmax(masked_verts[..., 1])
1223 
1224             corners = (minx, miny), (maxx, maxy)
1225             self.update_datalim(corners, updatex, updatey)
1226             self._request_autoscale_view()
1227         return lines
1228 
1229     @_preprocess_data(replace_names=["positions", "lineoffsets",
1230                                      "linelengths", "linewidths",
1231                                      "colors", "linestyles"])
1232     @_docstring.dedent_interpd
1233     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1234                   linelengths=1, linewidths=None, colors=None, alpha=None,
1235                   linestyles='solid', **kwargs):
1236         """
1237         Plot identical parallel lines at the given positions.
1238 
1239         This type of plot is commonly used in neuroscience for representing
1240         neural events, where it is usually called a spike raster, dot raster,
1241         or raster plot.
1242 
1243         However, it is useful in any situation where you wish to show the
1244         timing or position of multiple sets of discrete events, such as the
1245         arrival times of people to a business on each day of the month or the
1246         date of hurricanes each year of the last century.
1247 
1248         Parameters
1249         ----------
1250         positions : array-like or list of array-like
1251             A 1D array-like defines the positions of one sequence of events.
1252 
1253             Multiple groups of events may be passed as a list of array-likes.
1254             Each group can be styled independently by passing lists of values
1255             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1256             *linestyles*.
1257 
1258             Note that *positions* can be a 2D array, but in practice different
1259             event groups usually have different counts so that one will use a
1260             list of different-length arrays rather than a 2D array.
1261 
1262         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1263             The direction of the event sequence:
1264 
1265             - 'horizontal': the events are arranged horizontally.
1266               The indicator lines are vertical.
1267             - 'vertical': the events are arranged vertically.
1268               The indicator lines are horizontal.
1269 
1270         lineoffsets : float or array-like, default: 1
1271             The offset of the center of the lines from the origin, in the
1272             direction orthogonal to *orientation*.
1273 
1274             If *positions* is 2D, this can be a sequence with length matching
1275             the length of *positions*.
1276 
1277         linelengths : float or array-like, default: 1
1278             The total height of the lines (i.e. the lines stretches from
1279             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1280 
1281             If *positions* is 2D, this can be a sequence with length matching
1282             the length of *positions*.
1283 
1284         linewidths : float or array-like, default: :rc:`lines.linewidth`
1285             The line width(s) of the event lines, in points.
1286 
1287             If *positions* is 2D, this can be a sequence with length matching
1288             the length of *positions*.
1289 
1290         colors : color or list of colors, default: :rc:`lines.color`
1291             The color(s) of the event lines.
1292 
1293             If *positions* is 2D, this can be a sequence with length matching
1294             the length of *positions*.
1295 
1296         alpha : float or array-like, default: 1
1297             The alpha blending value(s), between 0 (transparent) and 1
1298             (opaque).
1299 
1300             If *positions* is 2D, this can be a sequence with length matching
1301             the length of *positions*.
1302 
1303         linestyles : str or tuple or list of such values, default: 'solid'
1304             Default is 'solid'. Valid strings are ['solid', 'dashed',
1305             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1306             should be of the form::
1307 
1308                 (offset, onoffseq),
1309 
1310             where *onoffseq* is an even length tuple of on and off ink
1311             in points.
1312 
1313             If *positions* is 2D, this can be a sequence with length matching
1314             the length of *positions*.
1315 
1316         data : indexable object, optional
1317             DATA_PARAMETER_PLACEHOLDER
1318 
1319         **kwargs
1320             Other keyword arguments are line collection properties.  See
1321             `.LineCollection` for a list of the valid properties.
1322 
1323         Returns
1324         -------
1325         list of `.EventCollection`
1326             The `.EventCollection` that were added.
1327 
1328         Notes
1329         -----
1330         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1331         only a single value is given, that value is applied to all lines. If an
1332         array-like is given, it must have the same length as *positions*, and
1333         each value will be applied to the corresponding row of the array.
1334 
1335         Examples
1336         --------
1337         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1338         """
1339 
1340         lineoffsets, linelengths = self._process_unit_info(
1341                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1342 
1343         # fix positions, noting that it can be a list of lists:
1344         if not np.iterable(positions):
1345             positions = [positions]
1346         elif any(np.iterable(position) for position in positions):
1347             positions = [np.asanyarray(position) for position in positions]
1348         else:
1349             positions = [np.asanyarray(positions)]
1350 
1351         poss = []
1352         for position in positions:
1353             poss += self._process_unit_info([("x", position)], kwargs)
1354         positions = poss
1355 
1356         # prevent 'singular' keys from **kwargs dict from overriding the effect
1357         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1358         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1359         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1360         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1361 
1362         if not np.iterable(lineoffsets):
1363             lineoffsets = [lineoffsets]
1364         if not np.iterable(linelengths):
1365             linelengths = [linelengths]
1366         if not np.iterable(linewidths):
1367             linewidths = [linewidths]
1368         if not np.iterable(colors):
1369             colors = [colors]
1370         if not np.iterable(alpha):
1371             alpha = [alpha]
1372         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1373             linestyles = [linestyles]
1374 
1375         lineoffsets = np.asarray(lineoffsets)
1376         linelengths = np.asarray(linelengths)
1377         linewidths = np.asarray(linewidths)
1378 
1379         if len(lineoffsets) == 0:
1380             raise ValueError('lineoffsets cannot be empty')
1381         if len(linelengths) == 0:
1382             raise ValueError('linelengths cannot be empty')
1383         if len(linestyles) == 0:
1384             raise ValueError('linestyles cannot be empty')
1385         if len(linewidths) == 0:
1386             raise ValueError('linewidths cannot be empty')
1387         if len(alpha) == 0:
1388             raise ValueError('alpha cannot be empty')
1389         if len(colors) == 0:
1390             colors = [None]
1391         try:
1392             # Early conversion of the colors into RGBA values to take care
1393             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1394             colors = mcolors.to_rgba_array(colors)
1395         except ValueError:
1396             # Will fail if any element of *colors* is None. But as long
1397             # as len(colors) == 1 or len(positions), the rest of the
1398             # code should process *colors* properly.
1399             pass
1400 
1401         if len(lineoffsets) == 1 and len(positions) != 1:
1402             lineoffsets = np.tile(lineoffsets, len(positions))
1403             lineoffsets[0] = 0
1404             lineoffsets = np.cumsum(lineoffsets)
1405         if len(linelengths) == 1:
1406             linelengths = np.tile(linelengths, len(positions))
1407         if len(linewidths) == 1:
1408             linewidths = np.tile(linewidths, len(positions))
1409         if len(colors) == 1:
1410             colors = list(colors) * len(positions)
1411         if len(alpha) == 1:
1412             alpha = list(alpha) * len(positions)
1413         if len(linestyles) == 1:
1414             linestyles = [linestyles] * len(positions)
1415 
1416         if len(lineoffsets) != len(positions):
1417             raise ValueError('lineoffsets and positions are unequal sized '
1418                              'sequences')
1419         if len(linelengths) != len(positions):
1420             raise ValueError('linelengths and positions are unequal sized '
1421                              'sequences')
1422         if len(linewidths) != len(positions):
1423             raise ValueError('linewidths and positions are unequal sized '
1424                              'sequences')
1425         if len(colors) != len(positions):
1426             raise ValueError('colors and positions are unequal sized '
1427                              'sequences')
1428         if len(alpha) != len(positions):
1429             raise ValueError('alpha and positions are unequal sized '
1430                              'sequences')
1431         if len(linestyles) != len(positions):
1432             raise ValueError('linestyles and positions are unequal sized '
1433                              'sequences')
1434 
1435         colls = []
1436         for position, lineoffset, linelength, linewidth, color, alpha_, \
1437             linestyle in \
1438                 zip(positions, lineoffsets, linelengths, linewidths,
1439                     colors, alpha, linestyles):
1440             coll = mcoll.EventCollection(position,
1441                                          orientation=orientation,
1442                                          lineoffset=lineoffset,
1443                                          linelength=linelength,
1444                                          linewidth=linewidth,
1445                                          color=color,
1446                                          alpha=alpha_,
1447                                          linestyle=linestyle)
1448             self.add_collection(coll, autolim=False)
1449             coll._internal_update(kwargs)
1450             colls.append(coll)
1451 
1452         if len(positions) > 0:
1453             # try to get min/max
1454             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1455                        if len(_p) > 0]
1456             # if we have any non-empty positions, try to autoscale
1457             if len(min_max) > 0:
1458                 mins, maxes = zip(*min_max)
1459                 minpos = np.min(mins)
1460                 maxpos = np.max(maxes)
1461 
1462                 minline = (lineoffsets - linelengths).min()
1463                 maxline = (lineoffsets + linelengths).max()
1464 
1465                 if orientation == "vertical":
1466                     corners = (minline, minpos), (maxline, maxpos)
1467                 else:  # "horizontal"
1468                     corners = (minpos, minline), (maxpos, maxline)
1469                 self.update_datalim(corners)
1470                 self._request_autoscale_view()
1471 
1472         return colls
1473 
1474     #### Basic plotting
1475 
1476     # Uses a custom implementation of data-kwarg handling in
1477     # _process_plot_var_args.
1478     @_docstring.dedent_interpd
1479     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1480         """
1481         Plot y versus x as lines and/or markers.
1482 
1483         Call signatures::
1484 
1485             plot([x], y, [fmt], *, data=None, **kwargs)
1486             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1487 
1488         The coordinates of the points or line nodes are given by *x*, *y*.
1489 
1490         The optional parameter *fmt* is a convenient way for defining basic
1491         formatting like color, marker and linestyle. It's a shortcut string
1492         notation described in the *Notes* section below.
1493 
1494         >>> plot(x, y)        # plot x and y using default line style and color
1495         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1496         >>> plot(y)           # plot y using x as index array 0..N-1
1497         >>> plot(y, 'r+')     # ditto, but with red plusses
1498 
1499         You can use `.Line2D` properties as keyword arguments for more
1500         control on the appearance. Line properties and *fmt* can be mixed.
1501         The following two calls yield identical results:
1502 
1503         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1504         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1505         ...      linewidth=2, markersize=12)
1506 
1507         When conflicting with *fmt*, keyword arguments take precedence.
1508 
1509 
1510         **Plotting labelled data**
1511 
1512         There's a convenient way for plotting objects with labelled data (i.e.
1513         data that can be accessed by index ``obj['y']``). Instead of giving
1514         the data in *x* and *y*, you can provide the object in the *data*
1515         parameter and just give the labels for *x* and *y*::
1516 
1517         >>> plot('xlabel', 'ylabel', data=obj)
1518 
1519         All indexable objects are supported. This could e.g. be a `dict`, a
1520         `pandas.DataFrame` or a structured numpy array.
1521 
1522 
1523         **Plotting multiple sets of data**
1524 
1525         There are various ways to plot multiple sets of data.
1526 
1527         - The most straight forward way is just to call `plot` multiple times.
1528           Example:
1529 
1530           >>> plot(x1, y1, 'bo')
1531           >>> plot(x2, y2, 'go')
1532 
1533         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1534           for every column. If both *x* and *y* are 2D, they must have the
1535           same shape. If only one of them is 2D with shape (N, m) the other
1536           must have length N and will be used for every data set m.
1537 
1538           Example:
1539 
1540           >>> x = [1, 2, 3]
1541           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1542           >>> plot(x, y)
1543 
1544           is equivalent to:
1545 
1546           >>> for col in range(y.shape[1]):
1547           ...     plot(x, y[:, col])
1548 
1549         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1550           groups::
1551 
1552           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1553 
1554           In this case, any additional keyword argument applies to all
1555           datasets. Also, this syntax cannot be combined with the *data*
1556           parameter.
1557 
1558         By default, each line is assigned a different style specified by a
1559         'style cycle'. The *fmt* and line property parameters are only
1560         necessary if you want explicit deviations from these defaults.
1561         Alternatively, you can also change the style cycle using
1562         :rc:`axes.prop_cycle`.
1563 
1564 
1565         Parameters
1566         ----------
1567         x, y : array-like or scalar
1568             The horizontal / vertical coordinates of the data points.
1569             *x* values are optional and default to ``range(len(y))``.
1570 
1571             Commonly, these parameters are 1D arrays.
1572 
1573             They can also be scalars, or two-dimensional (in that case, the
1574             columns represent separate data sets).
1575 
1576             These arguments cannot be passed as keywords.
1577 
1578         fmt : str, optional
1579             A format string, e.g. 'ro' for red circles. See the *Notes*
1580             section for a full description of the format strings.
1581 
1582             Format strings are just an abbreviation for quickly setting
1583             basic line properties. All of these and more can also be
1584             controlled by keyword arguments.
1585 
1586             This argument cannot be passed as keyword.
1587 
1588         data : indexable object, optional
1589             An object with labelled data. If given, provide the label names to
1590             plot in *x* and *y*.
1591 
1592             .. note::
1593                 Technically there's a slight ambiguity in calls where the
1594                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1595                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1596                 the former interpretation is chosen, but a warning is issued.
1597                 You may suppress the warning by adding an empty format string
1598                 ``plot('n', 'o', '', data=obj)``.
1599 
1600         Returns
1601         -------
1602         list of `.Line2D`
1603             A list of lines representing the plotted data.
1604 
1605         Other Parameters
1606         ----------------
1607         scalex, scaley : bool, default: True
1608             These parameters determine if the view limits are adapted to the
1609             data limits. The values are passed on to
1610             `~.axes.Axes.autoscale_view`.
1611 
1612         **kwargs : `.Line2D` properties, optional
1613             *kwargs* are used to specify properties like a line label (for
1614             auto legends), linewidth, antialiasing, marker face color.
1615             Example::
1616 
1617             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1618             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1619 
1620             If you specify multiple lines with one plot call, the kwargs apply
1621             to all those lines. In case the label object is iterable, each
1622             element is used as labels for each set of data.
1623 
1624             Here is a list of available `.Line2D` properties:
1625 
1626             %(Line2D:kwdoc)s
1627 
1628         See Also
1629         --------
1630         scatter : XY scatter plot with markers of varying size and/or color (
1631             sometimes also called bubble chart).
1632 
1633         Notes
1634         -----
1635         **Format Strings**
1636 
1637         A format string consists of a part for color, marker and line::
1638 
1639             fmt = '[marker][line][color]'
1640 
1641         Each of them is optional. If not provided, the value from the style
1642         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1643         the data will be a line without markers.
1644 
1645         Other combinations such as ``[color][marker][line]`` are also
1646         supported, but note that their parsing may be ambiguous.
1647 
1648         **Markers**
1649 
1650         =============   ===============================
1651         character       description
1652         =============   ===============================
1653         ``'.'``         point marker
1654         ``','``         pixel marker
1655         ``'o'``         circle marker
1656         ``'v'``         triangle_down marker
1657         ``'^'``         triangle_up marker
1658         ``'<'``         triangle_left marker
1659         ``'>'``         triangle_right marker
1660         ``'1'``         tri_down marker
1661         ``'2'``         tri_up marker
1662         ``'3'``         tri_left marker
1663         ``'4'``         tri_right marker
1664         ``'8'``         octagon marker
1665         ``'s'``         square marker
1666         ``'p'``         pentagon marker
1667         ``'P'``         plus (filled) marker
1668         ``'*'``         star marker
1669         ``'h'``         hexagon1 marker
1670         ``'H'``         hexagon2 marker
1671         ``'+'``         plus marker
1672         ``'x'``         x marker
1673         ``'X'``         x (filled) marker
1674         ``'D'``         diamond marker
1675         ``'d'``         thin_diamond marker
1676         ``'|'``         vline marker
1677         ``'_'``         hline marker
1678         =============   ===============================
1679 
1680         **Line Styles**
1681 
1682         =============    ===============================
1683         character        description
1684         =============    ===============================
1685         ``'-'``          solid line style
1686         ``'--'``         dashed line style
1687         ``'-.'``         dash-dot line style
1688         ``':'``          dotted line style
1689         =============    ===============================
1690 
1691         Example format strings::
1692 
1693             'b'    # blue markers with default shape
1694             'or'   # red circles
1695             '-g'   # green solid line
1696             '--'   # dashed line with default color
1697             '^k:'  # black triangle_up markers connected by a dotted line
1698 
1699         **Colors**
1700 
1701         The supported color abbreviations are the single letter codes
1702 
1703         =============    ===============================
1704         character        color
1705         =============    ===============================
1706         ``'b'``          blue
1707         ``'g'``          green
1708         ``'r'``          red
1709         ``'c'``          cyan
1710         ``'m'``          magenta
1711         ``'y'``          yellow
1712         ``'k'``          black
1713         ``'w'``          white
1714         =============    ===============================
1715 
1716         and the ``'CN'`` colors that index into the default property cycle.
1717 
1718         If the color is the only part of the format string, you can
1719         additionally use any  `matplotlib.colors` spec, e.g. full names
1720         (``'green'``) or hex strings (``'#008000'``).
1721         """
1722         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1723         lines = [*self._get_lines(*args, data=data, **kwargs)]
1724         for line in lines:
1725             self.add_line(line)
1726         if scalex:
1727             self._request_autoscale_view("x")
1728         if scaley:
1729             self._request_autoscale_view("y")
1730         return lines
1731 
1732     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1733     @_docstring.dedent_interpd
1734     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1735                   **kwargs):
1736         """
1737         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1738 
1739         .. admonition:: Discouraged
1740 
1741             This method exists for historic reasons and will be deprecated in
1742             the future.
1743 
1744             - ``datetime``-like data should directly be plotted using
1745               `~.Axes.plot`.
1746             -  If you need to plot plain numeric data as :ref:`date-format` or
1747                need to set a timezone, call ``ax.xaxis.axis_date`` /
1748                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1749                `.Axis.axis_date`.
1750 
1751         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1752         However, the axis labels are formatted as dates depending on *xdate*
1753         and *ydate*.  Note that `.plot` will work with `datetime` and
1754         `numpy.datetime64` objects without resorting to this method.
1755 
1756         Parameters
1757         ----------
1758         x, y : array-like
1759             The coordinates of the data points. If *xdate* or *ydate* is
1760             *True*, the respective values *x* or *y* are interpreted as
1761             :ref:`Matplotlib dates <date-format>`.
1762 
1763         fmt : str, optional
1764             The plot format string. For details, see the corresponding
1765             parameter in `.plot`.
1766 
1767         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1768             The time zone to use in labeling dates.
1769 
1770         xdate : bool, default: True
1771             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1772 
1773         ydate : bool, default: False
1774             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1775 
1776         Returns
1777         -------
1778         list of `.Line2D`
1779             Objects representing the plotted data.
1780 
1781         Other Parameters
1782         ----------------
1783         data : indexable object, optional
1784             DATA_PARAMETER_PLACEHOLDER
1785         **kwargs
1786             Keyword arguments control the `.Line2D` properties:
1787 
1788             %(Line2D:kwdoc)s
1789 
1790         See Also
1791         --------
1792         matplotlib.dates : Helper functions on dates.
1793         matplotlib.dates.date2num : Convert dates to num.
1794         matplotlib.dates.num2date : Convert num to dates.
1795         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1796 
1797         Notes
1798         -----
1799         If you are using custom date tickers and formatters, it may be
1800         necessary to set the formatters/locators after the call to
1801         `.plot_date`. `.plot_date` will set the default tick locator to
1802         `.AutoDateLocator` (if the tick locator is not already set to a
1803         `.DateLocator` instance) and the default tick formatter to
1804         `.AutoDateFormatter` (if the tick formatter is not already set to a
1805         `.DateFormatter` instance).
1806         """
1807         if xdate:
1808             self.xaxis_date(tz)
1809         if ydate:
1810             self.yaxis_date(tz)
1811         return self.plot(x, y, fmt, **kwargs)
1812 
1813     # @_preprocess_data() # let 'plot' do the unpacking..
1814     @_docstring.dedent_interpd
1815     def loglog(self, *args, **kwargs):
1816         """
1817         Make a plot with log scaling on both the x- and y-axis.
1818 
1819         Call signatures::
1820 
1821             loglog([x], y, [fmt], data=None, **kwargs)
1822             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1823 
1824         This is just a thin wrapper around `.plot` which additionally changes
1825         both the x-axis and the y-axis to log scaling. All the concepts and
1826         parameters of plot can be used here as well.
1827 
1828         The additional parameters *base*, *subs* and *nonpositive* control the
1829         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1830         `.Axes.set_yscale`. To use different properties on the x-axis and the
1831         y-axis, use e.g.
1832         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1833 
1834         Parameters
1835         ----------
1836         base : float, default: 10
1837             Base of the logarithm.
1838 
1839         subs : sequence, optional
1840             The location of the minor ticks. If *None*, reasonable locations
1841             are automatically chosen depending on the number of decades in the
1842             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1843 
1844         nonpositive : {'mask', 'clip'}, default: 'clip'
1845             Non-positive values can be masked as invalid, or clipped to a very
1846             small positive number.
1847 
1848         **kwargs
1849             All parameters supported by `.plot`.
1850 
1851         Returns
1852         -------
1853         list of `.Line2D`
1854             Objects representing the plotted data.
1855         """
1856         dx = {k: v for k, v in kwargs.items()
1857               if k in ['base', 'subs', 'nonpositive',
1858                        'basex', 'subsx', 'nonposx']}
1859         self.set_xscale('log', **dx)
1860         dy = {k: v for k, v in kwargs.items()
1861               if k in ['base', 'subs', 'nonpositive',
1862                        'basey', 'subsy', 'nonposy']}
1863         self.set_yscale('log', **dy)
1864         return self.plot(
1865             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1866 
1867     # @_preprocess_data() # let 'plot' do the unpacking..
1868     @_docstring.dedent_interpd
1869     def semilogx(self, *args, **kwargs):
1870         """
1871         Make a plot with log scaling on the x-axis.
1872 
1873         Call signatures::
1874 
1875             semilogx([x], y, [fmt], data=None, **kwargs)
1876             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1877 
1878         This is just a thin wrapper around `.plot` which additionally changes
1879         the x-axis to log scaling. All the concepts and parameters of plot can
1880         be used here as well.
1881 
1882         The additional parameters *base*, *subs*, and *nonpositive* control the
1883         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1884 
1885         Parameters
1886         ----------
1887         base : float, default: 10
1888             Base of the x logarithm.
1889 
1890         subs : array-like, optional
1891             The location of the minor xticks. If *None*, reasonable locations
1892             are automatically chosen depending on the number of decades in the
1893             plot. See `.Axes.set_xscale` for details.
1894 
1895         nonpositive : {'mask', 'clip'}, default: 'mask'
1896             Non-positive values in x can be masked as invalid, or clipped to a
1897             very small positive number.
1898 
1899         **kwargs
1900             All parameters supported by `.plot`.
1901 
1902         Returns
1903         -------
1904         list of `.Line2D`
1905             Objects representing the plotted data.
1906         """
1907         d = {k: v for k, v in kwargs.items()
1908              if k in ['base', 'subs', 'nonpositive',
1909                       'basex', 'subsx', 'nonposx']}
1910         self.set_xscale('log', **d)
1911         return self.plot(
1912             *args, **{k: v for k, v in kwargs.items() if k not in d})
1913 
1914     # @_preprocess_data() # let 'plot' do the unpacking..
1915     @_docstring.dedent_interpd
1916     def semilogy(self, *args, **kwargs):
1917         """
1918         Make a plot with log scaling on the y-axis.
1919 
1920         Call signatures::
1921 
1922             semilogy([x], y, [fmt], data=None, **kwargs)
1923             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1924 
1925         This is just a thin wrapper around `.plot` which additionally changes
1926         the y-axis to log scaling. All the concepts and parameters of plot can
1927         be used here as well.
1928 
1929         The additional parameters *base*, *subs*, and *nonpositive* control the
1930         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1931 
1932         Parameters
1933         ----------
1934         base : float, default: 10
1935             Base of the y logarithm.
1936 
1937         subs : array-like, optional
1938             The location of the minor yticks. If *None*, reasonable locations
1939             are automatically chosen depending on the number of decades in the
1940             plot. See `.Axes.set_yscale` for details.
1941 
1942         nonpositive : {'mask', 'clip'}, default: 'mask'
1943             Non-positive values in y can be masked as invalid, or clipped to a
1944             very small positive number.
1945 
1946         **kwargs
1947             All parameters supported by `.plot`.
1948 
1949         Returns
1950         -------
1951         list of `.Line2D`
1952             Objects representing the plotted data.
1953         """
1954         d = {k: v for k, v in kwargs.items()
1955              if k in ['base', 'subs', 'nonpositive',
1956                       'basey', 'subsy', 'nonposy']}
1957         self.set_yscale('log', **d)
1958         return self.plot(
1959             *args, **{k: v for k, v in kwargs.items() if k not in d})
1960 
1961     @_preprocess_data(replace_names=["x"], label_namer="x")
1962     def acorr(self, x, **kwargs):
1963         """
1964         Plot the autocorrelation of *x*.
1965 
1966         Parameters
1967         ----------
1968         x : array-like
1969 
1970         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1971             A detrending function applied to *x*.  It must have the
1972             signature ::
1973 
1974                 detrend(x: np.ndarray) -> np.ndarray
1975 
1976         normed : bool, default: True
1977             If ``True``, input vectors are normalised to unit length.
1978 
1979         usevlines : bool, default: True
1980             Determines the plot style.
1981 
1982             If ``True``, vertical lines are plotted from 0 to the acorr value
1983             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1984             at y=0 using `.Axes.axhline`.
1985 
1986             If ``False``, markers are plotted at the acorr values using
1987             `.Axes.plot`.
1988 
1989         maxlags : int, default: 10
1990             Number of lags to show. If ``None``, will return all
1991             ``2 * len(x) - 1`` lags.
1992 
1993         Returns
1994         -------
1995         lags : array (length ``2*maxlags+1``)
1996             The lag vector.
1997         c : array  (length ``2*maxlags+1``)
1998             The auto correlation vector.
1999         line : `.LineCollection` or `.Line2D`
2000             `.Artist` added to the Axes of the correlation:
2001 
2002             - `.LineCollection` if *usevlines* is True.
2003             - `.Line2D` if *usevlines* is False.
2004         b : `.Line2D` or None
2005             Horizontal line at 0 if *usevlines* is True
2006             None *usevlines* is False.
2007 
2008         Other Parameters
2009         ----------------
2010         linestyle : `.Line2D` property, optional
2011             The linestyle for plotting the data points.
2012             Only used if *usevlines* is ``False``.
2013 
2014         marker : str, default: 'o'
2015             The marker for plotting the data points.
2016             Only used if *usevlines* is ``False``.
2017 
2018         data : indexable object, optional
2019             DATA_PARAMETER_PLACEHOLDER
2020 
2021         **kwargs
2022             Additional parameters are passed to `.Axes.vlines` and
2023             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2024             passed to `.Axes.plot`.
2025 
2026         Notes
2027         -----
2028         The cross correlation is performed with `numpy.correlate` with
2029         ``mode = "full"``.
2030         """
2031         return self.xcorr(x, x, **kwargs)
2032 
2033     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2034     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2035               usevlines=True, maxlags=10, **kwargs):
2036         r"""
2037         Plot the cross correlation between *x* and *y*.
2038 
2039         The correlation with lag k is defined as
2040         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2041         conjugate of :math:`y`.
2042 
2043         Parameters
2044         ----------
2045         x, y : array-like of length n
2046 
2047         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2048             A detrending function applied to *x* and *y*.  It must have the
2049             signature ::
2050 
2051                 detrend(x: np.ndarray) -> np.ndarray
2052 
2053         normed : bool, default: True
2054             If ``True``, input vectors are normalised to unit length.
2055 
2056         usevlines : bool, default: True
2057             Determines the plot style.
2058 
2059             If ``True``, vertical lines are plotted from 0 to the xcorr value
2060             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2061             at y=0 using `.Axes.axhline`.
2062 
2063             If ``False``, markers are plotted at the xcorr values using
2064             `.Axes.plot`.
2065 
2066         maxlags : int, default: 10
2067             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2068             lags.
2069 
2070         Returns
2071         -------
2072         lags : array (length ``2*maxlags+1``)
2073             The lag vector.
2074         c : array  (length ``2*maxlags+1``)
2075             The auto correlation vector.
2076         line : `.LineCollection` or `.Line2D`
2077             `.Artist` added to the Axes of the correlation:
2078 
2079             - `.LineCollection` if *usevlines* is True.
2080             - `.Line2D` if *usevlines* is False.
2081         b : `.Line2D` or None
2082             Horizontal line at 0 if *usevlines* is True
2083             None *usevlines* is False.
2084 
2085         Other Parameters
2086         ----------------
2087         linestyle : `.Line2D` property, optional
2088             The linestyle for plotting the data points.
2089             Only used if *usevlines* is ``False``.
2090 
2091         marker : str, default: 'o'
2092             The marker for plotting the data points.
2093             Only used if *usevlines* is ``False``.
2094 
2095         data : indexable object, optional
2096             DATA_PARAMETER_PLACEHOLDER
2097 
2098         **kwargs
2099             Additional parameters are passed to `.Axes.vlines` and
2100             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2101             passed to `.Axes.plot`.
2102 
2103         Notes
2104         -----
2105         The cross correlation is performed with `numpy.correlate` with
2106         ``mode = "full"``.
2107         """
2108         Nx = len(x)
2109         if Nx != len(y):
2110             raise ValueError('x and y must be equal length')
2111 
2112         x = detrend(np.asarray(x))
2113         y = detrend(np.asarray(y))
2114 
2115         correls = np.correlate(x, y, mode="full")
2116 
2117         if normed:
2118             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2119 
2120         if maxlags is None:
2121             maxlags = Nx - 1
2122 
2123         if maxlags >= Nx or maxlags < 1:
2124             raise ValueError('maxlags must be None or strictly '
2125                              'positive < %d' % Nx)
2126 
2127         lags = np.arange(-maxlags, maxlags + 1)
2128         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2129 
2130         if usevlines:
2131             a = self.vlines(lags, [0], correls, **kwargs)
2132             # Make label empty so only vertical lines get a legend entry
2133             kwargs.pop('label', '')
2134             b = self.axhline(**kwargs)
2135         else:
2136             kwargs.setdefault('marker', 'o')
2137             kwargs.setdefault('linestyle', 'None')
2138             a, = self.plot(lags, correls, **kwargs)
2139             b = None
2140         return lags, correls, a, b
2141 
2142     #### Specialized plotting
2143 
2144     # @_preprocess_data() # let 'plot' do the unpacking..
2145     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2146         """
2147         Make a step plot.
2148 
2149         Call signatures::
2150 
2151             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2152             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2153 
2154         This is just a thin wrapper around `.plot` which changes some
2155         formatting options. Most of the concepts and parameters of plot can be
2156         used here as well.
2157 
2158         .. note::
2159 
2160             This method uses a standard plot with a step drawstyle: The *x*
2161             values are the reference positions and steps extend left/right/both
2162             directions depending on *where*.
2163 
2164             For the common case where you know the values and edges of the
2165             steps, use `~.Axes.stairs` instead.
2166 
2167         Parameters
2168         ----------
2169         x : array-like
2170             1D sequence of x positions. It is assumed, but not checked, that
2171             it is uniformly increasing.
2172 
2173         y : array-like
2174             1D sequence of y levels.
2175 
2176         fmt : str, optional
2177             A format string, e.g. 'g' for a green line. See `.plot` for a more
2178             detailed description.
2179 
2180             Note: While full format strings are accepted, it is recommended to
2181             only specify the color. Line styles are currently ignored (use
2182             the keyword argument *linestyle* instead). Markers are accepted
2183             and plotted on the given positions, however, this is a rarely
2184             needed feature for step plots.
2185 
2186         where : {'pre', 'post', 'mid'}, default: 'pre'
2187             Define where the steps should be placed:
2188 
2189             - 'pre': The y value is continued constantly to the left from
2190               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2191               value ``y[i]``.
2192             - 'post': The y value is continued constantly to the right from
2193               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2194               value ``y[i]``.
2195             - 'mid': Steps occur half-way between the *x* positions.
2196 
2197         data : indexable object, optional
2198             An object with labelled data. If given, provide the label names to
2199             plot in *x* and *y*.
2200 
2201         **kwargs
2202             Additional parameters are the same as those for `.plot`.
2203 
2204         Returns
2205         -------
2206         list of `.Line2D`
2207             Objects representing the plotted data.
2208         """
2209         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2210         kwargs['drawstyle'] = 'steps-' + where
2211         return self.plot(x, y, *args, data=data, **kwargs)
2212 
2213     @staticmethod
2214     def _convert_dx(dx, x0, xconv, convert):
2215         """
2216         Small helper to do logic of width conversion flexibly.
2217 
2218         *dx* and *x0* have units, but *xconv* has already been converted
2219         to unitless (and is an ndarray).  This allows the *dx* to have units
2220         that are different from *x0*, but are still accepted by the
2221         ``__add__`` operator of *x0*.
2222         """
2223 
2224         # x should be an array...
2225         assert type(xconv) is np.ndarray
2226 
2227         if xconv.size == 0:
2228             # xconv has already been converted, but maybe empty...
2229             return convert(dx)
2230 
2231         try:
2232             # attempt to add the width to x0; this works for
2233             # datetime+timedelta, for instance
2234 
2235             # only use the first element of x and x0.  This saves
2236             # having to be sure addition works across the whole
2237             # vector.  This is particularly an issue if
2238             # x0 and dx are lists so x0 + dx just concatenates the lists.
2239             # We can't just cast x0 and dx to numpy arrays because that
2240             # removes the units from unit packages like `pint` that
2241             # wrap numpy arrays.
2242             try:
2243                 x0 = cbook._safe_first_finite(x0)
2244             except (TypeError, IndexError, KeyError):
2245                 pass
2246 
2247             try:
2248                 x = cbook._safe_first_finite(xconv)
2249             except (TypeError, IndexError, KeyError):
2250                 x = xconv
2251 
2252             delist = False
2253             if not np.iterable(dx):
2254                 dx = [dx]
2255                 delist = True
2256             dx = [convert(x0 + ddx) - x for ddx in dx]
2257             if delist:
2258                 dx = dx[0]
2259         except (ValueError, TypeError, AttributeError):
2260             # if the above fails (for any reason) just fallback to what
2261             # we do by default and convert dx by itself.
2262             dx = convert(dx)
2263         return dx
2264 
2265     @_preprocess_data()
2266     @_docstring.dedent_interpd
2267     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2268             **kwargs):
2269         r"""
2270         Make a bar plot.
2271 
2272         The bars are positioned at *x* with the given *align*\ment. Their
2273         dimensions are given by *height* and *width*. The vertical baseline
2274         is *bottom* (default 0).
2275 
2276         Many parameters can take either a single value applying to all bars
2277         or a sequence of values, one for each bar.
2278 
2279         Parameters
2280         ----------
2281         x : float or array-like
2282             The x coordinates of the bars. See also *align* for the
2283             alignment of the bars to the coordinates.
2284 
2285         height : float or array-like
2286             The height(s) of the bars.
2287 
2288         width : float or array-like, default: 0.8
2289             The width(s) of the bars.
2290 
2291         bottom : float or array-like, default: 0
2292             The y coordinate(s) of the bottom side(s) of the bars.
2293 
2294         align : {'center', 'edge'}, default: 'center'
2295             Alignment of the bars to the *x* coordinates:
2296 
2297             - 'center': Center the base on the *x* positions.
2298             - 'edge': Align the left edges of the bars with the *x* positions.
2299 
2300             To align the bars on the right edge pass a negative *width* and
2301             ``align='edge'``.
2302 
2303         Returns
2304         -------
2305         `.BarContainer`
2306             Container with all the bars and optionally errorbars.
2307 
2308         Other Parameters
2309         ----------------
2310         color : color or list of color, optional
2311             The colors of the bar faces.
2312 
2313         edgecolor : color or list of color, optional
2314             The colors of the bar edges.
2315 
2316         linewidth : float or array-like, optional
2317             Width of the bar edge(s). If 0, don't draw edges.
2318 
2319         tick_label : str or list of str, optional
2320             The tick labels of the bars.
2321             Default: None (Use default numeric labels.)
2322 
2323         label : str or list of str, optional
2324             A single label is attached to the resulting `.BarContainer` as a
2325             label for the whole dataset.
2326             If a list is provided, it must be the same length as *x* and
2327             labels the individual bars. Repeated labels are not de-duplicated
2328             and will cause repeated label entries, so this is best used when
2329             bars also differ in style (e.g., by passing a list to *color*.)
2330 
2331         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2332             If not *None*, add horizontal / vertical errorbars to the bar tips.
2333             The values are +/- sizes relative to the data:
2334 
2335             - scalar: symmetric +/- values for all bars
2336             - shape(N,): symmetric +/- values for each bar
2337             - shape(2, N): Separate - and + values for each bar. First row
2338               contains the lower errors, the second row contains the upper
2339               errors.
2340             - *None*: No errorbar. (Default)
2341 
2342             See :doc:`/gallery/statistics/errorbar_features` for an example on
2343             the usage of *xerr* and *yerr*.
2344 
2345         ecolor : color or list of color, default: 'black'
2346             The line color of the errorbars.
2347 
2348         capsize : float, default: :rc:`errorbar.capsize`
2349            The length of the error bar caps in points.
2350 
2351         error_kw : dict, optional
2352             Dictionary of keyword arguments to be passed to the
2353             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2354             here take precedence over the independent keyword arguments.
2355 
2356         log : bool, default: False
2357             If *True*, set the y-axis to be log scale.
2358 
2359         data : indexable object, optional
2360             DATA_PARAMETER_PLACEHOLDER
2361 
2362         **kwargs : `.Rectangle` properties
2363 
2364         %(Rectangle:kwdoc)s
2365 
2366         See Also
2367         --------
2368         barh : Plot a horizontal bar plot.
2369 
2370         Notes
2371         -----
2372         Stacked bars can be achieved by passing individual *bottom* values per
2373         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2374         """
2375         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2376         color = kwargs.pop('color', None)
2377         if color is None:
2378             color = self._get_patches_for_fill.get_next_color()
2379         edgecolor = kwargs.pop('edgecolor', None)
2380         linewidth = kwargs.pop('linewidth', None)
2381         hatch = kwargs.pop('hatch', None)
2382 
2383         # Because xerr and yerr will be passed to errorbar, most dimension
2384         # checking and processing will be left to the errorbar method.
2385         xerr = kwargs.pop('xerr', None)
2386         yerr = kwargs.pop('yerr', None)
2387         error_kw = kwargs.pop('error_kw', {})
2388         ezorder = error_kw.pop('zorder', None)
2389         if ezorder is None:
2390             ezorder = kwargs.get('zorder', None)
2391             if ezorder is not None:
2392                 # If using the bar zorder, increment slightly to make sure
2393                 # errorbars are drawn on top of bars
2394                 ezorder += 0.01
2395         error_kw.setdefault('zorder', ezorder)
2396         ecolor = kwargs.pop('ecolor', 'k')
2397         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2398         error_kw.setdefault('ecolor', ecolor)
2399         error_kw.setdefault('capsize', capsize)
2400 
2401         # The keyword argument *orientation* is used by barh() to defer all
2402         # logic and drawing to bar(). It is considered internal and is
2403         # intentionally not mentioned in the docstring.
2404         orientation = kwargs.pop('orientation', 'vertical')
2405         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2406         log = kwargs.pop('log', False)
2407         label = kwargs.pop('label', '')
2408         tick_labels = kwargs.pop('tick_label', None)
2409 
2410         y = bottom  # Matches barh call signature.
2411         if orientation == 'vertical':
2412             if y is None:
2413                 y = 0
2414         else:  # horizontal
2415             if x is None:
2416                 x = 0
2417 
2418         if orientation == 'vertical':
2419             self._process_unit_info(
2420                 [("x", x), ("y", height)], kwargs, convert=False)
2421             if log:
2422                 self.set_yscale('log', nonpositive='clip')
2423         else:  # horizontal
2424             self._process_unit_info(
2425                 [("x", width), ("y", y)], kwargs, convert=False)
2426             if log:
2427                 self.set_xscale('log', nonpositive='clip')
2428 
2429         # lets do some conversions now since some types cannot be
2430         # subtracted uniformly
2431         if self.xaxis is not None:
2432             x0 = x
2433             x = np.asarray(self.convert_xunits(x))
2434             width = self._convert_dx(width, x0, x, self.convert_xunits)
2435             if xerr is not None:
2436                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2437         if self.yaxis is not None:
2438             y0 = y
2439             y = np.asarray(self.convert_yunits(y))
2440             height = self._convert_dx(height, y0, y, self.convert_yunits)
2441             if yerr is not None:
2442                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2443 
2444         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2445             # Make args iterable too.
2446             np.atleast_1d(x), height, width, y, linewidth, hatch)
2447 
2448         # Now that units have been converted, set the tick locations.
2449         if orientation == 'vertical':
2450             tick_label_axis = self.xaxis
2451             tick_label_position = x
2452         else:  # horizontal
2453             tick_label_axis = self.yaxis
2454             tick_label_position = y
2455 
2456         if not isinstance(label, str) and np.iterable(label):
2457             bar_container_label = '_nolegend_'
2458             patch_labels = label
2459         else:
2460             bar_container_label = label
2461             patch_labels = ['_nolegend_'] * len(x)
2462         if len(patch_labels) != len(x):
2463             raise ValueError(f'number of labels ({len(patch_labels)}) '
2464                              f'does not match number of bars ({len(x)}).')
2465 
2466         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2467         hatch = itertools.cycle(np.atleast_1d(hatch))
2468         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2469                                 # Fallback if color == "none".
2470                                 itertools.repeat('none'))
2471         if edgecolor is None:
2472             edgecolor = itertools.repeat(None)
2473         else:
2474             edgecolor = itertools.chain(
2475                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2476                 # Fallback if edgecolor == "none".
2477                 itertools.repeat('none'))
2478 
2479         # We will now resolve the alignment and really have
2480         # left, bottom, width, height vectors
2481         _api.check_in_list(['center', 'edge'], align=align)
2482         if align == 'center':
2483             if orientation == 'vertical':
2484                 try:
2485                     left = x - width / 2
2486                 except TypeError as e:
2487                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2488                                     f'and width ({width.dtype}) '
2489                                     f'are incompatible') from e
2490                 bottom = y
2491             else:  # horizontal
2492                 try:
2493                     bottom = y - height / 2
2494                 except TypeError as e:
2495                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2496                                     f'and height ({height.dtype}) '
2497                                     f'are incompatible') from e
2498                 left = x
2499         else:  # edge
2500             left = x
2501             bottom = y
2502 
2503         patches = []
2504         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2505                    hatch, patch_labels)
2506         for l, b, w, h, c, e, lw, htch, lbl in args:
2507             r = mpatches.Rectangle(
2508                 xy=(l, b), width=w, height=h,
2509                 facecolor=c,
2510                 edgecolor=e,
2511                 linewidth=lw,
2512                 label=lbl,
2513                 hatch=htch,
2514                 )
2515             r._internal_update(kwargs)
2516             r.get_path()._interpolation_steps = 100
2517             if orientation == 'vertical':
2518                 r.sticky_edges.y.append(b)
2519             else:  # horizontal
2520                 r.sticky_edges.x.append(l)
2521             self.add_patch(r)
2522             patches.append(r)
2523 
2524         if xerr is not None or yerr is not None:
2525             if orientation == 'vertical':
2526                 # using list comps rather than arrays to preserve unit info
2527                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2528                 ey = [b + h for b, h in zip(bottom, height)]
2529 
2530             else:  # horizontal
2531                 # using list comps rather than arrays to preserve unit info
2532                 ex = [l + w for l, w in zip(left, width)]
2533                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2534 
2535             error_kw.setdefault("label", '_nolegend_')
2536 
2537             errorbar = self.errorbar(ex, ey,
2538                                      yerr=yerr, xerr=xerr,
2539                                      fmt='none', **error_kw)
2540         else:
2541             errorbar = None
2542 
2543         self._request_autoscale_view()
2544 
2545         if orientation == 'vertical':
2546             datavalues = height
2547         else:  # horizontal
2548             datavalues = width
2549 
2550         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2551                                      orientation=orientation,
2552                                      label=bar_container_label)
2553         self.add_container(bar_container)
2554 
2555         if tick_labels is not None:
2556             tick_labels = np.broadcast_to(tick_labels, len(patches))
2557             tick_label_axis.set_ticks(tick_label_position)
2558             tick_label_axis.set_ticklabels(tick_labels)
2559 
2560         return bar_container
2561 
2562     # @_preprocess_data() # let 'bar' do the unpacking..
2563     @_docstring.dedent_interpd
2564     def barh(self, y, width, height=0.8, left=None, *, align="center",
2565              data=None, **kwargs):
2566         r"""
2567         Make a horizontal bar plot.
2568 
2569         The bars are positioned at *y* with the given *align*\ment. Their
2570         dimensions are given by *width* and *height*. The horizontal baseline
2571         is *left* (default 0).
2572 
2573         Many parameters can take either a single value applying to all bars
2574         or a sequence of values, one for each bar.
2575 
2576         Parameters
2577         ----------
2578         y : float or array-like
2579             The y coordinates of the bars. See also *align* for the
2580             alignment of the bars to the coordinates.
2581 
2582         width : float or array-like
2583             The width(s) of the bars.
2584 
2585         height : float or array-like, default: 0.8
2586             The heights of the bars.
2587 
2588         left : float or array-like, default: 0
2589             The x coordinates of the left side(s) of the bars.
2590 
2591         align : {'center', 'edge'}, default: 'center'
2592             Alignment of the base to the *y* coordinates*:
2593 
2594             - 'center': Center the bars on the *y* positions.
2595             - 'edge': Align the bottom edges of the bars with the *y*
2596               positions.
2597 
2598             To align the bars on the top edge pass a negative *height* and
2599             ``align='edge'``.
2600 
2601         Returns
2602         -------
2603         `.BarContainer`
2604             Container with all the bars and optionally errorbars.
2605 
2606         Other Parameters
2607         ----------------
2608         color : color or list of color, optional
2609             The colors of the bar faces.
2610 
2611         edgecolor : color or list of color, optional
2612             The colors of the bar edges.
2613 
2614         linewidth : float or array-like, optional
2615             Width of the bar edge(s). If 0, don't draw edges.
2616 
2617         tick_label : str or list of str, optional
2618             The tick labels of the bars.
2619             Default: None (Use default numeric labels.)
2620 
2621         label : str or list of str, optional
2622             A single label is attached to the resulting `.BarContainer` as a
2623             label for the whole dataset.
2624             If a list is provided, it must be the same length as *y* and
2625             labels the individual bars. Repeated labels are not de-duplicated
2626             and will cause repeated label entries, so this is best used when
2627             bars also differ in style (e.g., by passing a list to *color*.)
2628 
2629         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2630             If not *None*, add horizontal / vertical errorbars to the bar tips.
2631             The values are +/- sizes relative to the data:
2632 
2633             - scalar: symmetric +/- values for all bars
2634             - shape(N,): symmetric +/- values for each bar
2635             - shape(2, N): Separate - and + values for each bar. First row
2636               contains the lower errors, the second row contains the upper
2637               errors.
2638             - *None*: No errorbar. (default)
2639 
2640             See :doc:`/gallery/statistics/errorbar_features` for an example on
2641             the usage of *xerr* and *yerr*.
2642 
2643         ecolor : color or list of color, default: 'black'
2644             The line color of the errorbars.
2645 
2646         capsize : float, default: :rc:`errorbar.capsize`
2647            The length of the error bar caps in points.
2648 
2649         error_kw : dict, optional
2650             Dictionary of keyword arguments to be passed to the
2651             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2652             here take precedence over the independent keyword arguments.
2653 
2654         log : bool, default: False
2655             If ``True``, set the x-axis to be log scale.
2656 
2657         data : indexable object, optional
2658             If given, all parameters also accept a string ``s``, which is
2659             interpreted as ``data[s]`` (unless this raises an exception).
2660 
2661         **kwargs : `.Rectangle` properties
2662 
2663         %(Rectangle:kwdoc)s
2664 
2665         See Also
2666         --------
2667         bar : Plot a vertical bar plot.
2668 
2669         Notes
2670         -----
2671         Stacked bars can be achieved by passing individual *left* values per
2672         bar. See
2673         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2674         """
2675         kwargs.setdefault('orientation', 'horizontal')
2676         patches = self.bar(x=left, height=height, width=width, bottom=y,
2677                            align=align, data=data, **kwargs)
2678         return patches
2679 
2680     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2681                   padding=0, **kwargs):
2682         """
2683         Label a bar plot.
2684 
2685         Adds labels to bars in the given `.BarContainer`.
2686         You may need to adjust the axis limits to fit the labels.
2687 
2688         Parameters
2689         ----------
2690         container : `.BarContainer`
2691             Container with all the bars and optionally errorbars, likely
2692             returned from `.bar` or `.barh`.
2693 
2694         labels : array-like, optional
2695             A list of label texts, that should be displayed. If not given, the
2696             label texts will be the data values formatted with *fmt*.
2697 
2698         fmt : str or callable, default: '%g'
2699             An unnamed %-style or {}-style format string for the label or a
2700             function to call with the value as the first argument.
2701             When *fmt* is a string and can be interpreted in both formats,
2702             %-style takes precedence over {}-style.
2703 
2704             .. versionadded:: 3.7
2705                Support for {}-style format string and callables.
2706 
2707         label_type : {'edge', 'center'}, default: 'edge'
2708             The label type. Possible values:
2709 
2710             - 'edge': label placed at the end-point of the bar segment, and the
2711               value displayed will be the position of that end-point.
2712             - 'center': label placed in the center of the bar segment, and the
2713               value displayed will be the length of that segment.
2714               (useful for stacked bars, i.e.,
2715               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2716 
2717         padding : float, default: 0
2718             Distance of label from the end of the bar, in points.
2719 
2720         **kwargs
2721             Any remaining keyword arguments are passed through to
2722             `.Axes.annotate`. The alignment parameters (
2723             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2724             not supported because the labels are automatically aligned to
2725             the bars.
2726 
2727         Returns
2728         -------
2729         list of `.Text`
2730             A list of `.Text` instances for the labels.
2731         """
2732         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2733             if key in kwargs:
2734                 raise ValueError(
2735                     f"Passing {key!r} to bar_label() is not supported.")
2736 
2737         a, b = self.yaxis.get_view_interval()
2738         y_inverted = a > b
2739         c, d = self.xaxis.get_view_interval()
2740         x_inverted = c > d
2741 
2742         # want to know whether to put label on positive or negative direction
2743         # cannot use np.sign here because it will return 0 if x == 0
2744         def sign(x):
2745             return 1 if x >= 0 else -1
2746 
2747         _api.check_in_list(['edge', 'center'], label_type=label_type)
2748 
2749         bars = container.patches
2750         errorbar = container.errorbar
2751         datavalues = container.datavalues
2752         orientation = container.orientation
2753 
2754         if errorbar:
2755             # check "ErrorbarContainer" for the definition of these elements
2756             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2757             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2758             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2759             errs = barlinecol.get_segments()
2760         else:
2761             errs = []
2762 
2763         if labels is None:
2764             labels = []
2765 
2766         annotations = []
2767 
2768         for bar, err, dat, lbl in itertools.zip_longest(
2769                 bars, errs, datavalues, labels
2770         ):
2771             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2772             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2773 
2774             if orientation == "vertical":
2775                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2776                 length = abs(y0 - y1)
2777             else:  # horizontal
2778                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2779                 length = abs(x0 - x1)
2780 
2781             if err is None or np.size(err) == 0:
2782                 endpt = extrema
2783             elif orientation == "vertical":
2784                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2785             else:  # horizontal
2786                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2787 
2788             if label_type == "center":
2789                 value = sign(dat) * length
2790             else:  # edge
2791                 value = extrema
2792 
2793             if label_type == "center":
2794                 xy = (0.5, 0.5)
2795                 kwargs["xycoords"] = (
2796                     lambda r, b=bar:
2797                         mtransforms.Bbox.intersection(
2798                             b.get_window_extent(r), b.get_clip_box()
2799                         ) or mtransforms.Bbox.null()
2800                 )
2801             else:  # edge
2802                 if orientation == "vertical":
2803                     xy = xc, endpt
2804                 else:  # horizontal
2805                     xy = endpt, yc
2806 
2807             if orientation == "vertical":
2808                 y_direction = -1 if y_inverted else 1
2809                 xytext = 0, y_direction * sign(dat) * padding
2810             else:  # horizontal
2811                 x_direction = -1 if x_inverted else 1
2812                 xytext = x_direction * sign(dat) * padding, 0
2813 
2814             if label_type == "center":
2815                 ha, va = "center", "center"
2816             else:  # edge
2817                 if orientation == "vertical":
2818                     ha = 'center'
2819                     if y_inverted:
2820                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2821                     else:
2822                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2823                 else:  # horizontal
2824                     if x_inverted:
2825                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2826                     else:
2827                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2828                     va = 'center'
2829 
2830             if np.isnan(dat):
2831                 lbl = ''
2832 
2833             if lbl is None:
2834                 if isinstance(fmt, str):
2835                     lbl = cbook._auto_format_str(fmt, value)
2836                 elif callable(fmt):
2837                     lbl = fmt(value)
2838                 else:
2839                     raise TypeError("fmt must be a str or callable")
2840             annotation = self.annotate(lbl,
2841                                        xy, xytext, textcoords="offset points",
2842                                        ha=ha, va=va, **kwargs)
2843             annotations.append(annotation)
2844 
2845         return annotations
2846 
2847     @_preprocess_data()
2848     @_docstring.dedent_interpd
2849     def broken_barh(self, xranges, yrange, **kwargs):
2850         """
2851         Plot a horizontal sequence of rectangles.
2852 
2853         A rectangle is drawn for each element of *xranges*. All rectangles
2854         have the same vertical position and size defined by *yrange*.
2855 
2856         Parameters
2857         ----------
2858         xranges : sequence of tuples (*xmin*, *xwidth*)
2859             The x-positions and extents of the rectangles. For each tuple
2860             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2861             *xwidth*.
2862         yrange : (*ymin*, *yheight*)
2863             The y-position and extent for all the rectangles.
2864 
2865         Returns
2866         -------
2867         `~.collections.PolyCollection`
2868 
2869         Other Parameters
2870         ----------------
2871         data : indexable object, optional
2872             DATA_PARAMETER_PLACEHOLDER
2873         **kwargs : `.PolyCollection` properties
2874 
2875             Each *kwarg* can be either a single argument applying to all
2876             rectangles, e.g.::
2877 
2878                 facecolors='black'
2879 
2880             or a sequence of arguments over which is cycled, e.g.::
2881 
2882                 facecolors=('black', 'blue')
2883 
2884             would create interleaving black and blue rectangles.
2885 
2886             Supported keywords:
2887 
2888             %(PolyCollection:kwdoc)s
2889         """
2890         # process the unit information
2891         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2892         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2893         self._process_unit_info(
2894             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2895 
2896         vertices = []
2897         y0, dy = yrange
2898         y0, y1 = self.convert_yunits((y0, y0 + dy))
2899         for xr in xranges:  # convert the absolute values, not the x and dx
2900             try:
2901                 x0, dx = xr
2902             except Exception:
2903                 raise ValueError(
2904                     "each range in xrange must be a sequence with two "
2905                     "elements (i.e. xrange must be an (N, 2) array)") from None
2906             x0, x1 = self.convert_xunits((x0, x0 + dx))
2907             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2908 
2909         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2910         self.add_collection(col, autolim=True)
2911         self._request_autoscale_view()
2912 
2913         return col
2914 
2915     @_preprocess_data()
2916     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2917              label=None, orientation='vertical'):
2918         """
2919         Create a stem plot.
2920 
2921         A stem plot draws lines perpendicular to a baseline at each location
2922         *locs* from the baseline to *heads*, and places a marker there. For
2923         vertical stem plots (the default), the *locs* are *x* positions, and
2924         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2925         *y* positions, and the *heads* are *x* values.
2926 
2927         Call signature::
2928 
2929           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2930 
2931         The *locs*-positions are optional. *linefmt* may be provided as
2932         positional, but all other formats must be provided as keyword
2933         arguments.
2934 
2935         Parameters
2936         ----------
2937         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2938             For vertical stem plots, the x-positions of the stems.
2939             For horizontal stem plots, the y-positions of the stems.
2940 
2941         heads : array-like
2942             For vertical stem plots, the y-values of the stem heads.
2943             For horizontal stem plots, the x-values of the stem heads.
2944 
2945         linefmt : str, optional
2946             A string defining the color and/or linestyle of the vertical lines:
2947 
2948             =========  =============
2949             Character  Line Style
2950             =========  =============
2951             ``'-'``    solid line
2952             ``'--'``   dashed line
2953             ``'-.'``   dash-dot line
2954             ``':'``    dotted line
2955             =========  =============
2956 
2957             Default: 'C0-', i.e. solid line with the first color of the color
2958             cycle.
2959 
2960             Note: Markers specified through this parameter (e.g. 'x') will be
2961             silently ignored. Instead, markers should be specified using
2962             *markerfmt*.
2963 
2964         markerfmt : str, optional
2965             A string defining the color and/or shape of the markers at the stem
2966             heads. If the marker is not given, use the marker 'o', i.e. filled
2967             circles. If the color is not given, use the color from *linefmt*.
2968 
2969         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2970             A format string defining the properties of the baseline.
2971 
2972         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2973             If 'vertical', will produce a plot with stems oriented vertically,
2974             If 'horizontal', the stems will be oriented horizontally.
2975 
2976         bottom : float, default: 0
2977             The y/x-position of the baseline (depending on orientation).
2978 
2979         label : str, default: None
2980             The label to use for the stems in legends.
2981 
2982         data : indexable object, optional
2983             DATA_PARAMETER_PLACEHOLDER
2984 
2985         Returns
2986         -------
2987         `.StemContainer`
2988             The container may be treated like a tuple
2989             (*markerline*, *stemlines*, *baseline*)
2990 
2991         Notes
2992         -----
2993         .. seealso::
2994             The MATLAB function
2995             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2996             which inspired this method.
2997         """
2998         if not 1 <= len(args) <= 3:
2999             raise _api.nargs_error('stem', '1-3', len(args))
3000         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3001 
3002         if len(args) == 1:
3003             heads, = args
3004             locs = np.arange(len(heads))
3005             args = ()
3006         elif isinstance(args[1], str):
3007             heads, *args = args
3008             locs = np.arange(len(heads))
3009         else:
3010             locs, heads, *args = args
3011 
3012         if orientation == 'vertical':
3013             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3014         else:  # horizontal
3015             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3016 
3017         # resolve line format
3018         if linefmt is None:
3019             linefmt = args[0] if len(args) > 0 else "C0-"
3020         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3021 
3022         # resolve marker format
3023         if markerfmt is None:
3024             # if not given as kwarg, fall back to 'o'
3025             markerfmt = "o"
3026         if markerfmt == '':
3027             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3028         markerstyle, markermarker, markercolor = \
3029             _process_plot_format(markerfmt)
3030         if markermarker is None:
3031             markermarker = 'o'
3032         if markerstyle is None:
3033             markerstyle = 'None'
3034         if markercolor is None:
3035             markercolor = linecolor
3036 
3037         # resolve baseline format
3038         if basefmt is None:
3039             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3040                        "C3-")
3041         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3042 
3043         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3044         if linestyle is None:
3045             linestyle = mpl.rcParams['lines.linestyle']
3046         xlines = self.vlines if orientation == "vertical" else self.hlines
3047         stemlines = xlines(
3048             locs, bottom, heads,
3049             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3050 
3051         if orientation == 'horizontal':
3052             marker_x = heads
3053             marker_y = locs
3054             baseline_x = [bottom, bottom]
3055             baseline_y = [np.min(locs), np.max(locs)]
3056         else:
3057             marker_x = locs
3058             marker_y = heads
3059             baseline_x = [np.min(locs), np.max(locs)]
3060             baseline_y = [bottom, bottom]
3061 
3062         markerline, = self.plot(marker_x, marker_y,
3063                                 color=markercolor, linestyle=markerstyle,
3064                                 marker=markermarker, label="_nolegend_")
3065 
3066         baseline, = self.plot(baseline_x, baseline_y,
3067                               color=basecolor, linestyle=basestyle,
3068                               marker=basemarker, label="_nolegend_")
3069 
3070         stem_container = StemContainer((markerline, stemlines, baseline),
3071                                        label=label)
3072         self.add_container(stem_container)
3073         return stem_container
3074 
3075     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3076     def pie(self, x, explode=None, labels=None, colors=None,
3077             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3078             startangle=0, radius=1, counterclock=True,
3079             wedgeprops=None, textprops=None, center=(0, 0),
3080             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3081         """
3082         Plot a pie chart.
3083 
3084         Make a pie chart of array *x*.  The fractional area of each wedge is
3085         given by ``x/sum(x)``.
3086 
3087         The wedges are plotted counterclockwise, by default starting from the
3088         x-axis.
3089 
3090         Parameters
3091         ----------
3092         x : 1D array-like
3093             The wedge sizes.
3094 
3095         explode : array-like, default: None
3096             If not *None*, is a ``len(x)`` array which specifies the fraction
3097             of the radius with which to offset each wedge.
3098 
3099         labels : list, default: None
3100             A sequence of strings providing the labels for each wedge
3101 
3102         colors : color or array-like of color, default: None
3103             A sequence of colors through which the pie chart will cycle.  If
3104             *None*, will use the colors in the currently active cycle.
3105 
3106         hatch : str or list, default: None
3107             Hatching pattern applied to all pie wedges or sequence of patterns
3108             through which the chart will cycle. For a list of valid patterns,
3109             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3110 
3111             .. versionadded:: 3.7
3112 
3113         autopct : None or str or callable, default: None
3114             If not *None*, *autopct* is a string or function used to label the
3115             wedges with their numeric value. The label will be placed inside
3116             the wedge. If *autopct* is a format string, the label will be
3117             ``fmt % pct``. If *autopct* is a function, then it will be called.
3118 
3119         pctdistance : float, default: 0.6
3120             The relative distance along the radius at which the text
3121             generated by *autopct* is drawn. To draw the text outside the pie,
3122             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3123             ``None``.
3124 
3125         labeldistance : float or None, default: 1.1
3126             The relative distance along the radius at which the labels are
3127             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3128             If set to ``None``, labels are not drawn but are still stored for
3129             use in `.legend`.
3130 
3131         shadow : bool or dict, default: False
3132             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3133             passing the properties in the dict to `.Shadow`.
3134 
3135             .. versionadded:: 3.8
3136                 *shadow* can be a dict.
3137 
3138         startangle : float, default: 0 degrees
3139             The angle by which the start of the pie is rotated,
3140             counterclockwise from the x-axis.
3141 
3142         radius : float, default: 1
3143             The radius of the pie.
3144 
3145         counterclock : bool, default: True
3146             Specify fractions direction, clockwise or counterclockwise.
3147 
3148         wedgeprops : dict, default: None
3149             Dict of arguments passed to each `.patches.Wedge` of the pie.
3150             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3151             the wedge border lines equal to 3. By default, ``clip_on=False``.
3152             When there is a conflict between these properties and other
3153             keywords, properties passed to *wedgeprops* take precedence.
3154 
3155         textprops : dict, default: None
3156             Dict of arguments to pass to the text objects.
3157 
3158         center : (float, float), default: (0, 0)
3159             The coordinates of the center of the chart.
3160 
3161         frame : bool, default: False
3162             Plot Axes frame with the chart if true.
3163 
3164         rotatelabels : bool, default: False
3165             Rotate each label to the angle of the corresponding slice if true.
3166 
3167         normalize : bool, default: True
3168             When *True*, always make a full pie by normalizing x so that
3169             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3170             and raises a `ValueError` for ``sum(x) > 1``.
3171 
3172         data : indexable object, optional
3173             DATA_PARAMETER_PLACEHOLDER
3174 
3175         Returns
3176         -------
3177         patches : list
3178             A sequence of `matplotlib.patches.Wedge` instances
3179 
3180         texts : list
3181             A list of the label `.Text` instances.
3182 
3183         autotexts : list
3184             A list of `.Text` instances for the numeric labels. This will only
3185             be returned if the parameter *autopct* is not *None*.
3186 
3187         Notes
3188         -----
3189         The pie chart will probably look best if the figure and Axes are
3190         square, or the Axes aspect is equal.
3191         This method sets the aspect ratio of the axis to "equal".
3192         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3193         """
3194         self.set_aspect('equal')
3195         # The use of float32 is "historical", but can't be changed without
3196         # regenerating the test baselines.
3197         x = np.asarray(x, np.float32)
3198         if x.ndim > 1:
3199             raise ValueError("x must be 1D")
3200 
3201         if np.any(x < 0):
3202             raise ValueError("Wedge sizes 'x' must be non negative values")
3203 
3204         sx = x.sum()
3205 
3206         if normalize:
3207             x = x / sx
3208         elif sx > 1:
3209             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3210         if labels is None:
3211             labels = [''] * len(x)
3212         if explode is None:
3213             explode = [0] * len(x)
3214         if len(x) != len(labels):
3215             raise ValueError("'label' must be of length 'x'")
3216         if len(x) != len(explode):
3217             raise ValueError("'explode' must be of length 'x'")
3218         if colors is None:
3219             get_next_color = self._get_patches_for_fill.get_next_color
3220         else:
3221             color_cycle = itertools.cycle(colors)
3222 
3223             def get_next_color():
3224                 return next(color_cycle)
3225 
3226         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3227 
3228         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3229         if radius <= 0:
3230             raise ValueError(f'radius must be a positive number, not {radius}')
3231 
3232         # Starting theta1 is the start fraction of the circle
3233         theta1 = startangle / 360
3234 
3235         if wedgeprops is None:
3236             wedgeprops = {}
3237         if textprops is None:
3238             textprops = {}
3239 
3240         texts = []
3241         slices = []
3242         autotexts = []
3243 
3244         for frac, label, expl in zip(x, labels, explode):
3245             x, y = center
3246             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3247             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3248             x += expl * math.cos(thetam)
3249             y += expl * math.sin(thetam)
3250 
3251             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3252                                360. * max(theta1, theta2),
3253                                facecolor=get_next_color(),
3254                                hatch=next(hatch_cycle),
3255                                clip_on=False,
3256                                label=label)
3257             w.set(**wedgeprops)
3258             slices.append(w)
3259             self.add_patch(w)
3260 
3261             if shadow:
3262                 # Make sure to add a shadow after the call to add_patch so the
3263                 # figure and transform props will be set.
3264                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3265                 if isinstance(shadow, dict):
3266                     shadow_dict.update(shadow)
3267                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3268 
3269             if labeldistance is not None:
3270                 xt = x + labeldistance * radius * math.cos(thetam)
3271                 yt = y + labeldistance * radius * math.sin(thetam)
3272                 label_alignment_h = 'left' if xt > 0 else 'right'
3273                 label_alignment_v = 'center'
3274                 label_rotation = 'horizontal'
3275                 if rotatelabels:
3276                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3277                     label_rotation = (np.rad2deg(thetam)
3278                                       + (0 if xt > 0 else 180))
3279                 t = self.text(xt, yt, label,
3280                               clip_on=False,
3281                               horizontalalignment=label_alignment_h,
3282                               verticalalignment=label_alignment_v,
3283                               rotation=label_rotation,
3284                               size=mpl.rcParams['xtick.labelsize'])
3285                 t.set(**textprops)
3286                 texts.append(t)
3287 
3288             if autopct is not None:
3289                 xt = x + pctdistance * radius * math.cos(thetam)
3290                 yt = y + pctdistance * radius * math.sin(thetam)
3291                 if isinstance(autopct, str):
3292                     s = autopct % (100. * frac)
3293                 elif callable(autopct):
3294                     s = autopct(100. * frac)
3295                 else:
3296                     raise TypeError(
3297                         'autopct must be callable or a format string')
3298                 t = self.text(xt, yt, s,
3299                               clip_on=False,
3300                               horizontalalignment='center',
3301                               verticalalignment='center')
3302                 t.set(**textprops)
3303                 autotexts.append(t)
3304 
3305             theta1 = theta2
3306 
3307         if frame:
3308             self._request_autoscale_view()
3309         else:
3310             self.set(frame_on=False, xticks=[], yticks=[],
3311                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3312                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3313 
3314         if autopct is None:
3315             return slices, texts
3316         else:
3317             return slices, texts, autotexts
3318 
3319     @staticmethod
3320     def _errorevery_to_mask(x, errorevery):
3321         """
3322         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3323 
3324         This function is split out to be usable both by 2D and 3D errorbars.
3325         """
3326         if isinstance(errorevery, Integral):
3327             errorevery = (0, errorevery)
3328         if isinstance(errorevery, tuple):
3329             if (len(errorevery) == 2 and
3330                     isinstance(errorevery[0], Integral) and
3331                     isinstance(errorevery[1], Integral)):
3332                 errorevery = slice(errorevery[0], None, errorevery[1])
3333             else:
3334                 raise ValueError(
3335                     f'{errorevery=!r} is a not a tuple of two integers')
3336         elif isinstance(errorevery, slice):
3337             pass
3338         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3339             try:
3340                 x[errorevery]  # fancy indexing
3341             except (ValueError, IndexError) as err:
3342                 raise ValueError(
3343                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3344                     "index to match 'xerr'/'yerr'") from err
3345         else:
3346             raise ValueError(f"{errorevery=!r} is not a recognized value")
3347         everymask = np.zeros(len(x), bool)
3348         everymask[errorevery] = True
3349         return everymask
3350 
3351     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3352                       label_namer="y")
3353     @_docstring.dedent_interpd
3354     def errorbar(self, x, y, yerr=None, xerr=None,
3355                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3356                  barsabove=False, lolims=False, uplims=False,
3357                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3358                  **kwargs):
3359         """
3360         Plot y versus x as lines and/or markers with attached errorbars.
3361 
3362         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3363         sizes. By default, this draws the data markers/lines as well the
3364         errorbars. Use fmt='none' to draw errorbars without any data markers.
3365 
3366         .. versionadded:: 3.7
3367            Caps and error lines are drawn in polar coordinates on polar plots.
3368 
3369 
3370         Parameters
3371         ----------
3372         x, y : float or array-like
3373             The data positions.
3374 
3375         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3376             The errorbar sizes:
3377 
3378             - scalar: Symmetric +/- values for all data points.
3379             - shape(N,): Symmetric +/-values for each data point.
3380             - shape(2, N): Separate - and + values for each bar. First row
3381               contains the lower errors, the second row contains the upper
3382               errors.
3383             - *None*: No errorbar.
3384 
3385             All values must be >= 0.
3386 
3387             See :doc:`/gallery/statistics/errorbar_features`
3388             for an example on the usage of ``xerr`` and ``yerr``.
3389 
3390         fmt : str, default: ''
3391             The format for the data points / data lines. See `.plot` for
3392             details.
3393 
3394             Use 'none' (case-insensitive) to plot errorbars without any data
3395             markers.
3396 
3397         ecolor : color, default: None
3398             The color of the errorbar lines.  If None, use the color of the
3399             line connecting the markers.
3400 
3401         elinewidth : float, default: None
3402             The linewidth of the errorbar lines. If None, the linewidth of
3403             the current style is used.
3404 
3405         capsize : float, default: :rc:`errorbar.capsize`
3406             The length of the error bar caps in points.
3407 
3408         capthick : float, default: None
3409             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3410             This setting is a more sensible name for the property that
3411             controls the thickness of the error bar cap in points. For
3412             backwards compatibility, if *mew* or *markeredgewidth* are given,
3413             then they will over-ride *capthick*. This may change in future
3414             releases.
3415 
3416         barsabove : bool, default: False
3417             If True, will plot the errorbars above the plot
3418             symbols. Default is below.
3419 
3420         lolims, uplims, xlolims, xuplims : bool, default: False
3421             These arguments can be used to indicate that a value gives only
3422             upper/lower limits.  In that case a caret symbol is used to
3423             indicate this. *lims*-arguments may be scalars, or array-likes of
3424             the same length as *xerr* and *yerr*.  To use limits with inverted
3425             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3426             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3427             *lolims* to True means that the y-value is a *lower* limit of the
3428             True value, so, only an *upward*-pointing arrow will be drawn!
3429 
3430         errorevery : int or (int, int), default: 1
3431             draws error bars on a subset of the data. *errorevery* =N draws
3432             error bars on the points (x[::N], y[::N]).
3433             *errorevery* =(start, N) draws error bars on the points
3434             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3435             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3436             Used to avoid overlapping error bars when two series share x-axis
3437             values.
3438 
3439         Returns
3440         -------
3441         `.ErrorbarContainer`
3442             The container contains:
3443 
3444             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3445             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3446             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3447               vertical error ranges.
3448 
3449         Other Parameters
3450         ----------------
3451         data : indexable object, optional
3452             DATA_PARAMETER_PLACEHOLDER
3453 
3454         **kwargs
3455             All other keyword arguments are passed on to the `~.Axes.plot` call
3456             drawing the markers. For example, this code makes big red squares
3457             with thick green edges::
3458 
3459                 x, y, yerr = rand(3, 10)
3460                 errorbar(x, y, yerr, marker='s', mfc='red',
3461                          mec='green', ms=20, mew=4)
3462 
3463             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3464             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3465             and *markeredgewidth*.
3466 
3467             Valid kwargs for the marker properties are:
3468 
3469             - *dashes*
3470             - *dash_capstyle*
3471             - *dash_joinstyle*
3472             - *drawstyle*
3473             - *fillstyle*
3474             - *linestyle*
3475             - *marker*
3476             - *markeredgecolor*
3477             - *markeredgewidth*
3478             - *markerfacecolor*
3479             - *markerfacecoloralt*
3480             - *markersize*
3481             - *markevery*
3482             - *solid_capstyle*
3483             - *solid_joinstyle*
3484 
3485             Refer to the corresponding `.Line2D` property for more details:
3486 
3487             %(Line2D:kwdoc)s
3488         """
3489         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3490         # Drop anything that comes in as None to use the default instead.
3491         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3492         kwargs.setdefault('zorder', 2)
3493 
3494         # Casting to object arrays preserves units.
3495         if not isinstance(x, np.ndarray):
3496             x = np.asarray(x, dtype=object)
3497         if not isinstance(y, np.ndarray):
3498             y = np.asarray(y, dtype=object)
3499 
3500         def _upcast_err(err):
3501             """
3502             Safely handle tuple of containers that carry units.
3503 
3504             This function covers the case where the input to the xerr/yerr is a
3505             length 2 tuple of equal length ndarray-subclasses that carry the
3506             unit information in the container.
3507 
3508             If we have a tuple of nested numpy array (subclasses), we defer
3509             coercing the units to be consistent to the underlying unit
3510             library (and implicitly the broadcasting).
3511 
3512             Otherwise, fallback to casting to an object array.
3513             """
3514 
3515             if (
3516                     # make sure it is not a scalar
3517                     np.iterable(err) and
3518                     # and it is not empty
3519                     len(err) > 0 and
3520                     # and the first element is an array sub-class use
3521                     # safe_first_element because getitem is index-first not
3522                     # location first on pandas objects so err[0] almost always
3523                     # fails.
3524                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3525             ):
3526                 # Get the type of the first element
3527                 atype = type(cbook._safe_first_finite(err))
3528                 # Promote the outer container to match the inner container
3529                 if atype is np.ndarray:
3530                     # Converts using np.asarray, because data cannot
3531                     # be directly passed to init of np.ndarray
3532                     return np.asarray(err, dtype=object)
3533                 # If atype is not np.ndarray, directly pass data to init.
3534                 # This works for types such as unyts and astropy units
3535                 return atype(err)
3536             # Otherwise wrap it in an object array
3537             return np.asarray(err, dtype=object)
3538 
3539         if xerr is not None and not isinstance(xerr, np.ndarray):
3540             xerr = _upcast_err(xerr)
3541         if yerr is not None and not isinstance(yerr, np.ndarray):
3542             yerr = _upcast_err(yerr)
3543         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3544         if len(x) != len(y):
3545             raise ValueError("'x' and 'y' must have the same size")
3546 
3547         everymask = self._errorevery_to_mask(x, errorevery)
3548 
3549         label = kwargs.pop("label", None)
3550         kwargs['label'] = '_nolegend_'
3551 
3552         # Create the main line and determine overall kwargs for child artists.
3553         # We avoid calling self.plot() directly, or self._get_lines(), because
3554         # that would call self._process_unit_info again, and do other indirect
3555         # data processing.
3556         (data_line, base_style), = self._get_lines._plot_args(
3557             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3558 
3559         # Do this after creating `data_line` to avoid modifying `base_style`.
3560         if barsabove:
3561             data_line.set_zorder(kwargs['zorder'] - .1)
3562         else:
3563             data_line.set_zorder(kwargs['zorder'] + .1)
3564 
3565         # Add line to plot, or throw it away and use it to determine kwargs.
3566         if fmt.lower() != 'none':
3567             self.add_line(data_line)
3568         else:
3569             data_line = None
3570             # Remove alpha=0 color that _get_lines._plot_args returns for
3571             # 'none' format, and replace it with user-specified color, if
3572             # supplied.
3573             base_style.pop('color')
3574             if 'color' in kwargs:
3575                 base_style['color'] = kwargs.pop('color')
3576 
3577         if 'color' not in base_style:
3578             base_style['color'] = 'C0'
3579         if ecolor is None:
3580             ecolor = base_style['color']
3581 
3582         # Eject any line-specific information from format string, as it's not
3583         # needed for bars or caps.
3584         for key in ['marker', 'markersize', 'markerfacecolor',
3585                     'markerfacecoloralt',
3586                     'markeredgewidth', 'markeredgecolor', 'markevery',
3587                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3588                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3589                     'dashes']:
3590             base_style.pop(key, None)
3591 
3592         # Make the style dict for the line collections (the bars).
3593         eb_lines_style = {**base_style, 'color': ecolor}
3594 
3595         if elinewidth is not None:
3596             eb_lines_style['linewidth'] = elinewidth
3597         elif 'linewidth' in kwargs:
3598             eb_lines_style['linewidth'] = kwargs['linewidth']
3599 
3600         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3601             if key in kwargs:
3602                 eb_lines_style[key] = kwargs[key]
3603 
3604         # Make the style dict for caps (the "hats").
3605         eb_cap_style = {**base_style, 'linestyle': 'none'}
3606         if capsize is None:
3607             capsize = mpl.rcParams["errorbar.capsize"]
3608         if capsize > 0:
3609             eb_cap_style['markersize'] = 2. * capsize
3610         if capthick is not None:
3611             eb_cap_style['markeredgewidth'] = capthick
3612 
3613         # For backwards-compat, allow explicit setting of
3614         # 'markeredgewidth' to over-ride capthick.
3615         for key in ('markeredgewidth', 'transform', 'alpha',
3616                     'zorder', 'rasterized'):
3617             if key in kwargs:
3618                 eb_cap_style[key] = kwargs[key]
3619         eb_cap_style['color'] = ecolor
3620 
3621         barcols = []
3622         caplines = {'x': [], 'y': []}
3623 
3624         # Vectorized fancy-indexer.
3625         def apply_mask(arrays, mask):
3626             return [array[mask] for array in arrays]
3627 
3628         # dep: dependent dataset, indep: independent dataset
3629         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3630              marker, lomarker, himarker) in [
3631                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3632                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3633                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3634                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3635         ]:
3636             if err is None:
3637                 continue
3638             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3639             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3640             try:
3641                 np.broadcast_to(err, (2, len(dep)))
3642             except ValueError:
3643                 raise ValueError(
3644                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3645                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3646                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3647             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3648             if np.any(np.less(err, -err, out=res, where=(err == err))):
3649                 # like err<0, but also works for timedelta and nan.
3650                 raise ValueError(
3651                     f"'{dep_axis}err' must not contain negative values")
3652             # This is like
3653             #     elow, ehigh = np.broadcast_to(...)
3654             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3655             # except that broadcast_to would strip units.
3656             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3657             barcols.append(lines_func(
3658                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3659             if self.name == "polar" and dep_axis == "x":
3660                 for b in barcols:
3661                     for p in b.get_paths():
3662                         p._interpolation_steps = 2
3663             # Normal errorbars for points without upper/lower limits.
3664             nolims = ~(lolims | uplims)
3665             if nolims.any() and capsize > 0:
3666                 indep_masked, lo_masked, hi_masked = apply_mask(
3667                     [indep, low, high], nolims & everymask)
3668                 for lh_masked in [lo_masked, hi_masked]:
3669                     # Since this has to work for x and y as dependent data, we
3670                     # first set both x and y to the independent variable and
3671                     # overwrite the respective dependent data in a second step.
3672                     line = mlines.Line2D(indep_masked, indep_masked,
3673                                          marker=marker, **eb_cap_style)
3674                     line.set(**{f"{dep_axis}data": lh_masked})
3675                     caplines[dep_axis].append(line)
3676             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3677                 if not lims.any():
3678                     continue
3679                 hlmarker = (
3680                     himarker
3681                     if self._axis_map[dep_axis].get_inverted() ^ idx
3682                     else lomarker)
3683                 x_masked, y_masked, hl_masked = apply_mask(
3684                     [x, y, hl], lims & everymask)
3685                 # As above, we set the dependent data in a second step.
3686                 line = mlines.Line2D(x_masked, y_masked,
3687                                      marker=hlmarker, **eb_cap_style)
3688                 line.set(**{f"{dep_axis}data": hl_masked})
3689                 caplines[dep_axis].append(line)
3690                 if capsize > 0:
3691                     caplines[dep_axis].append(mlines.Line2D(
3692                         x_masked, y_masked, marker=marker, **eb_cap_style))
3693         if self.name == 'polar':
3694             for axis in caplines:
3695                 for l in caplines[axis]:
3696                     # Rotate caps to be perpendicular to the error bars
3697                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3698                         rotation = mtransforms.Affine2D().rotate(theta)
3699                         if axis == 'y':
3700                             rotation.rotate(-np.pi / 2)
3701                         ms = mmarkers.MarkerStyle(marker=marker,
3702                                                   transform=rotation)
3703                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3704                                                     **eb_cap_style))
3705         else:
3706             for axis in caplines:
3707                 for l in caplines[axis]:
3708                     self.add_line(l)
3709 
3710         self._request_autoscale_view()
3711         caplines = caplines['x'] + caplines['y']
3712         errorbar_container = ErrorbarContainer(
3713             (data_line, tuple(caplines), tuple(barcols)),
3714             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3715             label=label)
3716         self.containers.append(errorbar_container)
3717 
3718         return errorbar_container  # (l0, caplines, barcols)
3719 
3720     @_preprocess_data()
3721     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3722                 positions=None, widths=None, patch_artist=None,
3723                 bootstrap=None, usermedians=None, conf_intervals=None,
3724                 meanline=None, showmeans=None, showcaps=None,
3725                 showbox=None, showfliers=None, boxprops=None,
3726                 labels=None, flierprops=None, medianprops=None,
3727                 meanprops=None, capprops=None, whiskerprops=None,
3728                 manage_ticks=True, autorange=False, zorder=None,
3729                 capwidths=None):
3730         """
3731         Draw a box and whisker plot.
3732 
3733         The box extends from the first quartile (Q1) to the third
3734         quartile (Q3) of the data, with a line at the median.
3735         The whiskers extend from the box to the farthest data point
3736         lying within 1.5x the inter-quartile range (IQR) from the box.
3737         Flier points are those past the end of the whiskers.
3738         See https://en.wikipedia.org/wiki/Box_plot for reference.
3739 
3740         .. code-block:: none
3741 
3742                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3743                                |-----:-----|
3744                o      |--------|     :     |--------|    o  o
3745                                |-----:-----|
3746              flier             <----------->            fliers
3747                                     IQR
3748 
3749 
3750         Parameters
3751         ----------
3752         x : Array or a sequence of vectors.
3753             The input data.  If a 2D array, a boxplot is drawn for each column
3754             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3755             array in *x*.
3756 
3757         notch : bool, default: False
3758             Whether to draw a notched boxplot (`True`), or a rectangular
3759             boxplot (`False`).  The notches represent the confidence interval
3760             (CI) around the median.  The documentation for *bootstrap*
3761             describes how the locations of the notches are computed by
3762             default, but their locations may also be overridden by setting the
3763             *conf_intervals* parameter.
3764 
3765             .. note::
3766 
3767                 In cases where the values of the CI are less than the
3768                 lower quartile or greater than the upper quartile, the
3769                 notches will extend beyond the box, giving it a
3770                 distinctive "flipped" appearance. This is expected
3771                 behavior and consistent with other statistical
3772                 visualization packages.
3773 
3774         sym : str, optional
3775             The default symbol for flier points.  An empty string ('') hides
3776             the fliers.  If `None`, then the fliers default to 'b+'.  More
3777             control is provided by the *flierprops* parameter.
3778 
3779         vert : bool, default: True
3780             If `True`, draws vertical boxes.
3781             If `False`, draw horizontal boxes.
3782 
3783         whis : float or (float, float), default: 1.5
3784             The position of the whiskers.
3785 
3786             If a float, the lower whisker is at the lowest datum above
3787             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3788             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3789             third quartiles.  The default value of ``whis = 1.5`` corresponds
3790             to Tukey's original definition of boxplots.
3791 
3792             If a pair of floats, they indicate the percentiles at which to
3793             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3794             (0, 100) results in whiskers covering the whole range of the data.
3795 
3796             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3797             to (0, 100) (cover the whole range of the data) if *autorange* is
3798             True.
3799 
3800             Beyond the whiskers, data are considered outliers and are plotted
3801             as individual points.
3802 
3803         bootstrap : int, optional
3804             Specifies whether to bootstrap the confidence intervals
3805             around the median for notched boxplots. If *bootstrap* is
3806             None, no bootstrapping is performed, and notches are
3807             calculated using a Gaussian-based asymptotic approximation
3808             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3809             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3810             the number of times to bootstrap the median to determine its
3811             95% confidence intervals. Values between 1000 and 10000 are
3812             recommended.
3813 
3814         usermedians : 1D array-like, optional
3815             A 1D array-like of length ``len(x)``.  Each entry that is not
3816             `None` forces the value of the median for the corresponding
3817             dataset.  For entries that are `None`, the medians are computed
3818             by Matplotlib as normal.
3819 
3820         conf_intervals : array-like, optional
3821             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3822             None forces the location of the corresponding notch (which is
3823             only drawn if *notch* is `True`).  For entries that are `None`,
3824             the notches are computed by the method specified by the other
3825             parameters (e.g., *bootstrap*).
3826 
3827         positions : array-like, optional
3828             The positions of the boxes. The ticks and limits are
3829             automatically set to match the positions. Defaults to
3830             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3831 
3832         widths : float or array-like
3833             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3834             between extreme positions)``, if that is smaller.
3835 
3836         patch_artist : bool, default: False
3837             If `False` produces boxes with the Line2D artist. Otherwise,
3838             boxes are drawn with Patch artists.
3839 
3840         labels : sequence, optional
3841             Labels for each dataset (one per dataset).
3842 
3843         manage_ticks : bool, default: True
3844             If True, the tick locations and labels will be adjusted to match
3845             the boxplot positions.
3846 
3847         autorange : bool, default: False
3848             When `True` and the data are distributed such that the 25th and
3849             75th percentiles are equal, *whis* is set to (0, 100) such
3850             that the whisker ends are at the minimum and maximum of the data.
3851 
3852         meanline : bool, default: False
3853             If `True` (and *showmeans* is `True`), will try to render the
3854             mean as a line spanning the full width of the box according to
3855             *meanprops* (see below).  Not recommended if *shownotches* is also
3856             True.  Otherwise, means will be shown as points.
3857 
3858         zorder : float, default: ``Line2D.zorder = 2``
3859             The zorder of the boxplot.
3860 
3861         Returns
3862         -------
3863         dict
3864           A dictionary mapping each component of the boxplot to a list
3865           of the `.Line2D` instances created. That dictionary has the
3866           following keys (assuming vertical boxplots):
3867 
3868           - ``boxes``: the main body of the boxplot showing the
3869             quartiles and the median's confidence intervals if
3870             enabled.
3871 
3872           - ``medians``: horizontal lines at the median of each box.
3873 
3874           - ``whiskers``: the vertical lines extending to the most
3875             extreme, non-outlier data points.
3876 
3877           - ``caps``: the horizontal lines at the ends of the
3878             whiskers.
3879 
3880           - ``fliers``: points representing data that extend beyond
3881             the whiskers (fliers).
3882 
3883           - ``means``: points or lines representing the means.
3884 
3885         Other Parameters
3886         ----------------
3887         showcaps : bool, default: True
3888             Show the caps on the ends of whiskers.
3889         showbox : bool, default: True
3890             Show the central box.
3891         showfliers : bool, default: True
3892             Show the outliers beyond the caps.
3893         showmeans : bool, default: False
3894             Show the arithmetic means.
3895         capprops : dict, default: None
3896             The style of the caps.
3897         capwidths : float or array, default: None
3898             The widths of the caps.
3899         boxprops : dict, default: None
3900             The style of the box.
3901         whiskerprops : dict, default: None
3902             The style of the whiskers.
3903         flierprops : dict, default: None
3904             The style of the fliers.
3905         medianprops : dict, default: None
3906             The style of the median.
3907         meanprops : dict, default: None
3908             The style of the mean.
3909         data : indexable object, optional
3910             DATA_PARAMETER_PLACEHOLDER
3911 
3912         See Also
3913         --------
3914         violinplot : Draw an estimate of the probability density function.
3915         """
3916 
3917         # Missing arguments default to rcParams.
3918         if whis is None:
3919             whis = mpl.rcParams['boxplot.whiskers']
3920         if bootstrap is None:
3921             bootstrap = mpl.rcParams['boxplot.bootstrap']
3922 
3923         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3924                                        labels=labels, autorange=autorange)
3925         if notch is None:
3926             notch = mpl.rcParams['boxplot.notch']
3927         if vert is None:
3928             vert = mpl.rcParams['boxplot.vertical']
3929         if patch_artist is None:
3930             patch_artist = mpl.rcParams['boxplot.patchartist']
3931         if meanline is None:
3932             meanline = mpl.rcParams['boxplot.meanline']
3933         if showmeans is None:
3934             showmeans = mpl.rcParams['boxplot.showmeans']
3935         if showcaps is None:
3936             showcaps = mpl.rcParams['boxplot.showcaps']
3937         if showbox is None:
3938             showbox = mpl.rcParams['boxplot.showbox']
3939         if showfliers is None:
3940             showfliers = mpl.rcParams['boxplot.showfliers']
3941 
3942         if boxprops is None:
3943             boxprops = {}
3944         if whiskerprops is None:
3945             whiskerprops = {}
3946         if capprops is None:
3947             capprops = {}
3948         if medianprops is None:
3949             medianprops = {}
3950         if meanprops is None:
3951             meanprops = {}
3952         if flierprops is None:
3953             flierprops = {}
3954 
3955         if patch_artist:
3956             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3957             if 'color' in boxprops:
3958                 boxprops['edgecolor'] = boxprops.pop('color')
3959 
3960         # if non-default sym value, put it into the flier dictionary
3961         # the logic for providing the default symbol ('b+') now lives
3962         # in bxp in the initial value of flierkw
3963         # handle all of the *sym* related logic here so we only have to pass
3964         # on the flierprops dict.
3965         if sym is not None:
3966             # no-flier case, which should really be done with
3967             # 'showfliers=False' but none-the-less deal with it to keep back
3968             # compatibility
3969             if sym == '':
3970                 # blow away existing dict and make one for invisible markers
3971                 flierprops = dict(linestyle='none', marker='', color='none')
3972                 # turn the fliers off just to be safe
3973                 showfliers = False
3974             # now process the symbol string
3975             else:
3976                 # process the symbol string
3977                 # discarded linestyle
3978                 _, marker, color = _process_plot_format(sym)
3979                 # if we have a marker, use it
3980                 if marker is not None:
3981                     flierprops['marker'] = marker
3982                 # if we have a color, use it
3983                 if color is not None:
3984                     # assume that if color is passed in the user want
3985                     # filled symbol, if the users want more control use
3986                     # flierprops
3987                     flierprops['color'] = color
3988                     flierprops['markerfacecolor'] = color
3989                     flierprops['markeredgecolor'] = color
3990 
3991         # replace medians if necessary:
3992         if usermedians is not None:
3993             if (len(np.ravel(usermedians)) != len(bxpstats) or
3994                     np.shape(usermedians)[0] != len(bxpstats)):
3995                 raise ValueError(
3996                     "'usermedians' and 'x' have different lengths")
3997             else:
3998                 # reassign medians as necessary
3999                 for stats, med in zip(bxpstats, usermedians):
4000                     if med is not None:
4001                         stats['med'] = med
4002 
4003         if conf_intervals is not None:
4004             if len(conf_intervals) != len(bxpstats):
4005                 raise ValueError(
4006                     "'conf_intervals' and 'x' have different lengths")
4007             else:
4008                 for stats, ci in zip(bxpstats, conf_intervals):
4009                     if ci is not None:
4010                         if len(ci) != 2:
4011                             raise ValueError('each confidence interval must '
4012                                              'have two values')
4013                         else:
4014                             if ci[0] is not None:
4015                                 stats['cilo'] = ci[0]
4016                             if ci[1] is not None:
4017                                 stats['cihi'] = ci[1]
4018 
4019         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4020                            vert=vert, patch_artist=patch_artist,
4021                            shownotches=notch, showmeans=showmeans,
4022                            showcaps=showcaps, showbox=showbox,
4023                            boxprops=boxprops, flierprops=flierprops,
4024                            medianprops=medianprops, meanprops=meanprops,
4025                            meanline=meanline, showfliers=showfliers,
4026                            capprops=capprops, whiskerprops=whiskerprops,
4027                            manage_ticks=manage_ticks, zorder=zorder,
4028                            capwidths=capwidths)
4029         return artists
4030 
4031     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4032             patch_artist=False, shownotches=False, showmeans=False,
4033             showcaps=True, showbox=True, showfliers=True,
4034             boxprops=None, whiskerprops=None, flierprops=None,
4035             medianprops=None, capprops=None, meanprops=None,
4036             meanline=False, manage_ticks=True, zorder=None,
4037             capwidths=None):
4038         """
4039         Drawing function for box and whisker plots.
4040 
4041         Make a box and whisker plot for each column of *x* or each
4042         vector in sequence *x*.  The box extends from the lower to
4043         upper quartile values of the data, with a line at the median.
4044         The whiskers extend from the box to show the range of the
4045         data.  Flier points are those past the end of the whiskers.
4046 
4047         Parameters
4048         ----------
4049         bxpstats : list of dicts
4050           A list of dictionaries containing stats for each boxplot.
4051           Required keys are:
4052 
4053           - ``med``: Median (scalar).
4054           - ``q1``, ``q3``: First & third quartiles (scalars).
4055           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4056 
4057           Optional keys are:
4058 
4059           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4060           - ``fliers``: Data beyond the whiskers (array-like).
4061             Needed if ``showfliers=True``.
4062           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4063             about the median. Needed if ``shownotches=True``.
4064           - ``label``: Name of the dataset (str).  If available,
4065             this will be used a tick label for the boxplot
4066 
4067         positions : array-like, default: [1, 2, ..., n]
4068           The positions of the boxes. The ticks and limits
4069           are automatically set to match the positions.
4070 
4071         widths : float or array-like, default: None
4072           The widths of the boxes.  The default is
4073           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4074 
4075         capwidths : float or array-like, default: None
4076           Either a scalar or a vector and sets the width of each cap.
4077           The default is ``0.5*(with of the box)``, see *widths*.
4078 
4079         vert : bool, default: True
4080           If `True` (default), makes the boxes vertical.
4081           If `False`, makes horizontal boxes.
4082 
4083         patch_artist : bool, default: False
4084           If `False` produces boxes with the `.Line2D` artist.
4085           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4086 
4087         shownotches, showmeans, showcaps, showbox, showfliers : bool
4088           Whether to draw the CI notches, the mean value (both default to
4089           False), the caps, the box, and the fliers (all three default to
4090           True).
4091 
4092         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4093  dict, optional
4094           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4095           means.
4096 
4097         meanline : bool, default: False
4098           If `True` (and *showmeans* is `True`), will try to render the mean
4099           as a line spanning the full width of the box according to
4100           *meanprops*. Not recommended if *shownotches* is also True.
4101           Otherwise, means will be shown as points.
4102 
4103         manage_ticks : bool, default: True
4104           If True, the tick locations and labels will be adjusted to match the
4105           boxplot positions.
4106 
4107         zorder : float, default: ``Line2D.zorder = 2``
4108           The zorder of the resulting boxplot.
4109 
4110         Returns
4111         -------
4112         dict
4113           A dictionary mapping each component of the boxplot to a list
4114           of the `.Line2D` instances created. That dictionary has the
4115           following keys (assuming vertical boxplots):
4116 
4117           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4118             the median's confidence intervals if enabled.
4119           - ``medians``: horizontal lines at the median of each box.
4120           - ``whiskers``: vertical lines up to the last non-outlier data.
4121           - ``caps``: horizontal lines at the ends of the whiskers.
4122           - ``fliers``: points representing data beyond the whiskers (fliers).
4123           - ``means``: points or lines representing the means.
4124 
4125         Examples
4126         --------
4127         .. plot:: gallery/statistics/bxp.py
4128         """
4129 
4130         # lists of artists to be output
4131         whiskers = []
4132         caps = []
4133         boxes = []
4134         medians = []
4135         means = []
4136         fliers = []
4137 
4138         # empty list of xticklabels
4139         datalabels = []
4140 
4141         # Use default zorder if none specified
4142         if zorder is None:
4143             zorder = mlines.Line2D.zorder
4144 
4145         zdelta = 0.1
4146 
4147         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4148             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4149                  if k.startswith(f'boxplot.{subkey}props')}
4150             d['zorder'] = zorder + zdelta
4151             if not usemarker:
4152                 d['marker'] = ''
4153             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4154             return d
4155 
4156         box_kw = {
4157             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4158             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4159             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4160             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4161                           else mpl.rcParams['patch.facecolor']),
4162             'zorder': zorder,
4163             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4164         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4165         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4166         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4167         flier_kw = merge_kw_rc('flier', flierprops)
4168         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4169         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4170         removed_prop = 'marker' if meanline else 'linestyle'
4171         # Only remove the property if it's not set explicitly as a parameter.
4172         if meanprops is None or removed_prop not in meanprops:
4173             mean_kw[removed_prop] = ''
4174 
4175         # vertical or horizontal plot?
4176         maybe_swap = slice(None) if vert else slice(None, None, -1)
4177 
4178         def do_plot(xs, ys, **kwargs):
4179             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4180 
4181         def do_patch(xs, ys, **kwargs):
4182             path = mpath.Path._create_closed(
4183                 np.column_stack([xs, ys][maybe_swap]))
4184             patch = mpatches.PathPatch(path, **kwargs)
4185             self.add_artist(patch)
4186             return patch
4187 
4188         # input validation
4189         N = len(bxpstats)
4190         datashape_message = ("List of boxplot statistics and `{0}` "
4191                              "values must have same the length")
4192         # check position
4193         if positions is None:
4194             positions = list(range(1, N + 1))
4195         elif len(positions) != N:
4196             raise ValueError(datashape_message.format("positions"))
4197 
4198         positions = np.array(positions)
4199         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4200             raise TypeError("positions should be an iterable of numbers")
4201 
4202         # width
4203         if widths is None:
4204             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4205         elif np.isscalar(widths):
4206             widths = [widths] * N
4207         elif len(widths) != N:
4208             raise ValueError(datashape_message.format("widths"))
4209 
4210         # capwidth
4211         if capwidths is None:
4212             capwidths = 0.5 * np.array(widths)
4213         elif np.isscalar(capwidths):
4214             capwidths = [capwidths] * N
4215         elif len(capwidths) != N:
4216             raise ValueError(datashape_message.format("capwidths"))
4217 
4218         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4219                                                capwidths):
4220             # try to find a new label
4221             datalabels.append(stats.get('label', pos))
4222 
4223             # whisker coords
4224             whis_x = [pos, pos]
4225             whislo_y = [stats['q1'], stats['whislo']]
4226             whishi_y = [stats['q3'], stats['whishi']]
4227             # cap coords
4228             cap_left = pos - capwidth * 0.5
4229             cap_right = pos + capwidth * 0.5
4230             cap_x = [cap_left, cap_right]
4231             cap_lo = np.full(2, stats['whislo'])
4232             cap_hi = np.full(2, stats['whishi'])
4233             # box and median coords
4234             box_left = pos - width * 0.5
4235             box_right = pos + width * 0.5
4236             med_y = [stats['med'], stats['med']]
4237             # notched boxes
4238             if shownotches:
4239                 notch_left = pos - width * 0.25
4240                 notch_right = pos + width * 0.25
4241                 box_x = [box_left, box_right, box_right, notch_right,
4242                          box_right, box_right, box_left, box_left, notch_left,
4243                          box_left, box_left]
4244                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4245                          stats['med'], stats['cihi'], stats['q3'],
4246                          stats['q3'], stats['cihi'], stats['med'],
4247                          stats['cilo'], stats['q1']]
4248                 med_x = [notch_left, notch_right]
4249             # plain boxes
4250             else:
4251                 box_x = [box_left, box_right, box_right, box_left, box_left]
4252                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4253                          stats['q1']]
4254                 med_x = [box_left, box_right]
4255 
4256             # maybe draw the box
4257             if showbox:
4258                 do_box = do_patch if patch_artist else do_plot
4259                 boxes.append(do_box(box_x, box_y, **box_kw))
4260             # draw the whiskers
4261             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4262             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4263             # maybe draw the caps
4264             if showcaps:
4265                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4266                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4267             # draw the medians
4268             medians.append(do_plot(med_x, med_y, **median_kw))
4269             # maybe draw the means
4270             if showmeans:
4271                 if meanline:
4272                     means.append(do_plot(
4273                         [box_left, box_right], [stats['mean'], stats['mean']],
4274                         **mean_kw
4275                     ))
4276                 else:
4277                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4278             # maybe draw the fliers
4279             if showfliers:
4280                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4281                 flier_y = stats['fliers']
4282                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4283 
4284         if manage_ticks:
4285             axis_name = "x" if vert else "y"
4286             interval = getattr(self.dataLim, f"interval{axis_name}")
4287             axis = self._axis_map[axis_name]
4288             positions = axis.convert_units(positions)
4289             # The 0.5 additional padding ensures reasonable-looking boxes
4290             # even when drawing a single box.  We set the sticky edge to
4291             # prevent margins expansion, in order to match old behavior (back
4292             # when separate calls to boxplot() would completely reset the axis
4293             # limits regardless of what was drawn before).  The sticky edges
4294             # are attached to the median lines, as they are always present.
4295             interval[:] = (min(interval[0], min(positions) - .5),
4296                            max(interval[1], max(positions) + .5))
4297             for median, position in zip(medians, positions):
4298                 getattr(median.sticky_edges, axis_name).extend(
4299                     [position - .5, position + .5])
4300             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4301             locator = axis.get_major_locator()
4302             if not isinstance(axis.get_major_locator(),
4303                               mticker.FixedLocator):
4304                 locator = mticker.FixedLocator([])
4305                 axis.set_major_locator(locator)
4306             locator.locs = np.array([*locator.locs, *positions])
4307             formatter = axis.get_major_formatter()
4308             if not isinstance(axis.get_major_formatter(),
4309                               mticker.FixedFormatter):
4310                 formatter = mticker.FixedFormatter([])
4311                 axis.set_major_formatter(formatter)
4312             formatter.seq = [*formatter.seq, *datalabels]
4313 
4314             self._request_autoscale_view()
4315 
4316         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4317                     medians=medians, fliers=fliers, means=means)
4318 
4319     @staticmethod
4320     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4321                                   get_next_color_func):
4322         """
4323         Helper function to process color related arguments of `.Axes.scatter`.
4324 
4325         Argument precedence for facecolors:
4326 
4327         - c (if not None)
4328         - kwargs['facecolor']
4329         - kwargs['facecolors']
4330         - kwargs['color'] (==kwcolor)
4331         - 'b' if in classic mode else the result of ``get_next_color_func()``
4332 
4333         Argument precedence for edgecolors:
4334 
4335         - kwargs['edgecolor']
4336         - edgecolors (is an explicit kw argument in scatter())
4337         - kwargs['color'] (==kwcolor)
4338         - 'face' if not in classic mode else None
4339 
4340         Parameters
4341         ----------
4342         c : color or sequence or sequence of color or None
4343             See argument description of `.Axes.scatter`.
4344         edgecolors : color or sequence of color or {'face', 'none'} or None
4345             See argument description of `.Axes.scatter`.
4346         kwargs : dict
4347             Additional kwargs. If these keys exist, we pop and process them:
4348             'facecolors', 'facecolor', 'edgecolor', 'color'
4349             Note: The dict is modified by this function.
4350         xsize : int
4351             The size of the x and y arrays passed to `.Axes.scatter`.
4352         get_next_color_func : callable
4353             A callable that returns a color. This color is used as facecolor
4354             if no other color is provided.
4355 
4356             Note, that this is a function rather than a fixed color value to
4357             support conditional evaluation of the next color.  As of the
4358             current implementation obtaining the next color from the
4359             property cycle advances the cycle. This must only happen if we
4360             actually use the color, which will only be decided within this
4361             method.
4362 
4363         Returns
4364         -------
4365         c
4366             The input *c* if it was not *None*, else a color derived from the
4367             other inputs or defaults.
4368         colors : array(N, 4) or None
4369             The facecolors as RGBA values, or *None* if a colormap is used.
4370         edgecolors
4371             The edgecolor.
4372 
4373         """
4374         facecolors = kwargs.pop('facecolors', None)
4375         facecolors = kwargs.pop('facecolor', facecolors)
4376         edgecolors = kwargs.pop('edgecolor', edgecolors)
4377 
4378         kwcolor = kwargs.pop('color', None)
4379 
4380         if kwcolor is not None and c is not None:
4381             raise ValueError("Supply a 'c' argument or a 'color'"
4382                              " kwarg but not both; they differ but"
4383                              " their functionalities overlap.")
4384 
4385         if kwcolor is not None:
4386             try:
4387                 mcolors.to_rgba_array(kwcolor)
4388             except ValueError as err:
4389                 raise ValueError(
4390                     "'color' kwarg must be a color or sequence of color "
4391                     "specs.  For a sequence of values to be color-mapped, use "
4392                     "the 'c' argument instead.") from err
4393             if edgecolors is None:
4394                 edgecolors = kwcolor
4395             if facecolors is None:
4396                 facecolors = kwcolor
4397 
4398         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4399             edgecolors = mpl.rcParams['scatter.edgecolors']
4400 
4401         c_was_none = c is None
4402         if c is None:
4403             c = (facecolors if facecolors is not None
4404                  else "b" if mpl.rcParams['_internal.classic_mode']
4405                  else get_next_color_func())
4406         c_is_string_or_strings = (
4407             isinstance(c, str)
4408             or (np.iterable(c) and len(c) > 0
4409                 and isinstance(cbook._safe_first_finite(c), str)))
4410 
4411         def invalid_shape_exception(csize, xsize):
4412             return ValueError(
4413                 f"'c' argument has {csize} elements, which is inconsistent "
4414                 f"with 'x' and 'y' with size {xsize}.")
4415 
4416         c_is_mapped = False  # Unless proven otherwise below.
4417         valid_shape = True  # Unless proven otherwise below.
4418         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4419             try:  # First, does 'c' look suitable for value-mapping?
4420                 c = np.asanyarray(c, dtype=float)
4421             except ValueError:
4422                 pass  # Failed to convert to float array; must be color specs.
4423             else:
4424                 # handle the documented special case of a 2D array with 1
4425                 # row which as RGB(A) to broadcast.
4426                 if c.shape == (1, 4) or c.shape == (1, 3):
4427                     c_is_mapped = False
4428                     if c.size != xsize:
4429                         valid_shape = False
4430                 # If c can be either mapped values or an RGB(A) color, prefer
4431                 # the former if shapes match, the latter otherwise.
4432                 elif c.size == xsize:
4433                     c = c.ravel()
4434                     c_is_mapped = True
4435                 else:  # Wrong size; it must not be intended for mapping.
4436                     if c.shape in ((3,), (4,)):
4437                         _api.warn_external(
4438                             "*c* argument looks like a single numeric RGB or "
4439                             "RGBA sequence, which should be avoided as value-"
4440                             "mapping will have precedence in case its length "
4441                             "matches with *x* & *y*.  Please use the *color* "
4442                             "keyword-argument or provide a 2D array "
4443                             "with a single row if you intend to specify "
4444                             "the same RGB or RGBA value for all points.")
4445                     valid_shape = False
4446         if not c_is_mapped:
4447             try:  # Is 'c' acceptable as PathCollection facecolors?
4448                 colors = mcolors.to_rgba_array(c)
4449             except (TypeError, ValueError) as err:
4450                 if "RGBA values should be within 0-1 range" in str(err):
4451                     raise
4452                 else:
4453                     if not valid_shape:
4454                         raise invalid_shape_exception(c.size, xsize) from err
4455                     # Both the mapping *and* the RGBA conversion failed: pretty
4456                     # severe failure => one may appreciate a verbose feedback.
4457                     raise ValueError(
4458                         f"'c' argument must be a color, a sequence of colors, "
4459                         f"or a sequence of numbers, not {c!r}") from err
4460             else:
4461                 if len(colors) not in (0, 1, xsize):
4462                     # NB: remember that a single color is also acceptable.
4463                     # Besides *colors* will be an empty array if c == 'none'.
4464                     raise invalid_shape_exception(len(colors), xsize)
4465         else:
4466             colors = None  # use cmap, norm after collection is created
4467         return c, colors, edgecolors
4468 
4469     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4470                                      "edgecolors", "c", "facecolor",
4471                                      "facecolors", "color"],
4472                       label_namer="y")
4473     @_docstring.interpd
4474     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4475                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4476                 edgecolors=None, plotnonfinite=False, **kwargs):
4477         """
4478         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4479 
4480         Parameters
4481         ----------
4482         x, y : float or array-like, shape (n, )
4483             The data positions.
4484 
4485         s : float or array-like, shape (n, ), optional
4486             The marker size in points**2 (typographic points are 1/72 in.).
4487             Default is ``rcParams['lines.markersize'] ** 2``.
4488 
4489             The linewidth and edgecolor can visually interact with the marker
4490             size, and can lead to artifacts if the marker size is smaller than
4491             the linewidth.
4492 
4493             If the linewidth is greater than 0 and the edgecolor is anything
4494             but *'none'*, then the effective size of the marker will be
4495             increased by half the linewidth because the stroke will be centered
4496             on the edge of the shape.
4497 
4498             To eliminate the marker edge either set *linewidth=0* or
4499             *edgecolor='none'*.
4500 
4501         c : array-like or list of colors or color, optional
4502             The marker colors. Possible values:
4503 
4504             - A scalar or sequence of n numbers to be mapped to colors using
4505               *cmap* and *norm*.
4506             - A 2D array in which the rows are RGB or RGBA.
4507             - A sequence of colors of length n.
4508             - A single color format string.
4509 
4510             Note that *c* should not be a single numeric RGB or RGBA sequence
4511             because that is indistinguishable from an array of values to be
4512             colormapped. If you want to specify the same RGB or RGBA value for
4513             all points, use a 2D array with a single row.  Otherwise,
4514             value-matching will have precedence in case of a size matching with
4515             *x* and *y*.
4516 
4517             If you wish to specify a single color for all points
4518             prefer the *color* keyword argument.
4519 
4520             Defaults to `None`. In that case the marker color is determined
4521             by the value of *color*, *facecolor* or *facecolors*. In case
4522             those are not specified or `None`, the marker color is determined
4523             by the next color of the ``Axes``' current "shape and fill" color
4524             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4525 
4526         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4527             The marker style. *marker* can be either an instance of the class
4528             or the text shorthand for a particular marker.
4529             See :mod:`matplotlib.markers` for more information about marker
4530             styles.
4531 
4532         %(cmap_doc)s
4533 
4534             This parameter is ignored if *c* is RGB(A).
4535 
4536         %(norm_doc)s
4537 
4538             This parameter is ignored if *c* is RGB(A).
4539 
4540         %(vmin_vmax_doc)s
4541 
4542             This parameter is ignored if *c* is RGB(A).
4543 
4544         alpha : float, default: None
4545             The alpha blending value, between 0 (transparent) and 1 (opaque).
4546 
4547         linewidths : float or array-like, default: :rc:`lines.linewidth`
4548             The linewidth of the marker edges. Note: The default *edgecolors*
4549             is 'face'. You may want to change this as well.
4550 
4551         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4552 default: :rc:`scatter.edgecolors`
4553             The edge color of the marker. Possible values:
4554 
4555             - 'face': The edge color will always be the same as the face color.
4556             - 'none': No patch boundary will be drawn.
4557             - A color or sequence of colors.
4558 
4559             For non-filled markers, *edgecolors* is ignored. Instead, the color
4560             is determined like with 'face', i.e. from *c*, *colors*, or
4561             *facecolors*.
4562 
4563         plotnonfinite : bool, default: False
4564             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4565             or ``nan``). If ``True`` the points are drawn with the *bad*
4566             colormap color (see `.Colormap.set_bad`).
4567 
4568         Returns
4569         -------
4570         `~matplotlib.collections.PathCollection`
4571 
4572         Other Parameters
4573         ----------------
4574         data : indexable object, optional
4575             DATA_PARAMETER_PLACEHOLDER
4576         **kwargs : `~matplotlib.collections.Collection` properties
4577 
4578         See Also
4579         --------
4580         plot : To plot scatter plots when markers are identical in size and
4581             color.
4582 
4583         Notes
4584         -----
4585         * The `.plot` function will be faster for scatterplots where markers
4586           don't vary in size or color.
4587 
4588         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4589           case all masks will be combined and only unmasked points will be
4590           plotted.
4591 
4592         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4593           may be input as N-D arrays, but within scatter they will be
4594           flattened. The exception is *c*, which will be flattened only if its
4595           size matches the size of *x* and *y*.
4596 
4597         """
4598         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4599         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4600         # np.ma.ravel yields an ndarray, not a masked array,
4601         # unless its argument is a masked array.
4602         x = np.ma.ravel(x)
4603         y = np.ma.ravel(y)
4604         if x.size != y.size:
4605             raise ValueError("x and y must be the same size")
4606 
4607         if s is None:
4608             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4609                  mpl.rcParams['lines.markersize'] ** 2.0)
4610         s = np.ma.ravel(s)
4611         if (len(s) not in (1, x.size) or
4612                 (not np.issubdtype(s.dtype, np.floating) and
4613                  not np.issubdtype(s.dtype, np.integer))):
4614             raise ValueError(
4615                 "s must be a scalar, "
4616                 "or float array-like with the same size as x and y")
4617 
4618         # get the original edgecolor the user passed before we normalize
4619         orig_edgecolor = edgecolors
4620         if edgecolors is None:
4621             orig_edgecolor = kwargs.get('edgecolor', None)
4622         c, colors, edgecolors = \
4623             self._parse_scatter_color_args(
4624                 c, edgecolors, kwargs, x.size,
4625                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4626 
4627         if plotnonfinite and colors is None:
4628             c = np.ma.masked_invalid(c)
4629             x, y, s, edgecolors, linewidths = \
4630                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4631         else:
4632             x, y, s, c, colors, edgecolors, linewidths = \
4633                 cbook._combine_masks(
4634                     x, y, s, c, colors, edgecolors, linewidths)
4635         # Unmask edgecolors if it was actually a single RGB or RGBA.
4636         if (x.size in (3, 4)
4637                 and np.ma.is_masked(edgecolors)
4638                 and not np.ma.is_masked(orig_edgecolor)):
4639             edgecolors = edgecolors.data
4640 
4641         scales = s   # Renamed for readability below.
4642 
4643         # load default marker from rcParams
4644         if marker is None:
4645             marker = mpl.rcParams['scatter.marker']
4646 
4647         if isinstance(marker, mmarkers.MarkerStyle):
4648             marker_obj = marker
4649         else:
4650             marker_obj = mmarkers.MarkerStyle(marker)
4651 
4652         path = marker_obj.get_path().transformed(
4653             marker_obj.get_transform())
4654         if not marker_obj.is_filled():
4655             if orig_edgecolor is not None:
4656                 _api.warn_external(
4657                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4658                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4659                     "ignoring the edgecolor in favor of the facecolor.  This "
4660                     "behavior may change in the future."
4661                 )
4662             # We need to handle markers that cannot be filled (like
4663             # '+' and 'x') differently than markers that can be
4664             # filled, but have their fillstyle set to 'none'.  This is
4665             # to get:
4666             #
4667             #  - respecting the fillestyle if set
4668             #  - maintaining back-compatibility for querying the facecolor of
4669             #    the un-fillable markers.
4670             #
4671             # While not an ideal situation, but is better than the
4672             # alternatives.
4673             if marker_obj.get_fillstyle() == 'none':
4674                 # promote the facecolor to be the edgecolor
4675                 edgecolors = colors
4676                 # set the facecolor to 'none' (at the last chance) because
4677                 # we cannot fill a path if the facecolor is non-null
4678                 # (which is defendable at the renderer level).
4679                 colors = 'none'
4680             else:
4681                 # if we are not nulling the face color we can do this
4682                 # simpler
4683                 edgecolors = 'face'
4684 
4685             if linewidths is None:
4686                 linewidths = mpl.rcParams['lines.linewidth']
4687             elif np.iterable(linewidths):
4688                 linewidths = [
4689                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4690                     for lw in linewidths]
4691 
4692         offsets = np.ma.column_stack([x, y])
4693 
4694         collection = mcoll.PathCollection(
4695             (path,), scales,
4696             facecolors=colors,
4697             edgecolors=edgecolors,
4698             linewidths=linewidths,
4699             offsets=offsets,
4700             offset_transform=kwargs.pop('transform', self.transData),
4701             alpha=alpha,
4702         )
4703         collection.set_transform(mtransforms.IdentityTransform())
4704         if colors is None:
4705             collection.set_array(c)
4706             collection.set_cmap(cmap)
4707             collection.set_norm(norm)
4708             collection._scale_norm(norm, vmin, vmax)
4709         else:
4710             extra_kwargs = {
4711                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4712                     }
4713             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4714             if any(extra_keys):
4715                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4716                 _api.warn_external(
4717                     "No data for colormapping provided via 'c'. "
4718                     f"Parameters {keys_str} will be ignored")
4719         collection._internal_update(kwargs)
4720 
4721         # Classic mode only:
4722         # ensure there are margins to allow for the
4723         # finite size of the symbols.  In v2.x, margins
4724         # are present by default, so we disable this
4725         # scatter-specific override.
4726         if mpl.rcParams['_internal.classic_mode']:
4727             if self._xmargin < 0.05 and x.size > 0:
4728                 self.set_xmargin(0.05)
4729             if self._ymargin < 0.05 and x.size > 0:
4730                 self.set_ymargin(0.05)
4731 
4732         self.add_collection(collection)
4733         self._request_autoscale_view()
4734 
4735         return collection
4736 
4737     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4738     @_docstring.dedent_interpd
4739     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4740                xscale='linear', yscale='linear', extent=None,
4741                cmap=None, norm=None, vmin=None, vmax=None,
4742                alpha=None, linewidths=None, edgecolors='face',
4743                reduce_C_function=np.mean, mincnt=None, marginals=False,
4744                **kwargs):
4745         """
4746         Make a 2D hexagonal binning plot of points *x*, *y*.
4747 
4748         If *C* is *None*, the value of the hexagon is determined by the number
4749         of points in the hexagon. Otherwise, *C* specifies values at the
4750         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4751         using *reduce_C_function*.
4752 
4753         Parameters
4754         ----------
4755         x, y : array-like
4756             The data positions. *x* and *y* must be of the same length.
4757 
4758         C : array-like, optional
4759             If given, these values are accumulated in the bins. Otherwise,
4760             every point has a value of 1. Must be of the same length as *x*
4761             and *y*.
4762 
4763         gridsize : int or (int, int), default: 100
4764             If a single int, the number of hexagons in the *x*-direction.
4765             The number of hexagons in the *y*-direction is chosen such that
4766             the hexagons are approximately regular.
4767 
4768             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4769             in the *x*-direction and the *y*-direction. In the
4770             *y*-direction, counting is done along vertically aligned
4771             hexagons, not along the zig-zag chains of hexagons; see the
4772             following illustration.
4773 
4774             .. plot::
4775 
4776                import numpy
4777                import matplotlib.pyplot as plt
4778 
4779                np.random.seed(19680801)
4780                n= 300
4781                x = np.random.standard_normal(n)
4782                y = np.random.standard_normal(n)
4783 
4784                fig, ax = plt.subplots(figsize=(4, 4))
4785                h = ax.hexbin(x, y, gridsize=(5, 3))
4786                hx, hy = h.get_offsets().T
4787                ax.plot(hx[24::3], hy[24::3], 'ro-')
4788                ax.plot(hx[-3:], hy[-3:], 'ro-')
4789                ax.set_title('gridsize=(5, 3)')
4790                ax.axis('off')
4791 
4792             To get approximately regular hexagons, choose
4793             :math:`n_x = \\sqrt{3}\\,n_y`.
4794 
4795         bins : 'log' or int or sequence, default: None
4796             Discretization of the hexagon values.
4797 
4798             - If *None*, no binning is applied; the color of each hexagon
4799               directly corresponds to its count value.
4800             - If 'log', use a logarithmic scale for the colormap.
4801               Internally, :math:`log_{10}(i+1)` is used to determine the
4802               hexagon color. This is equivalent to ``norm=LogNorm()``.
4803             - If an integer, divide the counts in the specified number
4804               of bins, and color the hexagons accordingly.
4805             - If a sequence of values, the values of the lower bound of
4806               the bins to be used.
4807 
4808         xscale : {'linear', 'log'}, default: 'linear'
4809             Use a linear or log10 scale on the horizontal axis.
4810 
4811         yscale : {'linear', 'log'}, default: 'linear'
4812             Use a linear or log10 scale on the vertical axis.
4813 
4814         mincnt : int > 0, default: *None*
4815             If not *None*, only display cells with more than *mincnt*
4816             number of points in the cell.
4817 
4818         marginals : bool, default: *False*
4819             If marginals is *True*, plot the marginal density as
4820             colormapped rectangles along the bottom of the x-axis and
4821             left of the y-axis.
4822 
4823         extent : 4-tuple of float, default: *None*
4824             The limits of the bins (xmin, xmax, ymin, ymax).
4825             The default assigns the limits based on
4826             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4827 
4828             If *xscale* or *yscale* is set to 'log', the limits are
4829             expected to be the exponent for a power of 10. E.g. for
4830             x-limits of 1 and 50 in 'linear' scale and y-limits
4831             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4832 
4833         Returns
4834         -------
4835         `~matplotlib.collections.PolyCollection`
4836             A `.PolyCollection` defining the hexagonal bins.
4837 
4838             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4839               the x, y positions of the M hexagon centers.
4840             - `.PolyCollection.get_array` contains the values of the M
4841               hexagons.
4842 
4843             If *marginals* is *True*, horizontal
4844             bar and vertical bar (both PolyCollections) will be attached
4845             to the return collection as attributes *hbar* and *vbar*.
4846 
4847         Other Parameters
4848         ----------------
4849         %(cmap_doc)s
4850 
4851         %(norm_doc)s
4852 
4853         %(vmin_vmax_doc)s
4854 
4855         alpha : float between 0 and 1, optional
4856             The alpha blending value, between 0 (transparent) and 1 (opaque).
4857 
4858         linewidths : float, default: *None*
4859             If *None*, defaults to 1.0.
4860 
4861         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4862             The color of the hexagon edges. Possible values are:
4863 
4864             - 'face': Draw the edges in the same color as the fill color.
4865             - 'none': No edges are drawn. This can sometimes lead to unsightly
4866               unpainted pixels between the hexagons.
4867             - *None*: Draw outlines in the default color.
4868             - An explicit color.
4869 
4870         reduce_C_function : callable, default: `numpy.mean`
4871             The function to aggregate *C* within the bins. It is ignored if
4872             *C* is not given. This must have the signature::
4873 
4874                 def reduce_C_function(C: array) -> float
4875 
4876             Commonly used functions are:
4877 
4878             - `numpy.mean`: average of the points
4879             - `numpy.sum`: integral of the point values
4880             - `numpy.amax`: value taken from the largest point
4881 
4882         data : indexable object, optional
4883             DATA_PARAMETER_PLACEHOLDER
4884 
4885         **kwargs : `~matplotlib.collections.PolyCollection` properties
4886             All other keyword arguments are passed on to `.PolyCollection`:
4887 
4888             %(PolyCollection:kwdoc)s
4889 
4890         See Also
4891         --------
4892         hist2d : 2D histogram rectangular bins
4893         """
4894         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4895 
4896         x, y, C = cbook.delete_masked_points(x, y, C)
4897 
4898         # Set the size of the hexagon grid
4899         if np.iterable(gridsize):
4900             nx, ny = gridsize
4901         else:
4902             nx = gridsize
4903             ny = int(nx / math.sqrt(3))
4904         # Count the number of data in each hexagon
4905         x = np.asarray(x, float)
4906         y = np.asarray(y, float)
4907 
4908         # Will be log()'d if necessary, and then rescaled.
4909         tx = x
4910         ty = y
4911 
4912         if xscale == 'log':
4913             if np.any(x <= 0.0):
4914                 raise ValueError(
4915                     "x contains non-positive values, so cannot be log-scaled")
4916             tx = np.log10(tx)
4917         if yscale == 'log':
4918             if np.any(y <= 0.0):
4919                 raise ValueError(
4920                     "y contains non-positive values, so cannot be log-scaled")
4921             ty = np.log10(ty)
4922         if extent is not None:
4923             xmin, xmax, ymin, ymax = extent
4924         else:
4925             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4926             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4927 
4928             # to avoid issues with singular data, expand the min/max pairs
4929             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4930             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4931 
4932         nx1 = nx + 1
4933         ny1 = ny + 1
4934         nx2 = nx
4935         ny2 = ny
4936         n = nx1 * ny1 + nx2 * ny2
4937 
4938         # In the x-direction, the hexagons exactly cover the region from
4939         # xmin to xmax. Need some padding to avoid roundoff errors.
4940         padding = 1.e-9 * (xmax - xmin)
4941         xmin -= padding
4942         xmax += padding
4943         sx = (xmax - xmin) / nx
4944         sy = (ymax - ymin) / ny
4945         # Positions in hexagon index coordinates.
4946         ix = (tx - xmin) / sx
4947         iy = (ty - ymin) / sy
4948         ix1 = np.round(ix).astype(int)
4949         iy1 = np.round(iy).astype(int)
4950         ix2 = np.floor(ix).astype(int)
4951         iy2 = np.floor(iy).astype(int)
4952         # flat indices, plus one so that out-of-range points go to position 0.
4953         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4954                       ix1 * ny1 + iy1 + 1, 0)
4955         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4956                       ix2 * ny2 + iy2 + 1, 0)
4957 
4958         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4959         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4960         bdist = (d1 < d2)
4961 
4962         if C is None:  # [1:] drops out-of-range points.
4963             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4964             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4965             accum = np.concatenate([counts1, counts2]).astype(float)
4966             if mincnt is not None:
4967                 accum[accum < mincnt] = np.nan
4968             C = np.ones(len(x))
4969         else:
4970             # store the C values in a list per hexagon index
4971             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4972             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4973             for i in range(len(x)):
4974                 if bdist[i]:
4975                     Cs_at_i1[i1[i]].append(C[i])
4976                 else:
4977                     Cs_at_i2[i2[i]].append(C[i])
4978             if mincnt is None:
4979                 mincnt = 0
4980             accum = np.array(
4981                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4982                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4983                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4984                 float)
4985 
4986         good_idxs = ~np.isnan(accum)
4987 
4988         offsets = np.zeros((n, 2), float)
4989         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4990         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4991         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4992         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4993         offsets[:, 0] *= sx
4994         offsets[:, 1] *= sy
4995         offsets[:, 0] += xmin
4996         offsets[:, 1] += ymin
4997         # remove accumulation bins with no data
4998         offsets = offsets[good_idxs, :]
4999         accum = accum[good_idxs]
5000 
5001         polygon = [sx, sy / 3] * np.array(
5002             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5003 
5004         if linewidths is None:
5005             linewidths = [1.0]
5006 
5007         if xscale == 'log' or yscale == 'log':
5008             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5009             if xscale == 'log':
5010                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5011                 xmin = 10.0 ** xmin
5012                 xmax = 10.0 ** xmax
5013                 self.set_xscale(xscale)
5014             if yscale == 'log':
5015                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5016                 ymin = 10.0 ** ymin
5017                 ymax = 10.0 ** ymax
5018                 self.set_yscale(yscale)
5019             collection = mcoll.PolyCollection(
5020                 polygons,
5021                 edgecolors=edgecolors,
5022                 linewidths=linewidths,
5023                 )
5024         else:
5025             collection = mcoll.PolyCollection(
5026                 [polygon],
5027                 edgecolors=edgecolors,
5028                 linewidths=linewidths,
5029                 offsets=offsets,
5030                 offset_transform=mtransforms.AffineDeltaTransform(
5031                     self.transData),
5032             )
5033 
5034         # Set normalizer if bins is 'log'
5035         if bins == 'log':
5036             if norm is not None:
5037                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5038                                    f"can be supplied, ignoring bins={bins}")
5039             else:
5040                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5041                 vmin = vmax = None
5042             bins = None
5043 
5044         # autoscale the norm with current accum values if it hasn't been set
5045         if norm is not None:
5046             if norm.vmin is None and norm.vmax is None:
5047                 norm.autoscale(accum)
5048 
5049         if bins is not None:
5050             if not np.iterable(bins):
5051                 minimum, maximum = min(accum), max(accum)
5052                 bins -= 1  # one less edge than bins
5053                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5054             bins = np.sort(bins)
5055             accum = bins.searchsorted(accum)
5056 
5057         collection.set_array(accum)
5058         collection.set_cmap(cmap)
5059         collection.set_norm(norm)
5060         collection.set_alpha(alpha)
5061         collection._internal_update(kwargs)
5062         collection._scale_norm(norm, vmin, vmax)
5063 
5064         corners = ((xmin, ymin), (xmax, ymax))
5065         self.update_datalim(corners)
5066         self._request_autoscale_view(tight=True)
5067 
5068         # add the collection last
5069         self.add_collection(collection, autolim=False)
5070         if not marginals:
5071             return collection
5072 
5073         # Process marginals
5074         bars = []
5075         for zname, z, zmin, zmax, zscale, nbins in [
5076                 ("x", x, xmin, xmax, xscale, nx),
5077                 ("y", y, ymin, ymax, yscale, 2 * ny),
5078         ]:
5079 
5080             if zscale == "log":
5081                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5082             else:
5083                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5084 
5085             verts = np.empty((nbins, 4, 2))
5086             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5087             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5088             verts[:, 0, 1] = verts[:, 3, 1] = .00
5089             verts[:, 1, 1] = verts[:, 2, 1] = .05
5090             if zname == "y":
5091                 verts = verts[:, :, ::-1]  # Swap x and y.
5092 
5093             # Sort z-values into bins defined by bin_edges.
5094             bin_idxs = np.searchsorted(bin_edges, z) - 1
5095             values = np.empty(nbins)
5096             for i in range(nbins):
5097                 # Get C-values for each bin, and compute bin value with
5098                 # reduce_C_function.
5099                 ci = C[bin_idxs == i]
5100                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5101 
5102             mask = ~np.isnan(values)
5103             verts = verts[mask]
5104             values = values[mask]
5105 
5106             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5107             bar = mcoll.PolyCollection(
5108                 verts, transform=trans, edgecolors="face")
5109             bar.set_array(values)
5110             bar.set_cmap(cmap)
5111             bar.set_norm(norm)
5112             bar.set_alpha(alpha)
5113             bar._internal_update(kwargs)
5114             bars.append(self.add_collection(bar, autolim=False))
5115 
5116         collection.hbar, collection.vbar = bars
5117 
5118         def on_changed(collection):
5119             collection.hbar.set_cmap(collection.get_cmap())
5120             collection.hbar.set_cmap(collection.get_cmap())
5121             collection.vbar.set_clim(collection.get_clim())
5122             collection.vbar.set_clim(collection.get_clim())
5123 
5124         collection.callbacks.connect('changed', on_changed)
5125 
5126         return collection
5127 
5128     @_docstring.dedent_interpd
5129     def arrow(self, x, y, dx, dy, **kwargs):
5130         """
5131         Add an arrow to the Axes.
5132 
5133         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5134 
5135         Parameters
5136         ----------
5137         %(FancyArrow)s
5138 
5139         Returns
5140         -------
5141         `.FancyArrow`
5142             The created `.FancyArrow` object.
5143 
5144         Notes
5145         -----
5146         The resulting arrow is affected by the Axes aspect ratio and limits.
5147         This may produce an arrow whose head is not square with its stem. To
5148         create an arrow whose head is square with its stem,
5149         use :meth:`annotate` for example:
5150 
5151         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5152         ...             arrowprops=dict(arrowstyle="->"))
5153 
5154         """
5155         # Strip away units for the underlying patch since units
5156         # do not make sense to most patch-like code
5157         x = self.convert_xunits(x)
5158         y = self.convert_yunits(y)
5159         dx = self.convert_xunits(dx)
5160         dy = self.convert_yunits(dy)
5161 
5162         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5163         self.add_patch(a)
5164         self._request_autoscale_view()
5165         return a
5166 
5167     @_docstring.copy(mquiver.QuiverKey.__init__)
5168     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5169         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5170         self.add_artist(qk)
5171         return qk
5172 
5173     # Handle units for x and y, if they've been passed
5174     def _quiver_units(self, args, kwargs):
5175         if len(args) > 3:
5176             x, y = args[0:2]
5177             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5178             return (x, y) + args[2:]
5179         return args
5180 
5181     # args can be a combination of X, Y, U, V, C and all should be replaced
5182     @_preprocess_data()
5183     @_docstring.dedent_interpd
5184     def quiver(self, *args, **kwargs):
5185         """%(quiver_doc)s"""
5186         # Make sure units are handled for x and y values
5187         args = self._quiver_units(args, kwargs)
5188         q = mquiver.Quiver(self, *args, **kwargs)
5189         self.add_collection(q, autolim=True)
5190         self._request_autoscale_view()
5191         return q
5192 
5193     # args can be some combination of X, Y, U, V, C and all should be replaced
5194     @_preprocess_data()
5195     @_docstring.dedent_interpd
5196     def barbs(self, *args, **kwargs):
5197         """%(barbs_doc)s"""
5198         # Make sure units are handled for x and y values
5199         args = self._quiver_units(args, kwargs)
5200         b = mquiver.Barbs(self, *args, **kwargs)
5201         self.add_collection(b, autolim=True)
5202         self._request_autoscale_view()
5203         return b
5204 
5205     # Uses a custom implementation of data-kwarg handling in
5206     # _process_plot_var_args.
5207     def fill(self, *args, data=None, **kwargs):
5208         """
5209         Plot filled polygons.
5210 
5211         Parameters
5212         ----------
5213         *args : sequence of x, y, [color]
5214             Each polygon is defined by the lists of *x* and *y* positions of
5215             its nodes, optionally followed by a *color* specifier. See
5216             :mod:`matplotlib.colors` for supported color specifiers. The
5217             standard color cycle is used for polygons without a color
5218             specifier.
5219 
5220             You can plot multiple polygons by providing multiple *x*, *y*,
5221             *[color]* groups.
5222 
5223             For example, each of the following is legal::
5224 
5225                 ax.fill(x, y)                    # a polygon with default color
5226                 ax.fill(x, y, "b")               # a blue polygon
5227                 ax.fill(x, y, x2, y2)            # two polygons
5228                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5229 
5230         data : indexable object, optional
5231             An object with labelled data. If given, provide the label names to
5232             plot in *x* and *y*, e.g.::
5233 
5234                 ax.fill("time", "signal",
5235                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5236 
5237         Returns
5238         -------
5239         list of `~matplotlib.patches.Polygon`
5240 
5241         Other Parameters
5242         ----------------
5243         **kwargs : `~matplotlib.patches.Polygon` properties
5244 
5245         Notes
5246         -----
5247         Use :meth:`fill_between` if you would like to fill the region between
5248         two curves.
5249         """
5250         # For compatibility(!), get aliases from Line2D rather than Patch.
5251         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5252         # _get_patches_for_fill returns a generator, convert it to a list.
5253         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5254         for poly in patches:
5255             self.add_patch(poly)
5256         self._request_autoscale_view()
5257         return patches
5258 
5259     def _fill_between_x_or_y(
5260             self, ind_dir, ind, dep1, dep2=0, *,
5261             where=None, interpolate=False, step=None, **kwargs):
5262         # Common implementation between fill_between (*ind_dir*="x") and
5263         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5264         # *dep* the dependent variable.  The docstring below is interpolated
5265         # to generate both methods' docstrings.
5266         """
5267         Fill the area between two {dir} curves.
5268 
5269         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5270         *{dep}2*).  This creates one or multiple polygons describing the filled
5271         area.
5272 
5273         You may exclude some {dir} sections from filling using *where*.
5274 
5275         By default, the edges connect the given points directly.  Use *step*
5276         if the filling should be a step function, i.e. constant in between
5277         *{ind}*.
5278 
5279         Parameters
5280         ----------
5281         {ind} : array (length N)
5282             The {ind} coordinates of the nodes defining the curves.
5283 
5284         {dep}1 : array (length N) or scalar
5285             The {dep} coordinates of the nodes defining the first curve.
5286 
5287         {dep}2 : array (length N) or scalar, default: 0
5288             The {dep} coordinates of the nodes defining the second curve.
5289 
5290         where : array of bool (length N), optional
5291             Define *where* to exclude some {dir} regions from being filled.
5292             The filled regions are defined by the coordinates ``{ind}[where]``.
5293             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5294             ``where[i] and where[i+1]``.  Note that this definition implies
5295             that an isolated *True* value between two *False* values in *where*
5296             will not result in filling.  Both sides of the *True* position
5297             remain unfilled due to the adjacent *False* values.
5298 
5299         interpolate : bool, default: False
5300             This option is only relevant if *where* is used and the two curves
5301             are crossing each other.
5302 
5303             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5304             similar.  By default, the nodes of the polygon defining the filled
5305             region will only be placed at the positions in the *{ind}* array.
5306             Such a polygon cannot describe the above semantics close to the
5307             intersection.  The {ind}-sections containing the intersection are
5308             simply clipped.
5309 
5310             Setting *interpolate* to *True* will calculate the actual
5311             intersection point and extend the filled region up to this point.
5312 
5313         step : {{'pre', 'post', 'mid'}}, optional
5314             Define *step* if the filling should be a step function,
5315             i.e. constant in between *{ind}*.  The value determines where the
5316             step will occur:
5317 
5318             - 'pre': The y value is continued constantly to the left from
5319               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5320               value ``y[i]``.
5321             - 'post': The y value is continued constantly to the right from
5322               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5323               value ``y[i]``.
5324             - 'mid': Steps occur half-way between the *x* positions.
5325 
5326         Returns
5327         -------
5328         `.PolyCollection`
5329             A `.PolyCollection` containing the plotted polygons.
5330 
5331         Other Parameters
5332         ----------------
5333         data : indexable object, optional
5334             DATA_PARAMETER_PLACEHOLDER
5335 
5336         **kwargs
5337             All other keyword arguments are passed on to `.PolyCollection`.
5338             They control the `.Polygon` properties:
5339 
5340             %(PolyCollection:kwdoc)s
5341 
5342         See Also
5343         --------
5344         fill_between : Fill between two sets of y-values.
5345         fill_betweenx : Fill between two sets of x-values.
5346         """
5347 
5348         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5349 
5350         if not mpl.rcParams["_internal.classic_mode"]:
5351             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5352             if not any(c in kwargs for c in ("color", "facecolor")):
5353                 kwargs["facecolor"] = \
5354                     self._get_patches_for_fill.get_next_color()
5355 
5356         # Handle united data, such as dates
5357         ind, dep1, dep2 = map(
5358             ma.masked_invalid, self._process_unit_info(
5359                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5360 
5361         for name, array in [
5362                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5363             if array.ndim > 1:
5364                 raise ValueError(f"{name!r} is not 1-dimensional")
5365 
5366         if where is None:
5367             where = True
5368         else:
5369             where = np.asarray(where, dtype=bool)
5370             if where.size != ind.size:
5371                 raise ValueError(f"where size ({where.size}) does not match "
5372                                  f"{ind_dir} size ({ind.size})")
5373         where = where & ~functools.reduce(
5374             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5375 
5376         ind, dep1, dep2 = np.broadcast_arrays(
5377             np.atleast_1d(ind), dep1, dep2, subok=True)
5378 
5379         polys = []
5380         for idx0, idx1 in cbook.contiguous_regions(where):
5381             indslice = ind[idx0:idx1]
5382             dep1slice = dep1[idx0:idx1]
5383             dep2slice = dep2[idx0:idx1]
5384             if step is not None:
5385                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5386                 indslice, dep1slice, dep2slice = \
5387                     step_func(indslice, dep1slice, dep2slice)
5388 
5389             if not len(indslice):
5390                 continue
5391 
5392             N = len(indslice)
5393             pts = np.zeros((2 * N + 2, 2))
5394 
5395             if interpolate:
5396                 def get_interp_point(idx):
5397                     im1 = max(idx - 1, 0)
5398                     ind_values = ind[im1:idx+1]
5399                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5400                     dep1_values = dep1[im1:idx+1]
5401 
5402                     if len(diff_values) == 2:
5403                         if np.ma.is_masked(diff_values[1]):
5404                             return ind[im1], dep1[im1]
5405                         elif np.ma.is_masked(diff_values[0]):
5406                             return ind[idx], dep1[idx]
5407 
5408                     diff_order = diff_values.argsort()
5409                     diff_root_ind = np.interp(
5410                         0, diff_values[diff_order], ind_values[diff_order])
5411                     ind_order = ind_values.argsort()
5412                     diff_root_dep = np.interp(
5413                         diff_root_ind,
5414                         ind_values[ind_order], dep1_values[ind_order])
5415                     return diff_root_ind, diff_root_dep
5416 
5417                 start = get_interp_point(idx0)
5418                 end = get_interp_point(idx1)
5419             else:
5420                 # Handle scalar dep2 (e.g. 0): the fill should go all
5421                 # the way down to 0 even if none of the dep1 sample points do.
5422                 start = indslice[0], dep2slice[0]
5423                 end = indslice[-1], dep2slice[-1]
5424 
5425             pts[0] = start
5426             pts[N + 1] = end
5427 
5428             pts[1:N+1, 0] = indslice
5429             pts[1:N+1, 1] = dep1slice
5430             pts[N+2:, 0] = indslice[::-1]
5431             pts[N+2:, 1] = dep2slice[::-1]
5432 
5433             if ind_dir == "y":
5434                 pts = pts[:, ::-1]
5435 
5436             polys.append(pts)
5437 
5438         collection = mcoll.PolyCollection(polys, **kwargs)
5439 
5440         # now update the datalim and autoscale
5441         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5442                             np.column_stack([ind[where], dep2[where]])])
5443         if ind_dir == "y":
5444             pts = pts[:, ::-1]
5445 
5446         up_x = up_y = True
5447         if "transform" in kwargs:
5448             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5449         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5450 
5451         self.add_collection(collection, autolim=False)
5452         self._request_autoscale_view()
5453         return collection
5454 
5455     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5456                      step=None, **kwargs):
5457         return self._fill_between_x_or_y(
5458             "x", x, y1, y2,
5459             where=where, interpolate=interpolate, step=step, **kwargs)
5460 
5461     if _fill_between_x_or_y.__doc__:
5462         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5463             dir="horizontal", ind="x", dep="y"
5464         )
5465     fill_between = _preprocess_data(
5466         _docstring.dedent_interpd(fill_between),
5467         replace_names=["x", "y1", "y2", "where"])
5468 
5469     def fill_betweenx(self, y, x1, x2=0, where=None,
5470                       step=None, interpolate=False, **kwargs):
5471         return self._fill_between_x_or_y(
5472             "y", y, x1, x2,
5473             where=where, interpolate=interpolate, step=step, **kwargs)
5474 
5475     if _fill_between_x_or_y.__doc__:
5476         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5477             dir="vertical", ind="y", dep="x"
5478         )
5479     fill_betweenx = _preprocess_data(
5480         _docstring.dedent_interpd(fill_betweenx),
5481         replace_names=["y", "x1", "x2", "where"])
5482 
5483     #### plotting z(x, y): imshow, pcolor and relatives, contour
5484 
5485     @_preprocess_data()
5486     @_docstring.interpd
5487     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5488                interpolation=None, alpha=None,
5489                vmin=None, vmax=None, origin=None, extent=None,
5490                interpolation_stage=None, filternorm=True, filterrad=4.0,
5491                resample=None, url=None, **kwargs):
5492         """
5493         Display data as an image, i.e., on a 2D regular raster.
5494 
5495         The input may either be actual RGB(A) data, or 2D scalar data, which
5496         will be rendered as a pseudocolor image. For displaying a grayscale
5497         image set up the colormapping using the parameters
5498         ``cmap='gray', vmin=0, vmax=255``.
5499 
5500         The number of pixels used to render an image is set by the Axes size
5501         and the *dpi* of the figure. This can lead to aliasing artifacts when
5502         the image is resampled because the displayed image size will usually
5503         not match the size of *X* (see
5504         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5505         The resampling can be controlled via the *interpolation* parameter
5506         and/or :rc:`image.interpolation`.
5507 
5508         Parameters
5509         ----------
5510         X : array-like or PIL image
5511             The image data. Supported array shapes are:
5512 
5513             - (M, N): an image with scalar data. The values are mapped to
5514               colors using normalization and a colormap. See parameters *norm*,
5515               *cmap*, *vmin*, *vmax*.
5516             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5517             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5518               i.e. including transparency.
5519 
5520             The first two dimensions (M, N) define the rows and columns of
5521             the image.
5522 
5523             Out-of-range RGB(A) values are clipped.
5524 
5525         %(cmap_doc)s
5526 
5527             This parameter is ignored if *X* is RGB(A).
5528 
5529         %(norm_doc)s
5530 
5531             This parameter is ignored if *X* is RGB(A).
5532 
5533         %(vmin_vmax_doc)s
5534 
5535             This parameter is ignored if *X* is RGB(A).
5536 
5537         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5538             The aspect ratio of the Axes.  This parameter is particularly
5539             relevant for images since it determines whether data pixels are
5540             square.
5541 
5542             This parameter is a shortcut for explicitly calling
5543             `.Axes.set_aspect`. See there for further details.
5544 
5545             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5546               (unless pixel sizes are explicitly made non-square in data
5547               coordinates using *extent*).
5548             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5549               that the data fit in the Axes. In general, this will result in
5550               non-square pixels.
5551 
5552         interpolation : str, default: :rc:`image.interpolation`
5553             The interpolation method used.
5554 
5555             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5556             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5557             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5558             'sinc', 'lanczos', 'blackman'.
5559 
5560             The data *X* is resampled to the pixel size of the image on the
5561             figure canvas, using the interpolation method to either up- or
5562             downsample the data.
5563 
5564             If *interpolation* is 'none', then for the ps, pdf, and svg
5565             backends no down- or upsampling occurs, and the image data is
5566             passed to the backend as a native image.  Note that different ps,
5567             pdf, and svg viewers may display these raw pixels differently. On
5568             other backends, 'none' is the same as 'nearest'.
5569 
5570             If *interpolation* is the default 'antialiased', then 'nearest'
5571             interpolation is used if the image is upsampled by more than a
5572             factor of three (i.e. the number of display pixels is at least
5573             three times the size of the data array).  If the upsampling rate is
5574             smaller than 3, or the image is downsampled, then 'hanning'
5575             interpolation is used to act as an anti-aliasing filter, unless the
5576             image happens to be upsampled by exactly a factor of two or one.
5577 
5578             See
5579             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5580             for an overview of the supported interpolation methods, and
5581             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5582             a discussion of image antialiasing.
5583 
5584             Some interpolation methods require an additional radius parameter,
5585             which can be set by *filterrad*. Additionally, the antigrain image
5586             resize filter is controlled by the parameter *filternorm*.
5587 
5588         interpolation_stage : {'data', 'rgba'}, default: 'data'
5589             If 'data', interpolation
5590             is carried out on the data provided by the user.  If 'rgba', the
5591             interpolation is carried out after the colormapping has been
5592             applied (visual interpolation).
5593 
5594         alpha : float or array-like, optional
5595             The alpha blending value, between 0 (transparent) and 1 (opaque).
5596             If *alpha* is an array, the alpha blending values are applied pixel
5597             by pixel, and *alpha* must have the same shape as *X*.
5598 
5599         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5600             Place the [0, 0] index of the array in the upper left or lower
5601             left corner of the Axes. The convention (the default) 'upper' is
5602             typically used for matrices and images.
5603 
5604             Note that the vertical axis points upward for 'lower'
5605             but downward for 'upper'.
5606 
5607             See the :ref:`imshow_extent` tutorial for
5608             examples and a more detailed description.
5609 
5610         extent : floats (left, right, bottom, top), optional
5611             The bounding box in data coordinates that the image will fill.
5612             These values may be unitful and match the units of the Axes.
5613             The image is stretched individually along x and y to fill the box.
5614 
5615             The default extent is determined by the following conditions.
5616             Pixels have unit size in data coordinates. Their centers are on
5617             integer coordinates, and their center coordinates range from 0 to
5618             columns-1 horizontally and from 0 to rows-1 vertically.
5619 
5620             Note that the direction of the vertical axis and thus the default
5621             values for top and bottom depend on *origin*:
5622 
5623             - For ``origin == 'upper'`` the default is
5624               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5625             - For ``origin == 'lower'`` the default is
5626               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5627 
5628             See the :ref:`imshow_extent` tutorial for
5629             examples and a more detailed description.
5630 
5631         filternorm : bool, default: True
5632             A parameter for the antigrain image resize filter (see the
5633             antigrain documentation).  If *filternorm* is set, the filter
5634             normalizes integer values and corrects the rounding errors. It
5635             doesn't do anything with the source floating point values, it
5636             corrects only integers according to the rule of 1.0 which means
5637             that any sum of pixel weights must be equal to 1.0.  So, the
5638             filter function must produce a graph of the proper shape.
5639 
5640         filterrad : float > 0, default: 4.0
5641             The filter radius for filters that have a radius parameter, i.e.
5642             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5643 
5644         resample : bool, default: :rc:`image.resample`
5645             When *True*, use a full resampling method.  When *False*, only
5646             resample when the output image is larger than the input image.
5647 
5648         url : str, optional
5649             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5650 
5651         Returns
5652         -------
5653         `~matplotlib.image.AxesImage`
5654 
5655         Other Parameters
5656         ----------------
5657         data : indexable object, optional
5658             DATA_PARAMETER_PLACEHOLDER
5659 
5660         **kwargs : `~matplotlib.artist.Artist` properties
5661             These parameters are passed on to the constructor of the
5662             `.AxesImage` artist.
5663 
5664         See Also
5665         --------
5666         matshow : Plot a matrix or an array as an image.
5667 
5668         Notes
5669         -----
5670         Unless *extent* is used, pixel centers will be located at integer
5671         coordinates. In other words: the origin will coincide with the center
5672         of pixel (0, 0).
5673 
5674         There are two common representations for RGB images with an alpha
5675         channel:
5676 
5677         -   Straight (unassociated) alpha: R, G, and B channels represent the
5678             color of the pixel, disregarding its opacity.
5679         -   Premultiplied (associated) alpha: R, G, and B channels represent
5680             the color of the pixel, adjusted for its opacity by multiplication.
5681 
5682         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5683         (unassociated) alpha representation.
5684         """
5685         if aspect is None:
5686             aspect = mpl.rcParams['image.aspect']
5687         self.set_aspect(aspect)
5688         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5689                               interpolation=interpolation, origin=origin,
5690                               extent=extent, filternorm=filternorm,
5691                               filterrad=filterrad, resample=resample,
5692                               interpolation_stage=interpolation_stage,
5693                               **kwargs)
5694 
5695         im.set_data(X)
5696         im.set_alpha(alpha)
5697         if im.get_clip_path() is None:
5698             # image does not already have clipping set, clip to axes patch
5699             im.set_clip_path(self.patch)
5700         im._scale_norm(norm, vmin, vmax)
5701         im.set_url(url)
5702 
5703         # update ax.dataLim, and, if autoscaling, set viewLim
5704         # to tightly fit the image, regardless of dataLim.
5705         im.set_extent(im.get_extent())
5706 
5707         self.add_image(im)
5708         return im
5709 
5710     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5711         # - create X and Y if not present;
5712         # - reshape X and Y as needed if they are 1-D;
5713         # - check for proper sizes based on `shading` kwarg;
5714         # - reset shading if shading='auto' to flat or nearest
5715         #   depending on size;
5716 
5717         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5718         try:
5719             _api.check_in_list(_valid_shading, shading=shading)
5720         except ValueError:
5721             _api.warn_external(f"shading value '{shading}' not in list of "
5722                                f"valid values {_valid_shading}. Setting "
5723                                "shading='auto'.")
5724             shading = 'auto'
5725 
5726         if len(args) == 1:
5727             C = np.asanyarray(args[0])
5728             nrows, ncols = C.shape[:2]
5729             if shading in ['gouraud', 'nearest']:
5730                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5731             else:
5732                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5733                 shading = 'flat'
5734             C = cbook.safe_masked_invalid(C)
5735             return X, Y, C, shading
5736 
5737         if len(args) == 3:
5738             # Check x and y for bad data...
5739             C = np.asanyarray(args[2])
5740             # unit conversion allows e.g. datetime objects as axis values
5741             X, Y = args[:2]
5742             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5743             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5744 
5745             if funcname == 'pcolormesh':
5746                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5747                     raise ValueError(
5748                         'x and y arguments to pcolormesh cannot have '
5749                         'non-finite values or be of type '
5750                         'numpy.ma.core.MaskedArray with masked values')
5751                 # safe_masked_invalid() returns an ndarray for dtypes other
5752                 # than floating point.
5753                 if isinstance(X, np.ma.core.MaskedArray):
5754                     X = X.data  # strip mask as downstream doesn't like it...
5755                 if isinstance(Y, np.ma.core.MaskedArray):
5756                     Y = Y.data
5757             nrows, ncols = C.shape[:2]
5758         else:
5759             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5760 
5761         Nx = X.shape[-1]
5762         Ny = Y.shape[0]
5763         if X.ndim != 2 or X.shape[0] == 1:
5764             x = X.reshape(1, Nx)
5765             X = x.repeat(Ny, axis=0)
5766         if Y.ndim != 2 or Y.shape[1] == 1:
5767             y = Y.reshape(Ny, 1)
5768             Y = y.repeat(Nx, axis=1)
5769         if X.shape != Y.shape:
5770             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5771                             f'see help({funcname})')
5772 
5773         if shading == 'auto':
5774             if ncols == Nx and nrows == Ny:
5775                 shading = 'nearest'
5776             else:
5777                 shading = 'flat'
5778 
5779         if shading == 'flat':
5780             if (Nx, Ny) != (ncols + 1, nrows + 1):
5781                 raise TypeError(f"Dimensions of C {C.shape} should"
5782                                 f" be one smaller than X({Nx}) and Y({Ny})"
5783                                 f" while using shading='flat'"
5784                                 f" see help({funcname})")
5785         else:    # ['nearest', 'gouraud']:
5786             if (Nx, Ny) != (ncols, nrows):
5787                 raise TypeError('Dimensions of C %s are incompatible with'
5788                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5789                                     C.shape, Nx, Ny, funcname))
5790             if shading == 'nearest':
5791                 # grid is specified at the center, so define corners
5792                 # at the midpoints between the grid centers and then use the
5793                 # flat algorithm.
5794                 def _interp_grid(X):
5795                     # helper for below
5796                     if np.shape(X)[1] > 1:
5797                         dX = np.diff(X, axis=1)/2.
5798                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5799                             _api.warn_external(
5800                                 f"The input coordinates to {funcname} are "
5801                                 "interpreted as cell centers, but are not "
5802                                 "monotonically increasing or decreasing. "
5803                                 "This may lead to incorrectly calculated cell "
5804                                 "edges, in which case, please supply "
5805                                 f"explicit cell edges to {funcname}.")
5806                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5807                                        X[:, :-1] + dX,
5808                                        X[:, [-1]] + dX[:, [-1]]))
5809                     else:
5810                         # This is just degenerate, but we can't reliably guess
5811                         # a dX if there is just one value.
5812                         X = np.hstack((X, X))
5813                     return X
5814 
5815                 if ncols == Nx:
5816                     X = _interp_grid(X)
5817                     Y = _interp_grid(Y)
5818                 if nrows == Ny:
5819                     X = _interp_grid(X.T).T
5820                     Y = _interp_grid(Y.T).T
5821                 shading = 'flat'
5822 
5823         C = cbook.safe_masked_invalid(C)
5824         return X, Y, C, shading
5825 
5826     @_preprocess_data()
5827     @_docstring.dedent_interpd
5828     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5829                vmin=None, vmax=None, **kwargs):
5830         r"""
5831         Create a pseudocolor plot with a non-regular rectangular grid.
5832 
5833         Call signature::
5834 
5835             pcolor([X, Y,] C, **kwargs)
5836 
5837         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5838 
5839         .. hint::
5840 
5841             ``pcolor()`` can be very slow for large arrays. In most
5842             cases you should use the similar but much faster
5843             `~.Axes.pcolormesh` instead. See
5844             :ref:`Differences between pcolor() and pcolormesh()
5845             <differences-pcolor-pcolormesh>` for a discussion of the
5846             differences.
5847 
5848         Parameters
5849         ----------
5850         C : 2D array-like
5851             The color-mapped values.  Color-mapping is controlled by *cmap*,
5852             *norm*, *vmin*, and *vmax*.
5853 
5854         X, Y : array-like, optional
5855             The coordinates of the corners of quadrilaterals of a pcolormesh::
5856 
5857                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5858                                       ●╶───╴●
5859                                       │     │
5860                                       ●╶───╴●
5861                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5862 
5863             Note that the column index corresponds to the x-coordinate, and
5864             the row index corresponds to y. For details, see the
5865             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5866 
5867             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5868             greater than those of *C*, and the quadrilateral is colored due
5869             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5870             dimensions, a warning will be raised and the last row and column
5871             of *C* will be ignored.
5872 
5873             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5874             the same as those of *C* (if not, a ValueError will be raised). The
5875             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5876 
5877             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5878             expanded as needed into the appropriate 2D arrays, making a
5879             rectangular grid.
5880 
5881         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5882             The fill style for the quadrilateral. Possible values:
5883 
5884             - 'flat': A solid color is used for each quad. The color of the
5885               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5886               ``C[i, j]``. The dimensions of *X* and *Y* should be
5887               one greater than those of *C*; if they are the same as *C*,
5888               then a deprecation warning is raised, and the last row
5889               and column of *C* are dropped.
5890             - 'nearest': Each grid point will have a color centered on it,
5891               extending halfway between the adjacent grid centers.  The
5892               dimensions of *X* and *Y* must be the same as *C*.
5893             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5894               larger than *C*.  Choose 'nearest' if dimensions are the same.
5895 
5896             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5897             for more description.
5898 
5899         %(cmap_doc)s
5900 
5901         %(norm_doc)s
5902 
5903         %(vmin_vmax_doc)s
5904 
5905         edgecolors : {'none', None, 'face', color, color sequence}, optional
5906             The color of the edges. Defaults to 'none'. Possible values:
5907 
5908             - 'none' or '': No edge.
5909             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5910               :rc:`patch.force_edgecolor` has to be True for this to work.
5911             - 'face': Use the adjacent face color.
5912             - A color or sequence of colors will set the edge color.
5913 
5914             The singular form *edgecolor* works as an alias.
5915 
5916         alpha : float, default: None
5917             The alpha blending value of the face color, between 0 (transparent)
5918             and 1 (opaque). Note: The edgecolor is currently not affected by
5919             this.
5920 
5921         snap : bool, default: False
5922             Whether to snap the mesh to pixel boundaries.
5923 
5924         Returns
5925         -------
5926         `matplotlib.collections.Collection`
5927 
5928         Other Parameters
5929         ----------------
5930         antialiaseds : bool, default: False
5931             The default *antialiaseds* is False if the default
5932             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5933             at patch boundaries, and works regardless of the value of alpha.
5934             If *edgecolors* is not "none", then the default *antialiaseds*
5935             is taken from :rc:`patch.antialiased`.
5936             Stroking the edges may be preferred if *alpha* is 1, but will
5937             cause artifacts otherwise.
5938 
5939         data : indexable object, optional
5940             DATA_PARAMETER_PLACEHOLDER
5941 
5942         **kwargs
5943             Additionally, the following arguments are allowed. They are passed
5944             along to the `~matplotlib.collections.PolyCollection` constructor:
5945 
5946         %(PolyCollection:kwdoc)s
5947 
5948         See Also
5949         --------
5950         pcolormesh : for an explanation of the differences between
5951             pcolor and pcolormesh.
5952         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5953             faster alternative.
5954 
5955         Notes
5956         -----
5957         **Masked arrays**
5958 
5959         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5960         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5961         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5962         plotted.
5963 
5964         .. _axes-pcolor-grid-orientation:
5965 
5966         **Grid orientation**
5967 
5968         The grid orientation follows the standard matrix convention: An array
5969         *C* with shape (nrows, ncolumns) is plotted with the column number as
5970         *X* and the row number as *Y*.
5971         """
5972 
5973         if shading is None:
5974             shading = mpl.rcParams['pcolor.shading']
5975         shading = shading.lower()
5976         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5977                                             kwargs=kwargs)
5978         Ny, Nx = X.shape
5979 
5980         # convert to MA, if necessary.
5981         C = ma.asarray(C)
5982         X = ma.asarray(X)
5983         Y = ma.asarray(Y)
5984 
5985         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5986         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5987                   mask[0:-1, 1:] + mask[1:, 0:-1])
5988         # don't plot if C or any of the surrounding vertices are masked.
5989         mask = ma.getmaskarray(C) + xymask
5990 
5991         unmask = ~mask
5992         X1 = ma.filled(X[:-1, :-1])[unmask]
5993         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5994         X2 = ma.filled(X[1:, :-1])[unmask]
5995         Y2 = ma.filled(Y[1:, :-1])[unmask]
5996         X3 = ma.filled(X[1:, 1:])[unmask]
5997         Y3 = ma.filled(Y[1:, 1:])[unmask]
5998         X4 = ma.filled(X[:-1, 1:])[unmask]
5999         Y4 = ma.filled(Y[:-1, 1:])[unmask]
6000         npoly = len(X1)
6001 
6002         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
6003         verts = xy.reshape((npoly, 5, 2))
6004 
6005         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
6006 
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiased' in kwargs:
6021             kwargs['antialiaseds'] = kwargs.pop('antialiased')
6022         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiaseds'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         collection = mcoll.PolyCollection(
6028             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6029         collection._scale_norm(norm, vmin, vmax)
6030 
6031         x = X.compressed()
6032         y = Y.compressed()
6033 
6034         # Transform from native to data coordinates?
6035         t = collection._transform
6036         if (not isinstance(t, mtransforms.Transform) and
6037                 hasattr(t, '_as_mpl_transform')):
6038             t = t._as_mpl_transform(self.axes)
6039 
6040         if t and any(t.contains_branch_seperately(self.transData)):
6041             trans_to_data = t - self.transData
6042             pts = np.vstack([x, y]).T.astype(float)
6043             transformed_pts = trans_to_data.transform(pts)
6044             x = transformed_pts[..., 0]
6045             y = transformed_pts[..., 1]
6046 
6047         self.add_collection(collection, autolim=False)
6048 
6049         minx = np.min(x)
6050         maxx = np.max(x)
6051         miny = np.min(y)
6052         maxy = np.max(y)
6053         collection.sticky_edges.x[:] = [minx, maxx]
6054         collection.sticky_edges.y[:] = [miny, maxy]
6055         corners = (minx, miny), (maxx, maxy)
6056         self.update_datalim(corners)
6057         self._request_autoscale_view()
6058         return collection
6059 
6060     @_preprocess_data()
6061     @_docstring.dedent_interpd
6062     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6063                    vmax=None, shading=None, antialiased=False, **kwargs):
6064         """
6065         Create a pseudocolor plot with a non-regular rectangular grid.
6066 
6067         Call signature::
6068 
6069             pcolormesh([X, Y,] C, **kwargs)
6070 
6071         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6072 
6073         .. hint::
6074 
6075            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6076            and preferred in most cases. For a detailed discussion on the
6077            differences see :ref:`Differences between pcolor() and pcolormesh()
6078            <differences-pcolor-pcolormesh>`.
6079 
6080         Parameters
6081         ----------
6082         C : array-like
6083             The mesh data. Supported array shapes are:
6084 
6085             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6086               colors using normalization and a colormap. See parameters *norm*,
6087               *cmap*, *vmin*, *vmax*.
6088             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6089             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6090               i.e. including transparency.
6091 
6092             The first two dimensions (M, N) define the rows and columns of
6093             the mesh data.
6094 
6095         X, Y : array-like, optional
6096             The coordinates of the corners of quadrilaterals of a pcolormesh::
6097 
6098                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6099                                       ●╶───╴●
6100                                       │     │
6101                                       ●╶───╴●
6102                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6103 
6104             Note that the column index corresponds to the x-coordinate, and
6105             the row index corresponds to y. For details, see the
6106             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6107 
6108             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6109             greater than those of *C*, and the quadrilateral is colored due
6110             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6111             dimensions, a warning will be raised and the last row and column
6112             of *C* will be ignored.
6113 
6114             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6115             and *Y* should be the same as those of *C* (if not, a ValueError
6116             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6117             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6118             interpolation is caried out between the quadrilateral corners.
6119 
6120             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6121             expanded as needed into the appropriate 2D arrays, making a
6122             rectangular grid.
6123 
6124         %(cmap_doc)s
6125 
6126         %(norm_doc)s
6127 
6128         %(vmin_vmax_doc)s
6129 
6130         edgecolors : {'none', None, 'face', color, color sequence}, optional
6131             The color of the edges. Defaults to 'none'. Possible values:
6132 
6133             - 'none' or '': No edge.
6134             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6135               :rc:`patch.force_edgecolor` has to be True for this to work.
6136             - 'face': Use the adjacent face color.
6137             - A color or sequence of colors will set the edge color.
6138 
6139             The singular form *edgecolor* works as an alias.
6140 
6141         alpha : float, default: None
6142             The alpha blending value, between 0 (transparent) and 1 (opaque).
6143 
6144         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6145             The fill style for the quadrilateral; defaults to
6146             :rc:`pcolor.shading`. Possible values:
6147 
6148             - 'flat': A solid color is used for each quad. The color of the
6149               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6150               ``C[i, j]``. The dimensions of *X* and *Y* should be
6151               one greater than those of *C*; if they are the same as *C*,
6152               then a deprecation warning is raised, and the last row
6153               and column of *C* are dropped.
6154             - 'nearest': Each grid point will have a color centered on it,
6155               extending halfway between the adjacent grid centers.  The
6156               dimensions of *X* and *Y* must be the same as *C*.
6157             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6158               corners (i', j') are given by ``C[i', j']``. The color values of
6159               the area in between is interpolated from the corner values.
6160               The dimensions of *X* and *Y* must be the same as *C*. When
6161               Gouraud shading is used, *edgecolors* is ignored.
6162             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6163               larger than *C*.  Choose 'nearest' if dimensions are the same.
6164 
6165             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6166             for more description.
6167 
6168         snap : bool, default: False
6169             Whether to snap the mesh to pixel boundaries.
6170 
6171         rasterized : bool, optional
6172             Rasterize the pcolormesh when drawing vector graphics.  This can
6173             speed up rendering and produce smaller files for large data sets.
6174             See also :doc:`/gallery/misc/rasterization_demo`.
6175 
6176         Returns
6177         -------
6178         `matplotlib.collections.QuadMesh`
6179 
6180         Other Parameters
6181         ----------------
6182         data : indexable object, optional
6183             DATA_PARAMETER_PLACEHOLDER
6184 
6185         **kwargs
6186             Additionally, the following arguments are allowed. They are passed
6187             along to the `~matplotlib.collections.QuadMesh` constructor:
6188 
6189         %(QuadMesh:kwdoc)s
6190 
6191         See Also
6192         --------
6193         pcolor : An alternative implementation with slightly different
6194             features. For a detailed discussion on the differences see
6195             :ref:`Differences between pcolor() and pcolormesh()
6196             <differences-pcolor-pcolormesh>`.
6197         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6198             faster alternative.
6199 
6200         Notes
6201         -----
6202         **Masked arrays**
6203 
6204         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6205         quadrilateral will be transparent. Masking of *X* and *Y* is not
6206         supported. Use `~.Axes.pcolor` if you need this functionality.
6207 
6208         .. _axes-pcolormesh-grid-orientation:
6209 
6210         **Grid orientation**
6211 
6212         The grid orientation follows the standard matrix convention: An array
6213         *C* with shape (nrows, ncolumns) is plotted with the column number as
6214         *X* and the row number as *Y*.
6215 
6216         .. _differences-pcolor-pcolormesh:
6217 
6218         **Differences between pcolor() and pcolormesh()**
6219 
6220         Both methods are used to create a pseudocolor plot of a 2D array
6221         using quadrilaterals.
6222 
6223         The main difference lies in the created object and internal data
6224         handling:
6225         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6226         returns a `.QuadMesh`. The latter is more specialized for the given
6227         purpose and thus is faster. It should almost always be preferred.
6228 
6229         There is also a slight difference in the handling of masked arrays.
6230         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6231         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6232         and *Y*. The reason lies in the internal handling of the masked values.
6233         `~.Axes.pcolor` leaves out the respective polygons from the
6234         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6235         elements to transparent. You can see the difference when using
6236         edgecolors. While all edges are drawn irrespective of masking in a
6237         QuadMesh, the edge between two adjacent masked quadrilaterals in
6238         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6239         exist in the PolyCollection.
6240 
6241         Another difference is the support of Gouraud shading in
6242         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6243 
6244         """
6245         if shading is None:
6246             shading = mpl.rcParams['pcolor.shading']
6247         shading = shading.lower()
6248         kwargs.setdefault('edgecolors', 'none')
6249 
6250         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6251                                             shading=shading, kwargs=kwargs)
6252         coords = np.stack([X, Y], axis=-1)
6253 
6254         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6255 
6256         collection = mcoll.QuadMesh(
6257             coords, antialiased=antialiased, shading=shading,
6258             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6259         collection._scale_norm(norm, vmin, vmax)
6260 
6261         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6262 
6263         # Transform from native to data coordinates?
6264         t = collection._transform
6265         if (not isinstance(t, mtransforms.Transform) and
6266                 hasattr(t, '_as_mpl_transform')):
6267             t = t._as_mpl_transform(self.axes)
6268 
6269         if t and any(t.contains_branch_seperately(self.transData)):
6270             trans_to_data = t - self.transData
6271             coords = trans_to_data.transform(coords)
6272 
6273         self.add_collection(collection, autolim=False)
6274 
6275         minx, miny = np.min(coords, axis=0)
6276         maxx, maxy = np.max(coords, axis=0)
6277         collection.sticky_edges.x[:] = [minx, maxx]
6278         collection.sticky_edges.y[:] = [miny, maxy]
6279         corners = (minx, miny), (maxx, maxy)
6280         self.update_datalim(corners)
6281         self._request_autoscale_view()
6282         return collection
6283 
6284     @_preprocess_data()
6285     @_docstring.dedent_interpd
6286     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6287                    vmax=None, **kwargs):
6288         """
6289         Create a pseudocolor plot with a non-regular rectangular grid.
6290 
6291         Call signature::
6292 
6293           ax.pcolorfast([X, Y], C, /, **kwargs)
6294 
6295         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6296         It's designed to provide the fastest pcolor-type plotting with the
6297         Agg backend. To achieve this, it uses different algorithms internally
6298         depending on the complexity of the input grid (regular rectangular,
6299         non-regular rectangular or arbitrary quadrilateral).
6300 
6301         .. warning::
6302 
6303            This method is experimental. Compared to `~.Axes.pcolor` or
6304            `~.Axes.pcolormesh` it has some limitations:
6305 
6306            - It supports only flat shading (no outlines)
6307            - It lacks support for log scaling of the axes.
6308            - It does not have a pyplot wrapper.
6309 
6310         Parameters
6311         ----------
6312         C : array-like
6313             The image data. Supported array shapes are:
6314 
6315             - (M, N): an image with scalar data.  Color-mapping is controlled
6316               by *cmap*, *norm*, *vmin*, and *vmax*.
6317             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6318             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6319               i.e. including transparency.
6320 
6321             The first two dimensions (M, N) define the rows and columns of
6322             the image.
6323 
6324             This parameter can only be passed positionally.
6325 
6326         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6327             *X* and *Y* are used to specify the coordinates of the
6328             quadrilaterals. There are different ways to do this:
6329 
6330             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6331               a *uniform rectangular grid*.
6332 
6333               The tuples define the outer edges of the grid. All individual
6334               quadrilaterals will be of the same size. This is the fastest
6335               version.
6336 
6337             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6338               grid*.
6339 
6340               In this case *X* and *Y* have to be monotonic 1D arrays of length
6341               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6342 
6343               The speed is intermediate. Note: The grid is checked, and if
6344               found to be uniform the fast version is used.
6345 
6346             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6347               grid* (i.e. if the quadrilaterals are not rectangular).
6348 
6349               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6350               specifying the x and y coordinates of the corners of the colored
6351               quadrilaterals.
6352 
6353               This is the most general, but the slowest to render.  It may
6354               produce faster and more compact output using ps, pdf, and
6355               svg backends, however.
6356 
6357             These arguments can only be passed positionally.
6358 
6359         %(cmap_doc)s
6360 
6361             This parameter is ignored if *C* is RGB(A).
6362 
6363         %(norm_doc)s
6364 
6365             This parameter is ignored if *C* is RGB(A).
6366 
6367         %(vmin_vmax_doc)s
6368 
6369             This parameter is ignored if *C* is RGB(A).
6370 
6371         alpha : float, default: None
6372             The alpha blending value, between 0 (transparent) and 1 (opaque).
6373 
6374         snap : bool, default: False
6375             Whether to snap the mesh to pixel boundaries.
6376 
6377         Returns
6378         -------
6379         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6380             The return type depends on the type of grid:
6381 
6382             - `.AxesImage` for a regular rectangular grid.
6383             - `.PcolorImage` for a non-regular rectangular grid.
6384             - `.QuadMesh` for a non-rectangular grid.
6385 
6386         Other Parameters
6387         ----------------
6388         data : indexable object, optional
6389             DATA_PARAMETER_PLACEHOLDER
6390 
6391         **kwargs
6392             Supported additional parameters depend on the type of grid.
6393             See return types of *image* for further description.
6394         """
6395 
6396         C = args[-1]
6397         nr, nc = np.shape(C)[:2]
6398         if len(args) == 1:
6399             style = "image"
6400             x = [0, nc]
6401             y = [0, nr]
6402         elif len(args) == 3:
6403             x, y = args[:2]
6404             x = np.asarray(x)
6405             y = np.asarray(y)
6406             if x.ndim == 1 and y.ndim == 1:
6407                 if x.size == 2 and y.size == 2:
6408                     style = "image"
6409                 else:
6410                     dx = np.diff(x)
6411                     dy = np.diff(y)
6412                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6413                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6414                         style = "image"
6415                     else:
6416                         style = "pcolorimage"
6417             elif x.ndim == 2 and y.ndim == 2:
6418                 style = "quadmesh"
6419             else:
6420                 raise TypeError("arguments do not match valid signatures")
6421         else:
6422             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6423 
6424         if style == "quadmesh":
6425             # data point in each cell is value at lower left corner
6426             coords = np.stack([x, y], axis=-1)
6427             if np.ndim(C) not in {2, 3}:
6428                 raise ValueError("C must be 2D or 3D")
6429             collection = mcoll.QuadMesh(
6430                 coords, array=C,
6431                 alpha=alpha, cmap=cmap, norm=norm,
6432                 antialiased=False, edgecolors="none")
6433             self.add_collection(collection, autolim=False)
6434             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6435             ret = collection
6436 
6437         else:  # It's one of the two image styles.
6438             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6439             if style == "image":
6440                 im = mimage.AxesImage(
6441                     self, cmap=cmap, norm=norm,
6442                     data=C, alpha=alpha, extent=extent,
6443                     interpolation='nearest', origin='lower',
6444                     **kwargs)
6445             elif style == "pcolorimage":
6446                 im = mimage.PcolorImage(
6447                     self, x, y, C,
6448                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6449                     **kwargs)
6450             self.add_image(im)
6451             ret = im
6452 
6453         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6454             ret._scale_norm(norm, vmin, vmax)
6455 
6456         if ret.get_clip_path() is None:
6457             # image does not already have clipping set, clip to axes patch
6458             ret.set_clip_path(self.patch)
6459 
6460         ret.sticky_edges.x[:] = [xl, xr]
6461         ret.sticky_edges.y[:] = [yb, yt]
6462         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6463         self._request_autoscale_view(tight=True)
6464         return ret
6465 
6466     @_preprocess_data()
6467     @_docstring.dedent_interpd
6468     def contour(self, *args, **kwargs):
6469         """
6470         Plot contour lines.
6471 
6472         Call signature::
6473 
6474             contour([X, Y,] Z, [levels], **kwargs)
6475         %(contour_doc)s
6476         """
6477         kwargs['filled'] = False
6478         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6479         self._request_autoscale_view()
6480         return contours
6481 
6482     @_preprocess_data()
6483     @_docstring.dedent_interpd
6484     def contourf(self, *args, **kwargs):
6485         """
6486         Plot filled contours.
6487 
6488         Call signature::
6489 
6490             contourf([X, Y,] Z, [levels], **kwargs)
6491         %(contour_doc)s
6492         """
6493         kwargs['filled'] = True
6494         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6495         self._request_autoscale_view()
6496         return contours
6497 
6498     def clabel(self, CS, levels=None, **kwargs):
6499         """
6500         Label a contour plot.
6501 
6502         Adds labels to line contours in given `.ContourSet`.
6503 
6504         Parameters
6505         ----------
6506         CS : `.ContourSet` instance
6507             Line contours to label.
6508 
6509         levels : array-like, optional
6510             A list of level values, that should be labeled. The list must be
6511             a subset of ``CS.levels``. If not given, all levels are labeled.
6512 
6513         **kwargs
6514             All other parameters are documented in `~.ContourLabeler.clabel`.
6515         """
6516         return CS.clabel(levels, **kwargs)
6517 
6518     #### Data analysis
6519 
6520     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6521     def hist(self, x, bins=None, range=None, density=False, weights=None,
6522              cumulative=False, bottom=None, histtype='bar', align='mid',
6523              orientation='vertical', rwidth=None, log=False,
6524              color=None, label=None, stacked=False, **kwargs):
6525         """
6526         Compute and plot a histogram.
6527 
6528         This method uses `numpy.histogram` to bin the data in *x* and count the
6529         number of values in each bin, then draws the distribution either as a
6530         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6531         *weights* parameters are forwarded to `numpy.histogram`.
6532 
6533         If the data has already been binned and counted, use `~.bar` or
6534         `~.stairs` to plot the distribution::
6535 
6536             counts, bins = np.histogram(x)
6537             plt.stairs(counts, bins)
6538 
6539         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6540         treating each bin as a single point with a weight equal to its count::
6541 
6542             plt.hist(bins[:-1], bins, weights=counts)
6543 
6544         The data input *x* can be a singular array, a list of datasets of
6545         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6546         which each column is a dataset. Note that the ndarray form is
6547         transposed relative to the list form. If the input is an array, then
6548         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6549         sequence of arrays, then the return value is a tuple
6550         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6551 
6552         Masked arrays are not supported.
6553 
6554         Parameters
6555         ----------
6556         x : (n,) array or sequence of (n,) arrays
6557             Input values, this takes either a single array or a sequence of
6558             arrays which are not required to be of the same length.
6559 
6560         bins : int or sequence or str, default: :rc:`hist.bins`
6561             If *bins* is an integer, it defines the number of equal-width bins
6562             in the range.
6563 
6564             If *bins* is a sequence, it defines the bin edges, including the
6565             left edge of the first bin and the right edge of the last bin;
6566             in this case, bins may be unequally spaced.  All but the last
6567             (righthand-most) bin is half-open.  In other words, if *bins* is::
6568 
6569                 [1, 2, 3, 4]
6570 
6571             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6572             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6573             *includes* 4.
6574 
6575             If *bins* is a string, it is one of the binning strategies
6576             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6577             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6578 
6579         range : tuple or None, default: None
6580             The lower and upper range of the bins. Lower and upper outliers
6581             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6582             Range has no effect if *bins* is a sequence.
6583 
6584             If *bins* is a sequence or *range* is specified, autoscaling
6585             is based on the specified bin range instead of the
6586             range of x.
6587 
6588         density : bool, default: False
6589             If ``True``, draw and return a probability density: each bin
6590             will display the bin's raw count divided by the total number of
6591             counts *and the bin width*
6592             (``density = counts / (sum(counts) * np.diff(bins))``),
6593             so that the area under the histogram integrates to 1
6594             (``np.sum(density * np.diff(bins)) == 1``).
6595 
6596             If *stacked* is also ``True``, the sum of the histograms is
6597             normalized to 1.
6598 
6599         weights : (n,) array-like or None, default: None
6600             An array of weights, of the same shape as *x*.  Each value in
6601             *x* only contributes its associated weight towards the bin count
6602             (instead of 1).  If *density* is ``True``, the weights are
6603             normalized, so that the integral of the density over the range
6604             remains 1.
6605 
6606         cumulative : bool or -1, default: False
6607             If ``True``, then a histogram is computed where each bin gives the
6608             counts in that bin plus all bins for smaller values. The last bin
6609             gives the total number of datapoints.
6610 
6611             If *density* is also ``True`` then the histogram is normalized such
6612             that the last bin equals 1.
6613 
6614             If *cumulative* is a number less than 0 (e.g., -1), the direction
6615             of accumulation is reversed.  In this case, if *density* is also
6616             ``True``, then the histogram is normalized such that the first bin
6617             equals 1.
6618 
6619         bottom : array-like, scalar, or None, default: None
6620             Location of the bottom of each bin, i.e. bins are drawn from
6621             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6622             of each bin is shifted by the same amount. If an array, each bin
6623             is shifted independently and the length of bottom must match the
6624             number of bins. If None, defaults to 0.
6625 
6626         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6627             The type of histogram to draw.
6628 
6629             - 'bar' is a traditional bar-type histogram.  If multiple data
6630               are given the bars are arranged side by side.
6631             - 'barstacked' is a bar-type histogram where multiple
6632               data are stacked on top of each other.
6633             - 'step' generates a lineplot that is by default unfilled.
6634             - 'stepfilled' generates a lineplot that is by default filled.
6635 
6636         align : {'left', 'mid', 'right'}, default: 'mid'
6637             The horizontal alignment of the histogram bars.
6638 
6639             - 'left': bars are centered on the left bin edges.
6640             - 'mid': bars are centered between the bin edges.
6641             - 'right': bars are centered on the right bin edges.
6642 
6643         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6644             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6645             and the *bottom* kwarg will be the left edges.
6646 
6647         rwidth : float or None, default: None
6648             The relative width of the bars as a fraction of the bin width.  If
6649             ``None``, automatically compute the width.
6650 
6651             Ignored if *histtype* is 'step' or 'stepfilled'.
6652 
6653         log : bool, default: False
6654             If ``True``, the histogram axis will be set to a log scale.
6655 
6656         color : color or array-like of colors or None, default: None
6657             Color or sequence of colors, one per dataset.  Default (``None``)
6658             uses the standard line color sequence.
6659 
6660         label : str or None, default: None
6661             String, or sequence of strings to match multiple datasets.  Bar
6662             charts yield multiple patches per dataset, but only the first gets
6663             the label, so that `~.Axes.legend` will work as expected.
6664 
6665         stacked : bool, default: False
6666             If ``True``, multiple data are stacked on top of each other If
6667             ``False`` multiple data are arranged side by side if histtype is
6668             'bar' or on top of each other if histtype is 'step'
6669 
6670         Returns
6671         -------
6672         n : array or list of arrays
6673             The values of the histogram bins. See *density* and *weights* for a
6674             description of the possible semantics.  If input *x* is an array,
6675             then this is an array of length *nbins*. If input is a sequence of
6676             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6677             the values of the histograms for each of the arrays in the same
6678             order.  The dtype of the array *n* (or of its element arrays) will
6679             always be float even if no weighting or normalization is used.
6680 
6681         bins : array
6682             The edges of the bins. Length nbins + 1 (nbins left edges and right
6683             edge of last bin).  Always a single array even when multiple data
6684             sets are passed in.
6685 
6686         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6687 such objects
6688             Container of individual artists used to create the histogram
6689             or list of such containers if there are multiple input datasets.
6690 
6691         Other Parameters
6692         ----------------
6693         data : indexable object, optional
6694             DATA_PARAMETER_PLACEHOLDER
6695 
6696         **kwargs
6697             `~matplotlib.patches.Patch` properties
6698 
6699         See Also
6700         --------
6701         hist2d : 2D histogram with rectangular bins
6702         hexbin : 2D histogram with hexagonal bins
6703         stairs : Plot a pre-computed histogram
6704         bar : Plot a pre-computed histogram
6705 
6706         Notes
6707         -----
6708         For large numbers of bins (>1000), plotting can be significantly
6709         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6710         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6711         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6712         """
6713         # Avoid shadowing the builtin.
6714         bin_range = range
6715         from builtins import range
6716 
6717         if np.isscalar(x):
6718             x = [x]
6719 
6720         if bins is None:
6721             bins = mpl.rcParams['hist.bins']
6722 
6723         # Validate string inputs here to avoid cluttering subsequent code.
6724         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6725                            histtype=histtype)
6726         _api.check_in_list(['left', 'mid', 'right'], align=align)
6727         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6728 
6729         if histtype == 'barstacked' and not stacked:
6730             stacked = True
6731 
6732         # Massage 'x' for processing.
6733         x = cbook._reshape_2D(x, 'x')
6734         nx = len(x)  # number of datasets
6735 
6736         # Process unit information.  _process_unit_info sets the unit and
6737         # converts the first dataset; then we convert each following dataset
6738         # one at a time.
6739         if orientation == "vertical":
6740             convert_units = self.convert_xunits
6741             x = [*self._process_unit_info([("x", x[0])], kwargs),
6742                  *map(convert_units, x[1:])]
6743         else:  # horizontal
6744             convert_units = self.convert_yunits
6745             x = [*self._process_unit_info([("y", x[0])], kwargs),
6746                  *map(convert_units, x[1:])]
6747 
6748         if bin_range is not None:
6749             bin_range = convert_units(bin_range)
6750 
6751         if not cbook.is_scalar_or_string(bins):
6752             bins = convert_units(bins)
6753 
6754         # We need to do to 'weights' what was done to 'x'
6755         if weights is not None:
6756             w = cbook._reshape_2D(weights, 'weights')
6757         else:
6758             w = [None] * nx
6759 
6760         if len(w) != nx:
6761             raise ValueError('weights should have the same shape as x')
6762 
6763         input_empty = True
6764         for xi, wi in zip(x, w):
6765             len_xi = len(xi)
6766             if wi is not None and len(wi) != len_xi:
6767                 raise ValueError('weights should have the same shape as x')
6768             if len_xi:
6769                 input_empty = False
6770 
6771         if color is None:
6772             colors = [self._get_lines.get_next_color() for i in range(nx)]
6773         else:
6774             colors = mcolors.to_rgba_array(color)
6775             if len(colors) != nx:
6776                 raise ValueError(f"The 'color' keyword argument must have one "
6777                                  f"color per dataset, but {nx} datasets and "
6778                                  f"{len(colors)} colors were provided")
6779 
6780         hist_kwargs = dict()
6781 
6782         # if the bin_range is not given, compute without nan numpy
6783         # does not do this for us when guessing the range (but will
6784         # happily ignore nans when computing the histogram).
6785         if bin_range is None:
6786             xmin = np.inf
6787             xmax = -np.inf
6788             for xi in x:
6789                 if len(xi):
6790                     # python's min/max ignore nan,
6791                     # np.minnan returns nan for all nan input
6792                     xmin = min(xmin, np.nanmin(xi))
6793                     xmax = max(xmax, np.nanmax(xi))
6794             if xmin <= xmax:  # Only happens if we have seen a finite value.
6795                 bin_range = (xmin, xmax)
6796 
6797         # If bins are not specified either explicitly or via range,
6798         # we need to figure out the range required for all datasets,
6799         # and supply that to np.histogram.
6800         if not input_empty and len(x) > 1:
6801             if weights is not None:
6802                 _w = np.concatenate(w)
6803             else:
6804                 _w = None
6805             bins = np.histogram_bin_edges(
6806                 np.concatenate(x), bins, bin_range, _w)
6807         else:
6808             hist_kwargs['range'] = bin_range
6809 
6810         density = bool(density)
6811         if density and not stacked:
6812             hist_kwargs['density'] = density
6813 
6814         # List to store all the top coordinates of the histograms
6815         tops = []  # Will have shape (n_datasets, n_bins).
6816         # Loop through datasets
6817         for i in range(nx):
6818             # this will automatically overwrite bins,
6819             # so that each histogram uses the same bins
6820             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6821             tops.append(m)
6822         tops = np.array(tops, float)  # causes problems later if it's an int
6823         bins = np.array(bins, float)  # causes problems if float16
6824         if stacked:
6825             tops = tops.cumsum(axis=0)
6826             # If a stacked density plot, normalize so the area of all the
6827             # stacked histograms together is 1
6828             if density:
6829                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6830         if cumulative:
6831             slc = slice(None)
6832             if isinstance(cumulative, Number) and cumulative < 0:
6833                 slc = slice(None, None, -1)
6834             if density:
6835                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6836             else:
6837                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6838 
6839         patches = []
6840 
6841         if histtype.startswith('bar'):
6842 
6843             totwidth = np.diff(bins)
6844 
6845             if rwidth is not None:
6846                 dr = np.clip(rwidth, 0, 1)
6847             elif (len(tops) > 1 and
6848                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6849                 dr = 0.8
6850             else:
6851                 dr = 1.0
6852 
6853             if histtype == 'bar' and not stacked:
6854                 width = dr * totwidth / nx
6855                 dw = width
6856                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6857             elif histtype == 'barstacked' or stacked:
6858                 width = dr * totwidth
6859                 boffset, dw = 0.0, 0.0
6860 
6861             if align == 'mid':
6862                 boffset += 0.5 * totwidth
6863             elif align == 'right':
6864                 boffset += totwidth
6865 
6866             if orientation == 'horizontal':
6867                 _barfunc = self.barh
6868                 bottom_kwarg = 'left'
6869             else:  # orientation == 'vertical'
6870                 _barfunc = self.bar
6871                 bottom_kwarg = 'bottom'
6872 
6873             for top, color in zip(tops, colors):
6874                 if bottom is None:
6875                     bottom = np.zeros(len(top))
6876                 if stacked:
6877                     height = top - bottom
6878                 else:
6879                     height = top
6880                 bars = _barfunc(bins[:-1]+boffset, height, width,
6881                                 align='center', log=log,
6882                                 color=color, **{bottom_kwarg: bottom})
6883                 patches.append(bars)
6884                 if stacked:
6885                     bottom = top
6886                 boffset += dw
6887             # Remove stickies from all bars but the lowest ones, as otherwise
6888             # margin expansion would be unable to cross the stickies in the
6889             # middle of the bars.
6890             for bars in patches[1:]:
6891                 for patch in bars:
6892                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6893 
6894         elif histtype.startswith('step'):
6895             # these define the perimeter of the polygon
6896             x = np.zeros(4 * len(bins) - 3)
6897             y = np.zeros(4 * len(bins) - 3)
6898 
6899             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6900             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6901 
6902             if bottom is None:
6903                 bottom = 0
6904 
6905             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6906             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6907 
6908             if log:
6909                 if orientation == 'horizontal':
6910                     self.set_xscale('log', nonpositive='clip')
6911                 else:  # orientation == 'vertical'
6912                     self.set_yscale('log', nonpositive='clip')
6913 
6914             if align == 'left':
6915                 x -= 0.5*(bins[1]-bins[0])
6916             elif align == 'right':
6917                 x += 0.5*(bins[1]-bins[0])
6918 
6919             # If fill kwarg is set, it will be passed to the patch collection,
6920             # overriding this
6921             fill = (histtype == 'stepfilled')
6922 
6923             xvals, yvals = [], []
6924             for top in tops:
6925                 if stacked:
6926                     # top of the previous polygon becomes the bottom
6927                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6928                 # set the top of this polygon
6929                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6930 
6931                 # The starting point of the polygon has not yet been
6932                 # updated. So far only the endpoint was adjusted. This
6933                 # assignment closes the polygon. The redundant endpoint is
6934                 # later discarded (for step and stepfilled).
6935                 y[0] = y[-1]
6936 
6937                 if orientation == 'horizontal':
6938                     xvals.append(y.copy())
6939                     yvals.append(x.copy())
6940                 else:
6941                     xvals.append(x.copy())
6942                     yvals.append(y.copy())
6943 
6944             # stepfill is closed, step is not
6945             split = -1 if fill else 2 * len(bins)
6946             # add patches in reverse order so that when stacking,
6947             # items lower in the stack are plotted on top of
6948             # items higher in the stack
6949             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6950                 patches.append(self.fill(
6951                     x[:split], y[:split],
6952                     closed=True if fill else None,
6953                     facecolor=color,
6954                     edgecolor=None if fill else color,
6955                     fill=fill if fill else None,
6956                     zorder=None if fill else mlines.Line2D.zorder))
6957             for patch_list in patches:
6958                 for patch in patch_list:
6959                     if orientation == 'vertical':
6960                         patch.sticky_edges.y.append(0)
6961                     elif orientation == 'horizontal':
6962                         patch.sticky_edges.x.append(0)
6963 
6964             # we return patches, so put it back in the expected order
6965             patches.reverse()
6966 
6967         # If None, make all labels None (via zip_longest below); otherwise,
6968         # cast each element to str, but keep a single str as it.
6969         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6970         for patch, lbl in itertools.zip_longest(patches, labels):
6971             if patch:
6972                 p = patch[0]
6973                 p._internal_update(kwargs)
6974                 if lbl is not None:
6975                     p.set_label(lbl)
6976                 for p in patch[1:]:
6977                     p._internal_update(kwargs)
6978                     p.set_label('_nolegend_')
6979 
6980         if nx == 1:
6981             return tops[0], bins, patches[0]
6982         else:
6983             patch_type = ("BarContainer" if histtype.startswith("bar")
6984                           else "list[Polygon]")
6985             return tops, bins, cbook.silent_list(patch_type, patches)
6986 
6987     @_preprocess_data()
6988     def stairs(self, values, edges=None, *,
6989                orientation='vertical', baseline=0, fill=False, **kwargs):
6990         """
6991         A stepwise constant function as a line with bounding edges
6992         or a filled plot.
6993 
6994         Parameters
6995         ----------
6996         values : array-like
6997             The step heights.
6998 
6999         edges : array-like
7000             The edge positions, with ``len(edges) == len(vals) + 1``,
7001             between which the curve takes on vals values.
7002 
7003         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7004             The direction of the steps. Vertical means that *values* are along
7005             the y-axis, and edges are along the x-axis.
7006 
7007         baseline : float, array-like or None, default: 0
7008             The bottom value of the bounding edges or when
7009             ``fill=True``, position of lower edge. If *fill* is
7010             True or an array is passed to *baseline*, a closed
7011             path is drawn.
7012 
7013         fill : bool, default: False
7014             Whether the area under the step curve should be filled.
7015 
7016         Returns
7017         -------
7018         StepPatch : `matplotlib.patches.StepPatch`
7019 
7020         Other Parameters
7021         ----------------
7022         data : indexable object, optional
7023             DATA_PARAMETER_PLACEHOLDER
7024 
7025         **kwargs
7026             `~matplotlib.patches.StepPatch` properties
7027 
7028         """
7029 
7030         if 'color' in kwargs:
7031             _color = kwargs.pop('color')
7032         else:
7033             _color = self._get_lines.get_next_color()
7034         if fill:
7035             kwargs.setdefault('linewidth', 0)
7036             kwargs.setdefault('facecolor', _color)
7037         else:
7038             kwargs.setdefault('edgecolor', _color)
7039 
7040         if edges is None:
7041             edges = np.arange(len(values) + 1)
7042 
7043         edges, values, baseline = self._process_unit_info(
7044             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7045 
7046         patch = mpatches.StepPatch(values,
7047                                    edges,
7048                                    baseline=baseline,
7049                                    orientation=orientation,
7050                                    fill=fill,
7051                                    **kwargs)
7052         self.add_patch(patch)
7053         if baseline is None:
7054             baseline = 0
7055         if orientation == 'vertical':
7056             patch.sticky_edges.y.append(np.min(baseline))
7057             self.update_datalim([(edges[0], np.min(baseline))])
7058         else:
7059             patch.sticky_edges.x.append(np.min(baseline))
7060             self.update_datalim([(np.min(baseline), edges[0])])
7061         self._request_autoscale_view()
7062         return patch
7063 
7064     @_preprocess_data(replace_names=["x", "y", "weights"])
7065     @_docstring.dedent_interpd
7066     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7067                cmin=None, cmax=None, **kwargs):
7068         """
7069         Make a 2D histogram plot.
7070 
7071         Parameters
7072         ----------
7073         x, y : array-like, shape (n, )
7074             Input values
7075 
7076         bins : None or int or [int, int] or array-like or [array, array]
7077 
7078             The bin specification:
7079 
7080             - If int, the number of bins for the two dimensions
7081               (nx=ny=bins).
7082             - If ``[int, int]``, the number of bins in each dimension
7083               (nx, ny = bins).
7084             - If array-like, the bin edges for the two dimensions
7085               (x_edges=y_edges=bins).
7086             - If ``[array, array]``, the bin edges in each dimension
7087               (x_edges, y_edges = bins).
7088 
7089             The default value is 10.
7090 
7091         range : array-like shape(2, 2), optional
7092             The leftmost and rightmost edges of the bins along each dimension
7093             (if not specified explicitly in the bins parameters): ``[[xmin,
7094             xmax], [ymin, ymax]]``. All values outside of this range will be
7095             considered outliers and not tallied in the histogram.
7096 
7097         density : bool, default: False
7098             Normalize histogram.  See the documentation for the *density*
7099             parameter of `~.Axes.hist` for more details.
7100 
7101         weights : array-like, shape (n, ), optional
7102             An array of values w_i weighing each sample (x_i, y_i).
7103 
7104         cmin, cmax : float, default: None
7105             All bins that has count less than *cmin* or more than *cmax* will
7106             not be displayed (set to NaN before passing to imshow) and these
7107             count values in the return value count histogram will also be set
7108             to nan upon return.
7109 
7110         Returns
7111         -------
7112         h : 2D array
7113             The bi-dimensional histogram of samples x and y. Values in x are
7114             histogrammed along the first dimension and values in y are
7115             histogrammed along the second dimension.
7116         xedges : 1D array
7117             The bin edges along the x-axis.
7118         yedges : 1D array
7119             The bin edges along the y-axis.
7120         image : `~.matplotlib.collections.QuadMesh`
7121 
7122         Other Parameters
7123         ----------------
7124         %(cmap_doc)s
7125 
7126         %(norm_doc)s
7127 
7128         %(vmin_vmax_doc)s
7129 
7130         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7131             The alpha blending value.
7132 
7133         data : indexable object, optional
7134             DATA_PARAMETER_PLACEHOLDER
7135 
7136         **kwargs
7137             Additional parameters are passed along to the
7138             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7139             constructor.
7140 
7141         See Also
7142         --------
7143         hist : 1D histogram plotting
7144         hexbin : 2D histogram with hexagonal bins
7145 
7146         Notes
7147         -----
7148         - Currently ``hist2d`` calculates its own axis limits, and any limits
7149           previously set are ignored.
7150         - Rendering the histogram with a logarithmic color scale is
7151           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7152           keyword argument. Likewise, power-law normalization (similar
7153           in effect to gamma correction) can be accomplished with
7154           `.colors.PowerNorm`.
7155         """
7156 
7157         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7158                                            density=density, weights=weights)
7159 
7160         if cmin is not None:
7161             h[h < cmin] = None
7162         if cmax is not None:
7163             h[h > cmax] = None
7164 
7165         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7166         self.set_xlim(xedges[0], xedges[-1])
7167         self.set_ylim(yedges[0], yedges[-1])
7168 
7169         return h, xedges, yedges, pc
7170 
7171     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7172     @_docstring.dedent_interpd
7173     def ecdf(self, x, weights=None, *, complementary=False,
7174              orientation="vertical", compress=False, **kwargs):
7175         """
7176         Compute and plot the empirical cumulative distribution function of *x*.
7177 
7178         .. versionadded:: 3.8
7179 
7180         Parameters
7181         ----------
7182         x : 1d array-like
7183             The input data.  Infinite entries are kept (and move the relevant
7184             end of the ecdf from 0/1), but NaNs and masked values are errors.
7185 
7186         weights : 1d array-like or None, default: None
7187             The weights of the entries; must have the same shape as *x*.
7188             Weights corresponding to NaN data points are dropped, and then the
7189             remaining weights are normalized to sum to 1.  If unset, all
7190             entries have the same weight.
7191 
7192         complementary : bool, default: False
7193             Whether to plot a cumulative distribution function, which increases
7194             from 0 to 1 (the default), or a complementary cumulative
7195             distribution function, which decreases from 1 to 0.
7196 
7197         orientation : {"vertical", "horizontal"}, default: "vertical"
7198             Whether the entries are plotted along the x-axis ("vertical", the
7199             default) or the y-axis ("horizontal").  This parameter takes the
7200             same values as in `~.Axes.hist`.
7201 
7202         compress : bool, default: False
7203             Whether multiple entries with the same values are grouped together
7204             (with a summed weight) before plotting.  This is mainly useful if
7205             *x* contains many identical data points, to decrease the rendering
7206             complexity of the plot. If *x* contains no duplicate points, this
7207             has no effect and just uses some time and memory.
7208 
7209         Other Parameters
7210         ----------------
7211         data : indexable object, optional
7212             DATA_PARAMETER_PLACEHOLDER
7213 
7214         **kwargs
7215             Keyword arguments control the `.Line2D` properties:
7216 
7217             %(Line2D:kwdoc)s
7218 
7219         Returns
7220         -------
7221         `.Line2D`
7222 
7223         Notes
7224         -----
7225         The ecdf plot can be thought of as a cumulative histogram with one bin
7226         per data entry; i.e. it reports on the entire dataset without any
7227         arbitrary binning.
7228 
7229         If *x* contains NaNs or masked entries, either remove them first from
7230         the array (if they should not taken into account), or replace them by
7231         -inf or +inf (if they should be sorted at the beginning or the end of
7232         the array).
7233         """
7234         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7235         if "drawstyle" in kwargs or "ds" in kwargs:
7236             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7237         if np.ma.getmask(x).any():
7238             raise ValueError("ecdf() does not support masked entries")
7239         x = np.asarray(x)
7240         if np.isnan(x).any():
7241             raise ValueError("ecdf() does not support NaNs")
7242         argsort = np.argsort(x)
7243         x = x[argsort]
7244         if weights is None:
7245             # Ensure that we end at exactly 1, avoiding floating point errors.
7246             cum_weights = (1 + np.arange(len(x))) / len(x)
7247         else:
7248             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7249             cum_weights = np.cumsum(weights / np.sum(weights))
7250         if compress:
7251             # Get indices of unique x values.
7252             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7253             x = x[compress_idxs]
7254             cum_weights = cum_weights[compress_idxs]
7255         if orientation == "vertical":
7256             if not complementary:
7257                 line, = self.plot([x[0], *x], [0, *cum_weights],
7258                                   drawstyle="steps-post", **kwargs)
7259             else:
7260                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7261                                   drawstyle="steps-pre", **kwargs)
7262             line.sticky_edges.y[:] = [0, 1]
7263         else:  # orientation == "horizontal":
7264             if not complementary:
7265                 line, = self.plot([0, *cum_weights], [x[0], *x],
7266                                   drawstyle="steps-pre", **kwargs)
7267             else:
7268                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7269                                   drawstyle="steps-post", **kwargs)
7270             line.sticky_edges.x[:] = [0, 1]
7271         return line
7272 
7273     @_preprocess_data(replace_names=["x"])
7274     @_docstring.dedent_interpd
7275     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7276             window=None, noverlap=None, pad_to=None,
7277             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7278         r"""
7279         Plot the power spectral density.
7280 
7281         The power spectral density :math:`P_{xx}` by Welch's average
7282         periodogram method.  The vector *x* is divided into *NFFT* length
7283         segments.  Each segment is detrended by function *detrend* and
7284         windowed by function *window*.  *noverlap* gives the length of
7285         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7286         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7287         with a scaling to correct for power loss due to windowing.
7288 
7289         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7290 
7291         Parameters
7292         ----------
7293         x : 1-D array or sequence
7294             Array or sequence containing the data
7295 
7296         %(Spectral)s
7297 
7298         %(PSD)s
7299 
7300         noverlap : int, default: 0 (no overlap)
7301             The number of points of overlap between segments.
7302 
7303         Fc : int, default: 0
7304             The center frequency of *x*, which offsets the x extents of the
7305             plot to reflect the frequency range used when a signal is acquired
7306             and then filtered and downsampled to baseband.
7307 
7308         return_line : bool, default: False
7309             Whether to include the line object plotted in the returned values.
7310 
7311         Returns
7312         -------
7313         Pxx : 1-D array
7314             The values for the power spectrum :math:`P_{xx}` before scaling
7315             (real valued).
7316 
7317         freqs : 1-D array
7318             The frequencies corresponding to the elements in *Pxx*.
7319 
7320         line : `~matplotlib.lines.Line2D`
7321             The line created by this function.
7322             Only returned if *return_line* is True.
7323 
7324         Other Parameters
7325         ----------------
7326         data : indexable object, optional
7327             DATA_PARAMETER_PLACEHOLDER
7328 
7329         **kwargs
7330             Keyword arguments control the `.Line2D` properties:
7331 
7332             %(Line2D:kwdoc)s
7333 
7334         See Also
7335         --------
7336         specgram
7337             Differs in the default overlap; in not returning the mean of the
7338             segment periodograms; in returning the times of the segments; and
7339             in plotting a colormap instead of a line.
7340         magnitude_spectrum
7341             Plots the magnitude spectrum.
7342         csd
7343             Plots the spectral density between two signals.
7344 
7345         Notes
7346         -----
7347         For plotting, the power is plotted as
7348         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7349         is returned.
7350 
7351         References
7352         ----------
7353         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7354         John Wiley & Sons (1986)
7355         """
7356         if Fc is None:
7357             Fc = 0
7358 
7359         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7360                               window=window, noverlap=noverlap, pad_to=pad_to,
7361                               sides=sides, scale_by_freq=scale_by_freq)
7362         freqs += Fc
7363 
7364         if scale_by_freq in (None, True):
7365             psd_units = 'dB/Hz'
7366         else:
7367             psd_units = 'dB'
7368 
7369         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7370         self.set_xlabel('Frequency')
7371         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7372         self.grid(True)
7373 
7374         vmin, vmax = self.get_ybound()
7375         step = max(10 * int(np.log10(vmax - vmin)), 1)
7376         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7377         self.set_yticks(ticks)
7378 
7379         if return_line is None or not return_line:
7380             return pxx, freqs
7381         else:
7382             return pxx, freqs, line
7383 
7384     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7385     @_docstring.dedent_interpd
7386     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7387             window=None, noverlap=None, pad_to=None,
7388             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7389         r"""
7390         Plot the cross-spectral density.
7391 
7392         The cross spectral density :math:`P_{xy}` by Welch's average
7393         periodogram method.  The vectors *x* and *y* are divided into
7394         *NFFT* length segments.  Each segment is detrended by function
7395         *detrend* and windowed by function *window*.  *noverlap* gives
7396         the length of the overlap between segments.  The product of
7397         the direct FFTs of *x* and *y* are averaged over each segment
7398         to compute :math:`P_{xy}`, with a scaling to correct for power
7399         loss due to windowing.
7400 
7401         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7402         padded to *NFFT*.
7403 
7404         Parameters
7405         ----------
7406         x, y : 1-D arrays or sequences
7407             Arrays or sequences containing the data.
7408 
7409         %(Spectral)s
7410 
7411         %(PSD)s
7412 
7413         noverlap : int, default: 0 (no overlap)
7414             The number of points of overlap between segments.
7415 
7416         Fc : int, default: 0
7417             The center frequency of *x*, which offsets the x extents of the
7418             plot to reflect the frequency range used when a signal is acquired
7419             and then filtered and downsampled to baseband.
7420 
7421         return_line : bool, default: False
7422             Whether to include the line object plotted in the returned values.
7423 
7424         Returns
7425         -------
7426         Pxy : 1-D array
7427             The values for the cross spectrum :math:`P_{xy}` before scaling
7428             (complex valued).
7429 
7430         freqs : 1-D array
7431             The frequencies corresponding to the elements in *Pxy*.
7432 
7433         line : `~matplotlib.lines.Line2D`
7434             The line created by this function.
7435             Only returned if *return_line* is True.
7436 
7437         Other Parameters
7438         ----------------
7439         data : indexable object, optional
7440             DATA_PARAMETER_PLACEHOLDER
7441 
7442         **kwargs
7443             Keyword arguments control the `.Line2D` properties:
7444 
7445             %(Line2D:kwdoc)s
7446 
7447         See Also
7448         --------
7449         psd : is equivalent to setting ``y = x``.
7450 
7451         Notes
7452         -----
7453         For plotting, the power is plotted as
7454         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7455         is returned.
7456 
7457         References
7458         ----------
7459         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7460         John Wiley & Sons (1986)
7461         """
7462         if Fc is None:
7463             Fc = 0
7464 
7465         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7466                               window=window, noverlap=noverlap, pad_to=pad_to,
7467                               sides=sides, scale_by_freq=scale_by_freq)
7468         # pxy is complex
7469         freqs += Fc
7470 
7471         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7472         self.set_xlabel('Frequency')
7473         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7474         self.grid(True)
7475 
7476         vmin, vmax = self.get_ybound()
7477         step = max(10 * int(np.log10(vmax - vmin)), 1)
7478         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7479         self.set_yticks(ticks)
7480 
7481         if return_line is None or not return_line:
7482             return pxy, freqs
7483         else:
7484             return pxy, freqs, line
7485 
7486     @_preprocess_data(replace_names=["x"])
7487     @_docstring.dedent_interpd
7488     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7489                            pad_to=None, sides=None, scale=None,
7490                            **kwargs):
7491         """
7492         Plot the magnitude spectrum.
7493 
7494         Compute the magnitude spectrum of *x*.  Data is padded to a
7495         length of *pad_to* and the windowing function *window* is applied to
7496         the signal.
7497 
7498         Parameters
7499         ----------
7500         x : 1-D array or sequence
7501             Array or sequence containing the data.
7502 
7503         %(Spectral)s
7504 
7505         %(Single_Spectrum)s
7506 
7507         scale : {'default', 'linear', 'dB'}
7508             The scaling of the values in the *spec*.  'linear' is no scaling.
7509             'dB' returns the values in dB scale, i.e., the dB amplitude
7510             (20 * log10). 'default' is 'linear'.
7511 
7512         Fc : int, default: 0
7513             The center frequency of *x*, which offsets the x extents of the
7514             plot to reflect the frequency range used when a signal is acquired
7515             and then filtered and downsampled to baseband.
7516 
7517         Returns
7518         -------
7519         spectrum : 1-D array
7520             The values for the magnitude spectrum before scaling (real valued).
7521 
7522         freqs : 1-D array
7523             The frequencies corresponding to the elements in *spectrum*.
7524 
7525         line : `~matplotlib.lines.Line2D`
7526             The line created by this function.
7527 
7528         Other Parameters
7529         ----------------
7530         data : indexable object, optional
7531             DATA_PARAMETER_PLACEHOLDER
7532 
7533         **kwargs
7534             Keyword arguments control the `.Line2D` properties:
7535 
7536             %(Line2D:kwdoc)s
7537 
7538         See Also
7539         --------
7540         psd
7541             Plots the power spectral density.
7542         angle_spectrum
7543             Plots the angles of the corresponding frequencies.
7544         phase_spectrum
7545             Plots the phase (unwrapped angle) of the corresponding frequencies.
7546         specgram
7547             Can plot the magnitude spectrum of segments within the signal in a
7548             colormap.
7549         """
7550         if Fc is None:
7551             Fc = 0
7552 
7553         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7554                                               pad_to=pad_to, sides=sides)
7555         freqs += Fc
7556 
7557         yunits = _api.check_getitem(
7558             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7559              'dB': 'dB'},
7560             scale=scale)
7561         if yunits == 'energy':
7562             Z = spec
7563         else:  # yunits == 'dB'
7564             Z = 20. * np.log10(spec)
7565 
7566         line, = self.plot(freqs, Z, **kwargs)
7567         self.set_xlabel('Frequency')
7568         self.set_ylabel('Magnitude (%s)' % yunits)
7569 
7570         return spec, freqs, line
7571 
7572     @_preprocess_data(replace_names=["x"])
7573     @_docstring.dedent_interpd
7574     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7575                        pad_to=None, sides=None, **kwargs):
7576         """
7577         Plot the angle spectrum.
7578 
7579         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7580         Data is padded to a length of *pad_to* and the windowing function
7581         *window* is applied to the signal.
7582 
7583         Parameters
7584         ----------
7585         x : 1-D array or sequence
7586             Array or sequence containing the data.
7587 
7588         %(Spectral)s
7589 
7590         %(Single_Spectrum)s
7591 
7592         Fc : int, default: 0
7593             The center frequency of *x*, which offsets the x extents of the
7594             plot to reflect the frequency range used when a signal is acquired
7595             and then filtered and downsampled to baseband.
7596 
7597         Returns
7598         -------
7599         spectrum : 1-D array
7600             The values for the angle spectrum in radians (real valued).
7601 
7602         freqs : 1-D array
7603             The frequencies corresponding to the elements in *spectrum*.
7604 
7605         line : `~matplotlib.lines.Line2D`
7606             The line created by this function.
7607 
7608         Other Parameters
7609         ----------------
7610         data : indexable object, optional
7611             DATA_PARAMETER_PLACEHOLDER
7612 
7613         **kwargs
7614             Keyword arguments control the `.Line2D` properties:
7615 
7616             %(Line2D:kwdoc)s
7617 
7618         See Also
7619         --------
7620         magnitude_spectrum
7621             Plots the magnitudes of the corresponding frequencies.
7622         phase_spectrum
7623             Plots the unwrapped version of this function.
7624         specgram
7625             Can plot the angle spectrum of segments within the signal in a
7626             colormap.
7627         """
7628         if Fc is None:
7629             Fc = 0
7630 
7631         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7632                                           pad_to=pad_to, sides=sides)
7633         freqs += Fc
7634 
7635         lines = self.plot(freqs, spec, **kwargs)
7636         self.set_xlabel('Frequency')
7637         self.set_ylabel('Angle (radians)')
7638 
7639         return spec, freqs, lines[0]
7640 
7641     @_preprocess_data(replace_names=["x"])
7642     @_docstring.dedent_interpd
7643     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7644                        pad_to=None, sides=None, **kwargs):
7645         """
7646         Plot the phase spectrum.
7647 
7648         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7649         Data is padded to a length of *pad_to* and the windowing function
7650         *window* is applied to the signal.
7651 
7652         Parameters
7653         ----------
7654         x : 1-D array or sequence
7655             Array or sequence containing the data
7656 
7657         %(Spectral)s
7658 
7659         %(Single_Spectrum)s
7660 
7661         Fc : int, default: 0
7662             The center frequency of *x*, which offsets the x extents of the
7663             plot to reflect the frequency range used when a signal is acquired
7664             and then filtered and downsampled to baseband.
7665 
7666         Returns
7667         -------
7668         spectrum : 1-D array
7669             The values for the phase spectrum in radians (real valued).
7670 
7671         freqs : 1-D array
7672             The frequencies corresponding to the elements in *spectrum*.
7673 
7674         line : `~matplotlib.lines.Line2D`
7675             The line created by this function.
7676 
7677         Other Parameters
7678         ----------------
7679         data : indexable object, optional
7680             DATA_PARAMETER_PLACEHOLDER
7681 
7682         **kwargs
7683             Keyword arguments control the `.Line2D` properties:
7684 
7685             %(Line2D:kwdoc)s
7686 
7687         See Also
7688         --------
7689         magnitude_spectrum
7690             Plots the magnitudes of the corresponding frequencies.
7691         angle_spectrum
7692             Plots the wrapped version of this function.
7693         specgram
7694             Can plot the phase spectrum of segments within the signal in a
7695             colormap.
7696         """
7697         if Fc is None:
7698             Fc = 0
7699 
7700         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7701                                           pad_to=pad_to, sides=sides)
7702         freqs += Fc
7703 
7704         lines = self.plot(freqs, spec, **kwargs)
7705         self.set_xlabel('Frequency')
7706         self.set_ylabel('Phase (radians)')
7707 
7708         return spec, freqs, lines[0]
7709 
7710     @_preprocess_data(replace_names=["x", "y"])
7711     @_docstring.dedent_interpd
7712     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7713                window=mlab.window_hanning, noverlap=0, pad_to=None,
7714                sides='default', scale_by_freq=None, **kwargs):
7715         r"""
7716         Plot the coherence between *x* and *y*.
7717 
7718         Coherence is the normalized cross spectral density:
7719 
7720         .. math::
7721 
7722           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7723 
7724         Parameters
7725         ----------
7726         %(Spectral)s
7727 
7728         %(PSD)s
7729 
7730         noverlap : int, default: 0 (no overlap)
7731             The number of points of overlap between blocks.
7732 
7733         Fc : int, default: 0
7734             The center frequency of *x*, which offsets the x extents of the
7735             plot to reflect the frequency range used when a signal is acquired
7736             and then filtered and downsampled to baseband.
7737 
7738         Returns
7739         -------
7740         Cxy : 1-D array
7741             The coherence vector.
7742 
7743         freqs : 1-D array
7744             The frequencies for the elements in *Cxy*.
7745 
7746         Other Parameters
7747         ----------------
7748         data : indexable object, optional
7749             DATA_PARAMETER_PLACEHOLDER
7750 
7751         **kwargs
7752             Keyword arguments control the `.Line2D` properties:
7753 
7754             %(Line2D:kwdoc)s
7755 
7756         References
7757         ----------
7758         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7759         John Wiley & Sons (1986)
7760         """
7761         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7762                                  window=window, noverlap=noverlap,
7763                                  scale_by_freq=scale_by_freq, sides=sides,
7764                                  pad_to=pad_to)
7765         freqs += Fc
7766 
7767         self.plot(freqs, cxy, **kwargs)
7768         self.set_xlabel('Frequency')
7769         self.set_ylabel('Coherence')
7770         self.grid(True)
7771 
7772         return cxy, freqs
7773 
7774     @_preprocess_data(replace_names=["x"])
7775     @_docstring.dedent_interpd
7776     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7777                  window=None, noverlap=None,
7778                  cmap=None, xextent=None, pad_to=None, sides=None,
7779                  scale_by_freq=None, mode=None, scale=None,
7780                  vmin=None, vmax=None, **kwargs):
7781         """
7782         Plot a spectrogram.
7783 
7784         Compute and plot a spectrogram of data in *x*.  Data are split into
7785         *NFFT* length segments and the spectrum of each section is
7786         computed.  The windowing function *window* is applied to each
7787         segment, and the amount of overlap of each segment is
7788         specified with *noverlap*. The spectrogram is plotted as a colormap
7789         (using imshow).
7790 
7791         Parameters
7792         ----------
7793         x : 1-D array or sequence
7794             Array or sequence containing the data.
7795 
7796         %(Spectral)s
7797 
7798         %(PSD)s
7799 
7800         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7801             What sort of spectrum to use.  Default is 'psd', which takes the
7802             power spectral density.  'magnitude' returns the magnitude
7803             spectrum.  'angle' returns the phase spectrum without unwrapping.
7804             'phase' returns the phase spectrum with unwrapping.
7805 
7806         noverlap : int, default: 128
7807             The number of points of overlap between blocks.
7808 
7809         scale : {'default', 'linear', 'dB'}
7810             The scaling of the values in the *spec*.  'linear' is no scaling.
7811             'dB' returns the values in dB scale.  When *mode* is 'psd',
7812             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7813             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7814             'magnitude' and 'linear' otherwise.  This must be 'linear'
7815             if *mode* is 'angle' or 'phase'.
7816 
7817         Fc : int, default: 0
7818             The center frequency of *x*, which offsets the x extents of the
7819             plot to reflect the frequency range used when a signal is acquired
7820             and then filtered and downsampled to baseband.
7821 
7822         cmap : `.Colormap`, default: :rc:`image.cmap`
7823 
7824         xextent : *None* or (xmin, xmax)
7825             The image extent along the x-axis. The default sets *xmin* to the
7826             left border of the first bin (*spectrum* column) and *xmax* to the
7827             right border of the last bin. Note that for *noverlap>0* the width
7828             of the bins is smaller than those of the segments.
7829 
7830         data : indexable object, optional
7831             DATA_PARAMETER_PLACEHOLDER
7832 
7833         **kwargs
7834             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7835             which makes the specgram image. The origin keyword argument
7836             is not supported.
7837 
7838         Returns
7839         -------
7840         spectrum : 2D array
7841             Columns are the periodograms of successive segments.
7842 
7843         freqs : 1-D array
7844             The frequencies corresponding to the rows in *spectrum*.
7845 
7846         t : 1-D array
7847             The times corresponding to midpoints of segments (i.e., the columns
7848             in *spectrum*).
7849 
7850         im : `.AxesImage`
7851             The image created by imshow containing the spectrogram.
7852 
7853         See Also
7854         --------
7855         psd
7856             Differs in the default overlap; in returning the mean of the
7857             segment periodograms; in not returning times; and in generating a
7858             line plot instead of colormap.
7859         magnitude_spectrum
7860             A single spectrum, similar to having a single segment when *mode*
7861             is 'magnitude'. Plots a line instead of a colormap.
7862         angle_spectrum
7863             A single spectrum, similar to having a single segment when *mode*
7864             is 'angle'. Plots a line instead of a colormap.
7865         phase_spectrum
7866             A single spectrum, similar to having a single segment when *mode*
7867             is 'phase'. Plots a line instead of a colormap.
7868 
7869         Notes
7870         -----
7871         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7872         is set to 'psd'.
7873         """
7874         if NFFT is None:
7875             NFFT = 256  # same default as in mlab.specgram()
7876         if Fc is None:
7877             Fc = 0  # same default as in mlab._spectral_helper()
7878         if noverlap is None:
7879             noverlap = 128  # same default as in mlab.specgram()
7880         if Fs is None:
7881             Fs = 2  # same default as in mlab._spectral_helper()
7882 
7883         if mode == 'complex':
7884             raise ValueError('Cannot plot a complex specgram')
7885 
7886         if scale is None or scale == 'default':
7887             if mode in ['angle', 'phase']:
7888                 scale = 'linear'
7889             else:
7890                 scale = 'dB'
7891         elif mode in ['angle', 'phase'] and scale == 'dB':
7892             raise ValueError('Cannot use dB scale with angle or phase mode')
7893 
7894         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7895                                        detrend=detrend, window=window,
7896                                        noverlap=noverlap, pad_to=pad_to,
7897                                        sides=sides,
7898                                        scale_by_freq=scale_by_freq,
7899                                        mode=mode)
7900 
7901         if scale == 'linear':
7902             Z = spec
7903         elif scale == 'dB':
7904             if mode is None or mode == 'default' or mode == 'psd':
7905                 Z = 10. * np.log10(spec)
7906             else:
7907                 Z = 20. * np.log10(spec)
7908         else:
7909             raise ValueError(f'Unknown scale {scale!r}')
7910 
7911         Z = np.flipud(Z)
7912 
7913         if xextent is None:
7914             # padding is needed for first and last segment:
7915             pad_xextent = (NFFT-noverlap) / Fs / 2
7916             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7917         xmin, xmax = xextent
7918         freqs += Fc
7919         extent = xmin, xmax, freqs[0], freqs[-1]
7920 
7921         if 'origin' in kwargs:
7922             raise _api.kwarg_error("specgram", "origin")
7923 
7924         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7925                          origin='upper', **kwargs)
7926         self.axis('auto')
7927 
7928         return spec, freqs, t, im
7929 
7930     @_docstring.dedent_interpd
7931     def spy(self, Z, precision=0, marker=None, markersize=None,
7932             aspect='equal', origin="upper", **kwargs):
7933         """
7934         Plot the sparsity pattern of a 2D array.
7935 
7936         This visualizes the non-zero values of the array.
7937 
7938         Two plotting styles are available: image and marker. Both
7939         are available for full arrays, but only the marker style
7940         works for `scipy.sparse.spmatrix` instances.
7941 
7942         **Image style**
7943 
7944         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7945         extra remaining keyword arguments are passed to this method.
7946 
7947         **Marker style**
7948 
7949         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7950         *None*, a `.Line2D` object will be returned with the value of marker
7951         determining the marker type, and any remaining keyword arguments
7952         passed to `~.Axes.plot`.
7953 
7954         Parameters
7955         ----------
7956         Z : (M, N) array-like
7957             The array to be plotted.
7958 
7959         precision : float or 'present', default: 0
7960             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7961             values of :math:`|Z| > precision` will be plotted.
7962 
7963             For `scipy.sparse.spmatrix` instances, you can also
7964             pass 'present'. In this case any value present in the array
7965             will be plotted, even if it is identically zero.
7966 
7967         aspect : {'equal', 'auto', None} or float, default: 'equal'
7968             The aspect ratio of the Axes.  This parameter is particularly
7969             relevant for images since it determines whether data pixels are
7970             square.
7971 
7972             This parameter is a shortcut for explicitly calling
7973             `.Axes.set_aspect`. See there for further details.
7974 
7975             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7976             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7977               that the data fit in the Axes. In general, this will result in
7978               non-square pixels.
7979             - *None*: Use :rc:`image.aspect`.
7980 
7981         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7982             Place the [0, 0] index of the array in the upper left or lower left
7983             corner of the Axes. The convention 'upper' is typically used for
7984             matrices and images.
7985 
7986         Returns
7987         -------
7988         `~matplotlib.image.AxesImage` or `.Line2D`
7989             The return type depends on the plotting style (see above).
7990 
7991         Other Parameters
7992         ----------------
7993         **kwargs
7994             The supported additional parameters depend on the plotting style.
7995 
7996             For the image style, you can pass the following additional
7997             parameters of `~.Axes.imshow`:
7998 
7999             - *cmap*
8000             - *alpha*
8001             - *url*
8002             - any `.Artist` properties (passed on to the `.AxesImage`)
8003 
8004             For the marker style, you can pass any `.Line2D` property except
8005             for *linestyle*:
8006 
8007             %(Line2D:kwdoc)s
8008         """
8009         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8010             marker = 's'
8011         _api.check_in_list(["upper", "lower"], origin=origin)
8012         if marker is None and markersize is None:
8013             Z = np.asarray(Z)
8014             mask = np.abs(Z) > precision
8015 
8016             if 'cmap' not in kwargs:
8017                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8018                                                         name='binary')
8019             if 'interpolation' in kwargs:
8020                 raise _api.kwarg_error("spy", "interpolation")
8021             if 'norm' not in kwargs:
8022                 kwargs['norm'] = mcolors.NoNorm()
8023             ret = self.imshow(mask, interpolation='nearest',
8024                               aspect=aspect, origin=origin,
8025                               **kwargs)
8026         else:
8027             if hasattr(Z, 'tocoo'):
8028                 c = Z.tocoo()
8029                 if precision == 'present':
8030                     y = c.row
8031                     x = c.col
8032                 else:
8033                     nonzero = np.abs(c.data) > precision
8034                     y = c.row[nonzero]
8035                     x = c.col[nonzero]
8036             else:
8037                 Z = np.asarray(Z)
8038                 nonzero = np.abs(Z) > precision
8039                 y, x = np.nonzero(nonzero)
8040             if marker is None:
8041                 marker = 's'
8042             if markersize is None:
8043                 markersize = 10
8044             if 'linestyle' in kwargs:
8045                 raise _api.kwarg_error("spy", "linestyle")
8046             ret = mlines.Line2D(
8047                 x, y, linestyle='None', marker=marker, markersize=markersize,
8048                 **kwargs)
8049             self.add_line(ret)
8050             nr, nc = Z.shape
8051             self.set_xlim(-0.5, nc - 0.5)
8052             if origin == "upper":
8053                 self.set_ylim(nr - 0.5, -0.5)
8054             else:
8055                 self.set_ylim(-0.5, nr - 0.5)
8056             self.set_aspect(aspect)
8057         self.title.set_y(1.05)
8058         if origin == "upper":
8059             self.xaxis.tick_top()
8060         else:  # lower
8061             self.xaxis.tick_bottom()
8062         self.xaxis.set_ticks_position('both')
8063         self.xaxis.set_major_locator(
8064             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8065         self.yaxis.set_major_locator(
8066             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8067         return ret
8068 
8069     def matshow(self, Z, **kwargs):
8070         """
8071         Plot the values of a 2D matrix or array as color-coded image.
8072 
8073         The matrix will be shown the way it would be printed, with the first
8074         row at the top.  Row and column numbering is zero-based.
8075 
8076         Parameters
8077         ----------
8078         Z : (M, N) array-like
8079             The matrix to be displayed.
8080 
8081         Returns
8082         -------
8083         `~matplotlib.image.AxesImage`
8084 
8085         Other Parameters
8086         ----------------
8087         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8088 
8089         See Also
8090         --------
8091         imshow : More general function to plot data on a 2D regular raster.
8092 
8093         Notes
8094         -----
8095         This is just a convenience function wrapping `.imshow` to set useful
8096         defaults for displaying a matrix. In particular:
8097 
8098         - Set ``origin='upper'``.
8099         - Set ``interpolation='nearest'``.
8100         - Set ``aspect='equal'``.
8101         - Ticks are placed to the left and above.
8102         - Ticks are formatted to show integer indices.
8103 
8104         """
8105         Z = np.asanyarray(Z)
8106         kw = {'origin': 'upper',
8107               'interpolation': 'nearest',
8108               'aspect': 'equal',          # (already the imshow default)
8109               **kwargs}
8110         im = self.imshow(Z, **kw)
8111         self.title.set_y(1.05)
8112         self.xaxis.tick_top()
8113         self.xaxis.set_ticks_position('both')
8114         self.xaxis.set_major_locator(
8115             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8116         self.yaxis.set_major_locator(
8117             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8118         return im
8119 
8120     @_preprocess_data(replace_names=["dataset"])
8121     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8122                    showmeans=False, showextrema=True, showmedians=False,
8123                    quantiles=None, points=100, bw_method=None):
8124         """
8125         Make a violin plot.
8126 
8127         Make a violin plot for each column of *dataset* or each vector in
8128         sequence *dataset*.  Each filled area extends to represent the
8129         entire data range, with optional lines at the mean, the median,
8130         the minimum, the maximum, and user-specified quantiles.
8131 
8132         Parameters
8133         ----------
8134         dataset : Array or a sequence of vectors.
8135           The input data.
8136 
8137         positions : array-like, default: [1, 2, ..., n]
8138           The positions of the violins. The ticks and limits are
8139           automatically set to match the positions.
8140 
8141         vert : bool, default: True.
8142           If true, creates a vertical violin plot.
8143           Otherwise, creates a horizontal violin plot.
8144 
8145         widths : array-like, default: 0.5
8146           Either a scalar or a vector that sets the maximal width of
8147           each violin. The default is 0.5, which uses about half of the
8148           available horizontal space.
8149 
8150         showmeans : bool, default: False
8151           If `True`, will toggle rendering of the means.
8152 
8153         showextrema : bool, default: True
8154           If `True`, will toggle rendering of the extrema.
8155 
8156         showmedians : bool, default: False
8157           If `True`, will toggle rendering of the medians.
8158 
8159         quantiles : array-like, default: None
8160           If not None, set a list of floats in interval [0, 1] for each violin,
8161           which stands for the quantiles that will be rendered for that
8162           violin.
8163 
8164         points : int, default: 100
8165           Defines the number of points to evaluate each of the
8166           gaussian kernel density estimations at.
8167 
8168         bw_method : str, scalar or callable, optional
8169           The method used to calculate the estimator bandwidth.  This can be
8170           'scott', 'silverman', a scalar constant or a callable.  If a
8171           scalar, this will be used directly as `kde.factor`.  If a
8172           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8173           its only parameter and return a scalar. If None (default), 'scott'
8174           is used.
8175 
8176         data : indexable object, optional
8177             DATA_PARAMETER_PLACEHOLDER
8178 
8179         Returns
8180         -------
8181         dict
8182           A dictionary mapping each component of the violinplot to a
8183           list of the corresponding collection instances created. The
8184           dictionary has the following keys:
8185 
8186           - ``bodies``: A list of the `~.collections.PolyCollection`
8187             instances containing the filled area of each violin.
8188 
8189           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8190             the mean values of each of the violin's distribution.
8191 
8192           - ``cmins``: A `~.collections.LineCollection` instance that marks
8193             the bottom of each violin's distribution.
8194 
8195           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8196             the top of each violin's distribution.
8197 
8198           - ``cbars``: A `~.collections.LineCollection` instance that marks
8199             the centers of each violin's distribution.
8200 
8201           - ``cmedians``: A `~.collections.LineCollection` instance that
8202             marks the median values of each of the violin's distribution.
8203 
8204           - ``cquantiles``: A `~.collections.LineCollection` instance created
8205             to identify the quantile values of each of the violin's
8206             distribution.
8207 
8208         """
8209 
8210         def _kde_method(X, coords):
8211             # Unpack in case of e.g. Pandas or xarray object
8212             X = cbook._unpack_to_numpy(X)
8213             # fallback gracefully if the vector contains only one value
8214             if np.all(X[0] == X):
8215                 return (X[0] == coords).astype(float)
8216             kde = mlab.GaussianKDE(X, bw_method)
8217             return kde.evaluate(coords)
8218 
8219         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8220                                      quantiles=quantiles)
8221         return self.violin(vpstats, positions=positions, vert=vert,
8222                            widths=widths, showmeans=showmeans,
8223                            showextrema=showextrema, showmedians=showmedians)
8224 
8225     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8226                showmeans=False, showextrema=True, showmedians=False):
8227         """
8228         Drawing function for violin plots.
8229 
8230         Draw a violin plot for each column of *vpstats*. Each filled area
8231         extends to represent the entire data range, with optional lines at the
8232         mean, the median, the minimum, the maximum, and the quantiles values.
8233 
8234         Parameters
8235         ----------
8236         vpstats : list of dicts
8237           A list of dictionaries containing stats for each violin plot.
8238           Required keys are:
8239 
8240           - ``coords``: A list of scalars containing the coordinates that
8241             the violin's kernel density estimate were evaluated at.
8242 
8243           - ``vals``: A list of scalars containing the values of the
8244             kernel density estimate at each of the coordinates given
8245             in *coords*.
8246 
8247           - ``mean``: The mean value for this violin's dataset.
8248 
8249           - ``median``: The median value for this violin's dataset.
8250 
8251           - ``min``: The minimum value for this violin's dataset.
8252 
8253           - ``max``: The maximum value for this violin's dataset.
8254 
8255           Optional keys are:
8256 
8257           - ``quantiles``: A list of scalars containing the quantile values
8258             for this violin's dataset.
8259 
8260         positions : array-like, default: [1, 2, ..., n]
8261           The positions of the violins. The ticks and limits are
8262           automatically set to match the positions.
8263 
8264         vert : bool, default: True.
8265           If true, plots the violins vertically.
8266           Otherwise, plots the violins horizontally.
8267 
8268         widths : array-like, default: 0.5
8269           Either a scalar or a vector that sets the maximal width of
8270           each violin. The default is 0.5, which uses about half of the
8271           available horizontal space.
8272 
8273         showmeans : bool, default: False
8274           If true, will toggle rendering of the means.
8275 
8276         showextrema : bool, default: True
8277           If true, will toggle rendering of the extrema.
8278 
8279         showmedians : bool, default: False
8280           If true, will toggle rendering of the medians.
8281 
8282         Returns
8283         -------
8284         dict
8285           A dictionary mapping each component of the violinplot to a
8286           list of the corresponding collection instances created. The
8287           dictionary has the following keys:
8288 
8289           - ``bodies``: A list of the `~.collections.PolyCollection`
8290             instances containing the filled area of each violin.
8291 
8292           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8293             the mean values of each of the violin's distribution.
8294 
8295           - ``cmins``: A `~.collections.LineCollection` instance that marks
8296             the bottom of each violin's distribution.
8297 
8298           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8299             the top of each violin's distribution.
8300 
8301           - ``cbars``: A `~.collections.LineCollection` instance that marks
8302             the centers of each violin's distribution.
8303 
8304           - ``cmedians``: A `~.collections.LineCollection` instance that
8305             marks the median values of each of the violin's distribution.
8306 
8307           - ``cquantiles``: A `~.collections.LineCollection` instance created
8308             to identify the quantiles values of each of the violin's
8309             distribution.
8310         """
8311 
8312         # Statistical quantities to be plotted on the violins
8313         means = []
8314         mins = []
8315         maxes = []
8316         medians = []
8317         quantiles = []
8318 
8319         qlens = []  # Number of quantiles in each dataset.
8320 
8321         artists = {}  # Collections to be returned
8322 
8323         N = len(vpstats)
8324         datashape_message = ("List of violinplot statistics and `{0}` "
8325                              "values must have the same length")
8326 
8327         # Validate positions
8328         if positions is None:
8329             positions = range(1, N + 1)
8330         elif len(positions) != N:
8331             raise ValueError(datashape_message.format("positions"))
8332 
8333         # Validate widths
8334         if np.isscalar(widths):
8335             widths = [widths] * N
8336         elif len(widths) != N:
8337             raise ValueError(datashape_message.format("widths"))
8338 
8339         # Calculate ranges for statistics lines (shape (2, N)).
8340         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8341 
8342         # Colors.
8343         if mpl.rcParams['_internal.classic_mode']:
8344             fillcolor = 'y'
8345             linecolor = 'r'
8346         else:
8347             fillcolor = linecolor = self._get_lines.get_next_color()
8348 
8349         # Check whether we are rendering vertically or horizontally
8350         if vert:
8351             fill = self.fill_betweenx
8352             perp_lines = functools.partial(self.hlines, colors=linecolor)
8353             par_lines = functools.partial(self.vlines, colors=linecolor)
8354         else:
8355             fill = self.fill_between
8356             perp_lines = functools.partial(self.vlines, colors=linecolor)
8357             par_lines = functools.partial(self.hlines, colors=linecolor)
8358 
8359         # Render violins
8360         bodies = []
8361         for stats, pos, width in zip(vpstats, positions, widths):
8362             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8363             vals = np.array(stats['vals'])
8364             vals = 0.5 * width * vals / vals.max()
8365             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8366                             facecolor=fillcolor, alpha=0.3)]
8367             means.append(stats['mean'])
8368             mins.append(stats['min'])
8369             maxes.append(stats['max'])
8370             medians.append(stats['median'])
8371             q = stats.get('quantiles')  # a list of floats, or None
8372             if q is None:
8373                 q = []
8374             quantiles.extend(q)
8375             qlens.append(len(q))
8376         artists['bodies'] = bodies
8377 
8378         if showmeans:  # Render means
8379             artists['cmeans'] = perp_lines(means, *line_ends)
8380         if showextrema:  # Render extrema
8381             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8382             artists['cmins'] = perp_lines(mins, *line_ends)
8383             artists['cbars'] = par_lines(positions, mins, maxes)
8384         if showmedians:  # Render medians
8385             artists['cmedians'] = perp_lines(medians, *line_ends)
8386         if quantiles:  # Render quantiles: each width is repeated qlen times.
8387             artists['cquantiles'] = perp_lines(
8388                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8389 
8390         return artists
8391 
8392     # Methods that are entirely implemented in other modules.
8393 
8394     table = mtable.table
8395 
8396     # args can be either Y or y1, y2, ... and all should be replaced
8397     stackplot = _preprocess_data()(mstack.stackplot)
8398 
8399     streamplot = _preprocess_data(
8400         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8401 
8402     tricontour = mtri.tricontour
8403     tricontourf = mtri.tricontourf
8404     tripcolor = mtri.tripcolor
8405     triplot = mtri.triplot
8406 
8407     def _get_aspect_ratio(self):
8408         """
8409         Convenience method to calculate the aspect ratio of the axes in
8410         the display coordinate system.
8411         """
8412         figure_size = self.get_figure().get_size_inches()
8413         ll, ur = self.get_position() * figure_size
8414         width, height = ur - ll
8415         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:26:21.646 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>bar</method>
<code>
2267     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2268             **kwargs):
2269         r"""
2270         Make a bar plot.
2271 
2272         The bars are positioned at *x* with the given *align*\ment. Their
2273         dimensions are given by *height* and *width*. The vertical baseline
2274         is *bottom* (default 0).
2275 
2276         Many parameters can take either a single value applying to all bars
2277         or a sequence of values, one for each bar.
2278 
2279         Parameters
2280         ----------
2281         x : float or array-like
2282             The x coordinates of the bars. See also *align* for the
2283             alignment of the bars to the coordinates.
2284 
2285         height : float or array-like
2286             The height(s) of the bars.
2287 
2288         width : float or array-like, default: 0.8
2289             The width(s) of the bars.
2290 
2291         bottom : float or array-like, default: 0
2292             The y coordinate(s) of the bottom side(s) of the bars.
2293 
2294         align : {'center', 'edge'}, default: 'center'
2295             Alignment of the bars to the *x* coordinates:
2296 
2297             - 'center': Center the base on the *x* positions.
2298             - 'edge': Align the left edges of the bars with the *x* positions.
2299 
2300             To align the bars on the right edge pass a negative *width* and
2301             ``align='edge'``.
2302 
2303         Returns
2304         -------
2305         `.BarContainer`
2306             Container with all the bars and optionally errorbars.
2307 
2308         Other Parameters
2309         ----------------
2310         color : color or list of color, optional
2311             The colors of the bar faces.
2312 
2313         edgecolor : color or list of color, optional
2314             The colors of the bar edges.
2315 
2316         linewidth : float or array-like, optional
2317             Width of the bar edge(s). If 0, don't draw edges.
2318 
2319         tick_label : str or list of str, optional
2320             The tick labels of the bars.
2321             Default: None (Use default numeric labels.)
2322 
2323         label : str or list of str, optional
2324             A single label is attached to the resulting `.BarContainer` as a
2325             label for the whole dataset.
2326             If a list is provided, it must be the same length as *x* and
2327             labels the individual bars. Repeated labels are not de-duplicated
2328             and will cause repeated label entries, so this is best used when
2329             bars also differ in style (e.g., by passing a list to *color*.)
2330 
2331         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2332             If not *None*, add horizontal / vertical errorbars to the bar tips.
2333             The values are +/- sizes relative to the data:
2334 
2335             - scalar: symmetric +/- values for all bars
2336             - shape(N,): symmetric +/- values for each bar
2337             - shape(2, N): Separate - and + values for each bar. First row
2338               contains the lower errors, the second row contains the upper
2339               errors.
2340             - *None*: No errorbar. (Default)
2341 
2342             See :doc:`/gallery/statistics/errorbar_features` for an example on
2343             the usage of *xerr* and *yerr*.
2344 
2345         ecolor : color or list of color, default: 'black'
2346             The line color of the errorbars.
2347 
2348         capsize : float, default: :rc:`errorbar.capsize`
2349            The length of the error bar caps in points.
2350 
2351         error_kw : dict, optional
2352             Dictionary of keyword arguments to be passed to the
2353             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2354             here take precedence over the independent keyword arguments.
2355 
2356         log : bool, default: False
2357             If *True*, set the y-axis to be log scale.
2358 
2359         data : indexable object, optional
2360             DATA_PARAMETER_PLACEHOLDER
2361 
2362         **kwargs : `.Rectangle` properties
2363 
2364         %(Rectangle:kwdoc)s
2365 
2366         See Also
2367         --------
2368         barh : Plot a horizontal bar plot.
2369 
2370         Notes
2371         -----
2372         Stacked bars can be achieved by passing individual *bottom* values per
2373         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2374         """
2375         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2376         color = kwargs.pop('color', None)
2377         if color is None:
2378             color = self._get_patches_for_fill.get_next_color()
2379         edgecolor = kwargs.pop('edgecolor', None)
2380         linewidth = kwargs.pop('linewidth', None)
2381         hatch = kwargs.pop('hatch', None)
2382 
2383         # Because xerr and yerr will be passed to errorbar, most dimension
2384         # checking and processing will be left to the errorbar method.
2385         xerr = kwargs.pop('xerr', None)
2386         yerr = kwargs.pop('yerr', None)
2387         error_kw = kwargs.pop('error_kw', {})
2388         ezorder = error_kw.pop('zorder', None)
2389         if ezorder is None:
2390             ezorder = kwargs.get('zorder', None)
2391             if ezorder is not None:
2392                 # If using the bar zorder, increment slightly to make sure
2393                 # errorbars are drawn on top of bars
2394                 ezorder += 0.01
2395         error_kw.setdefault('zorder', ezorder)
2396         ecolor = kwargs.pop('ecolor', 'k')
2397         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2398         error_kw.setdefault('ecolor', ecolor)
2399         error_kw.setdefault('capsize', capsize)
2400 
2401         # The keyword argument *orientation* is used by barh() to defer all
2402         # logic and drawing to bar(). It is considered internal and is
2403         # intentionally not mentioned in the docstring.
2404         orientation = kwargs.pop('orientation', 'vertical')
2405         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2406         log = kwargs.pop('log', False)
2407         label = kwargs.pop('label', '')
2408         tick_labels = kwargs.pop('tick_label', None)
2409 
2410         y = bottom  # Matches barh call signature.
2411         if orientation == 'vertical':
2412             if y is None:
2413                 y = 0
2414         else:  # horizontal
2415             if x is None:
2416                 x = 0
2417 
2418         if orientation == 'vertical':
2419             self._process_unit_info(
2420                 [("x", x), ("y", height)], kwargs, convert=False)
2421             if log:
2422                 self.set_yscale('log', nonpositive='clip')
2423         else:  # horizontal
2424             self._process_unit_info(
2425                 [("x", width), ("y", y)], kwargs, convert=False)
2426             if log:
2427                 self.set_xscale('log', nonpositive='clip')
2428 
2429         # lets do some conversions now since some types cannot be
2430         # subtracted uniformly
2431         if self.xaxis is not None:
2432             x0 = x
2433             x = np.asarray(self.convert_xunits(x))
2434             width = self._convert_dx(width, x0, x, self.convert_xunits)
2435             if xerr is not None:
2436                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2437         if self.yaxis is not None:
2438             y0 = y
2439             y = np.asarray(self.convert_yunits(y))
2440             height = self._convert_dx(height, y0, y, self.convert_yunits)
2441             if yerr is not None:
2442                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2443 
2444         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2445             # Make args iterable too.
2446             np.atleast_1d(x), height, width, y, linewidth, hatch)
2447 
2448         # Now that units have been converted, set the tick locations.
2449         if orientation == 'vertical':
2450             tick_label_axis = self.xaxis
2451             tick_label_position = x
2452         else:  # horizontal
2453             tick_label_axis = self.yaxis
2454             tick_label_position = y
2455 
2456         if not isinstance(label, str) and np.iterable(label):
2457             bar_container_label = '_nolegend_'
2458             patch_labels = label
2459         else:
2460             bar_container_label = label
2461             patch_labels = ['_nolegend_'] * len(x)
2462         if len(patch_labels) != len(x):
2463             raise ValueError(f'number of labels ({len(patch_labels)}) '
2464                              f'does not match number of bars ({len(x)}).')
2465 
2466         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2467         hatch = itertools.cycle(np.atleast_1d(hatch))
2468         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2469                                 # Fallback if color == "none".
2470                                 itertools.repeat('none'))
2471         if edgecolor is None:
2472             edgecolor = itertools.repeat(None)
2473         else:
2474             edgecolor = itertools.chain(
2475                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2476                 # Fallback if edgecolor == "none".
2477                 itertools.repeat('none'))
2478 
2479         # We will now resolve the alignment and really have
2480         # left, bottom, width, height vectors
2481         _api.check_in_list(['center', 'edge'], align=align)
2482         if align == 'center':
2483             if orientation == 'vertical':
2484                 try:
2485                     left = x - width / 2
2486                 except TypeError as e:
2487                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2488                                     f'and width ({width.dtype}) '
2489                                     f'are incompatible') from e
2490                 bottom = y
2491             else:  # horizontal
2492                 try:
2493                     bottom = y - height / 2
2494                 except TypeError as e:
2495                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2496                                     f'and height ({height.dtype}) '
2497                                     f'are incompatible') from e
2498                 left = x
2499         else:  # edge
2500             left = x
2501             bottom = y
2502 
2503         patches = []
2504         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2505                    hatch, patch_labels)
2506         for l, b, w, h, c, e, lw, htch, lbl in args:
2507             r = mpatches.Rectangle(
2508                 xy=(l, b), width=w, height=h,
2509                 facecolor=c,
2510                 edgecolor=e,
2511                 linewidth=lw,
2512                 label=lbl,
2513                 hatch=htch,
2514                 )
2515             r._internal_update(kwargs)
2516             r.get_path()._interpolation_steps = 100
2517             if orientation == 'vertical':
2518                 r.sticky_edges.y.append(b)
2519             else:  # horizontal
2520                 r.sticky_edges.x.append(l)
2521             self.add_patch(r)
2522             patches.append(r)
2523 
2524         if xerr is not None or yerr is not None:
2525             if orientation == 'vertical':
2526                 # using list comps rather than arrays to preserve unit info
2527                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2528                 ey = [b + h for b, h in zip(bottom, height)]
2529 
2530             else:  # horizontal
2531                 # using list comps rather than arrays to preserve unit info
2532                 ex = [l + w for l, w in zip(left, width)]
2533                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2534 
2535             error_kw.setdefault("label", '_nolegend_')
2536 
2537             errorbar = self.errorbar(ex, ey,
2538                                      yerr=yerr, xerr=xerr,
2539                                      fmt='none', **error_kw)
2540         else:
2541             errorbar = None
2542 
2543         self._request_autoscale_view()
2544 
2545         if orientation == 'vertical':
2546             datavalues = height
2547         else:  # horizontal
2548             datavalues = width
2549 
2550         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2551                                      orientation=orientation,
2552                                      label=bar_container_label)
2553         self.add_container(bar_container)
2554 
2555         if tick_labels is not None:
2556             tick_labels = np.broadcast_to(tick_labels, len(patches))
2557             tick_label_axis.set_ticks(tick_label_position)
2558             tick_label_axis.set_ticklabels(tick_labels)
2559 
2560         return bar_container

</code><intended_behavior>This method should include a mechanism to detect if the `bottom` parameter is supplied with datetime objects, and if so, ensure proper conversion to the appropriate format that the Axes object can understand and correctly display. This behavior should preserve all existing functionality for other types of data while enhancing the method to handle datetime units effectively, thus ensuring that when `bottom` is a datetime object, the x-axis (for vertical bars) dynamically adjusts to represent time scales accurately.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
320                 [self],
321                 *args,
322                 **kwargs)
323         if len(extra_args):
324             raise _api.nargs_error('legend', '0-2', len(args))
325         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
326         self.legend_._remove_method = self._remove_legend
327         return self.legend_
328 
329     def _remove_legend(self, legend):
330         self.legend_ = None
331 
332     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
333         """
334         Add a child inset Axes to this existing Axes.
335 
336         Warnings
337         --------
338         This method is experimental as of 3.0, and the API may change.
339 
340         Parameters
341         ----------
342         bounds : [x0, y0, width, height]
343             Lower-left corner of inset Axes, and its width and height.
344 
345         transform : `.Transform`
346             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
347             Axes-relative coordinates.
348 
349         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
350 'polar', 'rectilinear', str}, optional
351             The projection type of the inset `~.axes.Axes`. *str* is the name
352             of a custom projection, see `~matplotlib.projections`. The default
353             None results in a 'rectilinear' projection.
354 
355         polar : bool, default: False
356             If True, equivalent to projection='polar'.
357 
358         axes_class : subclass type of `~.axes.Axes`, optional
359             The `.axes.Axes` subclass that is instantiated.  This parameter
360             is incompatible with *projection* and *polar*.  See
361             :ref:`axisartist_users-guide-index` for examples.
362 
363         zorder : number
364             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
365             to change whether it is above or below data plotted on the
366             parent Axes.
367 
368         **kwargs
369             Other keyword arguments are passed on to the inset Axes class.
370 
371         Returns
372         -------
373         ax
374             The created `~.axes.Axes` instance.
375 
376         Examples
377         --------
378         This example makes two inset Axes, the first is in Axes-relative
379         coordinates, and the second in data-coordinates::
380 
381             fig, ax = plt.subplots()
382             ax.plot(range(10))
383             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
384             axin2 = ax.inset_axes(
385                     [5, 7, 2.3, 2.3], transform=ax.transData)
386 
387         """
388         if transform is None:
389             transform = self.transAxes
390         kwargs.setdefault('label', 'inset_axes')
391 
392         # This puts the rectangle into figure-relative coordinates.
393         inset_locator = _TransformedBoundsLocator(bounds, transform)
394         bounds = inset_locator(self, None).bounds
395         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
396         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
397 
398         # this locator lets the axes move if in data coordinates.
399         # it gets called in `ax.apply_aspect() (of all places)
400         inset_ax.set_axes_locator(inset_locator)
401 
402         self.add_child_axes(inset_ax)
403 
404         return inset_ax
405 
406     @_docstring.dedent_interpd
407     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
408                        facecolor='none', edgecolor='0.5', alpha=0.5,
409                        zorder=4.99, **kwargs):
410         """
411         Add an inset indicator to the Axes.  This is a rectangle on the plot
412         at the position indicated by *bounds* that optionally has lines that
413         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
414 
415         Warnings
416         --------
417         This method is experimental as of 3.0, and the API may change.
418 
419         Parameters
420         ----------
421         bounds : [x0, y0, width, height]
422             Lower-left corner of rectangle to be marked, and its width
423             and height.
424 
425         inset_ax : `.Axes`
426             An optional inset Axes to draw connecting lines to.  Two lines are
427             drawn connecting the indicator box to the inset Axes on corners
428             chosen so as to not overlap with the indicator box.
429 
430         transform : `.Transform`
431             Transform for the rectangle coordinates. Defaults to
432             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
433             coordinates.
434 
435         facecolor : color, default: 'none'
436             Facecolor of the rectangle.
437 
438         edgecolor : color, default: '0.5'
439             Color of the rectangle and color of the connecting lines.
440 
441         alpha : float, default: 0.5
442             Transparency of the rectangle and connector lines.
443 
444         zorder : float, default: 4.99
445             Drawing order of the rectangle and connector lines.  The default,
446             4.99, is just below the default level of inset Axes.
447 
448         **kwargs
449             Other keyword arguments are passed on to the `.Rectangle` patch:
450 
451             %(Rectangle:kwdoc)s
452 
453         Returns
454         -------
455         rectangle_patch : `.patches.Rectangle`
456              The indicator frame.
457 
458         connector_lines : 4-tuple of `.patches.ConnectionPatch`
459             The four connector lines connecting to (lower_left, upper_left,
460             lower_right upper_right) corners of *inset_ax*. Two lines are
461             set with visibility to *False*,  but the user can set the
462             visibility to True if the automatic choice is not deemed correct.
463 
464         """
465         # to make the axes connectors work, we need to apply the aspect to
466         # the parent axes.
467         self.apply_aspect()
468 
469         if transform is None:
470             transform = self.transData
471         kwargs.setdefault('label', '_indicate_inset')
472 
473         x, y, width, height = bounds
474         rectangle_patch = mpatches.Rectangle(
475             (x, y), width, height,
476             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
477             zorder=zorder, transform=transform, **kwargs)
478         self.add_patch(rectangle_patch)
479 
480         connects = []
481 
482         if inset_ax is not None:
483             # connect the inset_axes to the rectangle
484             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
485                 # inset_ax positions are in axes coordinates
486                 # The 0, 1 values define the four edges if the inset_ax
487                 # lower_left, upper_left, lower_right upper_right.
488                 ex, ey = xy_inset_ax
489                 if self.xaxis.get_inverted():
490                     ex = 1 - ex
491                 if self.yaxis.get_inverted():
492                     ey = 1 - ey
493                 xy_data = x + ex * width, y + ey * height
494                 p = mpatches.ConnectionPatch(
495                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
496                     xyB=xy_data, coordsB=self.transData,
497                     arrowstyle="-", zorder=zorder,
498                     edgecolor=edgecolor, alpha=alpha)
499                 connects.append(p)
500                 self.add_patch(p)
501 
502             # decide which two of the lines to keep visible....
503             pos = inset_ax.get_position()
504             bboxins = pos.transformed(self.figure.transSubfigure)
505             rectbbox = mtransforms.Bbox.from_bounds(
506                 *bounds
507             ).transformed(transform)
508             x0 = rectbbox.x0 < bboxins.x0
509             x1 = rectbbox.x1 < bboxins.x1
510             y0 = rectbbox.y0 < bboxins.y0
511             y1 = rectbbox.y1 < bboxins.y1
512             connects[0].set_visible(x0 ^ y0)
513             connects[1].set_visible(x0 == y1)
514             connects[2].set_visible(x1 == y0)
515             connects[3].set_visible(x1 ^ y1)
516 
517         return rectangle_patch, tuple(connects) if connects else None
518 
519     def indicate_inset_zoom(self, inset_ax, **kwargs):
520         """
521         Add an inset indicator rectangle to the Axes based on the axis
522         limits for an *inset_ax* and draw connectors between *inset_ax*
523         and the rectangle.
524 
525         Warnings
526         --------
527         This method is experimental as of 3.0, and the API may change.
528 
529         Parameters
530         ----------
531         inset_ax : `.Axes`
532             Inset Axes to draw connecting lines to.  Two lines are
533             drawn connecting the indicator box to the inset Axes on corners
534             chosen so as to not overlap with the indicator box.
535 
536         **kwargs
537             Other keyword arguments are passed on to `.Axes.indicate_inset`
538 
539         Returns
540         -------
541         rectangle_patch : `.patches.Rectangle`
542              Rectangle artist.
543 
544         connector_lines : 4-tuple of `.patches.ConnectionPatch`
545             Each of four connector lines coming from the rectangle drawn on
546             this axis, in the order lower left, upper left, lower right,
547             upper right.
548             Two are set with visibility to *False*,  but the user can
549             set the visibility to *True* if the automatic choice is not deemed
550             correct.
551         """
552 
553         xlim = inset_ax.get_xlim()
554         ylim = inset_ax.get_ylim()
555         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
556         return self.indicate_inset(rect, inset_ax, **kwargs)
557 
558     @_docstring.dedent_interpd
559     def secondary_xaxis(self, location, *, functions=None, **kwargs):
560         """
561         Add a second x-axis to this `~.axes.Axes`.
562 
563         For example if we want to have a second scale for the data plotted on
564         the xaxis.
565 
566         %(_secax_docstring)s
567 
568         Examples
569         --------
570         The main axis shows frequency, and the secondary axis shows period.
571 
572         .. plot::
573 
574             fig, ax = plt.subplots()
575             ax.loglog(range(1, 360, 5), range(1, 360, 5))
576             ax.set_xlabel('frequency [Hz]')
577 
578             def invert(x):
579                 # 1/x with special treatment of x == 0
580                 x = np.array(x).astype(float)
581                 near_zero = np.isclose(x, 0)
582                 x[near_zero] = np.inf
583                 x[~near_zero] = 1 / x[~near_zero]
584                 return x
585 
586             # the inverse of 1/x is itself
587             secax = ax.secondary_xaxis('top', functions=(invert, invert))
588             secax.set_xlabel('Period [s]')
589             plt.show()
590         """
591         if location in ['top', 'bottom'] or isinstance(location, Real):
592             secondary_ax = SecondaryAxis(self, 'x', location, functions,
593                                          **kwargs)
594             self.add_child_axes(secondary_ax)
595             return secondary_ax
596         else:
597             raise ValueError('secondary_xaxis location must be either '
598                              'a float or "top"/"bottom"')
599 
600     @_docstring.dedent_interpd
601     def secondary_yaxis(self, location, *, functions=None, **kwargs):
602         """
603         Add a second y-axis to this `~.axes.Axes`.
604 
605         For example if we want to have a second scale for the data plotted on
606         the yaxis.
607 
608         %(_secax_docstring)s
609 
610         Examples
611         --------
612         Add a secondary Axes that converts from radians to degrees
613 
614         .. plot::
615 
616             fig, ax = plt.subplots()
617             ax.plot(range(1, 360, 5), range(1, 360, 5))
618             ax.set_ylabel('degrees')
619             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
620                                                            np.rad2deg))
621             secax.set_ylabel('radians')
622         """
623         if location in ['left', 'right'] or isinstance(location, Real):
624             secondary_ax = SecondaryAxis(self, 'y', location,
625                                          functions, **kwargs)
626             self.add_child_axes(secondary_ax)
627             return secondary_ax
628         else:
629             raise ValueError('secondary_yaxis location must be either '
630                              'a float or "left"/"right"')
631 
632     @_docstring.dedent_interpd
633     def text(self, x, y, s, fontdict=None, **kwargs):
634         """
635         Add text to the Axes.
636 
637         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
638 
639         Parameters
640         ----------
641         x, y : float
642             The position to place the text. By default, this is in data
643             coordinates. The coordinate system can be changed using the
644             *transform* parameter.
645 
646         s : str
647             The text.
648 
649         fontdict : dict, default: None
650 
651             .. admonition:: Discouraged
652 
653                The use of *fontdict* is discouraged. Parameters should be passed as
654                individual keyword arguments or using dictionary-unpacking
655                ``text(..., **fontdict)``.
656 
657             A dictionary to override the default text properties. If fontdict
658             is None, the defaults are determined by `.rcParams`.
659 
660         Returns
661         -------
662         `.Text`
663             The created `.Text` instance.
664 
665         Other Parameters
666         ----------------
667         **kwargs : `~matplotlib.text.Text` properties.
668             Other miscellaneous text parameters.
669 
670             %(Text:kwdoc)s
671 
672         Examples
673         --------
674         Individual keyword arguments can be used to override any given
675         parameter::
676 
677             >>> text(x, y, s, fontsize=12)
678 
679         The default transform specifies that text is in data coords,
680         alternatively, you can specify text in axis coords ((0, 0) is
681         lower-left and (1, 1) is upper-right).  The example below places
682         text in the center of the Axes::
683 
684             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
685             ...      verticalalignment='center', transform=ax.transAxes)
686 
687         You can put a rectangular box around the text instance (e.g., to
688         set a background color) by using the keyword *bbox*.  *bbox* is
689         a dictionary of `~matplotlib.patches.Rectangle`
690         properties.  For example::
691 
692             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
693         """
694         effective_kwargs = {
695             'verticalalignment': 'baseline',
696             'horizontalalignment': 'left',
697             'transform': self.transData,
698             'clip_on': False,
699             **(fontdict if fontdict is not None else {}),
700             **kwargs,
701         }
702         t = mtext.Text(x, y, text=s, **effective_kwargs)
703         if t.get_clip_path() is None:
704             t.set_clip_path(self.patch)
705         self._add_text(t)
706         return t
707 
708     @_docstring.dedent_interpd
709     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
710                  arrowprops=None, annotation_clip=None, **kwargs):
711         # Signature must match Annotation. This is verified in
712         # test_annotate_signature().
713         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
714                              textcoords=textcoords, arrowprops=arrowprops,
715                              annotation_clip=annotation_clip, **kwargs)
716         a.set_transform(mtransforms.IdentityTransform())
717         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
718             a.set_clip_path(self.patch)
719         self._add_text(a)
720         return a
721     annotate.__doc__ = mtext.Annotation.__init__.__doc__
722     #### Lines and spans
723 
724     @_docstring.dedent_interpd
725     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
726         """
727         Add a horizontal line across the Axes.
728 
729         Parameters
730         ----------
731         y : float, default: 0
732             y position in data coordinates of the horizontal line.
733 
734         xmin : float, default: 0
735             Should be between 0 and 1, 0 being the far left of the plot, 1 the
736             far right of the plot.
737 
738         xmax : float, default: 1
739             Should be between 0 and 1, 0 being the far left of the plot, 1 the
740             far right of the plot.
741 
742         Returns
743         -------
744         `~matplotlib.lines.Line2D`
745 
746         Other Parameters
747         ----------------
748         **kwargs
749             Valid keyword arguments are `.Line2D` properties, except for
750             'transform':
751 
752             %(Line2D:kwdoc)s
753 
754         See Also
755         --------
756         hlines : Add horizontal lines in data coordinates.
757         axhspan : Add a horizontal span (rectangle) across the axis.
758         axline : Add a line with an arbitrary slope.
759 
760         Examples
761         --------
762         * draw a thick red hline at 'y' = 0 that spans the xrange::
763 
764             >>> axhline(linewidth=4, color='r')
765 
766         * draw a default hline at 'y' = 1 that spans the xrange::
767 
768             >>> axhline(y=1)
769 
770         * draw a default hline at 'y' = .5 that spans the middle half of
771           the xrange::
772 
773             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
774         """
775         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
776         if "transform" in kwargs:
777             raise ValueError("'transform' is not allowed as a keyword "
778                              "argument; axhline generates its own transform.")
779         ymin, ymax = self.get_ybound()
780 
781         # Strip away the units for comparison with non-unitized bounds.
782         yy, = self._process_unit_info([("y", y)], kwargs)
783         scaley = (yy < ymin) or (yy > ymax)
784 
785         trans = self.get_yaxis_transform(which='grid')
786         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
787         self.add_line(l)
788         if scaley:
789             self._request_autoscale_view("y")
790         return l
791 
792     @_docstring.dedent_interpd
793     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
794         """
795         Add a vertical line across the Axes.
796 
797         Parameters
798         ----------
799         x : float, default: 0
800             x position in data coordinates of the vertical line.
801 
802         ymin : float, default: 0
803             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
804             top of the plot.
805 
806         ymax : float, default: 1
807             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
808             top of the plot.
809 
810         Returns
811         -------
812         `~matplotlib.lines.Line2D`
813 
814         Other Parameters
815         ----------------
816         **kwargs
817             Valid keyword arguments are `.Line2D` properties, except for
818             'transform':
819 
820             %(Line2D:kwdoc)s
821 
822         See Also
823         --------
824         vlines : Add vertical lines in data coordinates.
825         axvspan : Add a vertical span (rectangle) across the axis.
826         axline : Add a line with an arbitrary slope.
827 
828         Examples
829         --------
830         * draw a thick red vline at *x* = 0 that spans the yrange::
831 
832             >>> axvline(linewidth=4, color='r')
833 
834         * draw a default vline at *x* = 1 that spans the yrange::
835 
836             >>> axvline(x=1)
837 
838         * draw a default vline at *x* = .5 that spans the middle half of
839           the yrange::
840 
841             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
842         """
843         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
844         if "transform" in kwargs:
845             raise ValueError("'transform' is not allowed as a keyword "
846                              "argument; axvline generates its own transform.")
847         xmin, xmax = self.get_xbound()
848 
849         # Strip away the units for comparison with non-unitized bounds.
850         xx, = self._process_unit_info([("x", x)], kwargs)
851         scalex = (xx < xmin) or (xx > xmax)
852 
853         trans = self.get_xaxis_transform(which='grid')
854         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
855         self.add_line(l)
856         if scalex:
857             self._request_autoscale_view("x")
858         return l
859 
860     @staticmethod
861     def _check_no_units(vals, names):
862         # Helper method to check that vals are not unitized
863         for val, name in zip(vals, names):
864             if not munits._is_natively_supported(val):
865                 raise ValueError(f"{name} must be a single scalar value, "
866                                  f"but got {val}")
867 
868     @_docstring.dedent_interpd
869     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
870         """
871         Add an infinitely long straight line.
872 
873         The line can be defined either by two points *xy1* and *xy2*, or
874         by one point *xy1* and a *slope*.
875 
876         This draws a straight line "on the screen", regardless of the x and y
877         scales, and is thus also suitable for drawing exponential decays in
878         semilog plots, power laws in loglog plots, etc. However, *slope*
879         should only be used with linear scales; It has no clear meaning for
880         all other scales, and thus the behavior is undefined. Please specify
881         the line using the points *xy1*, *xy2* for non-linear scales.
882 
883         The *transform* keyword argument only applies to the points *xy1*,
884         *xy2*. The *slope* (if given) is always in data coordinates. This can
885         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
886         slope.
887 
888         Parameters
889         ----------
890         xy1, xy2 : (float, float)
891             Points for the line to pass through.
892             Either *xy2* or *slope* has to be given.
893         slope : float, optional
894             The slope of the line. Either *xy2* or *slope* has to be given.
895 
896         Returns
897         -------
898         `.Line2D`
899 
900         Other Parameters
901         ----------------
902         **kwargs
903             Valid kwargs are `.Line2D` properties
904 
905             %(Line2D:kwdoc)s
906 
907         See Also
908         --------
909         axhline : for horizontal lines
910         axvline : for vertical lines
911 
912         Examples
913         --------
914         Draw a thick red line passing through (0, 0) and (1, 1)::
915 
916             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
917         """
918         if slope is not None and (self.get_xscale() != 'linear' or
919                                   self.get_yscale() != 'linear'):
920             raise TypeError("'slope' cannot be used with non-linear scales")
921 
922         datalim = [xy1] if xy2 is None else [xy1, xy2]
923         if "transform" in kwargs:
924             # if a transform is passed (i.e. line points not in data space),
925             # data limits should not be adjusted.
926             datalim = []
927 
928         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
929         # Like add_line, but correctly handling data limits.
930         self._set_artist_props(line)
931         if line.get_clip_path() is None:
932             line.set_clip_path(self.patch)
933         if not line.get_label():
934             line.set_label(f"_child{len(self._children)}")
935         self._children.append(line)
936         line._remove_method = self._children.remove
937         self.update_datalim(datalim)
938 
939         self._request_autoscale_view()
940         return line
941 
942     @_docstring.dedent_interpd
943     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
944         """
945         Add a horizontal span (rectangle) across the Axes.
946 
947         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
948         the whole x-axis horizontally.  The x-span can be set using *xmin*
949         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
950         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
951         the limits set by `~.Axes.set_xlim`.
952 
953         Parameters
954         ----------
955         ymin : float
956             Lower y-coordinate of the span, in data units.
957         ymax : float
958             Upper y-coordinate of the span, in data units.
959         xmin : float, default: 0
960             Lower x-coordinate of the span, in x-axis (0-1) units.
961         xmax : float, default: 1
962             Upper x-coordinate of the span, in x-axis (0-1) units.
963 
964         Returns
965         -------
966         `~matplotlib.patches.Polygon`
967             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
968 
969         Other Parameters
970         ----------------
971         **kwargs : `~matplotlib.patches.Polygon` properties
972 
973         %(Polygon:kwdoc)s
974 
975         See Also
976         --------
977         axvspan : Add a vertical span across the Axes.
978         """
979         # Strip units away.
980         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
981         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
982 
983         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
984         p = mpatches.Polygon(verts, **kwargs)
985         p.set_transform(self.get_yaxis_transform(which="grid"))
986         self.add_patch(p)
987         self._request_autoscale_view("y")
988         return p
989 
990     @_docstring.dedent_interpd
991     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
992         """
993         Add a vertical span (rectangle) across the Axes.
994 
995         The rectangle spans from *xmin* to *xmax* horizontally, and, by
996         default, the whole y-axis vertically.  The y-span can be set using
997         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
998         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
999         regardless of the limits set by `~.Axes.set_ylim`.
1000 
1001         Parameters
1002         ----------
1003         xmin : float
1004             Lower x-coordinate of the span, in data units.
1005         xmax : float
1006             Upper x-coordinate of the span, in data units.
1007         ymin : float, default: 0
1008             Lower y-coordinate of the span, in y-axis units (0-1).
1009         ymax : float, default: 1
1010             Upper y-coordinate of the span, in y-axis units (0-1).
1011 
1012         Returns
1013         -------
1014         `~matplotlib.patches.Polygon`
1015             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1016 
1017         Other Parameters
1018         ----------------
1019         **kwargs : `~matplotlib.patches.Polygon` properties
1020 
1021         %(Polygon:kwdoc)s
1022 
1023         See Also
1024         --------
1025         axhspan : Add a horizontal span across the Axes.
1026 
1027         Examples
1028         --------
1029         Draw a vertical, green, translucent rectangle from x = 1.25 to
1030         x = 1.55 that spans the yrange of the Axes.
1031 
1032         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1033 
1034         """
1035         # Strip units away.
1036         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1037         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1038 
1039         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1040         p = mpatches.Polygon(verts, **kwargs)
1041         p.set_transform(self.get_xaxis_transform(which="grid"))
1042         p.get_path()._interpolation_steps = 100
1043         self.add_patch(p)
1044         self._request_autoscale_view("x")
1045         return p
1046 
1047     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1048                       label_namer="y")
1049     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1050                label='', **kwargs):
1051         """
1052         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1053 
1054         Parameters
1055         ----------
1056         y : float or array-like
1057             y-indexes where to plot the lines.
1058 
1059         xmin, xmax : float or array-like
1060             Respective beginning and end of each line. If scalars are
1061             provided, all lines will have the same length.
1062 
1063         colors : color or list of colors, default: :rc:`lines.color`
1064 
1065         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1066 
1067         label : str, default: ''
1068 
1069         Returns
1070         -------
1071         `~matplotlib.collections.LineCollection`
1072 
1073         Other Parameters
1074         ----------------
1075         data : indexable object, optional
1076             DATA_PARAMETER_PLACEHOLDER
1077         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1078 
1079         See Also
1080         --------
1081         vlines : vertical lines
1082         axhline : horizontal line across the Axes
1083         """
1084 
1085         # We do the conversion first since not all unitized data is uniform
1086         xmin, xmax, y = self._process_unit_info(
1087             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1088 
1089         if not np.iterable(y):
1090             y = [y]
1091         if not np.iterable(xmin):
1092             xmin = [xmin]
1093         if not np.iterable(xmax):
1094             xmax = [xmax]
1095 
1096         # Create and combine masked_arrays from input
1097         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1098         y = np.ravel(y)
1099         xmin = np.ravel(xmin)
1100         xmax = np.ravel(xmax)
1101 
1102         masked_verts = np.ma.empty((len(y), 2, 2))
1103         masked_verts[:, 0, 0] = xmin
1104         masked_verts[:, 0, 1] = y
1105         masked_verts[:, 1, 0] = xmax
1106         masked_verts[:, 1, 1] = y
1107 
1108         lines = mcoll.LineCollection(masked_verts, colors=colors,
1109                                      linestyles=linestyles, label=label)
1110         self.add_collection(lines, autolim=False)
1111         lines._internal_update(kwargs)
1112 
1113         if len(y) > 0:
1114             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1115             # the case of y being a masked *object* array (as can be generated
1116             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1117             updatex = True
1118             updatey = True
1119             if self.name == "rectilinear":
1120                 datalim = lines.get_datalim(self.transData)
1121                 t = lines.get_transform()
1122                 updatex, updatey = t.contains_branch_seperately(self.transData)
1123                 minx = np.nanmin(datalim.xmin)
1124                 maxx = np.nanmax(datalim.xmax)
1125                 miny = np.nanmin(datalim.ymin)
1126                 maxy = np.nanmax(datalim.ymax)
1127             else:
1128                 minx = np.nanmin(masked_verts[..., 0])
1129                 maxx = np.nanmax(masked_verts[..., 0])
1130                 miny = np.nanmin(masked_verts[..., 1])
1131                 maxy = np.nanmax(masked_verts[..., 1])
1132 
1133             corners = (minx, miny), (maxx, maxy)
1134             self.update_datalim(corners, updatex, updatey)
1135             self._request_autoscale_view()
1136         return lines
1137 
1138     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1139                       label_namer="x")
1140     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1141                label='', **kwargs):
1142         """
1143         Plot vertical lines at each *x* from *ymin* to *ymax*.
1144 
1145         Parameters
1146         ----------
1147         x : float or array-like
1148             x-indexes where to plot the lines.
1149 
1150         ymin, ymax : float or array-like
1151             Respective beginning and end of each line. If scalars are
1152             provided, all lines will have the same length.
1153 
1154         colors : color or list of colors, default: :rc:`lines.color`
1155 
1156         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1157 
1158         label : str, default: ''
1159 
1160         Returns
1161         -------
1162         `~matplotlib.collections.LineCollection`
1163 
1164         Other Parameters
1165         ----------------
1166         data : indexable object, optional
1167             DATA_PARAMETER_PLACEHOLDER
1168         **kwargs : `~matplotlib.collections.LineCollection` properties.
1169 
1170         See Also
1171         --------
1172         hlines : horizontal lines
1173         axvline : vertical line across the Axes
1174         """
1175 
1176         # We do the conversion first since not all unitized data is uniform
1177         x, ymin, ymax = self._process_unit_info(
1178             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1179 
1180         if not np.iterable(x):
1181             x = [x]
1182         if not np.iterable(ymin):
1183             ymin = [ymin]
1184         if not np.iterable(ymax):
1185             ymax = [ymax]
1186 
1187         # Create and combine masked_arrays from input
1188         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1189         x = np.ravel(x)
1190         ymin = np.ravel(ymin)
1191         ymax = np.ravel(ymax)
1192 
1193         masked_verts = np.ma.empty((len(x), 2, 2))
1194         masked_verts[:, 0, 0] = x
1195         masked_verts[:, 0, 1] = ymin
1196         masked_verts[:, 1, 0] = x
1197         masked_verts[:, 1, 1] = ymax
1198 
1199         lines = mcoll.LineCollection(masked_verts, colors=colors,
1200                                      linestyles=linestyles, label=label)
1201         self.add_collection(lines, autolim=False)
1202         lines._internal_update(kwargs)
1203 
1204         if len(x) > 0:
1205             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1206             # the case of x being a masked *object* array (as can be generated
1207             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1208             updatex = True
1209             updatey = True
1210             if self.name == "rectilinear":
1211                 datalim = lines.get_datalim(self.transData)
1212                 t = lines.get_transform()
1213                 updatex, updatey = t.contains_branch_seperately(self.transData)
1214                 minx = np.nanmin(datalim.xmin)
1215                 maxx = np.nanmax(datalim.xmax)
1216                 miny = np.nanmin(datalim.ymin)
1217                 maxy = np.nanmax(datalim.ymax)
1218             else:
1219                 minx = np.nanmin(masked_verts[..., 0])
1220                 maxx = np.nanmax(masked_verts[..., 0])
1221                 miny = np.nanmin(masked_verts[..., 1])
1222                 maxy = np.nanmax(masked_verts[..., 1])
1223 
1224             corners = (minx, miny), (maxx, maxy)
1225             self.update_datalim(corners, updatex, updatey)
1226             self._request_autoscale_view()
1227         return lines
1228 
1229     @_preprocess_data(replace_names=["positions", "lineoffsets",
1230                                      "linelengths", "linewidths",
1231                                      "colors", "linestyles"])
1232     @_docstring.dedent_interpd
1233     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1234                   linelengths=1, linewidths=None, colors=None, alpha=None,
1235                   linestyles='solid', **kwargs):
1236         """
1237         Plot identical parallel lines at the given positions.
1238 
1239         This type of plot is commonly used in neuroscience for representing
1240         neural events, where it is usually called a spike raster, dot raster,
1241         or raster plot.
1242 
1243         However, it is useful in any situation where you wish to show the
1244         timing or position of multiple sets of discrete events, such as the
1245         arrival times of people to a business on each day of the month or the
1246         date of hurricanes each year of the last century.
1247 
1248         Parameters
1249         ----------
1250         positions : array-like or list of array-like
1251             A 1D array-like defines the positions of one sequence of events.
1252 
1253             Multiple groups of events may be passed as a list of array-likes.
1254             Each group can be styled independently by passing lists of values
1255             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1256             *linestyles*.
1257 
1258             Note that *positions* can be a 2D array, but in practice different
1259             event groups usually have different counts so that one will use a
1260             list of different-length arrays rather than a 2D array.
1261 
1262         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1263             The direction of the event sequence:
1264 
1265             - 'horizontal': the events are arranged horizontally.
1266               The indicator lines are vertical.
1267             - 'vertical': the events are arranged vertically.
1268               The indicator lines are horizontal.
1269 
1270         lineoffsets : float or array-like, default: 1
1271             The offset of the center of the lines from the origin, in the
1272             direction orthogonal to *orientation*.
1273 
1274             If *positions* is 2D, this can be a sequence with length matching
1275             the length of *positions*.
1276 
1277         linelengths : float or array-like, default: 1
1278             The total height of the lines (i.e. the lines stretches from
1279             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1280 
1281             If *positions* is 2D, this can be a sequence with length matching
1282             the length of *positions*.
1283 
1284         linewidths : float or array-like, default: :rc:`lines.linewidth`
1285             The line width(s) of the event lines, in points.
1286 
1287             If *positions* is 2D, this can be a sequence with length matching
1288             the length of *positions*.
1289 
1290         colors : color or list of colors, default: :rc:`lines.color`
1291             The color(s) of the event lines.
1292 
1293             If *positions* is 2D, this can be a sequence with length matching
1294             the length of *positions*.
1295 
1296         alpha : float or array-like, default: 1
1297             The alpha blending value(s), between 0 (transparent) and 1
1298             (opaque).
1299 
1300             If *positions* is 2D, this can be a sequence with length matching
1301             the length of *positions*.
1302 
1303         linestyles : str or tuple or list of such values, default: 'solid'
1304             Default is 'solid'. Valid strings are ['solid', 'dashed',
1305             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1306             should be of the form::
1307 
1308                 (offset, onoffseq),
1309 
1310             where *onoffseq* is an even length tuple of on and off ink
1311             in points.
1312 
1313             If *positions* is 2D, this can be a sequence with length matching
1314             the length of *positions*.
1315 
1316         data : indexable object, optional
1317             DATA_PARAMETER_PLACEHOLDER
1318 
1319         **kwargs
1320             Other keyword arguments are line collection properties.  See
1321             `.LineCollection` for a list of the valid properties.
1322 
1323         Returns
1324         -------
1325         list of `.EventCollection`
1326             The `.EventCollection` that were added.
1327 
1328         Notes
1329         -----
1330         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1331         only a single value is given, that value is applied to all lines. If an
1332         array-like is given, it must have the same length as *positions*, and
1333         each value will be applied to the corresponding row of the array.
1334 
1335         Examples
1336         --------
1337         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1338         """
1339 
1340         lineoffsets, linelengths = self._process_unit_info(
1341                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1342 
1343         # fix positions, noting that it can be a list of lists:
1344         if not np.iterable(positions):
1345             positions = [positions]
1346         elif any(np.iterable(position) for position in positions):
1347             positions = [np.asanyarray(position) for position in positions]
1348         else:
1349             positions = [np.asanyarray(positions)]
1350 
1351         poss = []
1352         for position in positions:
1353             poss += self._process_unit_info([("x", position)], kwargs)
1354         positions = poss
1355 
1356         # prevent 'singular' keys from **kwargs dict from overriding the effect
1357         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1358         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1359         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1360         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1361 
1362         if not np.iterable(lineoffsets):
1363             lineoffsets = [lineoffsets]
1364         if not np.iterable(linelengths):
1365             linelengths = [linelengths]
1366         if not np.iterable(linewidths):
1367             linewidths = [linewidths]
1368         if not np.iterable(colors):
1369             colors = [colors]
1370         if not np.iterable(alpha):
1371             alpha = [alpha]
1372         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1373             linestyles = [linestyles]
1374 
1375         lineoffsets = np.asarray(lineoffsets)
1376         linelengths = np.asarray(linelengths)
1377         linewidths = np.asarray(linewidths)
1378 
1379         if len(lineoffsets) == 0:
1380             raise ValueError('lineoffsets cannot be empty')
1381         if len(linelengths) == 0:
1382             raise ValueError('linelengths cannot be empty')
1383         if len(linestyles) == 0:
1384             raise ValueError('linestyles cannot be empty')
1385         if len(linewidths) == 0:
1386             raise ValueError('linewidths cannot be empty')
1387         if len(alpha) == 0:
1388             raise ValueError('alpha cannot be empty')
1389         if len(colors) == 0:
1390             colors = [None]
1391         try:
1392             # Early conversion of the colors into RGBA values to take care
1393             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1394             colors = mcolors.to_rgba_array(colors)
1395         except ValueError:
1396             # Will fail if any element of *colors* is None. But as long
1397             # as len(colors) == 1 or len(positions), the rest of the
1398             # code should process *colors* properly.
1399             pass
1400 
1401         if len(lineoffsets) == 1 and len(positions) != 1:
1402             lineoffsets = np.tile(lineoffsets, len(positions))
1403             lineoffsets[0] = 0
1404             lineoffsets = np.cumsum(lineoffsets)
1405         if len(linelengths) == 1:
1406             linelengths = np.tile(linelengths, len(positions))
1407         if len(linewidths) == 1:
1408             linewidths = np.tile(linewidths, len(positions))
1409         if len(colors) == 1:
1410             colors = list(colors) * len(positions)
1411         if len(alpha) == 1:
1412             alpha = list(alpha) * len(positions)
1413         if len(linestyles) == 1:
1414             linestyles = [linestyles] * len(positions)
1415 
1416         if len(lineoffsets) != len(positions):
1417             raise ValueError('lineoffsets and positions are unequal sized '
1418                              'sequences')
1419         if len(linelengths) != len(positions):
1420             raise ValueError('linelengths and positions are unequal sized '
1421                              'sequences')
1422         if len(linewidths) != len(positions):
1423             raise ValueError('linewidths and positions are unequal sized '
1424                              'sequences')
1425         if len(colors) != len(positions):
1426             raise ValueError('colors and positions are unequal sized '
1427                              'sequences')
1428         if len(alpha) != len(positions):
1429             raise ValueError('alpha and positions are unequal sized '
1430                              'sequences')
1431         if len(linestyles) != len(positions):
1432             raise ValueError('linestyles and positions are unequal sized '
1433                              'sequences')
1434 
1435         colls = []
1436         for position, lineoffset, linelength, linewidth, color, alpha_, \
1437             linestyle in \
1438                 zip(positions, lineoffsets, linelengths, linewidths,
1439                     colors, alpha, linestyles):
1440             coll = mcoll.EventCollection(position,
1441                                          orientation=orientation,
1442                                          lineoffset=lineoffset,
1443                                          linelength=linelength,
1444                                          linewidth=linewidth,
1445                                          color=color,
1446                                          alpha=alpha_,
1447                                          linestyle=linestyle)
1448             self.add_collection(coll, autolim=False)
1449             coll._internal_update(kwargs)
1450             colls.append(coll)
1451 
1452         if len(positions) > 0:
1453             # try to get min/max
1454             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1455                        if len(_p) > 0]
1456             # if we have any non-empty positions, try to autoscale
1457             if len(min_max) > 0:
1458                 mins, maxes = zip(*min_max)
1459                 minpos = np.min(mins)
1460                 maxpos = np.max(maxes)
1461 
1462                 minline = (lineoffsets - linelengths).min()
1463                 maxline = (lineoffsets + linelengths).max()
1464 
1465                 if orientation == "vertical":
1466                     corners = (minline, minpos), (maxline, maxpos)
1467                 else:  # "horizontal"
1468                     corners = (minpos, minline), (maxpos, maxline)
1469                 self.update_datalim(corners)
1470                 self._request_autoscale_view()
1471 
1472         return colls
1473 
1474     #### Basic plotting
1475 
1476     # Uses a custom implementation of data-kwarg handling in
1477     # _process_plot_var_args.
1478     @_docstring.dedent_interpd
1479     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1480         """
1481         Plot y versus x as lines and/or markers.
1482 
1483         Call signatures::
1484 
1485             plot([x], y, [fmt], *, data=None, **kwargs)
1486             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1487 
1488         The coordinates of the points or line nodes are given by *x*, *y*.
1489 
1490         The optional parameter *fmt* is a convenient way for defining basic
1491         formatting like color, marker and linestyle. It's a shortcut string
1492         notation described in the *Notes* section below.
1493 
1494         >>> plot(x, y)        # plot x and y using default line style and color
1495         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1496         >>> plot(y)           # plot y using x as index array 0..N-1
1497         >>> plot(y, 'r+')     # ditto, but with red plusses
1498 
1499         You can use `.Line2D` properties as keyword arguments for more
1500         control on the appearance. Line properties and *fmt* can be mixed.
1501         The following two calls yield identical results:
1502 
1503         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1504         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1505         ...      linewidth=2, markersize=12)
1506 
1507         When conflicting with *fmt*, keyword arguments take precedence.
1508 
1509 
1510         **Plotting labelled data**
1511 
1512         There's a convenient way for plotting objects with labelled data (i.e.
1513         data that can be accessed by index ``obj['y']``). Instead of giving
1514         the data in *x* and *y*, you can provide the object in the *data*
1515         parameter and just give the labels for *x* and *y*::
1516 
1517         >>> plot('xlabel', 'ylabel', data=obj)
1518 
1519         All indexable objects are supported. This could e.g. be a `dict`, a
1520         `pandas.DataFrame` or a structured numpy array.
1521 
1522 
1523         **Plotting multiple sets of data**
1524 
1525         There are various ways to plot multiple sets of data.
1526 
1527         - The most straight forward way is just to call `plot` multiple times.
1528           Example:
1529 
1530           >>> plot(x1, y1, 'bo')
1531           >>> plot(x2, y2, 'go')
1532 
1533         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1534           for every column. If both *x* and *y* are 2D, they must have the
1535           same shape. If only one of them is 2D with shape (N, m) the other
1536           must have length N and will be used for every data set m.
1537 
1538           Example:
1539 
1540           >>> x = [1, 2, 3]
1541           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1542           >>> plot(x, y)
1543 
1544           is equivalent to:
1545 
1546           >>> for col in range(y.shape[1]):
1547           ...     plot(x, y[:, col])
1548 
1549         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1550           groups::
1551 
1552           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1553 
1554           In this case, any additional keyword argument applies to all
1555           datasets. Also, this syntax cannot be combined with the *data*
1556           parameter.
1557 
1558         By default, each line is assigned a different style specified by a
1559         'style cycle'. The *fmt* and line property parameters are only
1560         necessary if you want explicit deviations from these defaults.
1561         Alternatively, you can also change the style cycle using
1562         :rc:`axes.prop_cycle`.
1563 
1564 
1565         Parameters
1566         ----------
1567         x, y : array-like or scalar
1568             The horizontal / vertical coordinates of the data points.
1569             *x* values are optional and default to ``range(len(y))``.
1570 
1571             Commonly, these parameters are 1D arrays.
1572 
1573             They can also be scalars, or two-dimensional (in that case, the
1574             columns represent separate data sets).
1575 
1576             These arguments cannot be passed as keywords.
1577 
1578         fmt : str, optional
1579             A format string, e.g. 'ro' for red circles. See the *Notes*
1580             section for a full description of the format strings.
1581 
1582             Format strings are just an abbreviation for quickly setting
1583             basic line properties. All of these and more can also be
1584             controlled by keyword arguments.
1585 
1586             This argument cannot be passed as keyword.
1587 
1588         data : indexable object, optional
1589             An object with labelled data. If given, provide the label names to
1590             plot in *x* and *y*.
1591 
1592             .. note::
1593                 Technically there's a slight ambiguity in calls where the
1594                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1595                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1596                 the former interpretation is chosen, but a warning is issued.
1597                 You may suppress the warning by adding an empty format string
1598                 ``plot('n', 'o', '', data=obj)``.
1599 
1600         Returns
1601         -------
1602         list of `.Line2D`
1603             A list of lines representing the plotted data.
1604 
1605         Other Parameters
1606         ----------------
1607         scalex, scaley : bool, default: True
1608             These parameters determine if the view limits are adapted to the
1609             data limits. The values are passed on to
1610             `~.axes.Axes.autoscale_view`.
1611 
1612         **kwargs : `.Line2D` properties, optional
1613             *kwargs* are used to specify properties like a line label (for
1614             auto legends), linewidth, antialiasing, marker face color.
1615             Example::
1616 
1617             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1618             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1619 
1620             If you specify multiple lines with one plot call, the kwargs apply
1621             to all those lines. In case the label object is iterable, each
1622             element is used as labels for each set of data.
1623 
1624             Here is a list of available `.Line2D` properties:
1625 
1626             %(Line2D:kwdoc)s
1627 
1628         See Also
1629         --------
1630         scatter : XY scatter plot with markers of varying size and/or color (
1631             sometimes also called bubble chart).
1632 
1633         Notes
1634         -----
1635         **Format Strings**
1636 
1637         A format string consists of a part for color, marker and line::
1638 
1639             fmt = '[marker][line][color]'
1640 
1641         Each of them is optional. If not provided, the value from the style
1642         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1643         the data will be a line without markers.
1644 
1645         Other combinations such as ``[color][marker][line]`` are also
1646         supported, but note that their parsing may be ambiguous.
1647 
1648         **Markers**
1649 
1650         =============   ===============================
1651         character       description
1652         =============   ===============================
1653         ``'.'``         point marker
1654         ``','``         pixel marker
1655         ``'o'``         circle marker
1656         ``'v'``         triangle_down marker
1657         ``'^'``         triangle_up marker
1658         ``'<'``         triangle_left marker
1659         ``'>'``         triangle_right marker
1660         ``'1'``         tri_down marker
1661         ``'2'``         tri_up marker
1662         ``'3'``         tri_left marker
1663         ``'4'``         tri_right marker
1664         ``'8'``         octagon marker
1665         ``'s'``         square marker
1666         ``'p'``         pentagon marker
1667         ``'P'``         plus (filled) marker
1668         ``'*'``         star marker
1669         ``'h'``         hexagon1 marker
1670         ``'H'``         hexagon2 marker
1671         ``'+'``         plus marker
1672         ``'x'``         x marker
1673         ``'X'``         x (filled) marker
1674         ``'D'``         diamond marker
1675         ``'d'``         thin_diamond marker
1676         ``'|'``         vline marker
1677         ``'_'``         hline marker
1678         =============   ===============================
1679 
1680         **Line Styles**
1681 
1682         =============    ===============================
1683         character        description
1684         =============    ===============================
1685         ``'-'``          solid line style
1686         ``'--'``         dashed line style
1687         ``'-.'``         dash-dot line style
1688         ``':'``          dotted line style
1689         =============    ===============================
1690 
1691         Example format strings::
1692 
1693             'b'    # blue markers with default shape
1694             'or'   # red circles
1695             '-g'   # green solid line
1696             '--'   # dashed line with default color
1697             '^k:'  # black triangle_up markers connected by a dotted line
1698 
1699         **Colors**
1700 
1701         The supported color abbreviations are the single letter codes
1702 
1703         =============    ===============================
1704         character        color
1705         =============    ===============================
1706         ``'b'``          blue
1707         ``'g'``          green
1708         ``'r'``          red
1709         ``'c'``          cyan
1710         ``'m'``          magenta
1711         ``'y'``          yellow
1712         ``'k'``          black
1713         ``'w'``          white
1714         =============    ===============================
1715 
1716         and the ``'CN'`` colors that index into the default property cycle.
1717 
1718         If the color is the only part of the format string, you can
1719         additionally use any  `matplotlib.colors` spec, e.g. full names
1720         (``'green'``) or hex strings (``'#008000'``).
1721         """
1722         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1723         lines = [*self._get_lines(*args, data=data, **kwargs)]
1724         for line in lines:
1725             self.add_line(line)
1726         if scalex:
1727             self._request_autoscale_view("x")
1728         if scaley:
1729             self._request_autoscale_view("y")
1730         return lines
1731 
1732     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1733     @_docstring.dedent_interpd
1734     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1735                   **kwargs):
1736         """
1737         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1738 
1739         .. admonition:: Discouraged
1740 
1741             This method exists for historic reasons and will be deprecated in
1742             the future.
1743 
1744             - ``datetime``-like data should directly be plotted using
1745               `~.Axes.plot`.
1746             -  If you need to plot plain numeric data as :ref:`date-format` or
1747                need to set a timezone, call ``ax.xaxis.axis_date`` /
1748                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1749                `.Axis.axis_date`.
1750 
1751         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1752         However, the axis labels are formatted as dates depending on *xdate*
1753         and *ydate*.  Note that `.plot` will work with `datetime` and
1754         `numpy.datetime64` objects without resorting to this method.
1755 
1756         Parameters
1757         ----------
1758         x, y : array-like
1759             The coordinates of the data points. If *xdate* or *ydate* is
1760             *True*, the respective values *x* or *y* are interpreted as
1761             :ref:`Matplotlib dates <date-format>`.
1762 
1763         fmt : str, optional
1764             The plot format string. For details, see the corresponding
1765             parameter in `.plot`.
1766 
1767         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1768             The time zone to use in labeling dates.
1769 
1770         xdate : bool, default: True
1771             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1772 
1773         ydate : bool, default: False
1774             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1775 
1776         Returns
1777         -------
1778         list of `.Line2D`
1779             Objects representing the plotted data.
1780 
1781         Other Parameters
1782         ----------------
1783         data : indexable object, optional
1784             DATA_PARAMETER_PLACEHOLDER
1785         **kwargs
1786             Keyword arguments control the `.Line2D` properties:
1787 
1788             %(Line2D:kwdoc)s
1789 
1790         See Also
1791         --------
1792         matplotlib.dates : Helper functions on dates.
1793         matplotlib.dates.date2num : Convert dates to num.
1794         matplotlib.dates.num2date : Convert num to dates.
1795         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1796 
1797         Notes
1798         -----
1799         If you are using custom date tickers and formatters, it may be
1800         necessary to set the formatters/locators after the call to
1801         `.plot_date`. `.plot_date` will set the default tick locator to
1802         `.AutoDateLocator` (if the tick locator is not already set to a
1803         `.DateLocator` instance) and the default tick formatter to
1804         `.AutoDateFormatter` (if the tick formatter is not already set to a
1805         `.DateFormatter` instance).
1806         """
1807         if xdate:
1808             self.xaxis_date(tz)
1809         if ydate:
1810             self.yaxis_date(tz)
1811         return self.plot(x, y, fmt, **kwargs)
1812 
1813     # @_preprocess_data() # let 'plot' do the unpacking..
1814     @_docstring.dedent_interpd
1815     def loglog(self, *args, **kwargs):
1816         """
1817         Make a plot with log scaling on both the x- and y-axis.
1818 
1819         Call signatures::
1820 
1821             loglog([x], y, [fmt], data=None, **kwargs)
1822             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1823 
1824         This is just a thin wrapper around `.plot` which additionally changes
1825         both the x-axis and the y-axis to log scaling. All the concepts and
1826         parameters of plot can be used here as well.
1827 
1828         The additional parameters *base*, *subs* and *nonpositive* control the
1829         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1830         `.Axes.set_yscale`. To use different properties on the x-axis and the
1831         y-axis, use e.g.
1832         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1833 
1834         Parameters
1835         ----------
1836         base : float, default: 10
1837             Base of the logarithm.
1838 
1839         subs : sequence, optional
1840             The location of the minor ticks. If *None*, reasonable locations
1841             are automatically chosen depending on the number of decades in the
1842             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1843 
1844         nonpositive : {'mask', 'clip'}, default: 'clip'
1845             Non-positive values can be masked as invalid, or clipped to a very
1846             small positive number.
1847 
1848         **kwargs
1849             All parameters supported by `.plot`.
1850 
1851         Returns
1852         -------
1853         list of `.Line2D`
1854             Objects representing the plotted data.
1855         """
1856         dx = {k: v for k, v in kwargs.items()
1857               if k in ['base', 'subs', 'nonpositive',
1858                        'basex', 'subsx', 'nonposx']}
1859         self.set_xscale('log', **dx)
1860         dy = {k: v for k, v in kwargs.items()
1861               if k in ['base', 'subs', 'nonpositive',
1862                        'basey', 'subsy', 'nonposy']}
1863         self.set_yscale('log', **dy)
1864         return self.plot(
1865             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1866 
1867     # @_preprocess_data() # let 'plot' do the unpacking..
1868     @_docstring.dedent_interpd
1869     def semilogx(self, *args, **kwargs):
1870         """
1871         Make a plot with log scaling on the x-axis.
1872 
1873         Call signatures::
1874 
1875             semilogx([x], y, [fmt], data=None, **kwargs)
1876             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1877 
1878         This is just a thin wrapper around `.plot` which additionally changes
1879         the x-axis to log scaling. All the concepts and parameters of plot can
1880         be used here as well.
1881 
1882         The additional parameters *base*, *subs*, and *nonpositive* control the
1883         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1884 
1885         Parameters
1886         ----------
1887         base : float, default: 10
1888             Base of the x logarithm.
1889 
1890         subs : array-like, optional
1891             The location of the minor xticks. If *None*, reasonable locations
1892             are automatically chosen depending on the number of decades in the
1893             plot. See `.Axes.set_xscale` for details.
1894 
1895         nonpositive : {'mask', 'clip'}, default: 'mask'
1896             Non-positive values in x can be masked as invalid, or clipped to a
1897             very small positive number.
1898 
1899         **kwargs
1900             All parameters supported by `.plot`.
1901 
1902         Returns
1903         -------
1904         list of `.Line2D`
1905             Objects representing the plotted data.
1906         """
1907         d = {k: v for k, v in kwargs.items()
1908              if k in ['base', 'subs', 'nonpositive',
1909                       'basex', 'subsx', 'nonposx']}
1910         self.set_xscale('log', **d)
1911         return self.plot(
1912             *args, **{k: v for k, v in kwargs.items() if k not in d})
1913 
1914     # @_preprocess_data() # let 'plot' do the unpacking..
1915     @_docstring.dedent_interpd
1916     def semilogy(self, *args, **kwargs):
1917         """
1918         Make a plot with log scaling on the y-axis.
1919 
1920         Call signatures::
1921 
1922             semilogy([x], y, [fmt], data=None, **kwargs)
1923             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1924 
1925         This is just a thin wrapper around `.plot` which additionally changes
1926         the y-axis to log scaling. All the concepts and parameters of plot can
1927         be used here as well.
1928 
1929         The additional parameters *base*, *subs*, and *nonpositive* control the
1930         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1931 
1932         Parameters
1933         ----------
1934         base : float, default: 10
1935             Base of the y logarithm.
1936 
1937         subs : array-like, optional
1938             The location of the minor yticks. If *None*, reasonable locations
1939             are automatically chosen depending on the number of decades in the
1940             plot. See `.Axes.set_yscale` for details.
1941 
1942         nonpositive : {'mask', 'clip'}, default: 'mask'
1943             Non-positive values in y can be masked as invalid, or clipped to a
1944             very small positive number.
1945 
1946         **kwargs
1947             All parameters supported by `.plot`.
1948 
1949         Returns
1950         -------
1951         list of `.Line2D`
1952             Objects representing the plotted data.
1953         """
1954         d = {k: v for k, v in kwargs.items()
1955              if k in ['base', 'subs', 'nonpositive',
1956                       'basey', 'subsy', 'nonposy']}
1957         self.set_yscale('log', **d)
1958         return self.plot(
1959             *args, **{k: v for k, v in kwargs.items() if k not in d})
1960 
1961     @_preprocess_data(replace_names=["x"], label_namer="x")
1962     def acorr(self, x, **kwargs):
1963         """
1964         Plot the autocorrelation of *x*.
1965 
1966         Parameters
1967         ----------
1968         x : array-like
1969 
1970         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1971             A detrending function applied to *x*.  It must have the
1972             signature ::
1973 
1974                 detrend(x: np.ndarray) -> np.ndarray
1975 
1976         normed : bool, default: True
1977             If ``True``, input vectors are normalised to unit length.
1978 
1979         usevlines : bool, default: True
1980             Determines the plot style.
1981 
1982             If ``True``, vertical lines are plotted from 0 to the acorr value
1983             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1984             at y=0 using `.Axes.axhline`.
1985 
1986             If ``False``, markers are plotted at the acorr values using
1987             `.Axes.plot`.
1988 
1989         maxlags : int, default: 10
1990             Number of lags to show. If ``None``, will return all
1991             ``2 * len(x) - 1`` lags.
1992 
1993         Returns
1994         -------
1995         lags : array (length ``2*maxlags+1``)
1996             The lag vector.
1997         c : array  (length ``2*maxlags+1``)
1998             The auto correlation vector.
1999         line : `.LineCollection` or `.Line2D`
2000             `.Artist` added to the Axes of the correlation:
2001 
2002             - `.LineCollection` if *usevlines* is True.
2003             - `.Line2D` if *usevlines* is False.
2004         b : `.Line2D` or None
2005             Horizontal line at 0 if *usevlines* is True
2006             None *usevlines* is False.
2007 
2008         Other Parameters
2009         ----------------
2010         linestyle : `.Line2D` property, optional
2011             The linestyle for plotting the data points.
2012             Only used if *usevlines* is ``False``.
2013 
2014         marker : str, default: 'o'
2015             The marker for plotting the data points.
2016             Only used if *usevlines* is ``False``.
2017 
2018         data : indexable object, optional
2019             DATA_PARAMETER_PLACEHOLDER
2020 
2021         **kwargs
2022             Additional parameters are passed to `.Axes.vlines` and
2023             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2024             passed to `.Axes.plot`.
2025 
2026         Notes
2027         -----
2028         The cross correlation is performed with `numpy.correlate` with
2029         ``mode = "full"``.
2030         """
2031         return self.xcorr(x, x, **kwargs)
2032 
2033     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2034     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2035               usevlines=True, maxlags=10, **kwargs):
2036         r"""
2037         Plot the cross correlation between *x* and *y*.
2038 
2039         The correlation with lag k is defined as
2040         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2041         conjugate of :math:`y`.
2042 
2043         Parameters
2044         ----------
2045         x, y : array-like of length n
2046 
2047         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2048             A detrending function applied to *x* and *y*.  It must have the
2049             signature ::
2050 
2051                 detrend(x: np.ndarray) -> np.ndarray
2052 
2053         normed : bool, default: True
2054             If ``True``, input vectors are normalised to unit length.
2055 
2056         usevlines : bool, default: True
2057             Determines the plot style.
2058 
2059             If ``True``, vertical lines are plotted from 0 to the xcorr value
2060             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2061             at y=0 using `.Axes.axhline`.
2062 
2063             If ``False``, markers are plotted at the xcorr values using
2064             `.Axes.plot`.
2065 
2066         maxlags : int, default: 10
2067             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2068             lags.
2069 
2070         Returns
2071         -------
2072         lags : array (length ``2*maxlags+1``)
2073             The lag vector.
2074         c : array  (length ``2*maxlags+1``)
2075             The auto correlation vector.
2076         line : `.LineCollection` or `.Line2D`
2077             `.Artist` added to the Axes of the correlation:
2078 
2079             - `.LineCollection` if *usevlines* is True.
2080             - `.Line2D` if *usevlines* is False.
2081         b : `.Line2D` or None
2082             Horizontal line at 0 if *usevlines* is True
2083             None *usevlines* is False.
2084 
2085         Other Parameters
2086         ----------------
2087         linestyle : `.Line2D` property, optional
2088             The linestyle for plotting the data points.
2089             Only used if *usevlines* is ``False``.
2090 
2091         marker : str, default: 'o'
2092             The marker for plotting the data points.
2093             Only used if *usevlines* is ``False``.
2094 
2095         data : indexable object, optional
2096             DATA_PARAMETER_PLACEHOLDER
2097 
2098         **kwargs
2099             Additional parameters are passed to `.Axes.vlines` and
2100             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2101             passed to `.Axes.plot`.
2102 
2103         Notes
2104         -----
2105         The cross correlation is performed with `numpy.correlate` with
2106         ``mode = "full"``.
2107         """
2108         Nx = len(x)
2109         if Nx != len(y):
2110             raise ValueError('x and y must be equal length')
2111 
2112         x = detrend(np.asarray(x))
2113         y = detrend(np.asarray(y))
2114 
2115         correls = np.correlate(x, y, mode="full")
2116 
2117         if normed:
2118             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2119 
2120         if maxlags is None:
2121             maxlags = Nx - 1
2122 
2123         if maxlags >= Nx or maxlags < 1:
2124             raise ValueError('maxlags must be None or strictly '
2125                              'positive < %d' % Nx)
2126 
2127         lags = np.arange(-maxlags, maxlags + 1)
2128         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2129 
2130         if usevlines:
2131             a = self.vlines(lags, [0], correls, **kwargs)
2132             # Make label empty so only vertical lines get a legend entry
2133             kwargs.pop('label', '')
2134             b = self.axhline(**kwargs)
2135         else:
2136             kwargs.setdefault('marker', 'o')
2137             kwargs.setdefault('linestyle', 'None')
2138             a, = self.plot(lags, correls, **kwargs)
2139             b = None
2140         return lags, correls, a, b
2141 
2142     #### Specialized plotting
2143 
2144     # @_preprocess_data() # let 'plot' do the unpacking..
2145     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2146         """
2147         Make a step plot.
2148 
2149         Call signatures::
2150 
2151             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2152             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2153 
2154         This is just a thin wrapper around `.plot` which changes some
2155         formatting options. Most of the concepts and parameters of plot can be
2156         used here as well.
2157 
2158         .. note::
2159 
2160             This method uses a standard plot with a step drawstyle: The *x*
2161             values are the reference positions and steps extend left/right/both
2162             directions depending on *where*.
2163 
2164             For the common case where you know the values and edges of the
2165             steps, use `~.Axes.stairs` instead.
2166 
2167         Parameters
2168         ----------
2169         x : array-like
2170             1D sequence of x positions. It is assumed, but not checked, that
2171             it is uniformly increasing.
2172 
2173         y : array-like
2174             1D sequence of y levels.
2175 
2176         fmt : str, optional
2177             A format string, e.g. 'g' for a green line. See `.plot` for a more
2178             detailed description.
2179 
2180             Note: While full format strings are accepted, it is recommended to
2181             only specify the color. Line styles are currently ignored (use
2182             the keyword argument *linestyle* instead). Markers are accepted
2183             and plotted on the given positions, however, this is a rarely
2184             needed feature for step plots.
2185 
2186         where : {'pre', 'post', 'mid'}, default: 'pre'
2187             Define where the steps should be placed:
2188 
2189             - 'pre': The y value is continued constantly to the left from
2190               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2191               value ``y[i]``.
2192             - 'post': The y value is continued constantly to the right from
2193               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2194               value ``y[i]``.
2195             - 'mid': Steps occur half-way between the *x* positions.
2196 
2197         data : indexable object, optional
2198             An object with labelled data. If given, provide the label names to
2199             plot in *x* and *y*.
2200 
2201         **kwargs
2202             Additional parameters are the same as those for `.plot`.
2203 
2204         Returns
2205         -------
2206         list of `.Line2D`
2207             Objects representing the plotted data.
2208         """
2209         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2210         kwargs['drawstyle'] = 'steps-' + where
2211         return self.plot(x, y, *args, data=data, **kwargs)
2212 
2213     @staticmethod
2214     def _convert_dx(dx, x0, xconv, convert):
2215         """
2216         Small helper to do logic of width conversion flexibly.
2217 
2218         *dx* and *x0* have units, but *xconv* has already been converted
2219         to unitless (and is an ndarray).  This allows the *dx* to have units
2220         that are different from *x0*, but are still accepted by the
2221         ``__add__`` operator of *x0*.
2222         """
2223 
2224         # x should be an array...
2225         assert type(xconv) is np.ndarray
2226 
2227         if xconv.size == 0:
2228             # xconv has already been converted, but maybe empty...
2229             return convert(dx)
2230 
2231         try:
2232             # attempt to add the width to x0; this works for
2233             # datetime+timedelta, for instance
2234 
2235             # only use the first element of x and x0.  This saves
2236             # having to be sure addition works across the whole
2237             # vector.  This is particularly an issue if
2238             # x0 and dx are lists so x0 + dx just concatenates the lists.
2239             # We can't just cast x0 and dx to numpy arrays because that
2240             # removes the units from unit packages like `pint` that
2241             # wrap numpy arrays.
2242             try:
2243                 x0 = cbook._safe_first_finite(x0)
2244             except (TypeError, IndexError, KeyError):
2245                 pass
2246 
2247             try:
2248                 x = cbook._safe_first_finite(xconv)
2249             except (TypeError, IndexError, KeyError):
2250                 x = xconv
2251 
2252             delist = False
2253             if not np.iterable(dx):
2254                 dx = [dx]
2255                 delist = True
2256             dx = [convert(x0 + ddx) - x for ddx in dx]
2257             if delist:
2258                 dx = dx[0]
2259         except (ValueError, TypeError, AttributeError):
2260             # if the above fails (for any reason) just fallback to what
2261             # we do by default and convert dx by itself.
2262             dx = convert(dx)
2263         return dx
2264 
2265     @_preprocess_data()
2266     @_docstring.dedent_interpd
2267     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2268             **kwargs):
2269         r"""
2270         Make a bar plot.
2271 
2272         The bars are positioned at *x* with the given *align*\ment. Their
2273         dimensions are given by *height* and *width*. The vertical baseline
2274         is *bottom* (default 0).
2275 
2276         Many parameters can take either a single value applying to all bars
2277         or a sequence of values, one for each bar.
2278 
2279         Parameters
2280         ----------
2281         x : float or array-like
2282             The x coordinates of the bars. See also *align* for the
2283             alignment of the bars to the coordinates.
2284 
2285         height : float or array-like
2286             The height(s) of the bars.
2287 
2288         width : float or array-like, default: 0.8
2289             The width(s) of the bars.
2290 
2291         bottom : float or array-like, default: 0
2292             The y coordinate(s) of the bottom side(s) of the bars.
2293 
2294         align : {'center', 'edge'}, default: 'center'
2295             Alignment of the bars to the *x* coordinates:
2296 
2297             - 'center': Center the base on the *x* positions.
2298             - 'edge': Align the left edges of the bars with the *x* positions.
2299 
2300             To align the bars on the right edge pass a negative *width* and
2301             ``align='edge'``.
2302 
2303         Returns
2304         -------
2305         `.BarContainer`
2306             Container with all the bars and optionally errorbars.
2307 
2308         Other Parameters
2309         ----------------
2310         color : color or list of color, optional
2311             The colors of the bar faces.
2312 
2313         edgecolor : color or list of color, optional
2314             The colors of the bar edges.
2315 
2316         linewidth : float or array-like, optional
2317             Width of the bar edge(s). If 0, don't draw edges.
2318 
2319         tick_label : str or list of str, optional
2320             The tick labels of the bars.
2321             Default: None (Use default numeric labels.)
2322 
2323         label : str or list of str, optional
2324             A single label is attached to the resulting `.BarContainer` as a
2325             label for the whole dataset.
2326             If a list is provided, it must be the same length as *x* and
2327             labels the individual bars. Repeated labels are not de-duplicated
2328             and will cause repeated label entries, so this is best used when
2329             bars also differ in style (e.g., by passing a list to *color*.)
2330 
2331         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2332             If not *None*, add horizontal / vertical errorbars to the bar tips.
2333             The values are +/- sizes relative to the data:
2334 
2335             - scalar: symmetric +/- values for all bars
2336             - shape(N,): symmetric +/- values for each bar
2337             - shape(2, N): Separate - and + values for each bar. First row
2338               contains the lower errors, the second row contains the upper
2339               errors.
2340             - *None*: No errorbar. (Default)
2341 
2342             See :doc:`/gallery/statistics/errorbar_features` for an example on
2343             the usage of *xerr* and *yerr*.
2344 
2345         ecolor : color or list of color, default: 'black'
2346             The line color of the errorbars.
2347 
2348         capsize : float, default: :rc:`errorbar.capsize`
2349            The length of the error bar caps in points.
2350 
2351         error_kw : dict, optional
2352             Dictionary of keyword arguments to be passed to the
2353             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2354             here take precedence over the independent keyword arguments.
2355 
2356         log : bool, default: False
2357             If *True*, set the y-axis to be log scale.
2358 
2359         data : indexable object, optional
2360             DATA_PARAMETER_PLACEHOLDER
2361 
2362         **kwargs : `.Rectangle` properties
2363 
2364         %(Rectangle:kwdoc)s
2365 
2366         See Also
2367         --------
2368         barh : Plot a horizontal bar plot.
2369 
2370         Notes
2371         -----
2372         Stacked bars can be achieved by passing individual *bottom* values per
2373         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2374         """
2375         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2376         color = kwargs.pop('color', None)
2377         if color is None:
2378             color = self._get_patches_for_fill.get_next_color()
2379         edgecolor = kwargs.pop('edgecolor', None)
2380         linewidth = kwargs.pop('linewidth', None)
2381         hatch = kwargs.pop('hatch', None)
2382 
2383         # Because xerr and yerr will be passed to errorbar, most dimension
2384         # checking and processing will be left to the errorbar method.
2385         xerr = kwargs.pop('xerr', None)
2386         yerr = kwargs.pop('yerr', None)
2387         error_kw = kwargs.pop('error_kw', {})
2388         ezorder = error_kw.pop('zorder', None)
2389         if ezorder is None:
2390             ezorder = kwargs.get('zorder', None)
2391             if ezorder is not None:
2392                 # If using the bar zorder, increment slightly to make sure
2393                 # errorbars are drawn on top of bars
2394                 ezorder += 0.01
2395         error_kw.setdefault('zorder', ezorder)
2396         ecolor = kwargs.pop('ecolor', 'k')
2397         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2398         error_kw.setdefault('ecolor', ecolor)
2399         error_kw.setdefault('capsize', capsize)
2400 
2401         # The keyword argument *orientation* is used by barh() to defer all
2402         # logic and drawing to bar(). It is considered internal and is
2403         # intentionally not mentioned in the docstring.
2404         orientation = kwargs.pop('orientation', 'vertical')
2405         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2406         log = kwargs.pop('log', False)
2407         label = kwargs.pop('label', '')
2408         tick_labels = kwargs.pop('tick_label', None)
2409 
2410         y = bottom  # Matches barh call signature.
2411         if orientation == 'vertical':
2412             if y is None:
2413                 y = 0
2414         else:  # horizontal
2415             if x is None:
2416                 x = 0
2417 
2418         if orientation == 'vertical':
2419             self._process_unit_info(
2420                 [("x", x), ("y", height)], kwargs, convert=False)
2421             if log:
2422                 self.set_yscale('log', nonpositive='clip')
2423         else:  # horizontal
2424             self._process_unit_info(
2425                 [("x", width), ("y", y)], kwargs, convert=False)
2426             if log:
2427                 self.set_xscale('log', nonpositive='clip')
2428 
2429         # lets do some conversions now since some types cannot be
2430         # subtracted uniformly
2431         if self.xaxis is not None:
2432             x0 = x
2433             x = np.asarray(self.convert_xunits(x))
2434             width = self._convert_dx(width, x0, x, self.convert_xunits)
2435             if xerr is not None:
2436                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2437         if self.yaxis is not None:
2438             y0 = y
2439             y = np.asarray(self.convert_yunits(y))
2440             height = self._convert_dx(height, y0, y, self.convert_yunits)
2441             if yerr is not None:
2442                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2443 
2444         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2445             # Make args iterable too.
2446             np.atleast_1d(x), height, width, y, linewidth, hatch)
2447 
2448         # Now that units have been converted, set the tick locations.
2449         if orientation == 'vertical':
2450             tick_label_axis = self.xaxis
2451             tick_label_position = x
2452         else:  # horizontal
2453             tick_label_axis = self.yaxis
2454             tick_label_position = y
2455 
2456         if not isinstance(label, str) and np.iterable(label):
2457             bar_container_label = '_nolegend_'
2458             patch_labels = label
2459         else:
2460             bar_container_label = label
2461             patch_labels = ['_nolegend_'] * len(x)
2462         if len(patch_labels) != len(x):
2463             raise ValueError(f'number of labels ({len(patch_labels)}) '
2464                              f'does not match number of bars ({len(x)}).')
2465 
2466         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2467         hatch = itertools.cycle(np.atleast_1d(hatch))
2468         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2469                                 # Fallback if color == "none".
2470                                 itertools.repeat('none'))
2471         if edgecolor is None:
2472             edgecolor = itertools.repeat(None)
2473         else:
2474             edgecolor = itertools.chain(
2475                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2476                 # Fallback if edgecolor == "none".
2477                 itertools.repeat('none'))
2478 
2479         # We will now resolve the alignment and really have
2480         # left, bottom, width, height vectors
2481         _api.check_in_list(['center', 'edge'], align=align)
2482         if align == 'center':
2483             if orientation == 'vertical':
2484                 try:
2485                     left = x - width / 2
2486                 except TypeError as e:
2487                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2488                                     f'and width ({width.dtype}) '
2489                                     f'are incompatible') from e
2490                 bottom = y
2491             else:  # horizontal
2492                 try:
2493                     bottom = y - height / 2
2494                 except TypeError as e:
2495                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2496                                     f'and height ({height.dtype}) '
2497                                     f'are incompatible') from e
2498                 left = x
2499         else:  # edge
2500             left = x
2501             bottom = y
2502 
2503         patches = []
2504         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2505                    hatch, patch_labels)
2506         for l, b, w, h, c, e, lw, htch, lbl in args:
2507             r = mpatches.Rectangle(
2508                 xy=(l, b), width=w, height=h,
2509                 facecolor=c,
2510                 edgecolor=e,
2511                 linewidth=lw,
2512                 label=lbl,
2513                 hatch=htch,
2514                 )
2515             r._internal_update(kwargs)
2516             r.get_path()._interpolation_steps = 100
2517             if orientation == 'vertical':
2518                 r.sticky_edges.y.append(b)
2519             else:  # horizontal
2520                 r.sticky_edges.x.append(l)
2521             self.add_patch(r)
2522             patches.append(r)
2523 
2524         if xerr is not None or yerr is not None:
2525             if orientation == 'vertical':
2526                 # using list comps rather than arrays to preserve unit info
2527                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2528                 ey = [b + h for b, h in zip(bottom, height)]
2529 
2530             else:  # horizontal
2531                 # using list comps rather than arrays to preserve unit info
2532                 ex = [l + w for l, w in zip(left, width)]
2533                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2534 
2535             error_kw.setdefault("label", '_nolegend_')
2536 
2537             errorbar = self.errorbar(ex, ey,
2538                                      yerr=yerr, xerr=xerr,
2539                                      fmt='none', **error_kw)
2540         else:
2541             errorbar = None
2542 
2543         self._request_autoscale_view()
2544 
2545         if orientation == 'vertical':
2546             datavalues = height
2547         else:  # horizontal
2548             datavalues = width
2549 
2550         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2551                                      orientation=orientation,
2552                                      label=bar_container_label)
2553         self.add_container(bar_container)
2554 
2555         if tick_labels is not None:
2556             tick_labels = np.broadcast_to(tick_labels, len(patches))
2557             tick_label_axis.set_ticks(tick_label_position)
2558             tick_label_axis.set_ticklabels(tick_labels)
2559 
2560         return bar_container
2561 
2562     # @_preprocess_data() # let 'bar' do the unpacking..
2563     @_docstring.dedent_interpd
2564     def barh(self, y, width, height=0.8, left=None, *, align="center",
2565              data=None, **kwargs):
2566         r"""
2567         Make a horizontal bar plot.
2568 
2569         The bars are positioned at *y* with the given *align*\ment. Their
2570         dimensions are given by *width* and *height*. The horizontal baseline
2571         is *left* (default 0).
2572 
2573         Many parameters can take either a single value applying to all bars
2574         or a sequence of values, one for each bar.
2575 
2576         Parameters
2577         ----------
2578         y : float or array-like
2579             The y coordinates of the bars. See also *align* for the
2580             alignment of the bars to the coordinates.
2581 
2582         width : float or array-like
2583             The width(s) of the bars.
2584 
2585         height : float or array-like, default: 0.8
2586             The heights of the bars.
2587 
2588         left : float or array-like, default: 0
2589             The x coordinates of the left side(s) of the bars.
2590 
2591         align : {'center', 'edge'}, default: 'center'
2592             Alignment of the base to the *y* coordinates*:
2593 
2594             - 'center': Center the bars on the *y* positions.
2595             - 'edge': Align the bottom edges of the bars with the *y*
2596               positions.
2597 
2598             To align the bars on the top edge pass a negative *height* and
2599             ``align='edge'``.
2600 
2601         Returns
2602         -------
2603         `.BarContainer`
2604             Container with all the bars and optionally errorbars.
2605 
2606         Other Parameters
2607         ----------------
2608         color : color or list of color, optional
2609             The colors of the bar faces.
2610 
2611         edgecolor : color or list of color, optional
2612             The colors of the bar edges.
2613 
2614         linewidth : float or array-like, optional
2615             Width of the bar edge(s). If 0, don't draw edges.
2616 
2617         tick_label : str or list of str, optional
2618             The tick labels of the bars.
2619             Default: None (Use default numeric labels.)
2620 
2621         label : str or list of str, optional
2622             A single label is attached to the resulting `.BarContainer` as a
2623             label for the whole dataset.
2624             If a list is provided, it must be the same length as *y* and
2625             labels the individual bars. Repeated labels are not de-duplicated
2626             and will cause repeated label entries, so this is best used when
2627             bars also differ in style (e.g., by passing a list to *color*.)
2628 
2629         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2630             If not *None*, add horizontal / vertical errorbars to the bar tips.
2631             The values are +/- sizes relative to the data:
2632 
2633             - scalar: symmetric +/- values for all bars
2634             - shape(N,): symmetric +/- values for each bar
2635             - shape(2, N): Separate - and + values for each bar. First row
2636               contains the lower errors, the second row contains the upper
2637               errors.
2638             - *None*: No errorbar. (default)
2639 
2640             See :doc:`/gallery/statistics/errorbar_features` for an example on
2641             the usage of *xerr* and *yerr*.
2642 
2643         ecolor : color or list of color, default: 'black'
2644             The line color of the errorbars.
2645 
2646         capsize : float, default: :rc:`errorbar.capsize`
2647            The length of the error bar caps in points.
2648 
2649         error_kw : dict, optional
2650             Dictionary of keyword arguments to be passed to the
2651             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2652             here take precedence over the independent keyword arguments.
2653 
2654         log : bool, default: False
2655             If ``True``, set the x-axis to be log scale.
2656 
2657         data : indexable object, optional
2658             If given, all parameters also accept a string ``s``, which is
2659             interpreted as ``data[s]`` (unless this raises an exception).
2660 
2661         **kwargs : `.Rectangle` properties
2662 
2663         %(Rectangle:kwdoc)s
2664 
2665         See Also
2666         --------
2667         bar : Plot a vertical bar plot.
2668 
2669         Notes
2670         -----
2671         Stacked bars can be achieved by passing individual *left* values per
2672         bar. See
2673         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2674         """
2675         kwargs.setdefault('orientation', 'horizontal')
2676         patches = self.bar(x=left, height=height, width=width, bottom=y,
2677                            align=align, data=data, **kwargs)
2678         return patches
2679 
2680     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2681                   padding=0, **kwargs):
2682         """
2683         Label a bar plot.
2684 
2685         Adds labels to bars in the given `.BarContainer`.
2686         You may need to adjust the axis limits to fit the labels.
2687 
2688         Parameters
2689         ----------
2690         container : `.BarContainer`
2691             Container with all the bars and optionally errorbars, likely
2692             returned from `.bar` or `.barh`.
2693 
2694         labels : array-like, optional
2695             A list of label texts, that should be displayed. If not given, the
2696             label texts will be the data values formatted with *fmt*.
2697 
2698         fmt : str or callable, default: '%g'
2699             An unnamed %-style or {}-style format string for the label or a
2700             function to call with the value as the first argument.
2701             When *fmt* is a string and can be interpreted in both formats,
2702             %-style takes precedence over {}-style.
2703 
2704             .. versionadded:: 3.7
2705                Support for {}-style format string and callables.
2706 
2707         label_type : {'edge', 'center'}, default: 'edge'
2708             The label type. Possible values:
2709 
2710             - 'edge': label placed at the end-point of the bar segment, and the
2711               value displayed will be the position of that end-point.
2712             - 'center': label placed in the center of the bar segment, and the
2713               value displayed will be the length of that segment.
2714               (useful for stacked bars, i.e.,
2715               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2716 
2717         padding : float, default: 0
2718             Distance of label from the end of the bar, in points.
2719 
2720         **kwargs
2721             Any remaining keyword arguments are passed through to
2722             `.Axes.annotate`. The alignment parameters (
2723             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2724             not supported because the labels are automatically aligned to
2725             the bars.
2726 
2727         Returns
2728         -------
2729         list of `.Text`
2730             A list of `.Text` instances for the labels.
2731         """
2732         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2733             if key in kwargs:
2734                 raise ValueError(
2735                     f"Passing {key!r} to bar_label() is not supported.")
2736 
2737         a, b = self.yaxis.get_view_interval()
2738         y_inverted = a > b
2739         c, d = self.xaxis.get_view_interval()
2740         x_inverted = c > d
2741 
2742         # want to know whether to put label on positive or negative direction
2743         # cannot use np.sign here because it will return 0 if x == 0
2744         def sign(x):
2745             return 1 if x >= 0 else -1
2746 
2747         _api.check_in_list(['edge', 'center'], label_type=label_type)
2748 
2749         bars = container.patches
2750         errorbar = container.errorbar
2751         datavalues = container.datavalues
2752         orientation = container.orientation
2753 
2754         if errorbar:
2755             # check "ErrorbarContainer" for the definition of these elements
2756             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2757             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2758             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2759             errs = barlinecol.get_segments()
2760         else:
2761             errs = []
2762 
2763         if labels is None:
2764             labels = []
2765 
2766         annotations = []
2767 
2768         for bar, err, dat, lbl in itertools.zip_longest(
2769                 bars, errs, datavalues, labels
2770         ):
2771             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2772             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2773 
2774             if orientation == "vertical":
2775                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2776                 length = abs(y0 - y1)
2777             else:  # horizontal
2778                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2779                 length = abs(x0 - x1)
2780 
2781             if err is None or np.size(err) == 0:
2782                 endpt = extrema
2783             elif orientation == "vertical":
2784                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2785             else:  # horizontal
2786                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2787 
2788             if label_type == "center":
2789                 value = sign(dat) * length
2790             else:  # edge
2791                 value = extrema
2792 
2793             if label_type == "center":
2794                 xy = (0.5, 0.5)
2795                 kwargs["xycoords"] = (
2796                     lambda r, b=bar:
2797                         mtransforms.Bbox.intersection(
2798                             b.get_window_extent(r), b.get_clip_box()
2799                         ) or mtransforms.Bbox.null()
2800                 )
2801             else:  # edge
2802                 if orientation == "vertical":
2803                     xy = xc, endpt
2804                 else:  # horizontal
2805                     xy = endpt, yc
2806 
2807             if orientation == "vertical":
2808                 y_direction = -1 if y_inverted else 1
2809                 xytext = 0, y_direction * sign(dat) * padding
2810             else:  # horizontal
2811                 x_direction = -1 if x_inverted else 1
2812                 xytext = x_direction * sign(dat) * padding, 0
2813 
2814             if label_type == "center":
2815                 ha, va = "center", "center"
2816             else:  # edge
2817                 if orientation == "vertical":
2818                     ha = 'center'
2819                     if y_inverted:
2820                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2821                     else:
2822                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2823                 else:  # horizontal
2824                     if x_inverted:
2825                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2826                     else:
2827                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2828                     va = 'center'
2829 
2830             if np.isnan(dat):
2831                 lbl = ''
2832 
2833             if lbl is None:
2834                 if isinstance(fmt, str):
2835                     lbl = cbook._auto_format_str(fmt, value)
2836                 elif callable(fmt):
2837                     lbl = fmt(value)
2838                 else:
2839                     raise TypeError("fmt must be a str or callable")
2840             annotation = self.annotate(lbl,
2841                                        xy, xytext, textcoords="offset points",
2842                                        ha=ha, va=va, **kwargs)
2843             annotations.append(annotation)
2844 
2845         return annotations
2846 
2847     @_preprocess_data()
2848     @_docstring.dedent_interpd
2849     def broken_barh(self, xranges, yrange, **kwargs):
2850         """
2851         Plot a horizontal sequence of rectangles.
2852 
2853         A rectangle is drawn for each element of *xranges*. All rectangles
2854         have the same vertical position and size defined by *yrange*.
2855 
2856         Parameters
2857         ----------
2858         xranges : sequence of tuples (*xmin*, *xwidth*)
2859             The x-positions and extents of the rectangles. For each tuple
2860             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2861             *xwidth*.
2862         yrange : (*ymin*, *yheight*)
2863             The y-position and extent for all the rectangles.
2864 
2865         Returns
2866         -------
2867         `~.collections.PolyCollection`
2868 
2869         Other Parameters
2870         ----------------
2871         data : indexable object, optional
2872             DATA_PARAMETER_PLACEHOLDER
2873         **kwargs : `.PolyCollection` properties
2874 
2875             Each *kwarg* can be either a single argument applying to all
2876             rectangles, e.g.::
2877 
2878                 facecolors='black'
2879 
2880             or a sequence of arguments over which is cycled, e.g.::
2881 
2882                 facecolors=('black', 'blue')
2883 
2884             would create interleaving black and blue rectangles.
2885 
2886             Supported keywords:
2887 
2888             %(PolyCollection:kwdoc)s
2889         """
2890         # process the unit information
2891         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2892         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2893         self._process_unit_info(
2894             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2895 
2896         vertices = []
2897         y0, dy = yrange
2898         y0, y1 = self.convert_yunits((y0, y0 + dy))
2899         for xr in xranges:  # convert the absolute values, not the x and dx
2900             try:
2901                 x0, dx = xr
2902             except Exception:
2903                 raise ValueError(
2904                     "each range in xrange must be a sequence with two "
2905                     "elements (i.e. xrange must be an (N, 2) array)") from None
2906             x0, x1 = self.convert_xunits((x0, x0 + dx))
2907             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2908 
2909         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2910         self.add_collection(col, autolim=True)
2911         self._request_autoscale_view()
2912 
2913         return col
2914 
2915     @_preprocess_data()
2916     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2917              label=None, orientation='vertical'):
2918         """
2919         Create a stem plot.
2920 
2921         A stem plot draws lines perpendicular to a baseline at each location
2922         *locs* from the baseline to *heads*, and places a marker there. For
2923         vertical stem plots (the default), the *locs* are *x* positions, and
2924         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2925         *y* positions, and the *heads* are *x* values.
2926 
2927         Call signature::
2928 
2929           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2930 
2931         The *locs*-positions are optional. *linefmt* may be provided as
2932         positional, but all other formats must be provided as keyword
2933         arguments.
2934 
2935         Parameters
2936         ----------
2937         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2938             For vertical stem plots, the x-positions of the stems.
2939             For horizontal stem plots, the y-positions of the stems.
2940 
2941         heads : array-like
2942             For vertical stem plots, the y-values of the stem heads.
2943             For horizontal stem plots, the x-values of the stem heads.
2944 
2945         linefmt : str, optional
2946             A string defining the color and/or linestyle of the vertical lines:
2947 
2948             =========  =============
2949             Character  Line Style
2950             =========  =============
2951             ``'-'``    solid line
2952             ``'--'``   dashed line
2953             ``'-.'``   dash-dot line
2954             ``':'``    dotted line
2955             =========  =============
2956 
2957             Default: 'C0-', i.e. solid line with the first color of the color
2958             cycle.
2959 
2960             Note: Markers specified through this parameter (e.g. 'x') will be
2961             silently ignored. Instead, markers should be specified using
2962             *markerfmt*.
2963 
2964         markerfmt : str, optional
2965             A string defining the color and/or shape of the markers at the stem
2966             heads. If the marker is not given, use the marker 'o', i.e. filled
2967             circles. If the color is not given, use the color from *linefmt*.
2968 
2969         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2970             A format string defining the properties of the baseline.
2971 
2972         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2973             If 'vertical', will produce a plot with stems oriented vertically,
2974             If 'horizontal', the stems will be oriented horizontally.
2975 
2976         bottom : float, default: 0
2977             The y/x-position of the baseline (depending on orientation).
2978 
2979         label : str, default: None
2980             The label to use for the stems in legends.
2981 
2982         data : indexable object, optional
2983             DATA_PARAMETER_PLACEHOLDER
2984 
2985         Returns
2986         -------
2987         `.StemContainer`
2988             The container may be treated like a tuple
2989             (*markerline*, *stemlines*, *baseline*)
2990 
2991         Notes
2992         -----
2993         .. seealso::
2994             The MATLAB function
2995             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2996             which inspired this method.
2997         """
2998         if not 1 <= len(args) <= 3:
2999             raise _api.nargs_error('stem', '1-3', len(args))
3000         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3001 
3002         if len(args) == 1:
3003             heads, = args
3004             locs = np.arange(len(heads))
3005             args = ()
3006         elif isinstance(args[1], str):
3007             heads, *args = args
3008             locs = np.arange(len(heads))
3009         else:
3010             locs, heads, *args = args
3011 
3012         if orientation == 'vertical':
3013             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3014         else:  # horizontal
3015             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3016 
3017         # resolve line format
3018         if linefmt is None:
3019             linefmt = args[0] if len(args) > 0 else "C0-"
3020         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3021 
3022         # resolve marker format
3023         if markerfmt is None:
3024             # if not given as kwarg, fall back to 'o'
3025             markerfmt = "o"
3026         if markerfmt == '':
3027             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3028         markerstyle, markermarker, markercolor = \
3029             _process_plot_format(markerfmt)
3030         if markermarker is None:
3031             markermarker = 'o'
3032         if markerstyle is None:
3033             markerstyle = 'None'
3034         if markercolor is None:
3035             markercolor = linecolor
3036 
3037         # resolve baseline format
3038         if basefmt is None:
3039             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3040                        "C3-")
3041         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3042 
3043         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3044         if linestyle is None:
3045             linestyle = mpl.rcParams['lines.linestyle']
3046         xlines = self.vlines if orientation == "vertical" else self.hlines
3047         stemlines = xlines(
3048             locs, bottom, heads,
3049             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3050 
3051         if orientation == 'horizontal':
3052             marker_x = heads
3053             marker_y = locs
3054             baseline_x = [bottom, bottom]
3055             baseline_y = [np.min(locs), np.max(locs)]
3056         else:
3057             marker_x = locs
3058             marker_y = heads
3059             baseline_x = [np.min(locs), np.max(locs)]
3060             baseline_y = [bottom, bottom]
3061 
3062         markerline, = self.plot(marker_x, marker_y,
3063                                 color=markercolor, linestyle=markerstyle,
3064                                 marker=markermarker, label="_nolegend_")
3065 
3066         baseline, = self.plot(baseline_x, baseline_y,
3067                               color=basecolor, linestyle=basestyle,
3068                               marker=basemarker, label="_nolegend_")
3069 
3070         stem_container = StemContainer((markerline, stemlines, baseline),
3071                                        label=label)
3072         self.add_container(stem_container)
3073         return stem_container
3074 
3075     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3076     def pie(self, x, explode=None, labels=None, colors=None,
3077             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3078             startangle=0, radius=1, counterclock=True,
3079             wedgeprops=None, textprops=None, center=(0, 0),
3080             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3081         """
3082         Plot a pie chart.
3083 
3084         Make a pie chart of array *x*.  The fractional area of each wedge is
3085         given by ``x/sum(x)``.
3086 
3087         The wedges are plotted counterclockwise, by default starting from the
3088         x-axis.
3089 
3090         Parameters
3091         ----------
3092         x : 1D array-like
3093             The wedge sizes.
3094 
3095         explode : array-like, default: None
3096             If not *None*, is a ``len(x)`` array which specifies the fraction
3097             of the radius with which to offset each wedge.
3098 
3099         labels : list, default: None
3100             A sequence of strings providing the labels for each wedge
3101 
3102         colors : color or array-like of color, default: None
3103             A sequence of colors through which the pie chart will cycle.  If
3104             *None*, will use the colors in the currently active cycle.
3105 
3106         hatch : str or list, default: None
3107             Hatching pattern applied to all pie wedges or sequence of patterns
3108             through which the chart will cycle. For a list of valid patterns,
3109             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3110 
3111             .. versionadded:: 3.7
3112 
3113         autopct : None or str or callable, default: None
3114             If not *None*, *autopct* is a string or function used to label the
3115             wedges with their numeric value. The label will be placed inside
3116             the wedge. If *autopct* is a format string, the label will be
3117             ``fmt % pct``. If *autopct* is a function, then it will be called.
3118 
3119         pctdistance : float, default: 0.6
3120             The relative distance along the radius at which the text
3121             generated by *autopct* is drawn. To draw the text outside the pie,
3122             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3123             ``None``.
3124 
3125         labeldistance : float or None, default: 1.1
3126             The relative distance along the radius at which the labels are
3127             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3128             If set to ``None``, labels are not drawn but are still stored for
3129             use in `.legend`.
3130 
3131         shadow : bool or dict, default: False
3132             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3133             passing the properties in the dict to `.Shadow`.
3134 
3135             .. versionadded:: 3.8
3136                 *shadow* can be a dict.
3137 
3138         startangle : float, default: 0 degrees
3139             The angle by which the start of the pie is rotated,
3140             counterclockwise from the x-axis.
3141 
3142         radius : float, default: 1
3143             The radius of the pie.
3144 
3145         counterclock : bool, default: True
3146             Specify fractions direction, clockwise or counterclockwise.
3147 
3148         wedgeprops : dict, default: None
3149             Dict of arguments passed to each `.patches.Wedge` of the pie.
3150             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3151             the wedge border lines equal to 3. By default, ``clip_on=False``.
3152             When there is a conflict between these properties and other
3153             keywords, properties passed to *wedgeprops* take precedence.
3154 
3155         textprops : dict, default: None
3156             Dict of arguments to pass to the text objects.
3157 
3158         center : (float, float), default: (0, 0)
3159             The coordinates of the center of the chart.
3160 
3161         frame : bool, default: False
3162             Plot Axes frame with the chart if true.
3163 
3164         rotatelabels : bool, default: False
3165             Rotate each label to the angle of the corresponding slice if true.
3166 
3167         normalize : bool, default: True
3168             When *True*, always make a full pie by normalizing x so that
3169             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3170             and raises a `ValueError` for ``sum(x) > 1``.
3171 
3172         data : indexable object, optional
3173             DATA_PARAMETER_PLACEHOLDER
3174 
3175         Returns
3176         -------
3177         patches : list
3178             A sequence of `matplotlib.patches.Wedge` instances
3179 
3180         texts : list
3181             A list of the label `.Text` instances.
3182 
3183         autotexts : list
3184             A list of `.Text` instances for the numeric labels. This will only
3185             be returned if the parameter *autopct* is not *None*.
3186 
3187         Notes
3188         -----
3189         The pie chart will probably look best if the figure and Axes are
3190         square, or the Axes aspect is equal.
3191         This method sets the aspect ratio of the axis to "equal".
3192         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3193         """
3194         self.set_aspect('equal')
3195         # The use of float32 is "historical", but can't be changed without
3196         # regenerating the test baselines.
3197         x = np.asarray(x, np.float32)
3198         if x.ndim > 1:
3199             raise ValueError("x must be 1D")
3200 
3201         if np.any(x < 0):
3202             raise ValueError("Wedge sizes 'x' must be non negative values")
3203 
3204         sx = x.sum()
3205 
3206         if normalize:
3207             x = x / sx
3208         elif sx > 1:
3209             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3210         if labels is None:
3211             labels = [''] * len(x)
3212         if explode is None:
3213             explode = [0] * len(x)
3214         if len(x) != len(labels):
3215             raise ValueError("'label' must be of length 'x'")
3216         if len(x) != len(explode):
3217             raise ValueError("'explode' must be of length 'x'")
3218         if colors is None:
3219             get_next_color = self._get_patches_for_fill.get_next_color
3220         else:
3221             color_cycle = itertools.cycle(colors)
3222 
3223             def get_next_color():
3224                 return next(color_cycle)
3225 
3226         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3227 
3228         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3229         if radius <= 0:
3230             raise ValueError(f'radius must be a positive number, not {radius}')
3231 
3232         # Starting theta1 is the start fraction of the circle
3233         theta1 = startangle / 360
3234 
3235         if wedgeprops is None:
3236             wedgeprops = {}
3237         if textprops is None:
3238             textprops = {}
3239 
3240         texts = []
3241         slices = []
3242         autotexts = []
3243 
3244         for frac, label, expl in zip(x, labels, explode):
3245             x, y = center
3246             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3247             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3248             x += expl * math.cos(thetam)
3249             y += expl * math.sin(thetam)
3250 
3251             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3252                                360. * max(theta1, theta2),
3253                                facecolor=get_next_color(),
3254                                hatch=next(hatch_cycle),
3255                                clip_on=False,
3256                                label=label)
3257             w.set(**wedgeprops)
3258             slices.append(w)
3259             self.add_patch(w)
3260 
3261             if shadow:
3262                 # Make sure to add a shadow after the call to add_patch so the
3263                 # figure and transform props will be set.
3264                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3265                 if isinstance(shadow, dict):
3266                     shadow_dict.update(shadow)
3267                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3268 
3269             if labeldistance is not None:
3270                 xt = x + labeldistance * radius * math.cos(thetam)
3271                 yt = y + labeldistance * radius * math.sin(thetam)
3272                 label_alignment_h = 'left' if xt > 0 else 'right'
3273                 label_alignment_v = 'center'
3274                 label_rotation = 'horizontal'
3275                 if rotatelabels:
3276                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3277                     label_rotation = (np.rad2deg(thetam)
3278                                       + (0 if xt > 0 else 180))
3279                 t = self.text(xt, yt, label,
3280                               clip_on=False,
3281                               horizontalalignment=label_alignment_h,
3282                               verticalalignment=label_alignment_v,
3283                               rotation=label_rotation,
3284                               size=mpl.rcParams['xtick.labelsize'])
3285                 t.set(**textprops)
3286                 texts.append(t)
3287 
3288             if autopct is not None:
3289                 xt = x + pctdistance * radius * math.cos(thetam)
3290                 yt = y + pctdistance * radius * math.sin(thetam)
3291                 if isinstance(autopct, str):
3292                     s = autopct % (100. * frac)
3293                 elif callable(autopct):
3294                     s = autopct(100. * frac)
3295                 else:
3296                     raise TypeError(
3297                         'autopct must be callable or a format string')
3298                 t = self.text(xt, yt, s,
3299                               clip_on=False,
3300                               horizontalalignment='center',
3301                               verticalalignment='center')
3302                 t.set(**textprops)
3303                 autotexts.append(t)
3304 
3305             theta1 = theta2
3306 
3307         if frame:
3308             self._request_autoscale_view()
3309         else:
3310             self.set(frame_on=False, xticks=[], yticks=[],
3311                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3312                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3313 
3314         if autopct is None:
3315             return slices, texts
3316         else:
3317             return slices, texts, autotexts
3318 
3319     @staticmethod
3320     def _errorevery_to_mask(x, errorevery):
3321         """
3322         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3323 
3324         This function is split out to be usable both by 2D and 3D errorbars.
3325         """
3326         if isinstance(errorevery, Integral):
3327             errorevery = (0, errorevery)
3328         if isinstance(errorevery, tuple):
3329             if (len(errorevery) == 2 and
3330                     isinstance(errorevery[0], Integral) and
3331                     isinstance(errorevery[1], Integral)):
3332                 errorevery = slice(errorevery[0], None, errorevery[1])
3333             else:
3334                 raise ValueError(
3335                     f'{errorevery=!r} is a not a tuple of two integers')
3336         elif isinstance(errorevery, slice):
3337             pass
3338         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3339             try:
3340                 x[errorevery]  # fancy indexing
3341             except (ValueError, IndexError) as err:
3342                 raise ValueError(
3343                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3344                     "index to match 'xerr'/'yerr'") from err
3345         else:
3346             raise ValueError(f"{errorevery=!r} is not a recognized value")
3347         everymask = np.zeros(len(x), bool)
3348         everymask[errorevery] = True
3349         return everymask
3350 
3351     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3352                       label_namer="y")
3353     @_docstring.dedent_interpd
3354     def errorbar(self, x, y, yerr=None, xerr=None,
3355                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3356                  barsabove=False, lolims=False, uplims=False,
3357                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3358                  **kwargs):
3359         """
3360         Plot y versus x as lines and/or markers with attached errorbars.
3361 
3362         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3363         sizes. By default, this draws the data markers/lines as well the
3364         errorbars. Use fmt='none' to draw errorbars without any data markers.
3365 
3366         .. versionadded:: 3.7
3367            Caps and error lines are drawn in polar coordinates on polar plots.
3368 
3369 
3370         Parameters
3371         ----------
3372         x, y : float or array-like
3373             The data positions.
3374 
3375         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3376             The errorbar sizes:
3377 
3378             - scalar: Symmetric +/- values for all data points.
3379             - shape(N,): Symmetric +/-values for each data point.
3380             - shape(2, N): Separate - and + values for each bar. First row
3381               contains the lower errors, the second row contains the upper
3382               errors.
3383             - *None*: No errorbar.
3384 
3385             All values must be >= 0.
3386 
3387             See :doc:`/gallery/statistics/errorbar_features`
3388             for an example on the usage of ``xerr`` and ``yerr``.
3389 
3390         fmt : str, default: ''
3391             The format for the data points / data lines. See `.plot` for
3392             details.
3393 
3394             Use 'none' (case-insensitive) to plot errorbars without any data
3395             markers.
3396 
3397         ecolor : color, default: None
3398             The color of the errorbar lines.  If None, use the color of the
3399             line connecting the markers.
3400 
3401         elinewidth : float, default: None
3402             The linewidth of the errorbar lines. If None, the linewidth of
3403             the current style is used.
3404 
3405         capsize : float, default: :rc:`errorbar.capsize`
3406             The length of the error bar caps in points.
3407 
3408         capthick : float, default: None
3409             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3410             This setting is a more sensible name for the property that
3411             controls the thickness of the error bar cap in points. For
3412             backwards compatibility, if *mew* or *markeredgewidth* are given,
3413             then they will over-ride *capthick*. This may change in future
3414             releases.
3415 
3416         barsabove : bool, default: False
3417             If True, will plot the errorbars above the plot
3418             symbols. Default is below.
3419 
3420         lolims, uplims, xlolims, xuplims : bool, default: False
3421             These arguments can be used to indicate that a value gives only
3422             upper/lower limits.  In that case a caret symbol is used to
3423             indicate this. *lims*-arguments may be scalars, or array-likes of
3424             the same length as *xerr* and *yerr*.  To use limits with inverted
3425             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3426             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3427             *lolims* to True means that the y-value is a *lower* limit of the
3428             True value, so, only an *upward*-pointing arrow will be drawn!
3429 
3430         errorevery : int or (int, int), default: 1
3431             draws error bars on a subset of the data. *errorevery* =N draws
3432             error bars on the points (x[::N], y[::N]).
3433             *errorevery* =(start, N) draws error bars on the points
3434             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3435             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3436             Used to avoid overlapping error bars when two series share x-axis
3437             values.
3438 
3439         Returns
3440         -------
3441         `.ErrorbarContainer`
3442             The container contains:
3443 
3444             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3445             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3446             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3447               vertical error ranges.
3448 
3449         Other Parameters
3450         ----------------
3451         data : indexable object, optional
3452             DATA_PARAMETER_PLACEHOLDER
3453 
3454         **kwargs
3455             All other keyword arguments are passed on to the `~.Axes.plot` call
3456             drawing the markers. For example, this code makes big red squares
3457             with thick green edges::
3458 
3459                 x, y, yerr = rand(3, 10)
3460                 errorbar(x, y, yerr, marker='s', mfc='red',
3461                          mec='green', ms=20, mew=4)
3462 
3463             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3464             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3465             and *markeredgewidth*.
3466 
3467             Valid kwargs for the marker properties are:
3468 
3469             - *dashes*
3470             - *dash_capstyle*
3471             - *dash_joinstyle*
3472             - *drawstyle*
3473             - *fillstyle*
3474             - *linestyle*
3475             - *marker*
3476             - *markeredgecolor*
3477             - *markeredgewidth*
3478             - *markerfacecolor*
3479             - *markerfacecoloralt*
3480             - *markersize*
3481             - *markevery*
3482             - *solid_capstyle*
3483             - *solid_joinstyle*
3484 
3485             Refer to the corresponding `.Line2D` property for more details:
3486 
3487             %(Line2D:kwdoc)s
3488         """
3489         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3490         # Drop anything that comes in as None to use the default instead.
3491         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3492         kwargs.setdefault('zorder', 2)
3493 
3494         # Casting to object arrays preserves units.
3495         if not isinstance(x, np.ndarray):
3496             x = np.asarray(x, dtype=object)
3497         if not isinstance(y, np.ndarray):
3498             y = np.asarray(y, dtype=object)
3499 
3500         def _upcast_err(err):
3501             """
3502             Safely handle tuple of containers that carry units.
3503 
3504             This function covers the case where the input to the xerr/yerr is a
3505             length 2 tuple of equal length ndarray-subclasses that carry the
3506             unit information in the container.
3507 
3508             If we have a tuple of nested numpy array (subclasses), we defer
3509             coercing the units to be consistent to the underlying unit
3510             library (and implicitly the broadcasting).
3511 
3512             Otherwise, fallback to casting to an object array.
3513             """
3514 
3515             if (
3516                     # make sure it is not a scalar
3517                     np.iterable(err) and
3518                     # and it is not empty
3519                     len(err) > 0 and
3520                     # and the first element is an array sub-class use
3521                     # safe_first_element because getitem is index-first not
3522                     # location first on pandas objects so err[0] almost always
3523                     # fails.
3524                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3525             ):
3526                 # Get the type of the first element
3527                 atype = type(cbook._safe_first_finite(err))
3528                 # Promote the outer container to match the inner container
3529                 if atype is np.ndarray:
3530                     # Converts using np.asarray, because data cannot
3531                     # be directly passed to init of np.ndarray
3532                     return np.asarray(err, dtype=object)
3533                 # If atype is not np.ndarray, directly pass data to init.
3534                 # This works for types such as unyts and astropy units
3535                 return atype(err)
3536             # Otherwise wrap it in an object array
3537             return np.asarray(err, dtype=object)
3538 
3539         if xerr is not None and not isinstance(xerr, np.ndarray):
3540             xerr = _upcast_err(xerr)
3541         if yerr is not None and not isinstance(yerr, np.ndarray):
3542             yerr = _upcast_err(yerr)
3543         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3544         if len(x) != len(y):
3545             raise ValueError("'x' and 'y' must have the same size")
3546 
3547         everymask = self._errorevery_to_mask(x, errorevery)
3548 
3549         label = kwargs.pop("label", None)
3550         kwargs['label'] = '_nolegend_'
3551 
3552         # Create the main line and determine overall kwargs for child artists.
3553         # We avoid calling self.plot() directly, or self._get_lines(), because
3554         # that would call self._process_unit_info again, and do other indirect
3555         # data processing.
3556         (data_line, base_style), = self._get_lines._plot_args(
3557             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3558 
3559         # Do this after creating `data_line` to avoid modifying `base_style`.
3560         if barsabove:
3561             data_line.set_zorder(kwargs['zorder'] - .1)
3562         else:
3563             data_line.set_zorder(kwargs['zorder'] + .1)
3564 
3565         # Add line to plot, or throw it away and use it to determine kwargs.
3566         if fmt.lower() != 'none':
3567             self.add_line(data_line)
3568         else:
3569             data_line = None
3570             # Remove alpha=0 color that _get_lines._plot_args returns for
3571             # 'none' format, and replace it with user-specified color, if
3572             # supplied.
3573             base_style.pop('color')
3574             if 'color' in kwargs:
3575                 base_style['color'] = kwargs.pop('color')
3576 
3577         if 'color' not in base_style:
3578             base_style['color'] = 'C0'
3579         if ecolor is None:
3580             ecolor = base_style['color']
3581 
3582         # Eject any line-specific information from format string, as it's not
3583         # needed for bars or caps.
3584         for key in ['marker', 'markersize', 'markerfacecolor',
3585                     'markerfacecoloralt',
3586                     'markeredgewidth', 'markeredgecolor', 'markevery',
3587                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3588                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3589                     'dashes']:
3590             base_style.pop(key, None)
3591 
3592         # Make the style dict for the line collections (the bars).
3593         eb_lines_style = {**base_style, 'color': ecolor}
3594 
3595         if elinewidth is not None:
3596             eb_lines_style['linewidth'] = elinewidth
3597         elif 'linewidth' in kwargs:
3598             eb_lines_style['linewidth'] = kwargs['linewidth']
3599 
3600         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3601             if key in kwargs:
3602                 eb_lines_style[key] = kwargs[key]
3603 
3604         # Make the style dict for caps (the "hats").
3605         eb_cap_style = {**base_style, 'linestyle': 'none'}
3606         if capsize is None:
3607             capsize = mpl.rcParams["errorbar.capsize"]
3608         if capsize > 0:
3609             eb_cap_style['markersize'] = 2. * capsize
3610         if capthick is not None:
3611             eb_cap_style['markeredgewidth'] = capthick
3612 
3613         # For backwards-compat, allow explicit setting of
3614         # 'markeredgewidth' to over-ride capthick.
3615         for key in ('markeredgewidth', 'transform', 'alpha',
3616                     'zorder', 'rasterized'):
3617             if key in kwargs:
3618                 eb_cap_style[key] = kwargs[key]
3619         eb_cap_style['color'] = ecolor
3620 
3621         barcols = []
3622         caplines = {'x': [], 'y': []}
3623 
3624         # Vectorized fancy-indexer.
3625         def apply_mask(arrays, mask):
3626             return [array[mask] for array in arrays]
3627 
3628         # dep: dependent dataset, indep: independent dataset
3629         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3630              marker, lomarker, himarker) in [
3631                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3632                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3633                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3634                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3635         ]:
3636             if err is None:
3637                 continue
3638             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3639             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3640             try:
3641                 np.broadcast_to(err, (2, len(dep)))
3642             except ValueError:
3643                 raise ValueError(
3644                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3645                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3646                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3647             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3648             if np.any(np.less(err, -err, out=res, where=(err == err))):
3649                 # like err<0, but also works for timedelta and nan.
3650                 raise ValueError(
3651                     f"'{dep_axis}err' must not contain negative values")
3652             # This is like
3653             #     elow, ehigh = np.broadcast_to(...)
3654             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3655             # except that broadcast_to would strip units.
3656             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3657             barcols.append(lines_func(
3658                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3659             if self.name == "polar" and dep_axis == "x":
3660                 for b in barcols:
3661                     for p in b.get_paths():
3662                         p._interpolation_steps = 2
3663             # Normal errorbars for points without upper/lower limits.
3664             nolims = ~(lolims | uplims)
3665             if nolims.any() and capsize > 0:
3666                 indep_masked, lo_masked, hi_masked = apply_mask(
3667                     [indep, low, high], nolims & everymask)
3668                 for lh_masked in [lo_masked, hi_masked]:
3669                     # Since this has to work for x and y as dependent data, we
3670                     # first set both x and y to the independent variable and
3671                     # overwrite the respective dependent data in a second step.
3672                     line = mlines.Line2D(indep_masked, indep_masked,
3673                                          marker=marker, **eb_cap_style)
3674                     line.set(**{f"{dep_axis}data": lh_masked})
3675                     caplines[dep_axis].append(line)
3676             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3677                 if not lims.any():
3678                     continue
3679                 hlmarker = (
3680                     himarker
3681                     if self._axis_map[dep_axis].get_inverted() ^ idx
3682                     else lomarker)
3683                 x_masked, y_masked, hl_masked = apply_mask(
3684                     [x, y, hl], lims & everymask)
3685                 # As above, we set the dependent data in a second step.
3686                 line = mlines.Line2D(x_masked, y_masked,
3687                                      marker=hlmarker, **eb_cap_style)
3688                 line.set(**{f"{dep_axis}data": hl_masked})
3689                 caplines[dep_axis].append(line)
3690                 if capsize > 0:
3691                     caplines[dep_axis].append(mlines.Line2D(
3692                         x_masked, y_masked, marker=marker, **eb_cap_style))
3693         if self.name == 'polar':
3694             for axis in caplines:
3695                 for l in caplines[axis]:
3696                     # Rotate caps to be perpendicular to the error bars
3697                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3698                         rotation = mtransforms.Affine2D().rotate(theta)
3699                         if axis == 'y':
3700                             rotation.rotate(-np.pi / 2)
3701                         ms = mmarkers.MarkerStyle(marker=marker,
3702                                                   transform=rotation)
3703                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3704                                                     **eb_cap_style))
3705         else:
3706             for axis in caplines:
3707                 for l in caplines[axis]:
3708                     self.add_line(l)
3709 
3710         self._request_autoscale_view()
3711         caplines = caplines['x'] + caplines['y']
3712         errorbar_container = ErrorbarContainer(
3713             (data_line, tuple(caplines), tuple(barcols)),
3714             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3715             label=label)
3716         self.containers.append(errorbar_container)
3717 
3718         return errorbar_container  # (l0, caplines, barcols)
3719 
3720     @_preprocess_data()
3721     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3722                 positions=None, widths=None, patch_artist=None,
3723                 bootstrap=None, usermedians=None, conf_intervals=None,
3724                 meanline=None, showmeans=None, showcaps=None,
3725                 showbox=None, showfliers=None, boxprops=None,
3726                 labels=None, flierprops=None, medianprops=None,
3727                 meanprops=None, capprops=None, whiskerprops=None,
3728                 manage_ticks=True, autorange=False, zorder=None,
3729                 capwidths=None):
3730         """
3731         Draw a box and whisker plot.
3732 
3733         The box extends from the first quartile (Q1) to the third
3734         quartile (Q3) of the data, with a line at the median.
3735         The whiskers extend from the box to the farthest data point
3736         lying within 1.5x the inter-quartile range (IQR) from the box.
3737         Flier points are those past the end of the whiskers.
3738         See https://en.wikipedia.org/wiki/Box_plot for reference.
3739 
3740         .. code-block:: none
3741 
3742                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3743                                |-----:-----|
3744                o      |--------|     :     |--------|    o  o
3745                                |-----:-----|
3746              flier             <----------->            fliers
3747                                     IQR
3748 
3749 
3750         Parameters
3751         ----------
3752         x : Array or a sequence of vectors.
3753             The input data.  If a 2D array, a boxplot is drawn for each column
3754             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3755             array in *x*.
3756 
3757         notch : bool, default: False
3758             Whether to draw a notched boxplot (`True`), or a rectangular
3759             boxplot (`False`).  The notches represent the confidence interval
3760             (CI) around the median.  The documentation for *bootstrap*
3761             describes how the locations of the notches are computed by
3762             default, but their locations may also be overridden by setting the
3763             *conf_intervals* parameter.
3764 
3765             .. note::
3766 
3767                 In cases where the values of the CI are less than the
3768                 lower quartile or greater than the upper quartile, the
3769                 notches will extend beyond the box, giving it a
3770                 distinctive "flipped" appearance. This is expected
3771                 behavior and consistent with other statistical
3772                 visualization packages.
3773 
3774         sym : str, optional
3775             The default symbol for flier points.  An empty string ('') hides
3776             the fliers.  If `None`, then the fliers default to 'b+'.  More
3777             control is provided by the *flierprops* parameter.
3778 
3779         vert : bool, default: True
3780             If `True`, draws vertical boxes.
3781             If `False`, draw horizontal boxes.
3782 
3783         whis : float or (float, float), default: 1.5
3784             The position of the whiskers.
3785 
3786             If a float, the lower whisker is at the lowest datum above
3787             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3788             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3789             third quartiles.  The default value of ``whis = 1.5`` corresponds
3790             to Tukey's original definition of boxplots.
3791 
3792             If a pair of floats, they indicate the percentiles at which to
3793             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3794             (0, 100) results in whiskers covering the whole range of the data.
3795 
3796             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3797             to (0, 100) (cover the whole range of the data) if *autorange* is
3798             True.
3799 
3800             Beyond the whiskers, data are considered outliers and are plotted
3801             as individual points.
3802 
3803         bootstrap : int, optional
3804             Specifies whether to bootstrap the confidence intervals
3805             around the median for notched boxplots. If *bootstrap* is
3806             None, no bootstrapping is performed, and notches are
3807             calculated using a Gaussian-based asymptotic approximation
3808             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3809             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3810             the number of times to bootstrap the median to determine its
3811             95% confidence intervals. Values between 1000 and 10000 are
3812             recommended.
3813 
3814         usermedians : 1D array-like, optional
3815             A 1D array-like of length ``len(x)``.  Each entry that is not
3816             `None` forces the value of the median for the corresponding
3817             dataset.  For entries that are `None`, the medians are computed
3818             by Matplotlib as normal.
3819 
3820         conf_intervals : array-like, optional
3821             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3822             None forces the location of the corresponding notch (which is
3823             only drawn if *notch* is `True`).  For entries that are `None`,
3824             the notches are computed by the method specified by the other
3825             parameters (e.g., *bootstrap*).
3826 
3827         positions : array-like, optional
3828             The positions of the boxes. The ticks and limits are
3829             automatically set to match the positions. Defaults to
3830             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3831 
3832         widths : float or array-like
3833             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3834             between extreme positions)``, if that is smaller.
3835 
3836         patch_artist : bool, default: False
3837             If `False` produces boxes with the Line2D artist. Otherwise,
3838             boxes are drawn with Patch artists.
3839 
3840         labels : sequence, optional
3841             Labels for each dataset (one per dataset).
3842 
3843         manage_ticks : bool, default: True
3844             If True, the tick locations and labels will be adjusted to match
3845             the boxplot positions.
3846 
3847         autorange : bool, default: False
3848             When `True` and the data are distributed such that the 25th and
3849             75th percentiles are equal, *whis* is set to (0, 100) such
3850             that the whisker ends are at the minimum and maximum of the data.
3851 
3852         meanline : bool, default: False
3853             If `True` (and *showmeans* is `True`), will try to render the
3854             mean as a line spanning the full width of the box according to
3855             *meanprops* (see below).  Not recommended if *shownotches* is also
3856             True.  Otherwise, means will be shown as points.
3857 
3858         zorder : float, default: ``Line2D.zorder = 2``
3859             The zorder of the boxplot.
3860 
3861         Returns
3862         -------
3863         dict
3864           A dictionary mapping each component of the boxplot to a list
3865           of the `.Line2D` instances created. That dictionary has the
3866           following keys (assuming vertical boxplots):
3867 
3868           - ``boxes``: the main body of the boxplot showing the
3869             quartiles and the median's confidence intervals if
3870             enabled.
3871 
3872           - ``medians``: horizontal lines at the median of each box.
3873 
3874           - ``whiskers``: the vertical lines extending to the most
3875             extreme, non-outlier data points.
3876 
3877           - ``caps``: the horizontal lines at the ends of the
3878             whiskers.
3879 
3880           - ``fliers``: points representing data that extend beyond
3881             the whiskers (fliers).
3882 
3883           - ``means``: points or lines representing the means.
3884 
3885         Other Parameters
3886         ----------------
3887         showcaps : bool, default: True
3888             Show the caps on the ends of whiskers.
3889         showbox : bool, default: True
3890             Show the central box.
3891         showfliers : bool, default: True
3892             Show the outliers beyond the caps.
3893         showmeans : bool, default: False
3894             Show the arithmetic means.
3895         capprops : dict, default: None
3896             The style of the caps.
3897         capwidths : float or array, default: None
3898             The widths of the caps.
3899         boxprops : dict, default: None
3900             The style of the box.
3901         whiskerprops : dict, default: None
3902             The style of the whiskers.
3903         flierprops : dict, default: None
3904             The style of the fliers.
3905         medianprops : dict, default: None
3906             The style of the median.
3907         meanprops : dict, default: None
3908             The style of the mean.
3909         data : indexable object, optional
3910             DATA_PARAMETER_PLACEHOLDER
3911 
3912         See Also
3913         --------
3914         violinplot : Draw an estimate of the probability density function.
3915         """
3916 
3917         # Missing arguments default to rcParams.
3918         if whis is None:
3919             whis = mpl.rcParams['boxplot.whiskers']
3920         if bootstrap is None:
3921             bootstrap = mpl.rcParams['boxplot.bootstrap']
3922 
3923         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3924                                        labels=labels, autorange=autorange)
3925         if notch is None:
3926             notch = mpl.rcParams['boxplot.notch']
3927         if vert is None:
3928             vert = mpl.rcParams['boxplot.vertical']
3929         if patch_artist is None:
3930             patch_artist = mpl.rcParams['boxplot.patchartist']
3931         if meanline is None:
3932             meanline = mpl.rcParams['boxplot.meanline']
3933         if showmeans is None:
3934             showmeans = mpl.rcParams['boxplot.showmeans']
3935         if showcaps is None:
3936             showcaps = mpl.rcParams['boxplot.showcaps']
3937         if showbox is None:
3938             showbox = mpl.rcParams['boxplot.showbox']
3939         if showfliers is None:
3940             showfliers = mpl.rcParams['boxplot.showfliers']
3941 
3942         if boxprops is None:
3943             boxprops = {}
3944         if whiskerprops is None:
3945             whiskerprops = {}
3946         if capprops is None:
3947             capprops = {}
3948         if medianprops is None:
3949             medianprops = {}
3950         if meanprops is None:
3951             meanprops = {}
3952         if flierprops is None:
3953             flierprops = {}
3954 
3955         if patch_artist:
3956             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3957             if 'color' in boxprops:
3958                 boxprops['edgecolor'] = boxprops.pop('color')
3959 
3960         # if non-default sym value, put it into the flier dictionary
3961         # the logic for providing the default symbol ('b+') now lives
3962         # in bxp in the initial value of flierkw
3963         # handle all of the *sym* related logic here so we only have to pass
3964         # on the flierprops dict.
3965         if sym is not None:
3966             # no-flier case, which should really be done with
3967             # 'showfliers=False' but none-the-less deal with it to keep back
3968             # compatibility
3969             if sym == '':
3970                 # blow away existing dict and make one for invisible markers
3971                 flierprops = dict(linestyle='none', marker='', color='none')
3972                 # turn the fliers off just to be safe
3973                 showfliers = False
3974             # now process the symbol string
3975             else:
3976                 # process the symbol string
3977                 # discarded linestyle
3978                 _, marker, color = _process_plot_format(sym)
3979                 # if we have a marker, use it
3980                 if marker is not None:
3981                     flierprops['marker'] = marker
3982                 # if we have a color, use it
3983                 if color is not None:
3984                     # assume that if color is passed in the user want
3985                     # filled symbol, if the users want more control use
3986                     # flierprops
3987                     flierprops['color'] = color
3988                     flierprops['markerfacecolor'] = color
3989                     flierprops['markeredgecolor'] = color
3990 
3991         # replace medians if necessary:
3992         if usermedians is not None:
3993             if (len(np.ravel(usermedians)) != len(bxpstats) or
3994                     np.shape(usermedians)[0] != len(bxpstats)):
3995                 raise ValueError(
3996                     "'usermedians' and 'x' have different lengths")
3997             else:
3998                 # reassign medians as necessary
3999                 for stats, med in zip(bxpstats, usermedians):
4000                     if med is not None:
4001                         stats['med'] = med
4002 
4003         if conf_intervals is not None:
4004             if len(conf_intervals) != len(bxpstats):
4005                 raise ValueError(
4006                     "'conf_intervals' and 'x' have different lengths")
4007             else:
4008                 for stats, ci in zip(bxpstats, conf_intervals):
4009                     if ci is not None:
4010                         if len(ci) != 2:
4011                             raise ValueError('each confidence interval must '
4012                                              'have two values')
4013                         else:
4014                             if ci[0] is not None:
4015                                 stats['cilo'] = ci[0]
4016                             if ci[1] is not None:
4017                                 stats['cihi'] = ci[1]
4018 
4019         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4020                            vert=vert, patch_artist=patch_artist,
4021                            shownotches=notch, showmeans=showmeans,
4022                            showcaps=showcaps, showbox=showbox,
4023                            boxprops=boxprops, flierprops=flierprops,
4024                            medianprops=medianprops, meanprops=meanprops,
4025                            meanline=meanline, showfliers=showfliers,
4026                            capprops=capprops, whiskerprops=whiskerprops,
4027                            manage_ticks=manage_ticks, zorder=zorder,
4028                            capwidths=capwidths)
4029         return artists
4030 
4031     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4032             patch_artist=False, shownotches=False, showmeans=False,
4033             showcaps=True, showbox=True, showfliers=True,
4034             boxprops=None, whiskerprops=None, flierprops=None,
4035             medianprops=None, capprops=None, meanprops=None,
4036             meanline=False, manage_ticks=True, zorder=None,
4037             capwidths=None):
4038         """
4039         Drawing function for box and whisker plots.
4040 
4041         Make a box and whisker plot for each column of *x* or each
4042         vector in sequence *x*.  The box extends from the lower to
4043         upper quartile values of the data, with a line at the median.
4044         The whiskers extend from the box to show the range of the
4045         data.  Flier points are those past the end of the whiskers.
4046 
4047         Parameters
4048         ----------
4049         bxpstats : list of dicts
4050           A list of dictionaries containing stats for each boxplot.
4051           Required keys are:
4052 
4053           - ``med``: Median (scalar).
4054           - ``q1``, ``q3``: First & third quartiles (scalars).
4055           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4056 
4057           Optional keys are:
4058 
4059           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4060           - ``fliers``: Data beyond the whiskers (array-like).
4061             Needed if ``showfliers=True``.
4062           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4063             about the median. Needed if ``shownotches=True``.
4064           - ``label``: Name of the dataset (str).  If available,
4065             this will be used a tick label for the boxplot
4066 
4067         positions : array-like, default: [1, 2, ..., n]
4068           The positions of the boxes. The ticks and limits
4069           are automatically set to match the positions.
4070 
4071         widths : float or array-like, default: None
4072           The widths of the boxes.  The default is
4073           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4074 
4075         capwidths : float or array-like, default: None
4076           Either a scalar or a vector and sets the width of each cap.
4077           The default is ``0.5*(with of the box)``, see *widths*.
4078 
4079         vert : bool, default: True
4080           If `True` (default), makes the boxes vertical.
4081           If `False`, makes horizontal boxes.
4082 
4083         patch_artist : bool, default: False
4084           If `False` produces boxes with the `.Line2D` artist.
4085           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4086 
4087         shownotches, showmeans, showcaps, showbox, showfliers : bool
4088           Whether to draw the CI notches, the mean value (both default to
4089           False), the caps, the box, and the fliers (all three default to
4090           True).
4091 
4092         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4093  dict, optional
4094           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4095           means.
4096 
4097         meanline : bool, default: False
4098           If `True` (and *showmeans* is `True`), will try to render the mean
4099           as a line spanning the full width of the box according to
4100           *meanprops*. Not recommended if *shownotches* is also True.
4101           Otherwise, means will be shown as points.
4102 
4103         manage_ticks : bool, default: True
4104           If True, the tick locations and labels will be adjusted to match the
4105           boxplot positions.
4106 
4107         zorder : float, default: ``Line2D.zorder = 2``
4108           The zorder of the resulting boxplot.
4109 
4110         Returns
4111         -------
4112         dict
4113           A dictionary mapping each component of the boxplot to a list
4114           of the `.Line2D` instances created. That dictionary has the
4115           following keys (assuming vertical boxplots):
4116 
4117           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4118             the median's confidence intervals if enabled.
4119           - ``medians``: horizontal lines at the median of each box.
4120           - ``whiskers``: vertical lines up to the last non-outlier data.
4121           - ``caps``: horizontal lines at the ends of the whiskers.
4122           - ``fliers``: points representing data beyond the whiskers (fliers).
4123           - ``means``: points or lines representing the means.
4124 
4125         Examples
4126         --------
4127         .. plot:: gallery/statistics/bxp.py
4128         """
4129 
4130         # lists of artists to be output
4131         whiskers = []
4132         caps = []
4133         boxes = []
4134         medians = []
4135         means = []
4136         fliers = []
4137 
4138         # empty list of xticklabels
4139         datalabels = []
4140 
4141         # Use default zorder if none specified
4142         if zorder is None:
4143             zorder = mlines.Line2D.zorder
4144 
4145         zdelta = 0.1
4146 
4147         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4148             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4149                  if k.startswith(f'boxplot.{subkey}props')}
4150             d['zorder'] = zorder + zdelta
4151             if not usemarker:
4152                 d['marker'] = ''
4153             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4154             return d
4155 
4156         box_kw = {
4157             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4158             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4159             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4160             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4161                           else mpl.rcParams['patch.facecolor']),
4162             'zorder': zorder,
4163             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4164         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4165         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4166         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4167         flier_kw = merge_kw_rc('flier', flierprops)
4168         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4169         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4170         removed_prop = 'marker' if meanline else 'linestyle'
4171         # Only remove the property if it's not set explicitly as a parameter.
4172         if meanprops is None or removed_prop not in meanprops:
4173             mean_kw[removed_prop] = ''
4174 
4175         # vertical or horizontal plot?
4176         maybe_swap = slice(None) if vert else slice(None, None, -1)
4177 
4178         def do_plot(xs, ys, **kwargs):
4179             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4180 
4181         def do_patch(xs, ys, **kwargs):
4182             path = mpath.Path._create_closed(
4183                 np.column_stack([xs, ys][maybe_swap]))
4184             patch = mpatches.PathPatch(path, **kwargs)
4185             self.add_artist(patch)
4186             return patch
4187 
4188         # input validation
4189         N = len(bxpstats)
4190         datashape_message = ("List of boxplot statistics and `{0}` "
4191                              "values must have same the length")
4192         # check position
4193         if positions is None:
4194             positions = list(range(1, N + 1))
4195         elif len(positions) != N:
4196             raise ValueError(datashape_message.format("positions"))
4197 
4198         positions = np.array(positions)
4199         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4200             raise TypeError("positions should be an iterable of numbers")
4201 
4202         # width
4203         if widths is None:
4204             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4205         elif np.isscalar(widths):
4206             widths = [widths] * N
4207         elif len(widths) != N:
4208             raise ValueError(datashape_message.format("widths"))
4209 
4210         # capwidth
4211         if capwidths is None:
4212             capwidths = 0.5 * np.array(widths)
4213         elif np.isscalar(capwidths):
4214             capwidths = [capwidths] * N
4215         elif len(capwidths) != N:
4216             raise ValueError(datashape_message.format("capwidths"))
4217 
4218         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4219                                                capwidths):
4220             # try to find a new label
4221             datalabels.append(stats.get('label', pos))
4222 
4223             # whisker coords
4224             whis_x = [pos, pos]
4225             whislo_y = [stats['q1'], stats['whislo']]
4226             whishi_y = [stats['q3'], stats['whishi']]
4227             # cap coords
4228             cap_left = pos - capwidth * 0.5
4229             cap_right = pos + capwidth * 0.5
4230             cap_x = [cap_left, cap_right]
4231             cap_lo = np.full(2, stats['whislo'])
4232             cap_hi = np.full(2, stats['whishi'])
4233             # box and median coords
4234             box_left = pos - width * 0.5
4235             box_right = pos + width * 0.5
4236             med_y = [stats['med'], stats['med']]
4237             # notched boxes
4238             if shownotches:
4239                 notch_left = pos - width * 0.25
4240                 notch_right = pos + width * 0.25
4241                 box_x = [box_left, box_right, box_right, notch_right,
4242                          box_right, box_right, box_left, box_left, notch_left,
4243                          box_left, box_left]
4244                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4245                          stats['med'], stats['cihi'], stats['q3'],
4246                          stats['q3'], stats['cihi'], stats['med'],
4247                          stats['cilo'], stats['q1']]
4248                 med_x = [notch_left, notch_right]
4249             # plain boxes
4250             else:
4251                 box_x = [box_left, box_right, box_right, box_left, box_left]
4252                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4253                          stats['q1']]
4254                 med_x = [box_left, box_right]
4255 
4256             # maybe draw the box
4257             if showbox:
4258                 do_box = do_patch if patch_artist else do_plot
4259                 boxes.append(do_box(box_x, box_y, **box_kw))
4260             # draw the whiskers
4261             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4262             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4263             # maybe draw the caps
4264             if showcaps:
4265                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4266                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4267             # draw the medians
4268             medians.append(do_plot(med_x, med_y, **median_kw))
4269             # maybe draw the means
4270             if showmeans:
4271                 if meanline:
4272                     means.append(do_plot(
4273                         [box_left, box_right], [stats['mean'], stats['mean']],
4274                         **mean_kw
4275                     ))
4276                 else:
4277                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4278             # maybe draw the fliers
4279             if showfliers:
4280                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4281                 flier_y = stats['fliers']
4282                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4283 
4284         if manage_ticks:
4285             axis_name = "x" if vert else "y"
4286             interval = getattr(self.dataLim, f"interval{axis_name}")
4287             axis = self._axis_map[axis_name]
4288             positions = axis.convert_units(positions)
4289             # The 0.5 additional padding ensures reasonable-looking boxes
4290             # even when drawing a single box.  We set the sticky edge to
4291             # prevent margins expansion, in order to match old behavior (back
4292             # when separate calls to boxplot() would completely reset the axis
4293             # limits regardless of what was drawn before).  The sticky edges
4294             # are attached to the median lines, as they are always present.
4295             interval[:] = (min(interval[0], min(positions) - .5),
4296                            max(interval[1], max(positions) + .5))
4297             for median, position in zip(medians, positions):
4298                 getattr(median.sticky_edges, axis_name).extend(
4299                     [position - .5, position + .5])
4300             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4301             locator = axis.get_major_locator()
4302             if not isinstance(axis.get_major_locator(),
4303                               mticker.FixedLocator):
4304                 locator = mticker.FixedLocator([])
4305                 axis.set_major_locator(locator)
4306             locator.locs = np.array([*locator.locs, *positions])
4307             formatter = axis.get_major_formatter()
4308             if not isinstance(axis.get_major_formatter(),
4309                               mticker.FixedFormatter):
4310                 formatter = mticker.FixedFormatter([])
4311                 axis.set_major_formatter(formatter)
4312             formatter.seq = [*formatter.seq, *datalabels]
4313 
4314             self._request_autoscale_view()
4315 
4316         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4317                     medians=medians, fliers=fliers, means=means)
4318 
4319     @staticmethod
4320     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4321                                   get_next_color_func):
4322         """
4323         Helper function to process color related arguments of `.Axes.scatter`.
4324 
4325         Argument precedence for facecolors:
4326 
4327         - c (if not None)
4328         - kwargs['facecolor']
4329         - kwargs['facecolors']
4330         - kwargs['color'] (==kwcolor)
4331         - 'b' if in classic mode else the result of ``get_next_color_func()``
4332 
4333         Argument precedence for edgecolors:
4334 
4335         - kwargs['edgecolor']
4336         - edgecolors (is an explicit kw argument in scatter())
4337         - kwargs['color'] (==kwcolor)
4338         - 'face' if not in classic mode else None
4339 
4340         Parameters
4341         ----------
4342         c : color or sequence or sequence of color or None
4343             See argument description of `.Axes.scatter`.
4344         edgecolors : color or sequence of color or {'face', 'none'} or None
4345             See argument description of `.Axes.scatter`.
4346         kwargs : dict
4347             Additional kwargs. If these keys exist, we pop and process them:
4348             'facecolors', 'facecolor', 'edgecolor', 'color'
4349             Note: The dict is modified by this function.
4350         xsize : int
4351             The size of the x and y arrays passed to `.Axes.scatter`.
4352         get_next_color_func : callable
4353             A callable that returns a color. This color is used as facecolor
4354             if no other color is provided.
4355 
4356             Note, that this is a function rather than a fixed color value to
4357             support conditional evaluation of the next color.  As of the
4358             current implementation obtaining the next color from the
4359             property cycle advances the cycle. This must only happen if we
4360             actually use the color, which will only be decided within this
4361             method.
4362 
4363         Returns
4364         -------
4365         c
4366             The input *c* if it was not *None*, else a color derived from the
4367             other inputs or defaults.
4368         colors : array(N, 4) or None
4369             The facecolors as RGBA values, or *None* if a colormap is used.
4370         edgecolors
4371             The edgecolor.
4372 
4373         """
4374         facecolors = kwargs.pop('facecolors', None)
4375         facecolors = kwargs.pop('facecolor', facecolors)
4376         edgecolors = kwargs.pop('edgecolor', edgecolors)
4377 
4378         kwcolor = kwargs.pop('color', None)
4379 
4380         if kwcolor is not None and c is not None:
4381             raise ValueError("Supply a 'c' argument or a 'color'"
4382                              " kwarg but not both; they differ but"
4383                              " their functionalities overlap.")
4384 
4385         if kwcolor is not None:
4386             try:
4387                 mcolors.to_rgba_array(kwcolor)
4388             except ValueError as err:
4389                 raise ValueError(
4390                     "'color' kwarg must be a color or sequence of color "
4391                     "specs.  For a sequence of values to be color-mapped, use "
4392                     "the 'c' argument instead.") from err
4393             if edgecolors is None:
4394                 edgecolors = kwcolor
4395             if facecolors is None:
4396                 facecolors = kwcolor
4397 
4398         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4399             edgecolors = mpl.rcParams['scatter.edgecolors']
4400 
4401         c_was_none = c is None
4402         if c is None:
4403             c = (facecolors if facecolors is not None
4404                  else "b" if mpl.rcParams['_internal.classic_mode']
4405                  else get_next_color_func())
4406         c_is_string_or_strings = (
4407             isinstance(c, str)
4408             or (np.iterable(c) and len(c) > 0
4409                 and isinstance(cbook._safe_first_finite(c), str)))
4410 
4411         def invalid_shape_exception(csize, xsize):
4412             return ValueError(
4413                 f"'c' argument has {csize} elements, which is inconsistent "
4414                 f"with 'x' and 'y' with size {xsize}.")
4415 
4416         c_is_mapped = False  # Unless proven otherwise below.
4417         valid_shape = True  # Unless proven otherwise below.
4418         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4419             try:  # First, does 'c' look suitable for value-mapping?
4420                 c = np.asanyarray(c, dtype=float)
4421             except ValueError:
4422                 pass  # Failed to convert to float array; must be color specs.
4423             else:
4424                 # handle the documented special case of a 2D array with 1
4425                 # row which as RGB(A) to broadcast.
4426                 if c.shape == (1, 4) or c.shape == (1, 3):
4427                     c_is_mapped = False
4428                     if c.size != xsize:
4429                         valid_shape = False
4430                 # If c can be either mapped values or an RGB(A) color, prefer
4431                 # the former if shapes match, the latter otherwise.
4432                 elif c.size == xsize:
4433                     c = c.ravel()
4434                     c_is_mapped = True
4435                 else:  # Wrong size; it must not be intended for mapping.
4436                     if c.shape in ((3,), (4,)):
4437                         _api.warn_external(
4438                             "*c* argument looks like a single numeric RGB or "
4439                             "RGBA sequence, which should be avoided as value-"
4440                             "mapping will have precedence in case its length "
4441                             "matches with *x* & *y*.  Please use the *color* "
4442                             "keyword-argument or provide a 2D array "
4443                             "with a single row if you intend to specify "
4444                             "the same RGB or RGBA value for all points.")
4445                     valid_shape = False
4446         if not c_is_mapped:
4447             try:  # Is 'c' acceptable as PathCollection facecolors?
4448                 colors = mcolors.to_rgba_array(c)
4449             except (TypeError, ValueError) as err:
4450                 if "RGBA values should be within 0-1 range" in str(err):
4451                     raise
4452                 else:
4453                     if not valid_shape:
4454                         raise invalid_shape_exception(c.size, xsize) from err
4455                     # Both the mapping *and* the RGBA conversion failed: pretty
4456                     # severe failure => one may appreciate a verbose feedback.
4457                     raise ValueError(
4458                         f"'c' argument must be a color, a sequence of colors, "
4459                         f"or a sequence of numbers, not {c!r}") from err
4460             else:
4461                 if len(colors) not in (0, 1, xsize):
4462                     # NB: remember that a single color is also acceptable.
4463                     # Besides *colors* will be an empty array if c == 'none'.
4464                     raise invalid_shape_exception(len(colors), xsize)
4465         else:
4466             colors = None  # use cmap, norm after collection is created
4467         return c, colors, edgecolors
4468 
4469     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4470                                      "edgecolors", "c", "facecolor",
4471                                      "facecolors", "color"],
4472                       label_namer="y")
4473     @_docstring.interpd
4474     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4475                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4476                 edgecolors=None, plotnonfinite=False, **kwargs):
4477         """
4478         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4479 
4480         Parameters
4481         ----------
4482         x, y : float or array-like, shape (n, )
4483             The data positions.
4484 
4485         s : float or array-like, shape (n, ), optional
4486             The marker size in points**2 (typographic points are 1/72 in.).
4487             Default is ``rcParams['lines.markersize'] ** 2``.
4488 
4489             The linewidth and edgecolor can visually interact with the marker
4490             size, and can lead to artifacts if the marker size is smaller than
4491             the linewidth.
4492 
4493             If the linewidth is greater than 0 and the edgecolor is anything
4494             but *'none'*, then the effective size of the marker will be
4495             increased by half the linewidth because the stroke will be centered
4496             on the edge of the shape.
4497 
4498             To eliminate the marker edge either set *linewidth=0* or
4499             *edgecolor='none'*.
4500 
4501         c : array-like or list of colors or color, optional
4502             The marker colors. Possible values:
4503 
4504             - A scalar or sequence of n numbers to be mapped to colors using
4505               *cmap* and *norm*.
4506             - A 2D array in which the rows are RGB or RGBA.
4507             - A sequence of colors of length n.
4508             - A single color format string.
4509 
4510             Note that *c* should not be a single numeric RGB or RGBA sequence
4511             because that is indistinguishable from an array of values to be
4512             colormapped. If you want to specify the same RGB or RGBA value for
4513             all points, use a 2D array with a single row.  Otherwise,
4514             value-matching will have precedence in case of a size matching with
4515             *x* and *y*.
4516 
4517             If you wish to specify a single color for all points
4518             prefer the *color* keyword argument.
4519 
4520             Defaults to `None`. In that case the marker color is determined
4521             by the value of *color*, *facecolor* or *facecolors*. In case
4522             those are not specified or `None`, the marker color is determined
4523             by the next color of the ``Axes``' current "shape and fill" color
4524             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4525 
4526         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4527             The marker style. *marker* can be either an instance of the class
4528             or the text shorthand for a particular marker.
4529             See :mod:`matplotlib.markers` for more information about marker
4530             styles.
4531 
4532         %(cmap_doc)s
4533 
4534             This parameter is ignored if *c* is RGB(A).
4535 
4536         %(norm_doc)s
4537 
4538             This parameter is ignored if *c* is RGB(A).
4539 
4540         %(vmin_vmax_doc)s
4541 
4542             This parameter is ignored if *c* is RGB(A).
4543 
4544         alpha : float, default: None
4545             The alpha blending value, between 0 (transparent) and 1 (opaque).
4546 
4547         linewidths : float or array-like, default: :rc:`lines.linewidth`
4548             The linewidth of the marker edges. Note: The default *edgecolors*
4549             is 'face'. You may want to change this as well.
4550 
4551         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4552 default: :rc:`scatter.edgecolors`
4553             The edge color of the marker. Possible values:
4554 
4555             - 'face': The edge color will always be the same as the face color.
4556             - 'none': No patch boundary will be drawn.
4557             - A color or sequence of colors.
4558 
4559             For non-filled markers, *edgecolors* is ignored. Instead, the color
4560             is determined like with 'face', i.e. from *c*, *colors*, or
4561             *facecolors*.
4562 
4563         plotnonfinite : bool, default: False
4564             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4565             or ``nan``). If ``True`` the points are drawn with the *bad*
4566             colormap color (see `.Colormap.set_bad`).
4567 
4568         Returns
4569         -------
4570         `~matplotlib.collections.PathCollection`
4571 
4572         Other Parameters
4573         ----------------
4574         data : indexable object, optional
4575             DATA_PARAMETER_PLACEHOLDER
4576         **kwargs : `~matplotlib.collections.Collection` properties
4577 
4578         See Also
4579         --------
4580         plot : To plot scatter plots when markers are identical in size and
4581             color.
4582 
4583         Notes
4584         -----
4585         * The `.plot` function will be faster for scatterplots where markers
4586           don't vary in size or color.
4587 
4588         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4589           case all masks will be combined and only unmasked points will be
4590           plotted.
4591 
4592         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4593           may be input as N-D arrays, but within scatter they will be
4594           flattened. The exception is *c*, which will be flattened only if its
4595           size matches the size of *x* and *y*.
4596 
4597         """
4598         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4599         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4600         # np.ma.ravel yields an ndarray, not a masked array,
4601         # unless its argument is a masked array.
4602         x = np.ma.ravel(x)
4603         y = np.ma.ravel(y)
4604         if x.size != y.size:
4605             raise ValueError("x and y must be the same size")
4606 
4607         if s is None:
4608             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4609                  mpl.rcParams['lines.markersize'] ** 2.0)
4610         s = np.ma.ravel(s)
4611         if (len(s) not in (1, x.size) or
4612                 (not np.issubdtype(s.dtype, np.floating) and
4613                  not np.issubdtype(s.dtype, np.integer))):
4614             raise ValueError(
4615                 "s must be a scalar, "
4616                 "or float array-like with the same size as x and y")
4617 
4618         # get the original edgecolor the user passed before we normalize
4619         orig_edgecolor = edgecolors
4620         if edgecolors is None:
4621             orig_edgecolor = kwargs.get('edgecolor', None)
4622         c, colors, edgecolors = \
4623             self._parse_scatter_color_args(
4624                 c, edgecolors, kwargs, x.size,
4625                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4626 
4627         if plotnonfinite and colors is None:
4628             c = np.ma.masked_invalid(c)
4629             x, y, s, edgecolors, linewidths = \
4630                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4631         else:
4632             x, y, s, c, colors, edgecolors, linewidths = \
4633                 cbook._combine_masks(
4634                     x, y, s, c, colors, edgecolors, linewidths)
4635         # Unmask edgecolors if it was actually a single RGB or RGBA.
4636         if (x.size in (3, 4)
4637                 and np.ma.is_masked(edgecolors)
4638                 and not np.ma.is_masked(orig_edgecolor)):
4639             edgecolors = edgecolors.data
4640 
4641         scales = s   # Renamed for readability below.
4642 
4643         # load default marker from rcParams
4644         if marker is None:
4645             marker = mpl.rcParams['scatter.marker']
4646 
4647         if isinstance(marker, mmarkers.MarkerStyle):
4648             marker_obj = marker
4649         else:
4650             marker_obj = mmarkers.MarkerStyle(marker)
4651 
4652         path = marker_obj.get_path().transformed(
4653             marker_obj.get_transform())
4654         if not marker_obj.is_filled():
4655             if orig_edgecolor is not None:
4656                 _api.warn_external(
4657                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4658                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4659                     "ignoring the edgecolor in favor of the facecolor.  This "
4660                     "behavior may change in the future."
4661                 )
4662             # We need to handle markers that cannot be filled (like
4663             # '+' and 'x') differently than markers that can be
4664             # filled, but have their fillstyle set to 'none'.  This is
4665             # to get:
4666             #
4667             #  - respecting the fillestyle if set
4668             #  - maintaining back-compatibility for querying the facecolor of
4669             #    the un-fillable markers.
4670             #
4671             # While not an ideal situation, but is better than the
4672             # alternatives.
4673             if marker_obj.get_fillstyle() == 'none':
4674                 # promote the facecolor to be the edgecolor
4675                 edgecolors = colors
4676                 # set the facecolor to 'none' (at the last chance) because
4677                 # we cannot fill a path if the facecolor is non-null
4678                 # (which is defendable at the renderer level).
4679                 colors = 'none'
4680             else:
4681                 # if we are not nulling the face color we can do this
4682                 # simpler
4683                 edgecolors = 'face'
4684 
4685             if linewidths is None:
4686                 linewidths = mpl.rcParams['lines.linewidth']
4687             elif np.iterable(linewidths):
4688                 linewidths = [
4689                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4690                     for lw in linewidths]
4691 
4692         offsets = np.ma.column_stack([x, y])
4693 
4694         collection = mcoll.PathCollection(
4695             (path,), scales,
4696             facecolors=colors,
4697             edgecolors=edgecolors,
4698             linewidths=linewidths,
4699             offsets=offsets,
4700             offset_transform=kwargs.pop('transform', self.transData),
4701             alpha=alpha,
4702         )
4703         collection.set_transform(mtransforms.IdentityTransform())
4704         if colors is None:
4705             collection.set_array(c)
4706             collection.set_cmap(cmap)
4707             collection.set_norm(norm)
4708             collection._scale_norm(norm, vmin, vmax)
4709         else:
4710             extra_kwargs = {
4711                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4712                     }
4713             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4714             if any(extra_keys):
4715                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4716                 _api.warn_external(
4717                     "No data for colormapping provided via 'c'. "
4718                     f"Parameters {keys_str} will be ignored")
4719         collection._internal_update(kwargs)
4720 
4721         # Classic mode only:
4722         # ensure there are margins to allow for the
4723         # finite size of the symbols.  In v2.x, margins
4724         # are present by default, so we disable this
4725         # scatter-specific override.
4726         if mpl.rcParams['_internal.classic_mode']:
4727             if self._xmargin < 0.05 and x.size > 0:
4728                 self.set_xmargin(0.05)
4729             if self._ymargin < 0.05 and x.size > 0:
4730                 self.set_ymargin(0.05)
4731 
4732         self.add_collection(collection)
4733         self._request_autoscale_view()
4734 
4735         return collection
4736 
4737     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4738     @_docstring.dedent_interpd
4739     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4740                xscale='linear', yscale='linear', extent=None,
4741                cmap=None, norm=None, vmin=None, vmax=None,
4742                alpha=None, linewidths=None, edgecolors='face',
4743                reduce_C_function=np.mean, mincnt=None, marginals=False,
4744                **kwargs):
4745         """
4746         Make a 2D hexagonal binning plot of points *x*, *y*.
4747 
4748         If *C* is *None*, the value of the hexagon is determined by the number
4749         of points in the hexagon. Otherwise, *C* specifies values at the
4750         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4751         using *reduce_C_function*.
4752 
4753         Parameters
4754         ----------
4755         x, y : array-like
4756             The data positions. *x* and *y* must be of the same length.
4757 
4758         C : array-like, optional
4759             If given, these values are accumulated in the bins. Otherwise,
4760             every point has a value of 1. Must be of the same length as *x*
4761             and *y*.
4762 
4763         gridsize : int or (int, int), default: 100
4764             If a single int, the number of hexagons in the *x*-direction.
4765             The number of hexagons in the *y*-direction is chosen such that
4766             the hexagons are approximately regular.
4767 
4768             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4769             in the *x*-direction and the *y*-direction. In the
4770             *y*-direction, counting is done along vertically aligned
4771             hexagons, not along the zig-zag chains of hexagons; see the
4772             following illustration.
4773 
4774             .. plot::
4775 
4776                import numpy
4777                import matplotlib.pyplot as plt
4778 
4779                np.random.seed(19680801)
4780                n= 300
4781                x = np.random.standard_normal(n)
4782                y = np.random.standard_normal(n)
4783 
4784                fig, ax = plt.subplots(figsize=(4, 4))
4785                h = ax.hexbin(x, y, gridsize=(5, 3))
4786                hx, hy = h.get_offsets().T
4787                ax.plot(hx[24::3], hy[24::3], 'ro-')
4788                ax.plot(hx[-3:], hy[-3:], 'ro-')
4789                ax.set_title('gridsize=(5, 3)')
4790                ax.axis('off')
4791 
4792             To get approximately regular hexagons, choose
4793             :math:`n_x = \\sqrt{3}\\,n_y`.
4794 
4795         bins : 'log' or int or sequence, default: None
4796             Discretization of the hexagon values.
4797 
4798             - If *None*, no binning is applied; the color of each hexagon
4799               directly corresponds to its count value.
4800             - If 'log', use a logarithmic scale for the colormap.
4801               Internally, :math:`log_{10}(i+1)` is used to determine the
4802               hexagon color. This is equivalent to ``norm=LogNorm()``.
4803             - If an integer, divide the counts in the specified number
4804               of bins, and color the hexagons accordingly.
4805             - If a sequence of values, the values of the lower bound of
4806               the bins to be used.
4807 
4808         xscale : {'linear', 'log'}, default: 'linear'
4809             Use a linear or log10 scale on the horizontal axis.
4810 
4811         yscale : {'linear', 'log'}, default: 'linear'
4812             Use a linear or log10 scale on the vertical axis.
4813 
4814         mincnt : int > 0, default: *None*
4815             If not *None*, only display cells with more than *mincnt*
4816             number of points in the cell.
4817 
4818         marginals : bool, default: *False*
4819             If marginals is *True*, plot the marginal density as
4820             colormapped rectangles along the bottom of the x-axis and
4821             left of the y-axis.
4822 
4823         extent : 4-tuple of float, default: *None*
4824             The limits of the bins (xmin, xmax, ymin, ymax).
4825             The default assigns the limits based on
4826             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4827 
4828             If *xscale* or *yscale* is set to 'log', the limits are
4829             expected to be the exponent for a power of 10. E.g. for
4830             x-limits of 1 and 50 in 'linear' scale and y-limits
4831             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4832 
4833         Returns
4834         -------
4835         `~matplotlib.collections.PolyCollection`
4836             A `.PolyCollection` defining the hexagonal bins.
4837 
4838             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4839               the x, y positions of the M hexagon centers.
4840             - `.PolyCollection.get_array` contains the values of the M
4841               hexagons.
4842 
4843             If *marginals* is *True*, horizontal
4844             bar and vertical bar (both PolyCollections) will be attached
4845             to the return collection as attributes *hbar* and *vbar*.
4846 
4847         Other Parameters
4848         ----------------
4849         %(cmap_doc)s
4850 
4851         %(norm_doc)s
4852 
4853         %(vmin_vmax_doc)s
4854 
4855         alpha : float between 0 and 1, optional
4856             The alpha blending value, between 0 (transparent) and 1 (opaque).
4857 
4858         linewidths : float, default: *None*
4859             If *None*, defaults to 1.0.
4860 
4861         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4862             The color of the hexagon edges. Possible values are:
4863 
4864             - 'face': Draw the edges in the same color as the fill color.
4865             - 'none': No edges are drawn. This can sometimes lead to unsightly
4866               unpainted pixels between the hexagons.
4867             - *None*: Draw outlines in the default color.
4868             - An explicit color.
4869 
4870         reduce_C_function : callable, default: `numpy.mean`
4871             The function to aggregate *C* within the bins. It is ignored if
4872             *C* is not given. This must have the signature::
4873 
4874                 def reduce_C_function(C: array) -> float
4875 
4876             Commonly used functions are:
4877 
4878             - `numpy.mean`: average of the points
4879             - `numpy.sum`: integral of the point values
4880             - `numpy.amax`: value taken from the largest point
4881 
4882         data : indexable object, optional
4883             DATA_PARAMETER_PLACEHOLDER
4884 
4885         **kwargs : `~matplotlib.collections.PolyCollection` properties
4886             All other keyword arguments are passed on to `.PolyCollection`:
4887 
4888             %(PolyCollection:kwdoc)s
4889 
4890         See Also
4891         --------
4892         hist2d : 2D histogram rectangular bins
4893         """
4894         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4895 
4896         x, y, C = cbook.delete_masked_points(x, y, C)
4897 
4898         # Set the size of the hexagon grid
4899         if np.iterable(gridsize):
4900             nx, ny = gridsize
4901         else:
4902             nx = gridsize
4903             ny = int(nx / math.sqrt(3))
4904         # Count the number of data in each hexagon
4905         x = np.asarray(x, float)
4906         y = np.asarray(y, float)
4907 
4908         # Will be log()'d if necessary, and then rescaled.
4909         tx = x
4910         ty = y
4911 
4912         if xscale == 'log':
4913             if np.any(x <= 0.0):
4914                 raise ValueError(
4915                     "x contains non-positive values, so cannot be log-scaled")
4916             tx = np.log10(tx)
4917         if yscale == 'log':
4918             if np.any(y <= 0.0):
4919                 raise ValueError(
4920                     "y contains non-positive values, so cannot be log-scaled")
4921             ty = np.log10(ty)
4922         if extent is not None:
4923             xmin, xmax, ymin, ymax = extent
4924         else:
4925             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4926             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4927 
4928             # to avoid issues with singular data, expand the min/max pairs
4929             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4930             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4931 
4932         nx1 = nx + 1
4933         ny1 = ny + 1
4934         nx2 = nx
4935         ny2 = ny
4936         n = nx1 * ny1 + nx2 * ny2
4937 
4938         # In the x-direction, the hexagons exactly cover the region from
4939         # xmin to xmax. Need some padding to avoid roundoff errors.
4940         padding = 1.e-9 * (xmax - xmin)
4941         xmin -= padding
4942         xmax += padding
4943         sx = (xmax - xmin) / nx
4944         sy = (ymax - ymin) / ny
4945         # Positions in hexagon index coordinates.
4946         ix = (tx - xmin) / sx
4947         iy = (ty - ymin) / sy
4948         ix1 = np.round(ix).astype(int)
4949         iy1 = np.round(iy).astype(int)
4950         ix2 = np.floor(ix).astype(int)
4951         iy2 = np.floor(iy).astype(int)
4952         # flat indices, plus one so that out-of-range points go to position 0.
4953         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4954                       ix1 * ny1 + iy1 + 1, 0)
4955         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4956                       ix2 * ny2 + iy2 + 1, 0)
4957 
4958         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4959         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4960         bdist = (d1 < d2)
4961 
4962         if C is None:  # [1:] drops out-of-range points.
4963             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4964             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4965             accum = np.concatenate([counts1, counts2]).astype(float)
4966             if mincnt is not None:
4967                 accum[accum < mincnt] = np.nan
4968             C = np.ones(len(x))
4969         else:
4970             # store the C values in a list per hexagon index
4971             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4972             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4973             for i in range(len(x)):
4974                 if bdist[i]:
4975                     Cs_at_i1[i1[i]].append(C[i])
4976                 else:
4977                     Cs_at_i2[i2[i]].append(C[i])
4978             if mincnt is None:
4979                 mincnt = 0
4980             accum = np.array(
4981                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4982                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4983                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4984                 float)
4985 
4986         good_idxs = ~np.isnan(accum)
4987 
4988         offsets = np.zeros((n, 2), float)
4989         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4990         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4991         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4992         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4993         offsets[:, 0] *= sx
4994         offsets[:, 1] *= sy
4995         offsets[:, 0] += xmin
4996         offsets[:, 1] += ymin
4997         # remove accumulation bins with no data
4998         offsets = offsets[good_idxs, :]
4999         accum = accum[good_idxs]
5000 
5001         polygon = [sx, sy / 3] * np.array(
5002             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5003 
5004         if linewidths is None:
5005             linewidths = [1.0]
5006 
5007         if xscale == 'log' or yscale == 'log':
5008             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5009             if xscale == 'log':
5010                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5011                 xmin = 10.0 ** xmin
5012                 xmax = 10.0 ** xmax
5013                 self.set_xscale(xscale)
5014             if yscale == 'log':
5015                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5016                 ymin = 10.0 ** ymin
5017                 ymax = 10.0 ** ymax
5018                 self.set_yscale(yscale)
5019             collection = mcoll.PolyCollection(
5020                 polygons,
5021                 edgecolors=edgecolors,
5022                 linewidths=linewidths,
5023                 )
5024         else:
5025             collection = mcoll.PolyCollection(
5026                 [polygon],
5027                 edgecolors=edgecolors,
5028                 linewidths=linewidths,
5029                 offsets=offsets,
5030                 offset_transform=mtransforms.AffineDeltaTransform(
5031                     self.transData),
5032             )
5033 
5034         # Set normalizer if bins is 'log'
5035         if bins == 'log':
5036             if norm is not None:
5037                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5038                                    f"can be supplied, ignoring bins={bins}")
5039             else:
5040                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5041                 vmin = vmax = None
5042             bins = None
5043 
5044         # autoscale the norm with current accum values if it hasn't been set
5045         if norm is not None:
5046             if norm.vmin is None and norm.vmax is None:
5047                 norm.autoscale(accum)
5048 
5049         if bins is not None:
5050             if not np.iterable(bins):
5051                 minimum, maximum = min(accum), max(accum)
5052                 bins -= 1  # one less edge than bins
5053                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5054             bins = np.sort(bins)
5055             accum = bins.searchsorted(accum)
5056 
5057         collection.set_array(accum)
5058         collection.set_cmap(cmap)
5059         collection.set_norm(norm)
5060         collection.set_alpha(alpha)
5061         collection._internal_update(kwargs)
5062         collection._scale_norm(norm, vmin, vmax)
5063 
5064         corners = ((xmin, ymin), (xmax, ymax))
5065         self.update_datalim(corners)
5066         self._request_autoscale_view(tight=True)
5067 
5068         # add the collection last
5069         self.add_collection(collection, autolim=False)
5070         if not marginals:
5071             return collection
5072 
5073         # Process marginals
5074         bars = []
5075         for zname, z, zmin, zmax, zscale, nbins in [
5076                 ("x", x, xmin, xmax, xscale, nx),
5077                 ("y", y, ymin, ymax, yscale, 2 * ny),
5078         ]:
5079 
5080             if zscale == "log":
5081                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5082             else:
5083                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5084 
5085             verts = np.empty((nbins, 4, 2))
5086             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5087             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5088             verts[:, 0, 1] = verts[:, 3, 1] = .00
5089             verts[:, 1, 1] = verts[:, 2, 1] = .05
5090             if zname == "y":
5091                 verts = verts[:, :, ::-1]  # Swap x and y.
5092 
5093             # Sort z-values into bins defined by bin_edges.
5094             bin_idxs = np.searchsorted(bin_edges, z) - 1
5095             values = np.empty(nbins)
5096             for i in range(nbins):
5097                 # Get C-values for each bin, and compute bin value with
5098                 # reduce_C_function.
5099                 ci = C[bin_idxs == i]
5100                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5101 
5102             mask = ~np.isnan(values)
5103             verts = verts[mask]
5104             values = values[mask]
5105 
5106             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5107             bar = mcoll.PolyCollection(
5108                 verts, transform=trans, edgecolors="face")
5109             bar.set_array(values)
5110             bar.set_cmap(cmap)
5111             bar.set_norm(norm)
5112             bar.set_alpha(alpha)
5113             bar._internal_update(kwargs)
5114             bars.append(self.add_collection(bar, autolim=False))
5115 
5116         collection.hbar, collection.vbar = bars
5117 
5118         def on_changed(collection):
5119             collection.hbar.set_cmap(collection.get_cmap())
5120             collection.hbar.set_cmap(collection.get_cmap())
5121             collection.vbar.set_clim(collection.get_clim())
5122             collection.vbar.set_clim(collection.get_clim())
5123 
5124         collection.callbacks.connect('changed', on_changed)
5125 
5126         return collection
5127 
5128     @_docstring.dedent_interpd
5129     def arrow(self, x, y, dx, dy, **kwargs):
5130         """
5131         Add an arrow to the Axes.
5132 
5133         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5134 
5135         Parameters
5136         ----------
5137         %(FancyArrow)s
5138 
5139         Returns
5140         -------
5141         `.FancyArrow`
5142             The created `.FancyArrow` object.
5143 
5144         Notes
5145         -----
5146         The resulting arrow is affected by the Axes aspect ratio and limits.
5147         This may produce an arrow whose head is not square with its stem. To
5148         create an arrow whose head is square with its stem,
5149         use :meth:`annotate` for example:
5150 
5151         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5152         ...             arrowprops=dict(arrowstyle="->"))
5153 
5154         """
5155         # Strip away units for the underlying patch since units
5156         # do not make sense to most patch-like code
5157         x = self.convert_xunits(x)
5158         y = self.convert_yunits(y)
5159         dx = self.convert_xunits(dx)
5160         dy = self.convert_yunits(dy)
5161 
5162         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5163         self.add_patch(a)
5164         self._request_autoscale_view()
5165         return a
5166 
5167     @_docstring.copy(mquiver.QuiverKey.__init__)
5168     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5169         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5170         self.add_artist(qk)
5171         return qk
5172 
5173     # Handle units for x and y, if they've been passed
5174     def _quiver_units(self, args, kwargs):
5175         if len(args) > 3:
5176             x, y = args[0:2]
5177             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5178             return (x, y) + args[2:]
5179         return args
5180 
5181     # args can be a combination of X, Y, U, V, C and all should be replaced
5182     @_preprocess_data()
5183     @_docstring.dedent_interpd
5184     def quiver(self, *args, **kwargs):
5185         """%(quiver_doc)s"""
5186         # Make sure units are handled for x and y values
5187         args = self._quiver_units(args, kwargs)
5188         q = mquiver.Quiver(self, *args, **kwargs)
5189         self.add_collection(q, autolim=True)
5190         self._request_autoscale_view()
5191         return q
5192 
5193     # args can be some combination of X, Y, U, V, C and all should be replaced
5194     @_preprocess_data()
5195     @_docstring.dedent_interpd
5196     def barbs(self, *args, **kwargs):
5197         """%(barbs_doc)s"""
5198         # Make sure units are handled for x and y values
5199         args = self._quiver_units(args, kwargs)
5200         b = mquiver.Barbs(self, *args, **kwargs)
5201         self.add_collection(b, autolim=True)
5202         self._request_autoscale_view()
5203         return b
5204 
5205     # Uses a custom implementation of data-kwarg handling in
5206     # _process_plot_var_args.
5207     def fill(self, *args, data=None, **kwargs):
5208         """
5209         Plot filled polygons.
5210 
5211         Parameters
5212         ----------
5213         *args : sequence of x, y, [color]
5214             Each polygon is defined by the lists of *x* and *y* positions of
5215             its nodes, optionally followed by a *color* specifier. See
5216             :mod:`matplotlib.colors` for supported color specifiers. The
5217             standard color cycle is used for polygons without a color
5218             specifier.
5219 
5220             You can plot multiple polygons by providing multiple *x*, *y*,
5221             *[color]* groups.
5222 
5223             For example, each of the following is legal::
5224 
5225                 ax.fill(x, y)                    # a polygon with default color
5226                 ax.fill(x, y, "b")               # a blue polygon
5227                 ax.fill(x, y, x2, y2)            # two polygons
5228                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5229 
5230         data : indexable object, optional
5231             An object with labelled data. If given, provide the label names to
5232             plot in *x* and *y*, e.g.::
5233 
5234                 ax.fill("time", "signal",
5235                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5236 
5237         Returns
5238         -------
5239         list of `~matplotlib.patches.Polygon`
5240 
5241         Other Parameters
5242         ----------------
5243         **kwargs : `~matplotlib.patches.Polygon` properties
5244 
5245         Notes
5246         -----
5247         Use :meth:`fill_between` if you would like to fill the region between
5248         two curves.
5249         """
5250         # For compatibility(!), get aliases from Line2D rather than Patch.
5251         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5252         # _get_patches_for_fill returns a generator, convert it to a list.
5253         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5254         for poly in patches:
5255             self.add_patch(poly)
5256         self._request_autoscale_view()
5257         return patches
5258 
5259     def _fill_between_x_or_y(
5260             self, ind_dir, ind, dep1, dep2=0, *,
5261             where=None, interpolate=False, step=None, **kwargs):
5262         # Common implementation between fill_between (*ind_dir*="x") and
5263         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5264         # *dep* the dependent variable.  The docstring below is interpolated
5265         # to generate both methods' docstrings.
5266         """
5267         Fill the area between two {dir} curves.
5268 
5269         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5270         *{dep}2*).  This creates one or multiple polygons describing the filled
5271         area.
5272 
5273         You may exclude some {dir} sections from filling using *where*.
5274 
5275         By default, the edges connect the given points directly.  Use *step*
5276         if the filling should be a step function, i.e. constant in between
5277         *{ind}*.
5278 
5279         Parameters
5280         ----------
5281         {ind} : array (length N)
5282             The {ind} coordinates of the nodes defining the curves.
5283 
5284         {dep}1 : array (length N) or scalar
5285             The {dep} coordinates of the nodes defining the first curve.
5286 
5287         {dep}2 : array (length N) or scalar, default: 0
5288             The {dep} coordinates of the nodes defining the second curve.
5289 
5290         where : array of bool (length N), optional
5291             Define *where* to exclude some {dir} regions from being filled.
5292             The filled regions are defined by the coordinates ``{ind}[where]``.
5293             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5294             ``where[i] and where[i+1]``.  Note that this definition implies
5295             that an isolated *True* value between two *False* values in *where*
5296             will not result in filling.  Both sides of the *True* position
5297             remain unfilled due to the adjacent *False* values.
5298 
5299         interpolate : bool, default: False
5300             This option is only relevant if *where* is used and the two curves
5301             are crossing each other.
5302 
5303             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5304             similar.  By default, the nodes of the polygon defining the filled
5305             region will only be placed at the positions in the *{ind}* array.
5306             Such a polygon cannot describe the above semantics close to the
5307             intersection.  The {ind}-sections containing the intersection are
5308             simply clipped.
5309 
5310             Setting *interpolate* to *True* will calculate the actual
5311             intersection point and extend the filled region up to this point.
5312 
5313         step : {{'pre', 'post', 'mid'}}, optional
5314             Define *step* if the filling should be a step function,
5315             i.e. constant in between *{ind}*.  The value determines where the
5316             step will occur:
5317 
5318             - 'pre': The y value is continued constantly to the left from
5319               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5320               value ``y[i]``.
5321             - 'post': The y value is continued constantly to the right from
5322               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5323               value ``y[i]``.
5324             - 'mid': Steps occur half-way between the *x* positions.
5325 
5326         Returns
5327         -------
5328         `.PolyCollection`
5329             A `.PolyCollection` containing the plotted polygons.
5330 
5331         Other Parameters
5332         ----------------
5333         data : indexable object, optional
5334             DATA_PARAMETER_PLACEHOLDER
5335 
5336         **kwargs
5337             All other keyword arguments are passed on to `.PolyCollection`.
5338             They control the `.Polygon` properties:
5339 
5340             %(PolyCollection:kwdoc)s
5341 
5342         See Also
5343         --------
5344         fill_between : Fill between two sets of y-values.
5345         fill_betweenx : Fill between two sets of x-values.
5346         """
5347 
5348         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5349 
5350         if not mpl.rcParams["_internal.classic_mode"]:
5351             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5352             if not any(c in kwargs for c in ("color", "facecolor")):
5353                 kwargs["facecolor"] = \
5354                     self._get_patches_for_fill.get_next_color()
5355 
5356         # Handle united data, such as dates
5357         ind, dep1, dep2 = map(
5358             ma.masked_invalid, self._process_unit_info(
5359                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5360 
5361         for name, array in [
5362                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5363             if array.ndim > 1:
5364                 raise ValueError(f"{name!r} is not 1-dimensional")
5365 
5366         if where is None:
5367             where = True
5368         else:
5369             where = np.asarray(where, dtype=bool)
5370             if where.size != ind.size:
5371                 raise ValueError(f"where size ({where.size}) does not match "
5372                                  f"{ind_dir} size ({ind.size})")
5373         where = where & ~functools.reduce(
5374             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5375 
5376         ind, dep1, dep2 = np.broadcast_arrays(
5377             np.atleast_1d(ind), dep1, dep2, subok=True)
5378 
5379         polys = []
5380         for idx0, idx1 in cbook.contiguous_regions(where):
5381             indslice = ind[idx0:idx1]
5382             dep1slice = dep1[idx0:idx1]
5383             dep2slice = dep2[idx0:idx1]
5384             if step is not None:
5385                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5386                 indslice, dep1slice, dep2slice = \
5387                     step_func(indslice, dep1slice, dep2slice)
5388 
5389             if not len(indslice):
5390                 continue
5391 
5392             N = len(indslice)
5393             pts = np.zeros((2 * N + 2, 2))
5394 
5395             if interpolate:
5396                 def get_interp_point(idx):
5397                     im1 = max(idx - 1, 0)
5398                     ind_values = ind[im1:idx+1]
5399                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5400                     dep1_values = dep1[im1:idx+1]
5401 
5402                     if len(diff_values) == 2:
5403                         if np.ma.is_masked(diff_values[1]):
5404                             return ind[im1], dep1[im1]
5405                         elif np.ma.is_masked(diff_values[0]):
5406                             return ind[idx], dep1[idx]
5407 
5408                     diff_order = diff_values.argsort()
5409                     diff_root_ind = np.interp(
5410                         0, diff_values[diff_order], ind_values[diff_order])
5411                     ind_order = ind_values.argsort()
5412                     diff_root_dep = np.interp(
5413                         diff_root_ind,
5414                         ind_values[ind_order], dep1_values[ind_order])
5415                     return diff_root_ind, diff_root_dep
5416 
5417                 start = get_interp_point(idx0)
5418                 end = get_interp_point(idx1)
5419             else:
5420                 # Handle scalar dep2 (e.g. 0): the fill should go all
5421                 # the way down to 0 even if none of the dep1 sample points do.
5422                 start = indslice[0], dep2slice[0]
5423                 end = indslice[-1], dep2slice[-1]
5424 
5425             pts[0] = start
5426             pts[N + 1] = end
5427 
5428             pts[1:N+1, 0] = indslice
5429             pts[1:N+1, 1] = dep1slice
5430             pts[N+2:, 0] = indslice[::-1]
5431             pts[N+2:, 1] = dep2slice[::-1]
5432 
5433             if ind_dir == "y":
5434                 pts = pts[:, ::-1]
5435 
5436             polys.append(pts)
5437 
5438         collection = mcoll.PolyCollection(polys, **kwargs)
5439 
5440         # now update the datalim and autoscale
5441         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5442                             np.column_stack([ind[where], dep2[where]])])
5443         if ind_dir == "y":
5444             pts = pts[:, ::-1]
5445 
5446         up_x = up_y = True
5447         if "transform" in kwargs:
5448             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5449         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5450 
5451         self.add_collection(collection, autolim=False)
5452         self._request_autoscale_view()
5453         return collection
5454 
5455     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5456                      step=None, **kwargs):
5457         return self._fill_between_x_or_y(
5458             "x", x, y1, y2,
5459             where=where, interpolate=interpolate, step=step, **kwargs)
5460 
5461     if _fill_between_x_or_y.__doc__:
5462         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5463             dir="horizontal", ind="x", dep="y"
5464         )
5465     fill_between = _preprocess_data(
5466         _docstring.dedent_interpd(fill_between),
5467         replace_names=["x", "y1", "y2", "where"])
5468 
5469     def fill_betweenx(self, y, x1, x2=0, where=None,
5470                       step=None, interpolate=False, **kwargs):
5471         return self._fill_between_x_or_y(
5472             "y", y, x1, x2,
5473             where=where, interpolate=interpolate, step=step, **kwargs)
5474 
5475     if _fill_between_x_or_y.__doc__:
5476         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5477             dir="vertical", ind="y", dep="x"
5478         )
5479     fill_betweenx = _preprocess_data(
5480         _docstring.dedent_interpd(fill_betweenx),
5481         replace_names=["y", "x1", "x2", "where"])
5482 
5483     #### plotting z(x, y): imshow, pcolor and relatives, contour
5484 
5485     @_preprocess_data()
5486     @_docstring.interpd
5487     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5488                interpolation=None, alpha=None,
5489                vmin=None, vmax=None, origin=None, extent=None,
5490                interpolation_stage=None, filternorm=True, filterrad=4.0,
5491                resample=None, url=None, **kwargs):
5492         """
5493         Display data as an image, i.e., on a 2D regular raster.
5494 
5495         The input may either be actual RGB(A) data, or 2D scalar data, which
5496         will be rendered as a pseudocolor image. For displaying a grayscale
5497         image set up the colormapping using the parameters
5498         ``cmap='gray', vmin=0, vmax=255``.
5499 
5500         The number of pixels used to render an image is set by the Axes size
5501         and the *dpi* of the figure. This can lead to aliasing artifacts when
5502         the image is resampled because the displayed image size will usually
5503         not match the size of *X* (see
5504         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5505         The resampling can be controlled via the *interpolation* parameter
5506         and/or :rc:`image.interpolation`.
5507 
5508         Parameters
5509         ----------
5510         X : array-like or PIL image
5511             The image data. Supported array shapes are:
5512 
5513             - (M, N): an image with scalar data. The values are mapped to
5514               colors using normalization and a colormap. See parameters *norm*,
5515               *cmap*, *vmin*, *vmax*.
5516             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5517             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5518               i.e. including transparency.
5519 
5520             The first two dimensions (M, N) define the rows and columns of
5521             the image.
5522 
5523             Out-of-range RGB(A) values are clipped.
5524 
5525         %(cmap_doc)s
5526 
5527             This parameter is ignored if *X* is RGB(A).
5528 
5529         %(norm_doc)s
5530 
5531             This parameter is ignored if *X* is RGB(A).
5532 
5533         %(vmin_vmax_doc)s
5534 
5535             This parameter is ignored if *X* is RGB(A).
5536 
5537         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5538             The aspect ratio of the Axes.  This parameter is particularly
5539             relevant for images since it determines whether data pixels are
5540             square.
5541 
5542             This parameter is a shortcut for explicitly calling
5543             `.Axes.set_aspect`. See there for further details.
5544 
5545             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5546               (unless pixel sizes are explicitly made non-square in data
5547               coordinates using *extent*).
5548             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5549               that the data fit in the Axes. In general, this will result in
5550               non-square pixels.
5551 
5552         interpolation : str, default: :rc:`image.interpolation`
5553             The interpolation method used.
5554 
5555             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5556             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5557             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5558             'sinc', 'lanczos', 'blackman'.
5559 
5560             The data *X* is resampled to the pixel size of the image on the
5561             figure canvas, using the interpolation method to either up- or
5562             downsample the data.
5563 
5564             If *interpolation* is 'none', then for the ps, pdf, and svg
5565             backends no down- or upsampling occurs, and the image data is
5566             passed to the backend as a native image.  Note that different ps,
5567             pdf, and svg viewers may display these raw pixels differently. On
5568             other backends, 'none' is the same as 'nearest'.
5569 
5570             If *interpolation* is the default 'antialiased', then 'nearest'
5571             interpolation is used if the image is upsampled by more than a
5572             factor of three (i.e. the number of display pixels is at least
5573             three times the size of the data array).  If the upsampling rate is
5574             smaller than 3, or the image is downsampled, then 'hanning'
5575             interpolation is used to act as an anti-aliasing filter, unless the
5576             image happens to be upsampled by exactly a factor of two or one.
5577 
5578             See
5579             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5580             for an overview of the supported interpolation methods, and
5581             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5582             a discussion of image antialiasing.
5583 
5584             Some interpolation methods require an additional radius parameter,
5585             which can be set by *filterrad*. Additionally, the antigrain image
5586             resize filter is controlled by the parameter *filternorm*.
5587 
5588         interpolation_stage : {'data', 'rgba'}, default: 'data'
5589             If 'data', interpolation
5590             is carried out on the data provided by the user.  If 'rgba', the
5591             interpolation is carried out after the colormapping has been
5592             applied (visual interpolation).
5593 
5594         alpha : float or array-like, optional
5595             The alpha blending value, between 0 (transparent) and 1 (opaque).
5596             If *alpha* is an array, the alpha blending values are applied pixel
5597             by pixel, and *alpha* must have the same shape as *X*.
5598 
5599         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5600             Place the [0, 0] index of the array in the upper left or lower
5601             left corner of the Axes. The convention (the default) 'upper' is
5602             typically used for matrices and images.
5603 
5604             Note that the vertical axis points upward for 'lower'
5605             but downward for 'upper'.
5606 
5607             See the :ref:`imshow_extent` tutorial for
5608             examples and a more detailed description.
5609 
5610         extent : floats (left, right, bottom, top), optional
5611             The bounding box in data coordinates that the image will fill.
5612             These values may be unitful and match the units of the Axes.
5613             The image is stretched individually along x and y to fill the box.
5614 
5615             The default extent is determined by the following conditions.
5616             Pixels have unit size in data coordinates. Their centers are on
5617             integer coordinates, and their center coordinates range from 0 to
5618             columns-1 horizontally and from 0 to rows-1 vertically.
5619 
5620             Note that the direction of the vertical axis and thus the default
5621             values for top and bottom depend on *origin*:
5622 
5623             - For ``origin == 'upper'`` the default is
5624               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5625             - For ``origin == 'lower'`` the default is
5626               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5627 
5628             See the :ref:`imshow_extent` tutorial for
5629             examples and a more detailed description.
5630 
5631         filternorm : bool, default: True
5632             A parameter for the antigrain image resize filter (see the
5633             antigrain documentation).  If *filternorm* is set, the filter
5634             normalizes integer values and corrects the rounding errors. It
5635             doesn't do anything with the source floating point values, it
5636             corrects only integers according to the rule of 1.0 which means
5637             that any sum of pixel weights must be equal to 1.0.  So, the
5638             filter function must produce a graph of the proper shape.
5639 
5640         filterrad : float > 0, default: 4.0
5641             The filter radius for filters that have a radius parameter, i.e.
5642             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5643 
5644         resample : bool, default: :rc:`image.resample`
5645             When *True*, use a full resampling method.  When *False*, only
5646             resample when the output image is larger than the input image.
5647 
5648         url : str, optional
5649             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5650 
5651         Returns
5652         -------
5653         `~matplotlib.image.AxesImage`
5654 
5655         Other Parameters
5656         ----------------
5657         data : indexable object, optional
5658             DATA_PARAMETER_PLACEHOLDER
5659 
5660         **kwargs : `~matplotlib.artist.Artist` properties
5661             These parameters are passed on to the constructor of the
5662             `.AxesImage` artist.
5663 
5664         See Also
5665         --------
5666         matshow : Plot a matrix or an array as an image.
5667 
5668         Notes
5669         -----
5670         Unless *extent* is used, pixel centers will be located at integer
5671         coordinates. In other words: the origin will coincide with the center
5672         of pixel (0, 0).
5673 
5674         There are two common representations for RGB images with an alpha
5675         channel:
5676 
5677         -   Straight (unassociated) alpha: R, G, and B channels represent the
5678             color of the pixel, disregarding its opacity.
5679         -   Premultiplied (associated) alpha: R, G, and B channels represent
5680             the color of the pixel, adjusted for its opacity by multiplication.
5681 
5682         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5683         (unassociated) alpha representation.
5684         """
5685         if aspect is None:
5686             aspect = mpl.rcParams['image.aspect']
5687         self.set_aspect(aspect)
5688         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5689                               interpolation=interpolation, origin=origin,
5690                               extent=extent, filternorm=filternorm,
5691                               filterrad=filterrad, resample=resample,
5692                               interpolation_stage=interpolation_stage,
5693                               **kwargs)
5694 
5695         im.set_data(X)
5696         im.set_alpha(alpha)
5697         if im.get_clip_path() is None:
5698             # image does not already have clipping set, clip to axes patch
5699             im.set_clip_path(self.patch)
5700         im._scale_norm(norm, vmin, vmax)
5701         im.set_url(url)
5702 
5703         # update ax.dataLim, and, if autoscaling, set viewLim
5704         # to tightly fit the image, regardless of dataLim.
5705         im.set_extent(im.get_extent())
5706 
5707         self.add_image(im)
5708         return im
5709 
5710     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5711         # - create X and Y if not present;
5712         # - reshape X and Y as needed if they are 1-D;
5713         # - check for proper sizes based on `shading` kwarg;
5714         # - reset shading if shading='auto' to flat or nearest
5715         #   depending on size;
5716 
5717         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5718         try:
5719             _api.check_in_list(_valid_shading, shading=shading)
5720         except ValueError:
5721             _api.warn_external(f"shading value '{shading}' not in list of "
5722                                f"valid values {_valid_shading}. Setting "
5723                                "shading='auto'.")
5724             shading = 'auto'
5725 
5726         if len(args) == 1:
5727             C = np.asanyarray(args[0])
5728             nrows, ncols = C.shape[:2]
5729             if shading in ['gouraud', 'nearest']:
5730                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5731             else:
5732                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5733                 shading = 'flat'
5734             C = cbook.safe_masked_invalid(C)
5735             return X, Y, C, shading
5736 
5737         if len(args) == 3:
5738             # Check x and y for bad data...
5739             C = np.asanyarray(args[2])
5740             # unit conversion allows e.g. datetime objects as axis values
5741             X, Y = args[:2]
5742             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5743             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5744 
5745             if funcname == 'pcolormesh':
5746                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5747                     raise ValueError(
5748                         'x and y arguments to pcolormesh cannot have '
5749                         'non-finite values or be of type '
5750                         'numpy.ma.core.MaskedArray with masked values')
5751                 # safe_masked_invalid() returns an ndarray for dtypes other
5752                 # than floating point.
5753                 if isinstance(X, np.ma.core.MaskedArray):
5754                     X = X.data  # strip mask as downstream doesn't like it...
5755                 if isinstance(Y, np.ma.core.MaskedArray):
5756                     Y = Y.data
5757             nrows, ncols = C.shape[:2]
5758         else:
5759             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5760 
5761         Nx = X.shape[-1]
5762         Ny = Y.shape[0]
5763         if X.ndim != 2 or X.shape[0] == 1:
5764             x = X.reshape(1, Nx)
5765             X = x.repeat(Ny, axis=0)
5766         if Y.ndim != 2 or Y.shape[1] == 1:
5767             y = Y.reshape(Ny, 1)
5768             Y = y.repeat(Nx, axis=1)
5769         if X.shape != Y.shape:
5770             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5771                             f'see help({funcname})')
5772 
5773         if shading == 'auto':
5774             if ncols == Nx and nrows == Ny:
5775                 shading = 'nearest'
5776             else:
5777                 shading = 'flat'
5778 
5779         if shading == 'flat':
5780             if (Nx, Ny) != (ncols + 1, nrows + 1):
5781                 raise TypeError(f"Dimensions of C {C.shape} should"
5782                                 f" be one smaller than X({Nx}) and Y({Ny})"
5783                                 f" while using shading='flat'"
5784                                 f" see help({funcname})")
5785         else:    # ['nearest', 'gouraud']:
5786             if (Nx, Ny) != (ncols, nrows):
5787                 raise TypeError('Dimensions of C %s are incompatible with'
5788                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5789                                     C.shape, Nx, Ny, funcname))
5790             if shading == 'nearest':
5791                 # grid is specified at the center, so define corners
5792                 # at the midpoints between the grid centers and then use the
5793                 # flat algorithm.
5794                 def _interp_grid(X):
5795                     # helper for below
5796                     if np.shape(X)[1] > 1:
5797                         dX = np.diff(X, axis=1)/2.
5798                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5799                             _api.warn_external(
5800                                 f"The input coordinates to {funcname} are "
5801                                 "interpreted as cell centers, but are not "
5802                                 "monotonically increasing or decreasing. "
5803                                 "This may lead to incorrectly calculated cell "
5804                                 "edges, in which case, please supply "
5805                                 f"explicit cell edges to {funcname}.")
5806                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5807                                        X[:, :-1] + dX,
5808                                        X[:, [-1]] + dX[:, [-1]]))
5809                     else:
5810                         # This is just degenerate, but we can't reliably guess
5811                         # a dX if there is just one value.
5812                         X = np.hstack((X, X))
5813                     return X
5814 
5815                 if ncols == Nx:
5816                     X = _interp_grid(X)
5817                     Y = _interp_grid(Y)
5818                 if nrows == Ny:
5819                     X = _interp_grid(X.T).T
5820                     Y = _interp_grid(Y.T).T
5821                 shading = 'flat'
5822 
5823         C = cbook.safe_masked_invalid(C)
5824         return X, Y, C, shading
5825 
5826     @_preprocess_data()
5827     @_docstring.dedent_interpd
5828     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5829                vmin=None, vmax=None, **kwargs):
5830         r"""
5831         Create a pseudocolor plot with a non-regular rectangular grid.
5832 
5833         Call signature::
5834 
5835             pcolor([X, Y,] C, **kwargs)
5836 
5837         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5838 
5839         .. hint::
5840 
5841             ``pcolor()`` can be very slow for large arrays. In most
5842             cases you should use the similar but much faster
5843             `~.Axes.pcolormesh` instead. See
5844             :ref:`Differences between pcolor() and pcolormesh()
5845             <differences-pcolor-pcolormesh>` for a discussion of the
5846             differences.
5847 
5848         Parameters
5849         ----------
5850         C : 2D array-like
5851             The color-mapped values.  Color-mapping is controlled by *cmap*,
5852             *norm*, *vmin*, and *vmax*.
5853 
5854         X, Y : array-like, optional
5855             The coordinates of the corners of quadrilaterals of a pcolormesh::
5856 
5857                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5858                                       ●╶───╴●
5859                                       │     │
5860                                       ●╶───╴●
5861                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5862 
5863             Note that the column index corresponds to the x-coordinate, and
5864             the row index corresponds to y. For details, see the
5865             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5866 
5867             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5868             greater than those of *C*, and the quadrilateral is colored due
5869             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5870             dimensions, a warning will be raised and the last row and column
5871             of *C* will be ignored.
5872 
5873             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5874             the same as those of *C* (if not, a ValueError will be raised). The
5875             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5876 
5877             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5878             expanded as needed into the appropriate 2D arrays, making a
5879             rectangular grid.
5880 
5881         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5882             The fill style for the quadrilateral. Possible values:
5883 
5884             - 'flat': A solid color is used for each quad. The color of the
5885               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5886               ``C[i, j]``. The dimensions of *X* and *Y* should be
5887               one greater than those of *C*; if they are the same as *C*,
5888               then a deprecation warning is raised, and the last row
5889               and column of *C* are dropped.
5890             - 'nearest': Each grid point will have a color centered on it,
5891               extending halfway between the adjacent grid centers.  The
5892               dimensions of *X* and *Y* must be the same as *C*.
5893             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5894               larger than *C*.  Choose 'nearest' if dimensions are the same.
5895 
5896             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5897             for more description.
5898 
5899         %(cmap_doc)s
5900 
5901         %(norm_doc)s
5902 
5903         %(vmin_vmax_doc)s
5904 
5905         edgecolors : {'none', None, 'face', color, color sequence}, optional
5906             The color of the edges. Defaults to 'none'. Possible values:
5907 
5908             - 'none' or '': No edge.
5909             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5910               :rc:`patch.force_edgecolor` has to be True for this to work.
5911             - 'face': Use the adjacent face color.
5912             - A color or sequence of colors will set the edge color.
5913 
5914             The singular form *edgecolor* works as an alias.
5915 
5916         alpha : float, default: None
5917             The alpha blending value of the face color, between 0 (transparent)
5918             and 1 (opaque). Note: The edgecolor is currently not affected by
5919             this.
5920 
5921         snap : bool, default: False
5922             Whether to snap the mesh to pixel boundaries.
5923 
5924         Returns
5925         -------
5926         `matplotlib.collections.Collection`
5927 
5928         Other Parameters
5929         ----------------
5930         antialiaseds : bool, default: False
5931             The default *antialiaseds* is False if the default
5932             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5933             at patch boundaries, and works regardless of the value of alpha.
5934             If *edgecolors* is not "none", then the default *antialiaseds*
5935             is taken from :rc:`patch.antialiased`.
5936             Stroking the edges may be preferred if *alpha* is 1, but will
5937             cause artifacts otherwise.
5938 
5939         data : indexable object, optional
5940             DATA_PARAMETER_PLACEHOLDER
5941 
5942         **kwargs
5943             Additionally, the following arguments are allowed. They are passed
5944             along to the `~matplotlib.collections.PolyCollection` constructor:
5945 
5946         %(PolyCollection:kwdoc)s
5947 
5948         See Also
5949         --------
5950         pcolormesh : for an explanation of the differences between
5951             pcolor and pcolormesh.
5952         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5953             faster alternative.
5954 
5955         Notes
5956         -----
5957         **Masked arrays**
5958 
5959         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5960         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5961         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5962         plotted.
5963 
5964         .. _axes-pcolor-grid-orientation:
5965 
5966         **Grid orientation**
5967 
5968         The grid orientation follows the standard matrix convention: An array
5969         *C* with shape (nrows, ncolumns) is plotted with the column number as
5970         *X* and the row number as *Y*.
5971         """
5972 
5973         if shading is None:
5974             shading = mpl.rcParams['pcolor.shading']
5975         shading = shading.lower()
5976         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5977                                             kwargs=kwargs)
5978         Ny, Nx = X.shape
5979 
5980         # convert to MA, if necessary.
5981         C = ma.asarray(C)
5982         X = ma.asarray(X)
5983         Y = ma.asarray(Y)
5984 
5985         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5986         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5987                   mask[0:-1, 1:] + mask[1:, 0:-1])
5988         # don't plot if C or any of the surrounding vertices are masked.
5989         mask = ma.getmaskarray(C) + xymask
5990 
5991         unmask = ~mask
5992         X1 = ma.filled(X[:-1, :-1])[unmask]
5993         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5994         X2 = ma.filled(X[1:, :-1])[unmask]
5995         Y2 = ma.filled(Y[1:, :-1])[unmask]
5996         X3 = ma.filled(X[1:, 1:])[unmask]
5997         Y3 = ma.filled(Y[1:, 1:])[unmask]
5998         X4 = ma.filled(X[:-1, 1:])[unmask]
5999         Y4 = ma.filled(Y[:-1, 1:])[unmask]
6000         npoly = len(X1)
6001 
6002         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
6003         verts = xy.reshape((npoly, 5, 2))
6004 
6005         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
6006 
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiased' in kwargs:
6021             kwargs['antialiaseds'] = kwargs.pop('antialiased')
6022         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiaseds'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         collection = mcoll.PolyCollection(
6028             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6029         collection._scale_norm(norm, vmin, vmax)
6030 
6031         x = X.compressed()
6032         y = Y.compressed()
6033 
6034         # Transform from native to data coordinates?
6035         t = collection._transform
6036         if (not isinstance(t, mtransforms.Transform) and
6037                 hasattr(t, '_as_mpl_transform')):
6038             t = t._as_mpl_transform(self.axes)
6039 
6040         if t and any(t.contains_branch_seperately(self.transData)):
6041             trans_to_data = t - self.transData
6042             pts = np.vstack([x, y]).T.astype(float)
6043             transformed_pts = trans_to_data.transform(pts)
6044             x = transformed_pts[..., 0]
6045             y = transformed_pts[..., 1]
6046 
6047         self.add_collection(collection, autolim=False)
6048 
6049         minx = np.min(x)
6050         maxx = np.max(x)
6051         miny = np.min(y)
6052         maxy = np.max(y)
6053         collection.sticky_edges.x[:] = [minx, maxx]
6054         collection.sticky_edges.y[:] = [miny, maxy]
6055         corners = (minx, miny), (maxx, maxy)
6056         self.update_datalim(corners)
6057         self._request_autoscale_view()
6058         return collection
6059 
6060     @_preprocess_data()
6061     @_docstring.dedent_interpd
6062     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6063                    vmax=None, shading=None, antialiased=False, **kwargs):
6064         """
6065         Create a pseudocolor plot with a non-regular rectangular grid.
6066 
6067         Call signature::
6068 
6069             pcolormesh([X, Y,] C, **kwargs)
6070 
6071         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6072 
6073         .. hint::
6074 
6075            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6076            and preferred in most cases. For a detailed discussion on the
6077            differences see :ref:`Differences between pcolor() and pcolormesh()
6078            <differences-pcolor-pcolormesh>`.
6079 
6080         Parameters
6081         ----------
6082         C : array-like
6083             The mesh data. Supported array shapes are:
6084 
6085             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6086               colors using normalization and a colormap. See parameters *norm*,
6087               *cmap*, *vmin*, *vmax*.
6088             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6089             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6090               i.e. including transparency.
6091 
6092             The first two dimensions (M, N) define the rows and columns of
6093             the mesh data.
6094 
6095         X, Y : array-like, optional
6096             The coordinates of the corners of quadrilaterals of a pcolormesh::
6097 
6098                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6099                                       ●╶───╴●
6100                                       │     │
6101                                       ●╶───╴●
6102                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6103 
6104             Note that the column index corresponds to the x-coordinate, and
6105             the row index corresponds to y. For details, see the
6106             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6107 
6108             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6109             greater than those of *C*, and the quadrilateral is colored due
6110             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6111             dimensions, a warning will be raised and the last row and column
6112             of *C* will be ignored.
6113 
6114             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6115             and *Y* should be the same as those of *C* (if not, a ValueError
6116             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6117             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6118             interpolation is caried out between the quadrilateral corners.
6119 
6120             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6121             expanded as needed into the appropriate 2D arrays, making a
6122             rectangular grid.
6123 
6124         %(cmap_doc)s
6125 
6126         %(norm_doc)s
6127 
6128         %(vmin_vmax_doc)s
6129 
6130         edgecolors : {'none', None, 'face', color, color sequence}, optional
6131             The color of the edges. Defaults to 'none'. Possible values:
6132 
6133             - 'none' or '': No edge.
6134             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6135               :rc:`patch.force_edgecolor` has to be True for this to work.
6136             - 'face': Use the adjacent face color.
6137             - A color or sequence of colors will set the edge color.
6138 
6139             The singular form *edgecolor* works as an alias.
6140 
6141         alpha : float, default: None
6142             The alpha blending value, between 0 (transparent) and 1 (opaque).
6143 
6144         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6145             The fill style for the quadrilateral; defaults to
6146             :rc:`pcolor.shading`. Possible values:
6147 
6148             - 'flat': A solid color is used for each quad. The color of the
6149               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6150               ``C[i, j]``. The dimensions of *X* and *Y* should be
6151               one greater than those of *C*; if they are the same as *C*,
6152               then a deprecation warning is raised, and the last row
6153               and column of *C* are dropped.
6154             - 'nearest': Each grid point will have a color centered on it,
6155               extending halfway between the adjacent grid centers.  The
6156               dimensions of *X* and *Y* must be the same as *C*.
6157             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6158               corners (i', j') are given by ``C[i', j']``. The color values of
6159               the area in between is interpolated from the corner values.
6160               The dimensions of *X* and *Y* must be the same as *C*. When
6161               Gouraud shading is used, *edgecolors* is ignored.
6162             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6163               larger than *C*.  Choose 'nearest' if dimensions are the same.
6164 
6165             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6166             for more description.
6167 
6168         snap : bool, default: False
6169             Whether to snap the mesh to pixel boundaries.
6170 
6171         rasterized : bool, optional
6172             Rasterize the pcolormesh when drawing vector graphics.  This can
6173             speed up rendering and produce smaller files for large data sets.
6174             See also :doc:`/gallery/misc/rasterization_demo`.
6175 
6176         Returns
6177         -------
6178         `matplotlib.collections.QuadMesh`
6179 
6180         Other Parameters
6181         ----------------
6182         data : indexable object, optional
6183             DATA_PARAMETER_PLACEHOLDER
6184 
6185         **kwargs
6186             Additionally, the following arguments are allowed. They are passed
6187             along to the `~matplotlib.collections.QuadMesh` constructor:
6188 
6189         %(QuadMesh:kwdoc)s
6190 
6191         See Also
6192         --------
6193         pcolor : An alternative implementation with slightly different
6194             features. For a detailed discussion on the differences see
6195             :ref:`Differences between pcolor() and pcolormesh()
6196             <differences-pcolor-pcolormesh>`.
6197         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6198             faster alternative.
6199 
6200         Notes
6201         -----
6202         **Masked arrays**
6203 
6204         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6205         quadrilateral will be transparent. Masking of *X* and *Y* is not
6206         supported. Use `~.Axes.pcolor` if you need this functionality.
6207 
6208         .. _axes-pcolormesh-grid-orientation:
6209 
6210         **Grid orientation**
6211 
6212         The grid orientation follows the standard matrix convention: An array
6213         *C* with shape (nrows, ncolumns) is plotted with the column number as
6214         *X* and the row number as *Y*.
6215 
6216         .. _differences-pcolor-pcolormesh:
6217 
6218         **Differences between pcolor() and pcolormesh()**
6219 
6220         Both methods are used to create a pseudocolor plot of a 2D array
6221         using quadrilaterals.
6222 
6223         The main difference lies in the created object and internal data
6224         handling:
6225         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6226         returns a `.QuadMesh`. The latter is more specialized for the given
6227         purpose and thus is faster. It should almost always be preferred.
6228 
6229         There is also a slight difference in the handling of masked arrays.
6230         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6231         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6232         and *Y*. The reason lies in the internal handling of the masked values.
6233         `~.Axes.pcolor` leaves out the respective polygons from the
6234         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6235         elements to transparent. You can see the difference when using
6236         edgecolors. While all edges are drawn irrespective of masking in a
6237         QuadMesh, the edge between two adjacent masked quadrilaterals in
6238         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6239         exist in the PolyCollection.
6240 
6241         Another difference is the support of Gouraud shading in
6242         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6243 
6244         """
6245         if shading is None:
6246             shading = mpl.rcParams['pcolor.shading']
6247         shading = shading.lower()
6248         kwargs.setdefault('edgecolors', 'none')
6249 
6250         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6251                                             shading=shading, kwargs=kwargs)
6252         coords = np.stack([X, Y], axis=-1)
6253 
6254         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6255 
6256         collection = mcoll.QuadMesh(
6257             coords, antialiased=antialiased, shading=shading,
6258             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6259         collection._scale_norm(norm, vmin, vmax)
6260 
6261         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6262 
6263         # Transform from native to data coordinates?
6264         t = collection._transform
6265         if (not isinstance(t, mtransforms.Transform) and
6266                 hasattr(t, '_as_mpl_transform')):
6267             t = t._as_mpl_transform(self.axes)
6268 
6269         if t and any(t.contains_branch_seperately(self.transData)):
6270             trans_to_data = t - self.transData
6271             coords = trans_to_data.transform(coords)
6272 
6273         self.add_collection(collection, autolim=False)
6274 
6275         minx, miny = np.min(coords, axis=0)
6276         maxx, maxy = np.max(coords, axis=0)
6277         collection.sticky_edges.x[:] = [minx, maxx]
6278         collection.sticky_edges.y[:] = [miny, maxy]
6279         corners = (minx, miny), (maxx, maxy)
6280         self.update_datalim(corners)
6281         self._request_autoscale_view()
6282         return collection
6283 
6284     @_preprocess_data()
6285     @_docstring.dedent_interpd
6286     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6287                    vmax=None, **kwargs):
6288         """
6289         Create a pseudocolor plot with a non-regular rectangular grid.
6290 
6291         Call signature::
6292 
6293           ax.pcolorfast([X, Y], C, /, **kwargs)
6294 
6295         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6296         It's designed to provide the fastest pcolor-type plotting with the
6297         Agg backend. To achieve this, it uses different algorithms internally
6298         depending on the complexity of the input grid (regular rectangular,
6299         non-regular rectangular or arbitrary quadrilateral).
6300 
6301         .. warning::
6302 
6303            This method is experimental. Compared to `~.Axes.pcolor` or
6304            `~.Axes.pcolormesh` it has some limitations:
6305 
6306            - It supports only flat shading (no outlines)
6307            - It lacks support for log scaling of the axes.
6308            - It does not have a pyplot wrapper.
6309 
6310         Parameters
6311         ----------
6312         C : array-like
6313             The image data. Supported array shapes are:
6314 
6315             - (M, N): an image with scalar data.  Color-mapping is controlled
6316               by *cmap*, *norm*, *vmin*, and *vmax*.
6317             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6318             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6319               i.e. including transparency.
6320 
6321             The first two dimensions (M, N) define the rows and columns of
6322             the image.
6323 
6324             This parameter can only be passed positionally.
6325 
6326         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6327             *X* and *Y* are used to specify the coordinates of the
6328             quadrilaterals. There are different ways to do this:
6329 
6330             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6331               a *uniform rectangular grid*.
6332 
6333               The tuples define the outer edges of the grid. All individual
6334               quadrilaterals will be of the same size. This is the fastest
6335               version.
6336 
6337             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6338               grid*.
6339 
6340               In this case *X* and *Y* have to be monotonic 1D arrays of length
6341               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6342 
6343               The speed is intermediate. Note: The grid is checked, and if
6344               found to be uniform the fast version is used.
6345 
6346             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6347               grid* (i.e. if the quadrilaterals are not rectangular).
6348 
6349               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6350               specifying the x and y coordinates of the corners of the colored
6351               quadrilaterals.
6352 
6353               This is the most general, but the slowest to render.  It may
6354               produce faster and more compact output using ps, pdf, and
6355               svg backends, however.
6356 
6357             These arguments can only be passed positionally.
6358 
6359         %(cmap_doc)s
6360 
6361             This parameter is ignored if *C* is RGB(A).
6362 
6363         %(norm_doc)s
6364 
6365             This parameter is ignored if *C* is RGB(A).
6366 
6367         %(vmin_vmax_doc)s
6368 
6369             This parameter is ignored if *C* is RGB(A).
6370 
6371         alpha : float, default: None
6372             The alpha blending value, between 0 (transparent) and 1 (opaque).
6373 
6374         snap : bool, default: False
6375             Whether to snap the mesh to pixel boundaries.
6376 
6377         Returns
6378         -------
6379         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6380             The return type depends on the type of grid:
6381 
6382             - `.AxesImage` for a regular rectangular grid.
6383             - `.PcolorImage` for a non-regular rectangular grid.
6384             - `.QuadMesh` for a non-rectangular grid.
6385 
6386         Other Parameters
6387         ----------------
6388         data : indexable object, optional
6389             DATA_PARAMETER_PLACEHOLDER
6390 
6391         **kwargs
6392             Supported additional parameters depend on the type of grid.
6393             See return types of *image* for further description.
6394         """
6395 
6396         C = args[-1]
6397         nr, nc = np.shape(C)[:2]
6398         if len(args) == 1:
6399             style = "image"
6400             x = [0, nc]
6401             y = [0, nr]
6402         elif len(args) == 3:
6403             x, y = args[:2]
6404             x = np.asarray(x)
6405             y = np.asarray(y)
6406             if x.ndim == 1 and y.ndim == 1:
6407                 if x.size == 2 and y.size == 2:
6408                     style = "image"
6409                 else:
6410                     dx = np.diff(x)
6411                     dy = np.diff(y)
6412                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6413                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6414                         style = "image"
6415                     else:
6416                         style = "pcolorimage"
6417             elif x.ndim == 2 and y.ndim == 2:
6418                 style = "quadmesh"
6419             else:
6420                 raise TypeError("arguments do not match valid signatures")
6421         else:
6422             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6423 
6424         if style == "quadmesh":
6425             # data point in each cell is value at lower left corner
6426             coords = np.stack([x, y], axis=-1)
6427             if np.ndim(C) not in {2, 3}:
6428                 raise ValueError("C must be 2D or 3D")
6429             collection = mcoll.QuadMesh(
6430                 coords, array=C,
6431                 alpha=alpha, cmap=cmap, norm=norm,
6432                 antialiased=False, edgecolors="none")
6433             self.add_collection(collection, autolim=False)
6434             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6435             ret = collection
6436 
6437         else:  # It's one of the two image styles.
6438             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6439             if style == "image":
6440                 im = mimage.AxesImage(
6441                     self, cmap=cmap, norm=norm,
6442                     data=C, alpha=alpha, extent=extent,
6443                     interpolation='nearest', origin='lower',
6444                     **kwargs)
6445             elif style == "pcolorimage":
6446                 im = mimage.PcolorImage(
6447                     self, x, y, C,
6448                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6449                     **kwargs)
6450             self.add_image(im)
6451             ret = im
6452 
6453         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6454             ret._scale_norm(norm, vmin, vmax)
6455 
6456         if ret.get_clip_path() is None:
6457             # image does not already have clipping set, clip to axes patch
6458             ret.set_clip_path(self.patch)
6459 
6460         ret.sticky_edges.x[:] = [xl, xr]
6461         ret.sticky_edges.y[:] = [yb, yt]
6462         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6463         self._request_autoscale_view(tight=True)
6464         return ret
6465 
6466     @_preprocess_data()
6467     @_docstring.dedent_interpd
6468     def contour(self, *args, **kwargs):
6469         """
6470         Plot contour lines.
6471 
6472         Call signature::
6473 
6474             contour([X, Y,] Z, [levels], **kwargs)
6475         %(contour_doc)s
6476         """
6477         kwargs['filled'] = False
6478         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6479         self._request_autoscale_view()
6480         return contours
6481 
6482     @_preprocess_data()
6483     @_docstring.dedent_interpd
6484     def contourf(self, *args, **kwargs):
6485         """
6486         Plot filled contours.
6487 
6488         Call signature::
6489 
6490             contourf([X, Y,] Z, [levels], **kwargs)
6491         %(contour_doc)s
6492         """
6493         kwargs['filled'] = True
6494         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6495         self._request_autoscale_view()
6496         return contours
6497 
6498     def clabel(self, CS, levels=None, **kwargs):
6499         """
6500         Label a contour plot.
6501 
6502         Adds labels to line contours in given `.ContourSet`.
6503 
6504         Parameters
6505         ----------
6506         CS : `.ContourSet` instance
6507             Line contours to label.
6508 
6509         levels : array-like, optional
6510             A list of level values, that should be labeled. The list must be
6511             a subset of ``CS.levels``. If not given, all levels are labeled.
6512 
6513         **kwargs
6514             All other parameters are documented in `~.ContourLabeler.clabel`.
6515         """
6516         return CS.clabel(levels, **kwargs)
6517 
6518     #### Data analysis
6519 
6520     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6521     def hist(self, x, bins=None, range=None, density=False, weights=None,
6522              cumulative=False, bottom=None, histtype='bar', align='mid',
6523              orientation='vertical', rwidth=None, log=False,
6524              color=None, label=None, stacked=False, **kwargs):
6525         """
6526         Compute and plot a histogram.
6527 
6528         This method uses `numpy.histogram` to bin the data in *x* and count the
6529         number of values in each bin, then draws the distribution either as a
6530         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6531         *weights* parameters are forwarded to `numpy.histogram`.
6532 
6533         If the data has already been binned and counted, use `~.bar` or
6534         `~.stairs` to plot the distribution::
6535 
6536             counts, bins = np.histogram(x)
6537             plt.stairs(counts, bins)
6538 
6539         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6540         treating each bin as a single point with a weight equal to its count::
6541 
6542             plt.hist(bins[:-1], bins, weights=counts)
6543 
6544         The data input *x* can be a singular array, a list of datasets of
6545         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6546         which each column is a dataset. Note that the ndarray form is
6547         transposed relative to the list form. If the input is an array, then
6548         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6549         sequence of arrays, then the return value is a tuple
6550         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6551 
6552         Masked arrays are not supported.
6553 
6554         Parameters
6555         ----------
6556         x : (n,) array or sequence of (n,) arrays
6557             Input values, this takes either a single array or a sequence of
6558             arrays which are not required to be of the same length.
6559 
6560         bins : int or sequence or str, default: :rc:`hist.bins`
6561             If *bins* is an integer, it defines the number of equal-width bins
6562             in the range.
6563 
6564             If *bins* is a sequence, it defines the bin edges, including the
6565             left edge of the first bin and the right edge of the last bin;
6566             in this case, bins may be unequally spaced.  All but the last
6567             (righthand-most) bin is half-open.  In other words, if *bins* is::
6568 
6569                 [1, 2, 3, 4]
6570 
6571             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6572             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6573             *includes* 4.
6574 
6575             If *bins* is a string, it is one of the binning strategies
6576             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6577             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6578 
6579         range : tuple or None, default: None
6580             The lower and upper range of the bins. Lower and upper outliers
6581             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6582             Range has no effect if *bins* is a sequence.
6583 
6584             If *bins* is a sequence or *range* is specified, autoscaling
6585             is based on the specified bin range instead of the
6586             range of x.
6587 
6588         density : bool, default: False
6589             If ``True``, draw and return a probability density: each bin
6590             will display the bin's raw count divided by the total number of
6591             counts *and the bin width*
6592             (``density = counts / (sum(counts) * np.diff(bins))``),
6593             so that the area under the histogram integrates to 1
6594             (``np.sum(density * np.diff(bins)) == 1``).
6595 
6596             If *stacked* is also ``True``, the sum of the histograms is
6597             normalized to 1.
6598 
6599         weights : (n,) array-like or None, default: None
6600             An array of weights, of the same shape as *x*.  Each value in
6601             *x* only contributes its associated weight towards the bin count
6602             (instead of 1).  If *density* is ``True``, the weights are
6603             normalized, so that the integral of the density over the range
6604             remains 1.
6605 
6606         cumulative : bool or -1, default: False
6607             If ``True``, then a histogram is computed where each bin gives the
6608             counts in that bin plus all bins for smaller values. The last bin
6609             gives the total number of datapoints.
6610 
6611             If *density* is also ``True`` then the histogram is normalized such
6612             that the last bin equals 1.
6613 
6614             If *cumulative* is a number less than 0 (e.g., -1), the direction
6615             of accumulation is reversed.  In this case, if *density* is also
6616             ``True``, then the histogram is normalized such that the first bin
6617             equals 1.
6618 
6619         bottom : array-like, scalar, or None, default: None
6620             Location of the bottom of each bin, i.e. bins are drawn from
6621             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6622             of each bin is shifted by the same amount. If an array, each bin
6623             is shifted independently and the length of bottom must match the
6624             number of bins. If None, defaults to 0.
6625 
6626         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6627             The type of histogram to draw.
6628 
6629             - 'bar' is a traditional bar-type histogram.  If multiple data
6630               are given the bars are arranged side by side.
6631             - 'barstacked' is a bar-type histogram where multiple
6632               data are stacked on top of each other.
6633             - 'step' generates a lineplot that is by default unfilled.
6634             - 'stepfilled' generates a lineplot that is by default filled.
6635 
6636         align : {'left', 'mid', 'right'}, default: 'mid'
6637             The horizontal alignment of the histogram bars.
6638 
6639             - 'left': bars are centered on the left bin edges.
6640             - 'mid': bars are centered between the bin edges.
6641             - 'right': bars are centered on the right bin edges.
6642 
6643         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6644             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6645             and the *bottom* kwarg will be the left edges.
6646 
6647         rwidth : float or None, default: None
6648             The relative width of the bars as a fraction of the bin width.  If
6649             ``None``, automatically compute the width.
6650 
6651             Ignored if *histtype* is 'step' or 'stepfilled'.
6652 
6653         log : bool, default: False
6654             If ``True``, the histogram axis will be set to a log scale.
6655 
6656         color : color or array-like of colors or None, default: None
6657             Color or sequence of colors, one per dataset.  Default (``None``)
6658             uses the standard line color sequence.
6659 
6660         label : str or None, default: None
6661             String, or sequence of strings to match multiple datasets.  Bar
6662             charts yield multiple patches per dataset, but only the first gets
6663             the label, so that `~.Axes.legend` will work as expected.
6664 
6665         stacked : bool, default: False
6666             If ``True``, multiple data are stacked on top of each other If
6667             ``False`` multiple data are arranged side by side if histtype is
6668             'bar' or on top of each other if histtype is 'step'
6669 
6670         Returns
6671         -------
6672         n : array or list of arrays
6673             The values of the histogram bins. See *density* and *weights* for a
6674             description of the possible semantics.  If input *x* is an array,
6675             then this is an array of length *nbins*. If input is a sequence of
6676             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6677             the values of the histograms for each of the arrays in the same
6678             order.  The dtype of the array *n* (or of its element arrays) will
6679             always be float even if no weighting or normalization is used.
6680 
6681         bins : array
6682             The edges of the bins. Length nbins + 1 (nbins left edges and right
6683             edge of last bin).  Always a single array even when multiple data
6684             sets are passed in.
6685 
6686         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6687 such objects
6688             Container of individual artists used to create the histogram
6689             or list of such containers if there are multiple input datasets.
6690 
6691         Other Parameters
6692         ----------------
6693         data : indexable object, optional
6694             DATA_PARAMETER_PLACEHOLDER
6695 
6696         **kwargs
6697             `~matplotlib.patches.Patch` properties
6698 
6699         See Also
6700         --------
6701         hist2d : 2D histogram with rectangular bins
6702         hexbin : 2D histogram with hexagonal bins
6703         stairs : Plot a pre-computed histogram
6704         bar : Plot a pre-computed histogram
6705 
6706         Notes
6707         -----
6708         For large numbers of bins (>1000), plotting can be significantly
6709         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6710         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6711         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6712         """
6713         # Avoid shadowing the builtin.
6714         bin_range = range
6715         from builtins import range
6716 
6717         if np.isscalar(x):
6718             x = [x]
6719 
6720         if bins is None:
6721             bins = mpl.rcParams['hist.bins']
6722 
6723         # Validate string inputs here to avoid cluttering subsequent code.
6724         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6725                            histtype=histtype)
6726         _api.check_in_list(['left', 'mid', 'right'], align=align)
6727         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6728 
6729         if histtype == 'barstacked' and not stacked:
6730             stacked = True
6731 
6732         # Massage 'x' for processing.
6733         x = cbook._reshape_2D(x, 'x')
6734         nx = len(x)  # number of datasets
6735 
6736         # Process unit information.  _process_unit_info sets the unit and
6737         # converts the first dataset; then we convert each following dataset
6738         # one at a time.
6739         if orientation == "vertical":
6740             convert_units = self.convert_xunits
6741             x = [*self._process_unit_info([("x", x[0])], kwargs),
6742                  *map(convert_units, x[1:])]
6743         else:  # horizontal
6744             convert_units = self.convert_yunits
6745             x = [*self._process_unit_info([("y", x[0])], kwargs),
6746                  *map(convert_units, x[1:])]
6747 
6748         if bin_range is not None:
6749             bin_range = convert_units(bin_range)
6750 
6751         if not cbook.is_scalar_or_string(bins):
6752             bins = convert_units(bins)
6753 
6754         # We need to do to 'weights' what was done to 'x'
6755         if weights is not None:
6756             w = cbook._reshape_2D(weights, 'weights')
6757         else:
6758             w = [None] * nx
6759 
6760         if len(w) != nx:
6761             raise ValueError('weights should have the same shape as x')
6762 
6763         input_empty = True
6764         for xi, wi in zip(x, w):
6765             len_xi = len(xi)
6766             if wi is not None and len(wi) != len_xi:
6767                 raise ValueError('weights should have the same shape as x')
6768             if len_xi:
6769                 input_empty = False
6770 
6771         if color is None:
6772             colors = [self._get_lines.get_next_color() for i in range(nx)]
6773         else:
6774             colors = mcolors.to_rgba_array(color)
6775             if len(colors) != nx:
6776                 raise ValueError(f"The 'color' keyword argument must have one "
6777                                  f"color per dataset, but {nx} datasets and "
6778                                  f"{len(colors)} colors were provided")
6779 
6780         hist_kwargs = dict()
6781 
6782         # if the bin_range is not given, compute without nan numpy
6783         # does not do this for us when guessing the range (but will
6784         # happily ignore nans when computing the histogram).
6785         if bin_range is None:
6786             xmin = np.inf
6787             xmax = -np.inf
6788             for xi in x:
6789                 if len(xi):
6790                     # python's min/max ignore nan,
6791                     # np.minnan returns nan for all nan input
6792                     xmin = min(xmin, np.nanmin(xi))
6793                     xmax = max(xmax, np.nanmax(xi))
6794             if xmin <= xmax:  # Only happens if we have seen a finite value.
6795                 bin_range = (xmin, xmax)
6796 
6797         # If bins are not specified either explicitly or via range,
6798         # we need to figure out the range required for all datasets,
6799         # and supply that to np.histogram.
6800         if not input_empty and len(x) > 1:
6801             if weights is not None:
6802                 _w = np.concatenate(w)
6803             else:
6804                 _w = None
6805             bins = np.histogram_bin_edges(
6806                 np.concatenate(x), bins, bin_range, _w)
6807         else:
6808             hist_kwargs['range'] = bin_range
6809 
6810         density = bool(density)
6811         if density and not stacked:
6812             hist_kwargs['density'] = density
6813 
6814         # List to store all the top coordinates of the histograms
6815         tops = []  # Will have shape (n_datasets, n_bins).
6816         # Loop through datasets
6817         for i in range(nx):
6818             # this will automatically overwrite bins,
6819             # so that each histogram uses the same bins
6820             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6821             tops.append(m)
6822         tops = np.array(tops, float)  # causes problems later if it's an int
6823         bins = np.array(bins, float)  # causes problems if float16
6824         if stacked:
6825             tops = tops.cumsum(axis=0)
6826             # If a stacked density plot, normalize so the area of all the
6827             # stacked histograms together is 1
6828             if density:
6829                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6830         if cumulative:
6831             slc = slice(None)
6832             if isinstance(cumulative, Number) and cumulative < 0:
6833                 slc = slice(None, None, -1)
6834             if density:
6835                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6836             else:
6837                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6838 
6839         patches = []
6840 
6841         if histtype.startswith('bar'):
6842 
6843             totwidth = np.diff(bins)
6844 
6845             if rwidth is not None:
6846                 dr = np.clip(rwidth, 0, 1)
6847             elif (len(tops) > 1 and
6848                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6849                 dr = 0.8
6850             else:
6851                 dr = 1.0
6852 
6853             if histtype == 'bar' and not stacked:
6854                 width = dr * totwidth / nx
6855                 dw = width
6856                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6857             elif histtype == 'barstacked' or stacked:
6858                 width = dr * totwidth
6859                 boffset, dw = 0.0, 0.0
6860 
6861             if align == 'mid':
6862                 boffset += 0.5 * totwidth
6863             elif align == 'right':
6864                 boffset += totwidth
6865 
6866             if orientation == 'horizontal':
6867                 _barfunc = self.barh
6868                 bottom_kwarg = 'left'
6869             else:  # orientation == 'vertical'
6870                 _barfunc = self.bar
6871                 bottom_kwarg = 'bottom'
6872 
6873             for top, color in zip(tops, colors):
6874                 if bottom is None:
6875                     bottom = np.zeros(len(top))
6876                 if stacked:
6877                     height = top - bottom
6878                 else:
6879                     height = top
6880                 bars = _barfunc(bins[:-1]+boffset, height, width,
6881                                 align='center', log=log,
6882                                 color=color, **{bottom_kwarg: bottom})
6883                 patches.append(bars)
6884                 if stacked:
6885                     bottom = top
6886                 boffset += dw
6887             # Remove stickies from all bars but the lowest ones, as otherwise
6888             # margin expansion would be unable to cross the stickies in the
6889             # middle of the bars.
6890             for bars in patches[1:]:
6891                 for patch in bars:
6892                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6893 
6894         elif histtype.startswith('step'):
6895             # these define the perimeter of the polygon
6896             x = np.zeros(4 * len(bins) - 3)
6897             y = np.zeros(4 * len(bins) - 3)
6898 
6899             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6900             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6901 
6902             if bottom is None:
6903                 bottom = 0
6904 
6905             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6906             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6907 
6908             if log:
6909                 if orientation == 'horizontal':
6910                     self.set_xscale('log', nonpositive='clip')
6911                 else:  # orientation == 'vertical'
6912                     self.set_yscale('log', nonpositive='clip')
6913 
6914             if align == 'left':
6915                 x -= 0.5*(bins[1]-bins[0])
6916             elif align == 'right':
6917                 x += 0.5*(bins[1]-bins[0])
6918 
6919             # If fill kwarg is set, it will be passed to the patch collection,
6920             # overriding this
6921             fill = (histtype == 'stepfilled')
6922 
6923             xvals, yvals = [], []
6924             for top in tops:
6925                 if stacked:
6926                     # top of the previous polygon becomes the bottom
6927                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6928                 # set the top of this polygon
6929                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6930 
6931                 # The starting point of the polygon has not yet been
6932                 # updated. So far only the endpoint was adjusted. This
6933                 # assignment closes the polygon. The redundant endpoint is
6934                 # later discarded (for step and stepfilled).
6935                 y[0] = y[-1]
6936 
6937                 if orientation == 'horizontal':
6938                     xvals.append(y.copy())
6939                     yvals.append(x.copy())
6940                 else:
6941                     xvals.append(x.copy())
6942                     yvals.append(y.copy())
6943 
6944             # stepfill is closed, step is not
6945             split = -1 if fill else 2 * len(bins)
6946             # add patches in reverse order so that when stacking,
6947             # items lower in the stack are plotted on top of
6948             # items higher in the stack
6949             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6950                 patches.append(self.fill(
6951                     x[:split], y[:split],
6952                     closed=True if fill else None,
6953                     facecolor=color,
6954                     edgecolor=None if fill else color,
6955                     fill=fill if fill else None,
6956                     zorder=None if fill else mlines.Line2D.zorder))
6957             for patch_list in patches:
6958                 for patch in patch_list:
6959                     if orientation == 'vertical':
6960                         patch.sticky_edges.y.append(0)
6961                     elif orientation == 'horizontal':
6962                         patch.sticky_edges.x.append(0)
6963 
6964             # we return patches, so put it back in the expected order
6965             patches.reverse()
6966 
6967         # If None, make all labels None (via zip_longest below); otherwise,
6968         # cast each element to str, but keep a single str as it.
6969         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6970         for patch, lbl in itertools.zip_longest(patches, labels):
6971             if patch:
6972                 p = patch[0]
6973                 p._internal_update(kwargs)
6974                 if lbl is not None:
6975                     p.set_label(lbl)
6976                 for p in patch[1:]:
6977                     p._internal_update(kwargs)
6978                     p.set_label('_nolegend_')
6979 
6980         if nx == 1:
6981             return tops[0], bins, patches[0]
6982         else:
6983             patch_type = ("BarContainer" if histtype.startswith("bar")
6984                           else "list[Polygon]")
6985             return tops, bins, cbook.silent_list(patch_type, patches)
6986 
6987     @_preprocess_data()
6988     def stairs(self, values, edges=None, *,
6989                orientation='vertical', baseline=0, fill=False, **kwargs):
6990         """
6991         A stepwise constant function as a line with bounding edges
6992         or a filled plot.
6993 
6994         Parameters
6995         ----------
6996         values : array-like
6997             The step heights.
6998 
6999         edges : array-like
7000             The edge positions, with ``len(edges) == len(vals) + 1``,
7001             between which the curve takes on vals values.
7002 
7003         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7004             The direction of the steps. Vertical means that *values* are along
7005             the y-axis, and edges are along the x-axis.
7006 
7007         baseline : float, array-like or None, default: 0
7008             The bottom value of the bounding edges or when
7009             ``fill=True``, position of lower edge. If *fill* is
7010             True or an array is passed to *baseline*, a closed
7011             path is drawn.
7012 
7013         fill : bool, default: False
7014             Whether the area under the step curve should be filled.
7015 
7016         Returns
7017         -------
7018         StepPatch : `matplotlib.patches.StepPatch`
7019 
7020         Other Parameters
7021         ----------------
7022         data : indexable object, optional
7023             DATA_PARAMETER_PLACEHOLDER
7024 
7025         **kwargs
7026             `~matplotlib.patches.StepPatch` properties
7027 
7028         """
7029 
7030         if 'color' in kwargs:
7031             _color = kwargs.pop('color')
7032         else:
7033             _color = self._get_lines.get_next_color()
7034         if fill:
7035             kwargs.setdefault('linewidth', 0)
7036             kwargs.setdefault('facecolor', _color)
7037         else:
7038             kwargs.setdefault('edgecolor', _color)
7039 
7040         if edges is None:
7041             edges = np.arange(len(values) + 1)
7042 
7043         edges, values, baseline = self._process_unit_info(
7044             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7045 
7046         patch = mpatches.StepPatch(values,
7047                                    edges,
7048                                    baseline=baseline,
7049                                    orientation=orientation,
7050                                    fill=fill,
7051                                    **kwargs)
7052         self.add_patch(patch)
7053         if baseline is None:
7054             baseline = 0
7055         if orientation == 'vertical':
7056             patch.sticky_edges.y.append(np.min(baseline))
7057             self.update_datalim([(edges[0], np.min(baseline))])
7058         else:
7059             patch.sticky_edges.x.append(np.min(baseline))
7060             self.update_datalim([(np.min(baseline), edges[0])])
7061         self._request_autoscale_view()
7062         return patch
7063 
7064     @_preprocess_data(replace_names=["x", "y", "weights"])
7065     @_docstring.dedent_interpd
7066     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7067                cmin=None, cmax=None, **kwargs):
7068         """
7069         Make a 2D histogram plot.
7070 
7071         Parameters
7072         ----------
7073         x, y : array-like, shape (n, )
7074             Input values
7075 
7076         bins : None or int or [int, int] or array-like or [array, array]
7077 
7078             The bin specification:
7079 
7080             - If int, the number of bins for the two dimensions
7081               (nx=ny=bins).
7082             - If ``[int, int]``, the number of bins in each dimension
7083               (nx, ny = bins).
7084             - If array-like, the bin edges for the two dimensions
7085               (x_edges=y_edges=bins).
7086             - If ``[array, array]``, the bin edges in each dimension
7087               (x_edges, y_edges = bins).
7088 
7089             The default value is 10.
7090 
7091         range : array-like shape(2, 2), optional
7092             The leftmost and rightmost edges of the bins along each dimension
7093             (if not specified explicitly in the bins parameters): ``[[xmin,
7094             xmax], [ymin, ymax]]``. All values outside of this range will be
7095             considered outliers and not tallied in the histogram.
7096 
7097         density : bool, default: False
7098             Normalize histogram.  See the documentation for the *density*
7099             parameter of `~.Axes.hist` for more details.
7100 
7101         weights : array-like, shape (n, ), optional
7102             An array of values w_i weighing each sample (x_i, y_i).
7103 
7104         cmin, cmax : float, default: None
7105             All bins that has count less than *cmin* or more than *cmax* will
7106             not be displayed (set to NaN before passing to imshow) and these
7107             count values in the return value count histogram will also be set
7108             to nan upon return.
7109 
7110         Returns
7111         -------
7112         h : 2D array
7113             The bi-dimensional histogram of samples x and y. Values in x are
7114             histogrammed along the first dimension and values in y are
7115             histogrammed along the second dimension.
7116         xedges : 1D array
7117             The bin edges along the x-axis.
7118         yedges : 1D array
7119             The bin edges along the y-axis.
7120         image : `~.matplotlib.collections.QuadMesh`
7121 
7122         Other Parameters
7123         ----------------
7124         %(cmap_doc)s
7125 
7126         %(norm_doc)s
7127 
7128         %(vmin_vmax_doc)s
7129 
7130         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7131             The alpha blending value.
7132 
7133         data : indexable object, optional
7134             DATA_PARAMETER_PLACEHOLDER
7135 
7136         **kwargs
7137             Additional parameters are passed along to the
7138             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7139             constructor.
7140 
7141         See Also
7142         --------
7143         hist : 1D histogram plotting
7144         hexbin : 2D histogram with hexagonal bins
7145 
7146         Notes
7147         -----
7148         - Currently ``hist2d`` calculates its own axis limits, and any limits
7149           previously set are ignored.
7150         - Rendering the histogram with a logarithmic color scale is
7151           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7152           keyword argument. Likewise, power-law normalization (similar
7153           in effect to gamma correction) can be accomplished with
7154           `.colors.PowerNorm`.
7155         """
7156 
7157         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7158                                            density=density, weights=weights)
7159 
7160         if cmin is not None:
7161             h[h < cmin] = None
7162         if cmax is not None:
7163             h[h > cmax] = None
7164 
7165         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7166         self.set_xlim(xedges[0], xedges[-1])
7167         self.set_ylim(yedges[0], yedges[-1])
7168 
7169         return h, xedges, yedges, pc
7170 
7171     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7172     @_docstring.dedent_interpd
7173     def ecdf(self, x, weights=None, *, complementary=False,
7174              orientation="vertical", compress=False, **kwargs):
7175         """
7176         Compute and plot the empirical cumulative distribution function of *x*.
7177 
7178         .. versionadded:: 3.8
7179 
7180         Parameters
7181         ----------
7182         x : 1d array-like
7183             The input data.  Infinite entries are kept (and move the relevant
7184             end of the ecdf from 0/1), but NaNs and masked values are errors.
7185 
7186         weights : 1d array-like or None, default: None
7187             The weights of the entries; must have the same shape as *x*.
7188             Weights corresponding to NaN data points are dropped, and then the
7189             remaining weights are normalized to sum to 1.  If unset, all
7190             entries have the same weight.
7191 
7192         complementary : bool, default: False
7193             Whether to plot a cumulative distribution function, which increases
7194             from 0 to 1 (the default), or a complementary cumulative
7195             distribution function, which decreases from 1 to 0.
7196 
7197         orientation : {"vertical", "horizontal"}, default: "vertical"
7198             Whether the entries are plotted along the x-axis ("vertical", the
7199             default) or the y-axis ("horizontal").  This parameter takes the
7200             same values as in `~.Axes.hist`.
7201 
7202         compress : bool, default: False
7203             Whether multiple entries with the same values are grouped together
7204             (with a summed weight) before plotting.  This is mainly useful if
7205             *x* contains many identical data points, to decrease the rendering
7206             complexity of the plot. If *x* contains no duplicate points, this
7207             has no effect and just uses some time and memory.
7208 
7209         Other Parameters
7210         ----------------
7211         data : indexable object, optional
7212             DATA_PARAMETER_PLACEHOLDER
7213 
7214         **kwargs
7215             Keyword arguments control the `.Line2D` properties:
7216 
7217             %(Line2D:kwdoc)s
7218 
7219         Returns
7220         -------
7221         `.Line2D`
7222 
7223         Notes
7224         -----
7225         The ecdf plot can be thought of as a cumulative histogram with one bin
7226         per data entry; i.e. it reports on the entire dataset without any
7227         arbitrary binning.
7228 
7229         If *x* contains NaNs or masked entries, either remove them first from
7230         the array (if they should not taken into account), or replace them by
7231         -inf or +inf (if they should be sorted at the beginning or the end of
7232         the array).
7233         """
7234         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7235         if "drawstyle" in kwargs or "ds" in kwargs:
7236             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7237         if np.ma.getmask(x).any():
7238             raise ValueError("ecdf() does not support masked entries")
7239         x = np.asarray(x)
7240         if np.isnan(x).any():
7241             raise ValueError("ecdf() does not support NaNs")
7242         argsort = np.argsort(x)
7243         x = x[argsort]
7244         if weights is None:
7245             # Ensure that we end at exactly 1, avoiding floating point errors.
7246             cum_weights = (1 + np.arange(len(x))) / len(x)
7247         else:
7248             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7249             cum_weights = np.cumsum(weights / np.sum(weights))
7250         if compress:
7251             # Get indices of unique x values.
7252             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7253             x = x[compress_idxs]
7254             cum_weights = cum_weights[compress_idxs]
7255         if orientation == "vertical":
7256             if not complementary:
7257                 line, = self.plot([x[0], *x], [0, *cum_weights],
7258                                   drawstyle="steps-post", **kwargs)
7259             else:
7260                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7261                                   drawstyle="steps-pre", **kwargs)
7262             line.sticky_edges.y[:] = [0, 1]
7263         else:  # orientation == "horizontal":
7264             if not complementary:
7265                 line, = self.plot([0, *cum_weights], [x[0], *x],
7266                                   drawstyle="steps-pre", **kwargs)
7267             else:
7268                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7269                                   drawstyle="steps-post", **kwargs)
7270             line.sticky_edges.x[:] = [0, 1]
7271         return line
7272 
7273     @_preprocess_data(replace_names=["x"])
7274     @_docstring.dedent_interpd
7275     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7276             window=None, noverlap=None, pad_to=None,
7277             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7278         r"""
7279         Plot the power spectral density.
7280 
7281         The power spectral density :math:`P_{xx}` by Welch's average
7282         periodogram method.  The vector *x* is divided into *NFFT* length
7283         segments.  Each segment is detrended by function *detrend* and
7284         windowed by function *window*.  *noverlap* gives the length of
7285         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7286         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7287         with a scaling to correct for power loss due to windowing.
7288 
7289         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7290 
7291         Parameters
7292         ----------
7293         x : 1-D array or sequence
7294             Array or sequence containing the data
7295 
7296         %(Spectral)s
7297 
7298         %(PSD)s
7299 
7300         noverlap : int, default: 0 (no overlap)
7301             The number of points of overlap between segments.
7302 
7303         Fc : int, default: 0
7304             The center frequency of *x*, which offsets the x extents of the
7305             plot to reflect the frequency range used when a signal is acquired
7306             and then filtered and downsampled to baseband.
7307 
7308         return_line : bool, default: False
7309             Whether to include the line object plotted in the returned values.
7310 
7311         Returns
7312         -------
7313         Pxx : 1-D array
7314             The values for the power spectrum :math:`P_{xx}` before scaling
7315             (real valued).
7316 
7317         freqs : 1-D array
7318             The frequencies corresponding to the elements in *Pxx*.
7319 
7320         line : `~matplotlib.lines.Line2D`
7321             The line created by this function.
7322             Only returned if *return_line* is True.
7323 
7324         Other Parameters
7325         ----------------
7326         data : indexable object, optional
7327             DATA_PARAMETER_PLACEHOLDER
7328 
7329         **kwargs
7330             Keyword arguments control the `.Line2D` properties:
7331 
7332             %(Line2D:kwdoc)s
7333 
7334         See Also
7335         --------
7336         specgram
7337             Differs in the default overlap; in not returning the mean of the
7338             segment periodograms; in returning the times of the segments; and
7339             in plotting a colormap instead of a line.
7340         magnitude_spectrum
7341             Plots the magnitude spectrum.
7342         csd
7343             Plots the spectral density between two signals.
7344 
7345         Notes
7346         -----
7347         For plotting, the power is plotted as
7348         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7349         is returned.
7350 
7351         References
7352         ----------
7353         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7354         John Wiley & Sons (1986)
7355         """
7356         if Fc is None:
7357             Fc = 0
7358 
7359         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7360                               window=window, noverlap=noverlap, pad_to=pad_to,
7361                               sides=sides, scale_by_freq=scale_by_freq)
7362         freqs += Fc
7363 
7364         if scale_by_freq in (None, True):
7365             psd_units = 'dB/Hz'
7366         else:
7367             psd_units = 'dB'
7368 
7369         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7370         self.set_xlabel('Frequency')
7371         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7372         self.grid(True)
7373 
7374         vmin, vmax = self.get_ybound()
7375         step = max(10 * int(np.log10(vmax - vmin)), 1)
7376         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7377         self.set_yticks(ticks)
7378 
7379         if return_line is None or not return_line:
7380             return pxx, freqs
7381         else:
7382             return pxx, freqs, line
7383 
7384     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7385     @_docstring.dedent_interpd
7386     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7387             window=None, noverlap=None, pad_to=None,
7388             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7389         r"""
7390         Plot the cross-spectral density.
7391 
7392         The cross spectral density :math:`P_{xy}` by Welch's average
7393         periodogram method.  The vectors *x* and *y* are divided into
7394         *NFFT* length segments.  Each segment is detrended by function
7395         *detrend* and windowed by function *window*.  *noverlap* gives
7396         the length of the overlap between segments.  The product of
7397         the direct FFTs of *x* and *y* are averaged over each segment
7398         to compute :math:`P_{xy}`, with a scaling to correct for power
7399         loss due to windowing.
7400 
7401         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7402         padded to *NFFT*.
7403 
7404         Parameters
7405         ----------
7406         x, y : 1-D arrays or sequences
7407             Arrays or sequences containing the data.
7408 
7409         %(Spectral)s
7410 
7411         %(PSD)s
7412 
7413         noverlap : int, default: 0 (no overlap)
7414             The number of points of overlap between segments.
7415 
7416         Fc : int, default: 0
7417             The center frequency of *x*, which offsets the x extents of the
7418             plot to reflect the frequency range used when a signal is acquired
7419             and then filtered and downsampled to baseband.
7420 
7421         return_line : bool, default: False
7422             Whether to include the line object plotted in the returned values.
7423 
7424         Returns
7425         -------
7426         Pxy : 1-D array
7427             The values for the cross spectrum :math:`P_{xy}` before scaling
7428             (complex valued).
7429 
7430         freqs : 1-D array
7431             The frequencies corresponding to the elements in *Pxy*.
7432 
7433         line : `~matplotlib.lines.Line2D`
7434             The line created by this function.
7435             Only returned if *return_line* is True.
7436 
7437         Other Parameters
7438         ----------------
7439         data : indexable object, optional
7440             DATA_PARAMETER_PLACEHOLDER
7441 
7442         **kwargs
7443             Keyword arguments control the `.Line2D` properties:
7444 
7445             %(Line2D:kwdoc)s
7446 
7447         See Also
7448         --------
7449         psd : is equivalent to setting ``y = x``.
7450 
7451         Notes
7452         -----
7453         For plotting, the power is plotted as
7454         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7455         is returned.
7456 
7457         References
7458         ----------
7459         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7460         John Wiley & Sons (1986)
7461         """
7462         if Fc is None:
7463             Fc = 0
7464 
7465         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7466                               window=window, noverlap=noverlap, pad_to=pad_to,
7467                               sides=sides, scale_by_freq=scale_by_freq)
7468         # pxy is complex
7469         freqs += Fc
7470 
7471         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7472         self.set_xlabel('Frequency')
7473         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7474         self.grid(True)
7475 
7476         vmin, vmax = self.get_ybound()
7477         step = max(10 * int(np.log10(vmax - vmin)), 1)
7478         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7479         self.set_yticks(ticks)
7480 
7481         if return_line is None or not return_line:
7482             return pxy, freqs
7483         else:
7484             return pxy, freqs, line
7485 
7486     @_preprocess_data(replace_names=["x"])
7487     @_docstring.dedent_interpd
7488     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7489                            pad_to=None, sides=None, scale=None,
7490                            **kwargs):
7491         """
7492         Plot the magnitude spectrum.
7493 
7494         Compute the magnitude spectrum of *x*.  Data is padded to a
7495         length of *pad_to* and the windowing function *window* is applied to
7496         the signal.
7497 
7498         Parameters
7499         ----------
7500         x : 1-D array or sequence
7501             Array or sequence containing the data.
7502 
7503         %(Spectral)s
7504 
7505         %(Single_Spectrum)s
7506 
7507         scale : {'default', 'linear', 'dB'}
7508             The scaling of the values in the *spec*.  'linear' is no scaling.
7509             'dB' returns the values in dB scale, i.e., the dB amplitude
7510             (20 * log10). 'default' is 'linear'.
7511 
7512         Fc : int, default: 0
7513             The center frequency of *x*, which offsets the x extents of the
7514             plot to reflect the frequency range used when a signal is acquired
7515             and then filtered and downsampled to baseband.
7516 
7517         Returns
7518         -------
7519         spectrum : 1-D array
7520             The values for the magnitude spectrum before scaling (real valued).
7521 
7522         freqs : 1-D array
7523             The frequencies corresponding to the elements in *spectrum*.
7524 
7525         line : `~matplotlib.lines.Line2D`
7526             The line created by this function.
7527 
7528         Other Parameters
7529         ----------------
7530         data : indexable object, optional
7531             DATA_PARAMETER_PLACEHOLDER
7532 
7533         **kwargs
7534             Keyword arguments control the `.Line2D` properties:
7535 
7536             %(Line2D:kwdoc)s
7537 
7538         See Also
7539         --------
7540         psd
7541             Plots the power spectral density.
7542         angle_spectrum
7543             Plots the angles of the corresponding frequencies.
7544         phase_spectrum
7545             Plots the phase (unwrapped angle) of the corresponding frequencies.
7546         specgram
7547             Can plot the magnitude spectrum of segments within the signal in a
7548             colormap.
7549         """
7550         if Fc is None:
7551             Fc = 0
7552 
7553         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7554                                               pad_to=pad_to, sides=sides)
7555         freqs += Fc
7556 
7557         yunits = _api.check_getitem(
7558             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7559              'dB': 'dB'},
7560             scale=scale)
7561         if yunits == 'energy':
7562             Z = spec
7563         else:  # yunits == 'dB'
7564             Z = 20. * np.log10(spec)
7565 
7566         line, = self.plot(freqs, Z, **kwargs)
7567         self.set_xlabel('Frequency')
7568         self.set_ylabel('Magnitude (%s)' % yunits)
7569 
7570         return spec, freqs, line
7571 
7572     @_preprocess_data(replace_names=["x"])
7573     @_docstring.dedent_interpd
7574     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7575                        pad_to=None, sides=None, **kwargs):
7576         """
7577         Plot the angle spectrum.
7578 
7579         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7580         Data is padded to a length of *pad_to* and the windowing function
7581         *window* is applied to the signal.
7582 
7583         Parameters
7584         ----------
7585         x : 1-D array or sequence
7586             Array or sequence containing the data.
7587 
7588         %(Spectral)s
7589 
7590         %(Single_Spectrum)s
7591 
7592         Fc : int, default: 0
7593             The center frequency of *x*, which offsets the x extents of the
7594             plot to reflect the frequency range used when a signal is acquired
7595             and then filtered and downsampled to baseband.
7596 
7597         Returns
7598         -------
7599         spectrum : 1-D array
7600             The values for the angle spectrum in radians (real valued).
7601 
7602         freqs : 1-D array
7603             The frequencies corresponding to the elements in *spectrum*.
7604 
7605         line : `~matplotlib.lines.Line2D`
7606             The line created by this function.
7607 
7608         Other Parameters
7609         ----------------
7610         data : indexable object, optional
7611             DATA_PARAMETER_PLACEHOLDER
7612 
7613         **kwargs
7614             Keyword arguments control the `.Line2D` properties:
7615 
7616             %(Line2D:kwdoc)s
7617 
7618         See Also
7619         --------
7620         magnitude_spectrum
7621             Plots the magnitudes of the corresponding frequencies.
7622         phase_spectrum
7623             Plots the unwrapped version of this function.
7624         specgram
7625             Can plot the angle spectrum of segments within the signal in a
7626             colormap.
7627         """
7628         if Fc is None:
7629             Fc = 0
7630 
7631         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7632                                           pad_to=pad_to, sides=sides)
7633         freqs += Fc
7634 
7635         lines = self.plot(freqs, spec, **kwargs)
7636         self.set_xlabel('Frequency')
7637         self.set_ylabel('Angle (radians)')
7638 
7639         return spec, freqs, lines[0]
7640 
7641     @_preprocess_data(replace_names=["x"])
7642     @_docstring.dedent_interpd
7643     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7644                        pad_to=None, sides=None, **kwargs):
7645         """
7646         Plot the phase spectrum.
7647 
7648         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7649         Data is padded to a length of *pad_to* and the windowing function
7650         *window* is applied to the signal.
7651 
7652         Parameters
7653         ----------
7654         x : 1-D array or sequence
7655             Array or sequence containing the data
7656 
7657         %(Spectral)s
7658 
7659         %(Single_Spectrum)s
7660 
7661         Fc : int, default: 0
7662             The center frequency of *x*, which offsets the x extents of the
7663             plot to reflect the frequency range used when a signal is acquired
7664             and then filtered and downsampled to baseband.
7665 
7666         Returns
7667         -------
7668         spectrum : 1-D array
7669             The values for the phase spectrum in radians (real valued).
7670 
7671         freqs : 1-D array
7672             The frequencies corresponding to the elements in *spectrum*.
7673 
7674         line : `~matplotlib.lines.Line2D`
7675             The line created by this function.
7676 
7677         Other Parameters
7678         ----------------
7679         data : indexable object, optional
7680             DATA_PARAMETER_PLACEHOLDER
7681 
7682         **kwargs
7683             Keyword arguments control the `.Line2D` properties:
7684 
7685             %(Line2D:kwdoc)s
7686 
7687         See Also
7688         --------
7689         magnitude_spectrum
7690             Plots the magnitudes of the corresponding frequencies.
7691         angle_spectrum
7692             Plots the wrapped version of this function.
7693         specgram
7694             Can plot the phase spectrum of segments within the signal in a
7695             colormap.
7696         """
7697         if Fc is None:
7698             Fc = 0
7699 
7700         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7701                                           pad_to=pad_to, sides=sides)
7702         freqs += Fc
7703 
7704         lines = self.plot(freqs, spec, **kwargs)
7705         self.set_xlabel('Frequency')
7706         self.set_ylabel('Phase (radians)')
7707 
7708         return spec, freqs, lines[0]
7709 
7710     @_preprocess_data(replace_names=["x", "y"])
7711     @_docstring.dedent_interpd
7712     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7713                window=mlab.window_hanning, noverlap=0, pad_to=None,
7714                sides='default', scale_by_freq=None, **kwargs):
7715         r"""
7716         Plot the coherence between *x* and *y*.
7717 
7718         Coherence is the normalized cross spectral density:
7719 
7720         .. math::
7721 
7722           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7723 
7724         Parameters
7725         ----------
7726         %(Spectral)s
7727 
7728         %(PSD)s
7729 
7730         noverlap : int, default: 0 (no overlap)
7731             The number of points of overlap between blocks.
7732 
7733         Fc : int, default: 0
7734             The center frequency of *x*, which offsets the x extents of the
7735             plot to reflect the frequency range used when a signal is acquired
7736             and then filtered and downsampled to baseband.
7737 
7738         Returns
7739         -------
7740         Cxy : 1-D array
7741             The coherence vector.
7742 
7743         freqs : 1-D array
7744             The frequencies for the elements in *Cxy*.
7745 
7746         Other Parameters
7747         ----------------
7748         data : indexable object, optional
7749             DATA_PARAMETER_PLACEHOLDER
7750 
7751         **kwargs
7752             Keyword arguments control the `.Line2D` properties:
7753 
7754             %(Line2D:kwdoc)s
7755 
7756         References
7757         ----------
7758         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7759         John Wiley & Sons (1986)
7760         """
7761         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7762                                  window=window, noverlap=noverlap,
7763                                  scale_by_freq=scale_by_freq, sides=sides,
7764                                  pad_to=pad_to)
7765         freqs += Fc
7766 
7767         self.plot(freqs, cxy, **kwargs)
7768         self.set_xlabel('Frequency')
7769         self.set_ylabel('Coherence')
7770         self.grid(True)
7771 
7772         return cxy, freqs
7773 
7774     @_preprocess_data(replace_names=["x"])
7775     @_docstring.dedent_interpd
7776     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7777                  window=None, noverlap=None,
7778                  cmap=None, xextent=None, pad_to=None, sides=None,
7779                  scale_by_freq=None, mode=None, scale=None,
7780                  vmin=None, vmax=None, **kwargs):
7781         """
7782         Plot a spectrogram.
7783 
7784         Compute and plot a spectrogram of data in *x*.  Data are split into
7785         *NFFT* length segments and the spectrum of each section is
7786         computed.  The windowing function *window* is applied to each
7787         segment, and the amount of overlap of each segment is
7788         specified with *noverlap*. The spectrogram is plotted as a colormap
7789         (using imshow).
7790 
7791         Parameters
7792         ----------
7793         x : 1-D array or sequence
7794             Array or sequence containing the data.
7795 
7796         %(Spectral)s
7797 
7798         %(PSD)s
7799 
7800         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7801             What sort of spectrum to use.  Default is 'psd', which takes the
7802             power spectral density.  'magnitude' returns the magnitude
7803             spectrum.  'angle' returns the phase spectrum without unwrapping.
7804             'phase' returns the phase spectrum with unwrapping.
7805 
7806         noverlap : int, default: 128
7807             The number of points of overlap between blocks.
7808 
7809         scale : {'default', 'linear', 'dB'}
7810             The scaling of the values in the *spec*.  'linear' is no scaling.
7811             'dB' returns the values in dB scale.  When *mode* is 'psd',
7812             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7813             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7814             'magnitude' and 'linear' otherwise.  This must be 'linear'
7815             if *mode* is 'angle' or 'phase'.
7816 
7817         Fc : int, default: 0
7818             The center frequency of *x*, which offsets the x extents of the
7819             plot to reflect the frequency range used when a signal is acquired
7820             and then filtered and downsampled to baseband.
7821 
7822         cmap : `.Colormap`, default: :rc:`image.cmap`
7823 
7824         xextent : *None* or (xmin, xmax)
7825             The image extent along the x-axis. The default sets *xmin* to the
7826             left border of the first bin (*spectrum* column) and *xmax* to the
7827             right border of the last bin. Note that for *noverlap>0* the width
7828             of the bins is smaller than those of the segments.
7829 
7830         data : indexable object, optional
7831             DATA_PARAMETER_PLACEHOLDER
7832 
7833         **kwargs
7834             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7835             which makes the specgram image. The origin keyword argument
7836             is not supported.
7837 
7838         Returns
7839         -------
7840         spectrum : 2D array
7841             Columns are the periodograms of successive segments.
7842 
7843         freqs : 1-D array
7844             The frequencies corresponding to the rows in *spectrum*.
7845 
7846         t : 1-D array
7847             The times corresponding to midpoints of segments (i.e., the columns
7848             in *spectrum*).
7849 
7850         im : `.AxesImage`
7851             The image created by imshow containing the spectrogram.
7852 
7853         See Also
7854         --------
7855         psd
7856             Differs in the default overlap; in returning the mean of the
7857             segment periodograms; in not returning times; and in generating a
7858             line plot instead of colormap.
7859         magnitude_spectrum
7860             A single spectrum, similar to having a single segment when *mode*
7861             is 'magnitude'. Plots a line instead of a colormap.
7862         angle_spectrum
7863             A single spectrum, similar to having a single segment when *mode*
7864             is 'angle'. Plots a line instead of a colormap.
7865         phase_spectrum
7866             A single spectrum, similar to having a single segment when *mode*
7867             is 'phase'. Plots a line instead of a colormap.
7868 
7869         Notes
7870         -----
7871         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7872         is set to 'psd'.
7873         """
7874         if NFFT is None:
7875             NFFT = 256  # same default as in mlab.specgram()
7876         if Fc is None:
7877             Fc = 0  # same default as in mlab._spectral_helper()
7878         if noverlap is None:
7879             noverlap = 128  # same default as in mlab.specgram()
7880         if Fs is None:
7881             Fs = 2  # same default as in mlab._spectral_helper()
7882 
7883         if mode == 'complex':
7884             raise ValueError('Cannot plot a complex specgram')
7885 
7886         if scale is None or scale == 'default':
7887             if mode in ['angle', 'phase']:
7888                 scale = 'linear'
7889             else:
7890                 scale = 'dB'
7891         elif mode in ['angle', 'phase'] and scale == 'dB':
7892             raise ValueError('Cannot use dB scale with angle or phase mode')
7893 
7894         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7895                                        detrend=detrend, window=window,
7896                                        noverlap=noverlap, pad_to=pad_to,
7897                                        sides=sides,
7898                                        scale_by_freq=scale_by_freq,
7899                                        mode=mode)
7900 
7901         if scale == 'linear':
7902             Z = spec
7903         elif scale == 'dB':
7904             if mode is None or mode == 'default' or mode == 'psd':
7905                 Z = 10. * np.log10(spec)
7906             else:
7907                 Z = 20. * np.log10(spec)
7908         else:
7909             raise ValueError(f'Unknown scale {scale!r}')
7910 
7911         Z = np.flipud(Z)
7912 
7913         if xextent is None:
7914             # padding is needed for first and last segment:
7915             pad_xextent = (NFFT-noverlap) / Fs / 2
7916             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7917         xmin, xmax = xextent
7918         freqs += Fc
7919         extent = xmin, xmax, freqs[0], freqs[-1]
7920 
7921         if 'origin' in kwargs:
7922             raise _api.kwarg_error("specgram", "origin")
7923 
7924         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7925                          origin='upper', **kwargs)
7926         self.axis('auto')
7927 
7928         return spec, freqs, t, im
7929 
7930     @_docstring.dedent_interpd
7931     def spy(self, Z, precision=0, marker=None, markersize=None,
7932             aspect='equal', origin="upper", **kwargs):
7933         """
7934         Plot the sparsity pattern of a 2D array.
7935 
7936         This visualizes the non-zero values of the array.
7937 
7938         Two plotting styles are available: image and marker. Both
7939         are available for full arrays, but only the marker style
7940         works for `scipy.sparse.spmatrix` instances.
7941 
7942         **Image style**
7943 
7944         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7945         extra remaining keyword arguments are passed to this method.
7946 
7947         **Marker style**
7948 
7949         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7950         *None*, a `.Line2D` object will be returned with the value of marker
7951         determining the marker type, and any remaining keyword arguments
7952         passed to `~.Axes.plot`.
7953 
7954         Parameters
7955         ----------
7956         Z : (M, N) array-like
7957             The array to be plotted.
7958 
7959         precision : float or 'present', default: 0
7960             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7961             values of :math:`|Z| > precision` will be plotted.
7962 
7963             For `scipy.sparse.spmatrix` instances, you can also
7964             pass 'present'. In this case any value present in the array
7965             will be plotted, even if it is identically zero.
7966 
7967         aspect : {'equal', 'auto', None} or float, default: 'equal'
7968             The aspect ratio of the Axes.  This parameter is particularly
7969             relevant for images since it determines whether data pixels are
7970             square.
7971 
7972             This parameter is a shortcut for explicitly calling
7973             `.Axes.set_aspect`. See there for further details.
7974 
7975             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7976             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7977               that the data fit in the Axes. In general, this will result in
7978               non-square pixels.
7979             - *None*: Use :rc:`image.aspect`.
7980 
7981         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7982             Place the [0, 0] index of the array in the upper left or lower left
7983             corner of the Axes. The convention 'upper' is typically used for
7984             matrices and images.
7985 
7986         Returns
7987         -------
7988         `~matplotlib.image.AxesImage` or `.Line2D`
7989             The return type depends on the plotting style (see above).
7990 
7991         Other Parameters
7992         ----------------
7993         **kwargs
7994             The supported additional parameters depend on the plotting style.
7995 
7996             For the image style, you can pass the following additional
7997             parameters of `~.Axes.imshow`:
7998 
7999             - *cmap*
8000             - *alpha*
8001             - *url*
8002             - any `.Artist` properties (passed on to the `.AxesImage`)
8003 
8004             For the marker style, you can pass any `.Line2D` property except
8005             for *linestyle*:
8006 
8007             %(Line2D:kwdoc)s
8008         """
8009         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8010             marker = 's'
8011         _api.check_in_list(["upper", "lower"], origin=origin)
8012         if marker is None and markersize is None:
8013             Z = np.asarray(Z)
8014             mask = np.abs(Z) > precision
8015 
8016             if 'cmap' not in kwargs:
8017                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8018                                                         name='binary')
8019             if 'interpolation' in kwargs:
8020                 raise _api.kwarg_error("spy", "interpolation")
8021             if 'norm' not in kwargs:
8022                 kwargs['norm'] = mcolors.NoNorm()
8023             ret = self.imshow(mask, interpolation='nearest',
8024                               aspect=aspect, origin=origin,
8025                               **kwargs)
8026         else:
8027             if hasattr(Z, 'tocoo'):
8028                 c = Z.tocoo()
8029                 if precision == 'present':
8030                     y = c.row
8031                     x = c.col
8032                 else:
8033                     nonzero = np.abs(c.data) > precision
8034                     y = c.row[nonzero]
8035                     x = c.col[nonzero]
8036             else:
8037                 Z = np.asarray(Z)
8038                 nonzero = np.abs(Z) > precision
8039                 y, x = np.nonzero(nonzero)
8040             if marker is None:
8041                 marker = 's'
8042             if markersize is None:
8043                 markersize = 10
8044             if 'linestyle' in kwargs:
8045                 raise _api.kwarg_error("spy", "linestyle")
8046             ret = mlines.Line2D(
8047                 x, y, linestyle='None', marker=marker, markersize=markersize,
8048                 **kwargs)
8049             self.add_line(ret)
8050             nr, nc = Z.shape
8051             self.set_xlim(-0.5, nc - 0.5)
8052             if origin == "upper":
8053                 self.set_ylim(nr - 0.5, -0.5)
8054             else:
8055                 self.set_ylim(-0.5, nr - 0.5)
8056             self.set_aspect(aspect)
8057         self.title.set_y(1.05)
8058         if origin == "upper":
8059             self.xaxis.tick_top()
8060         else:  # lower
8061             self.xaxis.tick_bottom()
8062         self.xaxis.set_ticks_position('both')
8063         self.xaxis.set_major_locator(
8064             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8065         self.yaxis.set_major_locator(
8066             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8067         return ret
8068 
8069     def matshow(self, Z, **kwargs):
8070         """
8071         Plot the values of a 2D matrix or array as color-coded image.
8072 
8073         The matrix will be shown the way it would be printed, with the first
8074         row at the top.  Row and column numbering is zero-based.
8075 
8076         Parameters
8077         ----------
8078         Z : (M, N) array-like
8079             The matrix to be displayed.
8080 
8081         Returns
8082         -------
8083         `~matplotlib.image.AxesImage`
8084 
8085         Other Parameters
8086         ----------------
8087         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8088 
8089         See Also
8090         --------
8091         imshow : More general function to plot data on a 2D regular raster.
8092 
8093         Notes
8094         -----
8095         This is just a convenience function wrapping `.imshow` to set useful
8096         defaults for displaying a matrix. In particular:
8097 
8098         - Set ``origin='upper'``.
8099         - Set ``interpolation='nearest'``.
8100         - Set ``aspect='equal'``.
8101         - Ticks are placed to the left and above.
8102         - Ticks are formatted to show integer indices.
8103 
8104         """
8105         Z = np.asanyarray(Z)
8106         kw = {'origin': 'upper',
8107               'interpolation': 'nearest',
8108               'aspect': 'equal',          # (already the imshow default)
8109               **kwargs}
8110         im = self.imshow(Z, **kw)
8111         self.title.set_y(1.05)
8112         self.xaxis.tick_top()
8113         self.xaxis.set_ticks_position('both')
8114         self.xaxis.set_major_locator(
8115             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8116         self.yaxis.set_major_locator(
8117             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8118         return im
8119 
8120     @_preprocess_data(replace_names=["dataset"])
8121     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8122                    showmeans=False, showextrema=True, showmedians=False,
8123                    quantiles=None, points=100, bw_method=None):
8124         """
8125         Make a violin plot.
8126 
8127         Make a violin plot for each column of *dataset* or each vector in
8128         sequence *dataset*.  Each filled area extends to represent the
8129         entire data range, with optional lines at the mean, the median,
8130         the minimum, the maximum, and user-specified quantiles.
8131 
8132         Parameters
8133         ----------
8134         dataset : Array or a sequence of vectors.
8135           The input data.
8136 
8137         positions : array-like, default: [1, 2, ..., n]
8138           The positions of the violins. The ticks and limits are
8139           automatically set to match the positions.
8140 
8141         vert : bool, default: True.
8142           If true, creates a vertical violin plot.
8143           Otherwise, creates a horizontal violin plot.
8144 
8145         widths : array-like, default: 0.5
8146           Either a scalar or a vector that sets the maximal width of
8147           each violin. The default is 0.5, which uses about half of the
8148           available horizontal space.
8149 
8150         showmeans : bool, default: False
8151           If `True`, will toggle rendering of the means.
8152 
8153         showextrema : bool, default: True
8154           If `True`, will toggle rendering of the extrema.
8155 
8156         showmedians : bool, default: False
8157           If `True`, will toggle rendering of the medians.
8158 
8159         quantiles : array-like, default: None
8160           If not None, set a list of floats in interval [0, 1] for each violin,
8161           which stands for the quantiles that will be rendered for that
8162           violin.
8163 
8164         points : int, default: 100
8165           Defines the number of points to evaluate each of the
8166           gaussian kernel density estimations at.
8167 
8168         bw_method : str, scalar or callable, optional
8169           The method used to calculate the estimator bandwidth.  This can be
8170           'scott', 'silverman', a scalar constant or a callable.  If a
8171           scalar, this will be used directly as `kde.factor`.  If a
8172           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8173           its only parameter and return a scalar. If None (default), 'scott'
8174           is used.
8175 
8176         data : indexable object, optional
8177             DATA_PARAMETER_PLACEHOLDER
8178 
8179         Returns
8180         -------
8181         dict
8182           A dictionary mapping each component of the violinplot to a
8183           list of the corresponding collection instances created. The
8184           dictionary has the following keys:
8185 
8186           - ``bodies``: A list of the `~.collections.PolyCollection`
8187             instances containing the filled area of each violin.
8188 
8189           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8190             the mean values of each of the violin's distribution.
8191 
8192           - ``cmins``: A `~.collections.LineCollection` instance that marks
8193             the bottom of each violin's distribution.
8194 
8195           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8196             the top of each violin's distribution.
8197 
8198           - ``cbars``: A `~.collections.LineCollection` instance that marks
8199             the centers of each violin's distribution.
8200 
8201           - ``cmedians``: A `~.collections.LineCollection` instance that
8202             marks the median values of each of the violin's distribution.
8203 
8204           - ``cquantiles``: A `~.collections.LineCollection` instance created
8205             to identify the quantile values of each of the violin's
8206             distribution.
8207 
8208         """
8209 
8210         def _kde_method(X, coords):
8211             # Unpack in case of e.g. Pandas or xarray object
8212             X = cbook._unpack_to_numpy(X)
8213             # fallback gracefully if the vector contains only one value
8214             if np.all(X[0] == X):
8215                 return (X[0] == coords).astype(float)
8216             kde = mlab.GaussianKDE(X, bw_method)
8217             return kde.evaluate(coords)
8218 
8219         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8220                                      quantiles=quantiles)
8221         return self.violin(vpstats, positions=positions, vert=vert,
8222                            widths=widths, showmeans=showmeans,
8223                            showextrema=showextrema, showmedians=showmedians)
8224 
8225     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8226                showmeans=False, showextrema=True, showmedians=False):
8227         """
8228         Drawing function for violin plots.
8229 
8230         Draw a violin plot for each column of *vpstats*. Each filled area
8231         extends to represent the entire data range, with optional lines at the
8232         mean, the median, the minimum, the maximum, and the quantiles values.
8233 
8234         Parameters
8235         ----------
8236         vpstats : list of dicts
8237           A list of dictionaries containing stats for each violin plot.
8238           Required keys are:
8239 
8240           - ``coords``: A list of scalars containing the coordinates that
8241             the violin's kernel density estimate were evaluated at.
8242 
8243           - ``vals``: A list of scalars containing the values of the
8244             kernel density estimate at each of the coordinates given
8245             in *coords*.
8246 
8247           - ``mean``: The mean value for this violin's dataset.
8248 
8249           - ``median``: The median value for this violin's dataset.
8250 
8251           - ``min``: The minimum value for this violin's dataset.
8252 
8253           - ``max``: The maximum value for this violin's dataset.
8254 
8255           Optional keys are:
8256 
8257           - ``quantiles``: A list of scalars containing the quantile values
8258             for this violin's dataset.
8259 
8260         positions : array-like, default: [1, 2, ..., n]
8261           The positions of the violins. The ticks and limits are
8262           automatically set to match the positions.
8263 
8264         vert : bool, default: True.
8265           If true, plots the violins vertically.
8266           Otherwise, plots the violins horizontally.
8267 
8268         widths : array-like, default: 0.5
8269           Either a scalar or a vector that sets the maximal width of
8270           each violin. The default is 0.5, which uses about half of the
8271           available horizontal space.
8272 
8273         showmeans : bool, default: False
8274           If true, will toggle rendering of the means.
8275 
8276         showextrema : bool, default: True
8277           If true, will toggle rendering of the extrema.
8278 
8279         showmedians : bool, default: False
8280           If true, will toggle rendering of the medians.
8281 
8282         Returns
8283         -------
8284         dict
8285           A dictionary mapping each component of the violinplot to a
8286           list of the corresponding collection instances created. The
8287           dictionary has the following keys:
8288 
8289           - ``bodies``: A list of the `~.collections.PolyCollection`
8290             instances containing the filled area of each violin.
8291 
8292           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8293             the mean values of each of the violin's distribution.
8294 
8295           - ``cmins``: A `~.collections.LineCollection` instance that marks
8296             the bottom of each violin's distribution.
8297 
8298           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8299             the top of each violin's distribution.
8300 
8301           - ``cbars``: A `~.collections.LineCollection` instance that marks
8302             the centers of each violin's distribution.
8303 
8304           - ``cmedians``: A `~.collections.LineCollection` instance that
8305             marks the median values of each of the violin's distribution.
8306 
8307           - ``cquantiles``: A `~.collections.LineCollection` instance created
8308             to identify the quantiles values of each of the violin's
8309             distribution.
8310         """
8311 
8312         # Statistical quantities to be plotted on the violins
8313         means = []
8314         mins = []
8315         maxes = []
8316         medians = []
8317         quantiles = []
8318 
8319         qlens = []  # Number of quantiles in each dataset.
8320 
8321         artists = {}  # Collections to be returned
8322 
8323         N = len(vpstats)
8324         datashape_message = ("List of violinplot statistics and `{0}` "
8325                              "values must have the same length")
8326 
8327         # Validate positions
8328         if positions is None:
8329             positions = range(1, N + 1)
8330         elif len(positions) != N:
8331             raise ValueError(datashape_message.format("positions"))
8332 
8333         # Validate widths
8334         if np.isscalar(widths):
8335             widths = [widths] * N
8336         elif len(widths) != N:
8337             raise ValueError(datashape_message.format("widths"))
8338 
8339         # Calculate ranges for statistics lines (shape (2, N)).
8340         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8341 
8342         # Colors.
8343         if mpl.rcParams['_internal.classic_mode']:
8344             fillcolor = 'y'
8345             linecolor = 'r'
8346         else:
8347             fillcolor = linecolor = self._get_lines.get_next_color()
8348 
8349         # Check whether we are rendering vertically or horizontally
8350         if vert:
8351             fill = self.fill_betweenx
8352             perp_lines = functools.partial(self.hlines, colors=linecolor)
8353             par_lines = functools.partial(self.vlines, colors=linecolor)
8354         else:
8355             fill = self.fill_between
8356             perp_lines = functools.partial(self.vlines, colors=linecolor)
8357             par_lines = functools.partial(self.hlines, colors=linecolor)
8358 
8359         # Render violins
8360         bodies = []
8361         for stats, pos, width in zip(vpstats, positions, widths):
8362             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8363             vals = np.array(stats['vals'])
8364             vals = 0.5 * width * vals / vals.max()
8365             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8366                             facecolor=fillcolor, alpha=0.3)]
8367             means.append(stats['mean'])
8368             mins.append(stats['min'])
8369             maxes.append(stats['max'])
8370             medians.append(stats['median'])
8371             q = stats.get('quantiles')  # a list of floats, or None
8372             if q is None:
8373                 q = []
8374             quantiles.extend(q)
8375             qlens.append(len(q))
8376         artists['bodies'] = bodies
8377 
8378         if showmeans:  # Render means
8379             artists['cmeans'] = perp_lines(means, *line_ends)
8380         if showextrema:  # Render extrema
8381             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8382             artists['cmins'] = perp_lines(mins, *line_ends)
8383             artists['cbars'] = par_lines(positions, mins, maxes)
8384         if showmedians:  # Render medians
8385             artists['cmedians'] = perp_lines(medians, *line_ends)
8386         if quantiles:  # Render quantiles: each width is repeated qlen times.
8387             artists['cquantiles'] = perp_lines(
8388                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8389 
8390         return artists
8391 
8392     # Methods that are entirely implemented in other modules.
8393 
8394     table = mtable.table
8395 
8396     # args can be either Y or y1, y2, ... and all should be replaced
8397     stackplot = _preprocess_data()(mstack.stackplot)
8398 
8399     streamplot = _preprocess_data(
8400         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8401 
8402     tricontour = mtri.tricontour
8403     tricontourf = mtri.tricontourf
8404     tripcolor = mtri.tripcolor
8405     triplot = mtri.triplot
8406 
8407     def _get_aspect_ratio(self):
8408         """
8409         Convenience method to calculate the aspect ratio of the axes in
8410         the display coordinate system.
8411         """
8412         figure_size = self.get_figure().get_size_inches()
8413         ll, ur = self.get_position() * figure_size
8414         width, height = ur - ll
8415         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>barh</method>
<code>
2564     def barh(self, y, width, height=0.8, left=None, *, align="center",
2565              data=None, **kwargs):
2566         r"""
2567         Make a horizontal bar plot.
2568 
2569         The bars are positioned at *y* with the given *align*\ment. Their
2570         dimensions are given by *width* and *height*. The horizontal baseline
2571         is *left* (default 0).
2572 
2573         Many parameters can take either a single value applying to all bars
2574         or a sequence of values, one for each bar.
2575 
2576         Parameters
2577         ----------
2578         y : float or array-like
2579             The y coordinates of the bars. See also *align* for the
2580             alignment of the bars to the coordinates.
2581 
2582         width : float or array-like
2583             The width(s) of the bars.
2584 
2585         height : float or array-like, default: 0.8
2586             The heights of the bars.
2587 
2588         left : float or array-like, default: 0
2589             The x coordinates of the left side(s) of the bars.
2590 
2591         align : {'center', 'edge'}, default: 'center'
2592             Alignment of the base to the *y* coordinates*:
2593 
2594             - 'center': Center the bars on the *y* positions.
2595             - 'edge': Align the bottom edges of the bars with the *y*
2596               positions.
2597 
2598             To align the bars on the top edge pass a negative *height* and
2599             ``align='edge'``.
2600 
2601         Returns
2602         -------
2603         `.BarContainer`
2604             Container with all the bars and optionally errorbars.
2605 
2606         Other Parameters
2607         ----------------
2608         color : color or list of color, optional
2609             The colors of the bar faces.
2610 
2611         edgecolor : color or list of color, optional
2612             The colors of the bar edges.
2613 
2614         linewidth : float or array-like, optional
2615             Width of the bar edge(s). If 0, don't draw edges.
2616 
2617         tick_label : str or list of str, optional
2618             The tick labels of the bars.
2619             Default: None (Use default numeric labels.)
2620 
2621         label : str or list of str, optional
2622             A single label is attached to the resulting `.BarContainer` as a
2623             label for the whole dataset.
2624             If a list is provided, it must be the same length as *y* and
2625             labels the individual bars. Repeated labels are not de-duplicated
2626             and will cause repeated label entries, so this is best used when
2627             bars also differ in style (e.g., by passing a list to *color*.)
2628 
2629         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2630             If not *None*, add horizontal / vertical errorbars to the bar tips.
2631             The values are +/- sizes relative to the data:
2632 
2633             - scalar: symmetric +/- values for all bars
2634             - shape(N,): symmetric +/- values for each bar
2635             - shape(2, N): Separate - and + values for each bar. First row
2636               contains the lower errors, the second row contains the upper
2637               errors.
2638             - *None*: No errorbar. (default)
2639 
2640             See :doc:`/gallery/statistics/errorbar_features` for an example on
2641             the usage of *xerr* and *yerr*.
2642 
2643         ecolor : color or list of color, default: 'black'
2644             The line color of the errorbars.
2645 
2646         capsize : float, default: :rc:`errorbar.capsize`
2647            The length of the error bar caps in points.
2648 
2649         error_kw : dict, optional
2650             Dictionary of keyword arguments to be passed to the
2651             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2652             here take precedence over the independent keyword arguments.
2653 
2654         log : bool, default: False
2655             If ``True``, set the x-axis to be log scale.
2656 
2657         data : indexable object, optional
2658             If given, all parameters also accept a string ``s``, which is
2659             interpreted as ``data[s]`` (unless this raises an exception).
2660 
2661         **kwargs : `.Rectangle` properties
2662 
2663         %(Rectangle:kwdoc)s
2664 
2665         See Also
2666         --------
2667         bar : Plot a vertical bar plot.
2668 
2669         Notes
2670         -----
2671         Stacked bars can be achieved by passing individual *left* values per
2672         bar. See
2673         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2674         """
2675         kwargs.setdefault('orientation', 'horizontal')
2676         patches = self.bar(x=left, height=height, width=width, bottom=y,
2677                            align=align, data=data, **kwargs)
2678         return patches

</code><intended_behavior>Similarly to the `bar` method, `barh` should be enhanced to identify when the `left` parameter receives datetime objects and perform necessary conversions or adjustments to ensure the y-axis (for horizontal bars) adequately represents datetime scales. This preserves the method's current capabilities while extending its functionality to support datetime objects, addressing the reported issue of incorrect datetime units representation in horizontal bar plots.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119 
120             .. admonition:: Discouraged
121 
122                The use of *fontdict* is discouraged. Parameters should be passed as
123                individual keyword arguments or using dictionary-unpacking
124                ``set_title(..., **fontdict)``.
125 
126             A dictionary controlling the appearance of the title text,
127             the default *fontdict* is::
128 
129                {'fontsize': rcParams['axes.titlesize'],
130                 'fontweight': rcParams['axes.titleweight'],
131                 'color': rcParams['axes.titlecolor'],
132                 'verticalalignment': 'baseline',
133                 'horizontalalignment': loc}
134 
135         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
136             Which title to set.
137 
138         y : float, default: :rc:`axes.titley`
139             Vertical Axes location for the title (1.0 is the top).  If
140             None (the default) and :rc:`axes.titley` is also None, y is
141             determined automatically to avoid decorators on the Axes.
142 
143         pad : float, default: :rc:`axes.titlepad`
144             The offset of the title from the top of the Axes, in points.
145 
146         Returns
147         -------
148         `.Text`
149             The matplotlib text instance representing the title
150 
151         Other Parameters
152         ----------------
153         **kwargs : `.Text` properties
154             Other keyword arguments are text properties, see `.Text` for a list
155             of valid text properties.
156         """
157         if loc is None:
158             loc = mpl.rcParams['axes.titlelocation']
159 
160         if y is None:
161             y = mpl.rcParams['axes.titley']
162         if y is None:
163             y = 1.0
164         else:
165             self._autotitlepos = False
166         kwargs['y'] = y
167 
168         titles = {'left': self._left_title,
169                   'center': self.title,
170                   'right': self._right_title}
171         title = _api.check_getitem(titles, loc=loc.lower())
172         default = {
173             'fontsize': mpl.rcParams['axes.titlesize'],
174             'fontweight': mpl.rcParams['axes.titleweight'],
175             'verticalalignment': 'baseline',
176             'horizontalalignment': loc.lower()}
177         titlecolor = mpl.rcParams['axes.titlecolor']
178         if not cbook._str_lower_equal(titlecolor, 'auto'):
179             default["color"] = titlecolor
180         if pad is None:
181             pad = mpl.rcParams['axes.titlepad']
182         self._set_title_offset_trans(float(pad))
183         title.set_text(label)
184         title.update(default)
185         if fontdict is not None:
186             title.update(fontdict)
187         title._internal_update(kwargs)
188         return title
189 
190     def get_legend_handles_labels(self, legend_handler_map=None):
191         """
192         Return handles and labels for legend
193 
194         ``ax.legend()`` is equivalent to ::
195 
196           h, l = ax.get_legend_handles_labels()
197           ax.legend(h, l)
198         """
199         # pass through to legend.
200         handles, labels = mlegend._get_legend_handles_labels(
201             [self], legend_handler_map)
202         return handles, labels
203 
204     @_docstring.dedent_interpd
205     def legend(self, *args, **kwargs):
206         """
207         Place a legend on the Axes.
208 
209         Call signatures::
210 
211             legend()
212             legend(handles, labels)
213             legend(handles=handles)
214             legend(labels)
215 
216         The call signatures correspond to the following different ways to use
217         this method:
218 
219         **1. Automatic detection of elements to be shown in the legend**
220 
221         The elements to be added to the legend are automatically determined,
222         when you do not pass in any extra arguments.
223 
224         In this case, the labels are taken from the artist. You can specify
225         them either at artist creation or by calling the
226         :meth:`~.Artist.set_label` method on the artist::
227 
228             ax.plot([1, 2, 3], label='Inline label')
229             ax.legend()
230 
231         or::
232 
233             line, = ax.plot([1, 2, 3])
234             line.set_label('Label via method')
235             ax.legend()
236 
237         .. note::
238             Specific artists can be excluded from the automatic legend element
239             selection by using a label starting with an underscore, "_".
240             A string starting with an underscore is the default label for all
241             artists, so calling `.Axes.legend` without any arguments and
242             without setting the labels manually will result in no legend being
243             drawn.
244 
245 
246         **2. Explicitly listing the artists and labels in the legend**
247 
248         For full control of which artists have a legend entry, it is possible
249         to pass an iterable of legend artists followed by an iterable of
250         legend labels respectively::
251 
252             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
253 
254 
255         **3. Explicitly listing the artists in the legend**
256 
257         This is similar to 2, but the labels are taken from the artists'
258         label properties. Example::
259 
260             line1, = ax.plot([1, 2, 3], label='label1')
261             line2, = ax.plot([1, 2, 3], label='label2')
262             ax.legend(handles=[line1, line2])
263 
264 
265         **4. Labeling existing plot elements**
266 
267         .. admonition:: Discouraged
268 
269             This call signature is discouraged, because the relation between
270             plot elements and labels is only implicit by their order and can
271             easily be mixed up.
272 
273         To make a legend for all artists on an Axes, call this function with
274         an iterable of strings, one for each legend item. For example::
275 
276             ax.plot([1, 2, 3])
277             ax.plot([5, 6, 7])
278             ax.legend(['First line', 'Second line'])
279 
280 
281         Parameters
282         ----------
283         handles : sequence of `.Artist`, optional
284             A list of Artists (lines, patches) to be added to the legend.
285             Use this together with *labels*, if you need full control on what
286             is shown in the legend and the automatic mechanism described above
287             is not sufficient.
288 
289             The length of handles and labels should be the same in this
290             case. If they are not, they are truncated to the smaller length.
291 
292         labels : list of str, optional
293             A list of labels to show next to the artists.
294             Use this together with *handles*, if you need full control on what
295             is shown in the legend and the automatic mechanism described above
296             is not sufficient.
297 
298         Returns
299         -------
300         `~matplotlib.legend.Legend`
301 
302         Other Parameters
303         ----------------
304         %(_legend_kw_axes)s
305 
306         See Also
307         --------
308         .Figure.legend
309 
310         Notes
311         -----
312         Some artists are not supported by this function.  See
313         :ref:`legend_guide` for details.
314 
315         Examples
316         --------
317         .. plot:: gallery/text_labels_and_annotations/legend.py
318         """
319         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
320                 [self],
321                 *args,
322                 **kwargs)
323         if len(extra_args):
324             raise _api.nargs_error('legend', '0-2', len(args))
325         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
326         self.legend_._remove_method = self._remove_legend
327         return self.legend_
328 
329     def _remove_legend(self, legend):
330         self.legend_ = None
331 
332     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
333         """
334         Add a child inset Axes to this existing Axes.
335 
336         Warnings
337         --------
338         This method is experimental as of 3.0, and the API may change.
339 
340         Parameters
341         ----------
342         bounds : [x0, y0, width, height]
343             Lower-left corner of inset Axes, and its width and height.
344 
345         transform : `.Transform`
346             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
347             Axes-relative coordinates.
348 
349         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
350 'polar', 'rectilinear', str}, optional
351             The projection type of the inset `~.axes.Axes`. *str* is the name
352             of a custom projection, see `~matplotlib.projections`. The default
353             None results in a 'rectilinear' projection.
354 
355         polar : bool, default: False
356             If True, equivalent to projection='polar'.
357 
358         axes_class : subclass type of `~.axes.Axes`, optional
359             The `.axes.Axes` subclass that is instantiated.  This parameter
360             is incompatible with *projection* and *polar*.  See
361             :ref:`axisartist_users-guide-index` for examples.
362 
363         zorder : number
364             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
365             to change whether it is above or below data plotted on the
366             parent Axes.
367 
368         **kwargs
369             Other keyword arguments are passed on to the inset Axes class.
370 
371         Returns
372         -------
373         ax
374             The created `~.axes.Axes` instance.
375 
376         Examples
377         --------
378         This example makes two inset Axes, the first is in Axes-relative
379         coordinates, and the second in data-coordinates::
380 
381             fig, ax = plt.subplots()
382             ax.plot(range(10))
383             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
384             axin2 = ax.inset_axes(
385                     [5, 7, 2.3, 2.3], transform=ax.transData)
386 
387         """
388         if transform is None:
389             transform = self.transAxes
390         kwargs.setdefault('label', 'inset_axes')
391 
392         # This puts the rectangle into figure-relative coordinates.
393         inset_locator = _TransformedBoundsLocator(bounds, transform)
394         bounds = inset_locator(self, None).bounds
395         projection_class, pkw = self.figure._process_projection_requirements(**kwargs)
396         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
397 
398         # this locator lets the axes move if in data coordinates.
399         # it gets called in `ax.apply_aspect() (of all places)
400         inset_ax.set_axes_locator(inset_locator)
401 
402         self.add_child_axes(inset_ax)
403 
404         return inset_ax
405 
406     @_docstring.dedent_interpd
407     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
408                        facecolor='none', edgecolor='0.5', alpha=0.5,
409                        zorder=4.99, **kwargs):
410         """
411         Add an inset indicator to the Axes.  This is a rectangle on the plot
412         at the position indicated by *bounds* that optionally has lines that
413         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
414 
415         Warnings
416         --------
417         This method is experimental as of 3.0, and the API may change.
418 
419         Parameters
420         ----------
421         bounds : [x0, y0, width, height]
422             Lower-left corner of rectangle to be marked, and its width
423             and height.
424 
425         inset_ax : `.Axes`
426             An optional inset Axes to draw connecting lines to.  Two lines are
427             drawn connecting the indicator box to the inset Axes on corners
428             chosen so as to not overlap with the indicator box.
429 
430         transform : `.Transform`
431             Transform for the rectangle coordinates. Defaults to
432             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
433             coordinates.
434 
435         facecolor : color, default: 'none'
436             Facecolor of the rectangle.
437 
438         edgecolor : color, default: '0.5'
439             Color of the rectangle and color of the connecting lines.
440 
441         alpha : float, default: 0.5
442             Transparency of the rectangle and connector lines.
443 
444         zorder : float, default: 4.99
445             Drawing order of the rectangle and connector lines.  The default,
446             4.99, is just below the default level of inset Axes.
447 
448         **kwargs
449             Other keyword arguments are passed on to the `.Rectangle` patch:
450 
451             %(Rectangle:kwdoc)s
452 
453         Returns
454         -------
455         rectangle_patch : `.patches.Rectangle`
456              The indicator frame.
457 
458         connector_lines : 4-tuple of `.patches.ConnectionPatch`
459             The four connector lines connecting to (lower_left, upper_left,
460             lower_right upper_right) corners of *inset_ax*. Two lines are
461             set with visibility to *False*,  but the user can set the
462             visibility to True if the automatic choice is not deemed correct.
463 
464         """
465         # to make the axes connectors work, we need to apply the aspect to
466         # the parent axes.
467         self.apply_aspect()
468 
469         if transform is None:
470             transform = self.transData
471         kwargs.setdefault('label', '_indicate_inset')
472 
473         x, y, width, height = bounds
474         rectangle_patch = mpatches.Rectangle(
475             (x, y), width, height,
476             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
477             zorder=zorder, transform=transform, **kwargs)
478         self.add_patch(rectangle_patch)
479 
480         connects = []
481 
482         if inset_ax is not None:
483             # connect the inset_axes to the rectangle
484             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
485                 # inset_ax positions are in axes coordinates
486                 # The 0, 1 values define the four edges if the inset_ax
487                 # lower_left, upper_left, lower_right upper_right.
488                 ex, ey = xy_inset_ax
489                 if self.xaxis.get_inverted():
490                     ex = 1 - ex
491                 if self.yaxis.get_inverted():
492                     ey = 1 - ey
493                 xy_data = x + ex * width, y + ey * height
494                 p = mpatches.ConnectionPatch(
495                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
496                     xyB=xy_data, coordsB=self.transData,
497                     arrowstyle="-", zorder=zorder,
498                     edgecolor=edgecolor, alpha=alpha)
499                 connects.append(p)
500                 self.add_patch(p)
501 
502             # decide which two of the lines to keep visible....
503             pos = inset_ax.get_position()
504             bboxins = pos.transformed(self.figure.transSubfigure)
505             rectbbox = mtransforms.Bbox.from_bounds(
506                 *bounds
507             ).transformed(transform)
508             x0 = rectbbox.x0 < bboxins.x0
509             x1 = rectbbox.x1 < bboxins.x1
510             y0 = rectbbox.y0 < bboxins.y0
511             y1 = rectbbox.y1 < bboxins.y1
512             connects[0].set_visible(x0 ^ y0)
513             connects[1].set_visible(x0 == y1)
514             connects[2].set_visible(x1 == y0)
515             connects[3].set_visible(x1 ^ y1)
516 
517         return rectangle_patch, tuple(connects) if connects else None
518 
519     def indicate_inset_zoom(self, inset_ax, **kwargs):
520         """
521         Add an inset indicator rectangle to the Axes based on the axis
522         limits for an *inset_ax* and draw connectors between *inset_ax*
523         and the rectangle.
524 
525         Warnings
526         --------
527         This method is experimental as of 3.0, and the API may change.
528 
529         Parameters
530         ----------
531         inset_ax : `.Axes`
532             Inset Axes to draw connecting lines to.  Two lines are
533             drawn connecting the indicator box to the inset Axes on corners
534             chosen so as to not overlap with the indicator box.
535 
536         **kwargs
537             Other keyword arguments are passed on to `.Axes.indicate_inset`
538 
539         Returns
540         -------
541         rectangle_patch : `.patches.Rectangle`
542              Rectangle artist.
543 
544         connector_lines : 4-tuple of `.patches.ConnectionPatch`
545             Each of four connector lines coming from the rectangle drawn on
546             this axis, in the order lower left, upper left, lower right,
547             upper right.
548             Two are set with visibility to *False*,  but the user can
549             set the visibility to *True* if the automatic choice is not deemed
550             correct.
551         """
552 
553         xlim = inset_ax.get_xlim()
554         ylim = inset_ax.get_ylim()
555         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
556         return self.indicate_inset(rect, inset_ax, **kwargs)
557 
558     @_docstring.dedent_interpd
559     def secondary_xaxis(self, location, *, functions=None, **kwargs):
560         """
561         Add a second x-axis to this `~.axes.Axes`.
562 
563         For example if we want to have a second scale for the data plotted on
564         the xaxis.
565 
566         %(_secax_docstring)s
567 
568         Examples
569         --------
570         The main axis shows frequency, and the secondary axis shows period.
571 
572         .. plot::
573 
574             fig, ax = plt.subplots()
575             ax.loglog(range(1, 360, 5), range(1, 360, 5))
576             ax.set_xlabel('frequency [Hz]')
577 
578             def invert(x):
579                 # 1/x with special treatment of x == 0
580                 x = np.array(x).astype(float)
581                 near_zero = np.isclose(x, 0)
582                 x[near_zero] = np.inf
583                 x[~near_zero] = 1 / x[~near_zero]
584                 return x
585 
586             # the inverse of 1/x is itself
587             secax = ax.secondary_xaxis('top', functions=(invert, invert))
588             secax.set_xlabel('Period [s]')
589             plt.show()
590         """
591         if location in ['top', 'bottom'] or isinstance(location, Real):
592             secondary_ax = SecondaryAxis(self, 'x', location, functions,
593                                          **kwargs)
594             self.add_child_axes(secondary_ax)
595             return secondary_ax
596         else:
597             raise ValueError('secondary_xaxis location must be either '
598                              'a float or "top"/"bottom"')
599 
600     @_docstring.dedent_interpd
601     def secondary_yaxis(self, location, *, functions=None, **kwargs):
602         """
603         Add a second y-axis to this `~.axes.Axes`.
604 
605         For example if we want to have a second scale for the data plotted on
606         the yaxis.
607 
608         %(_secax_docstring)s
609 
610         Examples
611         --------
612         Add a secondary Axes that converts from radians to degrees
613 
614         .. plot::
615 
616             fig, ax = plt.subplots()
617             ax.plot(range(1, 360, 5), range(1, 360, 5))
618             ax.set_ylabel('degrees')
619             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
620                                                            np.rad2deg))
621             secax.set_ylabel('radians')
622         """
623         if location in ['left', 'right'] or isinstance(location, Real):
624             secondary_ax = SecondaryAxis(self, 'y', location,
625                                          functions, **kwargs)
626             self.add_child_axes(secondary_ax)
627             return secondary_ax
628         else:
629             raise ValueError('secondary_yaxis location must be either '
630                              'a float or "left"/"right"')
631 
632     @_docstring.dedent_interpd
633     def text(self, x, y, s, fontdict=None, **kwargs):
634         """
635         Add text to the Axes.
636 
637         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
638 
639         Parameters
640         ----------
641         x, y : float
642             The position to place the text. By default, this is in data
643             coordinates. The coordinate system can be changed using the
644             *transform* parameter.
645 
646         s : str
647             The text.
648 
649         fontdict : dict, default: None
650 
651             .. admonition:: Discouraged
652 
653                The use of *fontdict* is discouraged. Parameters should be passed as
654                individual keyword arguments or using dictionary-unpacking
655                ``text(..., **fontdict)``.
656 
657             A dictionary to override the default text properties. If fontdict
658             is None, the defaults are determined by `.rcParams`.
659 
660         Returns
661         -------
662         `.Text`
663             The created `.Text` instance.
664 
665         Other Parameters
666         ----------------
667         **kwargs : `~matplotlib.text.Text` properties.
668             Other miscellaneous text parameters.
669 
670             %(Text:kwdoc)s
671 
672         Examples
673         --------
674         Individual keyword arguments can be used to override any given
675         parameter::
676 
677             >>> text(x, y, s, fontsize=12)
678 
679         The default transform specifies that text is in data coords,
680         alternatively, you can specify text in axis coords ((0, 0) is
681         lower-left and (1, 1) is upper-right).  The example below places
682         text in the center of the Axes::
683 
684             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
685             ...      verticalalignment='center', transform=ax.transAxes)
686 
687         You can put a rectangular box around the text instance (e.g., to
688         set a background color) by using the keyword *bbox*.  *bbox* is
689         a dictionary of `~matplotlib.patches.Rectangle`
690         properties.  For example::
691 
692             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
693         """
694         effective_kwargs = {
695             'verticalalignment': 'baseline',
696             'horizontalalignment': 'left',
697             'transform': self.transData,
698             'clip_on': False,
699             **(fontdict if fontdict is not None else {}),
700             **kwargs,
701         }
702         t = mtext.Text(x, y, text=s, **effective_kwargs)
703         if t.get_clip_path() is None:
704             t.set_clip_path(self.patch)
705         self._add_text(t)
706         return t
707 
708     @_docstring.dedent_interpd
709     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
710                  arrowprops=None, annotation_clip=None, **kwargs):
711         # Signature must match Annotation. This is verified in
712         # test_annotate_signature().
713         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
714                              textcoords=textcoords, arrowprops=arrowprops,
715                              annotation_clip=annotation_clip, **kwargs)
716         a.set_transform(mtransforms.IdentityTransform())
717         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
718             a.set_clip_path(self.patch)
719         self._add_text(a)
720         return a
721     annotate.__doc__ = mtext.Annotation.__init__.__doc__
722     #### Lines and spans
723 
724     @_docstring.dedent_interpd
725     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
726         """
727         Add a horizontal line across the Axes.
728 
729         Parameters
730         ----------
731         y : float, default: 0
732             y position in data coordinates of the horizontal line.
733 
734         xmin : float, default: 0
735             Should be between 0 and 1, 0 being the far left of the plot, 1 the
736             far right of the plot.
737 
738         xmax : float, default: 1
739             Should be between 0 and 1, 0 being the far left of the plot, 1 the
740             far right of the plot.
741 
742         Returns
743         -------
744         `~matplotlib.lines.Line2D`
745 
746         Other Parameters
747         ----------------
748         **kwargs
749             Valid keyword arguments are `.Line2D` properties, except for
750             'transform':
751 
752             %(Line2D:kwdoc)s
753 
754         See Also
755         --------
756         hlines : Add horizontal lines in data coordinates.
757         axhspan : Add a horizontal span (rectangle) across the axis.
758         axline : Add a line with an arbitrary slope.
759 
760         Examples
761         --------
762         * draw a thick red hline at 'y' = 0 that spans the xrange::
763 
764             >>> axhline(linewidth=4, color='r')
765 
766         * draw a default hline at 'y' = 1 that spans the xrange::
767 
768             >>> axhline(y=1)
769 
770         * draw a default hline at 'y' = .5 that spans the middle half of
771           the xrange::
772 
773             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
774         """
775         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
776         if "transform" in kwargs:
777             raise ValueError("'transform' is not allowed as a keyword "
778                              "argument; axhline generates its own transform.")
779         ymin, ymax = self.get_ybound()
780 
781         # Strip away the units for comparison with non-unitized bounds.
782         yy, = self._process_unit_info([("y", y)], kwargs)
783         scaley = (yy < ymin) or (yy > ymax)
784 
785         trans = self.get_yaxis_transform(which='grid')
786         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
787         self.add_line(l)
788         if scaley:
789             self._request_autoscale_view("y")
790         return l
791 
792     @_docstring.dedent_interpd
793     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
794         """
795         Add a vertical line across the Axes.
796 
797         Parameters
798         ----------
799         x : float, default: 0
800             x position in data coordinates of the vertical line.
801 
802         ymin : float, default: 0
803             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
804             top of the plot.
805 
806         ymax : float, default: 1
807             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
808             top of the plot.
809 
810         Returns
811         -------
812         `~matplotlib.lines.Line2D`
813 
814         Other Parameters
815         ----------------
816         **kwargs
817             Valid keyword arguments are `.Line2D` properties, except for
818             'transform':
819 
820             %(Line2D:kwdoc)s
821 
822         See Also
823         --------
824         vlines : Add vertical lines in data coordinates.
825         axvspan : Add a vertical span (rectangle) across the axis.
826         axline : Add a line with an arbitrary slope.
827 
828         Examples
829         --------
830         * draw a thick red vline at *x* = 0 that spans the yrange::
831 
832             >>> axvline(linewidth=4, color='r')
833 
834         * draw a default vline at *x* = 1 that spans the yrange::
835 
836             >>> axvline(x=1)
837 
838         * draw a default vline at *x* = .5 that spans the middle half of
839           the yrange::
840 
841             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
842         """
843         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
844         if "transform" in kwargs:
845             raise ValueError("'transform' is not allowed as a keyword "
846                              "argument; axvline generates its own transform.")
847         xmin, xmax = self.get_xbound()
848 
849         # Strip away the units for comparison with non-unitized bounds.
850         xx, = self._process_unit_info([("x", x)], kwargs)
851         scalex = (xx < xmin) or (xx > xmax)
852 
853         trans = self.get_xaxis_transform(which='grid')
854         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
855         self.add_line(l)
856         if scalex:
857             self._request_autoscale_view("x")
858         return l
859 
860     @staticmethod
861     def _check_no_units(vals, names):
862         # Helper method to check that vals are not unitized
863         for val, name in zip(vals, names):
864             if not munits._is_natively_supported(val):
865                 raise ValueError(f"{name} must be a single scalar value, "
866                                  f"but got {val}")
867 
868     @_docstring.dedent_interpd
869     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
870         """
871         Add an infinitely long straight line.
872 
873         The line can be defined either by two points *xy1* and *xy2*, or
874         by one point *xy1* and a *slope*.
875 
876         This draws a straight line "on the screen", regardless of the x and y
877         scales, and is thus also suitable for drawing exponential decays in
878         semilog plots, power laws in loglog plots, etc. However, *slope*
879         should only be used with linear scales; It has no clear meaning for
880         all other scales, and thus the behavior is undefined. Please specify
881         the line using the points *xy1*, *xy2* for non-linear scales.
882 
883         The *transform* keyword argument only applies to the points *xy1*,
884         *xy2*. The *slope* (if given) is always in data coordinates. This can
885         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
886         slope.
887 
888         Parameters
889         ----------
890         xy1, xy2 : (float, float)
891             Points for the line to pass through.
892             Either *xy2* or *slope* has to be given.
893         slope : float, optional
894             The slope of the line. Either *xy2* or *slope* has to be given.
895 
896         Returns
897         -------
898         `.Line2D`
899 
900         Other Parameters
901         ----------------
902         **kwargs
903             Valid kwargs are `.Line2D` properties
904 
905             %(Line2D:kwdoc)s
906 
907         See Also
908         --------
909         axhline : for horizontal lines
910         axvline : for vertical lines
911 
912         Examples
913         --------
914         Draw a thick red line passing through (0, 0) and (1, 1)::
915 
916             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
917         """
918         if slope is not None and (self.get_xscale() != 'linear' or
919                                   self.get_yscale() != 'linear'):
920             raise TypeError("'slope' cannot be used with non-linear scales")
921 
922         datalim = [xy1] if xy2 is None else [xy1, xy2]
923         if "transform" in kwargs:
924             # if a transform is passed (i.e. line points not in data space),
925             # data limits should not be adjusted.
926             datalim = []
927 
928         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
929         # Like add_line, but correctly handling data limits.
930         self._set_artist_props(line)
931         if line.get_clip_path() is None:
932             line.set_clip_path(self.patch)
933         if not line.get_label():
934             line.set_label(f"_child{len(self._children)}")
935         self._children.append(line)
936         line._remove_method = self._children.remove
937         self.update_datalim(datalim)
938 
939         self._request_autoscale_view()
940         return line
941 
942     @_docstring.dedent_interpd
943     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
944         """
945         Add a horizontal span (rectangle) across the Axes.
946 
947         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
948         the whole x-axis horizontally.  The x-span can be set using *xmin*
949         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
950         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
951         the limits set by `~.Axes.set_xlim`.
952 
953         Parameters
954         ----------
955         ymin : float
956             Lower y-coordinate of the span, in data units.
957         ymax : float
958             Upper y-coordinate of the span, in data units.
959         xmin : float, default: 0
960             Lower x-coordinate of the span, in x-axis (0-1) units.
961         xmax : float, default: 1
962             Upper x-coordinate of the span, in x-axis (0-1) units.
963 
964         Returns
965         -------
966         `~matplotlib.patches.Polygon`
967             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
968 
969         Other Parameters
970         ----------------
971         **kwargs : `~matplotlib.patches.Polygon` properties
972 
973         %(Polygon:kwdoc)s
974 
975         See Also
976         --------
977         axvspan : Add a vertical span across the Axes.
978         """
979         # Strip units away.
980         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
981         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
982 
983         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
984         p = mpatches.Polygon(verts, **kwargs)
985         p.set_transform(self.get_yaxis_transform(which="grid"))
986         self.add_patch(p)
987         self._request_autoscale_view("y")
988         return p
989 
990     @_docstring.dedent_interpd
991     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
992         """
993         Add a vertical span (rectangle) across the Axes.
994 
995         The rectangle spans from *xmin* to *xmax* horizontally, and, by
996         default, the whole y-axis vertically.  The y-span can be set using
997         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
998         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
999         regardless of the limits set by `~.Axes.set_ylim`.
1000 
1001         Parameters
1002         ----------
1003         xmin : float
1004             Lower x-coordinate of the span, in data units.
1005         xmax : float
1006             Upper x-coordinate of the span, in data units.
1007         ymin : float, default: 0
1008             Lower y-coordinate of the span, in y-axis units (0-1).
1009         ymax : float, default: 1
1010             Upper y-coordinate of the span, in y-axis units (0-1).
1011 
1012         Returns
1013         -------
1014         `~matplotlib.patches.Polygon`
1015             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1016 
1017         Other Parameters
1018         ----------------
1019         **kwargs : `~matplotlib.patches.Polygon` properties
1020 
1021         %(Polygon:kwdoc)s
1022 
1023         See Also
1024         --------
1025         axhspan : Add a horizontal span across the Axes.
1026 
1027         Examples
1028         --------
1029         Draw a vertical, green, translucent rectangle from x = 1.25 to
1030         x = 1.55 that spans the yrange of the Axes.
1031 
1032         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1033 
1034         """
1035         # Strip units away.
1036         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1037         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1038 
1039         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1040         p = mpatches.Polygon(verts, **kwargs)
1041         p.set_transform(self.get_xaxis_transform(which="grid"))
1042         p.get_path()._interpolation_steps = 100
1043         self.add_patch(p)
1044         self._request_autoscale_view("x")
1045         return p
1046 
1047     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1048                       label_namer="y")
1049     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1050                label='', **kwargs):
1051         """
1052         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1053 
1054         Parameters
1055         ----------
1056         y : float or array-like
1057             y-indexes where to plot the lines.
1058 
1059         xmin, xmax : float or array-like
1060             Respective beginning and end of each line. If scalars are
1061             provided, all lines will have the same length.
1062 
1063         colors : color or list of colors, default: :rc:`lines.color`
1064 
1065         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1066 
1067         label : str, default: ''
1068 
1069         Returns
1070         -------
1071         `~matplotlib.collections.LineCollection`
1072 
1073         Other Parameters
1074         ----------------
1075         data : indexable object, optional
1076             DATA_PARAMETER_PLACEHOLDER
1077         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1078 
1079         See Also
1080         --------
1081         vlines : vertical lines
1082         axhline : horizontal line across the Axes
1083         """
1084 
1085         # We do the conversion first since not all unitized data is uniform
1086         xmin, xmax, y = self._process_unit_info(
1087             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1088 
1089         if not np.iterable(y):
1090             y = [y]
1091         if not np.iterable(xmin):
1092             xmin = [xmin]
1093         if not np.iterable(xmax):
1094             xmax = [xmax]
1095 
1096         # Create and combine masked_arrays from input
1097         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1098         y = np.ravel(y)
1099         xmin = np.ravel(xmin)
1100         xmax = np.ravel(xmax)
1101 
1102         masked_verts = np.ma.empty((len(y), 2, 2))
1103         masked_verts[:, 0, 0] = xmin
1104         masked_verts[:, 0, 1] = y
1105         masked_verts[:, 1, 0] = xmax
1106         masked_verts[:, 1, 1] = y
1107 
1108         lines = mcoll.LineCollection(masked_verts, colors=colors,
1109                                      linestyles=linestyles, label=label)
1110         self.add_collection(lines, autolim=False)
1111         lines._internal_update(kwargs)
1112 
1113         if len(y) > 0:
1114             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1115             # the case of y being a masked *object* array (as can be generated
1116             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1117             updatex = True
1118             updatey = True
1119             if self.name == "rectilinear":
1120                 datalim = lines.get_datalim(self.transData)
1121                 t = lines.get_transform()
1122                 updatex, updatey = t.contains_branch_seperately(self.transData)
1123                 minx = np.nanmin(datalim.xmin)
1124                 maxx = np.nanmax(datalim.xmax)
1125                 miny = np.nanmin(datalim.ymin)
1126                 maxy = np.nanmax(datalim.ymax)
1127             else:
1128                 minx = np.nanmin(masked_verts[..., 0])
1129                 maxx = np.nanmax(masked_verts[..., 0])
1130                 miny = np.nanmin(masked_verts[..., 1])
1131                 maxy = np.nanmax(masked_verts[..., 1])
1132 
1133             corners = (minx, miny), (maxx, maxy)
1134             self.update_datalim(corners, updatex, updatey)
1135             self._request_autoscale_view()
1136         return lines
1137 
1138     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1139                       label_namer="x")
1140     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1141                label='', **kwargs):
1142         """
1143         Plot vertical lines at each *x* from *ymin* to *ymax*.
1144 
1145         Parameters
1146         ----------
1147         x : float or array-like
1148             x-indexes where to plot the lines.
1149 
1150         ymin, ymax : float or array-like
1151             Respective beginning and end of each line. If scalars are
1152             provided, all lines will have the same length.
1153 
1154         colors : color or list of colors, default: :rc:`lines.color`
1155 
1156         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, default: 'solid'
1157 
1158         label : str, default: ''
1159 
1160         Returns
1161         -------
1162         `~matplotlib.collections.LineCollection`
1163 
1164         Other Parameters
1165         ----------------
1166         data : indexable object, optional
1167             DATA_PARAMETER_PLACEHOLDER
1168         **kwargs : `~matplotlib.collections.LineCollection` properties.
1169 
1170         See Also
1171         --------
1172         hlines : horizontal lines
1173         axvline : vertical line across the Axes
1174         """
1175 
1176         # We do the conversion first since not all unitized data is uniform
1177         x, ymin, ymax = self._process_unit_info(
1178             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1179 
1180         if not np.iterable(x):
1181             x = [x]
1182         if not np.iterable(ymin):
1183             ymin = [ymin]
1184         if not np.iterable(ymax):
1185             ymax = [ymax]
1186 
1187         # Create and combine masked_arrays from input
1188         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1189         x = np.ravel(x)
1190         ymin = np.ravel(ymin)
1191         ymax = np.ravel(ymax)
1192 
1193         masked_verts = np.ma.empty((len(x), 2, 2))
1194         masked_verts[:, 0, 0] = x
1195         masked_verts[:, 0, 1] = ymin
1196         masked_verts[:, 1, 0] = x
1197         masked_verts[:, 1, 1] = ymax
1198 
1199         lines = mcoll.LineCollection(masked_verts, colors=colors,
1200                                      linestyles=linestyles, label=label)
1201         self.add_collection(lines, autolim=False)
1202         lines._internal_update(kwargs)
1203 
1204         if len(x) > 0:
1205             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1206             # the case of x being a masked *object* array (as can be generated
1207             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1208             updatex = True
1209             updatey = True
1210             if self.name == "rectilinear":
1211                 datalim = lines.get_datalim(self.transData)
1212                 t = lines.get_transform()
1213                 updatex, updatey = t.contains_branch_seperately(self.transData)
1214                 minx = np.nanmin(datalim.xmin)
1215                 maxx = np.nanmax(datalim.xmax)
1216                 miny = np.nanmin(datalim.ymin)
1217                 maxy = np.nanmax(datalim.ymax)
1218             else:
1219                 minx = np.nanmin(masked_verts[..., 0])
1220                 maxx = np.nanmax(masked_verts[..., 0])
1221                 miny = np.nanmin(masked_verts[..., 1])
1222                 maxy = np.nanmax(masked_verts[..., 1])
1223 
1224             corners = (minx, miny), (maxx, maxy)
1225             self.update_datalim(corners, updatex, updatey)
1226             self._request_autoscale_view()
1227         return lines
1228 
1229     @_preprocess_data(replace_names=["positions", "lineoffsets",
1230                                      "linelengths", "linewidths",
1231                                      "colors", "linestyles"])
1232     @_docstring.dedent_interpd
1233     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1234                   linelengths=1, linewidths=None, colors=None, alpha=None,
1235                   linestyles='solid', **kwargs):
1236         """
1237         Plot identical parallel lines at the given positions.
1238 
1239         This type of plot is commonly used in neuroscience for representing
1240         neural events, where it is usually called a spike raster, dot raster,
1241         or raster plot.
1242 
1243         However, it is useful in any situation where you wish to show the
1244         timing or position of multiple sets of discrete events, such as the
1245         arrival times of people to a business on each day of the month or the
1246         date of hurricanes each year of the last century.
1247 
1248         Parameters
1249         ----------
1250         positions : array-like or list of array-like
1251             A 1D array-like defines the positions of one sequence of events.
1252 
1253             Multiple groups of events may be passed as a list of array-likes.
1254             Each group can be styled independently by passing lists of values
1255             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1256             *linestyles*.
1257 
1258             Note that *positions* can be a 2D array, but in practice different
1259             event groups usually have different counts so that one will use a
1260             list of different-length arrays rather than a 2D array.
1261 
1262         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1263             The direction of the event sequence:
1264 
1265             - 'horizontal': the events are arranged horizontally.
1266               The indicator lines are vertical.
1267             - 'vertical': the events are arranged vertically.
1268               The indicator lines are horizontal.
1269 
1270         lineoffsets : float or array-like, default: 1
1271             The offset of the center of the lines from the origin, in the
1272             direction orthogonal to *orientation*.
1273 
1274             If *positions* is 2D, this can be a sequence with length matching
1275             the length of *positions*.
1276 
1277         linelengths : float or array-like, default: 1
1278             The total height of the lines (i.e. the lines stretches from
1279             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1280 
1281             If *positions* is 2D, this can be a sequence with length matching
1282             the length of *positions*.
1283 
1284         linewidths : float or array-like, default: :rc:`lines.linewidth`
1285             The line width(s) of the event lines, in points.
1286 
1287             If *positions* is 2D, this can be a sequence with length matching
1288             the length of *positions*.
1289 
1290         colors : color or list of colors, default: :rc:`lines.color`
1291             The color(s) of the event lines.
1292 
1293             If *positions* is 2D, this can be a sequence with length matching
1294             the length of *positions*.
1295 
1296         alpha : float or array-like, default: 1
1297             The alpha blending value(s), between 0 (transparent) and 1
1298             (opaque).
1299 
1300             If *positions* is 2D, this can be a sequence with length matching
1301             the length of *positions*.
1302 
1303         linestyles : str or tuple or list of such values, default: 'solid'
1304             Default is 'solid'. Valid strings are ['solid', 'dashed',
1305             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1306             should be of the form::
1307 
1308                 (offset, onoffseq),
1309 
1310             where *onoffseq* is an even length tuple of on and off ink
1311             in points.
1312 
1313             If *positions* is 2D, this can be a sequence with length matching
1314             the length of *positions*.
1315 
1316         data : indexable object, optional
1317             DATA_PARAMETER_PLACEHOLDER
1318 
1319         **kwargs
1320             Other keyword arguments are line collection properties.  See
1321             `.LineCollection` for a list of the valid properties.
1322 
1323         Returns
1324         -------
1325         list of `.EventCollection`
1326             The `.EventCollection` that were added.
1327 
1328         Notes
1329         -----
1330         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1331         only a single value is given, that value is applied to all lines. If an
1332         array-like is given, it must have the same length as *positions*, and
1333         each value will be applied to the corresponding row of the array.
1334 
1335         Examples
1336         --------
1337         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1338         """
1339 
1340         lineoffsets, linelengths = self._process_unit_info(
1341                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1342 
1343         # fix positions, noting that it can be a list of lists:
1344         if not np.iterable(positions):
1345             positions = [positions]
1346         elif any(np.iterable(position) for position in positions):
1347             positions = [np.asanyarray(position) for position in positions]
1348         else:
1349             positions = [np.asanyarray(positions)]
1350 
1351         poss = []
1352         for position in positions:
1353             poss += self._process_unit_info([("x", position)], kwargs)
1354         positions = poss
1355 
1356         # prevent 'singular' keys from **kwargs dict from overriding the effect
1357         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1358         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1359         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1360         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1361 
1362         if not np.iterable(lineoffsets):
1363             lineoffsets = [lineoffsets]
1364         if not np.iterable(linelengths):
1365             linelengths = [linelengths]
1366         if not np.iterable(linewidths):
1367             linewidths = [linewidths]
1368         if not np.iterable(colors):
1369             colors = [colors]
1370         if not np.iterable(alpha):
1371             alpha = [alpha]
1372         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1373             linestyles = [linestyles]
1374 
1375         lineoffsets = np.asarray(lineoffsets)
1376         linelengths = np.asarray(linelengths)
1377         linewidths = np.asarray(linewidths)
1378 
1379         if len(lineoffsets) == 0:
1380             raise ValueError('lineoffsets cannot be empty')
1381         if len(linelengths) == 0:
1382             raise ValueError('linelengths cannot be empty')
1383         if len(linestyles) == 0:
1384             raise ValueError('linestyles cannot be empty')
1385         if len(linewidths) == 0:
1386             raise ValueError('linewidths cannot be empty')
1387         if len(alpha) == 0:
1388             raise ValueError('alpha cannot be empty')
1389         if len(colors) == 0:
1390             colors = [None]
1391         try:
1392             # Early conversion of the colors into RGBA values to take care
1393             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1394             colors = mcolors.to_rgba_array(colors)
1395         except ValueError:
1396             # Will fail if any element of *colors* is None. But as long
1397             # as len(colors) == 1 or len(positions), the rest of the
1398             # code should process *colors* properly.
1399             pass
1400 
1401         if len(lineoffsets) == 1 and len(positions) != 1:
1402             lineoffsets = np.tile(lineoffsets, len(positions))
1403             lineoffsets[0] = 0
1404             lineoffsets = np.cumsum(lineoffsets)
1405         if len(linelengths) == 1:
1406             linelengths = np.tile(linelengths, len(positions))
1407         if len(linewidths) == 1:
1408             linewidths = np.tile(linewidths, len(positions))
1409         if len(colors) == 1:
1410             colors = list(colors) * len(positions)
1411         if len(alpha) == 1:
1412             alpha = list(alpha) * len(positions)
1413         if len(linestyles) == 1:
1414             linestyles = [linestyles] * len(positions)
1415 
1416         if len(lineoffsets) != len(positions):
1417             raise ValueError('lineoffsets and positions are unequal sized '
1418                              'sequences')
1419         if len(linelengths) != len(positions):
1420             raise ValueError('linelengths and positions are unequal sized '
1421                              'sequences')
1422         if len(linewidths) != len(positions):
1423             raise ValueError('linewidths and positions are unequal sized '
1424                              'sequences')
1425         if len(colors) != len(positions):
1426             raise ValueError('colors and positions are unequal sized '
1427                              'sequences')
1428         if len(alpha) != len(positions):
1429             raise ValueError('alpha and positions are unequal sized '
1430                              'sequences')
1431         if len(linestyles) != len(positions):
1432             raise ValueError('linestyles and positions are unequal sized '
1433                              'sequences')
1434 
1435         colls = []
1436         for position, lineoffset, linelength, linewidth, color, alpha_, \
1437             linestyle in \
1438                 zip(positions, lineoffsets, linelengths, linewidths,
1439                     colors, alpha, linestyles):
1440             coll = mcoll.EventCollection(position,
1441                                          orientation=orientation,
1442                                          lineoffset=lineoffset,
1443                                          linelength=linelength,
1444                                          linewidth=linewidth,
1445                                          color=color,
1446                                          alpha=alpha_,
1447                                          linestyle=linestyle)
1448             self.add_collection(coll, autolim=False)
1449             coll._internal_update(kwargs)
1450             colls.append(coll)
1451 
1452         if len(positions) > 0:
1453             # try to get min/max
1454             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1455                        if len(_p) > 0]
1456             # if we have any non-empty positions, try to autoscale
1457             if len(min_max) > 0:
1458                 mins, maxes = zip(*min_max)
1459                 minpos = np.min(mins)
1460                 maxpos = np.max(maxes)
1461 
1462                 minline = (lineoffsets - linelengths).min()
1463                 maxline = (lineoffsets + linelengths).max()
1464 
1465                 if orientation == "vertical":
1466                     corners = (minline, minpos), (maxline, maxpos)
1467                 else:  # "horizontal"
1468                     corners = (minpos, minline), (maxpos, maxline)
1469                 self.update_datalim(corners)
1470                 self._request_autoscale_view()
1471 
1472         return colls
1473 
1474     #### Basic plotting
1475 
1476     # Uses a custom implementation of data-kwarg handling in
1477     # _process_plot_var_args.
1478     @_docstring.dedent_interpd
1479     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1480         """
1481         Plot y versus x as lines and/or markers.
1482 
1483         Call signatures::
1484 
1485             plot([x], y, [fmt], *, data=None, **kwargs)
1486             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1487 
1488         The coordinates of the points or line nodes are given by *x*, *y*.
1489 
1490         The optional parameter *fmt* is a convenient way for defining basic
1491         formatting like color, marker and linestyle. It's a shortcut string
1492         notation described in the *Notes* section below.
1493 
1494         >>> plot(x, y)        # plot x and y using default line style and color
1495         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1496         >>> plot(y)           # plot y using x as index array 0..N-1
1497         >>> plot(y, 'r+')     # ditto, but with red plusses
1498 
1499         You can use `.Line2D` properties as keyword arguments for more
1500         control on the appearance. Line properties and *fmt* can be mixed.
1501         The following two calls yield identical results:
1502 
1503         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1504         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1505         ...      linewidth=2, markersize=12)
1506 
1507         When conflicting with *fmt*, keyword arguments take precedence.
1508 
1509 
1510         **Plotting labelled data**
1511 
1512         There's a convenient way for plotting objects with labelled data (i.e.
1513         data that can be accessed by index ``obj['y']``). Instead of giving
1514         the data in *x* and *y*, you can provide the object in the *data*
1515         parameter and just give the labels for *x* and *y*::
1516 
1517         >>> plot('xlabel', 'ylabel', data=obj)
1518 
1519         All indexable objects are supported. This could e.g. be a `dict`, a
1520         `pandas.DataFrame` or a structured numpy array.
1521 
1522 
1523         **Plotting multiple sets of data**
1524 
1525         There are various ways to plot multiple sets of data.
1526 
1527         - The most straight forward way is just to call `plot` multiple times.
1528           Example:
1529 
1530           >>> plot(x1, y1, 'bo')
1531           >>> plot(x2, y2, 'go')
1532 
1533         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1534           for every column. If both *x* and *y* are 2D, they must have the
1535           same shape. If only one of them is 2D with shape (N, m) the other
1536           must have length N and will be used for every data set m.
1537 
1538           Example:
1539 
1540           >>> x = [1, 2, 3]
1541           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1542           >>> plot(x, y)
1543 
1544           is equivalent to:
1545 
1546           >>> for col in range(y.shape[1]):
1547           ...     plot(x, y[:, col])
1548 
1549         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1550           groups::
1551 
1552           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1553 
1554           In this case, any additional keyword argument applies to all
1555           datasets. Also, this syntax cannot be combined with the *data*
1556           parameter.
1557 
1558         By default, each line is assigned a different style specified by a
1559         'style cycle'. The *fmt* and line property parameters are only
1560         necessary if you want explicit deviations from these defaults.
1561         Alternatively, you can also change the style cycle using
1562         :rc:`axes.prop_cycle`.
1563 
1564 
1565         Parameters
1566         ----------
1567         x, y : array-like or scalar
1568             The horizontal / vertical coordinates of the data points.
1569             *x* values are optional and default to ``range(len(y))``.
1570 
1571             Commonly, these parameters are 1D arrays.
1572 
1573             They can also be scalars, or two-dimensional (in that case, the
1574             columns represent separate data sets).
1575 
1576             These arguments cannot be passed as keywords.
1577 
1578         fmt : str, optional
1579             A format string, e.g. 'ro' for red circles. See the *Notes*
1580             section for a full description of the format strings.
1581 
1582             Format strings are just an abbreviation for quickly setting
1583             basic line properties. All of these and more can also be
1584             controlled by keyword arguments.
1585 
1586             This argument cannot be passed as keyword.
1587 
1588         data : indexable object, optional
1589             An object with labelled data. If given, provide the label names to
1590             plot in *x* and *y*.
1591 
1592             .. note::
1593                 Technically there's a slight ambiguity in calls where the
1594                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1595                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1596                 the former interpretation is chosen, but a warning is issued.
1597                 You may suppress the warning by adding an empty format string
1598                 ``plot('n', 'o', '', data=obj)``.
1599 
1600         Returns
1601         -------
1602         list of `.Line2D`
1603             A list of lines representing the plotted data.
1604 
1605         Other Parameters
1606         ----------------
1607         scalex, scaley : bool, default: True
1608             These parameters determine if the view limits are adapted to the
1609             data limits. The values are passed on to
1610             `~.axes.Axes.autoscale_view`.
1611 
1612         **kwargs : `.Line2D` properties, optional
1613             *kwargs* are used to specify properties like a line label (for
1614             auto legends), linewidth, antialiasing, marker face color.
1615             Example::
1616 
1617             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1618             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1619 
1620             If you specify multiple lines with one plot call, the kwargs apply
1621             to all those lines. In case the label object is iterable, each
1622             element is used as labels for each set of data.
1623 
1624             Here is a list of available `.Line2D` properties:
1625 
1626             %(Line2D:kwdoc)s
1627 
1628         See Also
1629         --------
1630         scatter : XY scatter plot with markers of varying size and/or color (
1631             sometimes also called bubble chart).
1632 
1633         Notes
1634         -----
1635         **Format Strings**
1636 
1637         A format string consists of a part for color, marker and line::
1638 
1639             fmt = '[marker][line][color]'
1640 
1641         Each of them is optional. If not provided, the value from the style
1642         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1643         the data will be a line without markers.
1644 
1645         Other combinations such as ``[color][marker][line]`` are also
1646         supported, but note that their parsing may be ambiguous.
1647 
1648         **Markers**
1649 
1650         =============   ===============================
1651         character       description
1652         =============   ===============================
1653         ``'.'``         point marker
1654         ``','``         pixel marker
1655         ``'o'``         circle marker
1656         ``'v'``         triangle_down marker
1657         ``'^'``         triangle_up marker
1658         ``'<'``         triangle_left marker
1659         ``'>'``         triangle_right marker
1660         ``'1'``         tri_down marker
1661         ``'2'``         tri_up marker
1662         ``'3'``         tri_left marker
1663         ``'4'``         tri_right marker
1664         ``'8'``         octagon marker
1665         ``'s'``         square marker
1666         ``'p'``         pentagon marker
1667         ``'P'``         plus (filled) marker
1668         ``'*'``         star marker
1669         ``'h'``         hexagon1 marker
1670         ``'H'``         hexagon2 marker
1671         ``'+'``         plus marker
1672         ``'x'``         x marker
1673         ``'X'``         x (filled) marker
1674         ``'D'``         diamond marker
1675         ``'d'``         thin_diamond marker
1676         ``'|'``         vline marker
1677         ``'_'``         hline marker
1678         =============   ===============================
1679 
1680         **Line Styles**
1681 
1682         =============    ===============================
1683         character        description
1684         =============    ===============================
1685         ``'-'``          solid line style
1686         ``'--'``         dashed line style
1687         ``'-.'``         dash-dot line style
1688         ``':'``          dotted line style
1689         =============    ===============================
1690 
1691         Example format strings::
1692 
1693             'b'    # blue markers with default shape
1694             'or'   # red circles
1695             '-g'   # green solid line
1696             '--'   # dashed line with default color
1697             '^k:'  # black triangle_up markers connected by a dotted line
1698 
1699         **Colors**
1700 
1701         The supported color abbreviations are the single letter codes
1702 
1703         =============    ===============================
1704         character        color
1705         =============    ===============================
1706         ``'b'``          blue
1707         ``'g'``          green
1708         ``'r'``          red
1709         ``'c'``          cyan
1710         ``'m'``          magenta
1711         ``'y'``          yellow
1712         ``'k'``          black
1713         ``'w'``          white
1714         =============    ===============================
1715 
1716         and the ``'CN'`` colors that index into the default property cycle.
1717 
1718         If the color is the only part of the format string, you can
1719         additionally use any  `matplotlib.colors` spec, e.g. full names
1720         (``'green'``) or hex strings (``'#008000'``).
1721         """
1722         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1723         lines = [*self._get_lines(*args, data=data, **kwargs)]
1724         for line in lines:
1725             self.add_line(line)
1726         if scalex:
1727             self._request_autoscale_view("x")
1728         if scaley:
1729             self._request_autoscale_view("y")
1730         return lines
1731 
1732     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1733     @_docstring.dedent_interpd
1734     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1735                   **kwargs):
1736         """
1737         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1738 
1739         .. admonition:: Discouraged
1740 
1741             This method exists for historic reasons and will be deprecated in
1742             the future.
1743 
1744             - ``datetime``-like data should directly be plotted using
1745               `~.Axes.plot`.
1746             -  If you need to plot plain numeric data as :ref:`date-format` or
1747                need to set a timezone, call ``ax.xaxis.axis_date`` /
1748                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1749                `.Axis.axis_date`.
1750 
1751         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1752         However, the axis labels are formatted as dates depending on *xdate*
1753         and *ydate*.  Note that `.plot` will work with `datetime` and
1754         `numpy.datetime64` objects without resorting to this method.
1755 
1756         Parameters
1757         ----------
1758         x, y : array-like
1759             The coordinates of the data points. If *xdate* or *ydate* is
1760             *True*, the respective values *x* or *y* are interpreted as
1761             :ref:`Matplotlib dates <date-format>`.
1762 
1763         fmt : str, optional
1764             The plot format string. For details, see the corresponding
1765             parameter in `.plot`.
1766 
1767         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1768             The time zone to use in labeling dates.
1769 
1770         xdate : bool, default: True
1771             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1772 
1773         ydate : bool, default: False
1774             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1775 
1776         Returns
1777         -------
1778         list of `.Line2D`
1779             Objects representing the plotted data.
1780 
1781         Other Parameters
1782         ----------------
1783         data : indexable object, optional
1784             DATA_PARAMETER_PLACEHOLDER
1785         **kwargs
1786             Keyword arguments control the `.Line2D` properties:
1787 
1788             %(Line2D:kwdoc)s
1789 
1790         See Also
1791         --------
1792         matplotlib.dates : Helper functions on dates.
1793         matplotlib.dates.date2num : Convert dates to num.
1794         matplotlib.dates.num2date : Convert num to dates.
1795         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1796 
1797         Notes
1798         -----
1799         If you are using custom date tickers and formatters, it may be
1800         necessary to set the formatters/locators after the call to
1801         `.plot_date`. `.plot_date` will set the default tick locator to
1802         `.AutoDateLocator` (if the tick locator is not already set to a
1803         `.DateLocator` instance) and the default tick formatter to
1804         `.AutoDateFormatter` (if the tick formatter is not already set to a
1805         `.DateFormatter` instance).
1806         """
1807         if xdate:
1808             self.xaxis_date(tz)
1809         if ydate:
1810             self.yaxis_date(tz)
1811         return self.plot(x, y, fmt, **kwargs)
1812 
1813     # @_preprocess_data() # let 'plot' do the unpacking..
1814     @_docstring.dedent_interpd
1815     def loglog(self, *args, **kwargs):
1816         """
1817         Make a plot with log scaling on both the x- and y-axis.
1818 
1819         Call signatures::
1820 
1821             loglog([x], y, [fmt], data=None, **kwargs)
1822             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1823 
1824         This is just a thin wrapper around `.plot` which additionally changes
1825         both the x-axis and the y-axis to log scaling. All the concepts and
1826         parameters of plot can be used here as well.
1827 
1828         The additional parameters *base*, *subs* and *nonpositive* control the
1829         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1830         `.Axes.set_yscale`. To use different properties on the x-axis and the
1831         y-axis, use e.g.
1832         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1833 
1834         Parameters
1835         ----------
1836         base : float, default: 10
1837             Base of the logarithm.
1838 
1839         subs : sequence, optional
1840             The location of the minor ticks. If *None*, reasonable locations
1841             are automatically chosen depending on the number of decades in the
1842             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1843 
1844         nonpositive : {'mask', 'clip'}, default: 'clip'
1845             Non-positive values can be masked as invalid, or clipped to a very
1846             small positive number.
1847 
1848         **kwargs
1849             All parameters supported by `.plot`.
1850 
1851         Returns
1852         -------
1853         list of `.Line2D`
1854             Objects representing the plotted data.
1855         """
1856         dx = {k: v for k, v in kwargs.items()
1857               if k in ['base', 'subs', 'nonpositive',
1858                        'basex', 'subsx', 'nonposx']}
1859         self.set_xscale('log', **dx)
1860         dy = {k: v for k, v in kwargs.items()
1861               if k in ['base', 'subs', 'nonpositive',
1862                        'basey', 'subsy', 'nonposy']}
1863         self.set_yscale('log', **dy)
1864         return self.plot(
1865             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1866 
1867     # @_preprocess_data() # let 'plot' do the unpacking..
1868     @_docstring.dedent_interpd
1869     def semilogx(self, *args, **kwargs):
1870         """
1871         Make a plot with log scaling on the x-axis.
1872 
1873         Call signatures::
1874 
1875             semilogx([x], y, [fmt], data=None, **kwargs)
1876             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1877 
1878         This is just a thin wrapper around `.plot` which additionally changes
1879         the x-axis to log scaling. All the concepts and parameters of plot can
1880         be used here as well.
1881 
1882         The additional parameters *base*, *subs*, and *nonpositive* control the
1883         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1884 
1885         Parameters
1886         ----------
1887         base : float, default: 10
1888             Base of the x logarithm.
1889 
1890         subs : array-like, optional
1891             The location of the minor xticks. If *None*, reasonable locations
1892             are automatically chosen depending on the number of decades in the
1893             plot. See `.Axes.set_xscale` for details.
1894 
1895         nonpositive : {'mask', 'clip'}, default: 'mask'
1896             Non-positive values in x can be masked as invalid, or clipped to a
1897             very small positive number.
1898 
1899         **kwargs
1900             All parameters supported by `.plot`.
1901 
1902         Returns
1903         -------
1904         list of `.Line2D`
1905             Objects representing the plotted data.
1906         """
1907         d = {k: v for k, v in kwargs.items()
1908              if k in ['base', 'subs', 'nonpositive',
1909                       'basex', 'subsx', 'nonposx']}
1910         self.set_xscale('log', **d)
1911         return self.plot(
1912             *args, **{k: v for k, v in kwargs.items() if k not in d})
1913 
1914     # @_preprocess_data() # let 'plot' do the unpacking..
1915     @_docstring.dedent_interpd
1916     def semilogy(self, *args, **kwargs):
1917         """
1918         Make a plot with log scaling on the y-axis.
1919 
1920         Call signatures::
1921 
1922             semilogy([x], y, [fmt], data=None, **kwargs)
1923             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1924 
1925         This is just a thin wrapper around `.plot` which additionally changes
1926         the y-axis to log scaling. All the concepts and parameters of plot can
1927         be used here as well.
1928 
1929         The additional parameters *base*, *subs*, and *nonpositive* control the
1930         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1931 
1932         Parameters
1933         ----------
1934         base : float, default: 10
1935             Base of the y logarithm.
1936 
1937         subs : array-like, optional
1938             The location of the minor yticks. If *None*, reasonable locations
1939             are automatically chosen depending on the number of decades in the
1940             plot. See `.Axes.set_yscale` for details.
1941 
1942         nonpositive : {'mask', 'clip'}, default: 'mask'
1943             Non-positive values in y can be masked as invalid, or clipped to a
1944             very small positive number.
1945 
1946         **kwargs
1947             All parameters supported by `.plot`.
1948 
1949         Returns
1950         -------
1951         list of `.Line2D`
1952             Objects representing the plotted data.
1953         """
1954         d = {k: v for k, v in kwargs.items()
1955              if k in ['base', 'subs', 'nonpositive',
1956                       'basey', 'subsy', 'nonposy']}
1957         self.set_yscale('log', **d)
1958         return self.plot(
1959             *args, **{k: v for k, v in kwargs.items() if k not in d})
1960 
1961     @_preprocess_data(replace_names=["x"], label_namer="x")
1962     def acorr(self, x, **kwargs):
1963         """
1964         Plot the autocorrelation of *x*.
1965 
1966         Parameters
1967         ----------
1968         x : array-like
1969 
1970         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1971             A detrending function applied to *x*.  It must have the
1972             signature ::
1973 
1974                 detrend(x: np.ndarray) -> np.ndarray
1975 
1976         normed : bool, default: True
1977             If ``True``, input vectors are normalised to unit length.
1978 
1979         usevlines : bool, default: True
1980             Determines the plot style.
1981 
1982             If ``True``, vertical lines are plotted from 0 to the acorr value
1983             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1984             at y=0 using `.Axes.axhline`.
1985 
1986             If ``False``, markers are plotted at the acorr values using
1987             `.Axes.plot`.
1988 
1989         maxlags : int, default: 10
1990             Number of lags to show. If ``None``, will return all
1991             ``2 * len(x) - 1`` lags.
1992 
1993         Returns
1994         -------
1995         lags : array (length ``2*maxlags+1``)
1996             The lag vector.
1997         c : array  (length ``2*maxlags+1``)
1998             The auto correlation vector.
1999         line : `.LineCollection` or `.Line2D`
2000             `.Artist` added to the Axes of the correlation:
2001 
2002             - `.LineCollection` if *usevlines* is True.
2003             - `.Line2D` if *usevlines* is False.
2004         b : `.Line2D` or None
2005             Horizontal line at 0 if *usevlines* is True
2006             None *usevlines* is False.
2007 
2008         Other Parameters
2009         ----------------
2010         linestyle : `.Line2D` property, optional
2011             The linestyle for plotting the data points.
2012             Only used if *usevlines* is ``False``.
2013 
2014         marker : str, default: 'o'
2015             The marker for plotting the data points.
2016             Only used if *usevlines* is ``False``.
2017 
2018         data : indexable object, optional
2019             DATA_PARAMETER_PLACEHOLDER
2020 
2021         **kwargs
2022             Additional parameters are passed to `.Axes.vlines` and
2023             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2024             passed to `.Axes.plot`.
2025 
2026         Notes
2027         -----
2028         The cross correlation is performed with `numpy.correlate` with
2029         ``mode = "full"``.
2030         """
2031         return self.xcorr(x, x, **kwargs)
2032 
2033     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2034     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2035               usevlines=True, maxlags=10, **kwargs):
2036         r"""
2037         Plot the cross correlation between *x* and *y*.
2038 
2039         The correlation with lag k is defined as
2040         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2041         conjugate of :math:`y`.
2042 
2043         Parameters
2044         ----------
2045         x, y : array-like of length n
2046 
2047         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2048             A detrending function applied to *x* and *y*.  It must have the
2049             signature ::
2050 
2051                 detrend(x: np.ndarray) -> np.ndarray
2052 
2053         normed : bool, default: True
2054             If ``True``, input vectors are normalised to unit length.
2055 
2056         usevlines : bool, default: True
2057             Determines the plot style.
2058 
2059             If ``True``, vertical lines are plotted from 0 to the xcorr value
2060             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2061             at y=0 using `.Axes.axhline`.
2062 
2063             If ``False``, markers are plotted at the xcorr values using
2064             `.Axes.plot`.
2065 
2066         maxlags : int, default: 10
2067             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2068             lags.
2069 
2070         Returns
2071         -------
2072         lags : array (length ``2*maxlags+1``)
2073             The lag vector.
2074         c : array  (length ``2*maxlags+1``)
2075             The auto correlation vector.
2076         line : `.LineCollection` or `.Line2D`
2077             `.Artist` added to the Axes of the correlation:
2078 
2079             - `.LineCollection` if *usevlines* is True.
2080             - `.Line2D` if *usevlines* is False.
2081         b : `.Line2D` or None
2082             Horizontal line at 0 if *usevlines* is True
2083             None *usevlines* is False.
2084 
2085         Other Parameters
2086         ----------------
2087         linestyle : `.Line2D` property, optional
2088             The linestyle for plotting the data points.
2089             Only used if *usevlines* is ``False``.
2090 
2091         marker : str, default: 'o'
2092             The marker for plotting the data points.
2093             Only used if *usevlines* is ``False``.
2094 
2095         data : indexable object, optional
2096             DATA_PARAMETER_PLACEHOLDER
2097 
2098         **kwargs
2099             Additional parameters are passed to `.Axes.vlines` and
2100             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2101             passed to `.Axes.plot`.
2102 
2103         Notes
2104         -----
2105         The cross correlation is performed with `numpy.correlate` with
2106         ``mode = "full"``.
2107         """
2108         Nx = len(x)
2109         if Nx != len(y):
2110             raise ValueError('x and y must be equal length')
2111 
2112         x = detrend(np.asarray(x))
2113         y = detrend(np.asarray(y))
2114 
2115         correls = np.correlate(x, y, mode="full")
2116 
2117         if normed:
2118             correls = correls / np.sqrt(np.dot(x, x) * np.dot(y, y))
2119 
2120         if maxlags is None:
2121             maxlags = Nx - 1
2122 
2123         if maxlags >= Nx or maxlags < 1:
2124             raise ValueError('maxlags must be None or strictly '
2125                              'positive < %d' % Nx)
2126 
2127         lags = np.arange(-maxlags, maxlags + 1)
2128         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2129 
2130         if usevlines:
2131             a = self.vlines(lags, [0], correls, **kwargs)
2132             # Make label empty so only vertical lines get a legend entry
2133             kwargs.pop('label', '')
2134             b = self.axhline(**kwargs)
2135         else:
2136             kwargs.setdefault('marker', 'o')
2137             kwargs.setdefault('linestyle', 'None')
2138             a, = self.plot(lags, correls, **kwargs)
2139             b = None
2140         return lags, correls, a, b
2141 
2142     #### Specialized plotting
2143 
2144     # @_preprocess_data() # let 'plot' do the unpacking..
2145     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2146         """
2147         Make a step plot.
2148 
2149         Call signatures::
2150 
2151             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2152             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2153 
2154         This is just a thin wrapper around `.plot` which changes some
2155         formatting options. Most of the concepts and parameters of plot can be
2156         used here as well.
2157 
2158         .. note::
2159 
2160             This method uses a standard plot with a step drawstyle: The *x*
2161             values are the reference positions and steps extend left/right/both
2162             directions depending on *where*.
2163 
2164             For the common case where you know the values and edges of the
2165             steps, use `~.Axes.stairs` instead.
2166 
2167         Parameters
2168         ----------
2169         x : array-like
2170             1D sequence of x positions. It is assumed, but not checked, that
2171             it is uniformly increasing.
2172 
2173         y : array-like
2174             1D sequence of y levels.
2175 
2176         fmt : str, optional
2177             A format string, e.g. 'g' for a green line. See `.plot` for a more
2178             detailed description.
2179 
2180             Note: While full format strings are accepted, it is recommended to
2181             only specify the color. Line styles are currently ignored (use
2182             the keyword argument *linestyle* instead). Markers are accepted
2183             and plotted on the given positions, however, this is a rarely
2184             needed feature for step plots.
2185 
2186         where : {'pre', 'post', 'mid'}, default: 'pre'
2187             Define where the steps should be placed:
2188 
2189             - 'pre': The y value is continued constantly to the left from
2190               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2191               value ``y[i]``.
2192             - 'post': The y value is continued constantly to the right from
2193               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2194               value ``y[i]``.
2195             - 'mid': Steps occur half-way between the *x* positions.
2196 
2197         data : indexable object, optional
2198             An object with labelled data. If given, provide the label names to
2199             plot in *x* and *y*.
2200 
2201         **kwargs
2202             Additional parameters are the same as those for `.plot`.
2203 
2204         Returns
2205         -------
2206         list of `.Line2D`
2207             Objects representing the plotted data.
2208         """
2209         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2210         kwargs['drawstyle'] = 'steps-' + where
2211         return self.plot(x, y, *args, data=data, **kwargs)
2212 
2213     @staticmethod
2214     def _convert_dx(dx, x0, xconv, convert):
2215         """
2216         Small helper to do logic of width conversion flexibly.
2217 
2218         *dx* and *x0* have units, but *xconv* has already been converted
2219         to unitless (and is an ndarray).  This allows the *dx* to have units
2220         that are different from *x0*, but are still accepted by the
2221         ``__add__`` operator of *x0*.
2222         """
2223 
2224         # x should be an array...
2225         assert type(xconv) is np.ndarray
2226 
2227         if xconv.size == 0:
2228             # xconv has already been converted, but maybe empty...
2229             return convert(dx)
2230 
2231         try:
2232             # attempt to add the width to x0; this works for
2233             # datetime+timedelta, for instance
2234 
2235             # only use the first element of x and x0.  This saves
2236             # having to be sure addition works across the whole
2237             # vector.  This is particularly an issue if
2238             # x0 and dx are lists so x0 + dx just concatenates the lists.
2239             # We can't just cast x0 and dx to numpy arrays because that
2240             # removes the units from unit packages like `pint` that
2241             # wrap numpy arrays.
2242             try:
2243                 x0 = cbook._safe_first_finite(x0)
2244             except (TypeError, IndexError, KeyError):
2245                 pass
2246 
2247             try:
2248                 x = cbook._safe_first_finite(xconv)
2249             except (TypeError, IndexError, KeyError):
2250                 x = xconv
2251 
2252             delist = False
2253             if not np.iterable(dx):
2254                 dx = [dx]
2255                 delist = True
2256             dx = [convert(x0 + ddx) - x for ddx in dx]
2257             if delist:
2258                 dx = dx[0]
2259         except (ValueError, TypeError, AttributeError):
2260             # if the above fails (for any reason) just fallback to what
2261             # we do by default and convert dx by itself.
2262             dx = convert(dx)
2263         return dx
2264 
2265     @_preprocess_data()
2266     @_docstring.dedent_interpd
2267     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2268             **kwargs):
2269         r"""
2270         Make a bar plot.
2271 
2272         The bars are positioned at *x* with the given *align*\ment. Their
2273         dimensions are given by *height* and *width*. The vertical baseline
2274         is *bottom* (default 0).
2275 
2276         Many parameters can take either a single value applying to all bars
2277         or a sequence of values, one for each bar.
2278 
2279         Parameters
2280         ----------
2281         x : float or array-like
2282             The x coordinates of the bars. See also *align* for the
2283             alignment of the bars to the coordinates.
2284 
2285         height : float or array-like
2286             The height(s) of the bars.
2287 
2288         width : float or array-like, default: 0.8
2289             The width(s) of the bars.
2290 
2291         bottom : float or array-like, default: 0
2292             The y coordinate(s) of the bottom side(s) of the bars.
2293 
2294         align : {'center', 'edge'}, default: 'center'
2295             Alignment of the bars to the *x* coordinates:
2296 
2297             - 'center': Center the base on the *x* positions.
2298             - 'edge': Align the left edges of the bars with the *x* positions.
2299 
2300             To align the bars on the right edge pass a negative *width* and
2301             ``align='edge'``.
2302 
2303         Returns
2304         -------
2305         `.BarContainer`
2306             Container with all the bars and optionally errorbars.
2307 
2308         Other Parameters
2309         ----------------
2310         color : color or list of color, optional
2311             The colors of the bar faces.
2312 
2313         edgecolor : color or list of color, optional
2314             The colors of the bar edges.
2315 
2316         linewidth : float or array-like, optional
2317             Width of the bar edge(s). If 0, don't draw edges.
2318 
2319         tick_label : str or list of str, optional
2320             The tick labels of the bars.
2321             Default: None (Use default numeric labels.)
2322 
2323         label : str or list of str, optional
2324             A single label is attached to the resulting `.BarContainer` as a
2325             label for the whole dataset.
2326             If a list is provided, it must be the same length as *x* and
2327             labels the individual bars. Repeated labels are not de-duplicated
2328             and will cause repeated label entries, so this is best used when
2329             bars also differ in style (e.g., by passing a list to *color*.)
2330 
2331         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2332             If not *None*, add horizontal / vertical errorbars to the bar tips.
2333             The values are +/- sizes relative to the data:
2334 
2335             - scalar: symmetric +/- values for all bars
2336             - shape(N,): symmetric +/- values for each bar
2337             - shape(2, N): Separate - and + values for each bar. First row
2338               contains the lower errors, the second row contains the upper
2339               errors.
2340             - *None*: No errorbar. (Default)
2341 
2342             See :doc:`/gallery/statistics/errorbar_features` for an example on
2343             the usage of *xerr* and *yerr*.
2344 
2345         ecolor : color or list of color, default: 'black'
2346             The line color of the errorbars.
2347 
2348         capsize : float, default: :rc:`errorbar.capsize`
2349            The length of the error bar caps in points.
2350 
2351         error_kw : dict, optional
2352             Dictionary of keyword arguments to be passed to the
2353             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2354             here take precedence over the independent keyword arguments.
2355 
2356         log : bool, default: False
2357             If *True*, set the y-axis to be log scale.
2358 
2359         data : indexable object, optional
2360             DATA_PARAMETER_PLACEHOLDER
2361 
2362         **kwargs : `.Rectangle` properties
2363 
2364         %(Rectangle:kwdoc)s
2365 
2366         See Also
2367         --------
2368         barh : Plot a horizontal bar plot.
2369 
2370         Notes
2371         -----
2372         Stacked bars can be achieved by passing individual *bottom* values per
2373         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2374         """
2375         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2376         color = kwargs.pop('color', None)
2377         if color is None:
2378             color = self._get_patches_for_fill.get_next_color()
2379         edgecolor = kwargs.pop('edgecolor', None)
2380         linewidth = kwargs.pop('linewidth', None)
2381         hatch = kwargs.pop('hatch', None)
2382 
2383         # Because xerr and yerr will be passed to errorbar, most dimension
2384         # checking and processing will be left to the errorbar method.
2385         xerr = kwargs.pop('xerr', None)
2386         yerr = kwargs.pop('yerr', None)
2387         error_kw = kwargs.pop('error_kw', {})
2388         ezorder = error_kw.pop('zorder', None)
2389         if ezorder is None:
2390             ezorder = kwargs.get('zorder', None)
2391             if ezorder is not None:
2392                 # If using the bar zorder, increment slightly to make sure
2393                 # errorbars are drawn on top of bars
2394                 ezorder += 0.01
2395         error_kw.setdefault('zorder', ezorder)
2396         ecolor = kwargs.pop('ecolor', 'k')
2397         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2398         error_kw.setdefault('ecolor', ecolor)
2399         error_kw.setdefault('capsize', capsize)
2400 
2401         # The keyword argument *orientation* is used by barh() to defer all
2402         # logic and drawing to bar(). It is considered internal and is
2403         # intentionally not mentioned in the docstring.
2404         orientation = kwargs.pop('orientation', 'vertical')
2405         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2406         log = kwargs.pop('log', False)
2407         label = kwargs.pop('label', '')
2408         tick_labels = kwargs.pop('tick_label', None)
2409 
2410         y = bottom  # Matches barh call signature.
2411         if orientation == 'vertical':
2412             if y is None:
2413                 y = 0
2414         else:  # horizontal
2415             if x is None:
2416                 x = 0
2417 
2418         if orientation == 'vertical':
2419             self._process_unit_info(
2420                 [("x", x), ("y", height)], kwargs, convert=False)
2421             if log:
2422                 self.set_yscale('log', nonpositive='clip')
2423         else:  # horizontal
2424             self._process_unit_info(
2425                 [("x", width), ("y", y)], kwargs, convert=False)
2426             if log:
2427                 self.set_xscale('log', nonpositive='clip')
2428 
2429         # lets do some conversions now since some types cannot be
2430         # subtracted uniformly
2431         if self.xaxis is not None:
2432             x0 = x
2433             x = np.asarray(self.convert_xunits(x))
2434             width = self._convert_dx(width, x0, x, self.convert_xunits)
2435             if xerr is not None:
2436                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2437         if self.yaxis is not None:
2438             y0 = y
2439             y = np.asarray(self.convert_yunits(y))
2440             height = self._convert_dx(height, y0, y, self.convert_yunits)
2441             if yerr is not None:
2442                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2443 
2444         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2445             # Make args iterable too.
2446             np.atleast_1d(x), height, width, y, linewidth, hatch)
2447 
2448         # Now that units have been converted, set the tick locations.
2449         if orientation == 'vertical':
2450             tick_label_axis = self.xaxis
2451             tick_label_position = x
2452         else:  # horizontal
2453             tick_label_axis = self.yaxis
2454             tick_label_position = y
2455 
2456         if not isinstance(label, str) and np.iterable(label):
2457             bar_container_label = '_nolegend_'
2458             patch_labels = label
2459         else:
2460             bar_container_label = label
2461             patch_labels = ['_nolegend_'] * len(x)
2462         if len(patch_labels) != len(x):
2463             raise ValueError(f'number of labels ({len(patch_labels)}) '
2464                              f'does not match number of bars ({len(x)}).')
2465 
2466         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2467         hatch = itertools.cycle(np.atleast_1d(hatch))
2468         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2469                                 # Fallback if color == "none".
2470                                 itertools.repeat('none'))
2471         if edgecolor is None:
2472             edgecolor = itertools.repeat(None)
2473         else:
2474             edgecolor = itertools.chain(
2475                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2476                 # Fallback if edgecolor == "none".
2477                 itertools.repeat('none'))
2478 
2479         # We will now resolve the alignment and really have
2480         # left, bottom, width, height vectors
2481         _api.check_in_list(['center', 'edge'], align=align)
2482         if align == 'center':
2483             if orientation == 'vertical':
2484                 try:
2485                     left = x - width / 2
2486                 except TypeError as e:
2487                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2488                                     f'and width ({width.dtype}) '
2489                                     f'are incompatible') from e
2490                 bottom = y
2491             else:  # horizontal
2492                 try:
2493                     bottom = y - height / 2
2494                 except TypeError as e:
2495                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2496                                     f'and height ({height.dtype}) '
2497                                     f'are incompatible') from e
2498                 left = x
2499         else:  # edge
2500             left = x
2501             bottom = y
2502 
2503         patches = []
2504         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2505                    hatch, patch_labels)
2506         for l, b, w, h, c, e, lw, htch, lbl in args:
2507             r = mpatches.Rectangle(
2508                 xy=(l, b), width=w, height=h,
2509                 facecolor=c,
2510                 edgecolor=e,
2511                 linewidth=lw,
2512                 label=lbl,
2513                 hatch=htch,
2514                 )
2515             r._internal_update(kwargs)
2516             r.get_path()._interpolation_steps = 100
2517             if orientation == 'vertical':
2518                 r.sticky_edges.y.append(b)
2519             else:  # horizontal
2520                 r.sticky_edges.x.append(l)
2521             self.add_patch(r)
2522             patches.append(r)
2523 
2524         if xerr is not None or yerr is not None:
2525             if orientation == 'vertical':
2526                 # using list comps rather than arrays to preserve unit info
2527                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2528                 ey = [b + h for b, h in zip(bottom, height)]
2529 
2530             else:  # horizontal
2531                 # using list comps rather than arrays to preserve unit info
2532                 ex = [l + w for l, w in zip(left, width)]
2533                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2534 
2535             error_kw.setdefault("label", '_nolegend_')
2536 
2537             errorbar = self.errorbar(ex, ey,
2538                                      yerr=yerr, xerr=xerr,
2539                                      fmt='none', **error_kw)
2540         else:
2541             errorbar = None
2542 
2543         self._request_autoscale_view()
2544 
2545         if orientation == 'vertical':
2546             datavalues = height
2547         else:  # horizontal
2548             datavalues = width
2549 
2550         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2551                                      orientation=orientation,
2552                                      label=bar_container_label)
2553         self.add_container(bar_container)
2554 
2555         if tick_labels is not None:
2556             tick_labels = np.broadcast_to(tick_labels, len(patches))
2557             tick_label_axis.set_ticks(tick_label_position)
2558             tick_label_axis.set_ticklabels(tick_labels)
2559 
2560         return bar_container
2561 
2562     # @_preprocess_data() # let 'bar' do the unpacking..
2563     @_docstring.dedent_interpd
2564     def barh(self, y, width, height=0.8, left=None, *, align="center",
2565              data=None, **kwargs):
2566         r"""
2567         Make a horizontal bar plot.
2568 
2569         The bars are positioned at *y* with the given *align*\ment. Their
2570         dimensions are given by *width* and *height*. The horizontal baseline
2571         is *left* (default 0).
2572 
2573         Many parameters can take either a single value applying to all bars
2574         or a sequence of values, one for each bar.
2575 
2576         Parameters
2577         ----------
2578         y : float or array-like
2579             The y coordinates of the bars. See also *align* for the
2580             alignment of the bars to the coordinates.
2581 
2582         width : float or array-like
2583             The width(s) of the bars.
2584 
2585         height : float or array-like, default: 0.8
2586             The heights of the bars.
2587 
2588         left : float or array-like, default: 0
2589             The x coordinates of the left side(s) of the bars.
2590 
2591         align : {'center', 'edge'}, default: 'center'
2592             Alignment of the base to the *y* coordinates*:
2593 
2594             - 'center': Center the bars on the *y* positions.
2595             - 'edge': Align the bottom edges of the bars with the *y*
2596               positions.
2597 
2598             To align the bars on the top edge pass a negative *height* and
2599             ``align='edge'``.
2600 
2601         Returns
2602         -------
2603         `.BarContainer`
2604             Container with all the bars and optionally errorbars.
2605 
2606         Other Parameters
2607         ----------------
2608         color : color or list of color, optional
2609             The colors of the bar faces.
2610 
2611         edgecolor : color or list of color, optional
2612             The colors of the bar edges.
2613 
2614         linewidth : float or array-like, optional
2615             Width of the bar edge(s). If 0, don't draw edges.
2616 
2617         tick_label : str or list of str, optional
2618             The tick labels of the bars.
2619             Default: None (Use default numeric labels.)
2620 
2621         label : str or list of str, optional
2622             A single label is attached to the resulting `.BarContainer` as a
2623             label for the whole dataset.
2624             If a list is provided, it must be the same length as *y* and
2625             labels the individual bars. Repeated labels are not de-duplicated
2626             and will cause repeated label entries, so this is best used when
2627             bars also differ in style (e.g., by passing a list to *color*.)
2628 
2629         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2630             If not *None*, add horizontal / vertical errorbars to the bar tips.
2631             The values are +/- sizes relative to the data:
2632 
2633             - scalar: symmetric +/- values for all bars
2634             - shape(N,): symmetric +/- values for each bar
2635             - shape(2, N): Separate - and + values for each bar. First row
2636               contains the lower errors, the second row contains the upper
2637               errors.
2638             - *None*: No errorbar. (default)
2639 
2640             See :doc:`/gallery/statistics/errorbar_features` for an example on
2641             the usage of *xerr* and *yerr*.
2642 
2643         ecolor : color or list of color, default: 'black'
2644             The line color of the errorbars.
2645 
2646         capsize : float, default: :rc:`errorbar.capsize`
2647            The length of the error bar caps in points.
2648 
2649         error_kw : dict, optional
2650             Dictionary of keyword arguments to be passed to the
2651             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2652             here take precedence over the independent keyword arguments.
2653 
2654         log : bool, default: False
2655             If ``True``, set the x-axis to be log scale.
2656 
2657         data : indexable object, optional
2658             If given, all parameters also accept a string ``s``, which is
2659             interpreted as ``data[s]`` (unless this raises an exception).
2660 
2661         **kwargs : `.Rectangle` properties
2662 
2663         %(Rectangle:kwdoc)s
2664 
2665         See Also
2666         --------
2667         bar : Plot a vertical bar plot.
2668 
2669         Notes
2670         -----
2671         Stacked bars can be achieved by passing individual *left* values per
2672         bar. See
2673         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2674         """
2675         kwargs.setdefault('orientation', 'horizontal')
2676         patches = self.bar(x=left, height=height, width=width, bottom=y,
2677                            align=align, data=data, **kwargs)
2678         return patches
2679 
2680     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2681                   padding=0, **kwargs):
2682         """
2683         Label a bar plot.
2684 
2685         Adds labels to bars in the given `.BarContainer`.
2686         You may need to adjust the axis limits to fit the labels.
2687 
2688         Parameters
2689         ----------
2690         container : `.BarContainer`
2691             Container with all the bars and optionally errorbars, likely
2692             returned from `.bar` or `.barh`.
2693 
2694         labels : array-like, optional
2695             A list of label texts, that should be displayed. If not given, the
2696             label texts will be the data values formatted with *fmt*.
2697 
2698         fmt : str or callable, default: '%g'
2699             An unnamed %-style or {}-style format string for the label or a
2700             function to call with the value as the first argument.
2701             When *fmt* is a string and can be interpreted in both formats,
2702             %-style takes precedence over {}-style.
2703 
2704             .. versionadded:: 3.7
2705                Support for {}-style format string and callables.
2706 
2707         label_type : {'edge', 'center'}, default: 'edge'
2708             The label type. Possible values:
2709 
2710             - 'edge': label placed at the end-point of the bar segment, and the
2711               value displayed will be the position of that end-point.
2712             - 'center': label placed in the center of the bar segment, and the
2713               value displayed will be the length of that segment.
2714               (useful for stacked bars, i.e.,
2715               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2716 
2717         padding : float, default: 0
2718             Distance of label from the end of the bar, in points.
2719 
2720         **kwargs
2721             Any remaining keyword arguments are passed through to
2722             `.Axes.annotate`. The alignment parameters (
2723             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2724             not supported because the labels are automatically aligned to
2725             the bars.
2726 
2727         Returns
2728         -------
2729         list of `.Text`
2730             A list of `.Text` instances for the labels.
2731         """
2732         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2733             if key in kwargs:
2734                 raise ValueError(
2735                     f"Passing {key!r} to bar_label() is not supported.")
2736 
2737         a, b = self.yaxis.get_view_interval()
2738         y_inverted = a > b
2739         c, d = self.xaxis.get_view_interval()
2740         x_inverted = c > d
2741 
2742         # want to know whether to put label on positive or negative direction
2743         # cannot use np.sign here because it will return 0 if x == 0
2744         def sign(x):
2745             return 1 if x >= 0 else -1
2746 
2747         _api.check_in_list(['edge', 'center'], label_type=label_type)
2748 
2749         bars = container.patches
2750         errorbar = container.errorbar
2751         datavalues = container.datavalues
2752         orientation = container.orientation
2753 
2754         if errorbar:
2755             # check "ErrorbarContainer" for the definition of these elements
2756             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2757             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2758             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2759             errs = barlinecol.get_segments()
2760         else:
2761             errs = []
2762 
2763         if labels is None:
2764             labels = []
2765 
2766         annotations = []
2767 
2768         for bar, err, dat, lbl in itertools.zip_longest(
2769                 bars, errs, datavalues, labels
2770         ):
2771             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2772             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2773 
2774             if orientation == "vertical":
2775                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2776                 length = abs(y0 - y1)
2777             else:  # horizontal
2778                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2779                 length = abs(x0 - x1)
2780 
2781             if err is None or np.size(err) == 0:
2782                 endpt = extrema
2783             elif orientation == "vertical":
2784                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2785             else:  # horizontal
2786                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2787 
2788             if label_type == "center":
2789                 value = sign(dat) * length
2790             else:  # edge
2791                 value = extrema
2792 
2793             if label_type == "center":
2794                 xy = (0.5, 0.5)
2795                 kwargs["xycoords"] = (
2796                     lambda r, b=bar:
2797                         mtransforms.Bbox.intersection(
2798                             b.get_window_extent(r), b.get_clip_box()
2799                         ) or mtransforms.Bbox.null()
2800                 )
2801             else:  # edge
2802                 if orientation == "vertical":
2803                     xy = xc, endpt
2804                 else:  # horizontal
2805                     xy = endpt, yc
2806 
2807             if orientation == "vertical":
2808                 y_direction = -1 if y_inverted else 1
2809                 xytext = 0, y_direction * sign(dat) * padding
2810             else:  # horizontal
2811                 x_direction = -1 if x_inverted else 1
2812                 xytext = x_direction * sign(dat) * padding, 0
2813 
2814             if label_type == "center":
2815                 ha, va = "center", "center"
2816             else:  # edge
2817                 if orientation == "vertical":
2818                     ha = 'center'
2819                     if y_inverted:
2820                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2821                     else:
2822                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2823                 else:  # horizontal
2824                     if x_inverted:
2825                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2826                     else:
2827                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2828                     va = 'center'
2829 
2830             if np.isnan(dat):
2831                 lbl = ''
2832 
2833             if lbl is None:
2834                 if isinstance(fmt, str):
2835                     lbl = cbook._auto_format_str(fmt, value)
2836                 elif callable(fmt):
2837                     lbl = fmt(value)
2838                 else:
2839                     raise TypeError("fmt must be a str or callable")
2840             annotation = self.annotate(lbl,
2841                                        xy, xytext, textcoords="offset points",
2842                                        ha=ha, va=va, **kwargs)
2843             annotations.append(annotation)
2844 
2845         return annotations
2846 
2847     @_preprocess_data()
2848     @_docstring.dedent_interpd
2849     def broken_barh(self, xranges, yrange, **kwargs):
2850         """
2851         Plot a horizontal sequence of rectangles.
2852 
2853         A rectangle is drawn for each element of *xranges*. All rectangles
2854         have the same vertical position and size defined by *yrange*.
2855 
2856         Parameters
2857         ----------
2858         xranges : sequence of tuples (*xmin*, *xwidth*)
2859             The x-positions and extents of the rectangles. For each tuple
2860             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2861             *xwidth*.
2862         yrange : (*ymin*, *yheight*)
2863             The y-position and extent for all the rectangles.
2864 
2865         Returns
2866         -------
2867         `~.collections.PolyCollection`
2868 
2869         Other Parameters
2870         ----------------
2871         data : indexable object, optional
2872             DATA_PARAMETER_PLACEHOLDER
2873         **kwargs : `.PolyCollection` properties
2874 
2875             Each *kwarg* can be either a single argument applying to all
2876             rectangles, e.g.::
2877 
2878                 facecolors='black'
2879 
2880             or a sequence of arguments over which is cycled, e.g.::
2881 
2882                 facecolors=('black', 'blue')
2883 
2884             would create interleaving black and blue rectangles.
2885 
2886             Supported keywords:
2887 
2888             %(PolyCollection:kwdoc)s
2889         """
2890         # process the unit information
2891         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2892         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2893         self._process_unit_info(
2894             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2895 
2896         vertices = []
2897         y0, dy = yrange
2898         y0, y1 = self.convert_yunits((y0, y0 + dy))
2899         for xr in xranges:  # convert the absolute values, not the x and dx
2900             try:
2901                 x0, dx = xr
2902             except Exception:
2903                 raise ValueError(
2904                     "each range in xrange must be a sequence with two "
2905                     "elements (i.e. xrange must be an (N, 2) array)") from None
2906             x0, x1 = self.convert_xunits((x0, x0 + dx))
2907             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2908 
2909         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2910         self.add_collection(col, autolim=True)
2911         self._request_autoscale_view()
2912 
2913         return col
2914 
2915     @_preprocess_data()
2916     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2917              label=None, orientation='vertical'):
2918         """
2919         Create a stem plot.
2920 
2921         A stem plot draws lines perpendicular to a baseline at each location
2922         *locs* from the baseline to *heads*, and places a marker there. For
2923         vertical stem plots (the default), the *locs* are *x* positions, and
2924         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2925         *y* positions, and the *heads* are *x* values.
2926 
2927         Call signature::
2928 
2929           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2930 
2931         The *locs*-positions are optional. *linefmt* may be provided as
2932         positional, but all other formats must be provided as keyword
2933         arguments.
2934 
2935         Parameters
2936         ----------
2937         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2938             For vertical stem plots, the x-positions of the stems.
2939             For horizontal stem plots, the y-positions of the stems.
2940 
2941         heads : array-like
2942             For vertical stem plots, the y-values of the stem heads.
2943             For horizontal stem plots, the x-values of the stem heads.
2944 
2945         linefmt : str, optional
2946             A string defining the color and/or linestyle of the vertical lines:
2947 
2948             =========  =============
2949             Character  Line Style
2950             =========  =============
2951             ``'-'``    solid line
2952             ``'--'``   dashed line
2953             ``'-.'``   dash-dot line
2954             ``':'``    dotted line
2955             =========  =============
2956 
2957             Default: 'C0-', i.e. solid line with the first color of the color
2958             cycle.
2959 
2960             Note: Markers specified through this parameter (e.g. 'x') will be
2961             silently ignored. Instead, markers should be specified using
2962             *markerfmt*.
2963 
2964         markerfmt : str, optional
2965             A string defining the color and/or shape of the markers at the stem
2966             heads. If the marker is not given, use the marker 'o', i.e. filled
2967             circles. If the color is not given, use the color from *linefmt*.
2968 
2969         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2970             A format string defining the properties of the baseline.
2971 
2972         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2973             If 'vertical', will produce a plot with stems oriented vertically,
2974             If 'horizontal', the stems will be oriented horizontally.
2975 
2976         bottom : float, default: 0
2977             The y/x-position of the baseline (depending on orientation).
2978 
2979         label : str, default: None
2980             The label to use for the stems in legends.
2981 
2982         data : indexable object, optional
2983             DATA_PARAMETER_PLACEHOLDER
2984 
2985         Returns
2986         -------
2987         `.StemContainer`
2988             The container may be treated like a tuple
2989             (*markerline*, *stemlines*, *baseline*)
2990 
2991         Notes
2992         -----
2993         .. seealso::
2994             The MATLAB function
2995             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2996             which inspired this method.
2997         """
2998         if not 1 <= len(args) <= 3:
2999             raise _api.nargs_error('stem', '1-3', len(args))
3000         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
3001 
3002         if len(args) == 1:
3003             heads, = args
3004             locs = np.arange(len(heads))
3005             args = ()
3006         elif isinstance(args[1], str):
3007             heads, *args = args
3008             locs = np.arange(len(heads))
3009         else:
3010             locs, heads, *args = args
3011 
3012         if orientation == 'vertical':
3013             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
3014         else:  # horizontal
3015             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
3016 
3017         # resolve line format
3018         if linefmt is None:
3019             linefmt = args[0] if len(args) > 0 else "C0-"
3020         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3021 
3022         # resolve marker format
3023         if markerfmt is None:
3024             # if not given as kwarg, fall back to 'o'
3025             markerfmt = "o"
3026         if markerfmt == '':
3027             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3028         markerstyle, markermarker, markercolor = \
3029             _process_plot_format(markerfmt)
3030         if markermarker is None:
3031             markermarker = 'o'
3032         if markerstyle is None:
3033             markerstyle = 'None'
3034         if markercolor is None:
3035             markercolor = linecolor
3036 
3037         # resolve baseline format
3038         if basefmt is None:
3039             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3040                        "C3-")
3041         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3042 
3043         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3044         if linestyle is None:
3045             linestyle = mpl.rcParams['lines.linestyle']
3046         xlines = self.vlines if orientation == "vertical" else self.hlines
3047         stemlines = xlines(
3048             locs, bottom, heads,
3049             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3050 
3051         if orientation == 'horizontal':
3052             marker_x = heads
3053             marker_y = locs
3054             baseline_x = [bottom, bottom]
3055             baseline_y = [np.min(locs), np.max(locs)]
3056         else:
3057             marker_x = locs
3058             marker_y = heads
3059             baseline_x = [np.min(locs), np.max(locs)]
3060             baseline_y = [bottom, bottom]
3061 
3062         markerline, = self.plot(marker_x, marker_y,
3063                                 color=markercolor, linestyle=markerstyle,
3064                                 marker=markermarker, label="_nolegend_")
3065 
3066         baseline, = self.plot(baseline_x, baseline_y,
3067                               color=basecolor, linestyle=basestyle,
3068                               marker=basemarker, label="_nolegend_")
3069 
3070         stem_container = StemContainer((markerline, stemlines, baseline),
3071                                        label=label)
3072         self.add_container(stem_container)
3073         return stem_container
3074 
3075     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3076     def pie(self, x, explode=None, labels=None, colors=None,
3077             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3078             startangle=0, radius=1, counterclock=True,
3079             wedgeprops=None, textprops=None, center=(0, 0),
3080             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3081         """
3082         Plot a pie chart.
3083 
3084         Make a pie chart of array *x*.  The fractional area of each wedge is
3085         given by ``x/sum(x)``.
3086 
3087         The wedges are plotted counterclockwise, by default starting from the
3088         x-axis.
3089 
3090         Parameters
3091         ----------
3092         x : 1D array-like
3093             The wedge sizes.
3094 
3095         explode : array-like, default: None
3096             If not *None*, is a ``len(x)`` array which specifies the fraction
3097             of the radius with which to offset each wedge.
3098 
3099         labels : list, default: None
3100             A sequence of strings providing the labels for each wedge
3101 
3102         colors : color or array-like of color, default: None
3103             A sequence of colors through which the pie chart will cycle.  If
3104             *None*, will use the colors in the currently active cycle.
3105 
3106         hatch : str or list, default: None
3107             Hatching pattern applied to all pie wedges or sequence of patterns
3108             through which the chart will cycle. For a list of valid patterns,
3109             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3110 
3111             .. versionadded:: 3.7
3112 
3113         autopct : None or str or callable, default: None
3114             If not *None*, *autopct* is a string or function used to label the
3115             wedges with their numeric value. The label will be placed inside
3116             the wedge. If *autopct* is a format string, the label will be
3117             ``fmt % pct``. If *autopct* is a function, then it will be called.
3118 
3119         pctdistance : float, default: 0.6
3120             The relative distance along the radius at which the text
3121             generated by *autopct* is drawn. To draw the text outside the pie,
3122             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3123             ``None``.
3124 
3125         labeldistance : float or None, default: 1.1
3126             The relative distance along the radius at which the labels are
3127             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3128             If set to ``None``, labels are not drawn but are still stored for
3129             use in `.legend`.
3130 
3131         shadow : bool or dict, default: False
3132             If bool, whether to draw a shadow beneath the pie. If dict, draw a shadow
3133             passing the properties in the dict to `.Shadow`.
3134 
3135             .. versionadded:: 3.8
3136                 *shadow* can be a dict.
3137 
3138         startangle : float, default: 0 degrees
3139             The angle by which the start of the pie is rotated,
3140             counterclockwise from the x-axis.
3141 
3142         radius : float, default: 1
3143             The radius of the pie.
3144 
3145         counterclock : bool, default: True
3146             Specify fractions direction, clockwise or counterclockwise.
3147 
3148         wedgeprops : dict, default: None
3149             Dict of arguments passed to each `.patches.Wedge` of the pie.
3150             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3151             the wedge border lines equal to 3. By default, ``clip_on=False``.
3152             When there is a conflict between these properties and other
3153             keywords, properties passed to *wedgeprops* take precedence.
3154 
3155         textprops : dict, default: None
3156             Dict of arguments to pass to the text objects.
3157 
3158         center : (float, float), default: (0, 0)
3159             The coordinates of the center of the chart.
3160 
3161         frame : bool, default: False
3162             Plot Axes frame with the chart if true.
3163 
3164         rotatelabels : bool, default: False
3165             Rotate each label to the angle of the corresponding slice if true.
3166 
3167         normalize : bool, default: True
3168             When *True*, always make a full pie by normalizing x so that
3169             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3170             and raises a `ValueError` for ``sum(x) > 1``.
3171 
3172         data : indexable object, optional
3173             DATA_PARAMETER_PLACEHOLDER
3174 
3175         Returns
3176         -------
3177         patches : list
3178             A sequence of `matplotlib.patches.Wedge` instances
3179 
3180         texts : list
3181             A list of the label `.Text` instances.
3182 
3183         autotexts : list
3184             A list of `.Text` instances for the numeric labels. This will only
3185             be returned if the parameter *autopct* is not *None*.
3186 
3187         Notes
3188         -----
3189         The pie chart will probably look best if the figure and Axes are
3190         square, or the Axes aspect is equal.
3191         This method sets the aspect ratio of the axis to "equal".
3192         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3193         """
3194         self.set_aspect('equal')
3195         # The use of float32 is "historical", but can't be changed without
3196         # regenerating the test baselines.
3197         x = np.asarray(x, np.float32)
3198         if x.ndim > 1:
3199             raise ValueError("x must be 1D")
3200 
3201         if np.any(x < 0):
3202             raise ValueError("Wedge sizes 'x' must be non negative values")
3203 
3204         sx = x.sum()
3205 
3206         if normalize:
3207             x = x / sx
3208         elif sx > 1:
3209             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3210         if labels is None:
3211             labels = [''] * len(x)
3212         if explode is None:
3213             explode = [0] * len(x)
3214         if len(x) != len(labels):
3215             raise ValueError("'label' must be of length 'x'")
3216         if len(x) != len(explode):
3217             raise ValueError("'explode' must be of length 'x'")
3218         if colors is None:
3219             get_next_color = self._get_patches_for_fill.get_next_color
3220         else:
3221             color_cycle = itertools.cycle(colors)
3222 
3223             def get_next_color():
3224                 return next(color_cycle)
3225 
3226         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3227 
3228         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3229         if radius <= 0:
3230             raise ValueError(f'radius must be a positive number, not {radius}')
3231 
3232         # Starting theta1 is the start fraction of the circle
3233         theta1 = startangle / 360
3234 
3235         if wedgeprops is None:
3236             wedgeprops = {}
3237         if textprops is None:
3238             textprops = {}
3239 
3240         texts = []
3241         slices = []
3242         autotexts = []
3243 
3244         for frac, label, expl in zip(x, labels, explode):
3245             x, y = center
3246             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3247             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3248             x += expl * math.cos(thetam)
3249             y += expl * math.sin(thetam)
3250 
3251             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3252                                360. * max(theta1, theta2),
3253                                facecolor=get_next_color(),
3254                                hatch=next(hatch_cycle),
3255                                clip_on=False,
3256                                label=label)
3257             w.set(**wedgeprops)
3258             slices.append(w)
3259             self.add_patch(w)
3260 
3261             if shadow:
3262                 # Make sure to add a shadow after the call to add_patch so the
3263                 # figure and transform props will be set.
3264                 shadow_dict = {'ox': -0.02, 'oy': -0.02, 'label': '_nolegend_'}
3265                 if isinstance(shadow, dict):
3266                     shadow_dict.update(shadow)
3267                 self.add_patch(mpatches.Shadow(w, **shadow_dict))
3268 
3269             if labeldistance is not None:
3270                 xt = x + labeldistance * radius * math.cos(thetam)
3271                 yt = y + labeldistance * radius * math.sin(thetam)
3272                 label_alignment_h = 'left' if xt > 0 else 'right'
3273                 label_alignment_v = 'center'
3274                 label_rotation = 'horizontal'
3275                 if rotatelabels:
3276                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3277                     label_rotation = (np.rad2deg(thetam)
3278                                       + (0 if xt > 0 else 180))
3279                 t = self.text(xt, yt, label,
3280                               clip_on=False,
3281                               horizontalalignment=label_alignment_h,
3282                               verticalalignment=label_alignment_v,
3283                               rotation=label_rotation,
3284                               size=mpl.rcParams['xtick.labelsize'])
3285                 t.set(**textprops)
3286                 texts.append(t)
3287 
3288             if autopct is not None:
3289                 xt = x + pctdistance * radius * math.cos(thetam)
3290                 yt = y + pctdistance * radius * math.sin(thetam)
3291                 if isinstance(autopct, str):
3292                     s = autopct % (100. * frac)
3293                 elif callable(autopct):
3294                     s = autopct(100. * frac)
3295                 else:
3296                     raise TypeError(
3297                         'autopct must be callable or a format string')
3298                 t = self.text(xt, yt, s,
3299                               clip_on=False,
3300                               horizontalalignment='center',
3301                               verticalalignment='center')
3302                 t.set(**textprops)
3303                 autotexts.append(t)
3304 
3305             theta1 = theta2
3306 
3307         if frame:
3308             self._request_autoscale_view()
3309         else:
3310             self.set(frame_on=False, xticks=[], yticks=[],
3311                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3312                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3313 
3314         if autopct is None:
3315             return slices, texts
3316         else:
3317             return slices, texts, autotexts
3318 
3319     @staticmethod
3320     def _errorevery_to_mask(x, errorevery):
3321         """
3322         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3323 
3324         This function is split out to be usable both by 2D and 3D errorbars.
3325         """
3326         if isinstance(errorevery, Integral):
3327             errorevery = (0, errorevery)
3328         if isinstance(errorevery, tuple):
3329             if (len(errorevery) == 2 and
3330                     isinstance(errorevery[0], Integral) and
3331                     isinstance(errorevery[1], Integral)):
3332                 errorevery = slice(errorevery[0], None, errorevery[1])
3333             else:
3334                 raise ValueError(
3335                     f'{errorevery=!r} is a not a tuple of two integers')
3336         elif isinstance(errorevery, slice):
3337             pass
3338         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3339             try:
3340                 x[errorevery]  # fancy indexing
3341             except (ValueError, IndexError) as err:
3342                 raise ValueError(
3343                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3344                     "index to match 'xerr'/'yerr'") from err
3345         else:
3346             raise ValueError(f"{errorevery=!r} is not a recognized value")
3347         everymask = np.zeros(len(x), bool)
3348         everymask[errorevery] = True
3349         return everymask
3350 
3351     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3352                       label_namer="y")
3353     @_docstring.dedent_interpd
3354     def errorbar(self, x, y, yerr=None, xerr=None,
3355                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3356                  barsabove=False, lolims=False, uplims=False,
3357                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3358                  **kwargs):
3359         """
3360         Plot y versus x as lines and/or markers with attached errorbars.
3361 
3362         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3363         sizes. By default, this draws the data markers/lines as well the
3364         errorbars. Use fmt='none' to draw errorbars without any data markers.
3365 
3366         .. versionadded:: 3.7
3367            Caps and error lines are drawn in polar coordinates on polar plots.
3368 
3369 
3370         Parameters
3371         ----------
3372         x, y : float or array-like
3373             The data positions.
3374 
3375         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3376             The errorbar sizes:
3377 
3378             - scalar: Symmetric +/- values for all data points.
3379             - shape(N,): Symmetric +/-values for each data point.
3380             - shape(2, N): Separate - and + values for each bar. First row
3381               contains the lower errors, the second row contains the upper
3382               errors.
3383             - *None*: No errorbar.
3384 
3385             All values must be >= 0.
3386 
3387             See :doc:`/gallery/statistics/errorbar_features`
3388             for an example on the usage of ``xerr`` and ``yerr``.
3389 
3390         fmt : str, default: ''
3391             The format for the data points / data lines. See `.plot` for
3392             details.
3393 
3394             Use 'none' (case-insensitive) to plot errorbars without any data
3395             markers.
3396 
3397         ecolor : color, default: None
3398             The color of the errorbar lines.  If None, use the color of the
3399             line connecting the markers.
3400 
3401         elinewidth : float, default: None
3402             The linewidth of the errorbar lines. If None, the linewidth of
3403             the current style is used.
3404 
3405         capsize : float, default: :rc:`errorbar.capsize`
3406             The length of the error bar caps in points.
3407 
3408         capthick : float, default: None
3409             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3410             This setting is a more sensible name for the property that
3411             controls the thickness of the error bar cap in points. For
3412             backwards compatibility, if *mew* or *markeredgewidth* are given,
3413             then they will over-ride *capthick*. This may change in future
3414             releases.
3415 
3416         barsabove : bool, default: False
3417             If True, will plot the errorbars above the plot
3418             symbols. Default is below.
3419 
3420         lolims, uplims, xlolims, xuplims : bool, default: False
3421             These arguments can be used to indicate that a value gives only
3422             upper/lower limits.  In that case a caret symbol is used to
3423             indicate this. *lims*-arguments may be scalars, or array-likes of
3424             the same length as *xerr* and *yerr*.  To use limits with inverted
3425             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3426             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3427             *lolims* to True means that the y-value is a *lower* limit of the
3428             True value, so, only an *upward*-pointing arrow will be drawn!
3429 
3430         errorevery : int or (int, int), default: 1
3431             draws error bars on a subset of the data. *errorevery* =N draws
3432             error bars on the points (x[::N], y[::N]).
3433             *errorevery* =(start, N) draws error bars on the points
3434             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3435             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3436             Used to avoid overlapping error bars when two series share x-axis
3437             values.
3438 
3439         Returns
3440         -------
3441         `.ErrorbarContainer`
3442             The container contains:
3443 
3444             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3445             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3446             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3447               vertical error ranges.
3448 
3449         Other Parameters
3450         ----------------
3451         data : indexable object, optional
3452             DATA_PARAMETER_PLACEHOLDER
3453 
3454         **kwargs
3455             All other keyword arguments are passed on to the `~.Axes.plot` call
3456             drawing the markers. For example, this code makes big red squares
3457             with thick green edges::
3458 
3459                 x, y, yerr = rand(3, 10)
3460                 errorbar(x, y, yerr, marker='s', mfc='red',
3461                          mec='green', ms=20, mew=4)
3462 
3463             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3464             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3465             and *markeredgewidth*.
3466 
3467             Valid kwargs for the marker properties are:
3468 
3469             - *dashes*
3470             - *dash_capstyle*
3471             - *dash_joinstyle*
3472             - *drawstyle*
3473             - *fillstyle*
3474             - *linestyle*
3475             - *marker*
3476             - *markeredgecolor*
3477             - *markeredgewidth*
3478             - *markerfacecolor*
3479             - *markerfacecoloralt*
3480             - *markersize*
3481             - *markevery*
3482             - *solid_capstyle*
3483             - *solid_joinstyle*
3484 
3485             Refer to the corresponding `.Line2D` property for more details:
3486 
3487             %(Line2D:kwdoc)s
3488         """
3489         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3490         # Drop anything that comes in as None to use the default instead.
3491         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3492         kwargs.setdefault('zorder', 2)
3493 
3494         # Casting to object arrays preserves units.
3495         if not isinstance(x, np.ndarray):
3496             x = np.asarray(x, dtype=object)
3497         if not isinstance(y, np.ndarray):
3498             y = np.asarray(y, dtype=object)
3499 
3500         def _upcast_err(err):
3501             """
3502             Safely handle tuple of containers that carry units.
3503 
3504             This function covers the case where the input to the xerr/yerr is a
3505             length 2 tuple of equal length ndarray-subclasses that carry the
3506             unit information in the container.
3507 
3508             If we have a tuple of nested numpy array (subclasses), we defer
3509             coercing the units to be consistent to the underlying unit
3510             library (and implicitly the broadcasting).
3511 
3512             Otherwise, fallback to casting to an object array.
3513             """
3514 
3515             if (
3516                     # make sure it is not a scalar
3517                     np.iterable(err) and
3518                     # and it is not empty
3519                     len(err) > 0 and
3520                     # and the first element is an array sub-class use
3521                     # safe_first_element because getitem is index-first not
3522                     # location first on pandas objects so err[0] almost always
3523                     # fails.
3524                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3525             ):
3526                 # Get the type of the first element
3527                 atype = type(cbook._safe_first_finite(err))
3528                 # Promote the outer container to match the inner container
3529                 if atype is np.ndarray:
3530                     # Converts using np.asarray, because data cannot
3531                     # be directly passed to init of np.ndarray
3532                     return np.asarray(err, dtype=object)
3533                 # If atype is not np.ndarray, directly pass data to init.
3534                 # This works for types such as unyts and astropy units
3535                 return atype(err)
3536             # Otherwise wrap it in an object array
3537             return np.asarray(err, dtype=object)
3538 
3539         if xerr is not None and not isinstance(xerr, np.ndarray):
3540             xerr = _upcast_err(xerr)
3541         if yerr is not None and not isinstance(yerr, np.ndarray):
3542             yerr = _upcast_err(yerr)
3543         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3544         if len(x) != len(y):
3545             raise ValueError("'x' and 'y' must have the same size")
3546 
3547         everymask = self._errorevery_to_mask(x, errorevery)
3548 
3549         label = kwargs.pop("label", None)
3550         kwargs['label'] = '_nolegend_'
3551 
3552         # Create the main line and determine overall kwargs for child artists.
3553         # We avoid calling self.plot() directly, or self._get_lines(), because
3554         # that would call self._process_unit_info again, and do other indirect
3555         # data processing.
3556         (data_line, base_style), = self._get_lines._plot_args(
3557             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3558 
3559         # Do this after creating `data_line` to avoid modifying `base_style`.
3560         if barsabove:
3561             data_line.set_zorder(kwargs['zorder'] - .1)
3562         else:
3563             data_line.set_zorder(kwargs['zorder'] + .1)
3564 
3565         # Add line to plot, or throw it away and use it to determine kwargs.
3566         if fmt.lower() != 'none':
3567             self.add_line(data_line)
3568         else:
3569             data_line = None
3570             # Remove alpha=0 color that _get_lines._plot_args returns for
3571             # 'none' format, and replace it with user-specified color, if
3572             # supplied.
3573             base_style.pop('color')
3574             if 'color' in kwargs:
3575                 base_style['color'] = kwargs.pop('color')
3576 
3577         if 'color' not in base_style:
3578             base_style['color'] = 'C0'
3579         if ecolor is None:
3580             ecolor = base_style['color']
3581 
3582         # Eject any line-specific information from format string, as it's not
3583         # needed for bars or caps.
3584         for key in ['marker', 'markersize', 'markerfacecolor',
3585                     'markerfacecoloralt',
3586                     'markeredgewidth', 'markeredgecolor', 'markevery',
3587                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3588                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3589                     'dashes']:
3590             base_style.pop(key, None)
3591 
3592         # Make the style dict for the line collections (the bars).
3593         eb_lines_style = {**base_style, 'color': ecolor}
3594 
3595         if elinewidth is not None:
3596             eb_lines_style['linewidth'] = elinewidth
3597         elif 'linewidth' in kwargs:
3598             eb_lines_style['linewidth'] = kwargs['linewidth']
3599 
3600         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3601             if key in kwargs:
3602                 eb_lines_style[key] = kwargs[key]
3603 
3604         # Make the style dict for caps (the "hats").
3605         eb_cap_style = {**base_style, 'linestyle': 'none'}
3606         if capsize is None:
3607             capsize = mpl.rcParams["errorbar.capsize"]
3608         if capsize > 0:
3609             eb_cap_style['markersize'] = 2. * capsize
3610         if capthick is not None:
3611             eb_cap_style['markeredgewidth'] = capthick
3612 
3613         # For backwards-compat, allow explicit setting of
3614         # 'markeredgewidth' to over-ride capthick.
3615         for key in ('markeredgewidth', 'transform', 'alpha',
3616                     'zorder', 'rasterized'):
3617             if key in kwargs:
3618                 eb_cap_style[key] = kwargs[key]
3619         eb_cap_style['color'] = ecolor
3620 
3621         barcols = []
3622         caplines = {'x': [], 'y': []}
3623 
3624         # Vectorized fancy-indexer.
3625         def apply_mask(arrays, mask):
3626             return [array[mask] for array in arrays]
3627 
3628         # dep: dependent dataset, indep: independent dataset
3629         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3630              marker, lomarker, himarker) in [
3631                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3632                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3633                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3634                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3635         ]:
3636             if err is None:
3637                 continue
3638             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3639             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3640             try:
3641                 np.broadcast_to(err, (2, len(dep)))
3642             except ValueError:
3643                 raise ValueError(
3644                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3645                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3646                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3647             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3648             if np.any(np.less(err, -err, out=res, where=(err == err))):
3649                 # like err<0, but also works for timedelta and nan.
3650                 raise ValueError(
3651                     f"'{dep_axis}err' must not contain negative values")
3652             # This is like
3653             #     elow, ehigh = np.broadcast_to(...)
3654             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3655             # except that broadcast_to would strip units.
3656             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3657             barcols.append(lines_func(
3658                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3659             if self.name == "polar" and dep_axis == "x":
3660                 for b in barcols:
3661                     for p in b.get_paths():
3662                         p._interpolation_steps = 2
3663             # Normal errorbars for points without upper/lower limits.
3664             nolims = ~(lolims | uplims)
3665             if nolims.any() and capsize > 0:
3666                 indep_masked, lo_masked, hi_masked = apply_mask(
3667                     [indep, low, high], nolims & everymask)
3668                 for lh_masked in [lo_masked, hi_masked]:
3669                     # Since this has to work for x and y as dependent data, we
3670                     # first set both x and y to the independent variable and
3671                     # overwrite the respective dependent data in a second step.
3672                     line = mlines.Line2D(indep_masked, indep_masked,
3673                                          marker=marker, **eb_cap_style)
3674                     line.set(**{f"{dep_axis}data": lh_masked})
3675                     caplines[dep_axis].append(line)
3676             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3677                 if not lims.any():
3678                     continue
3679                 hlmarker = (
3680                     himarker
3681                     if self._axis_map[dep_axis].get_inverted() ^ idx
3682                     else lomarker)
3683                 x_masked, y_masked, hl_masked = apply_mask(
3684                     [x, y, hl], lims & everymask)
3685                 # As above, we set the dependent data in a second step.
3686                 line = mlines.Line2D(x_masked, y_masked,
3687                                      marker=hlmarker, **eb_cap_style)
3688                 line.set(**{f"{dep_axis}data": hl_masked})
3689                 caplines[dep_axis].append(line)
3690                 if capsize > 0:
3691                     caplines[dep_axis].append(mlines.Line2D(
3692                         x_masked, y_masked, marker=marker, **eb_cap_style))
3693         if self.name == 'polar':
3694             for axis in caplines:
3695                 for l in caplines[axis]:
3696                     # Rotate caps to be perpendicular to the error bars
3697                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3698                         rotation = mtransforms.Affine2D().rotate(theta)
3699                         if axis == 'y':
3700                             rotation.rotate(-np.pi / 2)
3701                         ms = mmarkers.MarkerStyle(marker=marker,
3702                                                   transform=rotation)
3703                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3704                                                     **eb_cap_style))
3705         else:
3706             for axis in caplines:
3707                 for l in caplines[axis]:
3708                     self.add_line(l)
3709 
3710         self._request_autoscale_view()
3711         caplines = caplines['x'] + caplines['y']
3712         errorbar_container = ErrorbarContainer(
3713             (data_line, tuple(caplines), tuple(barcols)),
3714             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3715             label=label)
3716         self.containers.append(errorbar_container)
3717 
3718         return errorbar_container  # (l0, caplines, barcols)
3719 
3720     @_preprocess_data()
3721     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3722                 positions=None, widths=None, patch_artist=None,
3723                 bootstrap=None, usermedians=None, conf_intervals=None,
3724                 meanline=None, showmeans=None, showcaps=None,
3725                 showbox=None, showfliers=None, boxprops=None,
3726                 labels=None, flierprops=None, medianprops=None,
3727                 meanprops=None, capprops=None, whiskerprops=None,
3728                 manage_ticks=True, autorange=False, zorder=None,
3729                 capwidths=None):
3730         """
3731         Draw a box and whisker plot.
3732 
3733         The box extends from the first quartile (Q1) to the third
3734         quartile (Q3) of the data, with a line at the median.
3735         The whiskers extend from the box to the farthest data point
3736         lying within 1.5x the inter-quartile range (IQR) from the box.
3737         Flier points are those past the end of the whiskers.
3738         See https://en.wikipedia.org/wiki/Box_plot for reference.
3739 
3740         .. code-block:: none
3741 
3742                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3743                                |-----:-----|
3744                o      |--------|     :     |--------|    o  o
3745                                |-----:-----|
3746              flier             <----------->            fliers
3747                                     IQR
3748 
3749 
3750         Parameters
3751         ----------
3752         x : Array or a sequence of vectors.
3753             The input data.  If a 2D array, a boxplot is drawn for each column
3754             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3755             array in *x*.
3756 
3757         notch : bool, default: False
3758             Whether to draw a notched boxplot (`True`), or a rectangular
3759             boxplot (`False`).  The notches represent the confidence interval
3760             (CI) around the median.  The documentation for *bootstrap*
3761             describes how the locations of the notches are computed by
3762             default, but their locations may also be overridden by setting the
3763             *conf_intervals* parameter.
3764 
3765             .. note::
3766 
3767                 In cases where the values of the CI are less than the
3768                 lower quartile or greater than the upper quartile, the
3769                 notches will extend beyond the box, giving it a
3770                 distinctive "flipped" appearance. This is expected
3771                 behavior and consistent with other statistical
3772                 visualization packages.
3773 
3774         sym : str, optional
3775             The default symbol for flier points.  An empty string ('') hides
3776             the fliers.  If `None`, then the fliers default to 'b+'.  More
3777             control is provided by the *flierprops* parameter.
3778 
3779         vert : bool, default: True
3780             If `True`, draws vertical boxes.
3781             If `False`, draw horizontal boxes.
3782 
3783         whis : float or (float, float), default: 1.5
3784             The position of the whiskers.
3785 
3786             If a float, the lower whisker is at the lowest datum above
3787             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3788             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3789             third quartiles.  The default value of ``whis = 1.5`` corresponds
3790             to Tukey's original definition of boxplots.
3791 
3792             If a pair of floats, they indicate the percentiles at which to
3793             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3794             (0, 100) results in whiskers covering the whole range of the data.
3795 
3796             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3797             to (0, 100) (cover the whole range of the data) if *autorange* is
3798             True.
3799 
3800             Beyond the whiskers, data are considered outliers and are plotted
3801             as individual points.
3802 
3803         bootstrap : int, optional
3804             Specifies whether to bootstrap the confidence intervals
3805             around the median for notched boxplots. If *bootstrap* is
3806             None, no bootstrapping is performed, and notches are
3807             calculated using a Gaussian-based asymptotic approximation
3808             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3809             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3810             the number of times to bootstrap the median to determine its
3811             95% confidence intervals. Values between 1000 and 10000 are
3812             recommended.
3813 
3814         usermedians : 1D array-like, optional
3815             A 1D array-like of length ``len(x)``.  Each entry that is not
3816             `None` forces the value of the median for the corresponding
3817             dataset.  For entries that are `None`, the medians are computed
3818             by Matplotlib as normal.
3819 
3820         conf_intervals : array-like, optional
3821             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3822             None forces the location of the corresponding notch (which is
3823             only drawn if *notch* is `True`).  For entries that are `None`,
3824             the notches are computed by the method specified by the other
3825             parameters (e.g., *bootstrap*).
3826 
3827         positions : array-like, optional
3828             The positions of the boxes. The ticks and limits are
3829             automatically set to match the positions. Defaults to
3830             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3831 
3832         widths : float or array-like
3833             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3834             between extreme positions)``, if that is smaller.
3835 
3836         patch_artist : bool, default: False
3837             If `False` produces boxes with the Line2D artist. Otherwise,
3838             boxes are drawn with Patch artists.
3839 
3840         labels : sequence, optional
3841             Labels for each dataset (one per dataset).
3842 
3843         manage_ticks : bool, default: True
3844             If True, the tick locations and labels will be adjusted to match
3845             the boxplot positions.
3846 
3847         autorange : bool, default: False
3848             When `True` and the data are distributed such that the 25th and
3849             75th percentiles are equal, *whis* is set to (0, 100) such
3850             that the whisker ends are at the minimum and maximum of the data.
3851 
3852         meanline : bool, default: False
3853             If `True` (and *showmeans* is `True`), will try to render the
3854             mean as a line spanning the full width of the box according to
3855             *meanprops* (see below).  Not recommended if *shownotches* is also
3856             True.  Otherwise, means will be shown as points.
3857 
3858         zorder : float, default: ``Line2D.zorder = 2``
3859             The zorder of the boxplot.
3860 
3861         Returns
3862         -------
3863         dict
3864           A dictionary mapping each component of the boxplot to a list
3865           of the `.Line2D` instances created. That dictionary has the
3866           following keys (assuming vertical boxplots):
3867 
3868           - ``boxes``: the main body of the boxplot showing the
3869             quartiles and the median's confidence intervals if
3870             enabled.
3871 
3872           - ``medians``: horizontal lines at the median of each box.
3873 
3874           - ``whiskers``: the vertical lines extending to the most
3875             extreme, non-outlier data points.
3876 
3877           - ``caps``: the horizontal lines at the ends of the
3878             whiskers.
3879 
3880           - ``fliers``: points representing data that extend beyond
3881             the whiskers (fliers).
3882 
3883           - ``means``: points or lines representing the means.
3884 
3885         Other Parameters
3886         ----------------
3887         showcaps : bool, default: True
3888             Show the caps on the ends of whiskers.
3889         showbox : bool, default: True
3890             Show the central box.
3891         showfliers : bool, default: True
3892             Show the outliers beyond the caps.
3893         showmeans : bool, default: False
3894             Show the arithmetic means.
3895         capprops : dict, default: None
3896             The style of the caps.
3897         capwidths : float or array, default: None
3898             The widths of the caps.
3899         boxprops : dict, default: None
3900             The style of the box.
3901         whiskerprops : dict, default: None
3902             The style of the whiskers.
3903         flierprops : dict, default: None
3904             The style of the fliers.
3905         medianprops : dict, default: None
3906             The style of the median.
3907         meanprops : dict, default: None
3908             The style of the mean.
3909         data : indexable object, optional
3910             DATA_PARAMETER_PLACEHOLDER
3911 
3912         See Also
3913         --------
3914         violinplot : Draw an estimate of the probability density function.
3915         """
3916 
3917         # Missing arguments default to rcParams.
3918         if whis is None:
3919             whis = mpl.rcParams['boxplot.whiskers']
3920         if bootstrap is None:
3921             bootstrap = mpl.rcParams['boxplot.bootstrap']
3922 
3923         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3924                                        labels=labels, autorange=autorange)
3925         if notch is None:
3926             notch = mpl.rcParams['boxplot.notch']
3927         if vert is None:
3928             vert = mpl.rcParams['boxplot.vertical']
3929         if patch_artist is None:
3930             patch_artist = mpl.rcParams['boxplot.patchartist']
3931         if meanline is None:
3932             meanline = mpl.rcParams['boxplot.meanline']
3933         if showmeans is None:
3934             showmeans = mpl.rcParams['boxplot.showmeans']
3935         if showcaps is None:
3936             showcaps = mpl.rcParams['boxplot.showcaps']
3937         if showbox is None:
3938             showbox = mpl.rcParams['boxplot.showbox']
3939         if showfliers is None:
3940             showfliers = mpl.rcParams['boxplot.showfliers']
3941 
3942         if boxprops is None:
3943             boxprops = {}
3944         if whiskerprops is None:
3945             whiskerprops = {}
3946         if capprops is None:
3947             capprops = {}
3948         if medianprops is None:
3949             medianprops = {}
3950         if meanprops is None:
3951             meanprops = {}
3952         if flierprops is None:
3953             flierprops = {}
3954 
3955         if patch_artist:
3956             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3957             if 'color' in boxprops:
3958                 boxprops['edgecolor'] = boxprops.pop('color')
3959 
3960         # if non-default sym value, put it into the flier dictionary
3961         # the logic for providing the default symbol ('b+') now lives
3962         # in bxp in the initial value of flierkw
3963         # handle all of the *sym* related logic here so we only have to pass
3964         # on the flierprops dict.
3965         if sym is not None:
3966             # no-flier case, which should really be done with
3967             # 'showfliers=False' but none-the-less deal with it to keep back
3968             # compatibility
3969             if sym == '':
3970                 # blow away existing dict and make one for invisible markers
3971                 flierprops = dict(linestyle='none', marker='', color='none')
3972                 # turn the fliers off just to be safe
3973                 showfliers = False
3974             # now process the symbol string
3975             else:
3976                 # process the symbol string
3977                 # discarded linestyle
3978                 _, marker, color = _process_plot_format(sym)
3979                 # if we have a marker, use it
3980                 if marker is not None:
3981                     flierprops['marker'] = marker
3982                 # if we have a color, use it
3983                 if color is not None:
3984                     # assume that if color is passed in the user want
3985                     # filled symbol, if the users want more control use
3986                     # flierprops
3987                     flierprops['color'] = color
3988                     flierprops['markerfacecolor'] = color
3989                     flierprops['markeredgecolor'] = color
3990 
3991         # replace medians if necessary:
3992         if usermedians is not None:
3993             if (len(np.ravel(usermedians)) != len(bxpstats) or
3994                     np.shape(usermedians)[0] != len(bxpstats)):
3995                 raise ValueError(
3996                     "'usermedians' and 'x' have different lengths")
3997             else:
3998                 # reassign medians as necessary
3999                 for stats, med in zip(bxpstats, usermedians):
4000                     if med is not None:
4001                         stats['med'] = med
4002 
4003         if conf_intervals is not None:
4004             if len(conf_intervals) != len(bxpstats):
4005                 raise ValueError(
4006                     "'conf_intervals' and 'x' have different lengths")
4007             else:
4008                 for stats, ci in zip(bxpstats, conf_intervals):
4009                     if ci is not None:
4010                         if len(ci) != 2:
4011                             raise ValueError('each confidence interval must '
4012                                              'have two values')
4013                         else:
4014                             if ci[0] is not None:
4015                                 stats['cilo'] = ci[0]
4016                             if ci[1] is not None:
4017                                 stats['cihi'] = ci[1]
4018 
4019         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4020                            vert=vert, patch_artist=patch_artist,
4021                            shownotches=notch, showmeans=showmeans,
4022                            showcaps=showcaps, showbox=showbox,
4023                            boxprops=boxprops, flierprops=flierprops,
4024                            medianprops=medianprops, meanprops=meanprops,
4025                            meanline=meanline, showfliers=showfliers,
4026                            capprops=capprops, whiskerprops=whiskerprops,
4027                            manage_ticks=manage_ticks, zorder=zorder,
4028                            capwidths=capwidths)
4029         return artists
4030 
4031     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4032             patch_artist=False, shownotches=False, showmeans=False,
4033             showcaps=True, showbox=True, showfliers=True,
4034             boxprops=None, whiskerprops=None, flierprops=None,
4035             medianprops=None, capprops=None, meanprops=None,
4036             meanline=False, manage_ticks=True, zorder=None,
4037             capwidths=None):
4038         """
4039         Drawing function for box and whisker plots.
4040 
4041         Make a box and whisker plot for each column of *x* or each
4042         vector in sequence *x*.  The box extends from the lower to
4043         upper quartile values of the data, with a line at the median.
4044         The whiskers extend from the box to show the range of the
4045         data.  Flier points are those past the end of the whiskers.
4046 
4047         Parameters
4048         ----------
4049         bxpstats : list of dicts
4050           A list of dictionaries containing stats for each boxplot.
4051           Required keys are:
4052 
4053           - ``med``: Median (scalar).
4054           - ``q1``, ``q3``: First & third quartiles (scalars).
4055           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4056 
4057           Optional keys are:
4058 
4059           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4060           - ``fliers``: Data beyond the whiskers (array-like).
4061             Needed if ``showfliers=True``.
4062           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4063             about the median. Needed if ``shownotches=True``.
4064           - ``label``: Name of the dataset (str).  If available,
4065             this will be used a tick label for the boxplot
4066 
4067         positions : array-like, default: [1, 2, ..., n]
4068           The positions of the boxes. The ticks and limits
4069           are automatically set to match the positions.
4070 
4071         widths : float or array-like, default: None
4072           The widths of the boxes.  The default is
4073           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4074 
4075         capwidths : float or array-like, default: None
4076           Either a scalar or a vector and sets the width of each cap.
4077           The default is ``0.5*(with of the box)``, see *widths*.
4078 
4079         vert : bool, default: True
4080           If `True` (default), makes the boxes vertical.
4081           If `False`, makes horizontal boxes.
4082 
4083         patch_artist : bool, default: False
4084           If `False` produces boxes with the `.Line2D` artist.
4085           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4086 
4087         shownotches, showmeans, showcaps, showbox, showfliers : bool
4088           Whether to draw the CI notches, the mean value (both default to
4089           False), the caps, the box, and the fliers (all three default to
4090           True).
4091 
4092         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4093  dict, optional
4094           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4095           means.
4096 
4097         meanline : bool, default: False
4098           If `True` (and *showmeans* is `True`), will try to render the mean
4099           as a line spanning the full width of the box according to
4100           *meanprops*. Not recommended if *shownotches* is also True.
4101           Otherwise, means will be shown as points.
4102 
4103         manage_ticks : bool, default: True
4104           If True, the tick locations and labels will be adjusted to match the
4105           boxplot positions.
4106 
4107         zorder : float, default: ``Line2D.zorder = 2``
4108           The zorder of the resulting boxplot.
4109 
4110         Returns
4111         -------
4112         dict
4113           A dictionary mapping each component of the boxplot to a list
4114           of the `.Line2D` instances created. That dictionary has the
4115           following keys (assuming vertical boxplots):
4116 
4117           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4118             the median's confidence intervals if enabled.
4119           - ``medians``: horizontal lines at the median of each box.
4120           - ``whiskers``: vertical lines up to the last non-outlier data.
4121           - ``caps``: horizontal lines at the ends of the whiskers.
4122           - ``fliers``: points representing data beyond the whiskers (fliers).
4123           - ``means``: points or lines representing the means.
4124 
4125         Examples
4126         --------
4127         .. plot:: gallery/statistics/bxp.py
4128         """
4129 
4130         # lists of artists to be output
4131         whiskers = []
4132         caps = []
4133         boxes = []
4134         medians = []
4135         means = []
4136         fliers = []
4137 
4138         # empty list of xticklabels
4139         datalabels = []
4140 
4141         # Use default zorder if none specified
4142         if zorder is None:
4143             zorder = mlines.Line2D.zorder
4144 
4145         zdelta = 0.1
4146 
4147         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4148             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4149                  if k.startswith(f'boxplot.{subkey}props')}
4150             d['zorder'] = zorder + zdelta
4151             if not usemarker:
4152                 d['marker'] = ''
4153             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4154             return d
4155 
4156         box_kw = {
4157             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4158             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4159             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4160             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4161                           else mpl.rcParams['patch.facecolor']),
4162             'zorder': zorder,
4163             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4164         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4165         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4166         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4167         flier_kw = merge_kw_rc('flier', flierprops)
4168         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4169         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4170         removed_prop = 'marker' if meanline else 'linestyle'
4171         # Only remove the property if it's not set explicitly as a parameter.
4172         if meanprops is None or removed_prop not in meanprops:
4173             mean_kw[removed_prop] = ''
4174 
4175         # vertical or horizontal plot?
4176         maybe_swap = slice(None) if vert else slice(None, None, -1)
4177 
4178         def do_plot(xs, ys, **kwargs):
4179             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4180 
4181         def do_patch(xs, ys, **kwargs):
4182             path = mpath.Path._create_closed(
4183                 np.column_stack([xs, ys][maybe_swap]))
4184             patch = mpatches.PathPatch(path, **kwargs)
4185             self.add_artist(patch)
4186             return patch
4187 
4188         # input validation
4189         N = len(bxpstats)
4190         datashape_message = ("List of boxplot statistics and `{0}` "
4191                              "values must have same the length")
4192         # check position
4193         if positions is None:
4194             positions = list(range(1, N + 1))
4195         elif len(positions) != N:
4196             raise ValueError(datashape_message.format("positions"))
4197 
4198         positions = np.array(positions)
4199         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4200             raise TypeError("positions should be an iterable of numbers")
4201 
4202         # width
4203         if widths is None:
4204             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4205         elif np.isscalar(widths):
4206             widths = [widths] * N
4207         elif len(widths) != N:
4208             raise ValueError(datashape_message.format("widths"))
4209 
4210         # capwidth
4211         if capwidths is None:
4212             capwidths = 0.5 * np.array(widths)
4213         elif np.isscalar(capwidths):
4214             capwidths = [capwidths] * N
4215         elif len(capwidths) != N:
4216             raise ValueError(datashape_message.format("capwidths"))
4217 
4218         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4219                                                capwidths):
4220             # try to find a new label
4221             datalabels.append(stats.get('label', pos))
4222 
4223             # whisker coords
4224             whis_x = [pos, pos]
4225             whislo_y = [stats['q1'], stats['whislo']]
4226             whishi_y = [stats['q3'], stats['whishi']]
4227             # cap coords
4228             cap_left = pos - capwidth * 0.5
4229             cap_right = pos + capwidth * 0.5
4230             cap_x = [cap_left, cap_right]
4231             cap_lo = np.full(2, stats['whislo'])
4232             cap_hi = np.full(2, stats['whishi'])
4233             # box and median coords
4234             box_left = pos - width * 0.5
4235             box_right = pos + width * 0.5
4236             med_y = [stats['med'], stats['med']]
4237             # notched boxes
4238             if shownotches:
4239                 notch_left = pos - width * 0.25
4240                 notch_right = pos + width * 0.25
4241                 box_x = [box_left, box_right, box_right, notch_right,
4242                          box_right, box_right, box_left, box_left, notch_left,
4243                          box_left, box_left]
4244                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4245                          stats['med'], stats['cihi'], stats['q3'],
4246                          stats['q3'], stats['cihi'], stats['med'],
4247                          stats['cilo'], stats['q1']]
4248                 med_x = [notch_left, notch_right]
4249             # plain boxes
4250             else:
4251                 box_x = [box_left, box_right, box_right, box_left, box_left]
4252                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4253                          stats['q1']]
4254                 med_x = [box_left, box_right]
4255 
4256             # maybe draw the box
4257             if showbox:
4258                 do_box = do_patch if patch_artist else do_plot
4259                 boxes.append(do_box(box_x, box_y, **box_kw))
4260             # draw the whiskers
4261             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4262             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4263             # maybe draw the caps
4264             if showcaps:
4265                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4266                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4267             # draw the medians
4268             medians.append(do_plot(med_x, med_y, **median_kw))
4269             # maybe draw the means
4270             if showmeans:
4271                 if meanline:
4272                     means.append(do_plot(
4273                         [box_left, box_right], [stats['mean'], stats['mean']],
4274                         **mean_kw
4275                     ))
4276                 else:
4277                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4278             # maybe draw the fliers
4279             if showfliers:
4280                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4281                 flier_y = stats['fliers']
4282                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4283 
4284         if manage_ticks:
4285             axis_name = "x" if vert else "y"
4286             interval = getattr(self.dataLim, f"interval{axis_name}")
4287             axis = self._axis_map[axis_name]
4288             positions = axis.convert_units(positions)
4289             # The 0.5 additional padding ensures reasonable-looking boxes
4290             # even when drawing a single box.  We set the sticky edge to
4291             # prevent margins expansion, in order to match old behavior (back
4292             # when separate calls to boxplot() would completely reset the axis
4293             # limits regardless of what was drawn before).  The sticky edges
4294             # are attached to the median lines, as they are always present.
4295             interval[:] = (min(interval[0], min(positions) - .5),
4296                            max(interval[1], max(positions) + .5))
4297             for median, position in zip(medians, positions):
4298                 getattr(median.sticky_edges, axis_name).extend(
4299                     [position - .5, position + .5])
4300             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4301             locator = axis.get_major_locator()
4302             if not isinstance(axis.get_major_locator(),
4303                               mticker.FixedLocator):
4304                 locator = mticker.FixedLocator([])
4305                 axis.set_major_locator(locator)
4306             locator.locs = np.array([*locator.locs, *positions])
4307             formatter = axis.get_major_formatter()
4308             if not isinstance(axis.get_major_formatter(),
4309                               mticker.FixedFormatter):
4310                 formatter = mticker.FixedFormatter([])
4311                 axis.set_major_formatter(formatter)
4312             formatter.seq = [*formatter.seq, *datalabels]
4313 
4314             self._request_autoscale_view()
4315 
4316         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4317                     medians=medians, fliers=fliers, means=means)
4318 
4319     @staticmethod
4320     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4321                                   get_next_color_func):
4322         """
4323         Helper function to process color related arguments of `.Axes.scatter`.
4324 
4325         Argument precedence for facecolors:
4326 
4327         - c (if not None)
4328         - kwargs['facecolor']
4329         - kwargs['facecolors']
4330         - kwargs['color'] (==kwcolor)
4331         - 'b' if in classic mode else the result of ``get_next_color_func()``
4332 
4333         Argument precedence for edgecolors:
4334 
4335         - kwargs['edgecolor']
4336         - edgecolors (is an explicit kw argument in scatter())
4337         - kwargs['color'] (==kwcolor)
4338         - 'face' if not in classic mode else None
4339 
4340         Parameters
4341         ----------
4342         c : color or sequence or sequence of color or None
4343             See argument description of `.Axes.scatter`.
4344         edgecolors : color or sequence of color or {'face', 'none'} or None
4345             See argument description of `.Axes.scatter`.
4346         kwargs : dict
4347             Additional kwargs. If these keys exist, we pop and process them:
4348             'facecolors', 'facecolor', 'edgecolor', 'color'
4349             Note: The dict is modified by this function.
4350         xsize : int
4351             The size of the x and y arrays passed to `.Axes.scatter`.
4352         get_next_color_func : callable
4353             A callable that returns a color. This color is used as facecolor
4354             if no other color is provided.
4355 
4356             Note, that this is a function rather than a fixed color value to
4357             support conditional evaluation of the next color.  As of the
4358             current implementation obtaining the next color from the
4359             property cycle advances the cycle. This must only happen if we
4360             actually use the color, which will only be decided within this
4361             method.
4362 
4363         Returns
4364         -------
4365         c
4366             The input *c* if it was not *None*, else a color derived from the
4367             other inputs or defaults.
4368         colors : array(N, 4) or None
4369             The facecolors as RGBA values, or *None* if a colormap is used.
4370         edgecolors
4371             The edgecolor.
4372 
4373         """
4374         facecolors = kwargs.pop('facecolors', None)
4375         facecolors = kwargs.pop('facecolor', facecolors)
4376         edgecolors = kwargs.pop('edgecolor', edgecolors)
4377 
4378         kwcolor = kwargs.pop('color', None)
4379 
4380         if kwcolor is not None and c is not None:
4381             raise ValueError("Supply a 'c' argument or a 'color'"
4382                              " kwarg but not both; they differ but"
4383                              " their functionalities overlap.")
4384 
4385         if kwcolor is not None:
4386             try:
4387                 mcolors.to_rgba_array(kwcolor)
4388             except ValueError as err:
4389                 raise ValueError(
4390                     "'color' kwarg must be a color or sequence of color "
4391                     "specs.  For a sequence of values to be color-mapped, use "
4392                     "the 'c' argument instead.") from err
4393             if edgecolors is None:
4394                 edgecolors = kwcolor
4395             if facecolors is None:
4396                 facecolors = kwcolor
4397 
4398         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4399             edgecolors = mpl.rcParams['scatter.edgecolors']
4400 
4401         c_was_none = c is None
4402         if c is None:
4403             c = (facecolors if facecolors is not None
4404                  else "b" if mpl.rcParams['_internal.classic_mode']
4405                  else get_next_color_func())
4406         c_is_string_or_strings = (
4407             isinstance(c, str)
4408             or (np.iterable(c) and len(c) > 0
4409                 and isinstance(cbook._safe_first_finite(c), str)))
4410 
4411         def invalid_shape_exception(csize, xsize):
4412             return ValueError(
4413                 f"'c' argument has {csize} elements, which is inconsistent "
4414                 f"with 'x' and 'y' with size {xsize}.")
4415 
4416         c_is_mapped = False  # Unless proven otherwise below.
4417         valid_shape = True  # Unless proven otherwise below.
4418         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4419             try:  # First, does 'c' look suitable for value-mapping?
4420                 c = np.asanyarray(c, dtype=float)
4421             except ValueError:
4422                 pass  # Failed to convert to float array; must be color specs.
4423             else:
4424                 # handle the documented special case of a 2D array with 1
4425                 # row which as RGB(A) to broadcast.
4426                 if c.shape == (1, 4) or c.shape == (1, 3):
4427                     c_is_mapped = False
4428                     if c.size != xsize:
4429                         valid_shape = False
4430                 # If c can be either mapped values or an RGB(A) color, prefer
4431                 # the former if shapes match, the latter otherwise.
4432                 elif c.size == xsize:
4433                     c = c.ravel()
4434                     c_is_mapped = True
4435                 else:  # Wrong size; it must not be intended for mapping.
4436                     if c.shape in ((3,), (4,)):
4437                         _api.warn_external(
4438                             "*c* argument looks like a single numeric RGB or "
4439                             "RGBA sequence, which should be avoided as value-"
4440                             "mapping will have precedence in case its length "
4441                             "matches with *x* & *y*.  Please use the *color* "
4442                             "keyword-argument or provide a 2D array "
4443                             "with a single row if you intend to specify "
4444                             "the same RGB or RGBA value for all points.")
4445                     valid_shape = False
4446         if not c_is_mapped:
4447             try:  # Is 'c' acceptable as PathCollection facecolors?
4448                 colors = mcolors.to_rgba_array(c)
4449             except (TypeError, ValueError) as err:
4450                 if "RGBA values should be within 0-1 range" in str(err):
4451                     raise
4452                 else:
4453                     if not valid_shape:
4454                         raise invalid_shape_exception(c.size, xsize) from err
4455                     # Both the mapping *and* the RGBA conversion failed: pretty
4456                     # severe failure => one may appreciate a verbose feedback.
4457                     raise ValueError(
4458                         f"'c' argument must be a color, a sequence of colors, "
4459                         f"or a sequence of numbers, not {c!r}") from err
4460             else:
4461                 if len(colors) not in (0, 1, xsize):
4462                     # NB: remember that a single color is also acceptable.
4463                     # Besides *colors* will be an empty array if c == 'none'.
4464                     raise invalid_shape_exception(len(colors), xsize)
4465         else:
4466             colors = None  # use cmap, norm after collection is created
4467         return c, colors, edgecolors
4468 
4469     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4470                                      "edgecolors", "c", "facecolor",
4471                                      "facecolors", "color"],
4472                       label_namer="y")
4473     @_docstring.interpd
4474     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4475                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4476                 edgecolors=None, plotnonfinite=False, **kwargs):
4477         """
4478         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4479 
4480         Parameters
4481         ----------
4482         x, y : float or array-like, shape (n, )
4483             The data positions.
4484 
4485         s : float or array-like, shape (n, ), optional
4486             The marker size in points**2 (typographic points are 1/72 in.).
4487             Default is ``rcParams['lines.markersize'] ** 2``.
4488 
4489             The linewidth and edgecolor can visually interact with the marker
4490             size, and can lead to artifacts if the marker size is smaller than
4491             the linewidth.
4492 
4493             If the linewidth is greater than 0 and the edgecolor is anything
4494             but *'none'*, then the effective size of the marker will be
4495             increased by half the linewidth because the stroke will be centered
4496             on the edge of the shape.
4497 
4498             To eliminate the marker edge either set *linewidth=0* or
4499             *edgecolor='none'*.
4500 
4501         c : array-like or list of colors or color, optional
4502             The marker colors. Possible values:
4503 
4504             - A scalar or sequence of n numbers to be mapped to colors using
4505               *cmap* and *norm*.
4506             - A 2D array in which the rows are RGB or RGBA.
4507             - A sequence of colors of length n.
4508             - A single color format string.
4509 
4510             Note that *c* should not be a single numeric RGB or RGBA sequence
4511             because that is indistinguishable from an array of values to be
4512             colormapped. If you want to specify the same RGB or RGBA value for
4513             all points, use a 2D array with a single row.  Otherwise,
4514             value-matching will have precedence in case of a size matching with
4515             *x* and *y*.
4516 
4517             If you wish to specify a single color for all points
4518             prefer the *color* keyword argument.
4519 
4520             Defaults to `None`. In that case the marker color is determined
4521             by the value of *color*, *facecolor* or *facecolors*. In case
4522             those are not specified or `None`, the marker color is determined
4523             by the next color of the ``Axes``' current "shape and fill" color
4524             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4525 
4526         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4527             The marker style. *marker* can be either an instance of the class
4528             or the text shorthand for a particular marker.
4529             See :mod:`matplotlib.markers` for more information about marker
4530             styles.
4531 
4532         %(cmap_doc)s
4533 
4534             This parameter is ignored if *c* is RGB(A).
4535 
4536         %(norm_doc)s
4537 
4538             This parameter is ignored if *c* is RGB(A).
4539 
4540         %(vmin_vmax_doc)s
4541 
4542             This parameter is ignored if *c* is RGB(A).
4543 
4544         alpha : float, default: None
4545             The alpha blending value, between 0 (transparent) and 1 (opaque).
4546 
4547         linewidths : float or array-like, default: :rc:`lines.linewidth`
4548             The linewidth of the marker edges. Note: The default *edgecolors*
4549             is 'face'. You may want to change this as well.
4550 
4551         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4552 default: :rc:`scatter.edgecolors`
4553             The edge color of the marker. Possible values:
4554 
4555             - 'face': The edge color will always be the same as the face color.
4556             - 'none': No patch boundary will be drawn.
4557             - A color or sequence of colors.
4558 
4559             For non-filled markers, *edgecolors* is ignored. Instead, the color
4560             is determined like with 'face', i.e. from *c*, *colors*, or
4561             *facecolors*.
4562 
4563         plotnonfinite : bool, default: False
4564             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4565             or ``nan``). If ``True`` the points are drawn with the *bad*
4566             colormap color (see `.Colormap.set_bad`).
4567 
4568         Returns
4569         -------
4570         `~matplotlib.collections.PathCollection`
4571 
4572         Other Parameters
4573         ----------------
4574         data : indexable object, optional
4575             DATA_PARAMETER_PLACEHOLDER
4576         **kwargs : `~matplotlib.collections.Collection` properties
4577 
4578         See Also
4579         --------
4580         plot : To plot scatter plots when markers are identical in size and
4581             color.
4582 
4583         Notes
4584         -----
4585         * The `.plot` function will be faster for scatterplots where markers
4586           don't vary in size or color.
4587 
4588         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4589           case all masks will be combined and only unmasked points will be
4590           plotted.
4591 
4592         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4593           may be input as N-D arrays, but within scatter they will be
4594           flattened. The exception is *c*, which will be flattened only if its
4595           size matches the size of *x* and *y*.
4596 
4597         """
4598         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4599         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4600         # np.ma.ravel yields an ndarray, not a masked array,
4601         # unless its argument is a masked array.
4602         x = np.ma.ravel(x)
4603         y = np.ma.ravel(y)
4604         if x.size != y.size:
4605             raise ValueError("x and y must be the same size")
4606 
4607         if s is None:
4608             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4609                  mpl.rcParams['lines.markersize'] ** 2.0)
4610         s = np.ma.ravel(s)
4611         if (len(s) not in (1, x.size) or
4612                 (not np.issubdtype(s.dtype, np.floating) and
4613                  not np.issubdtype(s.dtype, np.integer))):
4614             raise ValueError(
4615                 "s must be a scalar, "
4616                 "or float array-like with the same size as x and y")
4617 
4618         # get the original edgecolor the user passed before we normalize
4619         orig_edgecolor = edgecolors
4620         if edgecolors is None:
4621             orig_edgecolor = kwargs.get('edgecolor', None)
4622         c, colors, edgecolors = \
4623             self._parse_scatter_color_args(
4624                 c, edgecolors, kwargs, x.size,
4625                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4626 
4627         if plotnonfinite and colors is None:
4628             c = np.ma.masked_invalid(c)
4629             x, y, s, edgecolors, linewidths = \
4630                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4631         else:
4632             x, y, s, c, colors, edgecolors, linewidths = \
4633                 cbook._combine_masks(
4634                     x, y, s, c, colors, edgecolors, linewidths)
4635         # Unmask edgecolors if it was actually a single RGB or RGBA.
4636         if (x.size in (3, 4)
4637                 and np.ma.is_masked(edgecolors)
4638                 and not np.ma.is_masked(orig_edgecolor)):
4639             edgecolors = edgecolors.data
4640 
4641         scales = s   # Renamed for readability below.
4642 
4643         # load default marker from rcParams
4644         if marker is None:
4645             marker = mpl.rcParams['scatter.marker']
4646 
4647         if isinstance(marker, mmarkers.MarkerStyle):
4648             marker_obj = marker
4649         else:
4650             marker_obj = mmarkers.MarkerStyle(marker)
4651 
4652         path = marker_obj.get_path().transformed(
4653             marker_obj.get_transform())
4654         if not marker_obj.is_filled():
4655             if orig_edgecolor is not None:
4656                 _api.warn_external(
4657                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4658                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4659                     "ignoring the edgecolor in favor of the facecolor.  This "
4660                     "behavior may change in the future."
4661                 )
4662             # We need to handle markers that cannot be filled (like
4663             # '+' and 'x') differently than markers that can be
4664             # filled, but have their fillstyle set to 'none'.  This is
4665             # to get:
4666             #
4667             #  - respecting the fillestyle if set
4668             #  - maintaining back-compatibility for querying the facecolor of
4669             #    the un-fillable markers.
4670             #
4671             # While not an ideal situation, but is better than the
4672             # alternatives.
4673             if marker_obj.get_fillstyle() == 'none':
4674                 # promote the facecolor to be the edgecolor
4675                 edgecolors = colors
4676                 # set the facecolor to 'none' (at the last chance) because
4677                 # we cannot fill a path if the facecolor is non-null
4678                 # (which is defendable at the renderer level).
4679                 colors = 'none'
4680             else:
4681                 # if we are not nulling the face color we can do this
4682                 # simpler
4683                 edgecolors = 'face'
4684 
4685             if linewidths is None:
4686                 linewidths = mpl.rcParams['lines.linewidth']
4687             elif np.iterable(linewidths):
4688                 linewidths = [
4689                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4690                     for lw in linewidths]
4691 
4692         offsets = np.ma.column_stack([x, y])
4693 
4694         collection = mcoll.PathCollection(
4695             (path,), scales,
4696             facecolors=colors,
4697             edgecolors=edgecolors,
4698             linewidths=linewidths,
4699             offsets=offsets,
4700             offset_transform=kwargs.pop('transform', self.transData),
4701             alpha=alpha,
4702         )
4703         collection.set_transform(mtransforms.IdentityTransform())
4704         if colors is None:
4705             collection.set_array(c)
4706             collection.set_cmap(cmap)
4707             collection.set_norm(norm)
4708             collection._scale_norm(norm, vmin, vmax)
4709         else:
4710             extra_kwargs = {
4711                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4712                     }
4713             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4714             if any(extra_keys):
4715                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4716                 _api.warn_external(
4717                     "No data for colormapping provided via 'c'. "
4718                     f"Parameters {keys_str} will be ignored")
4719         collection._internal_update(kwargs)
4720 
4721         # Classic mode only:
4722         # ensure there are margins to allow for the
4723         # finite size of the symbols.  In v2.x, margins
4724         # are present by default, so we disable this
4725         # scatter-specific override.
4726         if mpl.rcParams['_internal.classic_mode']:
4727             if self._xmargin < 0.05 and x.size > 0:
4728                 self.set_xmargin(0.05)
4729             if self._ymargin < 0.05 and x.size > 0:
4730                 self.set_ymargin(0.05)
4731 
4732         self.add_collection(collection)
4733         self._request_autoscale_view()
4734 
4735         return collection
4736 
4737     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4738     @_docstring.dedent_interpd
4739     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4740                xscale='linear', yscale='linear', extent=None,
4741                cmap=None, norm=None, vmin=None, vmax=None,
4742                alpha=None, linewidths=None, edgecolors='face',
4743                reduce_C_function=np.mean, mincnt=None, marginals=False,
4744                **kwargs):
4745         """
4746         Make a 2D hexagonal binning plot of points *x*, *y*.
4747 
4748         If *C* is *None*, the value of the hexagon is determined by the number
4749         of points in the hexagon. Otherwise, *C* specifies values at the
4750         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4751         using *reduce_C_function*.
4752 
4753         Parameters
4754         ----------
4755         x, y : array-like
4756             The data positions. *x* and *y* must be of the same length.
4757 
4758         C : array-like, optional
4759             If given, these values are accumulated in the bins. Otherwise,
4760             every point has a value of 1. Must be of the same length as *x*
4761             and *y*.
4762 
4763         gridsize : int or (int, int), default: 100
4764             If a single int, the number of hexagons in the *x*-direction.
4765             The number of hexagons in the *y*-direction is chosen such that
4766             the hexagons are approximately regular.
4767 
4768             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4769             in the *x*-direction and the *y*-direction. In the
4770             *y*-direction, counting is done along vertically aligned
4771             hexagons, not along the zig-zag chains of hexagons; see the
4772             following illustration.
4773 
4774             .. plot::
4775 
4776                import numpy
4777                import matplotlib.pyplot as plt
4778 
4779                np.random.seed(19680801)
4780                n= 300
4781                x = np.random.standard_normal(n)
4782                y = np.random.standard_normal(n)
4783 
4784                fig, ax = plt.subplots(figsize=(4, 4))
4785                h = ax.hexbin(x, y, gridsize=(5, 3))
4786                hx, hy = h.get_offsets().T
4787                ax.plot(hx[24::3], hy[24::3], 'ro-')
4788                ax.plot(hx[-3:], hy[-3:], 'ro-')
4789                ax.set_title('gridsize=(5, 3)')
4790                ax.axis('off')
4791 
4792             To get approximately regular hexagons, choose
4793             :math:`n_x = \\sqrt{3}\\,n_y`.
4794 
4795         bins : 'log' or int or sequence, default: None
4796             Discretization of the hexagon values.
4797 
4798             - If *None*, no binning is applied; the color of each hexagon
4799               directly corresponds to its count value.
4800             - If 'log', use a logarithmic scale for the colormap.
4801               Internally, :math:`log_{10}(i+1)` is used to determine the
4802               hexagon color. This is equivalent to ``norm=LogNorm()``.
4803             - If an integer, divide the counts in the specified number
4804               of bins, and color the hexagons accordingly.
4805             - If a sequence of values, the values of the lower bound of
4806               the bins to be used.
4807 
4808         xscale : {'linear', 'log'}, default: 'linear'
4809             Use a linear or log10 scale on the horizontal axis.
4810 
4811         yscale : {'linear', 'log'}, default: 'linear'
4812             Use a linear or log10 scale on the vertical axis.
4813 
4814         mincnt : int > 0, default: *None*
4815             If not *None*, only display cells with more than *mincnt*
4816             number of points in the cell.
4817 
4818         marginals : bool, default: *False*
4819             If marginals is *True*, plot the marginal density as
4820             colormapped rectangles along the bottom of the x-axis and
4821             left of the y-axis.
4822 
4823         extent : 4-tuple of float, default: *None*
4824             The limits of the bins (xmin, xmax, ymin, ymax).
4825             The default assigns the limits based on
4826             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4827 
4828             If *xscale* or *yscale* is set to 'log', the limits are
4829             expected to be the exponent for a power of 10. E.g. for
4830             x-limits of 1 and 50 in 'linear' scale and y-limits
4831             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4832 
4833         Returns
4834         -------
4835         `~matplotlib.collections.PolyCollection`
4836             A `.PolyCollection` defining the hexagonal bins.
4837 
4838             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4839               the x, y positions of the M hexagon centers.
4840             - `.PolyCollection.get_array` contains the values of the M
4841               hexagons.
4842 
4843             If *marginals* is *True*, horizontal
4844             bar and vertical bar (both PolyCollections) will be attached
4845             to the return collection as attributes *hbar* and *vbar*.
4846 
4847         Other Parameters
4848         ----------------
4849         %(cmap_doc)s
4850 
4851         %(norm_doc)s
4852 
4853         %(vmin_vmax_doc)s
4854 
4855         alpha : float between 0 and 1, optional
4856             The alpha blending value, between 0 (transparent) and 1 (opaque).
4857 
4858         linewidths : float, default: *None*
4859             If *None*, defaults to 1.0.
4860 
4861         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4862             The color of the hexagon edges. Possible values are:
4863 
4864             - 'face': Draw the edges in the same color as the fill color.
4865             - 'none': No edges are drawn. This can sometimes lead to unsightly
4866               unpainted pixels between the hexagons.
4867             - *None*: Draw outlines in the default color.
4868             - An explicit color.
4869 
4870         reduce_C_function : callable, default: `numpy.mean`
4871             The function to aggregate *C* within the bins. It is ignored if
4872             *C* is not given. This must have the signature::
4873 
4874                 def reduce_C_function(C: array) -> float
4875 
4876             Commonly used functions are:
4877 
4878             - `numpy.mean`: average of the points
4879             - `numpy.sum`: integral of the point values
4880             - `numpy.amax`: value taken from the largest point
4881 
4882         data : indexable object, optional
4883             DATA_PARAMETER_PLACEHOLDER
4884 
4885         **kwargs : `~matplotlib.collections.PolyCollection` properties
4886             All other keyword arguments are passed on to `.PolyCollection`:
4887 
4888             %(PolyCollection:kwdoc)s
4889 
4890         See Also
4891         --------
4892         hist2d : 2D histogram rectangular bins
4893         """
4894         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4895 
4896         x, y, C = cbook.delete_masked_points(x, y, C)
4897 
4898         # Set the size of the hexagon grid
4899         if np.iterable(gridsize):
4900             nx, ny = gridsize
4901         else:
4902             nx = gridsize
4903             ny = int(nx / math.sqrt(3))
4904         # Count the number of data in each hexagon
4905         x = np.asarray(x, float)
4906         y = np.asarray(y, float)
4907 
4908         # Will be log()'d if necessary, and then rescaled.
4909         tx = x
4910         ty = y
4911 
4912         if xscale == 'log':
4913             if np.any(x <= 0.0):
4914                 raise ValueError(
4915                     "x contains non-positive values, so cannot be log-scaled")
4916             tx = np.log10(tx)
4917         if yscale == 'log':
4918             if np.any(y <= 0.0):
4919                 raise ValueError(
4920                     "y contains non-positive values, so cannot be log-scaled")
4921             ty = np.log10(ty)
4922         if extent is not None:
4923             xmin, xmax, ymin, ymax = extent
4924         else:
4925             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4926             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4927 
4928             # to avoid issues with singular data, expand the min/max pairs
4929             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4930             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4931 
4932         nx1 = nx + 1
4933         ny1 = ny + 1
4934         nx2 = nx
4935         ny2 = ny
4936         n = nx1 * ny1 + nx2 * ny2
4937 
4938         # In the x-direction, the hexagons exactly cover the region from
4939         # xmin to xmax. Need some padding to avoid roundoff errors.
4940         padding = 1.e-9 * (xmax - xmin)
4941         xmin -= padding
4942         xmax += padding
4943         sx = (xmax - xmin) / nx
4944         sy = (ymax - ymin) / ny
4945         # Positions in hexagon index coordinates.
4946         ix = (tx - xmin) / sx
4947         iy = (ty - ymin) / sy
4948         ix1 = np.round(ix).astype(int)
4949         iy1 = np.round(iy).astype(int)
4950         ix2 = np.floor(ix).astype(int)
4951         iy2 = np.floor(iy).astype(int)
4952         # flat indices, plus one so that out-of-range points go to position 0.
4953         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4954                       ix1 * ny1 + iy1 + 1, 0)
4955         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4956                       ix2 * ny2 + iy2 + 1, 0)
4957 
4958         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4959         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4960         bdist = (d1 < d2)
4961 
4962         if C is None:  # [1:] drops out-of-range points.
4963             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4964             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4965             accum = np.concatenate([counts1, counts2]).astype(float)
4966             if mincnt is not None:
4967                 accum[accum < mincnt] = np.nan
4968             C = np.ones(len(x))
4969         else:
4970             # store the C values in a list per hexagon index
4971             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4972             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4973             for i in range(len(x)):
4974                 if bdist[i]:
4975                     Cs_at_i1[i1[i]].append(C[i])
4976                 else:
4977                     Cs_at_i2[i2[i]].append(C[i])
4978             if mincnt is None:
4979                 mincnt = 0
4980             accum = np.array(
4981                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4982                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4983                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4984                 float)
4985 
4986         good_idxs = ~np.isnan(accum)
4987 
4988         offsets = np.zeros((n, 2), float)
4989         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4990         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4991         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4992         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4993         offsets[:, 0] *= sx
4994         offsets[:, 1] *= sy
4995         offsets[:, 0] += xmin
4996         offsets[:, 1] += ymin
4997         # remove accumulation bins with no data
4998         offsets = offsets[good_idxs, :]
4999         accum = accum[good_idxs]
5000 
5001         polygon = [sx, sy / 3] * np.array(
5002             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
5003 
5004         if linewidths is None:
5005             linewidths = [1.0]
5006 
5007         if xscale == 'log' or yscale == 'log':
5008             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
5009             if xscale == 'log':
5010                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
5011                 xmin = 10.0 ** xmin
5012                 xmax = 10.0 ** xmax
5013                 self.set_xscale(xscale)
5014             if yscale == 'log':
5015                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
5016                 ymin = 10.0 ** ymin
5017                 ymax = 10.0 ** ymax
5018                 self.set_yscale(yscale)
5019             collection = mcoll.PolyCollection(
5020                 polygons,
5021                 edgecolors=edgecolors,
5022                 linewidths=linewidths,
5023                 )
5024         else:
5025             collection = mcoll.PolyCollection(
5026                 [polygon],
5027                 edgecolors=edgecolors,
5028                 linewidths=linewidths,
5029                 offsets=offsets,
5030                 offset_transform=mtransforms.AffineDeltaTransform(
5031                     self.transData),
5032             )
5033 
5034         # Set normalizer if bins is 'log'
5035         if bins == 'log':
5036             if norm is not None:
5037                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5038                                    f"can be supplied, ignoring bins={bins}")
5039             else:
5040                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5041                 vmin = vmax = None
5042             bins = None
5043 
5044         # autoscale the norm with current accum values if it hasn't been set
5045         if norm is not None:
5046             if norm.vmin is None and norm.vmax is None:
5047                 norm.autoscale(accum)
5048 
5049         if bins is not None:
5050             if not np.iterable(bins):
5051                 minimum, maximum = min(accum), max(accum)
5052                 bins -= 1  # one less edge than bins
5053                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5054             bins = np.sort(bins)
5055             accum = bins.searchsorted(accum)
5056 
5057         collection.set_array(accum)
5058         collection.set_cmap(cmap)
5059         collection.set_norm(norm)
5060         collection.set_alpha(alpha)
5061         collection._internal_update(kwargs)
5062         collection._scale_norm(norm, vmin, vmax)
5063 
5064         corners = ((xmin, ymin), (xmax, ymax))
5065         self.update_datalim(corners)
5066         self._request_autoscale_view(tight=True)
5067 
5068         # add the collection last
5069         self.add_collection(collection, autolim=False)
5070         if not marginals:
5071             return collection
5072 
5073         # Process marginals
5074         bars = []
5075         for zname, z, zmin, zmax, zscale, nbins in [
5076                 ("x", x, xmin, xmax, xscale, nx),
5077                 ("y", y, ymin, ymax, yscale, 2 * ny),
5078         ]:
5079 
5080             if zscale == "log":
5081                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5082             else:
5083                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5084 
5085             verts = np.empty((nbins, 4, 2))
5086             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5087             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5088             verts[:, 0, 1] = verts[:, 3, 1] = .00
5089             verts[:, 1, 1] = verts[:, 2, 1] = .05
5090             if zname == "y":
5091                 verts = verts[:, :, ::-1]  # Swap x and y.
5092 
5093             # Sort z-values into bins defined by bin_edges.
5094             bin_idxs = np.searchsorted(bin_edges, z) - 1
5095             values = np.empty(nbins)
5096             for i in range(nbins):
5097                 # Get C-values for each bin, and compute bin value with
5098                 # reduce_C_function.
5099                 ci = C[bin_idxs == i]
5100                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5101 
5102             mask = ~np.isnan(values)
5103             verts = verts[mask]
5104             values = values[mask]
5105 
5106             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5107             bar = mcoll.PolyCollection(
5108                 verts, transform=trans, edgecolors="face")
5109             bar.set_array(values)
5110             bar.set_cmap(cmap)
5111             bar.set_norm(norm)
5112             bar.set_alpha(alpha)
5113             bar._internal_update(kwargs)
5114             bars.append(self.add_collection(bar, autolim=False))
5115 
5116         collection.hbar, collection.vbar = bars
5117 
5118         def on_changed(collection):
5119             collection.hbar.set_cmap(collection.get_cmap())
5120             collection.hbar.set_cmap(collection.get_cmap())
5121             collection.vbar.set_clim(collection.get_clim())
5122             collection.vbar.set_clim(collection.get_clim())
5123 
5124         collection.callbacks.connect('changed', on_changed)
5125 
5126         return collection
5127 
5128     @_docstring.dedent_interpd
5129     def arrow(self, x, y, dx, dy, **kwargs):
5130         """
5131         Add an arrow to the Axes.
5132 
5133         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5134 
5135         Parameters
5136         ----------
5137         %(FancyArrow)s
5138 
5139         Returns
5140         -------
5141         `.FancyArrow`
5142             The created `.FancyArrow` object.
5143 
5144         Notes
5145         -----
5146         The resulting arrow is affected by the Axes aspect ratio and limits.
5147         This may produce an arrow whose head is not square with its stem. To
5148         create an arrow whose head is square with its stem,
5149         use :meth:`annotate` for example:
5150 
5151         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5152         ...             arrowprops=dict(arrowstyle="->"))
5153 
5154         """
5155         # Strip away units for the underlying patch since units
5156         # do not make sense to most patch-like code
5157         x = self.convert_xunits(x)
5158         y = self.convert_yunits(y)
5159         dx = self.convert_xunits(dx)
5160         dy = self.convert_yunits(dy)
5161 
5162         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5163         self.add_patch(a)
5164         self._request_autoscale_view()
5165         return a
5166 
5167     @_docstring.copy(mquiver.QuiverKey.__init__)
5168     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5169         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5170         self.add_artist(qk)
5171         return qk
5172 
5173     # Handle units for x and y, if they've been passed
5174     def _quiver_units(self, args, kwargs):
5175         if len(args) > 3:
5176             x, y = args[0:2]
5177             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5178             return (x, y) + args[2:]
5179         return args
5180 
5181     # args can be a combination of X, Y, U, V, C and all should be replaced
5182     @_preprocess_data()
5183     @_docstring.dedent_interpd
5184     def quiver(self, *args, **kwargs):
5185         """%(quiver_doc)s"""
5186         # Make sure units are handled for x and y values
5187         args = self._quiver_units(args, kwargs)
5188         q = mquiver.Quiver(self, *args, **kwargs)
5189         self.add_collection(q, autolim=True)
5190         self._request_autoscale_view()
5191         return q
5192 
5193     # args can be some combination of X, Y, U, V, C and all should be replaced
5194     @_preprocess_data()
5195     @_docstring.dedent_interpd
5196     def barbs(self, *args, **kwargs):
5197         """%(barbs_doc)s"""
5198         # Make sure units are handled for x and y values
5199         args = self._quiver_units(args, kwargs)
5200         b = mquiver.Barbs(self, *args, **kwargs)
5201         self.add_collection(b, autolim=True)
5202         self._request_autoscale_view()
5203         return b
5204 
5205     # Uses a custom implementation of data-kwarg handling in
5206     # _process_plot_var_args.
5207     def fill(self, *args, data=None, **kwargs):
5208         """
5209         Plot filled polygons.
5210 
5211         Parameters
5212         ----------
5213         *args : sequence of x, y, [color]
5214             Each polygon is defined by the lists of *x* and *y* positions of
5215             its nodes, optionally followed by a *color* specifier. See
5216             :mod:`matplotlib.colors` for supported color specifiers. The
5217             standard color cycle is used for polygons without a color
5218             specifier.
5219 
5220             You can plot multiple polygons by providing multiple *x*, *y*,
5221             *[color]* groups.
5222 
5223             For example, each of the following is legal::
5224 
5225                 ax.fill(x, y)                    # a polygon with default color
5226                 ax.fill(x, y, "b")               # a blue polygon
5227                 ax.fill(x, y, x2, y2)            # two polygons
5228                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5229 
5230         data : indexable object, optional
5231             An object with labelled data. If given, provide the label names to
5232             plot in *x* and *y*, e.g.::
5233 
5234                 ax.fill("time", "signal",
5235                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5236 
5237         Returns
5238         -------
5239         list of `~matplotlib.patches.Polygon`
5240 
5241         Other Parameters
5242         ----------------
5243         **kwargs : `~matplotlib.patches.Polygon` properties
5244 
5245         Notes
5246         -----
5247         Use :meth:`fill_between` if you would like to fill the region between
5248         two curves.
5249         """
5250         # For compatibility(!), get aliases from Line2D rather than Patch.
5251         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5252         # _get_patches_for_fill returns a generator, convert it to a list.
5253         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5254         for poly in patches:
5255             self.add_patch(poly)
5256         self._request_autoscale_view()
5257         return patches
5258 
5259     def _fill_between_x_or_y(
5260             self, ind_dir, ind, dep1, dep2=0, *,
5261             where=None, interpolate=False, step=None, **kwargs):
5262         # Common implementation between fill_between (*ind_dir*="x") and
5263         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5264         # *dep* the dependent variable.  The docstring below is interpolated
5265         # to generate both methods' docstrings.
5266         """
5267         Fill the area between two {dir} curves.
5268 
5269         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5270         *{dep}2*).  This creates one or multiple polygons describing the filled
5271         area.
5272 
5273         You may exclude some {dir} sections from filling using *where*.
5274 
5275         By default, the edges connect the given points directly.  Use *step*
5276         if the filling should be a step function, i.e. constant in between
5277         *{ind}*.
5278 
5279         Parameters
5280         ----------
5281         {ind} : array (length N)
5282             The {ind} coordinates of the nodes defining the curves.
5283 
5284         {dep}1 : array (length N) or scalar
5285             The {dep} coordinates of the nodes defining the first curve.
5286 
5287         {dep}2 : array (length N) or scalar, default: 0
5288             The {dep} coordinates of the nodes defining the second curve.
5289 
5290         where : array of bool (length N), optional
5291             Define *where* to exclude some {dir} regions from being filled.
5292             The filled regions are defined by the coordinates ``{ind}[where]``.
5293             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5294             ``where[i] and where[i+1]``.  Note that this definition implies
5295             that an isolated *True* value between two *False* values in *where*
5296             will not result in filling.  Both sides of the *True* position
5297             remain unfilled due to the adjacent *False* values.
5298 
5299         interpolate : bool, default: False
5300             This option is only relevant if *where* is used and the two curves
5301             are crossing each other.
5302 
5303             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5304             similar.  By default, the nodes of the polygon defining the filled
5305             region will only be placed at the positions in the *{ind}* array.
5306             Such a polygon cannot describe the above semantics close to the
5307             intersection.  The {ind}-sections containing the intersection are
5308             simply clipped.
5309 
5310             Setting *interpolate* to *True* will calculate the actual
5311             intersection point and extend the filled region up to this point.
5312 
5313         step : {{'pre', 'post', 'mid'}}, optional
5314             Define *step* if the filling should be a step function,
5315             i.e. constant in between *{ind}*.  The value determines where the
5316             step will occur:
5317 
5318             - 'pre': The y value is continued constantly to the left from
5319               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5320               value ``y[i]``.
5321             - 'post': The y value is continued constantly to the right from
5322               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5323               value ``y[i]``.
5324             - 'mid': Steps occur half-way between the *x* positions.
5325 
5326         Returns
5327         -------
5328         `.PolyCollection`
5329             A `.PolyCollection` containing the plotted polygons.
5330 
5331         Other Parameters
5332         ----------------
5333         data : indexable object, optional
5334             DATA_PARAMETER_PLACEHOLDER
5335 
5336         **kwargs
5337             All other keyword arguments are passed on to `.PolyCollection`.
5338             They control the `.Polygon` properties:
5339 
5340             %(PolyCollection:kwdoc)s
5341 
5342         See Also
5343         --------
5344         fill_between : Fill between two sets of y-values.
5345         fill_betweenx : Fill between two sets of x-values.
5346         """
5347 
5348         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5349 
5350         if not mpl.rcParams["_internal.classic_mode"]:
5351             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5352             if not any(c in kwargs for c in ("color", "facecolor")):
5353                 kwargs["facecolor"] = \
5354                     self._get_patches_for_fill.get_next_color()
5355 
5356         # Handle united data, such as dates
5357         ind, dep1, dep2 = map(
5358             ma.masked_invalid, self._process_unit_info(
5359                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5360 
5361         for name, array in [
5362                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5363             if array.ndim > 1:
5364                 raise ValueError(f"{name!r} is not 1-dimensional")
5365 
5366         if where is None:
5367             where = True
5368         else:
5369             where = np.asarray(where, dtype=bool)
5370             if where.size != ind.size:
5371                 raise ValueError(f"where size ({where.size}) does not match "
5372                                  f"{ind_dir} size ({ind.size})")
5373         where = where & ~functools.reduce(
5374             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5375 
5376         ind, dep1, dep2 = np.broadcast_arrays(
5377             np.atleast_1d(ind), dep1, dep2, subok=True)
5378 
5379         polys = []
5380         for idx0, idx1 in cbook.contiguous_regions(where):
5381             indslice = ind[idx0:idx1]
5382             dep1slice = dep1[idx0:idx1]
5383             dep2slice = dep2[idx0:idx1]
5384             if step is not None:
5385                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5386                 indslice, dep1slice, dep2slice = \
5387                     step_func(indslice, dep1slice, dep2slice)
5388 
5389             if not len(indslice):
5390                 continue
5391 
5392             N = len(indslice)
5393             pts = np.zeros((2 * N + 2, 2))
5394 
5395             if interpolate:
5396                 def get_interp_point(idx):
5397                     im1 = max(idx - 1, 0)
5398                     ind_values = ind[im1:idx+1]
5399                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5400                     dep1_values = dep1[im1:idx+1]
5401 
5402                     if len(diff_values) == 2:
5403                         if np.ma.is_masked(diff_values[1]):
5404                             return ind[im1], dep1[im1]
5405                         elif np.ma.is_masked(diff_values[0]):
5406                             return ind[idx], dep1[idx]
5407 
5408                     diff_order = diff_values.argsort()
5409                     diff_root_ind = np.interp(
5410                         0, diff_values[diff_order], ind_values[diff_order])
5411                     ind_order = ind_values.argsort()
5412                     diff_root_dep = np.interp(
5413                         diff_root_ind,
5414                         ind_values[ind_order], dep1_values[ind_order])
5415                     return diff_root_ind, diff_root_dep
5416 
5417                 start = get_interp_point(idx0)
5418                 end = get_interp_point(idx1)
5419             else:
5420                 # Handle scalar dep2 (e.g. 0): the fill should go all
5421                 # the way down to 0 even if none of the dep1 sample points do.
5422                 start = indslice[0], dep2slice[0]
5423                 end = indslice[-1], dep2slice[-1]
5424 
5425             pts[0] = start
5426             pts[N + 1] = end
5427 
5428             pts[1:N+1, 0] = indslice
5429             pts[1:N+1, 1] = dep1slice
5430             pts[N+2:, 0] = indslice[::-1]
5431             pts[N+2:, 1] = dep2slice[::-1]
5432 
5433             if ind_dir == "y":
5434                 pts = pts[:, ::-1]
5435 
5436             polys.append(pts)
5437 
5438         collection = mcoll.PolyCollection(polys, **kwargs)
5439 
5440         # now update the datalim and autoscale
5441         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5442                             np.column_stack([ind[where], dep2[where]])])
5443         if ind_dir == "y":
5444             pts = pts[:, ::-1]
5445 
5446         up_x = up_y = True
5447         if "transform" in kwargs:
5448             up_x, up_y = kwargs["transform"].contains_branch_seperately(self.transData)
5449         self.update_datalim(pts, updatex=up_x, updatey=up_y)
5450 
5451         self.add_collection(collection, autolim=False)
5452         self._request_autoscale_view()
5453         return collection
5454 
5455     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5456                      step=None, **kwargs):
5457         return self._fill_between_x_or_y(
5458             "x", x, y1, y2,
5459             where=where, interpolate=interpolate, step=step, **kwargs)
5460 
5461     if _fill_between_x_or_y.__doc__:
5462         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5463             dir="horizontal", ind="x", dep="y"
5464         )
5465     fill_between = _preprocess_data(
5466         _docstring.dedent_interpd(fill_between),
5467         replace_names=["x", "y1", "y2", "where"])
5468 
5469     def fill_betweenx(self, y, x1, x2=0, where=None,
5470                       step=None, interpolate=False, **kwargs):
5471         return self._fill_between_x_or_y(
5472             "y", y, x1, x2,
5473             where=where, interpolate=interpolate, step=step, **kwargs)
5474 
5475     if _fill_between_x_or_y.__doc__:
5476         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5477             dir="vertical", ind="y", dep="x"
5478         )
5479     fill_betweenx = _preprocess_data(
5480         _docstring.dedent_interpd(fill_betweenx),
5481         replace_names=["y", "x1", "x2", "where"])
5482 
5483     #### plotting z(x, y): imshow, pcolor and relatives, contour
5484 
5485     @_preprocess_data()
5486     @_docstring.interpd
5487     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5488                interpolation=None, alpha=None,
5489                vmin=None, vmax=None, origin=None, extent=None,
5490                interpolation_stage=None, filternorm=True, filterrad=4.0,
5491                resample=None, url=None, **kwargs):
5492         """
5493         Display data as an image, i.e., on a 2D regular raster.
5494 
5495         The input may either be actual RGB(A) data, or 2D scalar data, which
5496         will be rendered as a pseudocolor image. For displaying a grayscale
5497         image set up the colormapping using the parameters
5498         ``cmap='gray', vmin=0, vmax=255``.
5499 
5500         The number of pixels used to render an image is set by the Axes size
5501         and the *dpi* of the figure. This can lead to aliasing artifacts when
5502         the image is resampled because the displayed image size will usually
5503         not match the size of *X* (see
5504         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5505         The resampling can be controlled via the *interpolation* parameter
5506         and/or :rc:`image.interpolation`.
5507 
5508         Parameters
5509         ----------
5510         X : array-like or PIL image
5511             The image data. Supported array shapes are:
5512 
5513             - (M, N): an image with scalar data. The values are mapped to
5514               colors using normalization and a colormap. See parameters *norm*,
5515               *cmap*, *vmin*, *vmax*.
5516             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5517             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5518               i.e. including transparency.
5519 
5520             The first two dimensions (M, N) define the rows and columns of
5521             the image.
5522 
5523             Out-of-range RGB(A) values are clipped.
5524 
5525         %(cmap_doc)s
5526 
5527             This parameter is ignored if *X* is RGB(A).
5528 
5529         %(norm_doc)s
5530 
5531             This parameter is ignored if *X* is RGB(A).
5532 
5533         %(vmin_vmax_doc)s
5534 
5535             This parameter is ignored if *X* is RGB(A).
5536 
5537         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5538             The aspect ratio of the Axes.  This parameter is particularly
5539             relevant for images since it determines whether data pixels are
5540             square.
5541 
5542             This parameter is a shortcut for explicitly calling
5543             `.Axes.set_aspect`. See there for further details.
5544 
5545             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5546               (unless pixel sizes are explicitly made non-square in data
5547               coordinates using *extent*).
5548             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5549               that the data fit in the Axes. In general, this will result in
5550               non-square pixels.
5551 
5552         interpolation : str, default: :rc:`image.interpolation`
5553             The interpolation method used.
5554 
5555             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5556             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5557             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5558             'sinc', 'lanczos', 'blackman'.
5559 
5560             The data *X* is resampled to the pixel size of the image on the
5561             figure canvas, using the interpolation method to either up- or
5562             downsample the data.
5563 
5564             If *interpolation* is 'none', then for the ps, pdf, and svg
5565             backends no down- or upsampling occurs, and the image data is
5566             passed to the backend as a native image.  Note that different ps,
5567             pdf, and svg viewers may display these raw pixels differently. On
5568             other backends, 'none' is the same as 'nearest'.
5569 
5570             If *interpolation* is the default 'antialiased', then 'nearest'
5571             interpolation is used if the image is upsampled by more than a
5572             factor of three (i.e. the number of display pixels is at least
5573             three times the size of the data array).  If the upsampling rate is
5574             smaller than 3, or the image is downsampled, then 'hanning'
5575             interpolation is used to act as an anti-aliasing filter, unless the
5576             image happens to be upsampled by exactly a factor of two or one.
5577 
5578             See
5579             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5580             for an overview of the supported interpolation methods, and
5581             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5582             a discussion of image antialiasing.
5583 
5584             Some interpolation methods require an additional radius parameter,
5585             which can be set by *filterrad*. Additionally, the antigrain image
5586             resize filter is controlled by the parameter *filternorm*.
5587 
5588         interpolation_stage : {'data', 'rgba'}, default: 'data'
5589             If 'data', interpolation
5590             is carried out on the data provided by the user.  If 'rgba', the
5591             interpolation is carried out after the colormapping has been
5592             applied (visual interpolation).
5593 
5594         alpha : float or array-like, optional
5595             The alpha blending value, between 0 (transparent) and 1 (opaque).
5596             If *alpha* is an array, the alpha blending values are applied pixel
5597             by pixel, and *alpha* must have the same shape as *X*.
5598 
5599         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5600             Place the [0, 0] index of the array in the upper left or lower
5601             left corner of the Axes. The convention (the default) 'upper' is
5602             typically used for matrices and images.
5603 
5604             Note that the vertical axis points upward for 'lower'
5605             but downward for 'upper'.
5606 
5607             See the :ref:`imshow_extent` tutorial for
5608             examples and a more detailed description.
5609 
5610         extent : floats (left, right, bottom, top), optional
5611             The bounding box in data coordinates that the image will fill.
5612             These values may be unitful and match the units of the Axes.
5613             The image is stretched individually along x and y to fill the box.
5614 
5615             The default extent is determined by the following conditions.
5616             Pixels have unit size in data coordinates. Their centers are on
5617             integer coordinates, and their center coordinates range from 0 to
5618             columns-1 horizontally and from 0 to rows-1 vertically.
5619 
5620             Note that the direction of the vertical axis and thus the default
5621             values for top and bottom depend on *origin*:
5622 
5623             - For ``origin == 'upper'`` the default is
5624               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5625             - For ``origin == 'lower'`` the default is
5626               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5627 
5628             See the :ref:`imshow_extent` tutorial for
5629             examples and a more detailed description.
5630 
5631         filternorm : bool, default: True
5632             A parameter for the antigrain image resize filter (see the
5633             antigrain documentation).  If *filternorm* is set, the filter
5634             normalizes integer values and corrects the rounding errors. It
5635             doesn't do anything with the source floating point values, it
5636             corrects only integers according to the rule of 1.0 which means
5637             that any sum of pixel weights must be equal to 1.0.  So, the
5638             filter function must produce a graph of the proper shape.
5639 
5640         filterrad : float > 0, default: 4.0
5641             The filter radius for filters that have a radius parameter, i.e.
5642             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5643 
5644         resample : bool, default: :rc:`image.resample`
5645             When *True*, use a full resampling method.  When *False*, only
5646             resample when the output image is larger than the input image.
5647 
5648         url : str, optional
5649             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5650 
5651         Returns
5652         -------
5653         `~matplotlib.image.AxesImage`
5654 
5655         Other Parameters
5656         ----------------
5657         data : indexable object, optional
5658             DATA_PARAMETER_PLACEHOLDER
5659 
5660         **kwargs : `~matplotlib.artist.Artist` properties
5661             These parameters are passed on to the constructor of the
5662             `.AxesImage` artist.
5663 
5664         See Also
5665         --------
5666         matshow : Plot a matrix or an array as an image.
5667 
5668         Notes
5669         -----
5670         Unless *extent* is used, pixel centers will be located at integer
5671         coordinates. In other words: the origin will coincide with the center
5672         of pixel (0, 0).
5673 
5674         There are two common representations for RGB images with an alpha
5675         channel:
5676 
5677         -   Straight (unassociated) alpha: R, G, and B channels represent the
5678             color of the pixel, disregarding its opacity.
5679         -   Premultiplied (associated) alpha: R, G, and B channels represent
5680             the color of the pixel, adjusted for its opacity by multiplication.
5681 
5682         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5683         (unassociated) alpha representation.
5684         """
5685         if aspect is None:
5686             aspect = mpl.rcParams['image.aspect']
5687         self.set_aspect(aspect)
5688         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5689                               interpolation=interpolation, origin=origin,
5690                               extent=extent, filternorm=filternorm,
5691                               filterrad=filterrad, resample=resample,
5692                               interpolation_stage=interpolation_stage,
5693                               **kwargs)
5694 
5695         im.set_data(X)
5696         im.set_alpha(alpha)
5697         if im.get_clip_path() is None:
5698             # image does not already have clipping set, clip to axes patch
5699             im.set_clip_path(self.patch)
5700         im._scale_norm(norm, vmin, vmax)
5701         im.set_url(url)
5702 
5703         # update ax.dataLim, and, if autoscaling, set viewLim
5704         # to tightly fit the image, regardless of dataLim.
5705         im.set_extent(im.get_extent())
5706 
5707         self.add_image(im)
5708         return im
5709 
5710     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5711         # - create X and Y if not present;
5712         # - reshape X and Y as needed if they are 1-D;
5713         # - check for proper sizes based on `shading` kwarg;
5714         # - reset shading if shading='auto' to flat or nearest
5715         #   depending on size;
5716 
5717         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5718         try:
5719             _api.check_in_list(_valid_shading, shading=shading)
5720         except ValueError:
5721             _api.warn_external(f"shading value '{shading}' not in list of "
5722                                f"valid values {_valid_shading}. Setting "
5723                                "shading='auto'.")
5724             shading = 'auto'
5725 
5726         if len(args) == 1:
5727             C = np.asanyarray(args[0])
5728             nrows, ncols = C.shape[:2]
5729             if shading in ['gouraud', 'nearest']:
5730                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5731             else:
5732                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5733                 shading = 'flat'
5734             C = cbook.safe_masked_invalid(C)
5735             return X, Y, C, shading
5736 
5737         if len(args) == 3:
5738             # Check x and y for bad data...
5739             C = np.asanyarray(args[2])
5740             # unit conversion allows e.g. datetime objects as axis values
5741             X, Y = args[:2]
5742             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5743             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5744 
5745             if funcname == 'pcolormesh':
5746                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5747                     raise ValueError(
5748                         'x and y arguments to pcolormesh cannot have '
5749                         'non-finite values or be of type '
5750                         'numpy.ma.core.MaskedArray with masked values')
5751                 # safe_masked_invalid() returns an ndarray for dtypes other
5752                 # than floating point.
5753                 if isinstance(X, np.ma.core.MaskedArray):
5754                     X = X.data  # strip mask as downstream doesn't like it...
5755                 if isinstance(Y, np.ma.core.MaskedArray):
5756                     Y = Y.data
5757             nrows, ncols = C.shape[:2]
5758         else:
5759             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5760 
5761         Nx = X.shape[-1]
5762         Ny = Y.shape[0]
5763         if X.ndim != 2 or X.shape[0] == 1:
5764             x = X.reshape(1, Nx)
5765             X = x.repeat(Ny, axis=0)
5766         if Y.ndim != 2 or Y.shape[1] == 1:
5767             y = Y.reshape(Ny, 1)
5768             Y = y.repeat(Nx, axis=1)
5769         if X.shape != Y.shape:
5770             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5771                             f'see help({funcname})')
5772 
5773         if shading == 'auto':
5774             if ncols == Nx and nrows == Ny:
5775                 shading = 'nearest'
5776             else:
5777                 shading = 'flat'
5778 
5779         if shading == 'flat':
5780             if (Nx, Ny) != (ncols + 1, nrows + 1):
5781                 raise TypeError(f"Dimensions of C {C.shape} should"
5782                                 f" be one smaller than X({Nx}) and Y({Ny})"
5783                                 f" while using shading='flat'"
5784                                 f" see help({funcname})")
5785         else:    # ['nearest', 'gouraud']:
5786             if (Nx, Ny) != (ncols, nrows):
5787                 raise TypeError('Dimensions of C %s are incompatible with'
5788                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5789                                     C.shape, Nx, Ny, funcname))
5790             if shading == 'nearest':
5791                 # grid is specified at the center, so define corners
5792                 # at the midpoints between the grid centers and then use the
5793                 # flat algorithm.
5794                 def _interp_grid(X):
5795                     # helper for below
5796                     if np.shape(X)[1] > 1:
5797                         dX = np.diff(X, axis=1)/2.
5798                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5799                             _api.warn_external(
5800                                 f"The input coordinates to {funcname} are "
5801                                 "interpreted as cell centers, but are not "
5802                                 "monotonically increasing or decreasing. "
5803                                 "This may lead to incorrectly calculated cell "
5804                                 "edges, in which case, please supply "
5805                                 f"explicit cell edges to {funcname}.")
5806                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5807                                        X[:, :-1] + dX,
5808                                        X[:, [-1]] + dX[:, [-1]]))
5809                     else:
5810                         # This is just degenerate, but we can't reliably guess
5811                         # a dX if there is just one value.
5812                         X = np.hstack((X, X))
5813                     return X
5814 
5815                 if ncols == Nx:
5816                     X = _interp_grid(X)
5817                     Y = _interp_grid(Y)
5818                 if nrows == Ny:
5819                     X = _interp_grid(X.T).T
5820                     Y = _interp_grid(Y.T).T
5821                 shading = 'flat'
5822 
5823         C = cbook.safe_masked_invalid(C)
5824         return X, Y, C, shading
5825 
5826     @_preprocess_data()
5827     @_docstring.dedent_interpd
5828     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5829                vmin=None, vmax=None, **kwargs):
5830         r"""
5831         Create a pseudocolor plot with a non-regular rectangular grid.
5832 
5833         Call signature::
5834 
5835             pcolor([X, Y,] C, **kwargs)
5836 
5837         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5838 
5839         .. hint::
5840 
5841             ``pcolor()`` can be very slow for large arrays. In most
5842             cases you should use the similar but much faster
5843             `~.Axes.pcolormesh` instead. See
5844             :ref:`Differences between pcolor() and pcolormesh()
5845             <differences-pcolor-pcolormesh>` for a discussion of the
5846             differences.
5847 
5848         Parameters
5849         ----------
5850         C : 2D array-like
5851             The color-mapped values.  Color-mapping is controlled by *cmap*,
5852             *norm*, *vmin*, and *vmax*.
5853 
5854         X, Y : array-like, optional
5855             The coordinates of the corners of quadrilaterals of a pcolormesh::
5856 
5857                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5858                                       ●╶───╴●
5859                                       │     │
5860                                       ●╶───╴●
5861                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5862 
5863             Note that the column index corresponds to the x-coordinate, and
5864             the row index corresponds to y. For details, see the
5865             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5866 
5867             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5868             greater than those of *C*, and the quadrilateral is colored due
5869             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5870             dimensions, a warning will be raised and the last row and column
5871             of *C* will be ignored.
5872 
5873             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5874             the same as those of *C* (if not, a ValueError will be raised). The
5875             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5876 
5877             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5878             expanded as needed into the appropriate 2D arrays, making a
5879             rectangular grid.
5880 
5881         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5882             The fill style for the quadrilateral. Possible values:
5883 
5884             - 'flat': A solid color is used for each quad. The color of the
5885               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5886               ``C[i, j]``. The dimensions of *X* and *Y* should be
5887               one greater than those of *C*; if they are the same as *C*,
5888               then a deprecation warning is raised, and the last row
5889               and column of *C* are dropped.
5890             - 'nearest': Each grid point will have a color centered on it,
5891               extending halfway between the adjacent grid centers.  The
5892               dimensions of *X* and *Y* must be the same as *C*.
5893             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5894               larger than *C*.  Choose 'nearest' if dimensions are the same.
5895 
5896             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5897             for more description.
5898 
5899         %(cmap_doc)s
5900 
5901         %(norm_doc)s
5902 
5903         %(vmin_vmax_doc)s
5904 
5905         edgecolors : {'none', None, 'face', color, color sequence}, optional
5906             The color of the edges. Defaults to 'none'. Possible values:
5907 
5908             - 'none' or '': No edge.
5909             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5910               :rc:`patch.force_edgecolor` has to be True for this to work.
5911             - 'face': Use the adjacent face color.
5912             - A color or sequence of colors will set the edge color.
5913 
5914             The singular form *edgecolor* works as an alias.
5915 
5916         alpha : float, default: None
5917             The alpha blending value of the face color, between 0 (transparent)
5918             and 1 (opaque). Note: The edgecolor is currently not affected by
5919             this.
5920 
5921         snap : bool, default: False
5922             Whether to snap the mesh to pixel boundaries.
5923 
5924         Returns
5925         -------
5926         `matplotlib.collections.Collection`
5927 
5928         Other Parameters
5929         ----------------
5930         antialiaseds : bool, default: False
5931             The default *antialiaseds* is False if the default
5932             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5933             at patch boundaries, and works regardless of the value of alpha.
5934             If *edgecolors* is not "none", then the default *antialiaseds*
5935             is taken from :rc:`patch.antialiased`.
5936             Stroking the edges may be preferred if *alpha* is 1, but will
5937             cause artifacts otherwise.
5938 
5939         data : indexable object, optional
5940             DATA_PARAMETER_PLACEHOLDER
5941 
5942         **kwargs
5943             Additionally, the following arguments are allowed. They are passed
5944             along to the `~matplotlib.collections.PolyCollection` constructor:
5945 
5946         %(PolyCollection:kwdoc)s
5947 
5948         See Also
5949         --------
5950         pcolormesh : for an explanation of the differences between
5951             pcolor and pcolormesh.
5952         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5953             faster alternative.
5954 
5955         Notes
5956         -----
5957         **Masked arrays**
5958 
5959         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5960         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5961         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5962         plotted.
5963 
5964         .. _axes-pcolor-grid-orientation:
5965 
5966         **Grid orientation**
5967 
5968         The grid orientation follows the standard matrix convention: An array
5969         *C* with shape (nrows, ncolumns) is plotted with the column number as
5970         *X* and the row number as *Y*.
5971         """
5972 
5973         if shading is None:
5974             shading = mpl.rcParams['pcolor.shading']
5975         shading = shading.lower()
5976         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5977                                             kwargs=kwargs)
5978         Ny, Nx = X.shape
5979 
5980         # convert to MA, if necessary.
5981         C = ma.asarray(C)
5982         X = ma.asarray(X)
5983         Y = ma.asarray(Y)
5984 
5985         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5986         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5987                   mask[0:-1, 1:] + mask[1:, 0:-1])
5988         # don't plot if C or any of the surrounding vertices are masked.
5989         mask = ma.getmaskarray(C) + xymask
5990 
5991         unmask = ~mask
5992         X1 = ma.filled(X[:-1, :-1])[unmask]
5993         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5994         X2 = ma.filled(X[1:, :-1])[unmask]
5995         Y2 = ma.filled(Y[1:, :-1])[unmask]
5996         X3 = ma.filled(X[1:, 1:])[unmask]
5997         Y3 = ma.filled(Y[1:, 1:])[unmask]
5998         X4 = ma.filled(X[:-1, 1:])[unmask]
5999         Y4 = ma.filled(Y[:-1, 1:])[unmask]
6000         npoly = len(X1)
6001 
6002         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
6003         verts = xy.reshape((npoly, 5, 2))
6004 
6005         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
6006 
6007         linewidths = (0.25,)
6008         if 'linewidth' in kwargs:
6009             kwargs['linewidths'] = kwargs.pop('linewidth')
6010         kwargs.setdefault('linewidths', linewidths)
6011 
6012         if 'edgecolor' in kwargs:
6013             kwargs['edgecolors'] = kwargs.pop('edgecolor')
6014         ec = kwargs.setdefault('edgecolors', 'none')
6015 
6016         # aa setting will default via collections to patch.antialiased
6017         # unless the boundary is not stroked, in which case the
6018         # default will be False; with unstroked boundaries, aa
6019         # makes artifacts that are often disturbing.
6020         if 'antialiased' in kwargs:
6021             kwargs['antialiaseds'] = kwargs.pop('antialiased')
6022         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
6023             kwargs['antialiaseds'] = False
6024 
6025         kwargs.setdefault('snap', False)
6026 
6027         collection = mcoll.PolyCollection(
6028             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6029         collection._scale_norm(norm, vmin, vmax)
6030 
6031         x = X.compressed()
6032         y = Y.compressed()
6033 
6034         # Transform from native to data coordinates?
6035         t = collection._transform
6036         if (not isinstance(t, mtransforms.Transform) and
6037                 hasattr(t, '_as_mpl_transform')):
6038             t = t._as_mpl_transform(self.axes)
6039 
6040         if t and any(t.contains_branch_seperately(self.transData)):
6041             trans_to_data = t - self.transData
6042             pts = np.vstack([x, y]).T.astype(float)
6043             transformed_pts = trans_to_data.transform(pts)
6044             x = transformed_pts[..., 0]
6045             y = transformed_pts[..., 1]
6046 
6047         self.add_collection(collection, autolim=False)
6048 
6049         minx = np.min(x)
6050         maxx = np.max(x)
6051         miny = np.min(y)
6052         maxy = np.max(y)
6053         collection.sticky_edges.x[:] = [minx, maxx]
6054         collection.sticky_edges.y[:] = [miny, maxy]
6055         corners = (minx, miny), (maxx, maxy)
6056         self.update_datalim(corners)
6057         self._request_autoscale_view()
6058         return collection
6059 
6060     @_preprocess_data()
6061     @_docstring.dedent_interpd
6062     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6063                    vmax=None, shading=None, antialiased=False, **kwargs):
6064         """
6065         Create a pseudocolor plot with a non-regular rectangular grid.
6066 
6067         Call signature::
6068 
6069             pcolormesh([X, Y,] C, **kwargs)
6070 
6071         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6072 
6073         .. hint::
6074 
6075            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6076            and preferred in most cases. For a detailed discussion on the
6077            differences see :ref:`Differences between pcolor() and pcolormesh()
6078            <differences-pcolor-pcolormesh>`.
6079 
6080         Parameters
6081         ----------
6082         C : array-like
6083             The mesh data. Supported array shapes are:
6084 
6085             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6086               colors using normalization and a colormap. See parameters *norm*,
6087               *cmap*, *vmin*, *vmax*.
6088             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6089             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6090               i.e. including transparency.
6091 
6092             The first two dimensions (M, N) define the rows and columns of
6093             the mesh data.
6094 
6095         X, Y : array-like, optional
6096             The coordinates of the corners of quadrilaterals of a pcolormesh::
6097 
6098                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6099                                       ●╶───╴●
6100                                       │     │
6101                                       ●╶───╴●
6102                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6103 
6104             Note that the column index corresponds to the x-coordinate, and
6105             the row index corresponds to y. For details, see the
6106             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6107 
6108             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6109             greater than those of *C*, and the quadrilateral is colored due
6110             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6111             dimensions, a warning will be raised and the last row and column
6112             of *C* will be ignored.
6113 
6114             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6115             and *Y* should be the same as those of *C* (if not, a ValueError
6116             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6117             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6118             interpolation is caried out between the quadrilateral corners.
6119 
6120             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6121             expanded as needed into the appropriate 2D arrays, making a
6122             rectangular grid.
6123 
6124         %(cmap_doc)s
6125 
6126         %(norm_doc)s
6127 
6128         %(vmin_vmax_doc)s
6129 
6130         edgecolors : {'none', None, 'face', color, color sequence}, optional
6131             The color of the edges. Defaults to 'none'. Possible values:
6132 
6133             - 'none' or '': No edge.
6134             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6135               :rc:`patch.force_edgecolor` has to be True for this to work.
6136             - 'face': Use the adjacent face color.
6137             - A color or sequence of colors will set the edge color.
6138 
6139             The singular form *edgecolor* works as an alias.
6140 
6141         alpha : float, default: None
6142             The alpha blending value, between 0 (transparent) and 1 (opaque).
6143 
6144         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6145             The fill style for the quadrilateral; defaults to
6146             :rc:`pcolor.shading`. Possible values:
6147 
6148             - 'flat': A solid color is used for each quad. The color of the
6149               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6150               ``C[i, j]``. The dimensions of *X* and *Y* should be
6151               one greater than those of *C*; if they are the same as *C*,
6152               then a deprecation warning is raised, and the last row
6153               and column of *C* are dropped.
6154             - 'nearest': Each grid point will have a color centered on it,
6155               extending halfway between the adjacent grid centers.  The
6156               dimensions of *X* and *Y* must be the same as *C*.
6157             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6158               corners (i', j') are given by ``C[i', j']``. The color values of
6159               the area in between is interpolated from the corner values.
6160               The dimensions of *X* and *Y* must be the same as *C*. When
6161               Gouraud shading is used, *edgecolors* is ignored.
6162             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6163               larger than *C*.  Choose 'nearest' if dimensions are the same.
6164 
6165             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6166             for more description.
6167 
6168         snap : bool, default: False
6169             Whether to snap the mesh to pixel boundaries.
6170 
6171         rasterized : bool, optional
6172             Rasterize the pcolormesh when drawing vector graphics.  This can
6173             speed up rendering and produce smaller files for large data sets.
6174             See also :doc:`/gallery/misc/rasterization_demo`.
6175 
6176         Returns
6177         -------
6178         `matplotlib.collections.QuadMesh`
6179 
6180         Other Parameters
6181         ----------------
6182         data : indexable object, optional
6183             DATA_PARAMETER_PLACEHOLDER
6184 
6185         **kwargs
6186             Additionally, the following arguments are allowed. They are passed
6187             along to the `~matplotlib.collections.QuadMesh` constructor:
6188 
6189         %(QuadMesh:kwdoc)s
6190 
6191         See Also
6192         --------
6193         pcolor : An alternative implementation with slightly different
6194             features. For a detailed discussion on the differences see
6195             :ref:`Differences between pcolor() and pcolormesh()
6196             <differences-pcolor-pcolormesh>`.
6197         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6198             faster alternative.
6199 
6200         Notes
6201         -----
6202         **Masked arrays**
6203 
6204         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6205         quadrilateral will be transparent. Masking of *X* and *Y* is not
6206         supported. Use `~.Axes.pcolor` if you need this functionality.
6207 
6208         .. _axes-pcolormesh-grid-orientation:
6209 
6210         **Grid orientation**
6211 
6212         The grid orientation follows the standard matrix convention: An array
6213         *C* with shape (nrows, ncolumns) is plotted with the column number as
6214         *X* and the row number as *Y*.
6215 
6216         .. _differences-pcolor-pcolormesh:
6217 
6218         **Differences between pcolor() and pcolormesh()**
6219 
6220         Both methods are used to create a pseudocolor plot of a 2D array
6221         using quadrilaterals.
6222 
6223         The main difference lies in the created object and internal data
6224         handling:
6225         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6226         returns a `.QuadMesh`. The latter is more specialized for the given
6227         purpose and thus is faster. It should almost always be preferred.
6228 
6229         There is also a slight difference in the handling of masked arrays.
6230         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6231         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6232         and *Y*. The reason lies in the internal handling of the masked values.
6233         `~.Axes.pcolor` leaves out the respective polygons from the
6234         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6235         elements to transparent. You can see the difference when using
6236         edgecolors. While all edges are drawn irrespective of masking in a
6237         QuadMesh, the edge between two adjacent masked quadrilaterals in
6238         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6239         exist in the PolyCollection.
6240 
6241         Another difference is the support of Gouraud shading in
6242         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6243 
6244         """
6245         if shading is None:
6246             shading = mpl.rcParams['pcolor.shading']
6247         shading = shading.lower()
6248         kwargs.setdefault('edgecolors', 'none')
6249 
6250         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6251                                             shading=shading, kwargs=kwargs)
6252         coords = np.stack([X, Y], axis=-1)
6253 
6254         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6255 
6256         collection = mcoll.QuadMesh(
6257             coords, antialiased=antialiased, shading=shading,
6258             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6259         collection._scale_norm(norm, vmin, vmax)
6260 
6261         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6262 
6263         # Transform from native to data coordinates?
6264         t = collection._transform
6265         if (not isinstance(t, mtransforms.Transform) and
6266                 hasattr(t, '_as_mpl_transform')):
6267             t = t._as_mpl_transform(self.axes)
6268 
6269         if t and any(t.contains_branch_seperately(self.transData)):
6270             trans_to_data = t - self.transData
6271             coords = trans_to_data.transform(coords)
6272 
6273         self.add_collection(collection, autolim=False)
6274 
6275         minx, miny = np.min(coords, axis=0)
6276         maxx, maxy = np.max(coords, axis=0)
6277         collection.sticky_edges.x[:] = [minx, maxx]
6278         collection.sticky_edges.y[:] = [miny, maxy]
6279         corners = (minx, miny), (maxx, maxy)
6280         self.update_datalim(corners)
6281         self._request_autoscale_view()
6282         return collection
6283 
6284     @_preprocess_data()
6285     @_docstring.dedent_interpd
6286     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6287                    vmax=None, **kwargs):
6288         """
6289         Create a pseudocolor plot with a non-regular rectangular grid.
6290 
6291         Call signature::
6292 
6293           ax.pcolorfast([X, Y], C, /, **kwargs)
6294 
6295         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6296         It's designed to provide the fastest pcolor-type plotting with the
6297         Agg backend. To achieve this, it uses different algorithms internally
6298         depending on the complexity of the input grid (regular rectangular,
6299         non-regular rectangular or arbitrary quadrilateral).
6300 
6301         .. warning::
6302 
6303            This method is experimental. Compared to `~.Axes.pcolor` or
6304            `~.Axes.pcolormesh` it has some limitations:
6305 
6306            - It supports only flat shading (no outlines)
6307            - It lacks support for log scaling of the axes.
6308            - It does not have a pyplot wrapper.
6309 
6310         Parameters
6311         ----------
6312         C : array-like
6313             The image data. Supported array shapes are:
6314 
6315             - (M, N): an image with scalar data.  Color-mapping is controlled
6316               by *cmap*, *norm*, *vmin*, and *vmax*.
6317             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6318             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6319               i.e. including transparency.
6320 
6321             The first two dimensions (M, N) define the rows and columns of
6322             the image.
6323 
6324             This parameter can only be passed positionally.
6325 
6326         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6327             *X* and *Y* are used to specify the coordinates of the
6328             quadrilaterals. There are different ways to do this:
6329 
6330             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6331               a *uniform rectangular grid*.
6332 
6333               The tuples define the outer edges of the grid. All individual
6334               quadrilaterals will be of the same size. This is the fastest
6335               version.
6336 
6337             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6338               grid*.
6339 
6340               In this case *X* and *Y* have to be monotonic 1D arrays of length
6341               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6342 
6343               The speed is intermediate. Note: The grid is checked, and if
6344               found to be uniform the fast version is used.
6345 
6346             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6347               grid* (i.e. if the quadrilaterals are not rectangular).
6348 
6349               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6350               specifying the x and y coordinates of the corners of the colored
6351               quadrilaterals.
6352 
6353               This is the most general, but the slowest to render.  It may
6354               produce faster and more compact output using ps, pdf, and
6355               svg backends, however.
6356 
6357             These arguments can only be passed positionally.
6358 
6359         %(cmap_doc)s
6360 
6361             This parameter is ignored if *C* is RGB(A).
6362 
6363         %(norm_doc)s
6364 
6365             This parameter is ignored if *C* is RGB(A).
6366 
6367         %(vmin_vmax_doc)s
6368 
6369             This parameter is ignored if *C* is RGB(A).
6370 
6371         alpha : float, default: None
6372             The alpha blending value, between 0 (transparent) and 1 (opaque).
6373 
6374         snap : bool, default: False
6375             Whether to snap the mesh to pixel boundaries.
6376 
6377         Returns
6378         -------
6379         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6380             The return type depends on the type of grid:
6381 
6382             - `.AxesImage` for a regular rectangular grid.
6383             - `.PcolorImage` for a non-regular rectangular grid.
6384             - `.QuadMesh` for a non-rectangular grid.
6385 
6386         Other Parameters
6387         ----------------
6388         data : indexable object, optional
6389             DATA_PARAMETER_PLACEHOLDER
6390 
6391         **kwargs
6392             Supported additional parameters depend on the type of grid.
6393             See return types of *image* for further description.
6394         """
6395 
6396         C = args[-1]
6397         nr, nc = np.shape(C)[:2]
6398         if len(args) == 1:
6399             style = "image"
6400             x = [0, nc]
6401             y = [0, nr]
6402         elif len(args) == 3:
6403             x, y = args[:2]
6404             x = np.asarray(x)
6405             y = np.asarray(y)
6406             if x.ndim == 1 and y.ndim == 1:
6407                 if x.size == 2 and y.size == 2:
6408                     style = "image"
6409                 else:
6410                     dx = np.diff(x)
6411                     dy = np.diff(y)
6412                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6413                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6414                         style = "image"
6415                     else:
6416                         style = "pcolorimage"
6417             elif x.ndim == 2 and y.ndim == 2:
6418                 style = "quadmesh"
6419             else:
6420                 raise TypeError("arguments do not match valid signatures")
6421         else:
6422             raise _api.nargs_error('pcolorfast', '1 or 3', len(args))
6423 
6424         if style == "quadmesh":
6425             # data point in each cell is value at lower left corner
6426             coords = np.stack([x, y], axis=-1)
6427             if np.ndim(C) not in {2, 3}:
6428                 raise ValueError("C must be 2D or 3D")
6429             collection = mcoll.QuadMesh(
6430                 coords, array=C,
6431                 alpha=alpha, cmap=cmap, norm=norm,
6432                 antialiased=False, edgecolors="none")
6433             self.add_collection(collection, autolim=False)
6434             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6435             ret = collection
6436 
6437         else:  # It's one of the two image styles.
6438             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6439             if style == "image":
6440                 im = mimage.AxesImage(
6441                     self, cmap=cmap, norm=norm,
6442                     data=C, alpha=alpha, extent=extent,
6443                     interpolation='nearest', origin='lower',
6444                     **kwargs)
6445             elif style == "pcolorimage":
6446                 im = mimage.PcolorImage(
6447                     self, x, y, C,
6448                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6449                     **kwargs)
6450             self.add_image(im)
6451             ret = im
6452 
6453         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6454             ret._scale_norm(norm, vmin, vmax)
6455 
6456         if ret.get_clip_path() is None:
6457             # image does not already have clipping set, clip to axes patch
6458             ret.set_clip_path(self.patch)
6459 
6460         ret.sticky_edges.x[:] = [xl, xr]
6461         ret.sticky_edges.y[:] = [yb, yt]
6462         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6463         self._request_autoscale_view(tight=True)
6464         return ret
6465 
6466     @_preprocess_data()
6467     @_docstring.dedent_interpd
6468     def contour(self, *args, **kwargs):
6469         """
6470         Plot contour lines.
6471 
6472         Call signature::
6473 
6474             contour([X, Y,] Z, [levels], **kwargs)
6475         %(contour_doc)s
6476         """
6477         kwargs['filled'] = False
6478         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6479         self._request_autoscale_view()
6480         return contours
6481 
6482     @_preprocess_data()
6483     @_docstring.dedent_interpd
6484     def contourf(self, *args, **kwargs):
6485         """
6486         Plot filled contours.
6487 
6488         Call signature::
6489 
6490             contourf([X, Y,] Z, [levels], **kwargs)
6491         %(contour_doc)s
6492         """
6493         kwargs['filled'] = True
6494         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6495         self._request_autoscale_view()
6496         return contours
6497 
6498     def clabel(self, CS, levels=None, **kwargs):
6499         """
6500         Label a contour plot.
6501 
6502         Adds labels to line contours in given `.ContourSet`.
6503 
6504         Parameters
6505         ----------
6506         CS : `.ContourSet` instance
6507             Line contours to label.
6508 
6509         levels : array-like, optional
6510             A list of level values, that should be labeled. The list must be
6511             a subset of ``CS.levels``. If not given, all levels are labeled.
6512 
6513         **kwargs
6514             All other parameters are documented in `~.ContourLabeler.clabel`.
6515         """
6516         return CS.clabel(levels, **kwargs)
6517 
6518     #### Data analysis
6519 
6520     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6521     def hist(self, x, bins=None, range=None, density=False, weights=None,
6522              cumulative=False, bottom=None, histtype='bar', align='mid',
6523              orientation='vertical', rwidth=None, log=False,
6524              color=None, label=None, stacked=False, **kwargs):
6525         """
6526         Compute and plot a histogram.
6527 
6528         This method uses `numpy.histogram` to bin the data in *x* and count the
6529         number of values in each bin, then draws the distribution either as a
6530         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6531         *weights* parameters are forwarded to `numpy.histogram`.
6532 
6533         If the data has already been binned and counted, use `~.bar` or
6534         `~.stairs` to plot the distribution::
6535 
6536             counts, bins = np.histogram(x)
6537             plt.stairs(counts, bins)
6538 
6539         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6540         treating each bin as a single point with a weight equal to its count::
6541 
6542             plt.hist(bins[:-1], bins, weights=counts)
6543 
6544         The data input *x* can be a singular array, a list of datasets of
6545         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6546         which each column is a dataset. Note that the ndarray form is
6547         transposed relative to the list form. If the input is an array, then
6548         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6549         sequence of arrays, then the return value is a tuple
6550         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6551 
6552         Masked arrays are not supported.
6553 
6554         Parameters
6555         ----------
6556         x : (n,) array or sequence of (n,) arrays
6557             Input values, this takes either a single array or a sequence of
6558             arrays which are not required to be of the same length.
6559 
6560         bins : int or sequence or str, default: :rc:`hist.bins`
6561             If *bins* is an integer, it defines the number of equal-width bins
6562             in the range.
6563 
6564             If *bins* is a sequence, it defines the bin edges, including the
6565             left edge of the first bin and the right edge of the last bin;
6566             in this case, bins may be unequally spaced.  All but the last
6567             (righthand-most) bin is half-open.  In other words, if *bins* is::
6568 
6569                 [1, 2, 3, 4]
6570 
6571             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6572             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6573             *includes* 4.
6574 
6575             If *bins* is a string, it is one of the binning strategies
6576             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6577             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6578 
6579         range : tuple or None, default: None
6580             The lower and upper range of the bins. Lower and upper outliers
6581             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6582             Range has no effect if *bins* is a sequence.
6583 
6584             If *bins* is a sequence or *range* is specified, autoscaling
6585             is based on the specified bin range instead of the
6586             range of x.
6587 
6588         density : bool, default: False
6589             If ``True``, draw and return a probability density: each bin
6590             will display the bin's raw count divided by the total number of
6591             counts *and the bin width*
6592             (``density = counts / (sum(counts) * np.diff(bins))``),
6593             so that the area under the histogram integrates to 1
6594             (``np.sum(density * np.diff(bins)) == 1``).
6595 
6596             If *stacked* is also ``True``, the sum of the histograms is
6597             normalized to 1.
6598 
6599         weights : (n,) array-like or None, default: None
6600             An array of weights, of the same shape as *x*.  Each value in
6601             *x* only contributes its associated weight towards the bin count
6602             (instead of 1).  If *density* is ``True``, the weights are
6603             normalized, so that the integral of the density over the range
6604             remains 1.
6605 
6606         cumulative : bool or -1, default: False
6607             If ``True``, then a histogram is computed where each bin gives the
6608             counts in that bin plus all bins for smaller values. The last bin
6609             gives the total number of datapoints.
6610 
6611             If *density* is also ``True`` then the histogram is normalized such
6612             that the last bin equals 1.
6613 
6614             If *cumulative* is a number less than 0 (e.g., -1), the direction
6615             of accumulation is reversed.  In this case, if *density* is also
6616             ``True``, then the histogram is normalized such that the first bin
6617             equals 1.
6618 
6619         bottom : array-like, scalar, or None, default: None
6620             Location of the bottom of each bin, i.e. bins are drawn from
6621             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6622             of each bin is shifted by the same amount. If an array, each bin
6623             is shifted independently and the length of bottom must match the
6624             number of bins. If None, defaults to 0.
6625 
6626         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6627             The type of histogram to draw.
6628 
6629             - 'bar' is a traditional bar-type histogram.  If multiple data
6630               are given the bars are arranged side by side.
6631             - 'barstacked' is a bar-type histogram where multiple
6632               data are stacked on top of each other.
6633             - 'step' generates a lineplot that is by default unfilled.
6634             - 'stepfilled' generates a lineplot that is by default filled.
6635 
6636         align : {'left', 'mid', 'right'}, default: 'mid'
6637             The horizontal alignment of the histogram bars.
6638 
6639             - 'left': bars are centered on the left bin edges.
6640             - 'mid': bars are centered between the bin edges.
6641             - 'right': bars are centered on the right bin edges.
6642 
6643         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6644             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6645             and the *bottom* kwarg will be the left edges.
6646 
6647         rwidth : float or None, default: None
6648             The relative width of the bars as a fraction of the bin width.  If
6649             ``None``, automatically compute the width.
6650 
6651             Ignored if *histtype* is 'step' or 'stepfilled'.
6652 
6653         log : bool, default: False
6654             If ``True``, the histogram axis will be set to a log scale.
6655 
6656         color : color or array-like of colors or None, default: None
6657             Color or sequence of colors, one per dataset.  Default (``None``)
6658             uses the standard line color sequence.
6659 
6660         label : str or None, default: None
6661             String, or sequence of strings to match multiple datasets.  Bar
6662             charts yield multiple patches per dataset, but only the first gets
6663             the label, so that `~.Axes.legend` will work as expected.
6664 
6665         stacked : bool, default: False
6666             If ``True``, multiple data are stacked on top of each other If
6667             ``False`` multiple data are arranged side by side if histtype is
6668             'bar' or on top of each other if histtype is 'step'
6669 
6670         Returns
6671         -------
6672         n : array or list of arrays
6673             The values of the histogram bins. See *density* and *weights* for a
6674             description of the possible semantics.  If input *x* is an array,
6675             then this is an array of length *nbins*. If input is a sequence of
6676             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6677             the values of the histograms for each of the arrays in the same
6678             order.  The dtype of the array *n* (or of its element arrays) will
6679             always be float even if no weighting or normalization is used.
6680 
6681         bins : array
6682             The edges of the bins. Length nbins + 1 (nbins left edges and right
6683             edge of last bin).  Always a single array even when multiple data
6684             sets are passed in.
6685 
6686         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6687 such objects
6688             Container of individual artists used to create the histogram
6689             or list of such containers if there are multiple input datasets.
6690 
6691         Other Parameters
6692         ----------------
6693         data : indexable object, optional
6694             DATA_PARAMETER_PLACEHOLDER
6695 
6696         **kwargs
6697             `~matplotlib.patches.Patch` properties
6698 
6699         See Also
6700         --------
6701         hist2d : 2D histogram with rectangular bins
6702         hexbin : 2D histogram with hexagonal bins
6703         stairs : Plot a pre-computed histogram
6704         bar : Plot a pre-computed histogram
6705 
6706         Notes
6707         -----
6708         For large numbers of bins (>1000), plotting can be significantly
6709         accelerated by using `~.Axes.stairs` to plot a pre-computed histogram
6710         (``plt.stairs(*np.histogram(data))``), or by setting *histtype* to
6711         'step' or 'stepfilled' rather than 'bar' or 'barstacked'.
6712         """
6713         # Avoid shadowing the builtin.
6714         bin_range = range
6715         from builtins import range
6716 
6717         if np.isscalar(x):
6718             x = [x]
6719 
6720         if bins is None:
6721             bins = mpl.rcParams['hist.bins']
6722 
6723         # Validate string inputs here to avoid cluttering subsequent code.
6724         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6725                            histtype=histtype)
6726         _api.check_in_list(['left', 'mid', 'right'], align=align)
6727         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6728 
6729         if histtype == 'barstacked' and not stacked:
6730             stacked = True
6731 
6732         # Massage 'x' for processing.
6733         x = cbook._reshape_2D(x, 'x')
6734         nx = len(x)  # number of datasets
6735 
6736         # Process unit information.  _process_unit_info sets the unit and
6737         # converts the first dataset; then we convert each following dataset
6738         # one at a time.
6739         if orientation == "vertical":
6740             convert_units = self.convert_xunits
6741             x = [*self._process_unit_info([("x", x[0])], kwargs),
6742                  *map(convert_units, x[1:])]
6743         else:  # horizontal
6744             convert_units = self.convert_yunits
6745             x = [*self._process_unit_info([("y", x[0])], kwargs),
6746                  *map(convert_units, x[1:])]
6747 
6748         if bin_range is not None:
6749             bin_range = convert_units(bin_range)
6750 
6751         if not cbook.is_scalar_or_string(bins):
6752             bins = convert_units(bins)
6753 
6754         # We need to do to 'weights' what was done to 'x'
6755         if weights is not None:
6756             w = cbook._reshape_2D(weights, 'weights')
6757         else:
6758             w = [None] * nx
6759 
6760         if len(w) != nx:
6761             raise ValueError('weights should have the same shape as x')
6762 
6763         input_empty = True
6764         for xi, wi in zip(x, w):
6765             len_xi = len(xi)
6766             if wi is not None and len(wi) != len_xi:
6767                 raise ValueError('weights should have the same shape as x')
6768             if len_xi:
6769                 input_empty = False
6770 
6771         if color is None:
6772             colors = [self._get_lines.get_next_color() for i in range(nx)]
6773         else:
6774             colors = mcolors.to_rgba_array(color)
6775             if len(colors) != nx:
6776                 raise ValueError(f"The 'color' keyword argument must have one "
6777                                  f"color per dataset, but {nx} datasets and "
6778                                  f"{len(colors)} colors were provided")
6779 
6780         hist_kwargs = dict()
6781 
6782         # if the bin_range is not given, compute without nan numpy
6783         # does not do this for us when guessing the range (but will
6784         # happily ignore nans when computing the histogram).
6785         if bin_range is None:
6786             xmin = np.inf
6787             xmax = -np.inf
6788             for xi in x:
6789                 if len(xi):
6790                     # python's min/max ignore nan,
6791                     # np.minnan returns nan for all nan input
6792                     xmin = min(xmin, np.nanmin(xi))
6793                     xmax = max(xmax, np.nanmax(xi))
6794             if xmin <= xmax:  # Only happens if we have seen a finite value.
6795                 bin_range = (xmin, xmax)
6796 
6797         # If bins are not specified either explicitly or via range,
6798         # we need to figure out the range required for all datasets,
6799         # and supply that to np.histogram.
6800         if not input_empty and len(x) > 1:
6801             if weights is not None:
6802                 _w = np.concatenate(w)
6803             else:
6804                 _w = None
6805             bins = np.histogram_bin_edges(
6806                 np.concatenate(x), bins, bin_range, _w)
6807         else:
6808             hist_kwargs['range'] = bin_range
6809 
6810         density = bool(density)
6811         if density and not stacked:
6812             hist_kwargs['density'] = density
6813 
6814         # List to store all the top coordinates of the histograms
6815         tops = []  # Will have shape (n_datasets, n_bins).
6816         # Loop through datasets
6817         for i in range(nx):
6818             # this will automatically overwrite bins,
6819             # so that each histogram uses the same bins
6820             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6821             tops.append(m)
6822         tops = np.array(tops, float)  # causes problems later if it's an int
6823         bins = np.array(bins, float)  # causes problems if float16
6824         if stacked:
6825             tops = tops.cumsum(axis=0)
6826             # If a stacked density plot, normalize so the area of all the
6827             # stacked histograms together is 1
6828             if density:
6829                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6830         if cumulative:
6831             slc = slice(None)
6832             if isinstance(cumulative, Number) and cumulative < 0:
6833                 slc = slice(None, None, -1)
6834             if density:
6835                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6836             else:
6837                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6838 
6839         patches = []
6840 
6841         if histtype.startswith('bar'):
6842 
6843             totwidth = np.diff(bins)
6844 
6845             if rwidth is not None:
6846                 dr = np.clip(rwidth, 0, 1)
6847             elif (len(tops) > 1 and
6848                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6849                 dr = 0.8
6850             else:
6851                 dr = 1.0
6852 
6853             if histtype == 'bar' and not stacked:
6854                 width = dr * totwidth / nx
6855                 dw = width
6856                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6857             elif histtype == 'barstacked' or stacked:
6858                 width = dr * totwidth
6859                 boffset, dw = 0.0, 0.0
6860 
6861             if align == 'mid':
6862                 boffset += 0.5 * totwidth
6863             elif align == 'right':
6864                 boffset += totwidth
6865 
6866             if orientation == 'horizontal':
6867                 _barfunc = self.barh
6868                 bottom_kwarg = 'left'
6869             else:  # orientation == 'vertical'
6870                 _barfunc = self.bar
6871                 bottom_kwarg = 'bottom'
6872 
6873             for top, color in zip(tops, colors):
6874                 if bottom is None:
6875                     bottom = np.zeros(len(top))
6876                 if stacked:
6877                     height = top - bottom
6878                 else:
6879                     height = top
6880                 bars = _barfunc(bins[:-1]+boffset, height, width,
6881                                 align='center', log=log,
6882                                 color=color, **{bottom_kwarg: bottom})
6883                 patches.append(bars)
6884                 if stacked:
6885                     bottom = top
6886                 boffset += dw
6887             # Remove stickies from all bars but the lowest ones, as otherwise
6888             # margin expansion would be unable to cross the stickies in the
6889             # middle of the bars.
6890             for bars in patches[1:]:
6891                 for patch in bars:
6892                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6893 
6894         elif histtype.startswith('step'):
6895             # these define the perimeter of the polygon
6896             x = np.zeros(4 * len(bins) - 3)
6897             y = np.zeros(4 * len(bins) - 3)
6898 
6899             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6900             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6901 
6902             if bottom is None:
6903                 bottom = 0
6904 
6905             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6906             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6907 
6908             if log:
6909                 if orientation == 'horizontal':
6910                     self.set_xscale('log', nonpositive='clip')
6911                 else:  # orientation == 'vertical'
6912                     self.set_yscale('log', nonpositive='clip')
6913 
6914             if align == 'left':
6915                 x -= 0.5*(bins[1]-bins[0])
6916             elif align == 'right':
6917                 x += 0.5*(bins[1]-bins[0])
6918 
6919             # If fill kwarg is set, it will be passed to the patch collection,
6920             # overriding this
6921             fill = (histtype == 'stepfilled')
6922 
6923             xvals, yvals = [], []
6924             for top in tops:
6925                 if stacked:
6926                     # top of the previous polygon becomes the bottom
6927                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6928                 # set the top of this polygon
6929                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6930 
6931                 # The starting point of the polygon has not yet been
6932                 # updated. So far only the endpoint was adjusted. This
6933                 # assignment closes the polygon. The redundant endpoint is
6934                 # later discarded (for step and stepfilled).
6935                 y[0] = y[-1]
6936 
6937                 if orientation == 'horizontal':
6938                     xvals.append(y.copy())
6939                     yvals.append(x.copy())
6940                 else:
6941                     xvals.append(x.copy())
6942                     yvals.append(y.copy())
6943 
6944             # stepfill is closed, step is not
6945             split = -1 if fill else 2 * len(bins)
6946             # add patches in reverse order so that when stacking,
6947             # items lower in the stack are plotted on top of
6948             # items higher in the stack
6949             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6950                 patches.append(self.fill(
6951                     x[:split], y[:split],
6952                     closed=True if fill else None,
6953                     facecolor=color,
6954                     edgecolor=None if fill else color,
6955                     fill=fill if fill else None,
6956                     zorder=None if fill else mlines.Line2D.zorder))
6957             for patch_list in patches:
6958                 for patch in patch_list:
6959                     if orientation == 'vertical':
6960                         patch.sticky_edges.y.append(0)
6961                     elif orientation == 'horizontal':
6962                         patch.sticky_edges.x.append(0)
6963 
6964             # we return patches, so put it back in the expected order
6965             patches.reverse()
6966 
6967         # If None, make all labels None (via zip_longest below); otherwise,
6968         # cast each element to str, but keep a single str as it.
6969         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6970         for patch, lbl in itertools.zip_longest(patches, labels):
6971             if patch:
6972                 p = patch[0]
6973                 p._internal_update(kwargs)
6974                 if lbl is not None:
6975                     p.set_label(lbl)
6976                 for p in patch[1:]:
6977                     p._internal_update(kwargs)
6978                     p.set_label('_nolegend_')
6979 
6980         if nx == 1:
6981             return tops[0], bins, patches[0]
6982         else:
6983             patch_type = ("BarContainer" if histtype.startswith("bar")
6984                           else "list[Polygon]")
6985             return tops, bins, cbook.silent_list(patch_type, patches)
6986 
6987     @_preprocess_data()
6988     def stairs(self, values, edges=None, *,
6989                orientation='vertical', baseline=0, fill=False, **kwargs):
6990         """
6991         A stepwise constant function as a line with bounding edges
6992         or a filled plot.
6993 
6994         Parameters
6995         ----------
6996         values : array-like
6997             The step heights.
6998 
6999         edges : array-like
7000             The edge positions, with ``len(edges) == len(vals) + 1``,
7001             between which the curve takes on vals values.
7002 
7003         orientation : {'vertical', 'horizontal'}, default: 'vertical'
7004             The direction of the steps. Vertical means that *values* are along
7005             the y-axis, and edges are along the x-axis.
7006 
7007         baseline : float, array-like or None, default: 0
7008             The bottom value of the bounding edges or when
7009             ``fill=True``, position of lower edge. If *fill* is
7010             True or an array is passed to *baseline*, a closed
7011             path is drawn.
7012 
7013         fill : bool, default: False
7014             Whether the area under the step curve should be filled.
7015 
7016         Returns
7017         -------
7018         StepPatch : `matplotlib.patches.StepPatch`
7019 
7020         Other Parameters
7021         ----------------
7022         data : indexable object, optional
7023             DATA_PARAMETER_PLACEHOLDER
7024 
7025         **kwargs
7026             `~matplotlib.patches.StepPatch` properties
7027 
7028         """
7029 
7030         if 'color' in kwargs:
7031             _color = kwargs.pop('color')
7032         else:
7033             _color = self._get_lines.get_next_color()
7034         if fill:
7035             kwargs.setdefault('linewidth', 0)
7036             kwargs.setdefault('facecolor', _color)
7037         else:
7038             kwargs.setdefault('edgecolor', _color)
7039 
7040         if edges is None:
7041             edges = np.arange(len(values) + 1)
7042 
7043         edges, values, baseline = self._process_unit_info(
7044             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7045 
7046         patch = mpatches.StepPatch(values,
7047                                    edges,
7048                                    baseline=baseline,
7049                                    orientation=orientation,
7050                                    fill=fill,
7051                                    **kwargs)
7052         self.add_patch(patch)
7053         if baseline is None:
7054             baseline = 0
7055         if orientation == 'vertical':
7056             patch.sticky_edges.y.append(np.min(baseline))
7057             self.update_datalim([(edges[0], np.min(baseline))])
7058         else:
7059             patch.sticky_edges.x.append(np.min(baseline))
7060             self.update_datalim([(np.min(baseline), edges[0])])
7061         self._request_autoscale_view()
7062         return patch
7063 
7064     @_preprocess_data(replace_names=["x", "y", "weights"])
7065     @_docstring.dedent_interpd
7066     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7067                cmin=None, cmax=None, **kwargs):
7068         """
7069         Make a 2D histogram plot.
7070 
7071         Parameters
7072         ----------
7073         x, y : array-like, shape (n, )
7074             Input values
7075 
7076         bins : None or int or [int, int] or array-like or [array, array]
7077 
7078             The bin specification:
7079 
7080             - If int, the number of bins for the two dimensions
7081               (nx=ny=bins).
7082             - If ``[int, int]``, the number of bins in each dimension
7083               (nx, ny = bins).
7084             - If array-like, the bin edges for the two dimensions
7085               (x_edges=y_edges=bins).
7086             - If ``[array, array]``, the bin edges in each dimension
7087               (x_edges, y_edges = bins).
7088 
7089             The default value is 10.
7090 
7091         range : array-like shape(2, 2), optional
7092             The leftmost and rightmost edges of the bins along each dimension
7093             (if not specified explicitly in the bins parameters): ``[[xmin,
7094             xmax], [ymin, ymax]]``. All values outside of this range will be
7095             considered outliers and not tallied in the histogram.
7096 
7097         density : bool, default: False
7098             Normalize histogram.  See the documentation for the *density*
7099             parameter of `~.Axes.hist` for more details.
7100 
7101         weights : array-like, shape (n, ), optional
7102             An array of values w_i weighing each sample (x_i, y_i).
7103 
7104         cmin, cmax : float, default: None
7105             All bins that has count less than *cmin* or more than *cmax* will
7106             not be displayed (set to NaN before passing to imshow) and these
7107             count values in the return value count histogram will also be set
7108             to nan upon return.
7109 
7110         Returns
7111         -------
7112         h : 2D array
7113             The bi-dimensional histogram of samples x and y. Values in x are
7114             histogrammed along the first dimension and values in y are
7115             histogrammed along the second dimension.
7116         xedges : 1D array
7117             The bin edges along the x-axis.
7118         yedges : 1D array
7119             The bin edges along the y-axis.
7120         image : `~.matplotlib.collections.QuadMesh`
7121 
7122         Other Parameters
7123         ----------------
7124         %(cmap_doc)s
7125 
7126         %(norm_doc)s
7127 
7128         %(vmin_vmax_doc)s
7129 
7130         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7131             The alpha blending value.
7132 
7133         data : indexable object, optional
7134             DATA_PARAMETER_PLACEHOLDER
7135 
7136         **kwargs
7137             Additional parameters are passed along to the
7138             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7139             constructor.
7140 
7141         See Also
7142         --------
7143         hist : 1D histogram plotting
7144         hexbin : 2D histogram with hexagonal bins
7145 
7146         Notes
7147         -----
7148         - Currently ``hist2d`` calculates its own axis limits, and any limits
7149           previously set are ignored.
7150         - Rendering the histogram with a logarithmic color scale is
7151           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7152           keyword argument. Likewise, power-law normalization (similar
7153           in effect to gamma correction) can be accomplished with
7154           `.colors.PowerNorm`.
7155         """
7156 
7157         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7158                                            density=density, weights=weights)
7159 
7160         if cmin is not None:
7161             h[h < cmin] = None
7162         if cmax is not None:
7163             h[h > cmax] = None
7164 
7165         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7166         self.set_xlim(xedges[0], xedges[-1])
7167         self.set_ylim(yedges[0], yedges[-1])
7168 
7169         return h, xedges, yedges, pc
7170 
7171     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7172     @_docstring.dedent_interpd
7173     def ecdf(self, x, weights=None, *, complementary=False,
7174              orientation="vertical", compress=False, **kwargs):
7175         """
7176         Compute and plot the empirical cumulative distribution function of *x*.
7177 
7178         .. versionadded:: 3.8
7179 
7180         Parameters
7181         ----------
7182         x : 1d array-like
7183             The input data.  Infinite entries are kept (and move the relevant
7184             end of the ecdf from 0/1), but NaNs and masked values are errors.
7185 
7186         weights : 1d array-like or None, default: None
7187             The weights of the entries; must have the same shape as *x*.
7188             Weights corresponding to NaN data points are dropped, and then the
7189             remaining weights are normalized to sum to 1.  If unset, all
7190             entries have the same weight.
7191 
7192         complementary : bool, default: False
7193             Whether to plot a cumulative distribution function, which increases
7194             from 0 to 1 (the default), or a complementary cumulative
7195             distribution function, which decreases from 1 to 0.
7196 
7197         orientation : {"vertical", "horizontal"}, default: "vertical"
7198             Whether the entries are plotted along the x-axis ("vertical", the
7199             default) or the y-axis ("horizontal").  This parameter takes the
7200             same values as in `~.Axes.hist`.
7201 
7202         compress : bool, default: False
7203             Whether multiple entries with the same values are grouped together
7204             (with a summed weight) before plotting.  This is mainly useful if
7205             *x* contains many identical data points, to decrease the rendering
7206             complexity of the plot. If *x* contains no duplicate points, this
7207             has no effect and just uses some time and memory.
7208 
7209         Other Parameters
7210         ----------------
7211         data : indexable object, optional
7212             DATA_PARAMETER_PLACEHOLDER
7213 
7214         **kwargs
7215             Keyword arguments control the `.Line2D` properties:
7216 
7217             %(Line2D:kwdoc)s
7218 
7219         Returns
7220         -------
7221         `.Line2D`
7222 
7223         Notes
7224         -----
7225         The ecdf plot can be thought of as a cumulative histogram with one bin
7226         per data entry; i.e. it reports on the entire dataset without any
7227         arbitrary binning.
7228 
7229         If *x* contains NaNs or masked entries, either remove them first from
7230         the array (if they should not taken into account), or replace them by
7231         -inf or +inf (if they should be sorted at the beginning or the end of
7232         the array).
7233         """
7234         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7235         if "drawstyle" in kwargs or "ds" in kwargs:
7236             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7237         if np.ma.getmask(x).any():
7238             raise ValueError("ecdf() does not support masked entries")
7239         x = np.asarray(x)
7240         if np.isnan(x).any():
7241             raise ValueError("ecdf() does not support NaNs")
7242         argsort = np.argsort(x)
7243         x = x[argsort]
7244         if weights is None:
7245             # Ensure that we end at exactly 1, avoiding floating point errors.
7246             cum_weights = (1 + np.arange(len(x))) / len(x)
7247         else:
7248             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7249             cum_weights = np.cumsum(weights / np.sum(weights))
7250         if compress:
7251             # Get indices of unique x values.
7252             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7253             x = x[compress_idxs]
7254             cum_weights = cum_weights[compress_idxs]
7255         if orientation == "vertical":
7256             if not complementary:
7257                 line, = self.plot([x[0], *x], [0, *cum_weights],
7258                                   drawstyle="steps-post", **kwargs)
7259             else:
7260                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7261                                   drawstyle="steps-pre", **kwargs)
7262             line.sticky_edges.y[:] = [0, 1]
7263         else:  # orientation == "horizontal":
7264             if not complementary:
7265                 line, = self.plot([0, *cum_weights], [x[0], *x],
7266                                   drawstyle="steps-pre", **kwargs)
7267             else:
7268                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7269                                   drawstyle="steps-post", **kwargs)
7270             line.sticky_edges.x[:] = [0, 1]
7271         return line
7272 
7273     @_preprocess_data(replace_names=["x"])
7274     @_docstring.dedent_interpd
7275     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7276             window=None, noverlap=None, pad_to=None,
7277             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7278         r"""
7279         Plot the power spectral density.
7280 
7281         The power spectral density :math:`P_{xx}` by Welch's average
7282         periodogram method.  The vector *x* is divided into *NFFT* length
7283         segments.  Each segment is detrended by function *detrend* and
7284         windowed by function *window*.  *noverlap* gives the length of
7285         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7286         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7287         with a scaling to correct for power loss due to windowing.
7288 
7289         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7290 
7291         Parameters
7292         ----------
7293         x : 1-D array or sequence
7294             Array or sequence containing the data
7295 
7296         %(Spectral)s
7297 
7298         %(PSD)s
7299 
7300         noverlap : int, default: 0 (no overlap)
7301             The number of points of overlap between segments.
7302 
7303         Fc : int, default: 0
7304             The center frequency of *x*, which offsets the x extents of the
7305             plot to reflect the frequency range used when a signal is acquired
7306             and then filtered and downsampled to baseband.
7307 
7308         return_line : bool, default: False
7309             Whether to include the line object plotted in the returned values.
7310 
7311         Returns
7312         -------
7313         Pxx : 1-D array
7314             The values for the power spectrum :math:`P_{xx}` before scaling
7315             (real valued).
7316 
7317         freqs : 1-D array
7318             The frequencies corresponding to the elements in *Pxx*.
7319 
7320         line : `~matplotlib.lines.Line2D`
7321             The line created by this function.
7322             Only returned if *return_line* is True.
7323 
7324         Other Parameters
7325         ----------------
7326         data : indexable object, optional
7327             DATA_PARAMETER_PLACEHOLDER
7328 
7329         **kwargs
7330             Keyword arguments control the `.Line2D` properties:
7331 
7332             %(Line2D:kwdoc)s
7333 
7334         See Also
7335         --------
7336         specgram
7337             Differs in the default overlap; in not returning the mean of the
7338             segment periodograms; in returning the times of the segments; and
7339             in plotting a colormap instead of a line.
7340         magnitude_spectrum
7341             Plots the magnitude spectrum.
7342         csd
7343             Plots the spectral density between two signals.
7344 
7345         Notes
7346         -----
7347         For plotting, the power is plotted as
7348         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7349         is returned.
7350 
7351         References
7352         ----------
7353         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7354         John Wiley & Sons (1986)
7355         """
7356         if Fc is None:
7357             Fc = 0
7358 
7359         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7360                               window=window, noverlap=noverlap, pad_to=pad_to,
7361                               sides=sides, scale_by_freq=scale_by_freq)
7362         freqs += Fc
7363 
7364         if scale_by_freq in (None, True):
7365             psd_units = 'dB/Hz'
7366         else:
7367             psd_units = 'dB'
7368 
7369         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7370         self.set_xlabel('Frequency')
7371         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7372         self.grid(True)
7373 
7374         vmin, vmax = self.get_ybound()
7375         step = max(10 * int(np.log10(vmax - vmin)), 1)
7376         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7377         self.set_yticks(ticks)
7378 
7379         if return_line is None or not return_line:
7380             return pxx, freqs
7381         else:
7382             return pxx, freqs, line
7383 
7384     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7385     @_docstring.dedent_interpd
7386     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7387             window=None, noverlap=None, pad_to=None,
7388             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7389         r"""
7390         Plot the cross-spectral density.
7391 
7392         The cross spectral density :math:`P_{xy}` by Welch's average
7393         periodogram method.  The vectors *x* and *y* are divided into
7394         *NFFT* length segments.  Each segment is detrended by function
7395         *detrend* and windowed by function *window*.  *noverlap* gives
7396         the length of the overlap between segments.  The product of
7397         the direct FFTs of *x* and *y* are averaged over each segment
7398         to compute :math:`P_{xy}`, with a scaling to correct for power
7399         loss due to windowing.
7400 
7401         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7402         padded to *NFFT*.
7403 
7404         Parameters
7405         ----------
7406         x, y : 1-D arrays or sequences
7407             Arrays or sequences containing the data.
7408 
7409         %(Spectral)s
7410 
7411         %(PSD)s
7412 
7413         noverlap : int, default: 0 (no overlap)
7414             The number of points of overlap between segments.
7415 
7416         Fc : int, default: 0
7417             The center frequency of *x*, which offsets the x extents of the
7418             plot to reflect the frequency range used when a signal is acquired
7419             and then filtered and downsampled to baseband.
7420 
7421         return_line : bool, default: False
7422             Whether to include the line object plotted in the returned values.
7423 
7424         Returns
7425         -------
7426         Pxy : 1-D array
7427             The values for the cross spectrum :math:`P_{xy}` before scaling
7428             (complex valued).
7429 
7430         freqs : 1-D array
7431             The frequencies corresponding to the elements in *Pxy*.
7432 
7433         line : `~matplotlib.lines.Line2D`
7434             The line created by this function.
7435             Only returned if *return_line* is True.
7436 
7437         Other Parameters
7438         ----------------
7439         data : indexable object, optional
7440             DATA_PARAMETER_PLACEHOLDER
7441 
7442         **kwargs
7443             Keyword arguments control the `.Line2D` properties:
7444 
7445             %(Line2D:kwdoc)s
7446 
7447         See Also
7448         --------
7449         psd : is equivalent to setting ``y = x``.
7450 
7451         Notes
7452         -----
7453         For plotting, the power is plotted as
7454         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7455         is returned.
7456 
7457         References
7458         ----------
7459         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7460         John Wiley & Sons (1986)
7461         """
7462         if Fc is None:
7463             Fc = 0
7464 
7465         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7466                               window=window, noverlap=noverlap, pad_to=pad_to,
7467                               sides=sides, scale_by_freq=scale_by_freq)
7468         # pxy is complex
7469         freqs += Fc
7470 
7471         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7472         self.set_xlabel('Frequency')
7473         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7474         self.grid(True)
7475 
7476         vmin, vmax = self.get_ybound()
7477         step = max(10 * int(np.log10(vmax - vmin)), 1)
7478         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7479         self.set_yticks(ticks)
7480 
7481         if return_line is None or not return_line:
7482             return pxy, freqs
7483         else:
7484             return pxy, freqs, line
7485 
7486     @_preprocess_data(replace_names=["x"])
7487     @_docstring.dedent_interpd
7488     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7489                            pad_to=None, sides=None, scale=None,
7490                            **kwargs):
7491         """
7492         Plot the magnitude spectrum.
7493 
7494         Compute the magnitude spectrum of *x*.  Data is padded to a
7495         length of *pad_to* and the windowing function *window* is applied to
7496         the signal.
7497 
7498         Parameters
7499         ----------
7500         x : 1-D array or sequence
7501             Array or sequence containing the data.
7502 
7503         %(Spectral)s
7504 
7505         %(Single_Spectrum)s
7506 
7507         scale : {'default', 'linear', 'dB'}
7508             The scaling of the values in the *spec*.  'linear' is no scaling.
7509             'dB' returns the values in dB scale, i.e., the dB amplitude
7510             (20 * log10). 'default' is 'linear'.
7511 
7512         Fc : int, default: 0
7513             The center frequency of *x*, which offsets the x extents of the
7514             plot to reflect the frequency range used when a signal is acquired
7515             and then filtered and downsampled to baseband.
7516 
7517         Returns
7518         -------
7519         spectrum : 1-D array
7520             The values for the magnitude spectrum before scaling (real valued).
7521 
7522         freqs : 1-D array
7523             The frequencies corresponding to the elements in *spectrum*.
7524 
7525         line : `~matplotlib.lines.Line2D`
7526             The line created by this function.
7527 
7528         Other Parameters
7529         ----------------
7530         data : indexable object, optional
7531             DATA_PARAMETER_PLACEHOLDER
7532 
7533         **kwargs
7534             Keyword arguments control the `.Line2D` properties:
7535 
7536             %(Line2D:kwdoc)s
7537 
7538         See Also
7539         --------
7540         psd
7541             Plots the power spectral density.
7542         angle_spectrum
7543             Plots the angles of the corresponding frequencies.
7544         phase_spectrum
7545             Plots the phase (unwrapped angle) of the corresponding frequencies.
7546         specgram
7547             Can plot the magnitude spectrum of segments within the signal in a
7548             colormap.
7549         """
7550         if Fc is None:
7551             Fc = 0
7552 
7553         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7554                                               pad_to=pad_to, sides=sides)
7555         freqs += Fc
7556 
7557         yunits = _api.check_getitem(
7558             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7559              'dB': 'dB'},
7560             scale=scale)
7561         if yunits == 'energy':
7562             Z = spec
7563         else:  # yunits == 'dB'
7564             Z = 20. * np.log10(spec)
7565 
7566         line, = self.plot(freqs, Z, **kwargs)
7567         self.set_xlabel('Frequency')
7568         self.set_ylabel('Magnitude (%s)' % yunits)
7569 
7570         return spec, freqs, line
7571 
7572     @_preprocess_data(replace_names=["x"])
7573     @_docstring.dedent_interpd
7574     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7575                        pad_to=None, sides=None, **kwargs):
7576         """
7577         Plot the angle spectrum.
7578 
7579         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7580         Data is padded to a length of *pad_to* and the windowing function
7581         *window* is applied to the signal.
7582 
7583         Parameters
7584         ----------
7585         x : 1-D array or sequence
7586             Array or sequence containing the data.
7587 
7588         %(Spectral)s
7589 
7590         %(Single_Spectrum)s
7591 
7592         Fc : int, default: 0
7593             The center frequency of *x*, which offsets the x extents of the
7594             plot to reflect the frequency range used when a signal is acquired
7595             and then filtered and downsampled to baseband.
7596 
7597         Returns
7598         -------
7599         spectrum : 1-D array
7600             The values for the angle spectrum in radians (real valued).
7601 
7602         freqs : 1-D array
7603             The frequencies corresponding to the elements in *spectrum*.
7604 
7605         line : `~matplotlib.lines.Line2D`
7606             The line created by this function.
7607 
7608         Other Parameters
7609         ----------------
7610         data : indexable object, optional
7611             DATA_PARAMETER_PLACEHOLDER
7612 
7613         **kwargs
7614             Keyword arguments control the `.Line2D` properties:
7615 
7616             %(Line2D:kwdoc)s
7617 
7618         See Also
7619         --------
7620         magnitude_spectrum
7621             Plots the magnitudes of the corresponding frequencies.
7622         phase_spectrum
7623             Plots the unwrapped version of this function.
7624         specgram
7625             Can plot the angle spectrum of segments within the signal in a
7626             colormap.
7627         """
7628         if Fc is None:
7629             Fc = 0
7630 
7631         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7632                                           pad_to=pad_to, sides=sides)
7633         freqs += Fc
7634 
7635         lines = self.plot(freqs, spec, **kwargs)
7636         self.set_xlabel('Frequency')
7637         self.set_ylabel('Angle (radians)')
7638 
7639         return spec, freqs, lines[0]
7640 
7641     @_preprocess_data(replace_names=["x"])
7642     @_docstring.dedent_interpd
7643     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7644                        pad_to=None, sides=None, **kwargs):
7645         """
7646         Plot the phase spectrum.
7647 
7648         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7649         Data is padded to a length of *pad_to* and the windowing function
7650         *window* is applied to the signal.
7651 
7652         Parameters
7653         ----------
7654         x : 1-D array or sequence
7655             Array or sequence containing the data
7656 
7657         %(Spectral)s
7658 
7659         %(Single_Spectrum)s
7660 
7661         Fc : int, default: 0
7662             The center frequency of *x*, which offsets the x extents of the
7663             plot to reflect the frequency range used when a signal is acquired
7664             and then filtered and downsampled to baseband.
7665 
7666         Returns
7667         -------
7668         spectrum : 1-D array
7669             The values for the phase spectrum in radians (real valued).
7670 
7671         freqs : 1-D array
7672             The frequencies corresponding to the elements in *spectrum*.
7673 
7674         line : `~matplotlib.lines.Line2D`
7675             The line created by this function.
7676 
7677         Other Parameters
7678         ----------------
7679         data : indexable object, optional
7680             DATA_PARAMETER_PLACEHOLDER
7681 
7682         **kwargs
7683             Keyword arguments control the `.Line2D` properties:
7684 
7685             %(Line2D:kwdoc)s
7686 
7687         See Also
7688         --------
7689         magnitude_spectrum
7690             Plots the magnitudes of the corresponding frequencies.
7691         angle_spectrum
7692             Plots the wrapped version of this function.
7693         specgram
7694             Can plot the phase spectrum of segments within the signal in a
7695             colormap.
7696         """
7697         if Fc is None:
7698             Fc = 0
7699 
7700         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7701                                           pad_to=pad_to, sides=sides)
7702         freqs += Fc
7703 
7704         lines = self.plot(freqs, spec, **kwargs)
7705         self.set_xlabel('Frequency')
7706         self.set_ylabel('Phase (radians)')
7707 
7708         return spec, freqs, lines[0]
7709 
7710     @_preprocess_data(replace_names=["x", "y"])
7711     @_docstring.dedent_interpd
7712     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7713                window=mlab.window_hanning, noverlap=0, pad_to=None,
7714                sides='default', scale_by_freq=None, **kwargs):
7715         r"""
7716         Plot the coherence between *x* and *y*.
7717 
7718         Coherence is the normalized cross spectral density:
7719 
7720         .. math::
7721 
7722           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7723 
7724         Parameters
7725         ----------
7726         %(Spectral)s
7727 
7728         %(PSD)s
7729 
7730         noverlap : int, default: 0 (no overlap)
7731             The number of points of overlap between blocks.
7732 
7733         Fc : int, default: 0
7734             The center frequency of *x*, which offsets the x extents of the
7735             plot to reflect the frequency range used when a signal is acquired
7736             and then filtered and downsampled to baseband.
7737 
7738         Returns
7739         -------
7740         Cxy : 1-D array
7741             The coherence vector.
7742 
7743         freqs : 1-D array
7744             The frequencies for the elements in *Cxy*.
7745 
7746         Other Parameters
7747         ----------------
7748         data : indexable object, optional
7749             DATA_PARAMETER_PLACEHOLDER
7750 
7751         **kwargs
7752             Keyword arguments control the `.Line2D` properties:
7753 
7754             %(Line2D:kwdoc)s
7755 
7756         References
7757         ----------
7758         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7759         John Wiley & Sons (1986)
7760         """
7761         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7762                                  window=window, noverlap=noverlap,
7763                                  scale_by_freq=scale_by_freq, sides=sides,
7764                                  pad_to=pad_to)
7765         freqs += Fc
7766 
7767         self.plot(freqs, cxy, **kwargs)
7768         self.set_xlabel('Frequency')
7769         self.set_ylabel('Coherence')
7770         self.grid(True)
7771 
7772         return cxy, freqs
7773 
7774     @_preprocess_data(replace_names=["x"])
7775     @_docstring.dedent_interpd
7776     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7777                  window=None, noverlap=None,
7778                  cmap=None, xextent=None, pad_to=None, sides=None,
7779                  scale_by_freq=None, mode=None, scale=None,
7780                  vmin=None, vmax=None, **kwargs):
7781         """
7782         Plot a spectrogram.
7783 
7784         Compute and plot a spectrogram of data in *x*.  Data are split into
7785         *NFFT* length segments and the spectrum of each section is
7786         computed.  The windowing function *window* is applied to each
7787         segment, and the amount of overlap of each segment is
7788         specified with *noverlap*. The spectrogram is plotted as a colormap
7789         (using imshow).
7790 
7791         Parameters
7792         ----------
7793         x : 1-D array or sequence
7794             Array or sequence containing the data.
7795 
7796         %(Spectral)s
7797 
7798         %(PSD)s
7799 
7800         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7801             What sort of spectrum to use.  Default is 'psd', which takes the
7802             power spectral density.  'magnitude' returns the magnitude
7803             spectrum.  'angle' returns the phase spectrum without unwrapping.
7804             'phase' returns the phase spectrum with unwrapping.
7805 
7806         noverlap : int, default: 128
7807             The number of points of overlap between blocks.
7808 
7809         scale : {'default', 'linear', 'dB'}
7810             The scaling of the values in the *spec*.  'linear' is no scaling.
7811             'dB' returns the values in dB scale.  When *mode* is 'psd',
7812             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7813             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7814             'magnitude' and 'linear' otherwise.  This must be 'linear'
7815             if *mode* is 'angle' or 'phase'.
7816 
7817         Fc : int, default: 0
7818             The center frequency of *x*, which offsets the x extents of the
7819             plot to reflect the frequency range used when a signal is acquired
7820             and then filtered and downsampled to baseband.
7821 
7822         cmap : `.Colormap`, default: :rc:`image.cmap`
7823 
7824         xextent : *None* or (xmin, xmax)
7825             The image extent along the x-axis. The default sets *xmin* to the
7826             left border of the first bin (*spectrum* column) and *xmax* to the
7827             right border of the last bin. Note that for *noverlap>0* the width
7828             of the bins is smaller than those of the segments.
7829 
7830         data : indexable object, optional
7831             DATA_PARAMETER_PLACEHOLDER
7832 
7833         **kwargs
7834             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7835             which makes the specgram image. The origin keyword argument
7836             is not supported.
7837 
7838         Returns
7839         -------
7840         spectrum : 2D array
7841             Columns are the periodograms of successive segments.
7842 
7843         freqs : 1-D array
7844             The frequencies corresponding to the rows in *spectrum*.
7845 
7846         t : 1-D array
7847             The times corresponding to midpoints of segments (i.e., the columns
7848             in *spectrum*).
7849 
7850         im : `.AxesImage`
7851             The image created by imshow containing the spectrogram.
7852 
7853         See Also
7854         --------
7855         psd
7856             Differs in the default overlap; in returning the mean of the
7857             segment periodograms; in not returning times; and in generating a
7858             line plot instead of colormap.
7859         magnitude_spectrum
7860             A single spectrum, similar to having a single segment when *mode*
7861             is 'magnitude'. Plots a line instead of a colormap.
7862         angle_spectrum
7863             A single spectrum, similar to having a single segment when *mode*
7864             is 'angle'. Plots a line instead of a colormap.
7865         phase_spectrum
7866             A single spectrum, similar to having a single segment when *mode*
7867             is 'phase'. Plots a line instead of a colormap.
7868 
7869         Notes
7870         -----
7871         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7872         is set to 'psd'.
7873         """
7874         if NFFT is None:
7875             NFFT = 256  # same default as in mlab.specgram()
7876         if Fc is None:
7877             Fc = 0  # same default as in mlab._spectral_helper()
7878         if noverlap is None:
7879             noverlap = 128  # same default as in mlab.specgram()
7880         if Fs is None:
7881             Fs = 2  # same default as in mlab._spectral_helper()
7882 
7883         if mode == 'complex':
7884             raise ValueError('Cannot plot a complex specgram')
7885 
7886         if scale is None or scale == 'default':
7887             if mode in ['angle', 'phase']:
7888                 scale = 'linear'
7889             else:
7890                 scale = 'dB'
7891         elif mode in ['angle', 'phase'] and scale == 'dB':
7892             raise ValueError('Cannot use dB scale with angle or phase mode')
7893 
7894         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7895                                        detrend=detrend, window=window,
7896                                        noverlap=noverlap, pad_to=pad_to,
7897                                        sides=sides,
7898                                        scale_by_freq=scale_by_freq,
7899                                        mode=mode)
7900 
7901         if scale == 'linear':
7902             Z = spec
7903         elif scale == 'dB':
7904             if mode is None or mode == 'default' or mode == 'psd':
7905                 Z = 10. * np.log10(spec)
7906             else:
7907                 Z = 20. * np.log10(spec)
7908         else:
7909             raise ValueError(f'Unknown scale {scale!r}')
7910 
7911         Z = np.flipud(Z)
7912 
7913         if xextent is None:
7914             # padding is needed for first and last segment:
7915             pad_xextent = (NFFT-noverlap) / Fs / 2
7916             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7917         xmin, xmax = xextent
7918         freqs += Fc
7919         extent = xmin, xmax, freqs[0], freqs[-1]
7920 
7921         if 'origin' in kwargs:
7922             raise _api.kwarg_error("specgram", "origin")
7923 
7924         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7925                          origin='upper', **kwargs)
7926         self.axis('auto')
7927 
7928         return spec, freqs, t, im
7929 
7930     @_docstring.dedent_interpd
7931     def spy(self, Z, precision=0, marker=None, markersize=None,
7932             aspect='equal', origin="upper", **kwargs):
7933         """
7934         Plot the sparsity pattern of a 2D array.
7935 
7936         This visualizes the non-zero values of the array.
7937 
7938         Two plotting styles are available: image and marker. Both
7939         are available for full arrays, but only the marker style
7940         works for `scipy.sparse.spmatrix` instances.
7941 
7942         **Image style**
7943 
7944         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7945         extra remaining keyword arguments are passed to this method.
7946 
7947         **Marker style**
7948 
7949         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7950         *None*, a `.Line2D` object will be returned with the value of marker
7951         determining the marker type, and any remaining keyword arguments
7952         passed to `~.Axes.plot`.
7953 
7954         Parameters
7955         ----------
7956         Z : (M, N) array-like
7957             The array to be plotted.
7958 
7959         precision : float or 'present', default: 0
7960             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7961             values of :math:`|Z| > precision` will be plotted.
7962 
7963             For `scipy.sparse.spmatrix` instances, you can also
7964             pass 'present'. In this case any value present in the array
7965             will be plotted, even if it is identically zero.
7966 
7967         aspect : {'equal', 'auto', None} or float, default: 'equal'
7968             The aspect ratio of the Axes.  This parameter is particularly
7969             relevant for images since it determines whether data pixels are
7970             square.
7971 
7972             This parameter is a shortcut for explicitly calling
7973             `.Axes.set_aspect`. See there for further details.
7974 
7975             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7976             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7977               that the data fit in the Axes. In general, this will result in
7978               non-square pixels.
7979             - *None*: Use :rc:`image.aspect`.
7980 
7981         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7982             Place the [0, 0] index of the array in the upper left or lower left
7983             corner of the Axes. The convention 'upper' is typically used for
7984             matrices and images.
7985 
7986         Returns
7987         -------
7988         `~matplotlib.image.AxesImage` or `.Line2D`
7989             The return type depends on the plotting style (see above).
7990 
7991         Other Parameters
7992         ----------------
7993         **kwargs
7994             The supported additional parameters depend on the plotting style.
7995 
7996             For the image style, you can pass the following additional
7997             parameters of `~.Axes.imshow`:
7998 
7999             - *cmap*
8000             - *alpha*
8001             - *url*
8002             - any `.Artist` properties (passed on to the `.AxesImage`)
8003 
8004             For the marker style, you can pass any `.Line2D` property except
8005             for *linestyle*:
8006 
8007             %(Line2D:kwdoc)s
8008         """
8009         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
8010             marker = 's'
8011         _api.check_in_list(["upper", "lower"], origin=origin)
8012         if marker is None and markersize is None:
8013             Z = np.asarray(Z)
8014             mask = np.abs(Z) > precision
8015 
8016             if 'cmap' not in kwargs:
8017                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
8018                                                         name='binary')
8019             if 'interpolation' in kwargs:
8020                 raise _api.kwarg_error("spy", "interpolation")
8021             if 'norm' not in kwargs:
8022                 kwargs['norm'] = mcolors.NoNorm()
8023             ret = self.imshow(mask, interpolation='nearest',
8024                               aspect=aspect, origin=origin,
8025                               **kwargs)
8026         else:
8027             if hasattr(Z, 'tocoo'):
8028                 c = Z.tocoo()
8029                 if precision == 'present':
8030                     y = c.row
8031                     x = c.col
8032                 else:
8033                     nonzero = np.abs(c.data) > precision
8034                     y = c.row[nonzero]
8035                     x = c.col[nonzero]
8036             else:
8037                 Z = np.asarray(Z)
8038                 nonzero = np.abs(Z) > precision
8039                 y, x = np.nonzero(nonzero)
8040             if marker is None:
8041                 marker = 's'
8042             if markersize is None:
8043                 markersize = 10
8044             if 'linestyle' in kwargs:
8045                 raise _api.kwarg_error("spy", "linestyle")
8046             ret = mlines.Line2D(
8047                 x, y, linestyle='None', marker=marker, markersize=markersize,
8048                 **kwargs)
8049             self.add_line(ret)
8050             nr, nc = Z.shape
8051             self.set_xlim(-0.5, nc - 0.5)
8052             if origin == "upper":
8053                 self.set_ylim(nr - 0.5, -0.5)
8054             else:
8055                 self.set_ylim(-0.5, nr - 0.5)
8056             self.set_aspect(aspect)
8057         self.title.set_y(1.05)
8058         if origin == "upper":
8059             self.xaxis.tick_top()
8060         else:  # lower
8061             self.xaxis.tick_bottom()
8062         self.xaxis.set_ticks_position('both')
8063         self.xaxis.set_major_locator(
8064             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8065         self.yaxis.set_major_locator(
8066             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8067         return ret
8068 
8069     def matshow(self, Z, **kwargs):
8070         """
8071         Plot the values of a 2D matrix or array as color-coded image.
8072 
8073         The matrix will be shown the way it would be printed, with the first
8074         row at the top.  Row and column numbering is zero-based.
8075 
8076         Parameters
8077         ----------
8078         Z : (M, N) array-like
8079             The matrix to be displayed.
8080 
8081         Returns
8082         -------
8083         `~matplotlib.image.AxesImage`
8084 
8085         Other Parameters
8086         ----------------
8087         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8088 
8089         See Also
8090         --------
8091         imshow : More general function to plot data on a 2D regular raster.
8092 
8093         Notes
8094         -----
8095         This is just a convenience function wrapping `.imshow` to set useful
8096         defaults for displaying a matrix. In particular:
8097 
8098         - Set ``origin='upper'``.
8099         - Set ``interpolation='nearest'``.
8100         - Set ``aspect='equal'``.
8101         - Ticks are placed to the left and above.
8102         - Ticks are formatted to show integer indices.
8103 
8104         """
8105         Z = np.asanyarray(Z)
8106         kw = {'origin': 'upper',
8107               'interpolation': 'nearest',
8108               'aspect': 'equal',          # (already the imshow default)
8109               **kwargs}
8110         im = self.imshow(Z, **kw)
8111         self.title.set_y(1.05)
8112         self.xaxis.tick_top()
8113         self.xaxis.set_ticks_position('both')
8114         self.xaxis.set_major_locator(
8115             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8116         self.yaxis.set_major_locator(
8117             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8118         return im
8119 
8120     @_preprocess_data(replace_names=["dataset"])
8121     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8122                    showmeans=False, showextrema=True, showmedians=False,
8123                    quantiles=None, points=100, bw_method=None):
8124         """
8125         Make a violin plot.
8126 
8127         Make a violin plot for each column of *dataset* or each vector in
8128         sequence *dataset*.  Each filled area extends to represent the
8129         entire data range, with optional lines at the mean, the median,
8130         the minimum, the maximum, and user-specified quantiles.
8131 
8132         Parameters
8133         ----------
8134         dataset : Array or a sequence of vectors.
8135           The input data.
8136 
8137         positions : array-like, default: [1, 2, ..., n]
8138           The positions of the violins. The ticks and limits are
8139           automatically set to match the positions.
8140 
8141         vert : bool, default: True.
8142           If true, creates a vertical violin plot.
8143           Otherwise, creates a horizontal violin plot.
8144 
8145         widths : array-like, default: 0.5
8146           Either a scalar or a vector that sets the maximal width of
8147           each violin. The default is 0.5, which uses about half of the
8148           available horizontal space.
8149 
8150         showmeans : bool, default: False
8151           If `True`, will toggle rendering of the means.
8152 
8153         showextrema : bool, default: True
8154           If `True`, will toggle rendering of the extrema.
8155 
8156         showmedians : bool, default: False
8157           If `True`, will toggle rendering of the medians.
8158 
8159         quantiles : array-like, default: None
8160           If not None, set a list of floats in interval [0, 1] for each violin,
8161           which stands for the quantiles that will be rendered for that
8162           violin.
8163 
8164         points : int, default: 100
8165           Defines the number of points to evaluate each of the
8166           gaussian kernel density estimations at.
8167 
8168         bw_method : str, scalar or callable, optional
8169           The method used to calculate the estimator bandwidth.  This can be
8170           'scott', 'silverman', a scalar constant or a callable.  If a
8171           scalar, this will be used directly as `kde.factor`.  If a
8172           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8173           its only parameter and return a scalar. If None (default), 'scott'
8174           is used.
8175 
8176         data : indexable object, optional
8177             DATA_PARAMETER_PLACEHOLDER
8178 
8179         Returns
8180         -------
8181         dict
8182           A dictionary mapping each component of the violinplot to a
8183           list of the corresponding collection instances created. The
8184           dictionary has the following keys:
8185 
8186           - ``bodies``: A list of the `~.collections.PolyCollection`
8187             instances containing the filled area of each violin.
8188 
8189           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8190             the mean values of each of the violin's distribution.
8191 
8192           - ``cmins``: A `~.collections.LineCollection` instance that marks
8193             the bottom of each violin's distribution.
8194 
8195           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8196             the top of each violin's distribution.
8197 
8198           - ``cbars``: A `~.collections.LineCollection` instance that marks
8199             the centers of each violin's distribution.
8200 
8201           - ``cmedians``: A `~.collections.LineCollection` instance that
8202             marks the median values of each of the violin's distribution.
8203 
8204           - ``cquantiles``: A `~.collections.LineCollection` instance created
8205             to identify the quantile values of each of the violin's
8206             distribution.
8207 
8208         """
8209 
8210         def _kde_method(X, coords):
8211             # Unpack in case of e.g. Pandas or xarray object
8212             X = cbook._unpack_to_numpy(X)
8213             # fallback gracefully if the vector contains only one value
8214             if np.all(X[0] == X):
8215                 return (X[0] == coords).astype(float)
8216             kde = mlab.GaussianKDE(X, bw_method)
8217             return kde.evaluate(coords)
8218 
8219         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8220                                      quantiles=quantiles)
8221         return self.violin(vpstats, positions=positions, vert=vert,
8222                            widths=widths, showmeans=showmeans,
8223                            showextrema=showextrema, showmedians=showmedians)
8224 
8225     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8226                showmeans=False, showextrema=True, showmedians=False):
8227         """
8228         Drawing function for violin plots.
8229 
8230         Draw a violin plot for each column of *vpstats*. Each filled area
8231         extends to represent the entire data range, with optional lines at the
8232         mean, the median, the minimum, the maximum, and the quantiles values.
8233 
8234         Parameters
8235         ----------
8236         vpstats : list of dicts
8237           A list of dictionaries containing stats for each violin plot.
8238           Required keys are:
8239 
8240           - ``coords``: A list of scalars containing the coordinates that
8241             the violin's kernel density estimate were evaluated at.
8242 
8243           - ``vals``: A list of scalars containing the values of the
8244             kernel density estimate at each of the coordinates given
8245             in *coords*.
8246 
8247           - ``mean``: The mean value for this violin's dataset.
8248 
8249           - ``median``: The median value for this violin's dataset.
8250 
8251           - ``min``: The minimum value for this violin's dataset.
8252 
8253           - ``max``: The maximum value for this violin's dataset.
8254 
8255           Optional keys are:
8256 
8257           - ``quantiles``: A list of scalars containing the quantile values
8258             for this violin's dataset.
8259 
8260         positions : array-like, default: [1, 2, ..., n]
8261           The positions of the violins. The ticks and limits are
8262           automatically set to match the positions.
8263 
8264         vert : bool, default: True.
8265           If true, plots the violins vertically.
8266           Otherwise, plots the violins horizontally.
8267 
8268         widths : array-like, default: 0.5
8269           Either a scalar or a vector that sets the maximal width of
8270           each violin. The default is 0.5, which uses about half of the
8271           available horizontal space.
8272 
8273         showmeans : bool, default: False
8274           If true, will toggle rendering of the means.
8275 
8276         showextrema : bool, default: True
8277           If true, will toggle rendering of the extrema.
8278 
8279         showmedians : bool, default: False
8280           If true, will toggle rendering of the medians.
8281 
8282         Returns
8283         -------
8284         dict
8285           A dictionary mapping each component of the violinplot to a
8286           list of the corresponding collection instances created. The
8287           dictionary has the following keys:
8288 
8289           - ``bodies``: A list of the `~.collections.PolyCollection`
8290             instances containing the filled area of each violin.
8291 
8292           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8293             the mean values of each of the violin's distribution.
8294 
8295           - ``cmins``: A `~.collections.LineCollection` instance that marks
8296             the bottom of each violin's distribution.
8297 
8298           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8299             the top of each violin's distribution.
8300 
8301           - ``cbars``: A `~.collections.LineCollection` instance that marks
8302             the centers of each violin's distribution.
8303 
8304           - ``cmedians``: A `~.collections.LineCollection` instance that
8305             marks the median values of each of the violin's distribution.
8306 
8307           - ``cquantiles``: A `~.collections.LineCollection` instance created
8308             to identify the quantiles values of each of the violin's
8309             distribution.
8310         """
8311 
8312         # Statistical quantities to be plotted on the violins
8313         means = []
8314         mins = []
8315         maxes = []
8316         medians = []
8317         quantiles = []
8318 
8319         qlens = []  # Number of quantiles in each dataset.
8320 
8321         artists = {}  # Collections to be returned
8322 
8323         N = len(vpstats)
8324         datashape_message = ("List of violinplot statistics and `{0}` "
8325                              "values must have the same length")
8326 
8327         # Validate positions
8328         if positions is None:
8329             positions = range(1, N + 1)
8330         elif len(positions) != N:
8331             raise ValueError(datashape_message.format("positions"))
8332 
8333         # Validate widths
8334         if np.isscalar(widths):
8335             widths = [widths] * N
8336         elif len(widths) != N:
8337             raise ValueError(datashape_message.format("widths"))
8338 
8339         # Calculate ranges for statistics lines (shape (2, N)).
8340         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8341 
8342         # Colors.
8343         if mpl.rcParams['_internal.classic_mode']:
8344             fillcolor = 'y'
8345             linecolor = 'r'
8346         else:
8347             fillcolor = linecolor = self._get_lines.get_next_color()
8348 
8349         # Check whether we are rendering vertically or horizontally
8350         if vert:
8351             fill = self.fill_betweenx
8352             perp_lines = functools.partial(self.hlines, colors=linecolor)
8353             par_lines = functools.partial(self.vlines, colors=linecolor)
8354         else:
8355             fill = self.fill_between
8356             perp_lines = functools.partial(self.vlines, colors=linecolor)
8357             par_lines = functools.partial(self.hlines, colors=linecolor)
8358 
8359         # Render violins
8360         bodies = []
8361         for stats, pos, width in zip(vpstats, positions, widths):
8362             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8363             vals = np.array(stats['vals'])
8364             vals = 0.5 * width * vals / vals.max()
8365             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8366                             facecolor=fillcolor, alpha=0.3)]
8367             means.append(stats['mean'])
8368             mins.append(stats['min'])
8369             maxes.append(stats['max'])
8370             medians.append(stats['median'])
8371             q = stats.get('quantiles')  # a list of floats, or None
8372             if q is None:
8373                 q = []
8374             quantiles.extend(q)
8375             qlens.append(len(q))
8376         artists['bodies'] = bodies
8377 
8378         if showmeans:  # Render means
8379             artists['cmeans'] = perp_lines(means, *line_ends)
8380         if showextrema:  # Render extrema
8381             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8382             artists['cmins'] = perp_lines(mins, *line_ends)
8383             artists['cbars'] = par_lines(positions, mins, maxes)
8384         if showmedians:  # Render medians
8385             artists['cmedians'] = perp_lines(medians, *line_ends)
8386         if quantiles:  # Render quantiles: each width is repeated qlen times.
8387             artists['cquantiles'] = perp_lines(
8388                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8389 
8390         return artists
8391 
8392     # Methods that are entirely implemented in other modules.
8393 
8394     table = mtable.table
8395 
8396     # args can be either Y or y1, y2, ... and all should be replaced
8397     stackplot = _preprocess_data()(mstack.stackplot)
8398 
8399     streamplot = _preprocess_data(
8400         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8401 
8402     tricontour = mtri.tricontour
8403     tricontourf = mtri.tricontourf
8404     tripcolor = mtri.tripcolor
8405     triplot = mtri.triplot
8406 
8407     def _get_aspect_ratio(self):
8408         """
8409         Convenience method to calculate the aspect ratio of the axes in
8410         the display coordinate system.
8411         """
8412         figure_size = self.get_figure().get_size_inches()
8413         ll, ur = self.get_position() * figure_size
8414         width, height = ur - ll
8415         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:26:21.648 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 14:26:21.648 | INFO     | Search-only: skipping patch selection
2025-10-18 14:26:21.731 | INFO     | Task matplotlib__matplotlib-25667 completed successfully.
2025-10-18 14:26:21.732 | INFO     | No patch generated. You can try running ACR again.
