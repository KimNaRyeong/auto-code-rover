[
    {
        "rel_file_path": "sphinx/ext/inheritance_diagram.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__7.2/sphinx/ext/inheritance_diagram.py",
        "start": 135,
        "end": 322,
        "class_name": "InheritanceGraph",
        "method_name": null,
        "code": "135 class InheritanceGraph:\n136     \"\"\"\n137     Given a list of classes, determines the set of classes that they inherit\n138     from all the way to the root \"object\", and then is able to generate a\n139     graphviz dot graph from them.\n140     \"\"\"\n141     def __init__(self, class_names: list[str], currmodule: str, show_builtins: bool = False,\n142                  private_bases: bool = False, parts: int = 0,\n143                  aliases: dict[str, str] | None = None, top_classes: list[Any] = [],\n144                  ) -> None:\n145         \"\"\"*class_names* is a list of child classes to show bases from.\n146 \n147         If *show_builtins* is True, then Python builtins will be shown\n148         in the graph.\n149         \"\"\"\n150         self.class_names = class_names\n151         classes = self._import_classes(class_names, currmodule)\n152         self.class_info = self._class_info(classes, show_builtins,\n153                                            private_bases, parts, aliases, top_classes)\n154         if not self.class_info:\n155             raise InheritanceException('No classes found for '\n156                                        'inheritance diagram')\n157 \n158     def _import_classes(self, class_names: list[str], currmodule: str) -> list[Any]:\n159         \"\"\"Import a list of classes.\"\"\"\n160         classes: list[Any] = []\n161         for name in class_names:\n162             classes.extend(import_classes(name, currmodule))\n163         return classes\n164 \n165     def _class_info(self, classes: list[Any], show_builtins: bool, private_bases: bool,\n166                     parts: int, aliases: dict[str, str] | None, top_classes: list[Any],\n167                     ) -> list[tuple[str, str, list[str], str]]:\n168         \"\"\"Return name and bases for all classes that are ancestors of\n169         *classes*.\n170 \n171         *parts* gives the number of dotted name parts to include in the\n172         displayed node names, from right to left. If given as a negative, the\n173         number of parts to drop from the left. A value of 0 displays the full\n174         dotted name. E.g. ``sphinx.ext.inheritance_diagram.InheritanceGraph``\n175         with ``parts=2`` or ``parts=-2`` gets displayed as\n176         ``inheritance_diagram.InheritanceGraph``, and as\n177         ``ext.inheritance_diagram.InheritanceGraph`` with ``parts=3`` or\n178         ``parts=-1``.\n179 \n180         *top_classes* gives the name(s) of the top most ancestor class to\n181         traverse to. Multiple names can be specified separated by comma.\n182         \"\"\"\n183         all_classes = {}\n184 \n185         def recurse(cls: Any) -> None:\n186             if not show_builtins and cls in py_builtins:\n187                 return\n188             if not private_bases and cls.__name__.startswith('_'):\n189                 return\n190 \n191             nodename = self.class_name(cls, parts, aliases)\n192             fullname = self.class_name(cls, 0, aliases)\n193 \n194             # Use first line of docstring as tooltip, if available\n195             tooltip = None\n196             try:\n197                 if cls.__doc__:\n198                     doc = cls.__doc__.strip().split(\"\\n\")[0]\n199                     if doc:\n200                         tooltip = '\"%s\"' % doc.replace('\"', '\\\\\"')\n201             except Exception:  # might raise AttributeError for strange classes\n202                 pass\n203 \n204             baselist: list[str] = []\n205             all_classes[cls] = (nodename, fullname, baselist, tooltip)\n206 \n207             if fullname in top_classes:\n208                 return\n209 \n210             for base in cls.__bases__:\n211                 if not show_builtins and base in py_builtins:\n212                     continue\n213                 if not private_bases and base.__name__.startswith('_'):\n214                     continue\n215                 baselist.append(self.class_name(base, parts, aliases))\n216                 if base not in all_classes:\n217                     recurse(base)\n218 \n219         for cls in classes:\n220             recurse(cls)\n221 \n222         return list(all_classes.values())  # type: ignore[arg-type]\n223 \n224     def class_name(\n225         self, cls: Any, parts: int = 0, aliases: dict[str, str] | None = None,\n226     ) -> str:\n227         \"\"\"Given a class object, return a fully-qualified name.\n228 \n229         This works for things I've tested in matplotlib so far, but may not be\n230         completely general.\n231         \"\"\"\n232         module = cls.__module__\n233         if module in ('__builtin__', 'builtins'):\n234             fullname = cls.__name__\n235         else:\n236             fullname = f'{module}.{cls.__qualname__}'\n237         if parts == 0:\n238             result = fullname\n239         else:\n240             name_parts = fullname.split('.')\n241             result = '.'.join(name_parts[-parts:])\n242         if aliases is not None and result in aliases:\n243             return aliases[result]\n244         return result\n245 \n246     def get_all_class_names(self) -> list[str]:\n247         \"\"\"Get all of the class names involved in the graph.\"\"\"\n248         return [fullname for (_, fullname, _, _) in self.class_info]\n249 \n250     # These are the default attrs for graphviz\n251     default_graph_attrs = {\n252         'rankdir': 'LR',\n253         'size': '\"8.0, 12.0\"',\n254         'bgcolor': 'transparent',\n255     }\n256     default_node_attrs = {\n257         'shape': 'box',\n258         'fontsize': 10,\n259         'height': 0.25,\n260         'fontname': '\"Vera Sans, DejaVu Sans, Liberation Sans, '\n261                     'Arial, Helvetica, sans\"',\n262         'style': '\"setlinewidth(0.5),filled\"',\n263         'fillcolor': 'white',\n264     }\n265     default_edge_attrs = {\n266         'arrowsize': 0.5,\n267         'style': '\"setlinewidth(0.5)\"',\n268     }\n269 \n270     def _format_node_attrs(self, attrs: dict[str, Any]) -> str:\n271         return ','.join(['%s=%s' % x for x in sorted(attrs.items())])\n272 \n273     def _format_graph_attrs(self, attrs: dict[str, Any]) -> str:\n274         return ''.join(['%s=%s;\\n' % x for x in sorted(attrs.items())])\n275 \n276     def generate_dot(self, name: str, urls: dict[str, str] = {},\n277                      env: BuildEnvironment | None = None,\n278                      graph_attrs: dict = {}, node_attrs: dict = {}, edge_attrs: dict = {},\n279                      ) -> str:\n280         \"\"\"Generate a graphviz dot graph from the classes that were passed in\n281         to __init__.\n282 \n283         *name* is the name of the graph.\n284 \n285         *urls* is a dictionary mapping class names to HTTP URLs.\n286 \n287         *graph_attrs*, *node_attrs*, *edge_attrs* are dictionaries containing\n288         key/value pairs to pass on as graphviz properties.\n289         \"\"\"\n290         g_attrs = self.default_graph_attrs.copy()\n291         n_attrs = self.default_node_attrs.copy()\n292         e_attrs = self.default_edge_attrs.copy()\n293         g_attrs.update(graph_attrs)\n294         n_attrs.update(node_attrs)\n295         e_attrs.update(edge_attrs)\n296         if env:\n297             g_attrs.update(env.config.inheritance_graph_attrs)\n298             n_attrs.update(env.config.inheritance_node_attrs)\n299             e_attrs.update(env.config.inheritance_edge_attrs)\n300 \n301         res: list[str] = []\n302         res.append('digraph %s {\\n' % name)\n303         res.append(self._format_graph_attrs(g_attrs))\n304 \n305         for name, fullname, bases, tooltip in sorted(self.class_info):\n306             # Write the node\n307             this_node_attrs = n_attrs.copy()\n308             if fullname in urls:\n309                 this_node_attrs['URL'] = '\"%s\"' % urls[fullname]\n310                 this_node_attrs['target'] = '\"_top\"'\n311             if tooltip:\n312                 this_node_attrs['tooltip'] = tooltip\n313             res.append('  \"%s\" [%s];\\n' %\n314                        (name, self._format_node_attrs(this_node_attrs)))\n315 \n316             # Write the edges\n317             for base_name in bases:\n318                 res.append('  \"%s\" -> \"%s\" [%s];\\n' %\n319                            (base_name, name,\n320                             self._format_node_attrs(e_attrs)))\n321         res.append('}\\n')\n322         return ''.join(res)\n",
        "intended_behavior": "The code within `InheritanceGraph` related to URL or path generation for links in SVG diagrams should ensure that paths are correctly calculated relative to the document in which the diagram is embedded, rather than relative to the SVG file itself. This adjustment will require ensuring that links are properly prefixed with the necessary path to correct for being nested within subdirectories. Specifically, when generating links, the code should consider the depth of the directory structure in which the output document resides and adjust the link paths accordingly. This could involve calculating the relative path from the document to the root of the documentation site and then appending this to the links within the SVG, ensuring they correctly point to the intended class documentation pages regardless of the document's location in the directory hierarchy. Preserve the existing functionality for diagrams in the root directory, ensuring that no regression occurs for those use cases."
    }
]