2025-10-18 17:39:52.939 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 17:39:56.918 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=479, output_tokens=13, cost=0.005180
2025-10-18 17:40:02.185 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=659, output_tokens=210, cost=0.012890
2025-10-18 17:40:03.184 | INFO     | registered non reproducing test 0
2025-10-18 17:40:14.997 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1713, output_tokens=554, cost=0.033750
2025-10-18 17:40:15.973 | INFO     | registered non reproducing test 1
2025-10-18 17:40:26.623 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2057, output_tokens=466, cost=0.034550
2025-10-18 17:40:27.601 | INFO     | registered non reproducing test 2
2025-10-18 17:40:27.601 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 17:40:27.607 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 17:40:34.957 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=781, output_tokens=343, cost=0.018100
2025-10-18 17:40:34.965 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 17:40:38.694 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=697, output_tokens=69, cost=0.009040
2025-10-18 17:40:38.696 | DEBUG    | Extracted a valid json.
2025-10-18 17:40:38.701 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"AdaBoostClassifier\")",
        "search_method_in_class(\"_validate_params\", \"AdaBoostClassifier\")",
        "search_code(\"validate_parameter_constraints\")",
        "search_code(\"`base_estimator` parameter of AdaBoostClassifier\")"
    ],
    "bug_locations": []
}
2025-10-18 17:40:38.767 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 17:40:38.767 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 17:40:56.442 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1631, output_tokens=774, cost=0.039530
2025-10-18 17:40:56.456 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 17:41:07.409 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2621, output_tokens=449, cost=0.039680
2025-10-18 17:41:07.417 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 17:41:17.646 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=803, output_tokens=403, cost=0.020120
2025-10-18 17:41:17.647 | DEBUG    | Extracted a valid json.
2025-10-18 17:41:17.647 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sklearn/ensemble/_weight_boosting.py",
            "class": "AdaBoostClassifier",
            "method": "__init__",
            "intended_behavior": "In the constructor of `AdaBoostClassifier`, the handling of the `base_estimator` parameter needs to be adjusted. Presently, setting `base_estimator=None` isn't correctly processed under the deprecation strategy. The intended behavior would allow users to set `base_estimator=None` without encountering validation errors. This could be managed by adding a check at the start of the `__init__` method (or within the deprecation handling logic) that treats `base_estimator=None` equivalently to not setting `base_estimator` at all or directly mapping it to the new `estimator` parameter as `None`. Additionally, documentation and deprecation warnings should be updated accordingly to inform users about the correct usage and the deprecation plan."
        },
        {
            "file": "Likely within `sklearn/utils/_param_validation.py` or `sklearn/base.py`",
            "method": "Likely within how `validate_parameter_constraints` is called or defined",
            "intended_behavior": "To solve the issue, wherever `validate_parameter_constraints` is applied to `AdaBoostClassifier`'s parameters, the validation logic should be updated to handle `None` as a valid value for `base_estimator` during its deprecation period. The code should explicitly allow `None` for `base_estimator` without throwing a validation exception if the parameter is in a deprecation phase. The validation logic should include a conditional check to see if `base_estimator` is deprecated, and if so, allow `None` as a valid value alongside any current checks for `fit` and `predict` methods (or the 'deprecated' string). This exception should be clearly documented in the code to aid future maintainers."
        }
    ]
}
2025-10-18 17:41:17.653 | DEBUG    | Found override of __init__ in BaseWeightBoosting
2025-10-18 17:41:17.654 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x761e6b526c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x761d7b11a3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x761d78dc3800>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x761d7b11a480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x761d78d3fcb0>
    └ <function run_task_in_subprocess at 0x761d7b11a660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x761d78d3fcb0>
    │        │      └ <function run_raw_task at 0x761d7b11a700>
    │        └ <function ProcessPoolExecutor.submit at 0x761e6ae72020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x761e6ae71da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x761e6ae71ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x761e6ae71f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x761e6b02cea0>
    └ <ForkProcess name='ForkProcess-368' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-368' parent=497161 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x761e6b09e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-368' parent=497161 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-368' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-368' parent=497161 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-368' parent=497161 started>
    │    └ <function Popen._launch at 0x761d7911b7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x761d7a57e840>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x761e6b02d8a0>
           └ <ForkProcess name='ForkProcess-368' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x761e6b02ce00>
    └ <ForkProcess name='ForkProcess-368' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-368' parent=497161 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x761d79004f20>, <multiprocessing.queues.SimpleQueue object at 0x761d795c6e...
    │    │        └ <ForkProcess name='ForkProcess-368' parent=497161 started>
    │    └ <function _process_worker at 0x761e6ae711c0>
    └ <ForkProcess name='ForkProcess-368' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x761d7a57e000>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         └ <function run_raw_task at 0x761d7b11a700>
        └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output5/scikit-learn__scikit-learn-26242_2025-10-18_17-39-52'
             │            │    └ <function RawSweTask.to_task at 0x761d7b1196c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x761d7a57e000>
             └ <function do_inference at 0x761d7b11a8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x761d7b228400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x761d7b9b84a0>
       │                 │         │            └ SweTask(task_id='scikit-learn__scikit-learn-26242', problem_statement='AdaBoost: deprecation of "base_estimator" does not han...
       │                 │         └ <app.manage.ProjectApiManager object at 0x761d7b6a3170>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output5/scikit-learn__scikit-learn-26242_2025-10-18_17-39-52/output_0')
       └ <function _run_one_task at 0x761d7b2298a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x761d7b431bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
                                  └ <app.manage.ProjectApiManager object at 0x761d7b6a3170>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'sklearn/ensemble/_weight_boosting.py', 'class': 'AdaBoostClassifier', 'method': '__init__', 'intended_behavior': "I...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x761d7b4318a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x761d7b21d610>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ '__init__'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit...
    │    │                      │   └ 'AdaBoostClassifier'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit...
    │    └ <function SearchBackend._get_inherited_methods at 0x761d7b431800>
    └ <app.search.search_backend.SearchBackend object at 0x761d7b21d610>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'BaseWeightBoosting', 'method_name': '__init__'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x761d7b430f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x761d7b21d610>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x761d7b21d610>, {'class_name': 'BaseWeightBoosting', 'method_name': '__i...
           └ <function SearchBackend.search_method_in_class at 0x761d7b430ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-18 17:41:17.661 | DEBUG    | Bug location extracted successfully: [<file>sklearn/ensemble/_weight_boosting.py</file>
<class>AdaBoostClassifier</class>
<method>__init__</method>
<code>
490     def __init__(
491         self,
492         estimator=None,
493         *,
494         n_estimators=50,
495         learning_rate=1.0,
496         algorithm="SAMME.R",
497         random_state=None,
498         base_estimator="deprecated",
499     ):
500         super().__init__(
501             estimator=estimator,
502             n_estimators=n_estimators,
503             learning_rate=learning_rate,
504             random_state=random_state,
505             base_estimator=base_estimator,
506         )
507 
508         self.algorithm = algorithm

</code><intended_behavior>In the constructor of `AdaBoostClassifier`, the handling of the `base_estimator` parameter needs to be adjusted. Presently, setting `base_estimator=None` isn't correctly processed under the deprecation strategy. The intended behavior would allow users to set `base_estimator=None` without encountering validation errors. This could be managed by adding a check at the start of the `__init__` method (or within the deprecation handling logic) that treats `base_estimator=None` equivalently to not setting `base_estimator` at all or directly mapping it to the new `estimator` parameter as `None`. Additionally, documentation and deprecation warnings should be updated accordingly to inform users about the correct usage and the deprecation plan.</intended_behavior>, <file>sklearn/ensemble/_weight_boosting.py</file>
<class>AdaBoostClassifier</class>
<method>None</method>
<code>
331 class AdaBoostClassifier(ClassifierMixin, BaseWeightBoosting):
332     """An AdaBoost classifier.
333 
334     An AdaBoost [1] classifier is a meta-estimator that begins by fitting a
335     classifier on the original dataset and then fits additional copies of the
336     classifier on the same dataset but where the weights of incorrectly
337     classified instances are adjusted such that subsequent classifiers focus
338     more on difficult cases.
339 
340     This class implements the algorithm known as AdaBoost-SAMME [2].
341 
342     Read more in the :ref:`User Guide <adaboost>`.
343 
344     .. versionadded:: 0.14
345 
346     Parameters
347     ----------
348     estimator : object, default=None
349         The base estimator from which the boosted ensemble is built.
350         Support for sample weighting is required, as well as proper
351         ``classes_`` and ``n_classes_`` attributes. If ``None``, then
352         the base estimator is :class:`~sklearn.tree.DecisionTreeClassifier`
353         initialized with `max_depth=1`.
354 
355         .. versionadded:: 1.2
356            `base_estimator` was renamed to `estimator`.
357 
358     n_estimators : int, default=50
359         The maximum number of estimators at which boosting is terminated.
360         In case of perfect fit, the learning procedure is stopped early.
361         Values must be in the range `[1, inf)`.
362 
363     learning_rate : float, default=1.0
364         Weight applied to each classifier at each boosting iteration. A higher
365         learning rate increases the contribution of each classifier. There is
366         a trade-off between the `learning_rate` and `n_estimators` parameters.
367         Values must be in the range `(0.0, inf)`.
368 
369     algorithm : {'SAMME', 'SAMME.R'}, default='SAMME.R'
370         If 'SAMME.R' then use the SAMME.R real boosting algorithm.
371         ``estimator`` must support calculation of class probabilities.
372         If 'SAMME' then use the SAMME discrete boosting algorithm.
373         The SAMME.R algorithm typically converges faster than SAMME,
374         achieving a lower test error with fewer boosting iterations.
375 
376     random_state : int, RandomState instance or None, default=None
377         Controls the random seed given at each `estimator` at each
378         boosting iteration.
379         Thus, it is only used when `estimator` exposes a `random_state`.
380         Pass an int for reproducible output across multiple function calls.
381         See :term:`Glossary <random_state>`.
382 
383     base_estimator : object, default=None
384         The base estimator from which the boosted ensemble is built.
385         Support for sample weighting is required, as well as proper
386         ``classes_`` and ``n_classes_`` attributes. If ``None``, then
387         the base estimator is :class:`~sklearn.tree.DecisionTreeClassifier`
388         initialized with `max_depth=1`.
389 
390         .. deprecated:: 1.2
391             `base_estimator` is deprecated and will be removed in 1.4.
392             Use `estimator` instead.
393 
394     Attributes
395     ----------
396     estimator_ : estimator
397         The base estimator from which the ensemble is grown.
398 
399         .. versionadded:: 1.2
400            `base_estimator_` was renamed to `estimator_`.
401 
402     base_estimator_ : estimator
403         The base estimator from which the ensemble is grown.
404 
405         .. deprecated:: 1.2
406             `base_estimator_` is deprecated and will be removed in 1.4.
407             Use `estimator_` instead.
408 
409     estimators_ : list of classifiers
410         The collection of fitted sub-estimators.
411 
412     classes_ : ndarray of shape (n_classes,)
413         The classes labels.
414 
415     n_classes_ : int
416         The number of classes.
417 
418     estimator_weights_ : ndarray of floats
419         Weights for each estimator in the boosted ensemble.
420 
421     estimator_errors_ : ndarray of floats
422         Classification error for each estimator in the boosted
423         ensemble.
424 
425     feature_importances_ : ndarray of shape (n_features,)
426         The impurity-based feature importances if supported by the
427         ``estimator`` (when based on decision trees).
428 
429         Warning: impurity-based feature importances can be misleading for
430         high cardinality features (many unique values). See
431         :func:`sklearn.inspection.permutation_importance` as an alternative.
432 
433     n_features_in_ : int
434         Number of features seen during :term:`fit`.
435 
436         .. versionadded:: 0.24
437 
438     feature_names_in_ : ndarray of shape (`n_features_in_`,)
439         Names of features seen during :term:`fit`. Defined only when `X`
440         has feature names that are all strings.
441 
442         .. versionadded:: 1.0
443 
444     See Also
445     --------
446     AdaBoostRegressor : An AdaBoost regressor that begins by fitting a
447         regressor on the original dataset and then fits additional copies of
448         the regressor on the same dataset but where the weights of instances
449         are adjusted according to the error of the current prediction.
450 
451     GradientBoostingClassifier : GB builds an additive model in a forward
452         stage-wise fashion. Regression trees are fit on the negative gradient
453         of the binomial or multinomial deviance loss function. Binary
454         classification is a special case where only a single regression tree is
455         induced.
456 
457     sklearn.tree.DecisionTreeClassifier : A non-parametric supervised learning
458         method used for classification.
459         Creates a model that predicts the value of a target variable by
460         learning simple decision rules inferred from the data features.
461 
462     References
463     ----------
464     .. [1] Y. Freund, R. Schapire, "A Decision-Theoretic Generalization of
465            on-Line Learning and an Application to Boosting", 1995.
466 
467     .. [2] J. Zhu, H. Zou, S. Rosset, T. Hastie, "Multi-class AdaBoost", 2009.
468 
469     Examples
470     --------
471     >>> from sklearn.ensemble import AdaBoostClassifier
472     >>> from sklearn.datasets import make_classification
473     >>> X, y = make_classification(n_samples=1000, n_features=4,
474     ...                            n_informative=2, n_redundant=0,
475     ...                            random_state=0, shuffle=False)
476     >>> clf = AdaBoostClassifier(n_estimators=100, random_state=0)
477     >>> clf.fit(X, y)
478     AdaBoostClassifier(n_estimators=100, random_state=0)
479     >>> clf.predict([[0, 0, 0, 0]])
480     array([1])
481     >>> clf.score(X, y)
482     0.983...
483     """
484 
485     _parameter_constraints: dict = {
486         **BaseWeightBoosting._parameter_constraints,
487         "algorithm": [StrOptions({"SAMME", "SAMME.R"})],
488     }
489 
490     def __init__(
491         self,
492         estimator=None,
493         *,
494         n_estimators=50,
495         learning_rate=1.0,
496         algorithm="SAMME.R",
497         random_state=None,
498         base_estimator="deprecated",
499     ):
500         super().__init__(
501             estimator=estimator,
502             n_estimators=n_estimators,
503             learning_rate=learning_rate,
504             random_state=random_state,
505             base_estimator=base_estimator,
506         )
507 
508         self.algorithm = algorithm
509 
510     def _validate_estimator(self):
511         """Check the estimator and set the estimator_ attribute."""
512         super()._validate_estimator(default=DecisionTreeClassifier(max_depth=1))
513 
514         #  SAMME-R requires predict_proba-enabled base estimators
515         if self.algorithm == "SAMME.R":
516             if not hasattr(self.estimator_, "predict_proba"):
517                 raise TypeError(
518                     "AdaBoostClassifier with algorithm='SAMME.R' requires "
519                     "that the weak learner supports the calculation of class "
520                     "probabilities with a predict_proba method.\n"
521                     "Please change the base estimator or set "
522                     "algorithm='SAMME' instead."
523                 )
524         if not has_fit_parameter(self.estimator_, "sample_weight"):
525             raise ValueError(
526                 f"{self.estimator.__class__.__name__} doesn't support sample_weight."
527             )
528 
529     def _boost(self, iboost, X, y, sample_weight, random_state):
530         """Implement a single boost.
531 
532         Perform a single boost according to the real multi-class SAMME.R
533         algorithm or to the discrete SAMME algorithm and return the updated
534         sample weights.
535 
536         Parameters
537         ----------
538         iboost : int
539             The index of the current boost iteration.
540 
541         X : {array-like, sparse matrix} of shape (n_samples, n_features)
542             The training input samples.
543 
544         y : array-like of shape (n_samples,)
545             The target values (class labels).
546 
547         sample_weight : array-like of shape (n_samples,)
548             The current sample weights.
549 
550         random_state : RandomState instance
551             The RandomState instance used if the base estimator accepts a
552             `random_state` attribute.
553 
554         Returns
555         -------
556         sample_weight : array-like of shape (n_samples,) or None
557             The reweighted sample weights.
558             If None then boosting has terminated early.
559 
560         estimator_weight : float
561             The weight for the current boost.
562             If None then boosting has terminated early.
563 
564         estimator_error : float
565             The classification error for the current boost.
566             If None then boosting has terminated early.
567         """
568         if self.algorithm == "SAMME.R":
569             return self._boost_real(iboost, X, y, sample_weight, random_state)
570 
571         else:  # elif self.algorithm == "SAMME":
572             return self._boost_discrete(iboost, X, y, sample_weight, random_state)
573 
574     def _boost_real(self, iboost, X, y, sample_weight, random_state):
575         """Implement a single boost using the SAMME.R real algorithm."""
576         estimator = self._make_estimator(random_state=random_state)
577 
578         estimator.fit(X, y, sample_weight=sample_weight)
579 
580         y_predict_proba = estimator.predict_proba(X)
581 
582         if iboost == 0:
583             self.classes_ = getattr(estimator, "classes_", None)
584             self.n_classes_ = len(self.classes_)
585 
586         y_predict = self.classes_.take(np.argmax(y_predict_proba, axis=1), axis=0)
587 
588         # Instances incorrectly classified
589         incorrect = y_predict != y
590 
591         # Error fraction
592         estimator_error = np.mean(np.average(incorrect, weights=sample_weight, axis=0))
593 
594         # Stop if classification is perfect
595         if estimator_error <= 0:
596             return sample_weight, 1.0, 0.0
597 
598         # Construct y coding as described in Zhu et al [2]:
599         #
600         #    y_k = 1 if c == k else -1 / (K - 1)
601         #
602         # where K == n_classes_ and c, k in [0, K) are indices along the second
603         # axis of the y coding with c being the index corresponding to the true
604         # class label.
605         n_classes = self.n_classes_
606         classes = self.classes_
607         y_codes = np.array([-1.0 / (n_classes - 1), 1.0])
608         y_coding = y_codes.take(classes == y[:, np.newaxis])
609 
610         # Displace zero probabilities so the log is defined.
611         # Also fix negative elements which may occur with
612         # negative sample weights.
613         proba = y_predict_proba  # alias for readability
614         np.clip(proba, np.finfo(proba.dtype).eps, None, out=proba)
615 
616         # Boost weight using multi-class AdaBoost SAMME.R alg
617         estimator_weight = (
618             -1.0
619             * self.learning_rate
620             * ((n_classes - 1.0) / n_classes)
621             * xlogy(y_coding, y_predict_proba).sum(axis=1)
622         )
623 
624         # Only boost the weights if it will fit again
625         if not iboost == self.n_estimators - 1:
626             # Only boost positive weights
627             sample_weight *= np.exp(
628                 estimator_weight * ((sample_weight > 0) | (estimator_weight < 0))
629             )
630 
631         return sample_weight, 1.0, estimator_error
632 
633     def _boost_discrete(self, iboost, X, y, sample_weight, random_state):
634         """Implement a single boost using the SAMME discrete algorithm."""
635         estimator = self._make_estimator(random_state=random_state)
636 
637         estimator.fit(X, y, sample_weight=sample_weight)
638 
639         y_predict = estimator.predict(X)
640 
641         if iboost == 0:
642             self.classes_ = getattr(estimator, "classes_", None)
643             self.n_classes_ = len(self.classes_)
644 
645         # Instances incorrectly classified
646         incorrect = y_predict != y
647 
648         # Error fraction
649         estimator_error = np.mean(np.average(incorrect, weights=sample_weight, axis=0))
650 
651         # Stop if classification is perfect
652         if estimator_error <= 0:
653             return sample_weight, 1.0, 0.0
654 
655         n_classes = self.n_classes_
656 
657         # Stop if the error is at least as bad as random guessing
658         if estimator_error >= 1.0 - (1.0 / n_classes):
659             self.estimators_.pop(-1)
660             if len(self.estimators_) == 0:
661                 raise ValueError(
662                     "BaseClassifier in AdaBoostClassifier "
663                     "ensemble is worse than random, ensemble "
664                     "can not be fit."
665                 )
666             return None, None, None
667 
668         # Boost weight using multi-class AdaBoost SAMME alg
669         estimator_weight = self.learning_rate * (
670             np.log((1.0 - estimator_error) / estimator_error) + np.log(n_classes - 1.0)
671         )
672 
673         # Only boost the weights if it will fit again
674         if not iboost == self.n_estimators - 1:
675             # Only boost positive weights
676             sample_weight = np.exp(
677                 np.log(sample_weight)
678                 + estimator_weight * incorrect * (sample_weight > 0)
679             )
680 
681         return sample_weight, estimator_weight, estimator_error
682 
683     def predict(self, X):
684         """Predict classes for X.
685 
686         The predicted class of an input sample is computed as the weighted mean
687         prediction of the classifiers in the ensemble.
688 
689         Parameters
690         ----------
691         X : {array-like, sparse matrix} of shape (n_samples, n_features)
692             The training input samples. Sparse matrix can be CSC, CSR, COO,
693             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
694 
695         Returns
696         -------
697         y : ndarray of shape (n_samples,)
698             The predicted classes.
699         """
700         pred = self.decision_function(X)
701 
702         if self.n_classes_ == 2:
703             return self.classes_.take(pred > 0, axis=0)
704 
705         return self.classes_.take(np.argmax(pred, axis=1), axis=0)
706 
707     def staged_predict(self, X):
708         """Return staged predictions for X.
709 
710         The predicted class of an input sample is computed as the weighted mean
711         prediction of the classifiers in the ensemble.
712 
713         This generator method yields the ensemble prediction after each
714         iteration of boosting and therefore allows monitoring, such as to
715         determine the prediction on a test set after each boost.
716 
717         Parameters
718         ----------
719         X : array-like of shape (n_samples, n_features)
720             The input samples. Sparse matrix can be CSC, CSR, COO,
721             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
722 
723         Yields
724         ------
725         y : generator of ndarray of shape (n_samples,)
726             The predicted classes.
727         """
728         X = self._check_X(X)
729 
730         n_classes = self.n_classes_
731         classes = self.classes_
732 
733         if n_classes == 2:
734             for pred in self.staged_decision_function(X):
735                 yield np.array(classes.take(pred > 0, axis=0))
736 
737         else:
738             for pred in self.staged_decision_function(X):
739                 yield np.array(classes.take(np.argmax(pred, axis=1), axis=0))
740 
741     def decision_function(self, X):
742         """Compute the decision function of ``X``.
743 
744         Parameters
745         ----------
746         X : {array-like, sparse matrix} of shape (n_samples, n_features)
747             The training input samples. Sparse matrix can be CSC, CSR, COO,
748             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
749 
750         Returns
751         -------
752         score : ndarray of shape of (n_samples, k)
753             The decision function of the input samples. The order of
754             outputs is the same of that of the :term:`classes_` attribute.
755             Binary classification is a special cases with ``k == 1``,
756             otherwise ``k==n_classes``. For binary classification,
757             values closer to -1 or 1 mean more like the first or second
758             class in ``classes_``, respectively.
759         """
760         check_is_fitted(self)
761         X = self._check_X(X)
762 
763         n_classes = self.n_classes_
764         classes = self.classes_[:, np.newaxis]
765 
766         if self.algorithm == "SAMME.R":
767             # The weights are all 1. for SAMME.R
768             pred = sum(
769                 _samme_proba(estimator, n_classes, X) for estimator in self.estimators_
770             )
771         else:  # self.algorithm == "SAMME"
772             pred = sum(
773                 (estimator.predict(X) == classes).T * w
774                 for estimator, w in zip(self.estimators_, self.estimator_weights_)
775             )
776 
777         pred /= self.estimator_weights_.sum()
778         if n_classes == 2:
779             pred[:, 0] *= -1
780             return pred.sum(axis=1)
781         return pred
782 
783     def staged_decision_function(self, X):
784         """Compute decision function of ``X`` for each boosting iteration.
785 
786         This method allows monitoring (i.e. determine error on testing set)
787         after each boosting iteration.
788 
789         Parameters
790         ----------
791         X : {array-like, sparse matrix} of shape (n_samples, n_features)
792             The training input samples. Sparse matrix can be CSC, CSR, COO,
793             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
794 
795         Yields
796         ------
797         score : generator of ndarray of shape (n_samples, k)
798             The decision function of the input samples. The order of
799             outputs is the same of that of the :term:`classes_` attribute.
800             Binary classification is a special cases with ``k == 1``,
801             otherwise ``k==n_classes``. For binary classification,
802             values closer to -1 or 1 mean more like the first or second
803             class in ``classes_``, respectively.
804         """
805         check_is_fitted(self)
806         X = self._check_X(X)
807 
808         n_classes = self.n_classes_
809         classes = self.classes_[:, np.newaxis]
810         pred = None
811         norm = 0.0
812 
813         for weight, estimator in zip(self.estimator_weights_, self.estimators_):
814             norm += weight
815 
816             if self.algorithm == "SAMME.R":
817                 # The weights are all 1. for SAMME.R
818                 current_pred = _samme_proba(estimator, n_classes, X)
819             else:  # elif self.algorithm == "SAMME":
820                 current_pred = estimator.predict(X)
821                 current_pred = (current_pred == classes).T * weight
822 
823             if pred is None:
824                 pred = current_pred
825             else:
826                 pred += current_pred
827 
828             if n_classes == 2:
829                 tmp_pred = np.copy(pred)
830                 tmp_pred[:, 0] *= -1
831                 yield (tmp_pred / norm).sum(axis=1)
832             else:
833                 yield pred / norm
834 
835     @staticmethod
836     def _compute_proba_from_decision(decision, n_classes):
837         """Compute probabilities from the decision function.
838 
839         This is based eq. (4) of [1] where:
840             p(y=c|X) = exp((1 / K-1) f_c(X)) / sum_k(exp((1 / K-1) f_k(X)))
841                      = softmax((1 / K-1) * f(X))
842 
843         References
844         ----------
845         .. [1] J. Zhu, H. Zou, S. Rosset, T. Hastie, "Multi-class AdaBoost",
846                2009.
847         """
848         if n_classes == 2:
849             decision = np.vstack([-decision, decision]).T / 2
850         else:
851             decision /= n_classes - 1
852         return softmax(decision, copy=False)
853 
854     def predict_proba(self, X):
855         """Predict class probabilities for X.
856 
857         The predicted class probabilities of an input sample is computed as
858         the weighted mean predicted class probabilities of the classifiers
859         in the ensemble.
860 
861         Parameters
862         ----------
863         X : {array-like, sparse matrix} of shape (n_samples, n_features)
864             The training input samples. Sparse matrix can be CSC, CSR, COO,
865             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
866 
867         Returns
868         -------
869         p : ndarray of shape (n_samples, n_classes)
870             The class probabilities of the input samples. The order of
871             outputs is the same of that of the :term:`classes_` attribute.
872         """
873         check_is_fitted(self)
874         n_classes = self.n_classes_
875 
876         if n_classes == 1:
877             return np.ones((_num_samples(X), 1))
878 
879         decision = self.decision_function(X)
880         return self._compute_proba_from_decision(decision, n_classes)
881 
882     def staged_predict_proba(self, X):
883         """Predict class probabilities for X.
884 
885         The predicted class probabilities of an input sample is computed as
886         the weighted mean predicted class probabilities of the classifiers
887         in the ensemble.
888 
889         This generator method yields the ensemble predicted class probabilities
890         after each iteration of boosting and therefore allows monitoring, such
891         as to determine the predicted class probabilities on a test set after
892         each boost.
893 
894         Parameters
895         ----------
896         X : {array-like, sparse matrix} of shape (n_samples, n_features)
897             The training input samples. Sparse matrix can be CSC, CSR, COO,
898             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
899 
900         Yields
901         ------
902         p : generator of ndarray of shape (n_samples,)
903             The class probabilities of the input samples. The order of
904             outputs is the same of that of the :term:`classes_` attribute.
905         """
906 
907         n_classes = self.n_classes_
908 
909         for decision in self.staged_decision_function(X):
910             yield self._compute_proba_from_decision(decision, n_classes)
911 
912     def predict_log_proba(self, X):
913         """Predict class log-probabilities for X.
914 
915         The predicted class log-probabilities of an input sample is computed as
916         the weighted mean predicted class log-probabilities of the classifiers
917         in the ensemble.
918 
919         Parameters
920         ----------
921         X : {array-like, sparse matrix} of shape (n_samples, n_features)
922             The training input samples. Sparse matrix can be CSC, CSR, COO,
923             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
924 
925         Returns
926         -------
927         p : ndarray of shape (n_samples, n_classes)
928             The class probabilities of the input samples. The order of
929             outputs is the same of that of the :term:`classes_` attribute.
930         """
931         return np.log(self.predict_proba(X))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 17:41:17.661 | INFO     | Search completed. Bug locations: [<file>sklearn/ensemble/_weight_boosting.py</file>
<class>AdaBoostClassifier</class>
<method>__init__</method>
<code>
490     def __init__(
491         self,
492         estimator=None,
493         *,
494         n_estimators=50,
495         learning_rate=1.0,
496         algorithm="SAMME.R",
497         random_state=None,
498         base_estimator="deprecated",
499     ):
500         super().__init__(
501             estimator=estimator,
502             n_estimators=n_estimators,
503             learning_rate=learning_rate,
504             random_state=random_state,
505             base_estimator=base_estimator,
506         )
507 
508         self.algorithm = algorithm

</code><intended_behavior>In the constructor of `AdaBoostClassifier`, the handling of the `base_estimator` parameter needs to be adjusted. Presently, setting `base_estimator=None` isn't correctly processed under the deprecation strategy. The intended behavior would allow users to set `base_estimator=None` without encountering validation errors. This could be managed by adding a check at the start of the `__init__` method (or within the deprecation handling logic) that treats `base_estimator=None` equivalently to not setting `base_estimator` at all or directly mapping it to the new `estimator` parameter as `None`. Additionally, documentation and deprecation warnings should be updated accordingly to inform users about the correct usage and the deprecation plan.</intended_behavior>, <file>sklearn/ensemble/_weight_boosting.py</file>
<class>AdaBoostClassifier</class>
<method>None</method>
<code>
331 class AdaBoostClassifier(ClassifierMixin, BaseWeightBoosting):
332     """An AdaBoost classifier.
333 
334     An AdaBoost [1] classifier is a meta-estimator that begins by fitting a
335     classifier on the original dataset and then fits additional copies of the
336     classifier on the same dataset but where the weights of incorrectly
337     classified instances are adjusted such that subsequent classifiers focus
338     more on difficult cases.
339 
340     This class implements the algorithm known as AdaBoost-SAMME [2].
341 
342     Read more in the :ref:`User Guide <adaboost>`.
343 
344     .. versionadded:: 0.14
345 
346     Parameters
347     ----------
348     estimator : object, default=None
349         The base estimator from which the boosted ensemble is built.
350         Support for sample weighting is required, as well as proper
351         ``classes_`` and ``n_classes_`` attributes. If ``None``, then
352         the base estimator is :class:`~sklearn.tree.DecisionTreeClassifier`
353         initialized with `max_depth=1`.
354 
355         .. versionadded:: 1.2
356            `base_estimator` was renamed to `estimator`.
357 
358     n_estimators : int, default=50
359         The maximum number of estimators at which boosting is terminated.
360         In case of perfect fit, the learning procedure is stopped early.
361         Values must be in the range `[1, inf)`.
362 
363     learning_rate : float, default=1.0
364         Weight applied to each classifier at each boosting iteration. A higher
365         learning rate increases the contribution of each classifier. There is
366         a trade-off between the `learning_rate` and `n_estimators` parameters.
367         Values must be in the range `(0.0, inf)`.
368 
369     algorithm : {'SAMME', 'SAMME.R'}, default='SAMME.R'
370         If 'SAMME.R' then use the SAMME.R real boosting algorithm.
371         ``estimator`` must support calculation of class probabilities.
372         If 'SAMME' then use the SAMME discrete boosting algorithm.
373         The SAMME.R algorithm typically converges faster than SAMME,
374         achieving a lower test error with fewer boosting iterations.
375 
376     random_state : int, RandomState instance or None, default=None
377         Controls the random seed given at each `estimator` at each
378         boosting iteration.
379         Thus, it is only used when `estimator` exposes a `random_state`.
380         Pass an int for reproducible output across multiple function calls.
381         See :term:`Glossary <random_state>`.
382 
383     base_estimator : object, default=None
384         The base estimator from which the boosted ensemble is built.
385         Support for sample weighting is required, as well as proper
386         ``classes_`` and ``n_classes_`` attributes. If ``None``, then
387         the base estimator is :class:`~sklearn.tree.DecisionTreeClassifier`
388         initialized with `max_depth=1`.
389 
390         .. deprecated:: 1.2
391             `base_estimator` is deprecated and will be removed in 1.4.
392             Use `estimator` instead.
393 
394     Attributes
395     ----------
396     estimator_ : estimator
397         The base estimator from which the ensemble is grown.
398 
399         .. versionadded:: 1.2
400            `base_estimator_` was renamed to `estimator_`.
401 
402     base_estimator_ : estimator
403         The base estimator from which the ensemble is grown.
404 
405         .. deprecated:: 1.2
406             `base_estimator_` is deprecated and will be removed in 1.4.
407             Use `estimator_` instead.
408 
409     estimators_ : list of classifiers
410         The collection of fitted sub-estimators.
411 
412     classes_ : ndarray of shape (n_classes,)
413         The classes labels.
414 
415     n_classes_ : int
416         The number of classes.
417 
418     estimator_weights_ : ndarray of floats
419         Weights for each estimator in the boosted ensemble.
420 
421     estimator_errors_ : ndarray of floats
422         Classification error for each estimator in the boosted
423         ensemble.
424 
425     feature_importances_ : ndarray of shape (n_features,)
426         The impurity-based feature importances if supported by the
427         ``estimator`` (when based on decision trees).
428 
429         Warning: impurity-based feature importances can be misleading for
430         high cardinality features (many unique values). See
431         :func:`sklearn.inspection.permutation_importance` as an alternative.
432 
433     n_features_in_ : int
434         Number of features seen during :term:`fit`.
435 
436         .. versionadded:: 0.24
437 
438     feature_names_in_ : ndarray of shape (`n_features_in_`,)
439         Names of features seen during :term:`fit`. Defined only when `X`
440         has feature names that are all strings.
441 
442         .. versionadded:: 1.0
443 
444     See Also
445     --------
446     AdaBoostRegressor : An AdaBoost regressor that begins by fitting a
447         regressor on the original dataset and then fits additional copies of
448         the regressor on the same dataset but where the weights of instances
449         are adjusted according to the error of the current prediction.
450 
451     GradientBoostingClassifier : GB builds an additive model in a forward
452         stage-wise fashion. Regression trees are fit on the negative gradient
453         of the binomial or multinomial deviance loss function. Binary
454         classification is a special case where only a single regression tree is
455         induced.
456 
457     sklearn.tree.DecisionTreeClassifier : A non-parametric supervised learning
458         method used for classification.
459         Creates a model that predicts the value of a target variable by
460         learning simple decision rules inferred from the data features.
461 
462     References
463     ----------
464     .. [1] Y. Freund, R. Schapire, "A Decision-Theoretic Generalization of
465            on-Line Learning and an Application to Boosting", 1995.
466 
467     .. [2] J. Zhu, H. Zou, S. Rosset, T. Hastie, "Multi-class AdaBoost", 2009.
468 
469     Examples
470     --------
471     >>> from sklearn.ensemble import AdaBoostClassifier
472     >>> from sklearn.datasets import make_classification
473     >>> X, y = make_classification(n_samples=1000, n_features=4,
474     ...                            n_informative=2, n_redundant=0,
475     ...                            random_state=0, shuffle=False)
476     >>> clf = AdaBoostClassifier(n_estimators=100, random_state=0)
477     >>> clf.fit(X, y)
478     AdaBoostClassifier(n_estimators=100, random_state=0)
479     >>> clf.predict([[0, 0, 0, 0]])
480     array([1])
481     >>> clf.score(X, y)
482     0.983...
483     """
484 
485     _parameter_constraints: dict = {
486         **BaseWeightBoosting._parameter_constraints,
487         "algorithm": [StrOptions({"SAMME", "SAMME.R"})],
488     }
489 
490     def __init__(
491         self,
492         estimator=None,
493         *,
494         n_estimators=50,
495         learning_rate=1.0,
496         algorithm="SAMME.R",
497         random_state=None,
498         base_estimator="deprecated",
499     ):
500         super().__init__(
501             estimator=estimator,
502             n_estimators=n_estimators,
503             learning_rate=learning_rate,
504             random_state=random_state,
505             base_estimator=base_estimator,
506         )
507 
508         self.algorithm = algorithm
509 
510     def _validate_estimator(self):
511         """Check the estimator and set the estimator_ attribute."""
512         super()._validate_estimator(default=DecisionTreeClassifier(max_depth=1))
513 
514         #  SAMME-R requires predict_proba-enabled base estimators
515         if self.algorithm == "SAMME.R":
516             if not hasattr(self.estimator_, "predict_proba"):
517                 raise TypeError(
518                     "AdaBoostClassifier with algorithm='SAMME.R' requires "
519                     "that the weak learner supports the calculation of class "
520                     "probabilities with a predict_proba method.\n"
521                     "Please change the base estimator or set "
522                     "algorithm='SAMME' instead."
523                 )
524         if not has_fit_parameter(self.estimator_, "sample_weight"):
525             raise ValueError(
526                 f"{self.estimator.__class__.__name__} doesn't support sample_weight."
527             )
528 
529     def _boost(self, iboost, X, y, sample_weight, random_state):
530         """Implement a single boost.
531 
532         Perform a single boost according to the real multi-class SAMME.R
533         algorithm or to the discrete SAMME algorithm and return the updated
534         sample weights.
535 
536         Parameters
537         ----------
538         iboost : int
539             The index of the current boost iteration.
540 
541         X : {array-like, sparse matrix} of shape (n_samples, n_features)
542             The training input samples.
543 
544         y : array-like of shape (n_samples,)
545             The target values (class labels).
546 
547         sample_weight : array-like of shape (n_samples,)
548             The current sample weights.
549 
550         random_state : RandomState instance
551             The RandomState instance used if the base estimator accepts a
552             `random_state` attribute.
553 
554         Returns
555         -------
556         sample_weight : array-like of shape (n_samples,) or None
557             The reweighted sample weights.
558             If None then boosting has terminated early.
559 
560         estimator_weight : float
561             The weight for the current boost.
562             If None then boosting has terminated early.
563 
564         estimator_error : float
565             The classification error for the current boost.
566             If None then boosting has terminated early.
567         """
568         if self.algorithm == "SAMME.R":
569             return self._boost_real(iboost, X, y, sample_weight, random_state)
570 
571         else:  # elif self.algorithm == "SAMME":
572             return self._boost_discrete(iboost, X, y, sample_weight, random_state)
573 
574     def _boost_real(self, iboost, X, y, sample_weight, random_state):
575         """Implement a single boost using the SAMME.R real algorithm."""
576         estimator = self._make_estimator(random_state=random_state)
577 
578         estimator.fit(X, y, sample_weight=sample_weight)
579 
580         y_predict_proba = estimator.predict_proba(X)
581 
582         if iboost == 0:
583             self.classes_ = getattr(estimator, "classes_", None)
584             self.n_classes_ = len(self.classes_)
585 
586         y_predict = self.classes_.take(np.argmax(y_predict_proba, axis=1), axis=0)
587 
588         # Instances incorrectly classified
589         incorrect = y_predict != y
590 
591         # Error fraction
592         estimator_error = np.mean(np.average(incorrect, weights=sample_weight, axis=0))
593 
594         # Stop if classification is perfect
595         if estimator_error <= 0:
596             return sample_weight, 1.0, 0.0
597 
598         # Construct y coding as described in Zhu et al [2]:
599         #
600         #    y_k = 1 if c == k else -1 / (K - 1)
601         #
602         # where K == n_classes_ and c, k in [0, K) are indices along the second
603         # axis of the y coding with c being the index corresponding to the true
604         # class label.
605         n_classes = self.n_classes_
606         classes = self.classes_
607         y_codes = np.array([-1.0 / (n_classes - 1), 1.0])
608         y_coding = y_codes.take(classes == y[:, np.newaxis])
609 
610         # Displace zero probabilities so the log is defined.
611         # Also fix negative elements which may occur with
612         # negative sample weights.
613         proba = y_predict_proba  # alias for readability
614         np.clip(proba, np.finfo(proba.dtype).eps, None, out=proba)
615 
616         # Boost weight using multi-class AdaBoost SAMME.R alg
617         estimator_weight = (
618             -1.0
619             * self.learning_rate
620             * ((n_classes - 1.0) / n_classes)
621             * xlogy(y_coding, y_predict_proba).sum(axis=1)
622         )
623 
624         # Only boost the weights if it will fit again
625         if not iboost == self.n_estimators - 1:
626             # Only boost positive weights
627             sample_weight *= np.exp(
628                 estimator_weight * ((sample_weight > 0) | (estimator_weight < 0))
629             )
630 
631         return sample_weight, 1.0, estimator_error
632 
633     def _boost_discrete(self, iboost, X, y, sample_weight, random_state):
634         """Implement a single boost using the SAMME discrete algorithm."""
635         estimator = self._make_estimator(random_state=random_state)
636 
637         estimator.fit(X, y, sample_weight=sample_weight)
638 
639         y_predict = estimator.predict(X)
640 
641         if iboost == 0:
642             self.classes_ = getattr(estimator, "classes_", None)
643             self.n_classes_ = len(self.classes_)
644 
645         # Instances incorrectly classified
646         incorrect = y_predict != y
647 
648         # Error fraction
649         estimator_error = np.mean(np.average(incorrect, weights=sample_weight, axis=0))
650 
651         # Stop if classification is perfect
652         if estimator_error <= 0:
653             return sample_weight, 1.0, 0.0
654 
655         n_classes = self.n_classes_
656 
657         # Stop if the error is at least as bad as random guessing
658         if estimator_error >= 1.0 - (1.0 / n_classes):
659             self.estimators_.pop(-1)
660             if len(self.estimators_) == 0:
661                 raise ValueError(
662                     "BaseClassifier in AdaBoostClassifier "
663                     "ensemble is worse than random, ensemble "
664                     "can not be fit."
665                 )
666             return None, None, None
667 
668         # Boost weight using multi-class AdaBoost SAMME alg
669         estimator_weight = self.learning_rate * (
670             np.log((1.0 - estimator_error) / estimator_error) + np.log(n_classes - 1.0)
671         )
672 
673         # Only boost the weights if it will fit again
674         if not iboost == self.n_estimators - 1:
675             # Only boost positive weights
676             sample_weight = np.exp(
677                 np.log(sample_weight)
678                 + estimator_weight * incorrect * (sample_weight > 0)
679             )
680 
681         return sample_weight, estimator_weight, estimator_error
682 
683     def predict(self, X):
684         """Predict classes for X.
685 
686         The predicted class of an input sample is computed as the weighted mean
687         prediction of the classifiers in the ensemble.
688 
689         Parameters
690         ----------
691         X : {array-like, sparse matrix} of shape (n_samples, n_features)
692             The training input samples. Sparse matrix can be CSC, CSR, COO,
693             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
694 
695         Returns
696         -------
697         y : ndarray of shape (n_samples,)
698             The predicted classes.
699         """
700         pred = self.decision_function(X)
701 
702         if self.n_classes_ == 2:
703             return self.classes_.take(pred > 0, axis=0)
704 
705         return self.classes_.take(np.argmax(pred, axis=1), axis=0)
706 
707     def staged_predict(self, X):
708         """Return staged predictions for X.
709 
710         The predicted class of an input sample is computed as the weighted mean
711         prediction of the classifiers in the ensemble.
712 
713         This generator method yields the ensemble prediction after each
714         iteration of boosting and therefore allows monitoring, such as to
715         determine the prediction on a test set after each boost.
716 
717         Parameters
718         ----------
719         X : array-like of shape (n_samples, n_features)
720             The input samples. Sparse matrix can be CSC, CSR, COO,
721             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
722 
723         Yields
724         ------
725         y : generator of ndarray of shape (n_samples,)
726             The predicted classes.
727         """
728         X = self._check_X(X)
729 
730         n_classes = self.n_classes_
731         classes = self.classes_
732 
733         if n_classes == 2:
734             for pred in self.staged_decision_function(X):
735                 yield np.array(classes.take(pred > 0, axis=0))
736 
737         else:
738             for pred in self.staged_decision_function(X):
739                 yield np.array(classes.take(np.argmax(pred, axis=1), axis=0))
740 
741     def decision_function(self, X):
742         """Compute the decision function of ``X``.
743 
744         Parameters
745         ----------
746         X : {array-like, sparse matrix} of shape (n_samples, n_features)
747             The training input samples. Sparse matrix can be CSC, CSR, COO,
748             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
749 
750         Returns
751         -------
752         score : ndarray of shape of (n_samples, k)
753             The decision function of the input samples. The order of
754             outputs is the same of that of the :term:`classes_` attribute.
755             Binary classification is a special cases with ``k == 1``,
756             otherwise ``k==n_classes``. For binary classification,
757             values closer to -1 or 1 mean more like the first or second
758             class in ``classes_``, respectively.
759         """
760         check_is_fitted(self)
761         X = self._check_X(X)
762 
763         n_classes = self.n_classes_
764         classes = self.classes_[:, np.newaxis]
765 
766         if self.algorithm == "SAMME.R":
767             # The weights are all 1. for SAMME.R
768             pred = sum(
769                 _samme_proba(estimator, n_classes, X) for estimator in self.estimators_
770             )
771         else:  # self.algorithm == "SAMME"
772             pred = sum(
773                 (estimator.predict(X) == classes).T * w
774                 for estimator, w in zip(self.estimators_, self.estimator_weights_)
775             )
776 
777         pred /= self.estimator_weights_.sum()
778         if n_classes == 2:
779             pred[:, 0] *= -1
780             return pred.sum(axis=1)
781         return pred
782 
783     def staged_decision_function(self, X):
784         """Compute decision function of ``X`` for each boosting iteration.
785 
786         This method allows monitoring (i.e. determine error on testing set)
787         after each boosting iteration.
788 
789         Parameters
790         ----------
791         X : {array-like, sparse matrix} of shape (n_samples, n_features)
792             The training input samples. Sparse matrix can be CSC, CSR, COO,
793             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
794 
795         Yields
796         ------
797         score : generator of ndarray of shape (n_samples, k)
798             The decision function of the input samples. The order of
799             outputs is the same of that of the :term:`classes_` attribute.
800             Binary classification is a special cases with ``k == 1``,
801             otherwise ``k==n_classes``. For binary classification,
802             values closer to -1 or 1 mean more like the first or second
803             class in ``classes_``, respectively.
804         """
805         check_is_fitted(self)
806         X = self._check_X(X)
807 
808         n_classes = self.n_classes_
809         classes = self.classes_[:, np.newaxis]
810         pred = None
811         norm = 0.0
812 
813         for weight, estimator in zip(self.estimator_weights_, self.estimators_):
814             norm += weight
815 
816             if self.algorithm == "SAMME.R":
817                 # The weights are all 1. for SAMME.R
818                 current_pred = _samme_proba(estimator, n_classes, X)
819             else:  # elif self.algorithm == "SAMME":
820                 current_pred = estimator.predict(X)
821                 current_pred = (current_pred == classes).T * weight
822 
823             if pred is None:
824                 pred = current_pred
825             else:
826                 pred += current_pred
827 
828             if n_classes == 2:
829                 tmp_pred = np.copy(pred)
830                 tmp_pred[:, 0] *= -1
831                 yield (tmp_pred / norm).sum(axis=1)
832             else:
833                 yield pred / norm
834 
835     @staticmethod
836     def _compute_proba_from_decision(decision, n_classes):
837         """Compute probabilities from the decision function.
838 
839         This is based eq. (4) of [1] where:
840             p(y=c|X) = exp((1 / K-1) f_c(X)) / sum_k(exp((1 / K-1) f_k(X)))
841                      = softmax((1 / K-1) * f(X))
842 
843         References
844         ----------
845         .. [1] J. Zhu, H. Zou, S. Rosset, T. Hastie, "Multi-class AdaBoost",
846                2009.
847         """
848         if n_classes == 2:
849             decision = np.vstack([-decision, decision]).T / 2
850         else:
851             decision /= n_classes - 1
852         return softmax(decision, copy=False)
853 
854     def predict_proba(self, X):
855         """Predict class probabilities for X.
856 
857         The predicted class probabilities of an input sample is computed as
858         the weighted mean predicted class probabilities of the classifiers
859         in the ensemble.
860 
861         Parameters
862         ----------
863         X : {array-like, sparse matrix} of shape (n_samples, n_features)
864             The training input samples. Sparse matrix can be CSC, CSR, COO,
865             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
866 
867         Returns
868         -------
869         p : ndarray of shape (n_samples, n_classes)
870             The class probabilities of the input samples. The order of
871             outputs is the same of that of the :term:`classes_` attribute.
872         """
873         check_is_fitted(self)
874         n_classes = self.n_classes_
875 
876         if n_classes == 1:
877             return np.ones((_num_samples(X), 1))
878 
879         decision = self.decision_function(X)
880         return self._compute_proba_from_decision(decision, n_classes)
881 
882     def staged_predict_proba(self, X):
883         """Predict class probabilities for X.
884 
885         The predicted class probabilities of an input sample is computed as
886         the weighted mean predicted class probabilities of the classifiers
887         in the ensemble.
888 
889         This generator method yields the ensemble predicted class probabilities
890         after each iteration of boosting and therefore allows monitoring, such
891         as to determine the predicted class probabilities on a test set after
892         each boost.
893 
894         Parameters
895         ----------
896         X : {array-like, sparse matrix} of shape (n_samples, n_features)
897             The training input samples. Sparse matrix can be CSC, CSR, COO,
898             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
899 
900         Yields
901         ------
902         p : generator of ndarray of shape (n_samples,)
903             The class probabilities of the input samples. The order of
904             outputs is the same of that of the :term:`classes_` attribute.
905         """
906 
907         n_classes = self.n_classes_
908 
909         for decision in self.staged_decision_function(X):
910             yield self._compute_proba_from_decision(decision, n_classes)
911 
912     def predict_log_proba(self, X):
913         """Predict class log-probabilities for X.
914 
915         The predicted class log-probabilities of an input sample is computed as
916         the weighted mean predicted class log-probabilities of the classifiers
917         in the ensemble.
918 
919         Parameters
920         ----------
921         X : {array-like, sparse matrix} of shape (n_samples, n_features)
922             The training input samples. Sparse matrix can be CSC, CSR, COO,
923             DOK, or LIL. COO, DOK, and LIL are converted to CSR.
924 
925         Returns
926         -------
927         p : ndarray of shape (n_samples, n_classes)
928             The class probabilities of the input samples. The order of
929             outputs is the same of that of the :term:`classes_` attribute.
930         """
931         return np.log(self.predict_proba(X))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 17:41:17.662 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 17:41:17.662 | INFO     | Search-only: skipping patch selection
2025-10-18 17:41:17.787 | INFO     | Task scikit-learn__scikit-learn-26242 completed successfully.
2025-10-18 17:41:17.788 | INFO     | No patch generated. You can try running ACR again.
