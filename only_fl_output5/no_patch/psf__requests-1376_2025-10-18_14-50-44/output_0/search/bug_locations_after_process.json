[
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__1.2/requests/models.py",
        "start": 345,
        "end": 400,
        "class_name": null,
        "method_name": "prepare_body",
        "code": "345     def prepare_body(self, data, files):\n346         \"\"\"Prepares the given HTTP body data.\"\"\"\n347 \n348         # Check if file, fo, generator, iterator.\n349         # If not, run through normal process.\n350 \n351         # Nottin' on you.\n352         body = None\n353         content_type = None\n354         length = None\n355         is_stream = False\n356 \n357         is_stream = all([\n358             hasattr(data, '__iter__'),\n359             not isinstance(data, basestring),\n360             not isinstance(data, list),\n361             not isinstance(data, dict)\n362         ])\n363 \n364         try:\n365             length = super_len(data)\n366         except (TypeError, AttributeError):\n367             length = False\n368 \n369         if is_stream:\n370             body = data\n371 \n372             if files:\n373                 raise NotImplementedError('Streamed bodies and files are mutually exclusive.')\n374 \n375             if length:\n376                 self.headers['Content-Length'] = str(length)\n377             else:\n378                 self.headers['Transfer-Encoding'] = 'chunked'\n379         # Check if file, fo, generator, iterator.\n380         # If not, run through normal process.\n381 \n382         else:\n383             # Multi-part file uploads.\n384             if files:\n385                 (body, content_type) = self._encode_files(files, data)\n386             else:\n387                 if data:\n388                     body = self._encode_params(data)\n389                     if isinstance(data, str) or isinstance(data, builtin_str) or hasattr(data, 'read'):\n390                         content_type = None\n391                     else:\n392                         content_type = 'application/x-www-form-urlencoded'\n393 \n394             self.prepare_content_length(body)\n395 \n396             # Add content-type if it wasn't explicitly provided.\n397             if (content_type) and (not 'content-type' in self.headers):\n398                 self.headers['Content-Type'] = content_type\n399 \n400         self.body = body\n",
        "intended_behavior": "The prepare_body method needs to ensure that when constructing the HTTP body for a request, if the data includes encoded field names (e.g., UTF-8 encoded strings), these names are incorporated into the body without being altered by Python-specific notations or encodings. This particularly applies to handling multipart/form-data where field names and file names might be encoded. The method should maintain the original encoding of these names, whether ASCII or UTF-8, ensuring they are represented correctly in the HTTP request body without additional markings (like b'' for byte strings) that are not part of the actual content. The preservation of existing functionality related to handling various data types (such as files, streams, and regular form data) is crucial, with the fix specifically aimed at correcting the representation of encoded names."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__1.2/requests/models.py",
        "start": 345,
        "end": 400,
        "class_name": "PreparedRequest",
        "method_name": "prepare_body",
        "code": "345     def prepare_body(self, data, files):\n346         \"\"\"Prepares the given HTTP body data.\"\"\"\n347 \n348         # Check if file, fo, generator, iterator.\n349         # If not, run through normal process.\n350 \n351         # Nottin' on you.\n352         body = None\n353         content_type = None\n354         length = None\n355         is_stream = False\n356 \n357         is_stream = all([\n358             hasattr(data, '__iter__'),\n359             not isinstance(data, basestring),\n360             not isinstance(data, list),\n361             not isinstance(data, dict)\n362         ])\n363 \n364         try:\n365             length = super_len(data)\n366         except (TypeError, AttributeError):\n367             length = False\n368 \n369         if is_stream:\n370             body = data\n371 \n372             if files:\n373                 raise NotImplementedError('Streamed bodies and files are mutually exclusive.')\n374 \n375             if length:\n376                 self.headers['Content-Length'] = str(length)\n377             else:\n378                 self.headers['Transfer-Encoding'] = 'chunked'\n379         # Check if file, fo, generator, iterator.\n380         # If not, run through normal process.\n381 \n382         else:\n383             # Multi-part file uploads.\n384             if files:\n385                 (body, content_type) = self._encode_files(files, data)\n386             else:\n387                 if data:\n388                     body = self._encode_params(data)\n389                     if isinstance(data, str) or isinstance(data, builtin_str) or hasattr(data, 'read'):\n390                         content_type = None\n391                     else:\n392                         content_type = 'application/x-www-form-urlencoded'\n393 \n394             self.prepare_content_length(body)\n395 \n396             # Add content-type if it wasn't explicitly provided.\n397             if (content_type) and (not 'content-type' in self.headers):\n398                 self.headers['Content-Type'] = content_type\n399 \n400         self.body = body\n",
        "intended_behavior": "The prepare_body method needs to ensure that when constructing the HTTP body for a request, if the data includes encoded field names (e.g., UTF-8 encoded strings), these names are incorporated into the body without being altered by Python-specific notations or encodings. This particularly applies to handling multipart/form-data where field names and file names might be encoded. The method should maintain the original encoding of these names, whether ASCII or UTF-8, ensuring they are represented correctly in the HTTP request body without additional markings (like b'' for byte strings) that are not part of the actual content. The preservation of existing functionality related to handling various data types (such as files, streams, and regular form data) is crucial, with the fix specifically aimed at correcting the representation of encoded names."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__1.2/requests/models.py",
        "start": 87,
        "end": 135,
        "class_name": "RequestEncodingMixin",
        "method_name": "_encode_files",
        "code": "87     def _encode_files(files, data):\n88         \"\"\"Build the body for a multipart/form-data request.\n89 \n90         Will successfully encode files when passed as a dict or a list of\n91         2-tuples. Order is retained if data is a list of 2-tuples but abritrary\n92         if parameters are supplied as a dict.\n93 \n94         \"\"\"\n95         if (not files) or isinstance(data, str):\n96             return None\n97 \n98         new_fields = []\n99         fields = to_key_val_list(data or {})\n100         files = to_key_val_list(files or {})\n101 \n102         for field, val in fields:\n103             if isinstance(val, basestring) or not hasattr(val, '__iter__'):\n104                 val = [val]\n105             for v in val:\n106                 if v is not None:\n107                     new_fields.append(\n108                         (field.decode('utf-8') if isinstance(field, bytes) else field,\n109                          v.encode('utf-8') if isinstance(v, str) else v))\n110 \n111         for (k, v) in files:\n112             # support for explicit filename\n113             ft = None\n114             if isinstance(v, (tuple, list)):\n115                 if len(v) == 2:\n116                     fn, fp = v\n117                 else:\n118                     fn, fp, ft = v\n119             else:\n120                 fn = guess_filename(v) or k\n121                 fp = v\n122             if isinstance(fp, str):\n123                 fp = StringIO(fp)\n124             if isinstance(fp, bytes):\n125                 fp = BytesIO(fp)\n126 \n127             if ft:\n128                 new_v = (fn, fp.read(), ft)\n129             else:\n130                 new_v = (fn, fp.read())\n131             new_fields.append((k, new_v))\n132 \n133         body, content_type = encode_multipart_formdata(new_fields)\n134 \n135         return body, content_type\n",
        "intended_behavior": "In the _encode_files method, the intended behavior is to accurately process and encode files and field names for multipart/form-data requests. This includes ensuring that when field names or file names are provided in an encoded format (such as UTF-8), these names are incorporated into the multipart body accurately and without unintended alterations. The method must handle these names in a way that does not introduce Python byte notation (b'') into the resulting HTTP body. This is critical for maintaining compliance with how such data should be transmitted over HTTP, enabling interoperability with systems expecting correctly formatted multipart/form-data payloads. All existing functionalities for encoding and preparing multipart requests should be preserved, with the fix specifically targeting the accurate inclusion of encoded names."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__1.2/requests/models.py",
        "start": 37,
        "end": 135,
        "class_name": "RequestEncodingMixin",
        "method_name": null,
        "code": "37 class RequestEncodingMixin(object):\n38     @property\n39     def path_url(self):\n40         \"\"\"Build the path URL to use.\"\"\"\n41 \n42         url = []\n43 \n44         p = urlsplit(self.url)\n45 \n46         path = p.path\n47         if not path:\n48             path = '/'\n49 \n50         url.append(path)\n51 \n52         query = p.query\n53         if query:\n54             url.append('?')\n55             url.append(query)\n56 \n57         return ''.join(url)\n58 \n59     @staticmethod\n60     def _encode_params(data):\n61         \"\"\"Encode parameters in a piece of data.\n62 \n63         Will successfully encode parameters when passed as a dict or a list of\n64         2-tuples. Order is retained if data is a list of 2-tuples but arbitrary\n65         if parameters are supplied as a dict.\n66         \"\"\"\n67 \n68         if isinstance(data, (str, bytes)):\n69             return data\n70         elif hasattr(data, 'read'):\n71             return data\n72         elif hasattr(data, '__iter__'):\n73             result = []\n74             for k, vs in to_key_val_list(data):\n75                 if isinstance(vs, basestring) or not hasattr(vs, '__iter__'):\n76                     vs = [vs]\n77                 for v in vs:\n78                     if v is not None:\n79                         result.append(\n80                             (k.encode('utf-8') if isinstance(k, str) else k,\n81                              v.encode('utf-8') if isinstance(v, str) else v))\n82             return urlencode(result, doseq=True)\n83         else:\n84             return data\n85 \n86     @staticmethod\n87     def _encode_files(files, data):\n88         \"\"\"Build the body for a multipart/form-data request.\n89 \n90         Will successfully encode files when passed as a dict or a list of\n91         2-tuples. Order is retained if data is a list of 2-tuples but abritrary\n92         if parameters are supplied as a dict.\n93 \n94         \"\"\"\n95         if (not files) or isinstance(data, str):\n96             return None\n97 \n98         new_fields = []\n99         fields = to_key_val_list(data or {})\n100         files = to_key_val_list(files or {})\n101 \n102         for field, val in fields:\n103             if isinstance(val, basestring) or not hasattr(val, '__iter__'):\n104                 val = [val]\n105             for v in val:\n106                 if v is not None:\n107                     new_fields.append(\n108                         (field.decode('utf-8') if isinstance(field, bytes) else field,\n109                          v.encode('utf-8') if isinstance(v, str) else v))\n110 \n111         for (k, v) in files:\n112             # support for explicit filename\n113             ft = None\n114             if isinstance(v, (tuple, list)):\n115                 if len(v) == 2:\n116                     fn, fp = v\n117                 else:\n118                     fn, fp, ft = v\n119             else:\n120                 fn = guess_filename(v) or k\n121                 fp = v\n122             if isinstance(fp, str):\n123                 fp = StringIO(fp)\n124             if isinstance(fp, bytes):\n125                 fp = BytesIO(fp)\n126 \n127             if ft:\n128                 new_v = (fn, fp.read(), ft)\n129             else:\n130                 new_v = (fn, fp.read())\n131             new_fields.append((k, new_v))\n132 \n133         body, content_type = encode_multipart_formdata(new_fields)\n134 \n135         return body, content_type\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]