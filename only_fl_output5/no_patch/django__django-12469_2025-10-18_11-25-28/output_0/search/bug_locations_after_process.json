[
    {
        "rel_file_path": "django/contrib/admin/views/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/views/main.py",
        "start": 1,
        "end": 509,
        "class_name": null,
        "method_name": null,
        "code": "1 from datetime import datetime, timedelta\n2 \n3 from django import forms\n4 from django.conf import settings\n5 from django.contrib import messages\n6 from django.contrib.admin import FieldListFilter\n7 from django.contrib.admin.exceptions import (\n8     DisallowedModelAdminLookup, DisallowedModelAdminToField,\n9 )\n10 from django.contrib.admin.options import (\n11     IS_POPUP_VAR, TO_FIELD_VAR, IncorrectLookupParameters,\n12 )\n13 from django.contrib.admin.utils import (\n14     get_fields_from_path, lookup_needs_distinct, prepare_lookup_value, quote,\n15 )\n16 from django.core.exceptions import (\n17     FieldDoesNotExist, ImproperlyConfigured, SuspiciousOperation,\n18 )\n19 from django.core.paginator import InvalidPage\n20 from django.db.models import F, Field, ManyToOneRel, OrderBy\n21 from django.db.models.expressions import Combinable\n22 from django.urls import reverse\n23 from django.utils.http import urlencode\n24 from django.utils.timezone import make_aware\n25 from django.utils.translation import gettext\n26 \n27 # Changelist settings\n28 ALL_VAR = 'all'\n29 ORDER_VAR = 'o'\n30 ORDER_TYPE_VAR = 'ot'\n31 PAGE_VAR = 'p'\n32 SEARCH_VAR = 'q'\n33 ERROR_FLAG = 'e'\n34 \n35 IGNORED_PARAMS = (\n36     ALL_VAR, ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)\n37 \n38 \n39 class ChangeListSearchForm(forms.Form):\n40     def __init__(self, *args, **kwargs):\n41         super().__init__(*args, **kwargs)\n42         # Populate \"fields\" dynamically because SEARCH_VAR is a variable:\n43         self.fields = {\n44             SEARCH_VAR: forms.CharField(required=False, strip=False),\n45         }\n46 \n47 \n48 class ChangeList:\n49     search_form_class = ChangeListSearchForm\n50 \n51     def __init__(self, request, model, list_display, list_display_links,\n52                  list_filter, date_hierarchy, search_fields, list_select_related,\n53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):\n54         self.model = model\n55         self.opts = model._meta\n56         self.lookup_opts = self.opts\n57         self.root_queryset = model_admin.get_queryset(request)\n58         self.list_display = list_display\n59         self.list_display_links = list_display_links\n60         self.list_filter = list_filter\n61         self.has_filters = None\n62         self.date_hierarchy = date_hierarchy\n63         self.search_fields = search_fields\n64         self.list_select_related = list_select_related\n65         self.list_per_page = list_per_page\n66         self.list_max_show_all = list_max_show_all\n67         self.model_admin = model_admin\n68         self.preserved_filters = model_admin.get_preserved_filters(request)\n69         self.sortable_by = sortable_by\n70 \n71         # Get search parameters from the query string.\n72         _search_form = self.search_form_class(request.GET)\n73         if not _search_form.is_valid():\n74             for error in _search_form.errors.values():\n75                 messages.error(request, ', '.join(error))\n76         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''\n77         try:\n78             self.page_num = int(request.GET.get(PAGE_VAR, 0))\n79         except ValueError:\n80             self.page_num = 0\n81         self.show_all = ALL_VAR in request.GET\n82         self.is_popup = IS_POPUP_VAR in request.GET\n83         to_field = request.GET.get(TO_FIELD_VAR)\n84         if to_field and not model_admin.to_field_allowed(request, to_field):\n85             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n86         self.to_field = to_field\n87         self.params = dict(request.GET.items())\n88         if PAGE_VAR in self.params:\n89             del self.params[PAGE_VAR]\n90         if ERROR_FLAG in self.params:\n91             del self.params[ERROR_FLAG]\n92 \n93         if self.is_popup:\n94             self.list_editable = ()\n95         else:\n96             self.list_editable = list_editable\n97         self.queryset = self.get_queryset(request)\n98         self.get_results(request)\n99         if self.is_popup:\n100             title = gettext('Select %s')\n101         elif self.model_admin.has_change_permission(request):\n102             title = gettext('Select %s to change')\n103         else:\n104             title = gettext('Select %s to view')\n105         self.title = title % self.opts.verbose_name\n106         self.pk_attname = self.lookup_opts.pk.attname\n107 \n108     def get_filters_params(self, params=None):\n109         \"\"\"\n110         Return all params except IGNORED_PARAMS.\n111         \"\"\"\n112         params = params or self.params\n113         lookup_params = params.copy()  # a dictionary of the query string\n114         # Remove all the parameters that are globally and systematically\n115         # ignored.\n116         for ignored in IGNORED_PARAMS:\n117             if ignored in lookup_params:\n118                 del lookup_params[ignored]\n119         return lookup_params\n120 \n121     def get_filters(self, request):\n122         lookup_params = self.get_filters_params()\n123         use_distinct = False\n124 \n125         for key, value in lookup_params.items():\n126             if not self.model_admin.lookup_allowed(key, value):\n127                 raise DisallowedModelAdminLookup(\"Filtering by %s not allowed\" % key)\n128 \n129         filter_specs = []\n130         for list_filter in self.list_filter:\n131             if callable(list_filter):\n132                 # This is simply a custom list filter class.\n133                 spec = list_filter(request, lookup_params, self.model, self.model_admin)\n134             else:\n135                 field_path = None\n136                 if isinstance(list_filter, (tuple, list)):\n137                     # This is a custom FieldListFilter class for a given field.\n138                     field, field_list_filter_class = list_filter\n139                 else:\n140                     # This is simply a field name, so use the default\n141                     # FieldListFilter class that has been registered for the\n142                     # type of the given field.\n143                     field, field_list_filter_class = list_filter, FieldListFilter.create\n144                 if not isinstance(field, Field):\n145                     field_path = field\n146                     field = get_fields_from_path(self.model, field_path)[-1]\n147 \n148                 lookup_params_count = len(lookup_params)\n149                 spec = field_list_filter_class(\n150                     field, request, lookup_params,\n151                     self.model, self.model_admin, field_path=field_path,\n152                 )\n153                 # field_list_filter_class removes any lookup_params it\n154                 # processes. If that happened, check if distinct() is needed to\n155                 # remove duplicate results.\n156                 if lookup_params_count > len(lookup_params):\n157                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)\n158             if spec and spec.has_output():\n159                 filter_specs.append(spec)\n160 \n161         if self.date_hierarchy:\n162             # Create bounded lookup parameters so that the query is more\n163             # efficient.\n164             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)\n165             if year is not None:\n166                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)\n167                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)\n168                 try:\n169                     from_date = datetime(\n170                         int(year),\n171                         int(month if month is not None else 1),\n172                         int(day if day is not None else 1),\n173                     )\n174                 except ValueError as e:\n175                     raise IncorrectLookupParameters(e) from e\n176                 if day:\n177                     to_date = from_date + timedelta(days=1)\n178                 elif month:\n179                     # In this branch, from_date will always be the first of a\n180                     # month, so advancing 32 days gives the next month.\n181                     to_date = (from_date + timedelta(days=32)).replace(day=1)\n182                 else:\n183                     to_date = from_date.replace(year=from_date.year + 1)\n184                 if settings.USE_TZ:\n185                     from_date = make_aware(from_date)\n186                     to_date = make_aware(to_date)\n187                 lookup_params.update({\n188                     '%s__gte' % self.date_hierarchy: from_date,\n189                     '%s__lt' % self.date_hierarchy: to_date,\n190                 })\n191 \n192         # At this point, all the parameters used by the various ListFilters\n193         # have been removed from lookup_params, which now only contains other\n194         # parameters passed via the query string. We now loop through the\n195         # remaining parameters both to ensure that all the parameters are valid\n196         # fields and to determine if at least one of them needs distinct(). If\n197         # the lookup parameters aren't real fields, then bail out.\n198         try:\n199             for key, value in lookup_params.items():\n200                 lookup_params[key] = prepare_lookup_value(key, value)\n201                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)\n202             return filter_specs, bool(filter_specs), lookup_params, use_distinct\n203         except FieldDoesNotExist as e:\n204             raise IncorrectLookupParameters(e) from e\n205 \n206     def get_query_string(self, new_params=None, remove=None):\n207         if new_params is None:\n208             new_params = {}\n209         if remove is None:\n210             remove = []\n211         p = self.params.copy()\n212         for r in remove:\n213             for k in list(p):\n214                 if k.startswith(r):\n215                     del p[k]\n216         for k, v in new_params.items():\n217             if v is None:\n218                 if k in p:\n219                     del p[k]\n220             else:\n221                 p[k] = v\n222         return '?%s' % urlencode(sorted(p.items()))\n223 \n224     def get_results(self, request):\n225         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)\n226         # Get the number of objects, with admin filters applied.\n227         result_count = paginator.count\n228 \n229         # Get the total number of objects, with no admin filters applied.\n230         if self.model_admin.show_full_result_count:\n231             full_result_count = self.root_queryset.count()\n232         else:\n233             full_result_count = None\n234         can_show_all = result_count <= self.list_max_show_all\n235         multi_page = result_count > self.list_per_page\n236 \n237         # Get the list of objects to display on this page.\n238         if (self.show_all and can_show_all) or not multi_page:\n239             result_list = self.queryset._clone()\n240         else:\n241             try:\n242                 result_list = paginator.page(self.page_num + 1).object_list\n243             except InvalidPage:\n244                 raise IncorrectLookupParameters\n245 \n246         self.result_count = result_count\n247         self.show_full_result_count = self.model_admin.show_full_result_count\n248         # Admin actions are shown if there is at least one entry\n249         # or if entries are not counted because show_full_result_count is disabled\n250         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)\n251         self.full_result_count = full_result_count\n252         self.result_list = result_list\n253         self.can_show_all = can_show_all\n254         self.multi_page = multi_page\n255         self.paginator = paginator\n256 \n257     def _get_default_ordering(self):\n258         ordering = []\n259         if self.model_admin.ordering:\n260             ordering = self.model_admin.ordering\n261         elif self.lookup_opts.ordering:\n262             ordering = self.lookup_opts.ordering\n263         return ordering\n264 \n265     def get_ordering_field(self, field_name):\n266         \"\"\"\n267         Return the proper model field name corresponding to the given\n268         field_name to use for ordering. field_name may either be the name of a\n269         proper model field or the name of a method (on the admin or model) or a\n270         callable with the 'admin_order_field' attribute. Return None if no\n271         proper model field name can be matched.\n272         \"\"\"\n273         try:\n274             field = self.lookup_opts.get_field(field_name)\n275             return field.name\n276         except FieldDoesNotExist:\n277             # See whether field_name is a name of a non-field\n278             # that allows sorting.\n279             if callable(field_name):\n280                 attr = field_name\n281             elif hasattr(self.model_admin, field_name):\n282                 attr = getattr(self.model_admin, field_name)\n283             else:\n284                 attr = getattr(self.model, field_name)\n285             if isinstance(attr, property) and hasattr(attr, 'fget'):\n286                 attr = attr.fget\n287             return getattr(attr, 'admin_order_field', None)\n288 \n289     def get_ordering(self, request, queryset):\n290         \"\"\"\n291         Return the list of ordering fields for the change list.\n292         First check the get_ordering() method in model admin, then check\n293         the object's default ordering. Then, any manually-specified ordering\n294         from the query string overrides anything. Finally, a deterministic\n295         order is guaranteed by calling _get_deterministic_ordering() with the\n296         constructed ordering.\n297         \"\"\"\n298         params = self.params\n299         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())\n300         if ORDER_VAR in params:\n301             # Clear ordering and used params\n302             ordering = []\n303             order_params = params[ORDER_VAR].split('.')\n304             for p in order_params:\n305                 try:\n306                     none, pfx, idx = p.rpartition('-')\n307                     field_name = self.list_display[int(idx)]\n308                     order_field = self.get_ordering_field(field_name)\n309                     if not order_field:\n310                         continue  # No 'admin_order_field', skip it\n311                     if isinstance(order_field, OrderBy):\n312                         if pfx == '-':\n313                             order_field = order_field.copy()\n314                             order_field.reverse_ordering()\n315                         ordering.append(order_field)\n316                     elif hasattr(order_field, 'resolve_expression'):\n317                         # order_field is an expression.\n318                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())\n319                     # reverse order if order_field has already \"-\" as prefix\n320                     elif order_field.startswith('-') and pfx == '-':\n321                         ordering.append(order_field[1:])\n322                     else:\n323                         ordering.append(pfx + order_field)\n324                 except (IndexError, ValueError):\n325                     continue  # Invalid ordering specified, skip it.\n326 \n327         # Add the given query's ordering fields, if any.\n328         ordering.extend(queryset.query.order_by)\n329 \n330         return self._get_deterministic_ordering(ordering)\n331 \n332     def _get_deterministic_ordering(self, ordering):\n333         \"\"\"\n334         Ensure a deterministic order across all database backends. Search for a\n335         single field or unique together set of fields providing a total\n336         ordering. If these are missing, augment the ordering with a descendant\n337         primary key.\n338         \"\"\"\n339         ordering = list(ordering)\n340         ordering_fields = set()\n341         total_ordering_fields = {'pk'} | {\n342             field.attname for field in self.lookup_opts.fields\n343             if field.unique and not field.null\n344         }\n345         for part in ordering:\n346             # Search for single field providing a total ordering.\n347             field_name = None\n348             if isinstance(part, str):\n349                 field_name = part.lstrip('-')\n350             elif isinstance(part, F):\n351                 field_name = part.name\n352             elif isinstance(part, OrderBy) and isinstance(part.expression, F):\n353                 field_name = part.expression.name\n354             if field_name:\n355                 # Normalize attname references by using get_field().\n356                 try:\n357                     field = self.lookup_opts.get_field(field_name)\n358                 except FieldDoesNotExist:\n359                     # Could be \"?\" for random ordering or a related field\n360                     # lookup. Skip this part of introspection for now.\n361                     continue\n362                 # Ordering by a related field name orders by the referenced\n363                 # model's ordering. Skip this part of introspection for now.\n364                 if field.remote_field and field_name == field.name:\n365                     continue\n366                 if field.attname in total_ordering_fields:\n367                     break\n368                 ordering_fields.add(field.attname)\n369         else:\n370             # No single total ordering field, try unique_together and total\n371             # unique constraints.\n372             constraint_field_names = (\n373                 *self.lookup_opts.unique_together,\n374                 *(\n375                     constraint.fields\n376                     for constraint in self.lookup_opts.total_unique_constraints\n377                 ),\n378             )\n379             for field_names in constraint_field_names:\n380                 # Normalize attname references by using get_field().\n381                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]\n382                 # Composite unique constraints containing a nullable column\n383                 # cannot ensure total ordering.\n384                 if any(field.null for field in fields):\n385                     continue\n386                 if ordering_fields.issuperset(field.attname for field in fields):\n387                     break\n388             else:\n389                 # If no set of unique fields is present in the ordering, rely\n390                 # on the primary key to provide total ordering.\n391                 ordering.append('-pk')\n392         return ordering\n393 \n394     def get_ordering_field_columns(self):\n395         \"\"\"\n396         Return a dictionary of ordering field column numbers and asc/desc.\n397         \"\"\"\n398         # We must cope with more than one column having the same underlying sort\n399         # field, so we base things on column numbers.\n400         ordering = self._get_default_ordering()\n401         ordering_fields = {}\n402         if ORDER_VAR not in self.params:\n403             # for ordering specified on ModelAdmin or model Meta, we don't know\n404             # the right column numbers absolutely, because there might be more\n405             # than one column associated with that ordering, so we guess.\n406             for field in ordering:\n407                 if isinstance(field, (Combinable, OrderBy)):\n408                     if not isinstance(field, OrderBy):\n409                         field = field.asc()\n410                     if isinstance(field.expression, F):\n411                         order_type = 'desc' if field.descending else 'asc'\n412                         field = field.expression.name\n413                     else:\n414                         continue\n415                 elif field.startswith('-'):\n416                     field = field[1:]\n417                     order_type = 'desc'\n418                 else:\n419                     order_type = 'asc'\n420                 for index, attr in enumerate(self.list_display):\n421                     if self.get_ordering_field(attr) == field:\n422                         ordering_fields[index] = order_type\n423                         break\n424         else:\n425             for p in self.params[ORDER_VAR].split('.'):\n426                 none, pfx, idx = p.rpartition('-')\n427                 try:\n428                     idx = int(idx)\n429                 except ValueError:\n430                     continue  # skip it\n431                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'\n432         return ordering_fields\n433 \n434     def get_queryset(self, request):\n435         # First, we collect all the declared list filters.\n436         (self.filter_specs, self.has_filters, remaining_lookup_params,\n437          filters_use_distinct) = self.get_filters(request)\n438 \n439         # Then, we let every list filter modify the queryset to its liking.\n440         qs = self.root_queryset\n441         for filter_spec in self.filter_specs:\n442             new_qs = filter_spec.queryset(request, qs)\n443             if new_qs is not None:\n444                 qs = new_qs\n445 \n446         try:\n447             # Finally, we apply the remaining lookup parameters from the query\n448             # string (i.e. those that haven't already been processed by the\n449             # filters).\n450             qs = qs.filter(**remaining_lookup_params)\n451         except (SuspiciousOperation, ImproperlyConfigured):\n452             # Allow certain types of errors to be re-raised as-is so that the\n453             # caller can treat them in a special way.\n454             raise\n455         except Exception as e:\n456             # Every other error is caught with a naked except, because we don't\n457             # have any other way of validating lookup parameters. They might be\n458             # invalid if the keyword arguments are incorrect, or if the values\n459             # are not in the correct type, so we might get FieldError,\n460             # ValueError, ValidationError, or ?.\n461             raise IncorrectLookupParameters(e)\n462 \n463         if not qs.query.select_related:\n464             qs = self.apply_select_related(qs)\n465 \n466         # Set ordering.\n467         ordering = self.get_ordering(request, qs)\n468         qs = qs.order_by(*ordering)\n469 \n470         # Apply search results\n471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)\n472 \n473         # Remove duplicates from results, if necessary\n474         if filters_use_distinct | search_use_distinct:\n475             return qs.distinct()\n476         else:\n477             return qs\n478 \n479     def apply_select_related(self, qs):\n480         if self.list_select_related is True:\n481             return qs.select_related()\n482 \n483         if self.list_select_related is False:\n484             if self.has_related_field_in_list_display():\n485                 return qs.select_related()\n486 \n487         if self.list_select_related:\n488             return qs.select_related(*self.list_select_related)\n489         return qs\n490 \n491     def has_related_field_in_list_display(self):\n492         for field_name in self.list_display:\n493             try:\n494                 field = self.lookup_opts.get_field(field_name)\n495             except FieldDoesNotExist:\n496                 pass\n497             else:\n498                 if isinstance(field.remote_field, ManyToOneRel):\n499                     # <FK>_id field names don't require a join.\n500                     if field_name != field.get_attname():\n501                         return True\n502         return False\n503 \n504     def url_for_result(self, result):\n505         pk = getattr(result, self.pk_attname)\n506         return reverse('admin:%s_%s_change' % (self.opts.app_label,\n507                                                self.opts.model_name),\n508                        args=(quote(pk),),\n509                        current_app=self.model_admin.admin_site.name)\n",
        "intended_behavior": "The intended behavior here would be to accurately consider the user's timezone when calculating the first and last days of a month for the date hierarchy filter. This ensures that the filter boundaries correctly reflect the user's perspective of a month, without extending into the previous month due to timezone differences from UTC."
    },
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/options.py",
        "start": 1,
        "end": 2184,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 import json\n3 import operator\n4 import re\n5 from functools import partial, reduce, update_wrapper\n6 from urllib.parse import quote as urlquote\n7 \n8 from django import forms\n9 from django.conf import settings\n10 from django.contrib import messages\n11 from django.contrib.admin import helpers, widgets\n12 from django.contrib.admin.checks import (\n13     BaseModelAdminChecks, InlineModelAdminChecks, ModelAdminChecks,\n14 )\n15 from django.contrib.admin.exceptions import DisallowedModelAdminToField\n16 from django.contrib.admin.templatetags.admin_urls import add_preserved_filters\n17 from django.contrib.admin.utils import (\n18     NestedObjects, construct_change_message, flatten_fieldsets,\n19     get_deleted_objects, lookup_needs_distinct, model_format_dict,\n20     model_ngettext, quote, unquote,\n21 )\n22 from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n23 from django.contrib.admin.widgets import (\n24     AutocompleteSelect, AutocompleteSelectMultiple,\n25 )\n26 from django.contrib.auth import get_permission_codename\n27 from django.core.exceptions import (\n28     FieldDoesNotExist, FieldError, PermissionDenied, ValidationError,\n29 )\n30 from django.core.paginator import Paginator\n31 from django.db import models, router, transaction\n32 from django.db.models.constants import LOOKUP_SEP\n33 from django.forms.formsets import DELETION_FIELD_NAME, all_valid\n34 from django.forms.models import (\n35     BaseInlineFormSet, inlineformset_factory, modelform_defines_fields,\n36     modelform_factory, modelformset_factory,\n37 )\n38 from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple\n39 from django.http import HttpResponseRedirect\n40 from django.http.response import HttpResponseBase\n41 from django.template.response import SimpleTemplateResponse, TemplateResponse\n42 from django.urls import reverse\n43 from django.utils.decorators import method_decorator\n44 from django.utils.html import format_html\n45 from django.utils.http import urlencode\n46 from django.utils.safestring import mark_safe\n47 from django.utils.text import capfirst, format_lazy, get_text_list\n48 from django.utils.translation import gettext as _, ngettext\n49 from django.views.decorators.csrf import csrf_protect\n50 from django.views.generic import RedirectView\n51 \n52 IS_POPUP_VAR = '_popup'\n53 TO_FIELD_VAR = '_to_field'\n54 \n55 \n56 HORIZONTAL, VERTICAL = 1, 2\n57 \n58 \n59 def get_content_type_for_model(obj):\n60     # Since this module gets imported in the application's root package,\n61     # it cannot import models from other applications at the module level.\n62     from django.contrib.contenttypes.models import ContentType\n63     return ContentType.objects.get_for_model(obj, for_concrete_model=False)\n64 \n65 \n66 def get_ul_class(radio_style):\n67     return 'radiolist' if radio_style == VERTICAL else 'radiolist inline'\n68 \n69 \n70 class IncorrectLookupParameters(Exception):\n71     pass\n72 \n73 \n74 # Defaults for formfield_overrides. ModelAdmin subclasses can change this\n75 # by adding to ModelAdmin.formfield_overrides.\n76 \n77 FORMFIELD_FOR_DBFIELD_DEFAULTS = {\n78     models.DateTimeField: {\n79         'form_class': forms.SplitDateTimeField,\n80         'widget': widgets.AdminSplitDateTime\n81     },\n82     models.DateField: {'widget': widgets.AdminDateWidget},\n83     models.TimeField: {'widget': widgets.AdminTimeWidget},\n84     models.TextField: {'widget': widgets.AdminTextareaWidget},\n85     models.URLField: {'widget': widgets.AdminURLFieldWidget},\n86     models.IntegerField: {'widget': widgets.AdminIntegerFieldWidget},\n87     models.BigIntegerField: {'widget': widgets.AdminBigIntegerFieldWidget},\n88     models.CharField: {'widget': widgets.AdminTextInputWidget},\n89     models.ImageField: {'widget': widgets.AdminFileWidget},\n90     models.FileField: {'widget': widgets.AdminFileWidget},\n91     models.EmailField: {'widget': widgets.AdminEmailInputWidget},\n92     models.UUIDField: {'widget': widgets.AdminUUIDInputWidget},\n93 }\n94 \n95 csrf_protect_m = method_decorator(csrf_protect)\n96 \n97 \n98 class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n99     \"\"\"Functionality common to both ModelAdmin and InlineAdmin.\"\"\"\n100 \n101     autocomplete_fields = ()\n102     raw_id_fields = ()\n103     fields = None\n104     exclude = None\n105     fieldsets = None\n106     form = forms.ModelForm\n107     filter_vertical = ()\n108     filter_horizontal = ()\n109     radio_fields = {}\n110     prepopulated_fields = {}\n111     formfield_overrides = {}\n112     readonly_fields = ()\n113     ordering = None\n114     sortable_by = None\n115     view_on_site = True\n116     show_full_result_count = True\n117     checks_class = BaseModelAdminChecks\n118 \n119     def check(self, **kwargs):\n120         return self.checks_class().check(self, **kwargs)\n121 \n122     def __init__(self):\n123         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides\n124         # rather than simply overwriting.\n125         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)\n126         for k, v in self.formfield_overrides.items():\n127             overrides.setdefault(k, {}).update(v)\n128         self.formfield_overrides = overrides\n129 \n130     def formfield_for_dbfield(self, db_field, request, **kwargs):\n131         \"\"\"\n132         Hook for specifying the form Field instance for a given database Field\n133         instance.\n134 \n135         If kwargs are given, they're passed to the form Field's constructor.\n136         \"\"\"\n137         # If the field specifies choices, we don't need to look for special\n138         # admin widgets - we just need to use a select widget of some kind.\n139         if db_field.choices:\n140             return self.formfield_for_choice_field(db_field, request, **kwargs)\n141 \n142         # ForeignKey or ManyToManyFields\n143         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):\n144             # Combine the field kwargs with any options for formfield_overrides.\n145             # Make sure the passed in **kwargs override anything in\n146             # formfield_overrides because **kwargs is more specific, and should\n147             # always win.\n148             if db_field.__class__ in self.formfield_overrides:\n149                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}\n150 \n151             # Get the correct formfield.\n152             if isinstance(db_field, models.ForeignKey):\n153                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)\n154             elif isinstance(db_field, models.ManyToManyField):\n155                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)\n156 \n157             # For non-raw_id fields, wrap the widget with a wrapper that adds\n158             # extra HTML -- the \"add other\" interface -- to the end of the\n159             # rendered output. formfield can be None if it came from a\n160             # OneToOneField with parent_link=True or a M2M intermediary.\n161             if formfield and db_field.name not in self.raw_id_fields:\n162                 related_modeladmin = self.admin_site._registry.get(db_field.remote_field.model)\n163                 wrapper_kwargs = {}\n164                 if related_modeladmin:\n165                     wrapper_kwargs.update(\n166                         can_add_related=related_modeladmin.has_add_permission(request),\n167                         can_change_related=related_modeladmin.has_change_permission(request),\n168                         can_delete_related=related_modeladmin.has_delete_permission(request),\n169                         can_view_related=related_modeladmin.has_view_permission(request),\n170                     )\n171                 formfield.widget = widgets.RelatedFieldWidgetWrapper(\n172                     formfield.widget, db_field.remote_field, self.admin_site, **wrapper_kwargs\n173                 )\n174 \n175             return formfield\n176 \n177         # If we've got overrides for the formfield defined, use 'em. **kwargs\n178         # passed to formfield_for_dbfield override the defaults.\n179         for klass in db_field.__class__.mro():\n180             if klass in self.formfield_overrides:\n181                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}\n182                 return db_field.formfield(**kwargs)\n183 \n184         # For any other type of field, just call its formfield() method.\n185         return db_field.formfield(**kwargs)\n186 \n187     def formfield_for_choice_field(self, db_field, request, **kwargs):\n188         \"\"\"\n189         Get a form Field for a database Field that has declared choices.\n190         \"\"\"\n191         # If the field is named as a radio_field, use a RadioSelect\n192         if db_field.name in self.radio_fields:\n193             # Avoid stomping on custom widget/choices arguments.\n194             if 'widget' not in kwargs:\n195                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n196                     'class': get_ul_class(self.radio_fields[db_field.name]),\n197                 })\n198             if 'choices' not in kwargs:\n199                 kwargs['choices'] = db_field.get_choices(\n200                     include_blank=db_field.blank,\n201                     blank_choice=[('', _('None'))]\n202                 )\n203         return db_field.formfield(**kwargs)\n204 \n205     def get_field_queryset(self, db, db_field, request):\n206         \"\"\"\n207         If the ModelAdmin specifies ordering, the queryset should respect that\n208         ordering.  Otherwise don't specify the queryset, let the field decide\n209         (return None in that case).\n210         \"\"\"\n211         related_admin = self.admin_site._registry.get(db_field.remote_field.model)\n212         if related_admin is not None:\n213             ordering = related_admin.get_ordering(request)\n214             if ordering is not None and ordering != ():\n215                 return db_field.remote_field.model._default_manager.using(db).order_by(*ordering)\n216         return None\n217 \n218     def formfield_for_foreignkey(self, db_field, request, **kwargs):\n219         \"\"\"\n220         Get a form Field for a ForeignKey.\n221         \"\"\"\n222         db = kwargs.get('using')\n223 \n224         if 'widget' not in kwargs:\n225             if db_field.name in self.get_autocomplete_fields(request):\n226                 kwargs['widget'] = AutocompleteSelect(db_field.remote_field, self.admin_site, using=db)\n227             elif db_field.name in self.raw_id_fields:\n228                 kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n229             elif db_field.name in self.radio_fields:\n230                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n231                     'class': get_ul_class(self.radio_fields[db_field.name]),\n232                 })\n233                 kwargs['empty_label'] = _('None') if db_field.blank else None\n234 \n235         if 'queryset' not in kwargs:\n236             queryset = self.get_field_queryset(db, db_field, request)\n237             if queryset is not None:\n238                 kwargs['queryset'] = queryset\n239 \n240         return db_field.formfield(**kwargs)\n241 \n242     def formfield_for_manytomany(self, db_field, request, **kwargs):\n243         \"\"\"\n244         Get a form Field for a ManyToManyField.\n245         \"\"\"\n246         # If it uses an intermediary model that isn't auto created, don't show\n247         # a field in admin.\n248         if not db_field.remote_field.through._meta.auto_created:\n249             return None\n250         db = kwargs.get('using')\n251 \n252         autocomplete_fields = self.get_autocomplete_fields(request)\n253         if db_field.name in autocomplete_fields:\n254             kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n255         elif db_field.name in self.raw_id_fields:\n256             kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n257         elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n258             kwargs['widget'] = widgets.FilteredSelectMultiple(\n259                 db_field.verbose_name,\n260                 db_field.name in self.filter_vertical\n261             )\n262 \n263         if 'queryset' not in kwargs:\n264             queryset = self.get_field_queryset(db, db_field, request)\n265             if queryset is not None:\n266                 kwargs['queryset'] = queryset\n267 \n268         form_field = db_field.formfield(**kwargs)\n269         if (isinstance(form_field.widget, SelectMultiple) and\n270                 not isinstance(form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple))):\n271             msg = _('Hold down \u201cControl\u201d, or \u201cCommand\u201d on a Mac, to select more than one.')\n272             help_text = form_field.help_text\n273             form_field.help_text = format_lazy('{} {}', help_text, msg) if help_text else msg\n274         return form_field\n275 \n276     def get_autocomplete_fields(self, request):\n277         \"\"\"\n278         Return a list of ForeignKey and/or ManyToMany fields which should use\n279         an autocomplete widget.\n280         \"\"\"\n281         return self.autocomplete_fields\n282 \n283     def get_view_on_site_url(self, obj=None):\n284         if obj is None or not self.view_on_site:\n285             return None\n286 \n287         if callable(self.view_on_site):\n288             return self.view_on_site(obj)\n289         elif self.view_on_site and hasattr(obj, 'get_absolute_url'):\n290             # use the ContentType lookup if view_on_site is True\n291             return reverse('admin:view_on_site', kwargs={\n292                 'content_type_id': get_content_type_for_model(obj).pk,\n293                 'object_id': obj.pk\n294             })\n295 \n296     def get_empty_value_display(self):\n297         \"\"\"\n298         Return the empty_value_display set on ModelAdmin or AdminSite.\n299         \"\"\"\n300         try:\n301             return mark_safe(self.empty_value_display)\n302         except AttributeError:\n303             return mark_safe(self.admin_site.empty_value_display)\n304 \n305     def get_exclude(self, request, obj=None):\n306         \"\"\"\n307         Hook for specifying exclude.\n308         \"\"\"\n309         return self.exclude\n310 \n311     def get_fields(self, request, obj=None):\n312         \"\"\"\n313         Hook for specifying fields.\n314         \"\"\"\n315         if self.fields:\n316             return self.fields\n317         # _get_form_for_get_fields() is implemented in subclasses.\n318         form = self._get_form_for_get_fields(request, obj)\n319         return [*form.base_fields, *self.get_readonly_fields(request, obj)]\n320 \n321     def get_fieldsets(self, request, obj=None):\n322         \"\"\"\n323         Hook for specifying fieldsets.\n324         \"\"\"\n325         if self.fieldsets:\n326             return self.fieldsets\n327         return [(None, {'fields': self.get_fields(request, obj)})]\n328 \n329     def get_inlines(self, request, obj):\n330         \"\"\"Hook for specifying custom inlines.\"\"\"\n331         return self.inlines\n332 \n333     def get_ordering(self, request):\n334         \"\"\"\n335         Hook for specifying field ordering.\n336         \"\"\"\n337         return self.ordering or ()  # otherwise we might try to *None, which is bad ;)\n338 \n339     def get_readonly_fields(self, request, obj=None):\n340         \"\"\"\n341         Hook for specifying custom readonly fields.\n342         \"\"\"\n343         return self.readonly_fields\n344 \n345     def get_prepopulated_fields(self, request, obj=None):\n346         \"\"\"\n347         Hook for specifying custom prepopulated fields.\n348         \"\"\"\n349         return self.prepopulated_fields\n350 \n351     def get_queryset(self, request):\n352         \"\"\"\n353         Return a QuerySet of all model instances that can be edited by the\n354         admin site. This is used by changelist_view.\n355         \"\"\"\n356         qs = self.model._default_manager.get_queryset()\n357         # TODO: this should be handled by some parameter to the ChangeList.\n358         ordering = self.get_ordering(request)\n359         if ordering:\n360             qs = qs.order_by(*ordering)\n361         return qs\n362 \n363     def get_sortable_by(self, request):\n364         \"\"\"Hook for specifying which fields can be sorted in the changelist.\"\"\"\n365         return self.sortable_by if self.sortable_by is not None else self.get_list_display(request)\n366 \n367     def lookup_allowed(self, lookup, value):\n368         from django.contrib.admin.filters import SimpleListFilter\n369 \n370         model = self.model\n371         # Check FKey lookups that are allowed, so that popups produced by\n372         # ForeignKeyRawIdWidget, on the basis of ForeignKey.limit_choices_to,\n373         # are allowed to work.\n374         for fk_lookup in model._meta.related_fkey_lookups:\n375             # As ``limit_choices_to`` can be a callable, invoke it here.\n376             if callable(fk_lookup):\n377                 fk_lookup = fk_lookup()\n378             if (lookup, value) in widgets.url_params_from_lookup_dict(fk_lookup).items():\n379                 return True\n380 \n381         relation_parts = []\n382         prev_field = None\n383         for part in lookup.split(LOOKUP_SEP):\n384             try:\n385                 field = model._meta.get_field(part)\n386             except FieldDoesNotExist:\n387                 # Lookups on nonexistent fields are ok, since they're ignored\n388                 # later.\n389                 break\n390             # It is allowed to filter on values that would be found from local\n391             # model anyways. For example, if you filter on employee__department__id,\n392             # then the id value would be found already from employee__department_id.\n393             if not prev_field or (prev_field.is_relation and\n394                                   field not in prev_field.get_path_info()[-1].target_fields):\n395                 relation_parts.append(part)\n396             if not getattr(field, 'get_path_info', None):\n397                 # This is not a relational field, so further parts\n398                 # must be transforms.\n399                 break\n400             prev_field = field\n401             model = field.get_path_info()[-1].to_opts.model\n402 \n403         if len(relation_parts) <= 1:\n404             # Either a local field filter, or no fields at all.\n405             return True\n406         valid_lookups = {self.date_hierarchy}\n407         for filter_item in self.list_filter:\n408             if isinstance(filter_item, type) and issubclass(filter_item, SimpleListFilter):\n409                 valid_lookups.add(filter_item.parameter_name)\n410             elif isinstance(filter_item, (list, tuple)):\n411                 valid_lookups.add(filter_item[0])\n412             else:\n413                 valid_lookups.add(filter_item)\n414 \n415         # Is it a valid relational lookup?\n416         return not {\n417             LOOKUP_SEP.join(relation_parts),\n418             LOOKUP_SEP.join(relation_parts + [part])\n419         }.isdisjoint(valid_lookups)\n420 \n421     def to_field_allowed(self, request, to_field):\n422         \"\"\"\n423         Return True if the model associated with this admin should be\n424         allowed to be referenced by the specified field.\n425         \"\"\"\n426         opts = self.model._meta\n427 \n428         try:\n429             field = opts.get_field(to_field)\n430         except FieldDoesNotExist:\n431             return False\n432 \n433         # Always allow referencing the primary key since it's already possible\n434         # to get this information from the change view URL.\n435         if field.primary_key:\n436             return True\n437 \n438         # Allow reverse relationships to models defining m2m fields if they\n439         # target the specified field.\n440         for many_to_many in opts.many_to_many:\n441             if many_to_many.m2m_target_field_name() == to_field:\n442                 return True\n443 \n444         # Make sure at least one of the models registered for this site\n445         # references this field through a FK or a M2M relationship.\n446         registered_models = set()\n447         for model, admin in self.admin_site._registry.items():\n448             registered_models.add(model)\n449             for inline in admin.inlines:\n450                 registered_models.add(inline.model)\n451 \n452         related_objects = (\n453             f for f in opts.get_fields(include_hidden=True)\n454             if (f.auto_created and not f.concrete)\n455         )\n456         for related_object in related_objects:\n457             related_model = related_object.related_model\n458             remote_field = related_object.field.remote_field\n459             if (any(issubclass(model, related_model) for model in registered_models) and\n460                     hasattr(remote_field, 'get_related_field') and\n461                     remote_field.get_related_field() == field):\n462                 return True\n463 \n464         return False\n465 \n466     def has_add_permission(self, request):\n467         \"\"\"\n468         Return True if the given request has permission to add an object.\n469         Can be overridden by the user in subclasses.\n470         \"\"\"\n471         opts = self.opts\n472         codename = get_permission_codename('add', opts)\n473         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n474 \n475     def has_change_permission(self, request, obj=None):\n476         \"\"\"\n477         Return True if the given request has permission to change the given\n478         Django model instance, the default implementation doesn't examine the\n479         `obj` parameter.\n480 \n481         Can be overridden by the user in subclasses. In such case it should\n482         return True if the given request has permission to change the `obj`\n483         model instance. If `obj` is None, this should return True if the given\n484         request has permission to change *any* object of the given type.\n485         \"\"\"\n486         opts = self.opts\n487         codename = get_permission_codename('change', opts)\n488         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n489 \n490     def has_delete_permission(self, request, obj=None):\n491         \"\"\"\n492         Return True if the given request has permission to change the given\n493         Django model instance, the default implementation doesn't examine the\n494         `obj` parameter.\n495 \n496         Can be overridden by the user in subclasses. In such case it should\n497         return True if the given request has permission to delete the `obj`\n498         model instance. If `obj` is None, this should return True if the given\n499         request has permission to delete *any* object of the given type.\n500         \"\"\"\n501         opts = self.opts\n502         codename = get_permission_codename('delete', opts)\n503         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n504 \n505     def has_view_permission(self, request, obj=None):\n506         \"\"\"\n507         Return True if the given request has permission to view the given\n508         Django model instance. The default implementation doesn't examine the\n509         `obj` parameter.\n510 \n511         If overridden by the user in subclasses, it should return True if the\n512         given request has permission to view the `obj` model instance. If `obj`\n513         is None, it should return True if the request has permission to view\n514         any object of the given type.\n515         \"\"\"\n516         opts = self.opts\n517         codename_view = get_permission_codename('view', opts)\n518         codename_change = get_permission_codename('change', opts)\n519         return (\n520             request.user.has_perm('%s.%s' % (opts.app_label, codename_view)) or\n521             request.user.has_perm('%s.%s' % (opts.app_label, codename_change))\n522         )\n523 \n524     def has_view_or_change_permission(self, request, obj=None):\n525         return self.has_view_permission(request, obj) or self.has_change_permission(request, obj)\n526 \n527     def has_module_permission(self, request):\n528         \"\"\"\n529         Return True if the given request has any permission in the given\n530         app label.\n531 \n532         Can be overridden by the user in subclasses. In such case it should\n533         return True if the given request has permission to view the module on\n534         the admin index page and access the module's index page. Overriding it\n535         does not restrict access to the add, change or delete views. Use\n536         `ModelAdmin.has_(add|change|delete)_permission` for that.\n537         \"\"\"\n538         return request.user.has_module_perms(self.opts.app_label)\n539 \n540 \n541 class ModelAdmin(BaseModelAdmin):\n542     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n543 \n544     list_display = ('__str__',)\n545     list_display_links = ()\n546     list_filter = ()\n547     list_select_related = False\n548     list_per_page = 100\n549     list_max_show_all = 200\n550     list_editable = ()\n551     search_fields = ()\n552     date_hierarchy = None\n553     save_as = False\n554     save_as_continue = True\n555     save_on_top = False\n556     paginator = Paginator\n557     preserve_filters = True\n558     inlines = []\n559 \n560     # Custom templates (designed to be over-ridden in subclasses)\n561     add_form_template = None\n562     change_form_template = None\n563     change_list_template = None\n564     delete_confirmation_template = None\n565     delete_selected_confirmation_template = None\n566     object_history_template = None\n567     popup_response_template = None\n568 \n569     # Actions\n570     actions = []\n571     action_form = helpers.ActionForm\n572     actions_on_top = True\n573     actions_on_bottom = False\n574     actions_selection_counter = True\n575     checks_class = ModelAdminChecks\n576 \n577     def __init__(self, model, admin_site):\n578         self.model = model\n579         self.opts = model._meta\n580         self.admin_site = admin_site\n581         super().__init__()\n582 \n583     def __str__(self):\n584         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n585 \n586     def get_inline_instances(self, request, obj=None):\n587         inline_instances = []\n588         for inline_class in self.get_inlines(request, obj):\n589             inline = inline_class(self.model, self.admin_site)\n590             if request:\n591                 if not (inline.has_view_or_change_permission(request, obj) or\n592                         inline.has_add_permission(request, obj) or\n593                         inline.has_delete_permission(request, obj)):\n594                     continue\n595                 if not inline.has_add_permission(request, obj):\n596                     inline.max_num = 0\n597             inline_instances.append(inline)\n598 \n599         return inline_instances\n600 \n601     def get_urls(self):\n602         from django.urls import path\n603 \n604         def wrap(view):\n605             def wrapper(*args, **kwargs):\n606                 return self.admin_site.admin_view(view)(*args, **kwargs)\n607             wrapper.model_admin = self\n608             return update_wrapper(wrapper, view)\n609 \n610         info = self.model._meta.app_label, self.model._meta.model_name\n611 \n612         return [\n613             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),\n614             path('add/', wrap(self.add_view), name='%s_%s_add' % info),\n615             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),\n616             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),\n617             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),\n618             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),\n619             # For backwards compatibility (was the change url before 1.9)\n620             path('<path:object_id>/', wrap(RedirectView.as_view(\n621                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)\n622             ))),\n623         ]\n624 \n625     @property\n626     def urls(self):\n627         return self.get_urls()\n628 \n629     @property\n630     def media(self):\n631         extra = '' if settings.DEBUG else '.min'\n632         js = [\n633             'vendor/jquery/jquery%s.js' % extra,\n634             'jquery.init.js',\n635             'core.js',\n636             'admin/RelatedObjectLookups.js',\n637             'actions%s.js' % extra,\n638             'urlify.js',\n639             'prepopulate%s.js' % extra,\n640             'vendor/xregexp/xregexp%s.js' % extra,\n641         ]\n642         return forms.Media(js=['admin/js/%s' % url for url in js])\n643 \n644     def get_model_perms(self, request):\n645         \"\"\"\n646         Return a dict of all perms for this model. This dict has the keys\n647         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n648         for each of those actions.\n649         \"\"\"\n650         return {\n651             'add': self.has_add_permission(request),\n652             'change': self.has_change_permission(request),\n653             'delete': self.has_delete_permission(request),\n654             'view': self.has_view_permission(request),\n655         }\n656 \n657     def _get_form_for_get_fields(self, request, obj):\n658         return self.get_form(request, obj, fields=None)\n659 \n660     def get_form(self, request, obj=None, change=False, **kwargs):\n661         \"\"\"\n662         Return a Form class for use in the admin add view. This is used by\n663         add_view and change_view.\n664         \"\"\"\n665         if 'fields' in kwargs:\n666             fields = kwargs.pop('fields')\n667         else:\n668             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n669         excluded = self.get_exclude(request, obj)\n670         exclude = [] if excluded is None else list(excluded)\n671         readonly_fields = self.get_readonly_fields(request, obj)\n672         exclude.extend(readonly_fields)\n673         # Exclude all fields if it's a change form and the user doesn't have\n674         # the change permission.\n675         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):\n676             exclude.extend(fields)\n677         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n678             # Take the custom ModelForm's Meta.exclude into account only if the\n679             # ModelAdmin doesn't define its own.\n680             exclude.extend(self.form._meta.exclude)\n681         # if exclude is an empty list we pass None to be consistent with the\n682         # default on modelform_factory\n683         exclude = exclude or None\n684 \n685         # Remove declared form fields which are in readonly_fields.\n686         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)\n687         form = type(self.form.__name__, (self.form,), new_attrs)\n688 \n689         defaults = {\n690             'form': form,\n691             'fields': fields,\n692             'exclude': exclude,\n693             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n694             **kwargs,\n695         }\n696 \n697         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n698             defaults['fields'] = forms.ALL_FIELDS\n699 \n700         try:\n701             return modelform_factory(self.model, **defaults)\n702         except FieldError as e:\n703             raise FieldError(\n704                 '%s. Check fields/fieldsets/exclude attributes of class %s.'\n705                 % (e, self.__class__.__name__)\n706             )\n707 \n708     def get_changelist(self, request, **kwargs):\n709         \"\"\"\n710         Return the ChangeList class for use on the changelist page.\n711         \"\"\"\n712         from django.contrib.admin.views.main import ChangeList\n713         return ChangeList\n714 \n715     def get_changelist_instance(self, request):\n716         \"\"\"\n717         Return a `ChangeList` instance based on `request`. May raise\n718         `IncorrectLookupParameters`.\n719         \"\"\"\n720         list_display = self.get_list_display(request)\n721         list_display_links = self.get_list_display_links(request, list_display)\n722         # Add the action checkboxes if any actions are available.\n723         if self.get_actions(request):\n724             list_display = ['action_checkbox', *list_display]\n725         sortable_by = self.get_sortable_by(request)\n726         ChangeList = self.get_changelist(request)\n727         return ChangeList(\n728             request,\n729             self.model,\n730             list_display,\n731             list_display_links,\n732             self.get_list_filter(request),\n733             self.date_hierarchy,\n734             self.get_search_fields(request),\n735             self.get_list_select_related(request),\n736             self.list_per_page,\n737             self.list_max_show_all,\n738             self.list_editable,\n739             self,\n740             sortable_by,\n741         )\n742 \n743     def get_object(self, request, object_id, from_field=None):\n744         \"\"\"\n745         Return an instance matching the field and value provided, the primary\n746         key is used if no field is provided. Return ``None`` if no match is\n747         found or the object_id fails validation.\n748         \"\"\"\n749         queryset = self.get_queryset(request)\n750         model = queryset.model\n751         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)\n752         try:\n753             object_id = field.to_python(object_id)\n754             return queryset.get(**{field.name: object_id})\n755         except (model.DoesNotExist, ValidationError, ValueError):\n756             return None\n757 \n758     def get_changelist_form(self, request, **kwargs):\n759         \"\"\"\n760         Return a Form class for use in the Formset on the changelist page.\n761         \"\"\"\n762         defaults = {\n763             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n764             **kwargs,\n765         }\n766         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):\n767             defaults['fields'] = forms.ALL_FIELDS\n768 \n769         return modelform_factory(self.model, **defaults)\n770 \n771     def get_changelist_formset(self, request, **kwargs):\n772         \"\"\"\n773         Return a FormSet class for use on the changelist page if list_editable\n774         is used.\n775         \"\"\"\n776         defaults = {\n777             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n778             **kwargs,\n779         }\n780         return modelformset_factory(\n781             self.model, self.get_changelist_form(request), extra=0,\n782             fields=self.list_editable, **defaults\n783         )\n784 \n785     def get_formsets_with_inlines(self, request, obj=None):\n786         \"\"\"\n787         Yield formsets and the corresponding inlines.\n788         \"\"\"\n789         for inline in self.get_inline_instances(request, obj):\n790             yield inline.get_formset(request, obj), inline\n791 \n792     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):\n793         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n794 \n795     def log_addition(self, request, object, message):\n796         \"\"\"\n797         Log that an object has been successfully added.\n798 \n799         The default implementation creates an admin LogEntry object.\n800         \"\"\"\n801         from django.contrib.admin.models import LogEntry, ADDITION\n802         return LogEntry.objects.log_action(\n803             user_id=request.user.pk,\n804             content_type_id=get_content_type_for_model(object).pk,\n805             object_id=object.pk,\n806             object_repr=str(object),\n807             action_flag=ADDITION,\n808             change_message=message,\n809         )\n810 \n811     def log_change(self, request, object, message):\n812         \"\"\"\n813         Log that an object has been successfully changed.\n814 \n815         The default implementation creates an admin LogEntry object.\n816         \"\"\"\n817         from django.contrib.admin.models import LogEntry, CHANGE\n818         return LogEntry.objects.log_action(\n819             user_id=request.user.pk,\n820             content_type_id=get_content_type_for_model(object).pk,\n821             object_id=object.pk,\n822             object_repr=str(object),\n823             action_flag=CHANGE,\n824             change_message=message,\n825         )\n826 \n827     def log_deletion(self, request, object, object_repr):\n828         \"\"\"\n829         Log that an object will be deleted. Note that this method must be\n830         called before the deletion.\n831 \n832         The default implementation creates an admin LogEntry object.\n833         \"\"\"\n834         from django.contrib.admin.models import LogEntry, DELETION\n835         return LogEntry.objects.log_action(\n836             user_id=request.user.pk,\n837             content_type_id=get_content_type_for_model(object).pk,\n838             object_id=object.pk,\n839             object_repr=object_repr,\n840             action_flag=DELETION,\n841         )\n842 \n843     def action_checkbox(self, obj):\n844         \"\"\"\n845         A list_display column containing a checkbox widget.\n846         \"\"\"\n847         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n848     action_checkbox.short_description = mark_safe('<input type=\"checkbox\" id=\"action-toggle\">')\n849 \n850     def _get_base_actions(self):\n851         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n852         actions = []\n853 \n854         # Gather actions from the admin site first\n855         for (name, func) in self.admin_site.actions:\n856             description = getattr(func, 'short_description', name.replace('_', ' '))\n857             actions.append((func, name, description))\n858         # Add actions from this ModelAdmin.\n859         actions.extend(self.get_action(action) for action in self.actions or [])\n860         # get_action might have returned None, so filter any of those out.\n861         return filter(None, actions)\n862 \n863     def _filter_actions_by_permissions(self, request, actions):\n864         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n865         filtered_actions = []\n866         for action in actions:\n867             callable = action[0]\n868             if not hasattr(callable, 'allowed_permissions'):\n869                 filtered_actions.append(action)\n870                 continue\n871             permission_checks = (\n872                 getattr(self, 'has_%s_permission' % permission)\n873                 for permission in callable.allowed_permissions\n874             )\n875             if any(has_permission(request) for has_permission in permission_checks):\n876                 filtered_actions.append(action)\n877         return filtered_actions\n878 \n879     def get_actions(self, request):\n880         \"\"\"\n881         Return a dictionary mapping the names of all actions for this\n882         ModelAdmin to a tuple of (callable, name, description) for each action.\n883         \"\"\"\n884         # If self.actions is set to None that means actions are disabled on\n885         # this page.\n886         if self.actions is None or IS_POPUP_VAR in request.GET:\n887             return {}\n888         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n889         return {name: (func, name, desc) for func, name, desc in actions}\n890 \n891     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):\n892         \"\"\"\n893         Return a list of choices for use in a form object.  Each choice is a\n894         tuple (name, description).\n895         \"\"\"\n896         choices = [] + default_choices\n897         for func, name, description in self.get_actions(request).values():\n898             choice = (name, description % model_format_dict(self.opts))\n899             choices.append(choice)\n900         return choices\n901 \n902     def get_action(self, action):\n903         \"\"\"\n904         Return a given action from a parameter, which can either be a callable,\n905         or the name of a method on the ModelAdmin.  Return is a tuple of\n906         (callable, name, description).\n907         \"\"\"\n908         # If the action is a callable, just use it.\n909         if callable(action):\n910             func = action\n911             action = action.__name__\n912 \n913         # Next, look for a method. Grab it off self.__class__ to get an unbound\n914         # method instead of a bound one; this ensures that the calling\n915         # conventions are the same for functions and methods.\n916         elif hasattr(self.__class__, action):\n917             func = getattr(self.__class__, action)\n918 \n919         # Finally, look for a named method on the admin site\n920         else:\n921             try:\n922                 func = self.admin_site.get_action(action)\n923             except KeyError:\n924                 return None\n925 \n926         if hasattr(func, 'short_description'):\n927             description = func.short_description\n928         else:\n929             description = capfirst(action.replace('_', ' '))\n930         return func, action, description\n931 \n932     def get_list_display(self, request):\n933         \"\"\"\n934         Return a sequence containing the fields to be displayed on the\n935         changelist.\n936         \"\"\"\n937         return self.list_display\n938 \n939     def get_list_display_links(self, request, list_display):\n940         \"\"\"\n941         Return a sequence containing the fields to be displayed as links\n942         on the changelist. The list_display parameter is the list of fields\n943         returned by get_list_display().\n944         \"\"\"\n945         if self.list_display_links or self.list_display_links is None or not list_display:\n946             return self.list_display_links\n947         else:\n948             # Use only the first item in list_display as link\n949             return list(list_display)[:1]\n950 \n951     def get_list_filter(self, request):\n952         \"\"\"\n953         Return a sequence containing the fields to be displayed as filters in\n954         the right sidebar of the changelist page.\n955         \"\"\"\n956         return self.list_filter\n957 \n958     def get_list_select_related(self, request):\n959         \"\"\"\n960         Return a list of fields to add to the select_related() part of the\n961         changelist items query.\n962         \"\"\"\n963         return self.list_select_related\n964 \n965     def get_search_fields(self, request):\n966         \"\"\"\n967         Return a sequence containing the fields to be searched whenever\n968         somebody submits a search query.\n969         \"\"\"\n970         return self.search_fields\n971 \n972     def get_search_results(self, request, queryset, search_term):\n973         \"\"\"\n974         Return a tuple containing a queryset to implement the search\n975         and a boolean indicating if the results may contain duplicates.\n976         \"\"\"\n977         # Apply keyword searches.\n978         def construct_search(field_name):\n979             if field_name.startswith('^'):\n980                 return \"%s__istartswith\" % field_name[1:]\n981             elif field_name.startswith('='):\n982                 return \"%s__iexact\" % field_name[1:]\n983             elif field_name.startswith('@'):\n984                 return \"%s__search\" % field_name[1:]\n985             # Use field_name if it includes a lookup.\n986             opts = queryset.model._meta\n987             lookup_fields = field_name.split(LOOKUP_SEP)\n988             # Go through the fields, following all relations.\n989             prev_field = None\n990             for path_part in lookup_fields:\n991                 if path_part == 'pk':\n992                     path_part = opts.pk.name\n993                 try:\n994                     field = opts.get_field(path_part)\n995                 except FieldDoesNotExist:\n996                     # Use valid query lookups.\n997                     if prev_field and prev_field.get_lookup(path_part):\n998                         return field_name\n999                 else:\n1000                     prev_field = field\n1001                     if hasattr(field, 'get_path_info'):\n1002                         # Update opts to follow the relation.\n1003                         opts = field.get_path_info()[-1].to_opts\n1004             # Otherwise, use the field with icontains.\n1005             return \"%s__icontains\" % field_name\n1006 \n1007         use_distinct = False\n1008         search_fields = self.get_search_fields(request)\n1009         if search_fields and search_term:\n1010             orm_lookups = [construct_search(str(search_field))\n1011                            for search_field in search_fields]\n1012             for bit in search_term.split():\n1013                 or_queries = [models.Q(**{orm_lookup: bit})\n1014                               for orm_lookup in orm_lookups]\n1015                 queryset = queryset.filter(reduce(operator.or_, or_queries))\n1016             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)\n1017 \n1018         return queryset, use_distinct\n1019 \n1020     def get_preserved_filters(self, request):\n1021         \"\"\"\n1022         Return the preserved filters querystring.\n1023         \"\"\"\n1024         match = request.resolver_match\n1025         if self.preserve_filters and match:\n1026             opts = self.model._meta\n1027             current_url = '%s:%s' % (match.app_name, match.url_name)\n1028             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)\n1029             if current_url == changelist_url:\n1030                 preserved_filters = request.GET.urlencode()\n1031             else:\n1032                 preserved_filters = request.GET.get('_changelist_filters')\n1033 \n1034             if preserved_filters:\n1035                 return urlencode({'_changelist_filters': preserved_filters})\n1036         return ''\n1037 \n1038     def construct_change_message(self, request, form, formsets, add=False):\n1039         \"\"\"\n1040         Construct a JSON structure describing changes from a changed object.\n1041         \"\"\"\n1042         return construct_change_message(form, formsets, add)\n1043 \n1044     def message_user(self, request, message, level=messages.INFO, extra_tags='',\n1045                      fail_silently=False):\n1046         \"\"\"\n1047         Send a message to the user. The default implementation\n1048         posts a message using the django.contrib.messages backend.\n1049 \n1050         Exposes almost the same API as messages.add_message(), but accepts the\n1051         positional arguments in a different order to maintain backwards\n1052         compatibility. For convenience, it accepts the `level` argument as\n1053         a string rather than the usual level number.\n1054         \"\"\"\n1055         if not isinstance(level, int):\n1056             # attempt to get the level if passed a string\n1057             try:\n1058                 level = getattr(messages.constants, level.upper())\n1059             except AttributeError:\n1060                 levels = messages.constants.DEFAULT_TAGS.values()\n1061                 levels_repr = ', '.join('`%s`' % l for l in levels)\n1062                 raise ValueError(\n1063                     'Bad message level string: `%s`. Possible values are: %s'\n1064                     % (level, levels_repr)\n1065                 )\n1066 \n1067         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)\n1068 \n1069     def save_form(self, request, form, change):\n1070         \"\"\"\n1071         Given a ModelForm return an unsaved instance. ``change`` is True if\n1072         the object is being changed, and False if it's being added.\n1073         \"\"\"\n1074         return form.save(commit=False)\n1075 \n1076     def save_model(self, request, obj, form, change):\n1077         \"\"\"\n1078         Given a model instance save it to the database.\n1079         \"\"\"\n1080         obj.save()\n1081 \n1082     def delete_model(self, request, obj):\n1083         \"\"\"\n1084         Given a model instance delete it from the database.\n1085         \"\"\"\n1086         obj.delete()\n1087 \n1088     def delete_queryset(self, request, queryset):\n1089         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1090         queryset.delete()\n1091 \n1092     def save_formset(self, request, form, formset, change):\n1093         \"\"\"\n1094         Given an inline formset save it to the database.\n1095         \"\"\"\n1096         formset.save()\n1097 \n1098     def save_related(self, request, form, formsets, change):\n1099         \"\"\"\n1100         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the\n1101         list of inline formsets and a boolean value based on whether the\n1102         parent is being added or changed, save the related objects to the\n1103         database. Note that at this point save_form() and save_model() have\n1104         already been called.\n1105         \"\"\"\n1106         form.save_m2m()\n1107         for formset in formsets:\n1108             self.save_formset(request, form, formset, change=change)\n1109 \n1110     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):\n1111         opts = self.model._meta\n1112         app_label = opts.app_label\n1113         preserved_filters = self.get_preserved_filters(request)\n1114         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)\n1115         view_on_site_url = self.get_view_on_site_url(obj)\n1116         has_editable_inline_admin_formsets = False\n1117         for inline in context['inline_admin_formsets']:\n1118             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:\n1119                 has_editable_inline_admin_formsets = True\n1120                 break\n1121         context.update({\n1122             'add': add,\n1123             'change': change,\n1124             'has_view_permission': self.has_view_permission(request, obj),\n1125             'has_add_permission': self.has_add_permission(request),\n1126             'has_change_permission': self.has_change_permission(request, obj),\n1127             'has_delete_permission': self.has_delete_permission(request, obj),\n1128             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,\n1129             'has_file_field': context['adminform'].form.is_multipart() or any(\n1130                 admin_formset.formset.is_multipart()\n1131                 for admin_formset in context['inline_admin_formsets']\n1132             ),\n1133             'has_absolute_url': view_on_site_url is not None,\n1134             'absolute_url': view_on_site_url,\n1135             'form_url': form_url,\n1136             'opts': opts,\n1137             'content_type_id': get_content_type_for_model(self.model).pk,\n1138             'save_as': self.save_as,\n1139             'save_on_top': self.save_on_top,\n1140             'to_field_var': TO_FIELD_VAR,\n1141             'is_popup_var': IS_POPUP_VAR,\n1142             'app_label': app_label,\n1143         })\n1144         if add and self.add_form_template is not None:\n1145             form_template = self.add_form_template\n1146         else:\n1147             form_template = self.change_form_template\n1148 \n1149         request.current_app = self.admin_site.name\n1150 \n1151         return TemplateResponse(request, form_template or [\n1152             \"admin/%s/%s/change_form.html\" % (app_label, opts.model_name),\n1153             \"admin/%s/change_form.html\" % app_label,\n1154             \"admin/change_form.html\"\n1155         ], context)\n1156 \n1157     def response_add(self, request, obj, post_url_continue=None):\n1158         \"\"\"\n1159         Determine the HttpResponse for the add_view stage.\n1160         \"\"\"\n1161         opts = obj._meta\n1162         preserved_filters = self.get_preserved_filters(request)\n1163         obj_url = reverse(\n1164             'admin:%s_%s_change' % (opts.app_label, opts.model_name),\n1165             args=(quote(obj.pk),),\n1166             current_app=self.admin_site.name,\n1167         )\n1168         # Add a link to the object's change form if the user can edit the obj.\n1169         if self.has_change_permission(request, obj):\n1170             obj_repr = format_html('<a href=\"{}\">{}</a>', urlquote(obj_url), obj)\n1171         else:\n1172             obj_repr = str(obj)\n1173         msg_dict = {\n1174             'name': opts.verbose_name,\n1175             'obj': obj_repr,\n1176         }\n1177         # Here, we distinguish between different save types by checking for\n1178         # the presence of keys in request.POST.\n1179 \n1180         if IS_POPUP_VAR in request.POST:\n1181             to_field = request.POST.get(TO_FIELD_VAR)\n1182             if to_field:\n1183                 attr = str(to_field)\n1184             else:\n1185                 attr = obj._meta.pk.attname\n1186             value = obj.serializable_value(attr)\n1187             popup_response_data = json.dumps({\n1188                 'value': str(value),\n1189                 'obj': str(obj),\n1190             })\n1191             return TemplateResponse(request, self.popup_response_template or [\n1192                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1193                 'admin/%s/popup_response.html' % opts.app_label,\n1194                 'admin/popup_response.html',\n1195             ], {\n1196                 'popup_response_data': popup_response_data,\n1197             })\n1198 \n1199         elif \"_continue\" in request.POST or (\n1200                 # Redirecting after \"Save as new\".\n1201                 \"_saveasnew\" in request.POST and self.save_as_continue and\n1202                 self.has_change_permission(request, obj)\n1203         ):\n1204             msg = _('The {name} \u201c{obj}\u201d was added successfully.')\n1205             if self.has_change_permission(request, obj):\n1206                 msg += ' ' + _('You may edit it again below.')\n1207             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)\n1208             if post_url_continue is None:\n1209                 post_url_continue = obj_url\n1210             post_url_continue = add_preserved_filters(\n1211                 {'preserved_filters': preserved_filters, 'opts': opts},\n1212                 post_url_continue\n1213             )\n1214             return HttpResponseRedirect(post_url_continue)\n1215 \n1216         elif \"_addanother\" in request.POST:\n1217             msg = format_html(\n1218                 _('The {name} \u201c{obj}\u201d was added successfully. You may add another {name} below.'),\n1219                 **msg_dict\n1220             )\n1221             self.message_user(request, msg, messages.SUCCESS)\n1222             redirect_url = request.path\n1223             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1224             return HttpResponseRedirect(redirect_url)\n1225 \n1226         else:\n1227             msg = format_html(\n1228                 _('The {name} \u201c{obj}\u201d was added successfully.'),\n1229                 **msg_dict\n1230             )\n1231             self.message_user(request, msg, messages.SUCCESS)\n1232             return self.response_post_save_add(request, obj)\n1233 \n1234     def response_change(self, request, obj):\n1235         \"\"\"\n1236         Determine the HttpResponse for the change_view stage.\n1237         \"\"\"\n1238 \n1239         if IS_POPUP_VAR in request.POST:\n1240             opts = obj._meta\n1241             to_field = request.POST.get(TO_FIELD_VAR)\n1242             attr = str(to_field) if to_field else opts.pk.attname\n1243             value = request.resolver_match.kwargs['object_id']\n1244             new_value = obj.serializable_value(attr)\n1245             popup_response_data = json.dumps({\n1246                 'action': 'change',\n1247                 'value': str(value),\n1248                 'obj': str(obj),\n1249                 'new_value': str(new_value),\n1250             })\n1251             return TemplateResponse(request, self.popup_response_template or [\n1252                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1253                 'admin/%s/popup_response.html' % opts.app_label,\n1254                 'admin/popup_response.html',\n1255             ], {\n1256                 'popup_response_data': popup_response_data,\n1257             })\n1258 \n1259         opts = self.model._meta\n1260         preserved_filters = self.get_preserved_filters(request)\n1261 \n1262         msg_dict = {\n1263             'name': opts.verbose_name,\n1264             'obj': format_html('<a href=\"{}\">{}</a>', urlquote(request.path), obj),\n1265         }\n1266         if \"_continue\" in request.POST:\n1267             msg = format_html(\n1268                 _('The {name} \u201c{obj}\u201d was changed successfully. You may edit it again below.'),\n1269                 **msg_dict\n1270             )\n1271             self.message_user(request, msg, messages.SUCCESS)\n1272             redirect_url = request.path\n1273             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1274             return HttpResponseRedirect(redirect_url)\n1275 \n1276         elif \"_saveasnew\" in request.POST:\n1277             msg = format_html(\n1278                 _('The {name} \u201c{obj}\u201d was added successfully. You may edit it again below.'),\n1279                 **msg_dict\n1280             )\n1281             self.message_user(request, msg, messages.SUCCESS)\n1282             redirect_url = reverse('admin:%s_%s_change' %\n1283                                    (opts.app_label, opts.model_name),\n1284                                    args=(obj.pk,),\n1285                                    current_app=self.admin_site.name)\n1286             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1287             return HttpResponseRedirect(redirect_url)\n1288 \n1289         elif \"_addanother\" in request.POST:\n1290             msg = format_html(\n1291                 _('The {name} \u201c{obj}\u201d was changed successfully. You may add another {name} below.'),\n1292                 **msg_dict\n1293             )\n1294             self.message_user(request, msg, messages.SUCCESS)\n1295             redirect_url = reverse('admin:%s_%s_add' %\n1296                                    (opts.app_label, opts.model_name),\n1297                                    current_app=self.admin_site.name)\n1298             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1299             return HttpResponseRedirect(redirect_url)\n1300 \n1301         else:\n1302             msg = format_html(\n1303                 _('The {name} \u201c{obj}\u201d was changed successfully.'),\n1304                 **msg_dict\n1305             )\n1306             self.message_user(request, msg, messages.SUCCESS)\n1307             return self.response_post_save_change(request, obj)\n1308 \n1309     def _response_post_save(self, request, obj):\n1310         opts = self.model._meta\n1311         if self.has_view_or_change_permission(request):\n1312             post_url = reverse('admin:%s_%s_changelist' %\n1313                                (opts.app_label, opts.model_name),\n1314                                current_app=self.admin_site.name)\n1315             preserved_filters = self.get_preserved_filters(request)\n1316             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)\n1317         else:\n1318             post_url = reverse('admin:index',\n1319                                current_app=self.admin_site.name)\n1320         return HttpResponseRedirect(post_url)\n1321 \n1322     def response_post_save_add(self, request, obj):\n1323         \"\"\"\n1324         Figure out where to redirect after the 'Save' button has been pressed\n1325         when adding a new object.\n1326         \"\"\"\n1327         return self._response_post_save(request, obj)\n1328 \n1329     def response_post_save_change(self, request, obj):\n1330         \"\"\"\n1331         Figure out where to redirect after the 'Save' button has been pressed\n1332         when editing an existing object.\n1333         \"\"\"\n1334         return self._response_post_save(request, obj)\n1335 \n1336     def response_action(self, request, queryset):\n1337         \"\"\"\n1338         Handle an admin action. This is called if a request is POSTed to the\n1339         changelist; it returns an HttpResponse if the action was handled, and\n1340         None otherwise.\n1341         \"\"\"\n1342 \n1343         # There can be multiple action forms on the page (at the top\n1344         # and bottom of the change list, for example). Get the action\n1345         # whose button was pushed.\n1346         try:\n1347             action_index = int(request.POST.get('index', 0))\n1348         except ValueError:\n1349             action_index = 0\n1350 \n1351         # Construct the action form.\n1352         data = request.POST.copy()\n1353         data.pop(helpers.ACTION_CHECKBOX_NAME, None)\n1354         data.pop(\"index\", None)\n1355 \n1356         # Use the action whose button was pushed\n1357         try:\n1358             data.update({'action': data.getlist('action')[action_index]})\n1359         except IndexError:\n1360             # If we didn't get an action from the chosen form that's invalid\n1361             # POST data, so by deleting action it'll fail the validation check\n1362             # below. So no need to do anything here\n1363             pass\n1364 \n1365         action_form = self.action_form(data, auto_id=None)\n1366         action_form.fields['action'].choices = self.get_action_choices(request)\n1367 \n1368         # If the form's valid we can handle the action.\n1369         if action_form.is_valid():\n1370             action = action_form.cleaned_data['action']\n1371             select_across = action_form.cleaned_data['select_across']\n1372             func = self.get_actions(request)[action][0]\n1373 \n1374             # Get the list of selected PKs. If nothing's selected, we can't\n1375             # perform an action on it, so bail. Except we want to perform\n1376             # the action explicitly on all objects.\n1377             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1378             if not selected and not select_across:\n1379                 # Reminder that something needs to be selected or nothing will happen\n1380                 msg = _(\"Items must be selected in order to perform \"\n1381                         \"actions on them. No items have been changed.\")\n1382                 self.message_user(request, msg, messages.WARNING)\n1383                 return None\n1384 \n1385             if not select_across:\n1386                 # Perform the action only on the selected objects\n1387                 queryset = queryset.filter(pk__in=selected)\n1388 \n1389             response = func(self, request, queryset)\n1390 \n1391             # Actions may return an HttpResponse-like object, which will be\n1392             # used as the response from the POST. If not, we'll be a good\n1393             # little HTTP citizen and redirect back to the changelist page.\n1394             if isinstance(response, HttpResponseBase):\n1395                 return response\n1396             else:\n1397                 return HttpResponseRedirect(request.get_full_path())\n1398         else:\n1399             msg = _(\"No action selected.\")\n1400             self.message_user(request, msg, messages.WARNING)\n1401             return None\n1402 \n1403     def response_delete(self, request, obj_display, obj_id):\n1404         \"\"\"\n1405         Determine the HttpResponse for the delete_view stage.\n1406         \"\"\"\n1407         opts = self.model._meta\n1408 \n1409         if IS_POPUP_VAR in request.POST:\n1410             popup_response_data = json.dumps({\n1411                 'action': 'delete',\n1412                 'value': str(obj_id),\n1413             })\n1414             return TemplateResponse(request, self.popup_response_template or [\n1415                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1416                 'admin/%s/popup_response.html' % opts.app_label,\n1417                 'admin/popup_response.html',\n1418             ], {\n1419                 'popup_response_data': popup_response_data,\n1420             })\n1421 \n1422         self.message_user(\n1423             request,\n1424             _('The %(name)s \u201c%(obj)s\u201d was deleted successfully.') % {\n1425                 'name': opts.verbose_name,\n1426                 'obj': obj_display,\n1427             },\n1428             messages.SUCCESS,\n1429         )\n1430 \n1431         if self.has_change_permission(request, None):\n1432             post_url = reverse(\n1433                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),\n1434                 current_app=self.admin_site.name,\n1435             )\n1436             preserved_filters = self.get_preserved_filters(request)\n1437             post_url = add_preserved_filters(\n1438                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url\n1439             )\n1440         else:\n1441             post_url = reverse('admin:index', current_app=self.admin_site.name)\n1442         return HttpResponseRedirect(post_url)\n1443 \n1444     def render_delete_form(self, request, context):\n1445         opts = self.model._meta\n1446         app_label = opts.app_label\n1447 \n1448         request.current_app = self.admin_site.name\n1449         context.update(\n1450             to_field_var=TO_FIELD_VAR,\n1451             is_popup_var=IS_POPUP_VAR,\n1452             media=self.media,\n1453         )\n1454 \n1455         return TemplateResponse(\n1456             request,\n1457             self.delete_confirmation_template or [\n1458                 \"admin/{}/{}/delete_confirmation.html\".format(app_label, opts.model_name),\n1459                 \"admin/{}/delete_confirmation.html\".format(app_label),\n1460                 \"admin/delete_confirmation.html\",\n1461             ],\n1462             context,\n1463         )\n1464 \n1465     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):\n1466         # Edit permissions on parent model are required for editable inlines.\n1467         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)\n1468         inline_admin_formsets = []\n1469         for inline, formset in zip(inline_instances, formsets):\n1470             fieldsets = list(inline.get_fieldsets(request, obj))\n1471             readonly = list(inline.get_readonly_fields(request, obj))\n1472             if can_edit_parent:\n1473                 has_add_permission = inline.has_add_permission(request, obj)\n1474                 has_change_permission = inline.has_change_permission(request, obj)\n1475                 has_delete_permission = inline.has_delete_permission(request, obj)\n1476             else:\n1477                 # Disable all edit-permissions, and overide formset settings.\n1478                 has_add_permission = has_change_permission = has_delete_permission = False\n1479                 formset.extra = formset.max_num = 0\n1480             has_view_permission = inline.has_view_permission(request, obj)\n1481             prepopulated = dict(inline.get_prepopulated_fields(request, obj))\n1482             inline_admin_formset = helpers.InlineAdminFormSet(\n1483                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,\n1484                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,\n1485                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,\n1486             )\n1487             inline_admin_formsets.append(inline_admin_formset)\n1488         return inline_admin_formsets\n1489 \n1490     def get_changeform_initial_data(self, request):\n1491         \"\"\"\n1492         Get the initial form data from the request's GET params.\n1493         \"\"\"\n1494         initial = dict(request.GET.items())\n1495         for k in initial:\n1496             try:\n1497                 f = self.model._meta.get_field(k)\n1498             except FieldDoesNotExist:\n1499                 continue\n1500             # We have to special-case M2Ms as a list of comma-separated PKs.\n1501             if isinstance(f, models.ManyToManyField):\n1502                 initial[k] = initial[k].split(\",\")\n1503         return initial\n1504 \n1505     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):\n1506         \"\"\"\n1507         Create a message informing the user that the object doesn't exist\n1508         and return a redirect to the admin index page.\n1509         \"\"\"\n1510         msg = _('%(name)s with ID \u201c%(key)s\u201d doesn\u2019t exist. Perhaps it was deleted?') % {\n1511             'name': opts.verbose_name,\n1512             'key': unquote(object_id),\n1513         }\n1514         self.message_user(request, msg, messages.WARNING)\n1515         url = reverse('admin:index', current_app=self.admin_site.name)\n1516         return HttpResponseRedirect(url)\n1517 \n1518     @csrf_protect_m\n1519     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):\n1520         with transaction.atomic(using=router.db_for_write(self.model)):\n1521             return self._changeform_view(request, object_id, form_url, extra_context)\n1522 \n1523     def _changeform_view(self, request, object_id, form_url, extra_context):\n1524         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1525         if to_field and not self.to_field_allowed(request, to_field):\n1526             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1527 \n1528         model = self.model\n1529         opts = model._meta\n1530 \n1531         if request.method == 'POST' and '_saveasnew' in request.POST:\n1532             object_id = None\n1533 \n1534         add = object_id is None\n1535 \n1536         if add:\n1537             if not self.has_add_permission(request):\n1538                 raise PermissionDenied\n1539             obj = None\n1540 \n1541         else:\n1542             obj = self.get_object(request, unquote(object_id), to_field)\n1543 \n1544             if request.method == 'POST':\n1545                 if not self.has_change_permission(request, obj):\n1546                     raise PermissionDenied\n1547             else:\n1548                 if not self.has_view_or_change_permission(request, obj):\n1549                     raise PermissionDenied\n1550 \n1551             if obj is None:\n1552                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1553 \n1554         fieldsets = self.get_fieldsets(request, obj)\n1555         ModelForm = self.get_form(\n1556             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)\n1557         )\n1558         if request.method == 'POST':\n1559             form = ModelForm(request.POST, request.FILES, instance=obj)\n1560             form_validated = form.is_valid()\n1561             if form_validated:\n1562                 new_object = self.save_form(request, form, change=not add)\n1563             else:\n1564                 new_object = form.instance\n1565             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)\n1566             if all_valid(formsets) and form_validated:\n1567                 self.save_model(request, new_object, form, not add)\n1568                 self.save_related(request, form, formsets, not add)\n1569                 change_message = self.construct_change_message(request, form, formsets, add)\n1570                 if add:\n1571                     self.log_addition(request, new_object, change_message)\n1572                     return self.response_add(request, new_object)\n1573                 else:\n1574                     self.log_change(request, new_object, change_message)\n1575                     return self.response_change(request, new_object)\n1576             else:\n1577                 form_validated = False\n1578         else:\n1579             if add:\n1580                 initial = self.get_changeform_initial_data(request)\n1581                 form = ModelForm(initial=initial)\n1582                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)\n1583             else:\n1584                 form = ModelForm(instance=obj)\n1585                 formsets, inline_instances = self._create_formsets(request, obj, change=True)\n1586 \n1587         if not add and not self.has_change_permission(request, obj):\n1588             readonly_fields = flatten_fieldsets(fieldsets)\n1589         else:\n1590             readonly_fields = self.get_readonly_fields(request, obj)\n1591         adminForm = helpers.AdminForm(\n1592             form,\n1593             list(fieldsets),\n1594             # Clear prepopulated fields on a view-only form to avoid a crash.\n1595             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},\n1596             readonly_fields,\n1597             model_admin=self)\n1598         media = self.media + adminForm.media\n1599 \n1600         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)\n1601         for inline_formset in inline_formsets:\n1602             media = media + inline_formset.media\n1603 \n1604         if add:\n1605             title = _('Add %s')\n1606         elif self.has_change_permission(request, obj):\n1607             title = _('Change %s')\n1608         else:\n1609             title = _('View %s')\n1610         context = {\n1611             **self.admin_site.each_context(request),\n1612             'title': title % opts.verbose_name,\n1613             'adminform': adminForm,\n1614             'object_id': object_id,\n1615             'original': obj,\n1616             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1617             'to_field': to_field,\n1618             'media': media,\n1619             'inline_admin_formsets': inline_formsets,\n1620             'errors': helpers.AdminErrorList(form, formsets),\n1621             'preserved_filters': self.get_preserved_filters(request),\n1622         }\n1623 \n1624         # Hide the \"Save\" and \"Save and continue\" buttons if \"Save as New\" was\n1625         # previously chosen to prevent the interface from getting confusing.\n1626         if request.method == 'POST' and not form_validated and \"_saveasnew\" in request.POST:\n1627             context['show_save'] = False\n1628             context['show_save_and_continue'] = False\n1629             # Use the change template instead of the add template.\n1630             add = False\n1631 \n1632         context.update(extra_context or {})\n1633 \n1634         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)\n1635 \n1636     def autocomplete_view(self, request):\n1637         return AutocompleteJsonView.as_view(model_admin=self)(request)\n1638 \n1639     def add_view(self, request, form_url='', extra_context=None):\n1640         return self.changeform_view(request, None, form_url, extra_context)\n1641 \n1642     def change_view(self, request, object_id, form_url='', extra_context=None):\n1643         return self.changeform_view(request, object_id, form_url, extra_context)\n1644 \n1645     def _get_edited_object_pks(self, request, prefix):\n1646         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n1647         pk_pattern = re.compile(\n1648             r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)\n1649         )\n1650         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n1651 \n1652     def _get_list_editable_queryset(self, request, prefix):\n1653         \"\"\"\n1654         Based on POST data, return a queryset of the objects that were edited\n1655         via list_editable.\n1656         \"\"\"\n1657         object_pks = self._get_edited_object_pks(request, prefix)\n1658         queryset = self.get_queryset(request)\n1659         validate = queryset.model._meta.pk.to_python\n1660         try:\n1661             for pk in object_pks:\n1662                 validate(pk)\n1663         except ValidationError:\n1664             # Disable the optimization if the POST data was tampered with.\n1665             return queryset\n1666         return queryset.filter(pk__in=object_pks)\n1667 \n1668     @csrf_protect_m\n1669     def changelist_view(self, request, extra_context=None):\n1670         \"\"\"\n1671         The 'change list' admin view for this model.\n1672         \"\"\"\n1673         from django.contrib.admin.views.main import ERROR_FLAG\n1674         opts = self.model._meta\n1675         app_label = opts.app_label\n1676         if not self.has_view_or_change_permission(request):\n1677             raise PermissionDenied\n1678 \n1679         try:\n1680             cl = self.get_changelist_instance(request)\n1681         except IncorrectLookupParameters:\n1682             # Wacky lookup parameters were given, so redirect to the main\n1683             # changelist page, without parameters, and pass an 'invalid=1'\n1684             # parameter via the query string. If wacky parameters were given\n1685             # and the 'invalid=1' parameter was already in the query string,\n1686             # something is screwed up with the database, so display an error\n1687             # page.\n1688             if ERROR_FLAG in request.GET:\n1689                 return SimpleTemplateResponse('admin/invalid_setup.html', {\n1690                     'title': _('Database error'),\n1691                 })\n1692             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')\n1693 \n1694         # If the request was POSTed, this might be a bulk action or a bulk\n1695         # edit. Try to look up an action or confirmation first, but if this\n1696         # isn't an action the POST will fall through to the bulk edit check,\n1697         # below.\n1698         action_failed = False\n1699         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1700 \n1701         actions = self.get_actions(request)\n1702         # Actions with no confirmation\n1703         if (actions and request.method == 'POST' and\n1704                 'index' in request.POST and '_save' not in request.POST):\n1705             if selected:\n1706                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1707                 if response:\n1708                     return response\n1709                 else:\n1710                     action_failed = True\n1711             else:\n1712                 msg = _(\"Items must be selected in order to perform \"\n1713                         \"actions on them. No items have been changed.\")\n1714                 self.message_user(request, msg, messages.WARNING)\n1715                 action_failed = True\n1716 \n1717         # Actions with confirmation\n1718         if (actions and request.method == 'POST' and\n1719                 helpers.ACTION_CHECKBOX_NAME in request.POST and\n1720                 'index' not in request.POST and '_save' not in request.POST):\n1721             if selected:\n1722                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1723                 if response:\n1724                     return response\n1725                 else:\n1726                     action_failed = True\n1727 \n1728         if action_failed:\n1729             # Redirect back to the changelist page to avoid resubmitting the\n1730             # form if the user refreshes the browser or uses the \"No, take\n1731             # me back\" button on the action confirmation page.\n1732             return HttpResponseRedirect(request.get_full_path())\n1733 \n1734         # If we're allowing changelist editing, we need to construct a formset\n1735         # for the changelist given all the fields to be edited. Then we'll\n1736         # use the formset to validate/process POSTed data.\n1737         formset = cl.formset = None\n1738 \n1739         # Handle POSTed bulk-edit data.\n1740         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:\n1741             if not self.has_change_permission(request):\n1742                 raise PermissionDenied\n1743             FormSet = self.get_changelist_formset(request)\n1744             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())\n1745             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)\n1746             if formset.is_valid():\n1747                 changecount = 0\n1748                 for form in formset.forms:\n1749                     if form.has_changed():\n1750                         obj = self.save_form(request, form, change=True)\n1751                         self.save_model(request, obj, form, change=True)\n1752                         self.save_related(request, form, formsets=[], change=True)\n1753                         change_msg = self.construct_change_message(request, form, None)\n1754                         self.log_change(request, obj, change_msg)\n1755                         changecount += 1\n1756 \n1757                 if changecount:\n1758                     msg = ngettext(\n1759                         \"%(count)s %(name)s was changed successfully.\",\n1760                         \"%(count)s %(name)s were changed successfully.\",\n1761                         changecount\n1762                     ) % {\n1763                         'count': changecount,\n1764                         'name': model_ngettext(opts, changecount),\n1765                     }\n1766                     self.message_user(request, msg, messages.SUCCESS)\n1767 \n1768                 return HttpResponseRedirect(request.get_full_path())\n1769 \n1770         # Handle GET -- construct a formset for display.\n1771         elif cl.list_editable and self.has_change_permission(request):\n1772             FormSet = self.get_changelist_formset(request)\n1773             formset = cl.formset = FormSet(queryset=cl.result_list)\n1774 \n1775         # Build the list of media to be used by the formset.\n1776         if formset:\n1777             media = self.media + formset.media\n1778         else:\n1779             media = self.media\n1780 \n1781         # Build the action form and populate it with available actions.\n1782         if actions:\n1783             action_form = self.action_form(auto_id=None)\n1784             action_form.fields['action'].choices = self.get_action_choices(request)\n1785             media += action_form.media\n1786         else:\n1787             action_form = None\n1788 \n1789         selection_note_all = ngettext(\n1790             '%(total_count)s selected',\n1791             'All %(total_count)s selected',\n1792             cl.result_count\n1793         )\n1794 \n1795         context = {\n1796             **self.admin_site.each_context(request),\n1797             'module_name': str(opts.verbose_name_plural),\n1798             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},\n1799             'selection_note_all': selection_note_all % {'total_count': cl.result_count},\n1800             'title': cl.title,\n1801             'is_popup': cl.is_popup,\n1802             'to_field': cl.to_field,\n1803             'cl': cl,\n1804             'media': media,\n1805             'has_add_permission': self.has_add_permission(request),\n1806             'opts': cl.opts,\n1807             'action_form': action_form,\n1808             'actions_on_top': self.actions_on_top,\n1809             'actions_on_bottom': self.actions_on_bottom,\n1810             'actions_selection_counter': self.actions_selection_counter,\n1811             'preserved_filters': self.get_preserved_filters(request),\n1812             **(extra_context or {}),\n1813         }\n1814 \n1815         request.current_app = self.admin_site.name\n1816 \n1817         return TemplateResponse(request, self.change_list_template or [\n1818             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),\n1819             'admin/%s/change_list.html' % app_label,\n1820             'admin/change_list.html'\n1821         ], context)\n1822 \n1823     def get_deleted_objects(self, objs, request):\n1824         \"\"\"\n1825         Hook for customizing the delete process for the delete view and the\n1826         \"delete selected\" action.\n1827         \"\"\"\n1828         return get_deleted_objects(objs, request, self.admin_site)\n1829 \n1830     @csrf_protect_m\n1831     def delete_view(self, request, object_id, extra_context=None):\n1832         with transaction.atomic(using=router.db_for_write(self.model)):\n1833             return self._delete_view(request, object_id, extra_context)\n1834 \n1835     def _delete_view(self, request, object_id, extra_context):\n1836         \"The 'delete' admin view for this model.\"\n1837         opts = self.model._meta\n1838         app_label = opts.app_label\n1839 \n1840         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1841         if to_field and not self.to_field_allowed(request, to_field):\n1842             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1843 \n1844         obj = self.get_object(request, unquote(object_id), to_field)\n1845 \n1846         if not self.has_delete_permission(request, obj):\n1847             raise PermissionDenied\n1848 \n1849         if obj is None:\n1850             return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1851 \n1852         # Populate deleted_objects, a data structure of all related objects that\n1853         # will also be deleted.\n1854         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)\n1855 \n1856         if request.POST and not protected:  # The user has confirmed the deletion.\n1857             if perms_needed:\n1858                 raise PermissionDenied\n1859             obj_display = str(obj)\n1860             attr = str(to_field) if to_field else opts.pk.attname\n1861             obj_id = obj.serializable_value(attr)\n1862             self.log_deletion(request, obj, obj_display)\n1863             self.delete_model(request, obj)\n1864 \n1865             return self.response_delete(request, obj_display, obj_id)\n1866 \n1867         object_name = str(opts.verbose_name)\n1868 \n1869         if perms_needed or protected:\n1870             title = _(\"Cannot delete %(name)s\") % {\"name\": object_name}\n1871         else:\n1872             title = _(\"Are you sure?\")\n1873 \n1874         context = {\n1875             **self.admin_site.each_context(request),\n1876             'title': title,\n1877             'object_name': object_name,\n1878             'object': obj,\n1879             'deleted_objects': deleted_objects,\n1880             'model_count': dict(model_count).items(),\n1881             'perms_lacking': perms_needed,\n1882             'protected': protected,\n1883             'opts': opts,\n1884             'app_label': app_label,\n1885             'preserved_filters': self.get_preserved_filters(request),\n1886             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1887             'to_field': to_field,\n1888             **(extra_context or {}),\n1889         }\n1890 \n1891         return self.render_delete_form(request, context)\n1892 \n1893     def history_view(self, request, object_id, extra_context=None):\n1894         \"The 'history' admin view for this model.\"\n1895         from django.contrib.admin.models import LogEntry\n1896         # First check if the user can see this history.\n1897         model = self.model\n1898         obj = self.get_object(request, unquote(object_id))\n1899         if obj is None:\n1900             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)\n1901 \n1902         if not self.has_view_or_change_permission(request, obj):\n1903             raise PermissionDenied\n1904 \n1905         # Then get the history for this object.\n1906         opts = model._meta\n1907         app_label = opts.app_label\n1908         action_list = LogEntry.objects.filter(\n1909             object_id=unquote(object_id),\n1910             content_type=get_content_type_for_model(model)\n1911         ).select_related().order_by('action_time')\n1912 \n1913         context = {\n1914             **self.admin_site.each_context(request),\n1915             'title': _('Change history: %s') % obj,\n1916             'action_list': action_list,\n1917             'module_name': str(capfirst(opts.verbose_name_plural)),\n1918             'object': obj,\n1919             'opts': opts,\n1920             'preserved_filters': self.get_preserved_filters(request),\n1921             **(extra_context or {}),\n1922         }\n1923 \n1924         request.current_app = self.admin_site.name\n1925 \n1926         return TemplateResponse(request, self.object_history_template or [\n1927             \"admin/%s/%s/object_history.html\" % (app_label, opts.model_name),\n1928             \"admin/%s/object_history.html\" % app_label,\n1929             \"admin/object_history.html\"\n1930         ], context)\n1931 \n1932     def _create_formsets(self, request, obj, change):\n1933         \"Helper function to generate formsets for add/change_view.\"\n1934         formsets = []\n1935         inline_instances = []\n1936         prefixes = {}\n1937         get_formsets_args = [request]\n1938         if change:\n1939             get_formsets_args.append(obj)\n1940         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n1941             prefix = FormSet.get_default_prefix()\n1942             prefixes[prefix] = prefixes.get(prefix, 0) + 1\n1943             if prefixes[prefix] != 1 or not prefix:\n1944                 prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n1945             formset_params = {\n1946                 'instance': obj,\n1947                 'prefix': prefix,\n1948                 'queryset': inline.get_queryset(request),\n1949             }\n1950             if request.method == 'POST':\n1951                 formset_params.update({\n1952                     'data': request.POST.copy(),\n1953                     'files': request.FILES,\n1954                     'save_as_new': '_saveasnew' in request.POST\n1955                 })\n1956             formset = FormSet(**formset_params)\n1957 \n1958             def user_deleted_form(request, obj, formset, index):\n1959                 \"\"\"Return whether or not the user deleted the form.\"\"\"\n1960                 return (\n1961                     inline.has_delete_permission(request, obj) and\n1962                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST\n1963                 )\n1964 \n1965             # Bypass validation of each view-only inline form (since the form's\n1966             # data won't be in request.POST), unless the form was deleted.\n1967             if not inline.has_change_permission(request, obj if change else None):\n1968                 for index, form in enumerate(formset.initial_forms):\n1969                     if user_deleted_form(request, obj, formset, index):\n1970                         continue\n1971                     form._errors = {}\n1972                     form.cleaned_data = form.initial\n1973             formsets.append(formset)\n1974             inline_instances.append(inline)\n1975         return formsets, inline_instances\n1976 \n1977 \n1978 class InlineModelAdmin(BaseModelAdmin):\n1979     \"\"\"\n1980     Options for inline editing of ``model`` instances.\n1981 \n1982     Provide ``fk_name`` to specify the attribute name of the ``ForeignKey``\n1983     from ``model`` to its parent. This is required if ``model`` has more than\n1984     one ``ForeignKey`` to its parent.\n1985     \"\"\"\n1986     model = None\n1987     fk_name = None\n1988     formset = BaseInlineFormSet\n1989     extra = 3\n1990     min_num = None\n1991     max_num = None\n1992     template = None\n1993     verbose_name = None\n1994     verbose_name_plural = None\n1995     can_delete = True\n1996     show_change_link = False\n1997     checks_class = InlineModelAdminChecks\n1998     classes = None\n1999 \n2000     def __init__(self, parent_model, admin_site):\n2001         self.admin_site = admin_site\n2002         self.parent_model = parent_model\n2003         self.opts = self.model._meta\n2004         self.has_registered_model = admin_site.is_registered(self.model)\n2005         super().__init__()\n2006         if self.verbose_name is None:\n2007             self.verbose_name = self.model._meta.verbose_name\n2008         if self.verbose_name_plural is None:\n2009             self.verbose_name_plural = self.model._meta.verbose_name_plural\n2010 \n2011     @property\n2012     def media(self):\n2013         extra = '' if settings.DEBUG else '.min'\n2014         js = ['vendor/jquery/jquery%s.js' % extra, 'jquery.init.js',\n2015               'inlines%s.js' % extra]\n2016         if self.filter_vertical or self.filter_horizontal:\n2017             js.extend(['SelectBox.js', 'SelectFilter2.js'])\n2018         if self.classes and 'collapse' in self.classes:\n2019             js.append('collapse%s.js' % extra)\n2020         return forms.Media(js=['admin/js/%s' % url for url in js])\n2021 \n2022     def get_extra(self, request, obj=None, **kwargs):\n2023         \"\"\"Hook for customizing the number of extra inline forms.\"\"\"\n2024         return self.extra\n2025 \n2026     def get_min_num(self, request, obj=None, **kwargs):\n2027         \"\"\"Hook for customizing the min number of inline forms.\"\"\"\n2028         return self.min_num\n2029 \n2030     def get_max_num(self, request, obj=None, **kwargs):\n2031         \"\"\"Hook for customizing the max number of extra inline forms.\"\"\"\n2032         return self.max_num\n2033 \n2034     def get_formset(self, request, obj=None, **kwargs):\n2035         \"\"\"Return a BaseInlineFormSet class for use in admin add/change views.\"\"\"\n2036         if 'fields' in kwargs:\n2037             fields = kwargs.pop('fields')\n2038         else:\n2039             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n2040         excluded = self.get_exclude(request, obj)\n2041         exclude = [] if excluded is None else list(excluded)\n2042         exclude.extend(self.get_readonly_fields(request, obj))\n2043         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n2044             # Take the custom ModelForm's Meta.exclude into account only if the\n2045             # InlineModelAdmin doesn't define its own.\n2046             exclude.extend(self.form._meta.exclude)\n2047         # If exclude is an empty list we use None, since that's the actual\n2048         # default.\n2049         exclude = exclude or None\n2050         can_delete = self.can_delete and self.has_delete_permission(request, obj)\n2051         defaults = {\n2052             'form': self.form,\n2053             'formset': self.formset,\n2054             'fk_name': self.fk_name,\n2055             'fields': fields,\n2056             'exclude': exclude,\n2057             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n2058             'extra': self.get_extra(request, obj, **kwargs),\n2059             'min_num': self.get_min_num(request, obj, **kwargs),\n2060             'max_num': self.get_max_num(request, obj, **kwargs),\n2061             'can_delete': can_delete,\n2062             **kwargs,\n2063         }\n2064 \n2065         base_model_form = defaults['form']\n2066         can_change = self.has_change_permission(request, obj) if request else True\n2067         can_add = self.has_add_permission(request, obj) if request else True\n2068 \n2069         class DeleteProtectedModelForm(base_model_form):\n2070 \n2071             def hand_clean_DELETE(self):\n2072                 \"\"\"\n2073                 We don't validate the 'DELETE' field itself because on\n2074                 templates it's not rendered using the field information, but\n2075                 just using a generic \"deletion_field\" of the InlineModelAdmin.\n2076                 \"\"\"\n2077                 if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n2078                     using = router.db_for_write(self._meta.model)\n2079                     collector = NestedObjects(using=using)\n2080                     if self.instance._state.adding:\n2081                         return\n2082                     collector.collect([self.instance])\n2083                     if collector.protected:\n2084                         objs = []\n2085                         for p in collector.protected:\n2086                             objs.append(\n2087                                 # Translators: Model verbose name and instance representation,\n2088                                 # suitable to be an item in a list.\n2089                                 _('%(class_name)s %(instance)s') % {\n2090                                     'class_name': p._meta.verbose_name,\n2091                                     'instance': p}\n2092                             )\n2093                         params = {\n2094                             'class_name': self._meta.model._meta.verbose_name,\n2095                             'instance': self.instance,\n2096                             'related_objects': get_text_list(objs, _('and')),\n2097                         }\n2098                         msg = _(\"Deleting %(class_name)s %(instance)s would require \"\n2099                                 \"deleting the following protected related objects: \"\n2100                                 \"%(related_objects)s\")\n2101                         raise ValidationError(msg, code='deleting_protected', params=params)\n2102 \n2103             def is_valid(self):\n2104                 result = super().is_valid()\n2105                 self.hand_clean_DELETE()\n2106                 return result\n2107 \n2108             def has_changed(self):\n2109                 # Protect against unauthorized edits.\n2110                 if not can_change and not self.instance._state.adding:\n2111                     return False\n2112                 if not can_add and self.instance._state.adding:\n2113                     return False\n2114                 return super().has_changed()\n2115 \n2116         defaults['form'] = DeleteProtectedModelForm\n2117 \n2118         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n2119             defaults['fields'] = forms.ALL_FIELDS\n2120 \n2121         return inlineformset_factory(self.parent_model, self.model, **defaults)\n2122 \n2123     def _get_form_for_get_fields(self, request, obj=None):\n2124         return self.get_formset(request, obj, fields=None).form\n2125 \n2126     def get_queryset(self, request):\n2127         queryset = super().get_queryset(request)\n2128         if not self.has_view_or_change_permission(request):\n2129             queryset = queryset.none()\n2130         return queryset\n2131 \n2132     def _has_any_perms_for_target_model(self, request, perms):\n2133         \"\"\"\n2134         This method is called only when the ModelAdmin's model is for an\n2135         ManyToManyField's implicit through model (if self.opts.auto_created).\n2136         Return True if the user has any of the given permissions ('add',\n2137         'change', etc.) for the model that points to the through model.\n2138         \"\"\"\n2139         opts = self.opts\n2140         # Find the target model of an auto-created many-to-many relationship.\n2141         for field in opts.fields:\n2142             if field.remote_field and field.remote_field.model != self.parent_model:\n2143                 opts = field.remote_field.model._meta\n2144                 break\n2145         return any(\n2146             request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename(perm, opts)))\n2147             for perm in perms\n2148         )\n2149 \n2150     def has_add_permission(self, request, obj):\n2151         if self.opts.auto_created:\n2152             # Auto-created intermediate models don't have their own\n2153             # permissions. The user needs to have the change permission for the\n2154             # related model in order to be able to do anything with the\n2155             # intermediate model.\n2156             return self._has_any_perms_for_target_model(request, ['change'])\n2157         return super().has_add_permission(request)\n2158 \n2159     def has_change_permission(self, request, obj=None):\n2160         if self.opts.auto_created:\n2161             # Same comment as has_add_permission().\n2162             return self._has_any_perms_for_target_model(request, ['change'])\n2163         return super().has_change_permission(request)\n2164 \n2165     def has_delete_permission(self, request, obj=None):\n2166         if self.opts.auto_created:\n2167             # Same comment as has_add_permission().\n2168             return self._has_any_perms_for_target_model(request, ['change'])\n2169         return super().has_delete_permission(request, obj)\n2170 \n2171     def has_view_permission(self, request, obj=None):\n2172         if self.opts.auto_created:\n2173             # Same comment as has_add_permission(). The 'change' permission\n2174             # also implies the 'view' permission.\n2175             return self._has_any_perms_for_target_model(request, ['view', 'change'])\n2176         return super().has_view_permission(request)\n2177 \n2178 \n2179 class StackedInline(InlineModelAdmin):\n2180     template = 'admin/edit_inline/stacked.html'\n2181 \n2182 \n2183 class TabularInline(InlineModelAdmin):\n2184     template = 'admin/edit_inline/tabular.html'\n",
        "intended_behavior": "The intended behavior would be ensuring any date range definitions or uses within this context properly account for user-specific timezones. This might involve ensuring that all datetime values used in conjunction with `date_hierarchy` are timezone-aware and correctly adjusted to the user's timezone before being used to filter models or displayed in the UI."
    }
]