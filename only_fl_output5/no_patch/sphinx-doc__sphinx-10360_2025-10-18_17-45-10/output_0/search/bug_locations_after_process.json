[
    {
        "rel_file_path": "sphinx/util/cfamily.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/util/cfamily.py",
        "start": 1,
        "end": 427,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Utility functions common to the C and C++ domains.\"\"\"\n2 \n3 import re\n4 from copy import deepcopy\n5 from typing import Any, Callable, List, Match, Optional, Pattern, Tuple, Union\n6 \n7 from docutils import nodes\n8 from docutils.nodes import TextElement\n9 \n10 from sphinx import addnodes\n11 from sphinx.config import Config\n12 from sphinx.util import logging\n13 \n14 logger = logging.getLogger(__name__)\n15 \n16 StringifyTransform = Callable[[Any], str]\n17 \n18 \n19 _whitespace_re = re.compile(r'(?u)\\s+')\n20 anon_identifier_re = re.compile(r'(@[a-zA-Z0-9_])[a-zA-Z0-9_]*\\b')\n21 identifier_re = re.compile(r'''(?x)\n22     (   # This 'extends' _anon_identifier_re with the ordinary identifiers,\n23         # make sure they are in sync.\n24         (~?\\b[a-zA-Z_])  # ordinary identifiers\n25     |   (@[a-zA-Z0-9_])  # our extension for names of anonymous entities\n26     )\n27     [a-zA-Z0-9_]*\\b\n28 ''')\n29 integer_literal_re = re.compile(r'[1-9][0-9]*(\\'[0-9]+)*')\n30 octal_literal_re = re.compile(r'0[0-7]*(\\'[0-7]+)*')\n31 hex_literal_re = re.compile(r'0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*')\n32 binary_literal_re = re.compile(r'0[bB][01]+(\\'[01]+)*')\n33 integers_literal_suffix_re = re.compile(r'''(?x)\n34     # unsigned and/or (long) long, in any order, but at least one of them\n35     (\n36         ([uU]    ([lL]  |  (ll)  |  (LL))?)\n37         |\n38         (([lL]  |  (ll)  |  (LL))    [uU]?)\n39     )\\b\n40     # the ending word boundary is important for distinguishing\n41     # between suffixes and UDLs in C++\n42 ''')\n43 float_literal_re = re.compile(r'''(?x)\n44     [+-]?(\n45     # decimal\n46       ([0-9]+(\\'[0-9]+)*[eE][+-]?[0-9]+(\\'[0-9]+)*)\n47     | (([0-9]+(\\'[0-9]+)*)?\\.[0-9]+(\\'[0-9]+)*([eE][+-]?[0-9]+(\\'[0-9]+)*)?)\n48     | ([0-9]+(\\'[0-9]+)*\\.([eE][+-]?[0-9]+(\\'[0-9]+)*)?)\n49     # hex\n50     | (0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*[pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)\n51     | (0[xX]([0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?\\.\n52         [0-9a-fA-F]+(\\'[0-9a-fA-F]+)*([pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?)\n53     | (0[xX][0-9a-fA-F]+(\\'[0-9a-fA-F]+)*\\.([pP][+-]?[0-9a-fA-F]+(\\'[0-9a-fA-F]+)*)?)\n54     )\n55 ''')\n56 float_literal_suffix_re = re.compile(r'[fFlL]\\b')\n57 # the ending word boundary is important for distinguishing between suffixes and UDLs in C++\n58 char_literal_re = re.compile(r'''(?x)\n59     ((?:u8)|u|U|L)?\n60     '(\n61       (?:[^\\\\'])\n62     | (\\\\(\n63         (?:['\"?\\\\abfnrtv])\n64       | (?:[0-7]{1,3})\n65       | (?:x[0-9a-fA-F]{2})\n66       | (?:u[0-9a-fA-F]{4})\n67       | (?:U[0-9a-fA-F]{8})\n68       ))\n69     )'\n70 ''')\n71 \n72 \n73 def verify_description_mode(mode: str) -> None:\n74     if mode not in ('lastIsName', 'noneIsName', 'markType', 'markName', 'param', 'udl'):\n75         raise Exception(\"Description mode '%s' is invalid.\" % mode)\n76 \n77 \n78 class NoOldIdError(Exception):\n79     # Used to avoid implementing unneeded id generation for old id schemes.\n80     pass\n81 \n82 \n83 class ASTBaseBase:\n84     def __eq__(self, other: Any) -> bool:\n85         if type(self) is not type(other):\n86             return False\n87         try:\n88             for key, value in self.__dict__.items():\n89                 if value != getattr(other, key):\n90                     return False\n91         except AttributeError:\n92             return False\n93         return True\n94 \n95     __hash__: Callable[[], int] = None\n96 \n97     def clone(self) -> Any:\n98         return deepcopy(self)\n99 \n100     def _stringify(self, transform: StringifyTransform) -> str:\n101         raise NotImplementedError(repr(self))\n102 \n103     def __str__(self) -> str:\n104         return self._stringify(lambda ast: str(ast))\n105 \n106     def get_display_string(self) -> str:\n107         return self._stringify(lambda ast: ast.get_display_string())\n108 \n109     def __repr__(self) -> str:\n110         return '<%s>' % self.__class__.__name__\n111 \n112 \n113 ################################################################################\n114 # Attributes\n115 ################################################################################\n116 \n117 class ASTAttribute(ASTBaseBase):\n118     def describe_signature(self, signode: TextElement) -> None:\n119         raise NotImplementedError(repr(self))\n120 \n121 \n122 class ASTCPPAttribute(ASTAttribute):\n123     def __init__(self, arg: str) -> None:\n124         self.arg = arg\n125 \n126     def _stringify(self, transform: StringifyTransform) -> str:\n127         return \"[[\" + self.arg + \"]]\"\n128 \n129     def describe_signature(self, signode: TextElement) -> None:\n130         signode.append(addnodes.desc_sig_punctuation('[[', '[['))\n131         signode.append(nodes.Text(self.arg, self.arg))\n132         signode.append(addnodes.desc_sig_punctuation(']]', ']]'))\n133 \n134 \n135 class ASTGnuAttribute(ASTBaseBase):\n136     def __init__(self, name: str, args: Optional[\"ASTBaseParenExprList\"]) -> None:\n137         self.name = name\n138         self.args = args\n139 \n140     def _stringify(self, transform: StringifyTransform) -> str:\n141         res = [self.name]\n142         if self.args:\n143             res.append(transform(self.args))\n144         return ''.join(res)\n145 \n146 \n147 class ASTGnuAttributeList(ASTAttribute):\n148     def __init__(self, attrs: List[ASTGnuAttribute]) -> None:\n149         self.attrs = attrs\n150 \n151     def _stringify(self, transform: StringifyTransform) -> str:\n152         res = ['__attribute__((']\n153         first = True\n154         for attr in self.attrs:\n155             if not first:\n156                 res.append(', ')\n157             first = False\n158             res.append(transform(attr))\n159         res.append('))')\n160         return ''.join(res)\n161 \n162     def describe_signature(self, signode: TextElement) -> None:\n163         txt = str(self)\n164         signode.append(nodes.Text(txt, txt))\n165 \n166 \n167 class ASTIdAttribute(ASTAttribute):\n168     \"\"\"For simple attributes defined by the user.\"\"\"\n169 \n170     def __init__(self, id: str) -> None:\n171         self.id = id\n172 \n173     def _stringify(self, transform: StringifyTransform) -> str:\n174         return self.id\n175 \n176     def describe_signature(self, signode: TextElement) -> None:\n177         signode.append(nodes.Text(self.id, self.id))\n178 \n179 \n180 class ASTParenAttribute(ASTAttribute):\n181     \"\"\"For paren attributes defined by the user.\"\"\"\n182 \n183     def __init__(self, id: str, arg: str) -> None:\n184         self.id = id\n185         self.arg = arg\n186 \n187     def _stringify(self, transform: StringifyTransform) -> str:\n188         return self.id + '(' + self.arg + ')'\n189 \n190     def describe_signature(self, signode: TextElement) -> None:\n191         txt = str(self)\n192         signode.append(nodes.Text(txt, txt))\n193 \n194 \n195 ################################################################################\n196 \n197 class ASTBaseParenExprList(ASTBaseBase):\n198     pass\n199 \n200 \n201 ################################################################################\n202 \n203 class UnsupportedMultiCharacterCharLiteral(Exception):\n204     pass\n205 \n206 \n207 class DefinitionError(Exception):\n208     pass\n209 \n210 \n211 class BaseParser:\n212     def __init__(self, definition: str, *,\n213                  location: Union[nodes.Node, Tuple[str, int], str],\n214                  config: \"Config\") -> None:\n215         self.definition = definition.strip()\n216         self.location = location  # for warnings\n217         self.config = config\n218 \n219         self.pos = 0\n220         self.end = len(self.definition)\n221         self.last_match: Match = None\n222         self._previous_state: Tuple[int, Match] = (0, None)\n223         self.otherErrors: List[DefinitionError] = []\n224 \n225         # in our tests the following is set to False to capture bad parsing\n226         self.allowFallbackExpressionParsing = True\n227 \n228     def _make_multi_error(self, errors: List[Any], header: str) -> DefinitionError:\n229         if len(errors) == 1:\n230             if len(header) > 0:\n231                 return DefinitionError(header + '\\n' + str(errors[0][0]))\n232             else:\n233                 return DefinitionError(str(errors[0][0]))\n234         result = [header, '\\n']\n235         for e in errors:\n236             if len(e[1]) > 0:\n237                 indent = '  '\n238                 result.append(e[1])\n239                 result.append(':\\n')\n240                 for line in str(e[0]).split('\\n'):\n241                     if len(line) == 0:\n242                         continue\n243                     result.append(indent)\n244                     result.append(line)\n245                     result.append('\\n')\n246             else:\n247                 result.append(str(e[0]))\n248         return DefinitionError(''.join(result))\n249 \n250     @property\n251     def language(self) -> str:\n252         raise NotImplementedError\n253 \n254     def status(self, msg: str) -> None:\n255         # for debugging\n256         indicator = '-' * self.pos + '^'\n257         print(\"%s\\n%s\\n%s\" % (msg, self.definition, indicator))\n258 \n259     def fail(self, msg: str) -> None:\n260         errors = []\n261         indicator = '-' * self.pos + '^'\n262         exMain = DefinitionError(\n263             'Invalid %s declaration: %s [error at %d]\\n  %s\\n  %s' %\n264             (self.language, msg, self.pos, self.definition, indicator))\n265         errors.append((exMain, \"Main error\"))\n266         for err in self.otherErrors:\n267             errors.append((err, \"Potential other error\"))\n268         self.otherErrors = []\n269         raise self._make_multi_error(errors, '')\n270 \n271     def warn(self, msg: str) -> None:\n272         logger.warning(msg, location=self.location)\n273 \n274     def match(self, regex: Pattern) -> bool:\n275         match = regex.match(self.definition, self.pos)\n276         if match is not None:\n277             self._previous_state = (self.pos, self.last_match)\n278             self.pos = match.end()\n279             self.last_match = match\n280             return True\n281         return False\n282 \n283     def skip_string(self, string: str) -> bool:\n284         strlen = len(string)\n285         if self.definition[self.pos:self.pos + strlen] == string:\n286             self.pos += strlen\n287             return True\n288         return False\n289 \n290     def skip_word(self, word: str) -> bool:\n291         return self.match(re.compile(r'\\b%s\\b' % re.escape(word)))\n292 \n293     def skip_ws(self) -> bool:\n294         return self.match(_whitespace_re)\n295 \n296     def skip_word_and_ws(self, word: str) -> bool:\n297         if self.skip_word(word):\n298             self.skip_ws()\n299             return True\n300         return False\n301 \n302     def skip_string_and_ws(self, string: str) -> bool:\n303         if self.skip_string(string):\n304             self.skip_ws()\n305             return True\n306         return False\n307 \n308     @property\n309     def eof(self) -> bool:\n310         return self.pos >= self.end\n311 \n312     @property\n313     def current_char(self) -> str:\n314         try:\n315             return self.definition[self.pos]\n316         except IndexError:\n317             return 'EOF'\n318 \n319     @property\n320     def matched_text(self) -> str:\n321         if self.last_match is not None:\n322             return self.last_match.group()\n323         else:\n324             return None\n325 \n326     def read_rest(self) -> str:\n327         rv = self.definition[self.pos:]\n328         self.pos = self.end\n329         return rv\n330 \n331     def assert_end(self, *, allowSemicolon: bool = False) -> None:\n332         self.skip_ws()\n333         if allowSemicolon:\n334             if not self.eof and self.definition[self.pos:] != ';':\n335                 self.fail('Expected end of definition or ;.')\n336         else:\n337             if not self.eof:\n338                 self.fail('Expected end of definition.')\n339 \n340     ################################################################################\n341 \n342     @property\n343     def id_attributes(self):\n344         raise NotImplementedError\n345 \n346     @property\n347     def paren_attributes(self):\n348         raise NotImplementedError\n349 \n350     def _parse_balanced_token_seq(self, end: List[str]) -> str:\n351         # TODO: add handling of string literals and similar\n352         brackets = {'(': ')', '[': ']', '{': '}'}\n353         startPos = self.pos\n354         symbols: List[str] = []\n355         while not self.eof:\n356             if len(symbols) == 0 and self.current_char in end:\n357                 break\n358             if self.current_char in brackets.keys():\n359                 symbols.append(brackets[self.current_char])\n360             elif len(symbols) > 0 and self.current_char == symbols[-1]:\n361                 symbols.pop()\n362             elif self.current_char in \")]}\":\n363                 self.fail(\"Unexpected '%s' in balanced-token-seq.\" % self.current_char)\n364             self.pos += 1\n365         if self.eof:\n366             self.fail(\"Could not find end of balanced-token-seq starting at %d.\"\n367                       % startPos)\n368         return self.definition[startPos:self.pos]\n369 \n370     def _parse_attribute(self) -> Optional[ASTAttribute]:\n371         self.skip_ws()\n372         # try C++11 style\n373         startPos = self.pos\n374         if self.skip_string_and_ws('['):\n375             if not self.skip_string('['):\n376                 self.pos = startPos\n377             else:\n378                 # TODO: actually implement the correct grammar\n379                 arg = self._parse_balanced_token_seq(end=[']'])\n380                 if not self.skip_string_and_ws(']'):\n381                     self.fail(\"Expected ']' in end of attribute.\")\n382                 if not self.skip_string_and_ws(']'):\n383                     self.fail(\"Expected ']' in end of attribute after [[...]\")\n384                 return ASTCPPAttribute(arg)\n385 \n386         # try GNU style\n387         if self.skip_word_and_ws('__attribute__'):\n388             if not self.skip_string_and_ws('('):\n389                 self.fail(\"Expected '(' after '__attribute__'.\")\n390             if not self.skip_string_and_ws('('):\n391                 self.fail(\"Expected '(' after '__attribute__('.\")\n392             attrs = []\n393             while 1:\n394                 if self.match(identifier_re):\n395                     name = self.matched_text\n396                     exprs = self._parse_paren_expression_list()\n397                     attrs.append(ASTGnuAttribute(name, exprs))\n398                 if self.skip_string_and_ws(','):\n399                     continue\n400                 elif self.skip_string_and_ws(')'):\n401                     break\n402                 else:\n403                     self.fail(\"Expected identifier, ')', or ',' in __attribute__.\")\n404             if not self.skip_string_and_ws(')'):\n405                 self.fail(\"Expected ')' after '__attribute__((...)'\")\n406             return ASTGnuAttributeList(attrs)\n407 \n408         # try the simple id attributes defined by the user\n409         for id in self.id_attributes:\n410             if self.skip_word_and_ws(id):\n411                 return ASTIdAttribute(id)\n412 \n413         # try the paren attributes defined by the user\n414         for id in self.paren_attributes:\n415             if not self.skip_string_and_ws(id):\n416                 continue\n417             if not self.skip_string('('):\n418                 self.fail(\"Expected '(' after user-defined paren-attribute.\")\n419             arg = self._parse_balanced_token_seq(end=[')'])\n420             if not self.skip_string(')'):\n421                 self.fail(\"Expected ')' to end user-defined paren-attribute.\")\n422             return ASTParenAttribute(id, arg)\n423 \n424         return None\n425 \n426     def _parse_paren_expression_list(self) -> ASTBaseParenExprList:\n427         raise NotImplementedError\n",
        "intended_behavior": "The code in `sphinx/util/cfamily.py` responsible for parsing C/C++ constructs, specifically enums and their attributes, needs to be revised with the following behavior in mind:\n   - Correctly parse and ignore (or handle separately without affecting names) attributes attached to `enum` values. This ensures that the actual names of the enums are used in the documentation rather than the attributes' names.\n   - Ensure that when attributes are present, they do not interfere with the recognition of enum value names. This involves possibly extending the parsing logic to differentiate between the enum names and their optional attributes, ensuring attributes like `__attribute__((__deprecated__))` or macros that expand to such attributes are properly skipped over in the name recognition process.\n   - Prevent the generation of duplicates in the documentation due to misinterpreted enum values. This might require checking for uniqueness in the context where an attribute could lead to misunderstanding of the enum's actual identifiers.\n   - The existing functionality for parsing and documenting C/C++ code must be preserved, with additional handling for enums with attributes being the only change. This involves retaining all current capabilities for processing standard enum declarations, function declarations, variable definitions, and other typical C/C++ constructs without attributes."
    }
]