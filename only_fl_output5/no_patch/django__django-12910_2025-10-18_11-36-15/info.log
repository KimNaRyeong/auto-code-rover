2025-10-18 11:36:15.993 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 11:36:20.450 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=213, output_tokens=12, cost=0.002490
2025-10-18 11:36:20.451 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 11:36:20.455 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:36:29.677 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=522, output_tokens=385, cost=0.016770
2025-10-18 11:36:29.684 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:36:32.412 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=58, cost=0.009130
2025-10-18 11:36:32.413 | DEBUG    | Extracted a valid json.
2025-10-18 11:36:32.413 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Command\")",
        "search_code(\"requires_system_checks = True\")",
        "search_method_in_class(\"handle\", \"Command\")",
        "search_code(\"system checks\")"
    ],
    "bug_locations": []
}
2025-10-18 11:36:32.534 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 11:36:32.535 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 11:36:46.270 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3922, output_tokens=617, cost=0.057730
2025-10-18 11:36:46.277 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:36:55.870 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4755, output_tokens=437, cost=0.060660
2025-10-18 11:36:55.880 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:37:04.066 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=791, output_tokens=339, cost=0.018080
2025-10-18 11:37:04.067 | DEBUG    | Extracted a valid json.
2025-10-18 11:37:04.067 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/core/management/base.py",
            "class": "BaseCommand",
            "attribute": "requires_system_checks",
            "intended_behavior": "This attribute should evolve into 'required_system_checks', with the default value of '__all__'. Instead of a boolean that enables or disables system checks globally, 'required_system_checks' will allow specifying which system checks to run. A value of '__all__' implies running all checks (preserving existing functionality), an empty list ([]) implies running no system checks (equivalent to False), and a list of specific tags (e.g., ['staticfiles', 'models']) would imply running only checks tagged accordingly. This change requires updating wherever 'requires_system_checks' is checked or utilized in the codebase, ensuring backward compatibility and clear documentation to guide developers on the new usage."
        },
        {
            "file": "django/core/management/base.py",
            "method": "Various methods across the BaseCommand class or its children",
            "intended_behavior": "Any method that currently inspects 'requires_system_checks' should be updated to interpret 'required_system_checks'. This includes methods that might directly or indirectly trigger system checks before a command's execution. The handling logic should: Support the '__all__' value to run all checks, support an empty list ([]) to skip all checks, correctly interpret and filter checks based on a provided list of tags, and ensure that any command-specific logic that previously depended on the boolean 'requires_system_checks' to bypass checks is now compatible with the new scheme."
        }
    ]
}
2025-10-18 11:37:04.075 | DEBUG    | Bug location extracted successfully: [<file>django/core/management/base.py</file>
<class>BaseCommand</class>
<method>None</method>
<code>
150 class BaseCommand:
151     """
152     The base class from which all management commands ultimately
153     derive.
154 
155     Use this class if you want access to all of the mechanisms which
156     parse the command-line arguments and work out what code to call in
157     response; if you don't need to change any of that behavior,
158     consider using one of the subclasses defined in this file.
159 
160     If you are interested in overriding/customizing various aspects of
161     the command-parsing and -execution behavior, the normal flow works
162     as follows:
163 
164     1. ``django-admin`` or ``manage.py`` loads the command class
165        and calls its ``run_from_argv()`` method.
166 
167     2. The ``run_from_argv()`` method calls ``create_parser()`` to get
168        an ``ArgumentParser`` for the arguments, parses them, performs
169        any environment changes requested by options like
170        ``pythonpath``, and then calls the ``execute()`` method,
171        passing the parsed arguments.
172 
173     3. The ``execute()`` method attempts to carry out the command by
174        calling the ``handle()`` method with the parsed arguments; any
175        output produced by ``handle()`` will be printed to standard
176        output and, if the command is intended to produce a block of
177        SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.
178 
179     4. If ``handle()`` or ``execute()`` raised any exception (e.g.
180        ``CommandError``), ``run_from_argv()`` will  instead print an error
181        message to ``stderr``.
182 
183     Thus, the ``handle()`` method is typically the starting point for
184     subclasses; many built-in commands and command types either place
185     all of their logic in ``handle()``, or perform some additional
186     parsing work in ``handle()`` and then delegate from it to more
187     specialized methods as needed.
188 
189     Several attributes affect behavior at various steps along the way:
190 
191     ``help``
192         A short description of the command, which will be printed in
193         help messages.
194 
195     ``output_transaction``
196         A boolean indicating whether the command outputs SQL
197         statements; if ``True``, the output will automatically be
198         wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is
199         ``False``.
200 
201     ``requires_migrations_checks``
202         A boolean; if ``True``, the command prints a warning if the set of
203         migrations on disk don't match the migrations in the database.
204 
205     ``requires_system_checks``
206         A boolean; if ``True``, entire Django project will be checked for errors
207         prior to executing the command. Default value is ``True``.
208         To validate an individual application's models
209         rather than all applications' models, call
210         ``self.check(app_configs)`` from ``handle()``, where ``app_configs``
211         is the list of application's configuration provided by the
212         app registry.
213 
214     ``stealth_options``
215         A tuple of any options the command uses which aren't defined by the
216         argument parser.
217     """
218     # Metadata about this command.
219     help = ''
220 
221     # Configuration shortcuts that alter various logic.
222     _called_from_command_line = False
223     output_transaction = False  # Whether to wrap the output in a "BEGIN; COMMIT;"
224     requires_migrations_checks = False
225     requires_system_checks = True
226     # Arguments, common to all commands, which aren't defined by the argument
227     # parser.
228     base_stealth_options = ('stderr', 'stdout')
229     # Command-specific options not defined by the argument parser.
230     stealth_options = ()
231 
232     def __init__(self, stdout=None, stderr=None, no_color=False, force_color=False):
233         self.stdout = OutputWrapper(stdout or sys.stdout)
234         self.stderr = OutputWrapper(stderr or sys.stderr)
235         if no_color and force_color:
236             raise CommandError("'no_color' and 'force_color' can't be used together.")
237         if no_color:
238             self.style = no_style()
239         else:
240             self.style = color_style(force_color)
241             self.stderr.style_func = self.style.ERROR
242 
243     def get_version(self):
244         """
245         Return the Django version, which should be correct for all built-in
246         Django commands. User-supplied commands can override this method to
247         return their own version.
248         """
249         return django.get_version()
250 
251     def create_parser(self, prog_name, subcommand, **kwargs):
252         """
253         Create and return the ``ArgumentParser`` which will be used to
254         parse the arguments to this command.
255         """
256         parser = CommandParser(
257             prog='%s %s' % (os.path.basename(prog_name), subcommand),
258             description=self.help or None,
259             formatter_class=DjangoHelpFormatter,
260             missing_args_message=getattr(self, 'missing_args_message', None),
261             called_from_command_line=getattr(self, '_called_from_command_line', None),
262             **kwargs
263         )
264         parser.add_argument('--version', action='version', version=self.get_version())
265         parser.add_argument(
266             '-v', '--verbosity', default=1,
267             type=int, choices=[0, 1, 2, 3],
268             help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output',
269         )
270         parser.add_argument(
271             '--settings',
272             help=(
273                 'The Python path to a settings module, e.g. '
274                 '"myproject.settings.main". If this isn\'t provided, the '
275                 'DJANGO_SETTINGS_MODULE environment variable will be used.'
276             ),
277         )
278         parser.add_argument(
279             '--pythonpath',
280             help='A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".',
281         )
282         parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')
283         parser.add_argument(
284             '--no-color', action='store_true',
285             help="Don't colorize the command output.",
286         )
287         parser.add_argument(
288             '--force-color', action='store_true',
289             help='Force colorization of the command output.',
290         )
291         if self.requires_system_checks:
292             parser.add_argument(
293                 '--skip-checks', action='store_true',
294                 help='Skip system checks.',
295             )
296         self.add_arguments(parser)
297         return parser
298 
299     def add_arguments(self, parser):
300         """
301         Entry point for subclassed commands to add custom arguments.
302         """
303         pass
304 
305     def print_help(self, prog_name, subcommand):
306         """
307         Print the help message for this command, derived from
308         ``self.usage()``.
309         """
310         parser = self.create_parser(prog_name, subcommand)
311         parser.print_help()
312 
313     def run_from_argv(self, argv):
314         """
315         Set up any environment changes requested (e.g., Python path
316         and Django settings), then run this command. If the
317         command raises a ``CommandError``, intercept it and print it sensibly
318         to stderr. If the ``--traceback`` option is present or the raised
319         ``Exception`` is not ``CommandError``, raise it.
320         """
321         self._called_from_command_line = True
322         parser = self.create_parser(argv[0], argv[1])
323 
324         options = parser.parse_args(argv[2:])
325         cmd_options = vars(options)
326         # Move positional args out of options to mimic legacy optparse
327         args = cmd_options.pop('args', ())
328         handle_default_options(options)
329         try:
330             self.execute(*args, **cmd_options)
331         except CommandError as e:
332             if options.traceback:
333                 raise
334 
335             # SystemCheckError takes care of its own formatting.
336             if isinstance(e, SystemCheckError):
337                 self.stderr.write(str(e), lambda x: x)
338             else:
339                 self.stderr.write('%s: %s' % (e.__class__.__name__, e))
340             sys.exit(e.returncode)
341         finally:
342             try:
343                 connections.close_all()
344             except ImproperlyConfigured:
345                 # Ignore if connections aren't setup at this point (e.g. no
346                 # configured settings).
347                 pass
348 
349     def execute(self, *args, **options):
350         """
351         Try to execute this command, performing system checks if needed (as
352         controlled by the ``requires_system_checks`` attribute, except if
353         force-skipped).
354         """
355         if options['force_color'] and options['no_color']:
356             raise CommandError("The --no-color and --force-color options can't be used together.")
357         if options['force_color']:
358             self.style = color_style(force_color=True)
359         elif options['no_color']:
360             self.style = no_style()
361             self.stderr.style_func = None
362         if options.get('stdout'):
363             self.stdout = OutputWrapper(options['stdout'])
364         if options.get('stderr'):
365             self.stderr = OutputWrapper(options['stderr'])
366 
367         if self.requires_system_checks and not options['skip_checks']:
368             self.check()
369         if self.requires_migrations_checks:
370             self.check_migrations()
371         output = self.handle(*args, **options)
372         if output:
373             if self.output_transaction:
374                 connection = connections[options.get('database', DEFAULT_DB_ALIAS)]
375                 output = '%s\n%s\n%s' % (
376                     self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()),
377                     output,
378                     self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()),
379                 )
380             self.stdout.write(output)
381         return output
382 
383     def check(self, app_configs=None, tags=None, display_num_errors=False,
384               include_deployment_checks=False, fail_level=checks.ERROR,
385               databases=None):
386         """
387         Use the system check framework to validate entire Django project.
388         Raise CommandError for any serious message (error or critical errors).
389         If there are only light messages (like warnings), print them to stderr
390         and don't raise an exception.
391         """
392         all_issues = checks.run_checks(
393             app_configs=app_configs,
394             tags=tags,
395             include_deployment_checks=include_deployment_checks,
396             databases=databases,
397         )
398 
399         header, body, footer = "", "", ""
400         visible_issue_count = 0  # excludes silenced warnings
401 
402         if all_issues:
403             debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced()]
404             infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced()]
405             warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced()]
406             errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced()]
407             criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced()]
408             sorted_issues = [
409                 (criticals, 'CRITICALS'),
410                 (errors, 'ERRORS'),
411                 (warnings, 'WARNINGS'),
412                 (infos, 'INFOS'),
413                 (debugs, 'DEBUGS'),
414             ]
415 
416             for issues, group_name in sorted_issues:
417                 if issues:
418                     visible_issue_count += len(issues)
419                     formatted = (
420                         self.style.ERROR(str(e))
421                         if e.is_serious()
422                         else self.style.WARNING(str(e))
423                         for e in issues)
424                     formatted = "\n".join(sorted(formatted))
425                     body += '\n%s:\n%s\n' % (group_name, formatted)
426 
427         if visible_issue_count:
428             header = "System check identified some issues:\n"
429 
430         if display_num_errors:
431             if visible_issue_count:
432                 footer += '\n'
433             footer += "System check identified %s (%s silenced)." % (
434                 "no issues" if visible_issue_count == 0 else
435                 "1 issue" if visible_issue_count == 1 else
436                 "%s issues" % visible_issue_count,
437                 len(all_issues) - visible_issue_count,
438             )
439 
440         if any(e.is_serious(fail_level) and not e.is_silenced() for e in all_issues):
441             msg = self.style.ERROR("SystemCheckError: %s" % header) + body + footer
442             raise SystemCheckError(msg)
443         else:
444             msg = header + body + footer
445 
446         if msg:
447             if visible_issue_count:
448                 self.stderr.write(msg, lambda x: x)
449             else:
450                 self.stdout.write(msg)
451 
452     def check_migrations(self):
453         """
454         Print a warning if the set of migrations on disk don't match the
455         migrations in the database.
456         """
457         from django.db.migrations.executor import MigrationExecutor
458         try:
459             executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS])
460         except ImproperlyConfigured:
461             # No databases are configured (or the dummy one)
462             return
463 
464         plan = executor.migration_plan(executor.loader.graph.leaf_nodes())
465         if plan:
466             apps_waiting_migration = sorted({migration.app_label for migration, backwards in plan})
467             self.stdout.write(
468                 self.style.NOTICE(
469                     "\nYou have %(unapplied_migration_count)s unapplied migration(s). "
470                     "Your project may not work properly until you apply the "
471                     "migrations for app(s): %(apps_waiting_migration)s." % {
472                         "unapplied_migration_count": len(plan),
473                         "apps_waiting_migration": ", ".join(apps_waiting_migration),
474                     }
475                 )
476             )
477             self.stdout.write(self.style.NOTICE("Run 'python manage.py migrate' to apply them."))
478 
479     def handle(self, *args, **options):
480         """
481         The actual logic of the command. Subclasses must implement
482         this method.
483         """
484         raise NotImplementedError('subclasses of BaseCommand must provide a handle() method')

</code><intended_behavior>This attribute should evolve into 'required_system_checks', with the default value of '__all__'. Instead of a boolean that enables or disables system checks globally, 'required_system_checks' will allow specifying which system checks to run. A value of '__all__' implies running all checks (preserving existing functionality), an empty list ([]) implies running no system checks (equivalent to False), and a list of specific tags (e.g., ['staticfiles', 'models']) would imply running only checks tagged accordingly. This change requires updating wherever 'requires_system_checks' is checked or utilized in the codebase, ensuring backward compatibility and clear documentation to guide developers on the new usage.</intended_behavior>, <file>django/core/management/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Base classes for writing management commands (named commands which can
3 be executed through ``django-admin`` or ``manage.py``).
4 """
5 import os
6 import sys
7 from argparse import ArgumentParser, HelpFormatter
8 from io import TextIOBase
9 
10 import django
11 from django.core import checks
12 from django.core.exceptions import ImproperlyConfigured
13 from django.core.management.color import color_style, no_style
14 from django.db import DEFAULT_DB_ALIAS, connections
15 
16 
17 class CommandError(Exception):
18     """
19     Exception class indicating a problem while executing a management
20     command.
21 
22     If this exception is raised during the execution of a management
23     command, it will be caught and turned into a nicely-printed error
24     message to the appropriate output stream (i.e., stderr); as a
25     result, raising this exception (with a sensible description of the
26     error) is the preferred way to indicate that something has gone
27     wrong in the execution of a command.
28     """
29     def __init__(self, *args, returncode=1, **kwargs):
30         self.returncode = returncode
31         super().__init__(*args, **kwargs)
32 
33 
34 class SystemCheckError(CommandError):
35     """
36     The system check framework detected unrecoverable errors.
37     """
38     pass
39 
40 
41 class CommandParser(ArgumentParser):
42     """
43     Customized ArgumentParser class to improve some error messages and prevent
44     SystemExit in several occasions, as SystemExit is unacceptable when a
45     command is called programmatically.
46     """
47     def __init__(self, *, missing_args_message=None, called_from_command_line=None, **kwargs):
48         self.missing_args_message = missing_args_message
49         self.called_from_command_line = called_from_command_line
50         super().__init__(**kwargs)
51 
52     def parse_args(self, args=None, namespace=None):
53         # Catch missing argument for a better error message
54         if (self.missing_args_message and
55                 not (args or any(not arg.startswith('-') for arg in args))):
56             self.error(self.missing_args_message)
57         return super().parse_args(args, namespace)
58 
59     def error(self, message):
60         if self.called_from_command_line:
61             super().error(message)
62         else:
63             raise CommandError("Error: %s" % message)
64 
65 
66 def handle_default_options(options):
67     """
68     Include any default options that all commands should accept here
69     so that ManagementUtility can handle them before searching for
70     user commands.
71     """
72     if options.settings:
73         os.environ['DJANGO_SETTINGS_MODULE'] = options.settings
74     if options.pythonpath:
75         sys.path.insert(0, options.pythonpath)
76 
77 
78 def no_translations(handle_func):
79     """Decorator that forces a command to run with translations deactivated."""
80     def wrapped(*args, **kwargs):
81         from django.utils import translation
82         saved_locale = translation.get_language()
83         translation.deactivate_all()
84         try:
85             res = handle_func(*args, **kwargs)
86         finally:
87             if saved_locale is not None:
88                 translation.activate(saved_locale)
89         return res
90     return wrapped
91 
92 
93 class DjangoHelpFormatter(HelpFormatter):
94     """
95     Customized formatter so that command-specific arguments appear in the
96     --help output before arguments common to all commands.
97     """
98     show_last = {
99         '--version', '--verbosity', '--traceback', '--settings', '--pythonpath',
100         '--no-color', '--force-color', '--skip-checks',
101     }
102 
103     def _reordered_actions(self, actions):
104         return sorted(
105             actions,
106             key=lambda a: set(a.option_strings) & self.show_last != set()
107         )
108 
109     def add_usage(self, usage, actions, *args, **kwargs):
110         super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)
111 
112     def add_arguments(self, actions):
113         super().add_arguments(self._reordered_actions(actions))
114 
115 
116 class OutputWrapper(TextIOBase):
117     """
118     Wrapper around stdout/stderr
119     """
120     @property
121     def style_func(self):
122         return self._style_func
123 
124     @style_func.setter
125     def style_func(self, style_func):
126         if style_func and self.isatty():
127             self._style_func = style_func
128         else:
129             self._style_func = lambda x: x
130 
131     def __init__(self, out, ending='\n'):
132         self._out = out
133         self.style_func = None
134         self.ending = ending
135 
136     def __getattr__(self, name):
137         return getattr(self._out, name)
138 
139     def isatty(self):
140         return hasattr(self._out, 'isatty') and self._out.isatty()
141 
142     def write(self, msg='', style_func=None, ending=None):
143         ending = self.ending if ending is None else ending
144         if ending and not msg.endswith(ending):
145             msg += ending
146         style_func = style_func or self.style_func
147         self._out.write(style_func(msg))
148 
149 
150 class BaseCommand:
151     """
152     The base class from which all management commands ultimately
153     derive.
154 
155     Use this class if you want access to all of the mechanisms which
156     parse the command-line arguments and work out what code to call in
157     response; if you don't need to change any of that behavior,
158     consider using one of the subclasses defined in this file.
159 
160     If you are interested in overriding/customizing various aspects of
161     the command-parsing and -execution behavior, the normal flow works
162     as follows:
163 
164     1. ``django-admin`` or ``manage.py`` loads the command class
165        and calls its ``run_from_argv()`` method.
166 
167     2. The ``run_from_argv()`` method calls ``create_parser()`` to get
168        an ``ArgumentParser`` for the arguments, parses them, performs
169        any environment changes requested by options like
170        ``pythonpath``, and then calls the ``execute()`` method,
171        passing the parsed arguments.
172 
173     3. The ``execute()`` method attempts to carry out the command by
174        calling the ``handle()`` method with the parsed arguments; any
175        output produced by ``handle()`` will be printed to standard
176        output and, if the command is intended to produce a block of
177        SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.
178 
179     4. If ``handle()`` or ``execute()`` raised any exception (e.g.
180        ``CommandError``), ``run_from_argv()`` will  instead print an error
181        message to ``stderr``.
182 
183     Thus, the ``handle()`` method is typically the starting point for
184     subclasses; many built-in commands and command types either place
185     all of their logic in ``handle()``, or perform some additional
186     parsing work in ``handle()`` and then delegate from it to more
187     specialized methods as needed.
188 
189     Several attributes affect behavior at various steps along the way:
190 
191     ``help``
192         A short description of the command, which will be printed in
193         help messages.
194 
195     ``output_transaction``
196         A boolean indicating whether the command outputs SQL
197         statements; if ``True``, the output will automatically be
198         wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is
199         ``False``.
200 
201     ``requires_migrations_checks``
202         A boolean; if ``True``, the command prints a warning if the set of
203         migrations on disk don't match the migrations in the database.
204 
205     ``requires_system_checks``
206         A boolean; if ``True``, entire Django project will be checked for errors
207         prior to executing the command. Default value is ``True``.
208         To validate an individual application's models
209         rather than all applications' models, call
210         ``self.check(app_configs)`` from ``handle()``, where ``app_configs``
211         is the list of application's configuration provided by the
212         app registry.
213 
214     ``stealth_options``
215         A tuple of any options the command uses which aren't defined by the
216         argument parser.
217     """
218     # Metadata about this command.
219     help = ''
220 
221     # Configuration shortcuts that alter various logic.
222     _called_from_command_line = False
223     output_transaction = False  # Whether to wrap the output in a "BEGIN; COMMIT;"
224     requires_migrations_checks = False
225     requires_system_checks = True
226     # Arguments, common to all commands, which aren't defined by the argument
227     # parser.
228     base_stealth_options = ('stderr', 'stdout')
229     # Command-specific options not defined by the argument parser.
230     stealth_options = ()
231 
232     def __init__(self, stdout=None, stderr=None, no_color=False, force_color=False):
233         self.stdout = OutputWrapper(stdout or sys.stdout)
234         self.stderr = OutputWrapper(stderr or sys.stderr)
235         if no_color and force_color:
236             raise CommandError("'no_color' and 'force_color' can't be used together.")
237         if no_color:
238             self.style = no_style()
239         else:
240             self.style = color_style(force_color)
241             self.stderr.style_func = self.style.ERROR
242 
243     def get_version(self):
244         """
245         Return the Django version, which should be correct for all built-in
246         Django commands. User-supplied commands can override this method to
247         return their own version.
248         """
249         return django.get_version()
250 
251     def create_parser(self, prog_name, subcommand, **kwargs):
252         """
253         Create and return the ``ArgumentParser`` which will be used to
254         parse the arguments to this command.
255         """
256         parser = CommandParser(
257             prog='%s %s' % (os.path.basename(prog_name), subcommand),
258             description=self.help or None,
259             formatter_class=DjangoHelpFormatter,
260             missing_args_message=getattr(self, 'missing_args_message', None),
261             called_from_command_line=getattr(self, '_called_from_command_line', None),
262             **kwargs
263         )
264         parser.add_argument('--version', action='version', version=self.get_version())
265         parser.add_argument(
266             '-v', '--verbosity', default=1,
267             type=int, choices=[0, 1, 2, 3],
268             help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output',
269         )
270         parser.add_argument(
271             '--settings',
272             help=(
273                 'The Python path to a settings module, e.g. '
274                 '"myproject.settings.main". If this isn\'t provided, the '
275                 'DJANGO_SETTINGS_MODULE environment variable will be used.'
276             ),
277         )
278         parser.add_argument(
279             '--pythonpath',
280             help='A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".',
281         )
282         parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')
283         parser.add_argument(
284             '--no-color', action='store_true',
285             help="Don't colorize the command output.",
286         )
287         parser.add_argument(
288             '--force-color', action='store_true',
289             help='Force colorization of the command output.',
290         )
291         if self.requires_system_checks:
292             parser.add_argument(
293                 '--skip-checks', action='store_true',
294                 help='Skip system checks.',
295             )
296         self.add_arguments(parser)
297         return parser
298 
299     def add_arguments(self, parser):
300         """
301         Entry point for subclassed commands to add custom arguments.
302         """
303         pass
304 
305     def print_help(self, prog_name, subcommand):
306         """
307         Print the help message for this command, derived from
308         ``self.usage()``.
309         """
310         parser = self.create_parser(prog_name, subcommand)
311         parser.print_help()
312 
313     def run_from_argv(self, argv):
314         """
315         Set up any environment changes requested (e.g., Python path
316         and Django settings), then run this command. If the
317         command raises a ``CommandError``, intercept it and print it sensibly
318         to stderr. If the ``--traceback`` option is present or the raised
319         ``Exception`` is not ``CommandError``, raise it.
320         """
321         self._called_from_command_line = True
322         parser = self.create_parser(argv[0], argv[1])
323 
324         options = parser.parse_args(argv[2:])
325         cmd_options = vars(options)
326         # Move positional args out of options to mimic legacy optparse
327         args = cmd_options.pop('args', ())
328         handle_default_options(options)
329         try:
330             self.execute(*args, **cmd_options)
331         except CommandError as e:
332             if options.traceback:
333                 raise
334 
335             # SystemCheckError takes care of its own formatting.
336             if isinstance(e, SystemCheckError):
337                 self.stderr.write(str(e), lambda x: x)
338             else:
339                 self.stderr.write('%s: %s' % (e.__class__.__name__, e))
340             sys.exit(e.returncode)
341         finally:
342             try:
343                 connections.close_all()
344             except ImproperlyConfigured:
345                 # Ignore if connections aren't setup at this point (e.g. no
346                 # configured settings).
347                 pass
348 
349     def execute(self, *args, **options):
350         """
351         Try to execute this command, performing system checks if needed (as
352         controlled by the ``requires_system_checks`` attribute, except if
353         force-skipped).
354         """
355         if options['force_color'] and options['no_color']:
356             raise CommandError("The --no-color and --force-color options can't be used together.")
357         if options['force_color']:
358             self.style = color_style(force_color=True)
359         elif options['no_color']:
360             self.style = no_style()
361             self.stderr.style_func = None
362         if options.get('stdout'):
363             self.stdout = OutputWrapper(options['stdout'])
364         if options.get('stderr'):
365             self.stderr = OutputWrapper(options['stderr'])
366 
367         if self.requires_system_checks and not options['skip_checks']:
368             self.check()
369         if self.requires_migrations_checks:
370             self.check_migrations()
371         output = self.handle(*args, **options)
372         if output:
373             if self.output_transaction:
374                 connection = connections[options.get('database', DEFAULT_DB_ALIAS)]
375                 output = '%s\n%s\n%s' % (
376                     self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()),
377                     output,
378                     self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()),
379                 )
380             self.stdout.write(output)
381         return output
382 
383     def check(self, app_configs=None, tags=None, display_num_errors=False,
384               include_deployment_checks=False, fail_level=checks.ERROR,
385               databases=None):
386         """
387         Use the system check framework to validate entire Django project.
388         Raise CommandError for any serious message (error or critical errors).
389         If there are only light messages (like warnings), print them to stderr
390         and don't raise an exception.
391         """
392         all_issues = checks.run_checks(
393             app_configs=app_configs,
394             tags=tags,
395             include_deployment_checks=include_deployment_checks,
396             databases=databases,
397         )
398 
399         header, body, footer = "", "", ""
400         visible_issue_count = 0  # excludes silenced warnings
401 
402         if all_issues:
403             debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced()]
404             infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced()]
405             warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced()]
406             errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced()]
407             criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced()]
408             sorted_issues = [
409                 (criticals, 'CRITICALS'),
410                 (errors, 'ERRORS'),
411                 (warnings, 'WARNINGS'),
412                 (infos, 'INFOS'),
413                 (debugs, 'DEBUGS'),
414             ]
415 
416             for issues, group_name in sorted_issues:
417                 if issues:
418                     visible_issue_count += len(issues)
419                     formatted = (
420                         self.style.ERROR(str(e))
421                         if e.is_serious()
422                         else self.style.WARNING(str(e))
423                         for e in issues)
424                     formatted = "\n".join(sorted(formatted))
425                     body += '\n%s:\n%s\n' % (group_name, formatted)
426 
427         if visible_issue_count:
428             header = "System check identified some issues:\n"
429 
430         if display_num_errors:
431             if visible_issue_count:
432                 footer += '\n'
433             footer += "System check identified %s (%s silenced)." % (
434                 "no issues" if visible_issue_count == 0 else
435                 "1 issue" if visible_issue_count == 1 else
436                 "%s issues" % visible_issue_count,
437                 len(all_issues) - visible_issue_count,
438             )
439 
440         if any(e.is_serious(fail_level) and not e.is_silenced() for e in all_issues):
441             msg = self.style.ERROR("SystemCheckError: %s" % header) + body + footer
442             raise SystemCheckError(msg)
443         else:
444             msg = header + body + footer
445 
446         if msg:
447             if visible_issue_count:
448                 self.stderr.write(msg, lambda x: x)
449             else:
450                 self.stdout.write(msg)
451 
452     def check_migrations(self):
453         """
454         Print a warning if the set of migrations on disk don't match the
455         migrations in the database.
456         """
457         from django.db.migrations.executor import MigrationExecutor
458         try:
459             executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS])
460         except ImproperlyConfigured:
461             # No databases are configured (or the dummy one)
462             return
463 
464         plan = executor.migration_plan(executor.loader.graph.leaf_nodes())
465         if plan:
466             apps_waiting_migration = sorted({migration.app_label for migration, backwards in plan})
467             self.stdout.write(
468                 self.style.NOTICE(
469                     "\nYou have %(unapplied_migration_count)s unapplied migration(s). "
470                     "Your project may not work properly until you apply the "
471                     "migrations for app(s): %(apps_waiting_migration)s." % {
472                         "unapplied_migration_count": len(plan),
473                         "apps_waiting_migration": ", ".join(apps_waiting_migration),
474                     }
475                 )
476             )
477             self.stdout.write(self.style.NOTICE("Run 'python manage.py migrate' to apply them."))
478 
479     def handle(self, *args, **options):
480         """
481         The actual logic of the command. Subclasses must implement
482         this method.
483         """
484         raise NotImplementedError('subclasses of BaseCommand must provide a handle() method')
485 
486 
487 class AppCommand(BaseCommand):
488     """
489     A management command which takes one or more installed application labels
490     as arguments, and does something with each of them.
491 
492     Rather than implementing ``handle()``, subclasses must implement
493     ``handle_app_config()``, which will be called once for each application.
494     """
495     missing_args_message = "Enter at least one application label."
496 
497     def add_arguments(self, parser):
498         parser.add_argument('args', metavar='app_label', nargs='+', help='One or more application label.')
499 
500     def handle(self, *app_labels, **options):
501         from django.apps import apps
502         try:
503             app_configs = [apps.get_app_config(app_label) for app_label in app_labels]
504         except (LookupError, ImportError) as e:
505             raise CommandError("%s. Are you sure your INSTALLED_APPS setting is correct?" % e)
506         output = []
507         for app_config in app_configs:
508             app_output = self.handle_app_config(app_config, **options)
509             if app_output:
510                 output.append(app_output)
511         return '\n'.join(output)
512 
513     def handle_app_config(self, app_config, **options):
514         """
515         Perform the command's actions for app_config, an AppConfig instance
516         corresponding to an application label given on the command line.
517         """
518         raise NotImplementedError(
519             "Subclasses of AppCommand must provide"
520             "a handle_app_config() method.")
521 
522 
523 class LabelCommand(BaseCommand):
524     """
525     A management command which takes one or more arbitrary arguments
526     (labels) on the command line, and does something with each of
527     them.
528 
529     Rather than implementing ``handle()``, subclasses must implement
530     ``handle_label()``, which will be called once for each label.
531 
532     If the arguments should be names of installed applications, use
533     ``AppCommand`` instead.
534     """
535     label = 'label'
536     missing_args_message = "Enter at least one %s." % label
537 
538     def add_arguments(self, parser):
539         parser.add_argument('args', metavar=self.label, nargs='+')
540 
541     def handle(self, *labels, **options):
542         output = []
543         for label in labels:
544             label_output = self.handle_label(label, **options)
545             if label_output:
546                 output.append(label_output)
547         return '\n'.join(output)
548 
549     def handle_label(self, label, **options):
550         """
551         Perform the command's actions for ``label``, which will be the
552         string as given on the command line.
553         """
554         raise NotImplementedError('subclasses of LabelCommand must provide a handle_label() method')

</code><intended_behavior>Any method that currently inspects 'requires_system_checks' should be updated to interpret 'required_system_checks'. This includes methods that might directly or indirectly trigger system checks before a command's execution. The handling logic should: Support the '__all__' value to run all checks, support an empty list ([]) to skip all checks, correctly interpret and filter checks based on a provided list of tags, and ensure that any command-specific logic that previously depended on the boolean 'requires_system_checks' to bypass checks is now compatible with the new scheme.</intended_behavior>]
2025-10-18 11:37:04.076 | INFO     | Search completed. Bug locations: [<file>django/core/management/base.py</file>
<class>BaseCommand</class>
<method>None</method>
<code>
150 class BaseCommand:
151     """
152     The base class from which all management commands ultimately
153     derive.
154 
155     Use this class if you want access to all of the mechanisms which
156     parse the command-line arguments and work out what code to call in
157     response; if you don't need to change any of that behavior,
158     consider using one of the subclasses defined in this file.
159 
160     If you are interested in overriding/customizing various aspects of
161     the command-parsing and -execution behavior, the normal flow works
162     as follows:
163 
164     1. ``django-admin`` or ``manage.py`` loads the command class
165        and calls its ``run_from_argv()`` method.
166 
167     2. The ``run_from_argv()`` method calls ``create_parser()`` to get
168        an ``ArgumentParser`` for the arguments, parses them, performs
169        any environment changes requested by options like
170        ``pythonpath``, and then calls the ``execute()`` method,
171        passing the parsed arguments.
172 
173     3. The ``execute()`` method attempts to carry out the command by
174        calling the ``handle()`` method with the parsed arguments; any
175        output produced by ``handle()`` will be printed to standard
176        output and, if the command is intended to produce a block of
177        SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.
178 
179     4. If ``handle()`` or ``execute()`` raised any exception (e.g.
180        ``CommandError``), ``run_from_argv()`` will  instead print an error
181        message to ``stderr``.
182 
183     Thus, the ``handle()`` method is typically the starting point for
184     subclasses; many built-in commands and command types either place
185     all of their logic in ``handle()``, or perform some additional
186     parsing work in ``handle()`` and then delegate from it to more
187     specialized methods as needed.
188 
189     Several attributes affect behavior at various steps along the way:
190 
191     ``help``
192         A short description of the command, which will be printed in
193         help messages.
194 
195     ``output_transaction``
196         A boolean indicating whether the command outputs SQL
197         statements; if ``True``, the output will automatically be
198         wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is
199         ``False``.
200 
201     ``requires_migrations_checks``
202         A boolean; if ``True``, the command prints a warning if the set of
203         migrations on disk don't match the migrations in the database.
204 
205     ``requires_system_checks``
206         A boolean; if ``True``, entire Django project will be checked for errors
207         prior to executing the command. Default value is ``True``.
208         To validate an individual application's models
209         rather than all applications' models, call
210         ``self.check(app_configs)`` from ``handle()``, where ``app_configs``
211         is the list of application's configuration provided by the
212         app registry.
213 
214     ``stealth_options``
215         A tuple of any options the command uses which aren't defined by the
216         argument parser.
217     """
218     # Metadata about this command.
219     help = ''
220 
221     # Configuration shortcuts that alter various logic.
222     _called_from_command_line = False
223     output_transaction = False  # Whether to wrap the output in a "BEGIN; COMMIT;"
224     requires_migrations_checks = False
225     requires_system_checks = True
226     # Arguments, common to all commands, which aren't defined by the argument
227     # parser.
228     base_stealth_options = ('stderr', 'stdout')
229     # Command-specific options not defined by the argument parser.
230     stealth_options = ()
231 
232     def __init__(self, stdout=None, stderr=None, no_color=False, force_color=False):
233         self.stdout = OutputWrapper(stdout or sys.stdout)
234         self.stderr = OutputWrapper(stderr or sys.stderr)
235         if no_color and force_color:
236             raise CommandError("'no_color' and 'force_color' can't be used together.")
237         if no_color:
238             self.style = no_style()
239         else:
240             self.style = color_style(force_color)
241             self.stderr.style_func = self.style.ERROR
242 
243     def get_version(self):
244         """
245         Return the Django version, which should be correct for all built-in
246         Django commands. User-supplied commands can override this method to
247         return their own version.
248         """
249         return django.get_version()
250 
251     def create_parser(self, prog_name, subcommand, **kwargs):
252         """
253         Create and return the ``ArgumentParser`` which will be used to
254         parse the arguments to this command.
255         """
256         parser = CommandParser(
257             prog='%s %s' % (os.path.basename(prog_name), subcommand),
258             description=self.help or None,
259             formatter_class=DjangoHelpFormatter,
260             missing_args_message=getattr(self, 'missing_args_message', None),
261             called_from_command_line=getattr(self, '_called_from_command_line', None),
262             **kwargs
263         )
264         parser.add_argument('--version', action='version', version=self.get_version())
265         parser.add_argument(
266             '-v', '--verbosity', default=1,
267             type=int, choices=[0, 1, 2, 3],
268             help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output',
269         )
270         parser.add_argument(
271             '--settings',
272             help=(
273                 'The Python path to a settings module, e.g. '
274                 '"myproject.settings.main". If this isn\'t provided, the '
275                 'DJANGO_SETTINGS_MODULE environment variable will be used.'
276             ),
277         )
278         parser.add_argument(
279             '--pythonpath',
280             help='A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".',
281         )
282         parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')
283         parser.add_argument(
284             '--no-color', action='store_true',
285             help="Don't colorize the command output.",
286         )
287         parser.add_argument(
288             '--force-color', action='store_true',
289             help='Force colorization of the command output.',
290         )
291         if self.requires_system_checks:
292             parser.add_argument(
293                 '--skip-checks', action='store_true',
294                 help='Skip system checks.',
295             )
296         self.add_arguments(parser)
297         return parser
298 
299     def add_arguments(self, parser):
300         """
301         Entry point for subclassed commands to add custom arguments.
302         """
303         pass
304 
305     def print_help(self, prog_name, subcommand):
306         """
307         Print the help message for this command, derived from
308         ``self.usage()``.
309         """
310         parser = self.create_parser(prog_name, subcommand)
311         parser.print_help()
312 
313     def run_from_argv(self, argv):
314         """
315         Set up any environment changes requested (e.g., Python path
316         and Django settings), then run this command. If the
317         command raises a ``CommandError``, intercept it and print it sensibly
318         to stderr. If the ``--traceback`` option is present or the raised
319         ``Exception`` is not ``CommandError``, raise it.
320         """
321         self._called_from_command_line = True
322         parser = self.create_parser(argv[0], argv[1])
323 
324         options = parser.parse_args(argv[2:])
325         cmd_options = vars(options)
326         # Move positional args out of options to mimic legacy optparse
327         args = cmd_options.pop('args', ())
328         handle_default_options(options)
329         try:
330             self.execute(*args, **cmd_options)
331         except CommandError as e:
332             if options.traceback:
333                 raise
334 
335             # SystemCheckError takes care of its own formatting.
336             if isinstance(e, SystemCheckError):
337                 self.stderr.write(str(e), lambda x: x)
338             else:
339                 self.stderr.write('%s: %s' % (e.__class__.__name__, e))
340             sys.exit(e.returncode)
341         finally:
342             try:
343                 connections.close_all()
344             except ImproperlyConfigured:
345                 # Ignore if connections aren't setup at this point (e.g. no
346                 # configured settings).
347                 pass
348 
349     def execute(self, *args, **options):
350         """
351         Try to execute this command, performing system checks if needed (as
352         controlled by the ``requires_system_checks`` attribute, except if
353         force-skipped).
354         """
355         if options['force_color'] and options['no_color']:
356             raise CommandError("The --no-color and --force-color options can't be used together.")
357         if options['force_color']:
358             self.style = color_style(force_color=True)
359         elif options['no_color']:
360             self.style = no_style()
361             self.stderr.style_func = None
362         if options.get('stdout'):
363             self.stdout = OutputWrapper(options['stdout'])
364         if options.get('stderr'):
365             self.stderr = OutputWrapper(options['stderr'])
366 
367         if self.requires_system_checks and not options['skip_checks']:
368             self.check()
369         if self.requires_migrations_checks:
370             self.check_migrations()
371         output = self.handle(*args, **options)
372         if output:
373             if self.output_transaction:
374                 connection = connections[options.get('database', DEFAULT_DB_ALIAS)]
375                 output = '%s\n%s\n%s' % (
376                     self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()),
377                     output,
378                     self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()),
379                 )
380             self.stdout.write(output)
381         return output
382 
383     def check(self, app_configs=None, tags=None, display_num_errors=False,
384               include_deployment_checks=False, fail_level=checks.ERROR,
385               databases=None):
386         """
387         Use the system check framework to validate entire Django project.
388         Raise CommandError for any serious message (error or critical errors).
389         If there are only light messages (like warnings), print them to stderr
390         and don't raise an exception.
391         """
392         all_issues = checks.run_checks(
393             app_configs=app_configs,
394             tags=tags,
395             include_deployment_checks=include_deployment_checks,
396             databases=databases,
397         )
398 
399         header, body, footer = "", "", ""
400         visible_issue_count = 0  # excludes silenced warnings
401 
402         if all_issues:
403             debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced()]
404             infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced()]
405             warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced()]
406             errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced()]
407             criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced()]
408             sorted_issues = [
409                 (criticals, 'CRITICALS'),
410                 (errors, 'ERRORS'),
411                 (warnings, 'WARNINGS'),
412                 (infos, 'INFOS'),
413                 (debugs, 'DEBUGS'),
414             ]
415 
416             for issues, group_name in sorted_issues:
417                 if issues:
418                     visible_issue_count += len(issues)
419                     formatted = (
420                         self.style.ERROR(str(e))
421                         if e.is_serious()
422                         else self.style.WARNING(str(e))
423                         for e in issues)
424                     formatted = "\n".join(sorted(formatted))
425                     body += '\n%s:\n%s\n' % (group_name, formatted)
426 
427         if visible_issue_count:
428             header = "System check identified some issues:\n"
429 
430         if display_num_errors:
431             if visible_issue_count:
432                 footer += '\n'
433             footer += "System check identified %s (%s silenced)." % (
434                 "no issues" if visible_issue_count == 0 else
435                 "1 issue" if visible_issue_count == 1 else
436                 "%s issues" % visible_issue_count,
437                 len(all_issues) - visible_issue_count,
438             )
439 
440         if any(e.is_serious(fail_level) and not e.is_silenced() for e in all_issues):
441             msg = self.style.ERROR("SystemCheckError: %s" % header) + body + footer
442             raise SystemCheckError(msg)
443         else:
444             msg = header + body + footer
445 
446         if msg:
447             if visible_issue_count:
448                 self.stderr.write(msg, lambda x: x)
449             else:
450                 self.stdout.write(msg)
451 
452     def check_migrations(self):
453         """
454         Print a warning if the set of migrations on disk don't match the
455         migrations in the database.
456         """
457         from django.db.migrations.executor import MigrationExecutor
458         try:
459             executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS])
460         except ImproperlyConfigured:
461             # No databases are configured (or the dummy one)
462             return
463 
464         plan = executor.migration_plan(executor.loader.graph.leaf_nodes())
465         if plan:
466             apps_waiting_migration = sorted({migration.app_label for migration, backwards in plan})
467             self.stdout.write(
468                 self.style.NOTICE(
469                     "\nYou have %(unapplied_migration_count)s unapplied migration(s). "
470                     "Your project may not work properly until you apply the "
471                     "migrations for app(s): %(apps_waiting_migration)s." % {
472                         "unapplied_migration_count": len(plan),
473                         "apps_waiting_migration": ", ".join(apps_waiting_migration),
474                     }
475                 )
476             )
477             self.stdout.write(self.style.NOTICE("Run 'python manage.py migrate' to apply them."))
478 
479     def handle(self, *args, **options):
480         """
481         The actual logic of the command. Subclasses must implement
482         this method.
483         """
484         raise NotImplementedError('subclasses of BaseCommand must provide a handle() method')

</code><intended_behavior>This attribute should evolve into 'required_system_checks', with the default value of '__all__'. Instead of a boolean that enables or disables system checks globally, 'required_system_checks' will allow specifying which system checks to run. A value of '__all__' implies running all checks (preserving existing functionality), an empty list ([]) implies running no system checks (equivalent to False), and a list of specific tags (e.g., ['staticfiles', 'models']) would imply running only checks tagged accordingly. This change requires updating wherever 'requires_system_checks' is checked or utilized in the codebase, ensuring backward compatibility and clear documentation to guide developers on the new usage.</intended_behavior>, <file>django/core/management/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Base classes for writing management commands (named commands which can
3 be executed through ``django-admin`` or ``manage.py``).
4 """
5 import os
6 import sys
7 from argparse import ArgumentParser, HelpFormatter
8 from io import TextIOBase
9 
10 import django
11 from django.core import checks
12 from django.core.exceptions import ImproperlyConfigured
13 from django.core.management.color import color_style, no_style
14 from django.db import DEFAULT_DB_ALIAS, connections
15 
16 
17 class CommandError(Exception):
18     """
19     Exception class indicating a problem while executing a management
20     command.
21 
22     If this exception is raised during the execution of a management
23     command, it will be caught and turned into a nicely-printed error
24     message to the appropriate output stream (i.e., stderr); as a
25     result, raising this exception (with a sensible description of the
26     error) is the preferred way to indicate that something has gone
27     wrong in the execution of a command.
28     """
29     def __init__(self, *args, returncode=1, **kwargs):
30         self.returncode = returncode
31         super().__init__(*args, **kwargs)
32 
33 
34 class SystemCheckError(CommandError):
35     """
36     The system check framework detected unrecoverable errors.
37     """
38     pass
39 
40 
41 class CommandParser(ArgumentParser):
42     """
43     Customized ArgumentParser class to improve some error messages and prevent
44     SystemExit in several occasions, as SystemExit is unacceptable when a
45     command is called programmatically.
46     """
47     def __init__(self, *, missing_args_message=None, called_from_command_line=None, **kwargs):
48         self.missing_args_message = missing_args_message
49         self.called_from_command_line = called_from_command_line
50         super().__init__(**kwargs)
51 
52     def parse_args(self, args=None, namespace=None):
53         # Catch missing argument for a better error message
54         if (self.missing_args_message and
55                 not (args or any(not arg.startswith('-') for arg in args))):
56             self.error(self.missing_args_message)
57         return super().parse_args(args, namespace)
58 
59     def error(self, message):
60         if self.called_from_command_line:
61             super().error(message)
62         else:
63             raise CommandError("Error: %s" % message)
64 
65 
66 def handle_default_options(options):
67     """
68     Include any default options that all commands should accept here
69     so that ManagementUtility can handle them before searching for
70     user commands.
71     """
72     if options.settings:
73         os.environ['DJANGO_SETTINGS_MODULE'] = options.settings
74     if options.pythonpath:
75         sys.path.insert(0, options.pythonpath)
76 
77 
78 def no_translations(handle_func):
79     """Decorator that forces a command to run with translations deactivated."""
80     def wrapped(*args, **kwargs):
81         from django.utils import translation
82         saved_locale = translation.get_language()
83         translation.deactivate_all()
84         try:
85             res = handle_func(*args, **kwargs)
86         finally:
87             if saved_locale is not None:
88                 translation.activate(saved_locale)
89         return res
90     return wrapped
91 
92 
93 class DjangoHelpFormatter(HelpFormatter):
94     """
95     Customized formatter so that command-specific arguments appear in the
96     --help output before arguments common to all commands.
97     """
98     show_last = {
99         '--version', '--verbosity', '--traceback', '--settings', '--pythonpath',
100         '--no-color', '--force-color', '--skip-checks',
101     }
102 
103     def _reordered_actions(self, actions):
104         return sorted(
105             actions,
106             key=lambda a: set(a.option_strings) & self.show_last != set()
107         )
108 
109     def add_usage(self, usage, actions, *args, **kwargs):
110         super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)
111 
112     def add_arguments(self, actions):
113         super().add_arguments(self._reordered_actions(actions))
114 
115 
116 class OutputWrapper(TextIOBase):
117     """
118     Wrapper around stdout/stderr
119     """
120     @property
121     def style_func(self):
122         return self._style_func
123 
124     @style_func.setter
125     def style_func(self, style_func):
126         if style_func and self.isatty():
127             self._style_func = style_func
128         else:
129             self._style_func = lambda x: x
130 
131     def __init__(self, out, ending='\n'):
132         self._out = out
133         self.style_func = None
134         self.ending = ending
135 
136     def __getattr__(self, name):
137         return getattr(self._out, name)
138 
139     def isatty(self):
140         return hasattr(self._out, 'isatty') and self._out.isatty()
141 
142     def write(self, msg='', style_func=None, ending=None):
143         ending = self.ending if ending is None else ending
144         if ending and not msg.endswith(ending):
145             msg += ending
146         style_func = style_func or self.style_func
147         self._out.write(style_func(msg))
148 
149 
150 class BaseCommand:
151     """
152     The base class from which all management commands ultimately
153     derive.
154 
155     Use this class if you want access to all of the mechanisms which
156     parse the command-line arguments and work out what code to call in
157     response; if you don't need to change any of that behavior,
158     consider using one of the subclasses defined in this file.
159 
160     If you are interested in overriding/customizing various aspects of
161     the command-parsing and -execution behavior, the normal flow works
162     as follows:
163 
164     1. ``django-admin`` or ``manage.py`` loads the command class
165        and calls its ``run_from_argv()`` method.
166 
167     2. The ``run_from_argv()`` method calls ``create_parser()`` to get
168        an ``ArgumentParser`` for the arguments, parses them, performs
169        any environment changes requested by options like
170        ``pythonpath``, and then calls the ``execute()`` method,
171        passing the parsed arguments.
172 
173     3. The ``execute()`` method attempts to carry out the command by
174        calling the ``handle()`` method with the parsed arguments; any
175        output produced by ``handle()`` will be printed to standard
176        output and, if the command is intended to produce a block of
177        SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.
178 
179     4. If ``handle()`` or ``execute()`` raised any exception (e.g.
180        ``CommandError``), ``run_from_argv()`` will  instead print an error
181        message to ``stderr``.
182 
183     Thus, the ``handle()`` method is typically the starting point for
184     subclasses; many built-in commands and command types either place
185     all of their logic in ``handle()``, or perform some additional
186     parsing work in ``handle()`` and then delegate from it to more
187     specialized methods as needed.
188 
189     Several attributes affect behavior at various steps along the way:
190 
191     ``help``
192         A short description of the command, which will be printed in
193         help messages.
194 
195     ``output_transaction``
196         A boolean indicating whether the command outputs SQL
197         statements; if ``True``, the output will automatically be
198         wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is
199         ``False``.
200 
201     ``requires_migrations_checks``
202         A boolean; if ``True``, the command prints a warning if the set of
203         migrations on disk don't match the migrations in the database.
204 
205     ``requires_system_checks``
206         A boolean; if ``True``, entire Django project will be checked for errors
207         prior to executing the command. Default value is ``True``.
208         To validate an individual application's models
209         rather than all applications' models, call
210         ``self.check(app_configs)`` from ``handle()``, where ``app_configs``
211         is the list of application's configuration provided by the
212         app registry.
213 
214     ``stealth_options``
215         A tuple of any options the command uses which aren't defined by the
216         argument parser.
217     """
218     # Metadata about this command.
219     help = ''
220 
221     # Configuration shortcuts that alter various logic.
222     _called_from_command_line = False
223     output_transaction = False  # Whether to wrap the output in a "BEGIN; COMMIT;"
224     requires_migrations_checks = False
225     requires_system_checks = True
226     # Arguments, common to all commands, which aren't defined by the argument
227     # parser.
228     base_stealth_options = ('stderr', 'stdout')
229     # Command-specific options not defined by the argument parser.
230     stealth_options = ()
231 
232     def __init__(self, stdout=None, stderr=None, no_color=False, force_color=False):
233         self.stdout = OutputWrapper(stdout or sys.stdout)
234         self.stderr = OutputWrapper(stderr or sys.stderr)
235         if no_color and force_color:
236             raise CommandError("'no_color' and 'force_color' can't be used together.")
237         if no_color:
238             self.style = no_style()
239         else:
240             self.style = color_style(force_color)
241             self.stderr.style_func = self.style.ERROR
242 
243     def get_version(self):
244         """
245         Return the Django version, which should be correct for all built-in
246         Django commands. User-supplied commands can override this method to
247         return their own version.
248         """
249         return django.get_version()
250 
251     def create_parser(self, prog_name, subcommand, **kwargs):
252         """
253         Create and return the ``ArgumentParser`` which will be used to
254         parse the arguments to this command.
255         """
256         parser = CommandParser(
257             prog='%s %s' % (os.path.basename(prog_name), subcommand),
258             description=self.help or None,
259             formatter_class=DjangoHelpFormatter,
260             missing_args_message=getattr(self, 'missing_args_message', None),
261             called_from_command_line=getattr(self, '_called_from_command_line', None),
262             **kwargs
263         )
264         parser.add_argument('--version', action='version', version=self.get_version())
265         parser.add_argument(
266             '-v', '--verbosity', default=1,
267             type=int, choices=[0, 1, 2, 3],
268             help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output',
269         )
270         parser.add_argument(
271             '--settings',
272             help=(
273                 'The Python path to a settings module, e.g. '
274                 '"myproject.settings.main". If this isn\'t provided, the '
275                 'DJANGO_SETTINGS_MODULE environment variable will be used.'
276             ),
277         )
278         parser.add_argument(
279             '--pythonpath',
280             help='A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".',
281         )
282         parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')
283         parser.add_argument(
284             '--no-color', action='store_true',
285             help="Don't colorize the command output.",
286         )
287         parser.add_argument(
288             '--force-color', action='store_true',
289             help='Force colorization of the command output.',
290         )
291         if self.requires_system_checks:
292             parser.add_argument(
293                 '--skip-checks', action='store_true',
294                 help='Skip system checks.',
295             )
296         self.add_arguments(parser)
297         return parser
298 
299     def add_arguments(self, parser):
300         """
301         Entry point for subclassed commands to add custom arguments.
302         """
303         pass
304 
305     def print_help(self, prog_name, subcommand):
306         """
307         Print the help message for this command, derived from
308         ``self.usage()``.
309         """
310         parser = self.create_parser(prog_name, subcommand)
311         parser.print_help()
312 
313     def run_from_argv(self, argv):
314         """
315         Set up any environment changes requested (e.g., Python path
316         and Django settings), then run this command. If the
317         command raises a ``CommandError``, intercept it and print it sensibly
318         to stderr. If the ``--traceback`` option is present or the raised
319         ``Exception`` is not ``CommandError``, raise it.
320         """
321         self._called_from_command_line = True
322         parser = self.create_parser(argv[0], argv[1])
323 
324         options = parser.parse_args(argv[2:])
325         cmd_options = vars(options)
326         # Move positional args out of options to mimic legacy optparse
327         args = cmd_options.pop('args', ())
328         handle_default_options(options)
329         try:
330             self.execute(*args, **cmd_options)
331         except CommandError as e:
332             if options.traceback:
333                 raise
334 
335             # SystemCheckError takes care of its own formatting.
336             if isinstance(e, SystemCheckError):
337                 self.stderr.write(str(e), lambda x: x)
338             else:
339                 self.stderr.write('%s: %s' % (e.__class__.__name__, e))
340             sys.exit(e.returncode)
341         finally:
342             try:
343                 connections.close_all()
344             except ImproperlyConfigured:
345                 # Ignore if connections aren't setup at this point (e.g. no
346                 # configured settings).
347                 pass
348 
349     def execute(self, *args, **options):
350         """
351         Try to execute this command, performing system checks if needed (as
352         controlled by the ``requires_system_checks`` attribute, except if
353         force-skipped).
354         """
355         if options['force_color'] and options['no_color']:
356             raise CommandError("The --no-color and --force-color options can't be used together.")
357         if options['force_color']:
358             self.style = color_style(force_color=True)
359         elif options['no_color']:
360             self.style = no_style()
361             self.stderr.style_func = None
362         if options.get('stdout'):
363             self.stdout = OutputWrapper(options['stdout'])
364         if options.get('stderr'):
365             self.stderr = OutputWrapper(options['stderr'])
366 
367         if self.requires_system_checks and not options['skip_checks']:
368             self.check()
369         if self.requires_migrations_checks:
370             self.check_migrations()
371         output = self.handle(*args, **options)
372         if output:
373             if self.output_transaction:
374                 connection = connections[options.get('database', DEFAULT_DB_ALIAS)]
375                 output = '%s\n%s\n%s' % (
376                     self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()),
377                     output,
378                     self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()),
379                 )
380             self.stdout.write(output)
381         return output
382 
383     def check(self, app_configs=None, tags=None, display_num_errors=False,
384               include_deployment_checks=False, fail_level=checks.ERROR,
385               databases=None):
386         """
387         Use the system check framework to validate entire Django project.
388         Raise CommandError for any serious message (error or critical errors).
389         If there are only light messages (like warnings), print them to stderr
390         and don't raise an exception.
391         """
392         all_issues = checks.run_checks(
393             app_configs=app_configs,
394             tags=tags,
395             include_deployment_checks=include_deployment_checks,
396             databases=databases,
397         )
398 
399         header, body, footer = "", "", ""
400         visible_issue_count = 0  # excludes silenced warnings
401 
402         if all_issues:
403             debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced()]
404             infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced()]
405             warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced()]
406             errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced()]
407             criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced()]
408             sorted_issues = [
409                 (criticals, 'CRITICALS'),
410                 (errors, 'ERRORS'),
411                 (warnings, 'WARNINGS'),
412                 (infos, 'INFOS'),
413                 (debugs, 'DEBUGS'),
414             ]
415 
416             for issues, group_name in sorted_issues:
417                 if issues:
418                     visible_issue_count += len(issues)
419                     formatted = (
420                         self.style.ERROR(str(e))
421                         if e.is_serious()
422                         else self.style.WARNING(str(e))
423                         for e in issues)
424                     formatted = "\n".join(sorted(formatted))
425                     body += '\n%s:\n%s\n' % (group_name, formatted)
426 
427         if visible_issue_count:
428             header = "System check identified some issues:\n"
429 
430         if display_num_errors:
431             if visible_issue_count:
432                 footer += '\n'
433             footer += "System check identified %s (%s silenced)." % (
434                 "no issues" if visible_issue_count == 0 else
435                 "1 issue" if visible_issue_count == 1 else
436                 "%s issues" % visible_issue_count,
437                 len(all_issues) - visible_issue_count,
438             )
439 
440         if any(e.is_serious(fail_level) and not e.is_silenced() for e in all_issues):
441             msg = self.style.ERROR("SystemCheckError: %s" % header) + body + footer
442             raise SystemCheckError(msg)
443         else:
444             msg = header + body + footer
445 
446         if msg:
447             if visible_issue_count:
448                 self.stderr.write(msg, lambda x: x)
449             else:
450                 self.stdout.write(msg)
451 
452     def check_migrations(self):
453         """
454         Print a warning if the set of migrations on disk don't match the
455         migrations in the database.
456         """
457         from django.db.migrations.executor import MigrationExecutor
458         try:
459             executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS])
460         except ImproperlyConfigured:
461             # No databases are configured (or the dummy one)
462             return
463 
464         plan = executor.migration_plan(executor.loader.graph.leaf_nodes())
465         if plan:
466             apps_waiting_migration = sorted({migration.app_label for migration, backwards in plan})
467             self.stdout.write(
468                 self.style.NOTICE(
469                     "\nYou have %(unapplied_migration_count)s unapplied migration(s). "
470                     "Your project may not work properly until you apply the "
471                     "migrations for app(s): %(apps_waiting_migration)s." % {
472                         "unapplied_migration_count": len(plan),
473                         "apps_waiting_migration": ", ".join(apps_waiting_migration),
474                     }
475                 )
476             )
477             self.stdout.write(self.style.NOTICE("Run 'python manage.py migrate' to apply them."))
478 
479     def handle(self, *args, **options):
480         """
481         The actual logic of the command. Subclasses must implement
482         this method.
483         """
484         raise NotImplementedError('subclasses of BaseCommand must provide a handle() method')
485 
486 
487 class AppCommand(BaseCommand):
488     """
489     A management command which takes one or more installed application labels
490     as arguments, and does something with each of them.
491 
492     Rather than implementing ``handle()``, subclasses must implement
493     ``handle_app_config()``, which will be called once for each application.
494     """
495     missing_args_message = "Enter at least one application label."
496 
497     def add_arguments(self, parser):
498         parser.add_argument('args', metavar='app_label', nargs='+', help='One or more application label.')
499 
500     def handle(self, *app_labels, **options):
501         from django.apps import apps
502         try:
503             app_configs = [apps.get_app_config(app_label) for app_label in app_labels]
504         except (LookupError, ImportError) as e:
505             raise CommandError("%s. Are you sure your INSTALLED_APPS setting is correct?" % e)
506         output = []
507         for app_config in app_configs:
508             app_output = self.handle_app_config(app_config, **options)
509             if app_output:
510                 output.append(app_output)
511         return '\n'.join(output)
512 
513     def handle_app_config(self, app_config, **options):
514         """
515         Perform the command's actions for app_config, an AppConfig instance
516         corresponding to an application label given on the command line.
517         """
518         raise NotImplementedError(
519             "Subclasses of AppCommand must provide"
520             "a handle_app_config() method.")
521 
522 
523 class LabelCommand(BaseCommand):
524     """
525     A management command which takes one or more arbitrary arguments
526     (labels) on the command line, and does something with each of
527     them.
528 
529     Rather than implementing ``handle()``, subclasses must implement
530     ``handle_label()``, which will be called once for each label.
531 
532     If the arguments should be names of installed applications, use
533     ``AppCommand`` instead.
534     """
535     label = 'label'
536     missing_args_message = "Enter at least one %s." % label
537 
538     def add_arguments(self, parser):
539         parser.add_argument('args', metavar=self.label, nargs='+')
540 
541     def handle(self, *labels, **options):
542         output = []
543         for label in labels:
544             label_output = self.handle_label(label, **options)
545             if label_output:
546                 output.append(label_output)
547         return '\n'.join(output)
548 
549     def handle_label(self, label, **options):
550         """
551         Perform the command's actions for ``label``, which will be the
552         string as given on the command line.
553         """
554         raise NotImplementedError('subclasses of LabelCommand must provide a handle_label() method')

</code><intended_behavior>Any method that currently inspects 'requires_system_checks' should be updated to interpret 'required_system_checks'. This includes methods that might directly or indirectly trigger system checks before a command's execution. The handling logic should: Support the '__all__' value to run all checks, support an empty list ([]) to skip all checks, correctly interpret and filter checks based on a provided list of tags, and ensure that any command-specific logic that previously depended on the boolean 'requires_system_checks' to bypass checks is now compatible with the new scheme.</intended_behavior>]
2025-10-18 11:37:04.076 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 11:37:04.076 | INFO     | Search-only: skipping patch selection
2025-10-18 11:37:04.217 | INFO     | Task django__django-12910 completed successfully.
2025-10-18 11:37:04.218 | INFO     | No patch generated. You can try running ACR again.
