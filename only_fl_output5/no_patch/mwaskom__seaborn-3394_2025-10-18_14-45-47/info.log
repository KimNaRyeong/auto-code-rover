2025-10-18 14:45:47.184 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 14:45:49.742 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=535, output_tokens=12, cost=0.005710
2025-10-18 14:46:03.286 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=715, output_tokens=597, cost=0.025060
2025-10-18 14:46:04.297 | INFO     | registered non reproducing test 0
2025-10-18 14:46:20.837 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1662, output_tokens=727, cost=0.038430
2025-10-18 14:46:21.804 | INFO     | registered non reproducing test 1
2025-10-18 14:46:35.555 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1757, output_tokens=635, cost=0.036620
2025-10-18 14:46:36.522 | INFO     | registered non reproducing test 2
2025-10-18 14:46:36.522 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 14:46:36.529 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:46:43.949 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=834, output_tokens=337, cost=0.018450
2025-10-18 14:46:43.956 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:46:46.817 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=691, output_tokens=62, cost=0.008770
2025-10-18 14:46:46.818 | DEBUG    | Extracted a valid json.
2025-10-18 14:46:46.818 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"FacetGrid\")",
        "search_code(\"sns.lineplot\")",
        "search_code(\"pd.concat\")",
        "search_code_in_file(\"plt.show()\", \"matplotlib_integration.py\")"
    ],
    "bug_locations": []
}
2025-10-18 14:46:46.841 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:46:46.842 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:47:01.510 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1556, output_tokens=694, cost=0.036380
2025-10-18 14:47:01.523 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:47:09.493 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2466, output_tokens=347, cost=0.035070
2025-10-18 14:47:09.501 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:47:16.200 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=701, output_tokens=245, cost=0.014360
2025-10-18 14:47:16.201 | DEBUG    | Extracted a valid json.
2025-10-18 14:47:16.201 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "seaborn/_core/plot.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely contains functions or methods that prepare data for plotting, including handling of missing values. The code should ensure that missing values (`pd.NA` or `np.nan`) do not influence the sorting or ordering of axes in plots. A specific method within this could potentially be handling data frames before they are plotted, which would need to be adjusted to uniformly treat `pd.NA` and `np.nan` to maintain axis ordering."
        },
        {
            "file": "seaborn/_core/data.py",
            "class": "",
            "method": "",
            "intended_behavior": "As this file likely involves data manipulation and preparation for plotting, it should properly manage datasets with missing values, ensuring that insertion of `pd.NA` does not lead to reversed axes. Updating or refining the method to handle `pd.NA` equivalently to `np.nan`, especially in regards to data sorting and ordering for plotting, could resolve the issue."
        }
    ]
}
2025-10-18 14:47:16.212 | DEBUG    | Bug location extracted successfully: [<file>seaborn/_core/plot.py</file>
<class>None</class>
<method>None</method>
<code>
1 """The classes for specifying and compiling a declarative visualization."""
2 from __future__ import annotations
3 
4 import io
5 import os
6 import re
7 import inspect
8 import itertools
9 import textwrap
10 from contextlib import contextmanager
11 from collections import abc
12 from collections.abc import Callable, Generator
13 from typing import Any, List, Literal, Optional, cast
14 from xml.etree import ElementTree
15 
16 from cycler import cycler
17 import pandas as pd
18 from pandas import DataFrame, Series, Index
19 import matplotlib as mpl
20 from matplotlib.axes import Axes
21 from matplotlib.artist import Artist
22 from matplotlib.figure import Figure
23 from PIL import Image
24 
25 from seaborn._marks.base import Mark
26 from seaborn._stats.base import Stat
27 from seaborn._core.data import PlotData
28 from seaborn._core.moves import Move
29 from seaborn._core.scales import Scale, Nominal
30 from seaborn._core.subplots import Subplots
31 from seaborn._core.groupby import GroupBy
32 from seaborn._core.properties import PROPERTIES, Property
33 from seaborn._core.typing import (
34     DataSource,
35     VariableSpec,
36     VariableSpecList,
37     OrderSpec,
38     Default,
39 )
40 from seaborn._core.exceptions import PlotSpecError
41 from seaborn._core.rules import categorical_order
42 from seaborn._compat import set_scale_obj, set_layout_engine
43 from seaborn.rcmod import axes_style, plotting_context
44 from seaborn.palettes import color_palette
45 from seaborn.utils import _version_predates
46 
47 from typing import TYPE_CHECKING, TypedDict
48 if TYPE_CHECKING:
49     from matplotlib.figure import SubFigure
50 
51 
52 default = Default()
53 
54 
55 # ---- Definitions for internal specs ---------------------------------------------- #
56 
57 
58 class Layer(TypedDict, total=False):
59 
60     mark: Mark  # TODO allow list?
61     stat: Stat | None  # TODO allow list?
62     move: Move | list[Move] | None
63     data: PlotData
64     source: DataSource
65     vars: dict[str, VariableSpec]
66     orient: str
67     legend: bool
68 
69 
70 class FacetSpec(TypedDict, total=False):
71 
72     variables: dict[str, VariableSpec]
73     structure: dict[str, list[str]]
74     wrap: int | None
75 
76 
77 class PairSpec(TypedDict, total=False):
78 
79     variables: dict[str, VariableSpec]
80     structure: dict[str, list[str]]
81     cross: bool
82     wrap: int | None
83 
84 
85 # --- Local helpers ---------------------------------------------------------------- #
86 
87 
88 @contextmanager
89 def theme_context(params: dict[str, Any]) -> Generator:
90     """Temporarily modify specifc matplotlib rcParams."""
91     orig_params = {k: mpl.rcParams[k] for k in params}
92     color_codes = "bgrmyck"
93     nice_colors = [*color_palette("deep6"), (.15, .15, .15)]
94     orig_colors = [mpl.colors.colorConverter.colors[x] for x in color_codes]
95     # TODO how to allow this to reflect the color cycle when relevant?
96     try:
97         mpl.rcParams.update(params)
98         for (code, color) in zip(color_codes, nice_colors):
99             mpl.colors.colorConverter.colors[code] = color
100         yield
101     finally:
102         mpl.rcParams.update(orig_params)
103         for (code, color) in zip(color_codes, orig_colors):
104             mpl.colors.colorConverter.colors[code] = color
105 
106 
107 def build_plot_signature(cls):
108     """
109     Decorator function for giving Plot a useful signature.
110 
111     Currently this mostly saves us some duplicated typing, but we would
112     like eventually to have a way of registering new semantic properties,
113     at which point dynamic signature generation would become more important.
114 
115     """
116     sig = inspect.signature(cls)
117     params = [
118         inspect.Parameter("args", inspect.Parameter.VAR_POSITIONAL),
119         inspect.Parameter("data", inspect.Parameter.KEYWORD_ONLY, default=None)
120     ]
121     params.extend([
122         inspect.Parameter(name, inspect.Parameter.KEYWORD_ONLY, default=None)
123         for name in PROPERTIES
124     ])
125     new_sig = sig.replace(parameters=params)
126     cls.__signature__ = new_sig
127 
128     known_properties = textwrap.fill(
129         ", ".join([f"|{p}|" for p in PROPERTIES]),
130         width=78, subsequent_indent=" " * 8,
131     )
132 
133     if cls.__doc__ is not None:  # support python -OO mode
134         cls.__doc__ = cls.__doc__.format(known_properties=known_properties)
135 
136     return cls
137 
138 
139 # ---- Plot configuration ---------------------------------------------------------- #
140 
141 
142 class ThemeConfig(mpl.RcParams):
143     """
144     Configuration object for the Plot.theme, using matplotlib rc parameters.
145     """
146     THEME_GROUPS = [
147         "axes", "figure", "font", "grid", "hatch", "legend", "lines",
148         "mathtext", "markers", "patch", "savefig", "scatter",
149         "xaxis", "xtick", "yaxis", "ytick",
150     ]
151 
152     def __init__(self):
153         super().__init__()
154         self.reset()
155 
156     @property
157     def _default(self) -> dict[str, Any]:
158 
159         return {
160             **self._filter_params(mpl.rcParamsDefault),
161             **axes_style("darkgrid"),
162             **plotting_context("notebook"),
163             "axes.prop_cycle": cycler("color", color_palette("deep")),
164         }
165 
166     def reset(self) -> None:
167         """Update the theme dictionary with seaborn's default values."""
168         self.update(self._default)
169 
170     def update(self, other: dict[str, Any] | None = None, /, **kwds):
171         """Update the theme with a dictionary or keyword arguments of rc parameters."""
172         if other is not None:
173             theme = self._filter_params(other)
174         else:
175             theme = {}
176         theme.update(kwds)
177         super().update(theme)
178 
179     def _filter_params(self, params: dict[str, Any]) -> dict[str, Any]:
180         """Restruct to thematic rc params."""
181         return {
182             k: v for k, v in params.items()
183             if any(k.startswith(p) for p in self.THEME_GROUPS)
184         }
185 
186     def _html_table(self, params: dict[str, Any]) -> list[str]:
187 
188         lines = ["<table>"]
189         for k, v in params.items():
190             row = f"<tr><td>{k}:</td><td style='text-align:left'>{v!r}</td></tr>"
191             lines.append(row)
192         lines.append("</table>")
193         return lines
194 
195     def _repr_html_(self) -> str:
196 
197         repr = [
198             "<div style='height: 300px'>",
199             "<div style='border-style: inset; border-width: 2px'>",
200             *self._html_table(self),
201             "</div>",
202             "</div>",
203         ]
204         return "\n".join(repr)
205 
206 
207 class DisplayConfig(TypedDict):
208     """Configuration for IPython's rich display hooks."""
209     format: Literal["png", "svg"]
210     scaling: float
211     hidpi: bool
212 
213 
214 class PlotConfig:
215     """Configuration for default behavior / appearance of class:`Plot` instances."""
216     def __init__(self):
217 
218         self._theme = ThemeConfig()
219         self._display = {"format": "png", "scaling": .85, "hidpi": True}
220 
221     @property
222     def theme(self) -> dict[str, Any]:
223         """
224         Dictionary of base theme parameters for :class:`Plot`.
225 
226         Keys and values correspond to matplotlib rc params, as documented here:
227         https://matplotlib.org/stable/tutorials/introductory/customizing.html
228 
229         """
230         return self._theme
231 
232     @property
233     def display(self) -> DisplayConfig:
234         """
235         Dictionary of parameters for rich display in Jupyter notebook.
236 
237         Valid parameters:
238 
239         - format ("png" or "svg"): Image format to produce
240         - scaling (float): Relative scaling of embedded image
241         - hidpi (bool): When True, double the DPI while preserving the size
242 
243         """
244         return self._display
245 
246 
247 # ---- The main interface for declarative plotting --------------------------------- #
248 
249 
250 @build_plot_signature
251 class Plot:
252     """
253     An interface for declaratively specifying statistical graphics.
254 
255     Plots are constructed by initializing this class and adding one or more
256     layers, comprising a `Mark` and optional `Stat` or `Move`.  Additionally,
257     faceting variables or variable pairings may be defined to divide the space
258     into multiple subplots. The mappings from data values to visual properties
259     can be parametrized using scales, although the plot will try to infer good
260     defaults when scales are not explicitly defined.
261 
262     The constructor accepts a data source (a :class:`pandas.DataFrame` or
263     dictionary with columnar values) and variable assignments. Variables can be
264     passed as keys to the data source or directly as data vectors.  If multiple
265     data-containing objects are provided, they will be index-aligned.
266 
267     The data source and variables defined in the constructor will be used for
268     all layers in the plot, unless overridden or disabled when adding a layer.
269 
270     The following variables can be defined in the constructor:
271         {known_properties}
272 
273     The `data`, `x`, and `y` variables can be passed as positional arguments or
274     using keywords. Whether the first positional argument is interpreted as a
275     data source or `x` variable depends on its type.
276 
277     The methods of this class return a copy of the instance; use chaining to
278     build up a plot through multiple calls. Methods can be called in any order.
279 
280     Most methods only add information to the plot spec; no actual processing
281     happens until the plot is shown or saved. It is also possible to compile
282     the plot without rendering it to access the lower-level representation.
283 
284     """
285     config = PlotConfig()
286 
287     _data: PlotData
288     _layers: list[Layer]
289 
290     _scales: dict[str, Scale]
291     _shares: dict[str, bool | str]
292     _limits: dict[str, tuple[Any, Any]]
293     _labels: dict[str, str | Callable[[str], str]]
294     _theme: dict[str, Any]
295 
296     _facet_spec: FacetSpec
297     _pair_spec: PairSpec
298 
299     _figure_spec: dict[str, Any]
300     _subplot_spec: dict[str, Any]
301     _layout_spec: dict[str, Any]
302 
303     def __init__(
304         self,
305         *args: DataSource | VariableSpec,
306         data: DataSource = None,
307         **variables: VariableSpec,
308     ):
309 
310         if args:
311             data, variables = self._resolve_positionals(args, data, variables)
312 
313         unknown = [x for x in variables if x not in PROPERTIES]
314         if unknown:
315             err = f"Plot() got unexpected keyword argument(s): {', '.join(unknown)}"
316             raise TypeError(err)
317 
318         self._data = PlotData(data, variables)
319 
320         self._layers = []
321 
322         self._scales = {}
323         self._shares = {}
324         self._limits = {}
325         self._labels = {}
326         self._theme = {}
327 
328         self._facet_spec = {}
329         self._pair_spec = {}
330 
331         self._figure_spec = {}
332         self._subplot_spec = {}
333         self._layout_spec = {}
334 
335         self._target = None
336 
337     def _resolve_positionals(
338         self,
339         args: tuple[DataSource | VariableSpec, ...],
340         data: DataSource,
341         variables: dict[str, VariableSpec],
342     ) -> tuple[DataSource, dict[str, VariableSpec]]:
343         """Handle positional arguments, which may contain data / x / y."""
344         if len(args) > 3:
345             err = "Plot() accepts no more than 3 positional arguments (data, x, y)."
346             raise TypeError(err)
347 
348         # TODO need some clearer way to differentiate data / vector here
349         # (There might be an abstract DataFrame class to use here?)
350         if isinstance(args[0], (abc.Mapping, pd.DataFrame)):
351             if data is not None:
352                 raise TypeError("`data` given by both name and position.")
353             data, args = args[0], args[1:]
354 
355         if len(args) == 2:
356             x, y = args
357         elif len(args) == 1:
358             x, y = *args, None
359         else:
360             x = y = None
361 
362         for name, var in zip("yx", (y, x)):
363             if var is not None:
364                 if name in variables:
365                     raise TypeError(f"`{name}` given by both name and position.")
366                 # Keep coordinates at the front of the variables dict
367                 # Cast type because we know this isn't a DataSource at this point
368                 variables = {name: cast(VariableSpec, var), **variables}
369 
370         return data, variables
371 
372     def __add__(self, other):
373 
374         if isinstance(other, Mark) or isinstance(other, Stat):
375             raise TypeError("Sorry, this isn't ggplot! Perhaps try Plot.add?")
376 
377         other_type = other.__class__.__name__
378         raise TypeError(f"Unsupported operand type(s) for +: 'Plot' and '{other_type}")
379 
380     def _repr_png_(self) -> tuple[bytes, dict[str, float]] | None:
381 
382         if Plot.config.display["format"] != "png":
383             return None
384         return self.plot()._repr_png_()
385 
386     def _repr_svg_(self) -> str | None:
387 
388         if Plot.config.display["format"] != "svg":
389             return None
390         return self.plot()._repr_svg_()
391 
392     def _clone(self) -> Plot:
393         """Generate a new object with the same information as the current spec."""
394         new = Plot()
395 
396         # TODO any way to enforce that data does not get mutated?
397         new._data = self._data
398 
399         new._layers.extend(self._layers)
400 
401         new._scales.update(self._scales)
402         new._shares.update(self._shares)
403         new._limits.update(self._limits)
404         new._labels.update(self._labels)
405         new._theme.update(self._theme)
406 
407         new._facet_spec.update(self._facet_spec)
408         new._pair_spec.update(self._pair_spec)
409 
410         new._figure_spec.update(self._figure_spec)
411         new._subplot_spec.update(self._subplot_spec)
412         new._layout_spec.update(self._layout_spec)
413 
414         new._target = self._target
415 
416         return new
417 
418     def _theme_with_defaults(self) -> dict[str, Any]:
419 
420         theme = self.config.theme.copy()
421         theme.update(self._theme)
422         return theme
423 
424     @property
425     def _variables(self) -> list[str]:
426 
427         variables = (
428             list(self._data.frame)
429             + list(self._pair_spec.get("variables", []))
430             + list(self._facet_spec.get("variables", []))
431         )
432         for layer in self._layers:
433             variables.extend(v for v in layer["vars"] if v not in variables)
434 
435         # Coerce to str in return to appease mypy; we know these will only
436         # ever be strings but I don't think we can type a DataFrame that way yet
437         return [str(v) for v in variables]
438 
439     def on(self, target: Axes | SubFigure | Figure) -> Plot:
440         """
441         Provide existing Matplotlib figure or axes for drawing the plot.
442 
443         When using this method, you will also need to explicitly call a method that
444         triggers compilation, such as :meth:`Plot.show` or :meth:`Plot.save`. If you
445         want to postprocess using matplotlib, you'd need to call :meth:`Plot.plot`
446         first to compile the plot without rendering it.
447 
448         Parameters
449         ----------
450         target : Axes, SubFigure, or Figure
451             Matplotlib object to use. Passing :class:`matplotlib.axes.Axes` will add
452             artists without otherwise modifying the figure. Otherwise, subplots will be
453             created within the space of the given :class:`matplotlib.figure.Figure` or
454             :class:`matplotlib.figure.SubFigure`.
455 
456         Examples
457         --------
458         .. include:: ../docstrings/objects.Plot.on.rst
459 
460         """
461         accepted_types: tuple  # Allow tuple of various length
462         if hasattr(mpl.figure, "SubFigure"):  # Added in mpl 3.4
463             accepted_types = (
464                 mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure
465             )
466             accepted_types_str = (
467                 f"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}"
468             )
469         else:
470             accepted_types = mpl.axes.Axes, mpl.figure.Figure
471             accepted_types_str = f"{mpl.axes.Axes} or {mpl.figure.Figure}"
472 
473         if not isinstance(target, accepted_types):
474             err = (
475                 f"The `Plot.on` target must be an instance of {accepted_types_str}. "
476                 f"You passed an instance of {target.__class__} instead."
477             )
478             raise TypeError(err)
479 
480         new = self._clone()
481         new._target = target
482 
483         return new
484 
485     def add(
486         self,
487         mark: Mark,
488         *transforms: Stat | Mark,
489         orient: str | None = None,
490         legend: bool = True,
491         data: DataSource = None,
492         **variables: VariableSpec,
493     ) -> Plot:
494         """
495         Specify a layer of the visualization in terms of mark and data transform(s).
496 
497         This is the main method for specifying how the data should be visualized.
498         It can be called multiple times with different arguments to define
499         a plot with multiple layers.
500 
501         Parameters
502         ----------
503         mark : :class:`Mark`
504             The visual representation of the data to use in this layer.
505         transforms : :class:`Stat` or :class:`Move`
506             Objects representing transforms to be applied before plotting the data.
507             Currently, at most one :class:`Stat` can be used, and it
508             must be passed first. This constraint will be relaxed in the future.
509         orient : "x", "y", "v", or "h"
510             The orientation of the mark, which also affects how transforms are computed.
511             Typically corresponds to the axis that defines groups for aggregation.
512             The "v" (vertical) and "h" (horizontal) options are synonyms for "x" / "y",
513             but may be more intuitive with some marks. When not provided, an
514             orientation will be inferred from characteristics of the data and scales.
515         legend : bool
516             Option to suppress the mark/mappings for this layer from the legend.
517         data : DataFrame or dict
518             Data source to override the global source provided in the constructor.
519         variables : data vectors or identifiers
520             Additional layer-specific variables, including variables that will be
521             passed directly to the transforms without scaling.
522 
523         Examples
524         --------
525         .. include:: ../docstrings/objects.Plot.add.rst
526 
527         """
528         if not isinstance(mark, Mark):
529             msg = f"mark must be a Mark instance, not {type(mark)!r}."
530             raise TypeError(msg)
531 
532         # TODO This API for transforms was a late decision, and previously Plot.add
533         # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.
534         # It will take some work to refactor the internals so that Stat and Move are
535         # treated identically, and until then well need to "unpack" the transforms
536         # here and enforce limitations on the order / types.
537 
538         stat: Optional[Stat]
539         move: Optional[List[Move]]
540         error = False
541         if not transforms:
542             stat, move = None, None
543         elif isinstance(transforms[0], Stat):
544             stat = transforms[0]
545             move = [m for m in transforms[1:] if isinstance(m, Move)]
546             error = len(move) != len(transforms) - 1
547         else:
548             stat = None
549             move = [m for m in transforms if isinstance(m, Move)]
550             error = len(move) != len(transforms)
551 
552         if error:
553             msg = " ".join([
554                 "Transforms must have at most one Stat type (in the first position),",
555                 "and all others must be a Move type. Given transform type(s):",
556                 ", ".join(str(type(t).__name__) for t in transforms) + "."
557             ])
558             raise TypeError(msg)
559 
560         new = self._clone()
561         new._layers.append({
562             "mark": mark,
563             "stat": stat,
564             "move": move,
565             # TODO it doesn't work to supply scalars to variables, but it should
566             "vars": variables,
567             "source": data,
568             "legend": legend,
569             "orient": {"v": "x", "h": "y"}.get(orient, orient),  # type: ignore
570         })
571 
572         return new
573 
574     def pair(
575         self,
576         x: VariableSpecList = None,
577         y: VariableSpecList = None,
578         wrap: int | None = None,
579         cross: bool = True,
580     ) -> Plot:
581         """
582         Produce subplots by pairing multiple `x` and/or `y` variables.
583 
584         Parameters
585         ----------
586         x, y : sequence(s) of data vectors or identifiers
587             Variables that will define the grid of subplots.
588         wrap : int
589             When using only `x` or `y`, "wrap" subplots across a two-dimensional grid
590             with this many columns (when using `x`) or rows (when using `y`).
591         cross : bool
592             When False, zip the `x` and `y` lists such that the first subplot gets the
593             first pair, the second gets the second pair, etc. Otherwise, create a
594             two-dimensional grid from the cartesian product of the lists.
595 
596         Examples
597         --------
598         .. include:: ../docstrings/objects.Plot.pair.rst
599 
600         """
601         # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows
602         # This may also be possible by setting `wrap=1`, but is that too unobvious?
603         # TODO PairGrid features not currently implemented: diagonals, corner
604 
605         pair_spec: PairSpec = {}
606 
607         axes = {"x": [] if x is None else x, "y": [] if y is None else y}
608         for axis, arg in axes.items():
609             if isinstance(arg, (str, int)):
610                 err = f"You must pass a sequence of variable keys to `{axis}`"
611                 raise TypeError(err)
612 
613         pair_spec["variables"] = {}
614         pair_spec["structure"] = {}
615 
616         for axis in "xy":
617             keys = []
618             for i, col in enumerate(axes[axis]):
619                 key = f"{axis}{i}"
620                 keys.append(key)
621                 pair_spec["variables"][key] = col
622 
623             if keys:
624                 pair_spec["structure"][axis] = keys
625 
626         if not cross and len(axes["x"]) != len(axes["y"]):
627             err = "Lengths of the `x` and `y` lists must match with cross=False"
628             raise ValueError(err)
629 
630         pair_spec["cross"] = cross
631         pair_spec["wrap"] = wrap
632 
633         new = self._clone()
634         new._pair_spec.update(pair_spec)
635         return new
636 
637     def facet(
638         self,
639         col: VariableSpec = None,
640         row: VariableSpec = None,
641         order: OrderSpec | dict[str, OrderSpec] = None,
642         wrap: int | None = None,
643     ) -> Plot:
644         """
645         Produce subplots with conditional subsets of the data.
646 
647         Parameters
648         ----------
649         col, row : data vectors or identifiers
650             Variables used to define subsets along the columns and/or rows of the grid.
651             Can be references to the global data source passed in the constructor.
652         order : list of strings, or dict with dimensional keys
653             Define the order of the faceting variables.
654         wrap : int
655             When using only `col` or `row`, wrap subplots across a two-dimensional
656             grid with this many subplots on the faceting dimension.
657 
658         Examples
659         --------
660         .. include:: ../docstrings/objects.Plot.facet.rst
661 
662         """
663         variables: dict[str, VariableSpec] = {}
664         if col is not None:
665             variables["col"] = col
666         if row is not None:
667             variables["row"] = row
668 
669         structure = {}
670         if isinstance(order, dict):
671             for dim in ["col", "row"]:
672                 dim_order = order.get(dim)
673                 if dim_order is not None:
674                     structure[dim] = list(dim_order)
675         elif order is not None:
676             if col is not None and row is not None:
677                 err = " ".join([
678                     "When faceting on both col= and row=, passing `order` as a list"
679                     "is ambiguous. Use a dict with 'col' and/or 'row' keys instead."
680                 ])
681                 raise RuntimeError(err)
682             elif col is not None:
683                 structure["col"] = list(order)
684             elif row is not None:
685                 structure["row"] = list(order)
686 
687         spec: FacetSpec = {
688             "variables": variables,
689             "structure": structure,
690             "wrap": wrap,
691         }
692 
693         new = self._clone()
694         new._facet_spec.update(spec)
695 
696         return new
697 
698     # TODO def twin()?
699 
700     def scale(self, **scales: Scale) -> Plot:
701         """
702         Specify mappings from data units to visual properties.
703 
704         Keywords correspond to variables defined in the plot, including coordinate
705         variables (`x`, `y`) and semantic variables (`color`, `pointsize`, etc.).
706 
707         A number of "magic" arguments are accepted, including:
708             - The name of a transform (e.g., `"log"`, `"sqrt"`)
709             - The name of a palette (e.g., `"viridis"`, `"muted"`)
710             - A tuple of values, defining the output range (e.g. `(1, 5)`)
711             - A dict, implying a :class:`Nominal` scale (e.g. `{"a": .2, "b": .5}`)
712             - A list of values, implying a :class:`Nominal` scale (e.g. `["b", "r"]`)
713 
714         For more explicit control, pass a scale spec object such as :class:`Continuous`
715         or :class:`Nominal`. Or pass `None` to use an "identity" scale, which treats
716         data values as literally encoding visual properties.
717 
718         Examples
719         --------
720         .. include:: ../docstrings/objects.Plot.scale.rst
721 
722         """
723         new = self._clone()
724         new._scales.update(scales)
725         return new
726 
727     def share(self, **shares: bool | str) -> Plot:
728         """
729         Control sharing of axis limits and ticks across subplots.
730 
731         Keywords correspond to variables defined in the plot, and values can be
732         boolean (to share across all subplots), or one of "row" or "col" (to share
733         more selectively across one dimension of a grid).
734 
735         Behavior for non-coordinate variables is currently undefined.
736 
737         Examples
738         --------
739         .. include:: ../docstrings/objects.Plot.share.rst
740 
741         """
742         new = self._clone()
743         new._shares.update(shares)
744         return new
745 
746     def limit(self, **limits: tuple[Any, Any]) -> Plot:
747         """
748         Control the range of visible data.
749 
750         Keywords correspond to variables defined in the plot, and values are a
751         `(min, max)` tuple (where either can be `None` to leave unset).
752 
753         Limits apply only to the axis; data outside the visible range are
754         still used for any stat transforms and added to the plot.
755 
756         Behavior for non-coordinate variables is currently undefined.
757 
758         Examples
759         --------
760         .. include:: ../docstrings/objects.Plot.limit.rst
761 
762         """
763         new = self._clone()
764         new._limits.update(limits)
765         return new
766 
767     def label(self, *, title=None, **variables: str | Callable[[str], str]) -> Plot:
768         """
769         Control the labels and titles for axes, legends, and subplots.
770 
771         Additional keywords correspond to variables defined in the plot.
772         Values can be one of the following types:
773 
774         - string (used literally; pass "" to clear the default label)
775         - function (called on the default label)
776 
777         For coordinate variables, the value sets the axis label.
778         For semantic variables, the value sets the legend title.
779         For faceting variables, `title=` modifies the subplot-specific label,
780         while `col=` and/or `row=` add a label for the faceting variable.
781         When using a single subplot, `title=` sets its title.
782 
783         Examples
784         --------
785         .. include:: ../docstrings/objects.Plot.label.rst
786 
787 
788         """
789         new = self._clone()
790         if title is not None:
791             new._labels["title"] = title
792         new._labels.update(variables)
793         return new
794 
795     def layout(
796         self,
797         *,
798         size: tuple[float, float] | Default = default,
799         engine: str | None | Default = default,
800     ) -> Plot:
801         """
802         Control the figure size and layout.
803 
804         .. note::
805 
806             Default figure sizes and the API for specifying the figure size are subject
807             to change in future "experimental" releases of the objects API. The default
808             layout engine may also change.
809 
810         Parameters
811         ----------
812         size : (width, height)
813             Size of the resulting figure, in inches. Size is inclusive of legend when
814             using pyplot, but not otherwise.
815         engine : {{"tight", "constrained", None}}
816             Name of method for automatically adjusting the layout to remove overlap.
817             The default depends on whether :meth:`Plot.on` is used.
818 
819         Examples
820         --------
821         .. include:: ../docstrings/objects.Plot.layout.rst
822 
823         """
824         # TODO add an "auto" mode for figsize that roughly scales with the rcParams
825         # figsize (so that works), but expands to prevent subplots from being squished
826         # Also should we have height=, aspect=, exclusive with figsize? Or working
827         # with figsize when only one is defined?
828 
829         new = self._clone()
830 
831         if size is not default:
832             new._figure_spec["figsize"] = size
833         if engine is not default:
834             new._layout_spec["engine"] = engine
835 
836         return new
837 
838     # TODO def legend (ugh)
839 
840     def theme(self, *args: dict[str, Any]) -> Plot:
841         """
842         Control the appearance of elements in the plot.
843 
844         .. note::
845 
846             The API for customizing plot appearance is not yet finalized.
847             Currently, the only valid argument is a dict of matplotlib rc parameters.
848             (This dict must be passed as a positional argument.)
849 
850             It is likely that this method will be enhanced in future releases.
851 
852         Matplotlib rc parameters are documented on the following page:
853         https://matplotlib.org/stable/tutorials/introductory/customizing.html
854 
855         Examples
856         --------
857         .. include:: ../docstrings/objects.Plot.theme.rst
858 
859         """
860         new = self._clone()
861 
862         # We can skip this whole block on Python 3.8+ with positional-only syntax
863         nargs = len(args)
864         if nargs != 1:
865             err = f"theme() takes 1 positional argument, but {nargs} were given"
866             raise TypeError(err)
867 
868         rc = mpl.RcParams(args[0])
869         new._theme.update(rc)
870 
871         return new
872 
873     def save(self, loc, **kwargs) -> Plot:
874         """
875         Compile the plot and write it to a buffer or file on disk.
876 
877         Parameters
878         ----------
879         loc : str, path, or buffer
880             Location on disk to save the figure, or a buffer to write into.
881         kwargs
882             Other keyword arguments are passed through to
883             :meth:`matplotlib.figure.Figure.savefig`.
884 
885         """
886         # TODO expose important keyword arguments in our signature?
887         with theme_context(self._theme_with_defaults()):
888             self._plot().save(loc, **kwargs)
889         return self
890 
891     def show(self, **kwargs) -> None:
892         """
893         Compile the plot and display it by hooking into pyplot.
894 
895         Calling this method is not necessary to render a plot in notebook context,
896         but it may be in other environments (e.g., in a terminal). After compiling the
897         plot, it calls :func:`matplotlib.pyplot.show` (passing any keyword parameters).
898 
899         Unlike other :class:`Plot` methods, there is no return value. This should be
900         the last method you call when specifying a plot.
901 
902         """
903         # TODO make pyplot configurable at the class level, and when not using,
904         # import IPython.display and call on self to populate cell output?
905 
906         # Keep an eye on whether matplotlib implements "attaching" an existing
907         # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024
908 
909         self.plot(pyplot=True).show(**kwargs)
910 
911     def plot(self, pyplot: bool = False) -> Plotter:
912         """
913         Compile the plot spec and return the Plotter object.
914         """
915         with theme_context(self._theme_with_defaults()):
916             return self._plot(pyplot)
917 
918     def _plot(self, pyplot: bool = False) -> Plotter:
919 
920         # TODO if we have _target object, pyplot should be determined by whether it
921         # is hooked into the pyplot state machine (how do we check?)
922 
923         plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())
924 
925         # Process the variable assignments and initialize the figure
926         common, layers = plotter._extract_data(self)
927         plotter._setup_figure(self, common, layers)
928 
929         # Process the scale spec for coordinate variables and transform their data
930         coord_vars = [v for v in self._variables if re.match(r"^x|y", v)]
931         plotter._setup_scales(self, common, layers, coord_vars)
932 
933         # Apply statistical transform(s)
934         plotter._compute_stats(self, layers)
935 
936         # Process scale spec for semantic variables and coordinates computed by stat
937         plotter._setup_scales(self, common, layers)
938 
939         # TODO Remove these after updating other methods
940         # ---- Maybe have debug= param that attaches these when True?
941         plotter._data = common
942         plotter._layers = layers
943 
944         # Process the data for each layer and add matplotlib artists
945         for layer in layers:
946             plotter._plot_layer(self, layer)
947 
948         # Add various figure decorations
949         plotter._make_legend(self)
950         plotter._finalize_figure(self)
951 
952         return plotter
953 
954 
955 # ---- The plot compilation engine ---------------------------------------------- #
956 
957 
958 class Plotter:
959     """
960     Engine for compiling a :class:`Plot` spec into a Matplotlib figure.
961 
962     This class is not intended to be instantiated directly by users.
963 
964     """
965     # TODO decide if we ever want these (Plot.plot(debug=True))?
966     _data: PlotData
967     _layers: list[Layer]
968     _figure: Figure
969 
970     def __init__(self, pyplot: bool, theme: dict[str, Any]):
971 
972         self._pyplot = pyplot
973         self._theme = theme
974         self._legend_contents: list[tuple[
975             tuple[str, str | int], list[Artist], list[str],
976         ]] = []
977         self._scales: dict[str, Scale] = {}
978 
979     def save(self, loc, **kwargs) -> Plotter:  # TODO type args
980         kwargs.setdefault("dpi", 96)
981         try:
982             loc = os.path.expanduser(loc)
983         except TypeError:
984             # loc may be a buffer in which case that would not work
985             pass
986         self._figure.savefig(loc, **kwargs)
987         return self
988 
989     def show(self, **kwargs) -> None:
990         """
991         Display the plot by hooking into pyplot.
992 
993         This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.
994 
995         """
996         # TODO if we did not create the Plotter with pyplot, is it possible to do this?
997         # If not we should clearly raise.
998         import matplotlib.pyplot as plt
999         with theme_context(self._theme):
1000             plt.show(**kwargs)
1001 
1002     # TODO API for accessing the underlying matplotlib objects
1003     # TODO what else is useful in the public API for this class?
1004 
1005     def _repr_png_(self) -> tuple[bytes, dict[str, float]] | None:
1006 
1007         # TODO use matplotlib backend directly instead of going through savefig?
1008 
1009         # TODO perhaps have self.show() flip a switch to disable this, so that
1010         # user does not end up with two versions of the figure in the output
1011 
1012         # TODO use bbox_inches="tight" like the inline backend?
1013         # pro: better results,  con: (sometimes) confusing results
1014         # Better solution would be to default (with option to change)
1015         # to using constrained/tight layout.
1016 
1017         if Plot.config.display["format"] != "png":
1018             return None
1019 
1020         buffer = io.BytesIO()
1021 
1022         factor = 2 if Plot.config.display["hidpi"] else 1
1023         scaling = Plot.config.display["scaling"] / factor
1024         dpi = 96 * factor  # TODO put dpi in Plot.config?
1025 
1026         with theme_context(self._theme):  # TODO _theme_with_defaults?
1027             self._figure.savefig(buffer, dpi=dpi, format="png", bbox_inches="tight")
1028         data = buffer.getvalue()
1029 
1030         w, h = Image.open(buffer).size
1031         metadata = {"width": w * scaling, "height": h * scaling}
1032         return data, metadata
1033 
1034     def _repr_svg_(self) -> str | None:
1035 
1036         if Plot.config.display["format"] != "svg":
1037             return None
1038 
1039         # TODO DPI for rasterized artists?
1040 
1041         scaling = Plot.config.display["scaling"]
1042 
1043         buffer = io.StringIO()
1044         with theme_context(self._theme):  # TODO _theme_with_defaults?
1045             self._figure.savefig(buffer, format="svg", bbox_inches="tight")
1046 
1047         root = ElementTree.fromstring(buffer.getvalue())
1048         w = scaling * float(root.attrib["width"][:-2])
1049         h = scaling * float(root.attrib["height"][:-2])
1050         root.attrib.update(width=f"{w}pt", height=f"{h}pt", viewbox=f"0 0 {w} {h}")
1051         ElementTree.ElementTree(root).write(out := io.BytesIO())
1052 
1053         return out.getvalue().decode()
1054 
1055     def _extract_data(self, p: Plot) -> tuple[PlotData, list[Layer]]:
1056 
1057         common_data = (
1058             p._data
1059             .join(None, p._facet_spec.get("variables"))
1060             .join(None, p._pair_spec.get("variables"))
1061         )
1062 
1063         layers: list[Layer] = []
1064         for layer in p._layers:
1065             spec = layer.copy()
1066             spec["data"] = common_data.join(layer.get("source"), layer.get("vars"))
1067             layers.append(spec)
1068 
1069         return common_data, layers
1070 
1071     def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -> str:
1072 
1073         label: str
1074         if var in p._labels:
1075             manual_label = p._labels[var]
1076             if callable(manual_label) and auto_label is not None:
1077                 label = manual_label(auto_label)
1078             else:
1079                 label = cast(str, manual_label)
1080         elif auto_label is None:
1081             label = ""
1082         else:
1083             label = auto_label
1084         return label
1085 
1086     def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -> None:
1087 
1088         # --- Parsing the faceting/pairing parameterization to specify figure grid
1089 
1090         subplot_spec = p._subplot_spec.copy()
1091         facet_spec = p._facet_spec.copy()
1092         pair_spec = p._pair_spec.copy()
1093 
1094         for axis in "xy":
1095             if axis in p._shares:
1096                 subplot_spec[f"share{axis}"] = p._shares[axis]
1097 
1098         for dim in ["col", "row"]:
1099             if dim in common.frame and dim not in facet_spec["structure"]:
1100                 order = categorical_order(common.frame[dim])
1101                 facet_spec["structure"][dim] = order
1102 
1103         self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)
1104 
1105         # --- Figure initialization
1106         self._figure = subplots.init_figure(
1107             pair_spec, self._pyplot, p._figure_spec, p._target,
1108         )
1109 
1110         # --- Figure annotation
1111         for sub in subplots:
1112             ax = sub["ax"]
1113             for axis in "xy":
1114                 axis_key = sub[axis]
1115 
1116                 # ~~ Axis labels
1117 
1118                 # TODO Should we make it possible to use only one x/y label for
1119                 # all rows/columns in a faceted plot? Maybe using sub{axis}label,
1120                 # although the alignments of the labels from that method leaves
1121                 # something to be desired (in terms of how it defines 'centered').
1122                 names = [
1123                     common.names.get(axis_key),
1124                     *(layer["data"].names.get(axis_key) for layer in layers)
1125                 ]
1126                 auto_label = next((name for name in names if name is not None), None)
1127                 label = self._resolve_label(p, axis_key, auto_label)
1128                 ax.set(**{f"{axis}label": label})
1129 
1130                 # ~~ Decoration visibility
1131 
1132                 # TODO there should be some override (in Plot.layout?) so that
1133                 # axis / tick labels can be shown on interior shared axes if desired
1134 
1135                 axis_obj = getattr(ax, f"{axis}axis")
1136                 visible_side = {"x": "bottom", "y": "left"}.get(axis)
1137                 show_axis_label = (
1138                     sub[visible_side]
1139                     or not p._pair_spec.get("cross", True)
1140                     or (
1141                         axis in p._pair_spec.get("structure", {})
1142                         and bool(p._pair_spec.get("wrap"))
1143                     )
1144                 )
1145                 axis_obj.get_label().set_visible(show_axis_label)
1146 
1147                 show_tick_labels = (
1148                     show_axis_label
1149                     or subplot_spec.get(f"share{axis}") not in (
1150                         True, "all", {"x": "col", "y": "row"}[axis]
1151                     )
1152                 )
1153                 for group in ("major", "minor"):
1154                     for t in getattr(axis_obj, f"get_{group}ticklabels")():
1155                         t.set_visible(show_tick_labels)
1156 
1157             # TODO we want right-side titles for row facets in most cases?
1158             # Let's have what we currently call "margin titles" but properly using the
1159             # ax.set_title interface (see my gist)
1160             title_parts = []
1161             for dim in ["col", "row"]:
1162                 if sub[dim] is not None:
1163                     val = self._resolve_label(p, "title", f"{sub[dim]}")
1164                     if dim in p._labels:
1165                         key = self._resolve_label(p, dim, common.names.get(dim))
1166                         val = f"{key} {val}"
1167                     title_parts.append(val)
1168 
1169             has_col = sub["col"] is not None
1170             has_row = sub["row"] is not None
1171             show_title = (
1172                 has_col and has_row
1173                 or (has_col or has_row) and p._facet_spec.get("wrap")
1174                 or (has_col and sub["top"])
1175                 # TODO or has_row and sub["right"] and <right titles>
1176                 or has_row  # TODO and not <right titles>
1177             )
1178             if title_parts:
1179                 title = " | ".join(title_parts)
1180                 title_text = ax.set_title(title)
1181                 title_text.set_visible(show_title)
1182             elif not (has_col or has_row):
1183                 title = self._resolve_label(p, "title", None)
1184                 title_text = ax.set_title(title)
1185 
1186     def _compute_stats(self, spec: Plot, layers: list[Layer]) -> None:
1187 
1188         grouping_vars = [v for v in PROPERTIES if v not in "xy"]
1189         grouping_vars += ["col", "row", "group"]
1190 
1191         pair_vars = spec._pair_spec.get("structure", {})
1192 
1193         for layer in layers:
1194 
1195             data = layer["data"]
1196             mark = layer["mark"]
1197             stat = layer["stat"]
1198 
1199             if stat is None:
1200                 continue
1201 
1202             iter_axes = itertools.product(*[
1203                 pair_vars.get(axis, [axis]) for axis in "xy"
1204             ])
1205 
1206             old = data.frame
1207 
1208             if pair_vars:
1209                 data.frames = {}
1210                 data.frame = data.frame.iloc[:0]  # TODO to simplify typing
1211 
1212             for coord_vars in iter_axes:
1213 
1214                 pairings = "xy", coord_vars
1215 
1216                 df = old.copy()
1217                 scales = self._scales.copy()
1218 
1219                 for axis, var in zip(*pairings):
1220                     if axis != var:
1221                         df = df.rename(columns={var: axis})
1222                         drop_cols = [x for x in df if re.match(rf"{axis}\d+", str(x))]
1223                         df = df.drop(drop_cols, axis=1)
1224                         scales[axis] = scales[var]
1225 
1226                 orient = layer["orient"] or mark._infer_orient(scales)
1227 
1228                 if stat.group_by_orient:
1229                     grouper = [orient, *grouping_vars]
1230                 else:
1231                     grouper = grouping_vars
1232                 groupby = GroupBy(grouper)
1233                 res = stat(df, groupby, orient, scales)
1234 
1235                 if pair_vars:
1236                     data.frames[coord_vars] = res
1237                 else:
1238                     data.frame = res
1239 
1240     def _get_scale(
1241         self, spec: Plot, var: str, prop: Property, values: Series
1242     ) -> Scale:
1243 
1244         if var in spec._scales:
1245             arg = spec._scales[var]
1246             if arg is None or isinstance(arg, Scale):
1247                 scale = arg
1248             else:
1249                 scale = prop.infer_scale(arg, values)
1250         else:
1251             scale = prop.default_scale(values)
1252 
1253         return scale
1254 
1255     def _get_subplot_data(self, df, var, view, share_state):
1256 
1257         if share_state in [True, "all"]:
1258             # The all-shared case is easiest, every subplot sees all the data
1259             seed_values = df[var]
1260         else:
1261             # Otherwise, we need to setup separate scales for different subplots
1262             if share_state in [False, "none"]:
1263                 # Fully independent axes are also easy: use each subplot's data
1264                 idx = self._get_subplot_index(df, view)
1265             elif share_state in df:
1266                 # Sharing within row/col is more complicated
1267                 use_rows = df[share_state] == view[share_state]
1268                 idx = df.index[use_rows]
1269             else:
1270                 # This configuration doesn't make much sense, but it's fine
1271                 idx = df.index
1272 
1273             seed_values = df.loc[idx, var]
1274 
1275         return seed_values
1276 
1277     def _setup_scales(
1278         self, p: Plot,
1279         common: PlotData,
1280         layers: list[Layer],
1281         variables: list[str] | None = None,
1282     ) -> None:
1283 
1284         if variables is None:
1285             # Add variables that have data but not a scale, which happens
1286             # because this method can be called multiple time, to handle
1287             # variables added during the Stat transform.
1288             variables = []
1289             for layer in layers:
1290                 variables.extend(layer["data"].frame.columns)
1291                 for df in layer["data"].frames.values():
1292                     variables.extend(str(v) for v in df if v not in variables)
1293             variables = [v for v in variables if v not in self._scales]
1294 
1295         for var in variables:
1296 
1297             # Determine whether this is a coordinate variable
1298             # (i.e., x/y, paired x/y, or derivative such as xmax)
1299             m = re.match(r"^(?P<coord>(?P<axis>x|y)\d*).*", var)
1300             if m is None:
1301                 coord = axis = None
1302             else:
1303                 coord = m["coord"]
1304                 axis = m["axis"]
1305 
1306             # Get keys that handle things like x0, xmax, properly where relevant
1307             prop_key = var if axis is None else axis
1308             scale_key = var if coord is None else coord
1309 
1310             if prop_key not in PROPERTIES:
1311                 continue
1312 
1313             # Concatenate layers, using only the relevant coordinate and faceting vars,
1314             # This is unnecessarily wasteful, as layer data will often be redundant.
1315             # But figuring out the minimal amount we need is more complicated.
1316             cols = [var, "col", "row"]
1317             parts = [common.frame.filter(cols)]
1318             for layer in layers:
1319                 parts.append(layer["data"].frame.filter(cols))
1320                 for df in layer["data"].frames.values():
1321                     parts.append(df.filter(cols))
1322             var_df = pd.concat(parts, ignore_index=True)
1323 
1324             prop = PROPERTIES[prop_key]
1325             scale = self._get_scale(p, scale_key, prop, var_df[var])
1326 
1327             if scale_key not in p._variables:
1328                 # TODO this implies that the variable was added by the stat
1329                 # It allows downstream orientation inference to work properly.
1330                 # But it feels rather hacky, so ideally revisit.
1331                 scale._priority = 0  # type: ignore
1332 
1333             if axis is None:
1334                 # We could think about having a broader concept of (un)shared properties
1335                 # In general, not something you want to do (different scales in facets)
1336                 # But could make sense e.g. with paired plots. Build later.
1337                 share_state = None
1338                 subplots = []
1339             else:
1340                 share_state = self._subplots.subplot_spec[f"share{axis}"]
1341                 subplots = [view for view in self._subplots if view[axis] == coord]
1342 
1343             # Shared categorical axes are broken on matplotlib<3.4.0.
1344             # https://github.com/matplotlib/matplotlib/pull/18308
1345             # This only affects us when sharing *paired* axes. This is a novel/niche
1346             # behavior, so we will raise rather than hack together a workaround.
1347             if axis is not None and _version_predates(mpl, "3.4"):
1348                 paired_axis = axis in p._pair_spec.get("structure", {})
1349                 cat_scale = isinstance(scale, Nominal)
1350                 ok_dim = {"x": "col", "y": "row"}[axis]
1351                 shared_axes = share_state not in [False, "none", ok_dim]
1352                 if paired_axis and cat_scale and shared_axes:
1353                     err = "Sharing paired categorical axes requires matplotlib>=3.4.0"
1354                     raise RuntimeError(err)
1355 
1356             if scale is None:
1357                 self._scales[var] = Scale._identity()
1358             else:
1359                 try:
1360                     self._scales[var] = scale._setup(var_df[var], prop)
1361                 except Exception as err:
1362                     raise PlotSpecError._during("Scale setup", var) from err
1363 
1364             if axis is None or (var != coord and coord in p._variables):
1365                 # Everything below here applies only to coordinate variables
1366                 continue
1367 
1368             # Set up an empty series to receive the transformed values.
1369             # We need this to handle piecemeal transforms of categories -> floats.
1370             transformed_data = []
1371             for layer in layers:
1372                 index = layer["data"].frame.index
1373                 empty_series = pd.Series(dtype=float, index=index, name=var)
1374                 transformed_data.append(empty_series)
1375 
1376             for view in subplots:
1377 
1378                 axis_obj = getattr(view["ax"], f"{axis}axis")
1379                 seed_values = self._get_subplot_data(var_df, var, view, share_state)
1380                 view_scale = scale._setup(seed_values, prop, axis=axis_obj)
1381                 set_scale_obj(view["ax"], axis, view_scale._matplotlib_scale)
1382 
1383                 for layer, new_series in zip(layers, transformed_data):
1384                     layer_df = layer["data"].frame
1385                     if var not in layer_df:
1386                         continue
1387 
1388                     idx = self._get_subplot_index(layer_df, view)
1389                     try:
1390                         new_series.loc[idx] = view_scale(layer_df.loc[idx, var])
1391                     except Exception as err:
1392                         spec_error = PlotSpecError._during("Scaling operation", var)
1393                         raise spec_error from err
1394 
1395             # Now the transformed data series are complete, set update the layer data
1396             for layer, new_series in zip(layers, transformed_data):
1397                 layer_df = layer["data"].frame
1398                 if var in layer_df:
1399                     layer_df[var] = new_series
1400 
1401     def _plot_layer(self, p: Plot, layer: Layer) -> None:
1402 
1403         data = layer["data"]
1404         mark = layer["mark"]
1405         move = layer["move"]
1406 
1407         default_grouping_vars = ["col", "row", "group"]  # TODO where best to define?
1408         grouping_properties = [v for v in PROPERTIES if v[0] not in "xy"]
1409 
1410         pair_variables = p._pair_spec.get("structure", {})
1411 
1412         for subplots, df, scales in self._generate_pairings(data, pair_variables):
1413 
1414             orient = layer["orient"] or mark._infer_orient(scales)
1415 
1416             def get_order(var):
1417                 # Ignore order for x/y: they have been scaled to numeric indices,
1418                 # so any original order is no longer valid. Default ordering rules
1419                 # sorted unique numbers will correctly reconstruct intended order
1420                 # TODO This is tricky, make sure we add some tests for this
1421                 if var not in "xy" and var in scales:
1422                     return getattr(scales[var], "order", None)
1423 
1424             if orient in df:
1425                 width = pd.Series(index=df.index, dtype=float)
1426                 for view in subplots:
1427                     view_idx = self._get_subplot_data(
1428                         df, orient, view, p._shares.get(orient)
1429                     ).index
1430                     view_df = df.loc[view_idx]
1431                     if "width" in mark._mappable_props:
1432                         view_width = mark._resolve(view_df, "width", None)
1433                     elif "width" in df:
1434                         view_width = view_df["width"]
1435                     else:
1436                         view_width = 0.8  # TODO what default?
1437                     spacing = scales[orient]._spacing(view_df.loc[view_idx, orient])
1438                     width.loc[view_idx] = view_width * spacing
1439                 df["width"] = width
1440 
1441             if "baseline" in mark._mappable_props:
1442                 # TODO what marks should have this?
1443                 # If we can set baseline with, e.g., Bar(), then the
1444                 # "other" (e.g. y for x oriented bars) parameterization
1445                 # is somewhat ambiguous.
1446                 baseline = mark._resolve(df, "baseline", None)
1447             else:
1448                 # TODO unlike width, we might not want to add baseline to data
1449                 # if the mark doesn't use it. Practically, there is a concern about
1450                 # Mark abstraction like Area / Ribbon
1451                 baseline = 0 if "baseline" not in df else df["baseline"]
1452             df["baseline"] = baseline
1453 
1454             if move is not None:
1455                 moves = move if isinstance(move, list) else [move]
1456                 for move_step in moves:
1457                     move_by = getattr(move_step, "by", None)
1458                     if move_by is None:
1459                         move_by = grouping_properties
1460                     move_groupers = [*move_by, *default_grouping_vars]
1461                     if move_step.group_by_orient:
1462                         move_groupers.insert(0, orient)
1463                     order = {var: get_order(var) for var in move_groupers}
1464                     groupby = GroupBy(order)
1465                     df = move_step(df, groupby, orient, scales)
1466 
1467             df = self._unscale_coords(subplots, df, orient)
1468 
1469             grouping_vars = mark._grouping_props + default_grouping_vars
1470             split_generator = self._setup_split_generator(grouping_vars, df, subplots)
1471 
1472             mark._plot(split_generator, scales, orient)
1473 
1474         # TODO is this the right place for this?
1475         for view in self._subplots:
1476             view["ax"].autoscale_view()
1477 
1478         if layer["legend"]:
1479             self._update_legend_contents(p, mark, data, scales)
1480 
1481     def _unscale_coords(
1482         self, subplots: list[dict], df: DataFrame, orient: str,
1483     ) -> DataFrame:
1484         # TODO do we still have numbers in the variable name at this point?
1485         coord_cols = [c for c in df if re.match(r"^[xy]\D*$", str(c))]
1486         out_df = (
1487             df
1488             .drop(coord_cols, axis=1)
1489             .reindex(df.columns, axis=1)  # So unscaled columns retain their place
1490             .copy(deep=False)
1491         )
1492 
1493         for view in subplots:
1494             view_df = self._filter_subplot_data(df, view)
1495             axes_df = view_df[coord_cols]
1496             for var, values in axes_df.items():
1497 
1498                 axis = getattr(view["ax"], f"{str(var)[0]}axis")
1499                 # TODO see https://github.com/matplotlib/matplotlib/issues/22713
1500                 transform = axis.get_transform().inverted().transform
1501                 inverted = transform(values)
1502                 out_df.loc[values.index, str(var)] = inverted
1503 
1504         return out_df
1505 
1506     def _generate_pairings(
1507         self, data: PlotData, pair_variables: dict,
1508     ) -> Generator[
1509         tuple[list[dict], DataFrame, dict[str, Scale]], None, None
1510     ]:
1511         # TODO retype return with subplot_spec or similar
1512 
1513         iter_axes = itertools.product(*[
1514             pair_variables.get(axis, [axis]) for axis in "xy"
1515         ])
1516 
1517         for x, y in iter_axes:
1518 
1519             subplots = []
1520             for view in self._subplots:
1521                 if (view["x"] == x) and (view["y"] == y):
1522                     subplots.append(view)
1523 
1524             if data.frame.empty and data.frames:
1525                 out_df = data.frames[(x, y)].copy()
1526             elif not pair_variables:
1527                 out_df = data.frame.copy()
1528             else:
1529                 if data.frame.empty and data.frames:
1530                     out_df = data.frames[(x, y)].copy()
1531                 else:
1532                     out_df = data.frame.copy()
1533 
1534             scales = self._scales.copy()
1535             if x in out_df:
1536                 scales["x"] = self._scales[x]
1537             if y in out_df:
1538                 scales["y"] = self._scales[y]
1539 
1540             for axis, var in zip("xy", (x, y)):
1541                 if axis != var:
1542                     out_df = out_df.rename(columns={var: axis})
1543                     cols = [col for col in out_df if re.match(rf"{axis}\d+", str(col))]
1544                     out_df = out_df.drop(cols, axis=1)
1545 
1546             yield subplots, out_df, scales
1547 
1548     def _get_subplot_index(self, df: DataFrame, subplot: dict) -> Index:
1549 
1550         dims = df.columns.intersection(["col", "row"])
1551         if dims.empty:
1552             return df.index
1553 
1554         keep_rows = pd.Series(True, df.index, dtype=bool)
1555         for dim in dims:
1556             keep_rows &= df[dim] == subplot[dim]
1557         return df.index[keep_rows]
1558 
1559     def _filter_subplot_data(self, df: DataFrame, subplot: dict) -> DataFrame:
1560         # TODO note redundancies with preceding function ... needs refactoring
1561         dims = df.columns.intersection(["col", "row"])
1562         if dims.empty:
1563             return df
1564 
1565         keep_rows = pd.Series(True, df.index, dtype=bool)
1566         for dim in dims:
1567             keep_rows &= df[dim] == subplot[dim]
1568         return df[keep_rows]
1569 
1570     def _setup_split_generator(
1571         self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],
1572     ) -> Callable[[], Generator]:
1573 
1574         grouping_keys = []
1575         grouping_vars = [
1576             v for v in grouping_vars if v in df and v not in ["col", "row"]
1577         ]
1578         for var in grouping_vars:
1579             order = getattr(self._scales[var], "order", None)
1580             if order is None:
1581                 order = categorical_order(df[var])
1582             grouping_keys.append(order)
1583 
1584         def split_generator(keep_na=False) -> Generator:
1585 
1586             for view in subplots:
1587 
1588                 axes_df = self._filter_subplot_data(df, view)
1589 
1590                 with pd.option_context("mode.use_inf_as_na", True):
1591                     if keep_na:
1592                         # The simpler thing to do would be x.dropna().reindex(x.index).
1593                         # But that doesn't work with the way that the subset iteration
1594                         # is written below, which assumes data for grouping vars.
1595                         # Matplotlib (usually?) masks nan data, so this should "work".
1596                         # Downstream code can also drop these rows, at some speed cost.
1597                         present = axes_df.notna().all(axis=1)
1598                         nulled = {}
1599                         for axis in "xy":
1600                             if axis in axes_df:
1601                                 nulled[axis] = axes_df[axis].where(present)
1602                         axes_df = axes_df.assign(**nulled)
1603                     else:
1604                         axes_df = axes_df.dropna()
1605 
1606                 subplot_keys = {}
1607                 for dim in ["col", "row"]:
1608                     if view[dim] is not None:
1609                         subplot_keys[dim] = view[dim]
1610 
1611                 if not grouping_vars or not any(grouping_keys):
1612                     if not axes_df.empty:
1613                         yield subplot_keys, axes_df.copy(), view["ax"]
1614                     continue
1615 
1616                 grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)
1617 
1618                 for key in itertools.product(*grouping_keys):
1619 
1620                     # Pandas fails with singleton tuple inputs
1621                     pd_key = key[0] if len(key) == 1 else key
1622 
1623                     try:
1624                         df_subset = grouped_df.get_group(pd_key)
1625                     except KeyError:
1626                         # TODO (from initial work on categorical plots refactor)
1627                         # We are adding this to allow backwards compatability
1628                         # with the empty artists that old categorical plots would
1629                         # add (before 0.12), which we may decide to break, in which
1630                         # case this option could be removed
1631                         df_subset = axes_df.loc[[]]
1632 
1633                     if df_subset.empty:
1634                         continue
1635 
1636                     sub_vars = dict(zip(grouping_vars, key))
1637                     sub_vars.update(subplot_keys)
1638 
1639                     # TODO need copy(deep=...) policy (here, above, anywhere else?)
1640                     yield sub_vars, df_subset.copy(), view["ax"]
1641 
1642         return split_generator
1643 
1644     def _update_legend_contents(
1645         self,
1646         p: Plot,
1647         mark: Mark,
1648         data: PlotData,
1649         scales: dict[str, Scale],
1650     ) -> None:
1651         """Add legend artists / labels for one layer in the plot."""
1652         if data.frame.empty and data.frames:
1653             legend_vars: list[str] = []
1654             for frame in data.frames.values():
1655                 frame_vars = frame.columns.intersection(list(scales))
1656                 legend_vars.extend(v for v in frame_vars if v not in legend_vars)
1657         else:
1658             legend_vars = list(data.frame.columns.intersection(list(scales)))
1659 
1660         # First pass: Identify the values that will be shown for each variable
1661         schema: list[tuple[
1662             tuple[str, str | int], list[str], tuple[list, list[str]]
1663         ]] = []
1664         schema = []
1665         for var in legend_vars:
1666             var_legend = scales[var]._legend
1667             if var_legend is not None:
1668                 values, labels = var_legend
1669                 for (_, part_id), part_vars, _ in schema:
1670                     if data.ids[var] == part_id:
1671                         # Allow multiple plot semantics to represent same data variable
1672                         part_vars.append(var)
1673                         break
1674                 else:
1675                     title = self._resolve_label(p, var, data.names[var])
1676                     entry = (title, data.ids[var]), [var], (values, labels)
1677                     schema.append(entry)
1678 
1679         # Second pass, generate an artist corresponding to each value
1680         contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []
1681         for key, variables, (values, labels) in schema:
1682             artists = []
1683             for val in values:
1684                 artist = mark._legend_artist(variables, val, scales)
1685                 if artist is not None:
1686                     artists.append(artist)
1687             if artists:
1688                 contents.append((key, artists, labels))
1689 
1690         self._legend_contents.extend(contents)
1691 
1692     def _make_legend(self, p: Plot) -> None:
1693         """Create the legend artist(s) and add onto the figure."""
1694         # Combine artists representing same information across layers
1695         # Input list has an entry for each distinct variable in each layer
1696         # Output dict has an entry for each distinct variable
1697         merged_contents: dict[
1698             tuple[str, str | int], tuple[list[Artist], list[str]],
1699         ] = {}
1700         for key, new_artists, labels in self._legend_contents:
1701             # Key is (name, id); we need the id to resolve variable uniqueness,
1702             # but will need the name in the next step to title the legend
1703             if key in merged_contents:
1704                 # Copy so inplace updates don't propagate back to legend_contents
1705                 existing_artists = merged_contents[key][0]
1706                 for i, artist in enumerate(existing_artists):
1707                     # Matplotlib accepts a tuple of artists and will overlay them
1708                     if isinstance(artist, tuple):
1709                         artist += new_artists[i],
1710                     else:
1711                         existing_artists[i] = artist, new_artists[i]
1712             else:
1713                 merged_contents[key] = new_artists.copy(), labels
1714 
1715         # TODO explain
1716         loc = "center right" if self._pyplot else "center left"
1717 
1718         base_legend = None
1719         for (name, _), (handles, labels) in merged_contents.items():
1720 
1721             legend = mpl.legend.Legend(
1722                 self._figure,
1723                 handles,
1724                 labels,
1725                 title=name,
1726                 loc=loc,
1727                 bbox_to_anchor=(.98, .55),
1728             )
1729 
1730             if base_legend:
1731                 # Matplotlib has no public API for this so it is a bit of a hack.
1732                 # Ideally we'd define our own legend class with more flexibility,
1733                 # but that is a lot of work!
1734                 base_legend_box = base_legend.get_children()[0]
1735                 this_legend_box = legend.get_children()[0]
1736                 base_legend_box.get_children().extend(this_legend_box.get_children())
1737             else:
1738                 base_legend = legend
1739                 self._figure.legends.append(legend)
1740 
1741     def _finalize_figure(self, p: Plot) -> None:
1742 
1743         for sub in self._subplots:
1744             ax = sub["ax"]
1745             for axis in "xy":
1746                 axis_key = sub[axis]
1747                 axis_obj = getattr(ax, f"{axis}axis")
1748 
1749                 # Axis limits
1750                 if axis_key in p._limits:
1751                     convert_units = getattr(ax, f"{axis}axis").convert_units
1752                     a, b = p._limits[axis_key]
1753                     lo = a if a is None else convert_units(a)
1754                     hi = b if b is None else convert_units(b)
1755                     if isinstance(a, str):
1756                         lo = cast(float, lo) - 0.5
1757                     if isinstance(b, str):
1758                         hi = cast(float, hi) + 0.5
1759                     ax.set(**{f"{axis}lim": (lo, hi)})
1760 
1761                 if axis_key in self._scales:  # TODO when would it not be?
1762                     self._scales[axis_key]._finalize(p, axis_obj)
1763 
1764         if (engine := p._layout_spec.get("engine", default)) is not default:
1765             # None is a valid arg for Figure.set_layout_engine, hence `default`
1766             set_layout_engine(self._figure, engine)
1767         elif p._target is None:
1768             # Don't modify the layout engine if the user supplied their own
1769             # matplotlib figure and didn't specify an engine through Plot
1770             # TODO switch default to "constrained"?
1771             # TODO either way, make configurable
1772             set_layout_engine(self._figure, "tight")

</code><intended_behavior>This file likely contains functions or methods that prepare data for plotting, including handling of missing values. The code should ensure that missing values (`pd.NA` or `np.nan`) do not influence the sorting or ordering of axes in plots. A specific method within this could potentially be handling data frames before they are plotted, which would need to be adjusted to uniformly treat `pd.NA` and `np.nan` to maintain axis ordering.</intended_behavior>, <file>seaborn/_core/data.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Components for parsing variable assignments and internally representing plot data.
3 """
4 from __future__ import annotations
5 
6 from collections.abc import Mapping, Sized
7 from typing import cast
8 
9 import pandas as pd
10 from pandas import DataFrame
11 
12 from seaborn._core.typing import DataSource, VariableSpec, ColumnName
13 
14 
15 class PlotData:
16     """
17     Data table with plot variable schema and mapping to original names.
18 
19     Contains logic for parsing variable specification arguments and updating
20     the table with layer-specific data and/or mappings.
21 
22     Parameters
23     ----------
24     data
25         Input data where variable names map to vector values.
26     variables
27         Keys are names of plot variables (x, y, ...) each value is one of:
28 
29         - name of a column (or index level, or dictionary entry) in `data`
30         - vector in any format that can construct a :class:`pandas.DataFrame`
31 
32     Attributes
33     ----------
34     frame
35         Data table with column names having defined plot variables.
36     names
37         Dictionary mapping plot variable names to names in source data structure(s).
38     ids
39         Dictionary mapping plot variable names to unique data source identifiers.
40 
41     """
42     frame: DataFrame
43     frames: dict[tuple, DataFrame]
44     names: dict[str, str | None]
45     ids: dict[str, str | int]
46     source_data: DataSource
47     source_vars: dict[str, VariableSpec]
48 
49     def __init__(
50         self,
51         data: DataSource,
52         variables: dict[str, VariableSpec],
53     ):
54 
55         frame, names, ids = self._assign_variables(data, variables)
56 
57         self.frame = frame
58         self.names = names
59         self.ids = ids
60 
61         self.frames = {}  # TODO this is a hack, remove
62 
63         self.source_data = data
64         self.source_vars = variables
65 
66     def __contains__(self, key: str) -> bool:
67         """Boolean check on whether a variable is defined in this dataset."""
68         if self.frame is None:
69             return any(key in df for df in self.frames.values())
70         return key in self.frame
71 
72     def join(
73         self,
74         data: DataSource,
75         variables: dict[str, VariableSpec] | None,
76     ) -> PlotData:
77         """Add, replace, or drop variables and return as a new dataset."""
78         # Inherit the original source of the upsteam data by default
79         if data is None:
80             data = self.source_data
81 
82         # TODO allow `data` to be a function (that is called on the source data?)
83 
84         if not variables:
85             variables = self.source_vars
86 
87         # Passing var=None implies that we do not want that variable in this layer
88         disinherit = [k for k, v in variables.items() if v is None]
89 
90         # Create a new dataset with just the info passed here
91         new = PlotData(data, variables)
92 
93         # -- Update the inherited DataSource with this new information
94 
95         drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]
96         parts = [self.frame.drop(columns=drop_cols), new.frame]
97 
98         # Because we are combining distinct columns, this is perhaps more
99         # naturally thought of as a "merge"/"join". But using concat because
100         # some simple testing suggests that it is marginally faster.
101         frame = pd.concat(parts, axis=1, sort=False, copy=False)
102 
103         names = {k: v for k, v in self.names.items() if k not in disinherit}
104         names.update(new.names)
105 
106         ids = {k: v for k, v in self.ids.items() if k not in disinherit}
107         ids.update(new.ids)
108 
109         new.frame = frame
110         new.names = names
111         new.ids = ids
112 
113         # Multiple chained operations should always inherit from the original object
114         new.source_data = self.source_data
115         new.source_vars = self.source_vars
116 
117         return new
118 
119     def _assign_variables(
120         self,
121         data: DataSource,
122         variables: dict[str, VariableSpec],
123     ) -> tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:
124         """
125         Assign values for plot variables given long-form data and/or vector inputs.
126 
127         Parameters
128         ----------
129         data
130             Input data where variable names map to vector values.
131         variables
132             Keys are names of plot variables (x, y, ...) each value is one of:
133 
134             - name of a column (or index level, or dictionary entry) in `data`
135             - vector in any format that can construct a :class:`pandas.DataFrame`
136 
137         Returns
138         -------
139         frame
140             Table mapping seaborn variables (x, y, color, ...) to data vectors.
141         names
142             Keys are defined seaborn variables; values are names inferred from
143             the inputs (or None when no name can be determined).
144         ids
145             Like the `names` dict, but `None` values are replaced by the `id()`
146             of the data object that defined the variable.
147 
148         Raises
149         ------
150         ValueError
151             When variables are strings that don't appear in `data`, or when they are
152             non-indexed vector datatypes that have a different length from `data`.
153 
154         """
155         source_data: Mapping | DataFrame
156         frame: DataFrame
157         names: dict[str, str | None]
158         ids: dict[str, str | int]
159 
160         plot_data = {}
161         names = {}
162         ids = {}
163 
164         given_data = data is not None
165         if data is not None:
166             source_data = data
167         else:
168             # Data is optional; all variables can be defined as vectors
169             # But simplify downstream code by always having a usable source data object
170             source_data = {}
171 
172         # TODO Generally interested in accepting a generic DataFrame interface
173         # Track https://data-apis.org/ for development
174 
175         # Variables can also be extracted from the index of a DataFrame
176         if isinstance(source_data, pd.DataFrame):
177             index = source_data.index.to_frame().to_dict("series")
178         else:
179             index = {}
180 
181         for key, val in variables.items():
182 
183             # Simply ignore variables with no specification
184             if val is None:
185                 continue
186 
187             # Try to treat the argument as a key for the data collection.
188             # But be flexible about what can be used as a key.
189             # Usually it will be a string, but allow other hashables when
190             # taking from the main data object. Allow only strings to reference
191             # fields in the index, because otherwise there is too much ambiguity.
192 
193             # TODO this will be rendered unnecessary by the following pandas fix:
194             # https://github.com/pandas-dev/pandas/pull/41283
195             try:
196                 hash(val)
197                 val_is_hashable = True
198             except TypeError:
199                 val_is_hashable = False
200 
201             val_as_data_key = (
202                 # See https://github.com/pandas-dev/pandas/pull/41283
203                 # (isinstance(val, abc.Hashable) and val in source_data)
204                 (val_is_hashable and val in source_data)
205                 or (isinstance(val, str) and val in index)
206             )
207 
208             if val_as_data_key:
209                 val = cast(ColumnName, val)
210                 if val in source_data:
211                     plot_data[key] = source_data[val]
212                 elif val in index:
213                     plot_data[key] = index[val]
214                 names[key] = ids[key] = str(val)
215 
216             elif isinstance(val, str):
217 
218                 # This looks like a column name but, lookup failed.
219 
220                 err = f"Could not interpret value `{val}` for `{key}`. "
221                 if not given_data:
222                     err += "Value is a string, but `data` was not passed."
223                 else:
224                     err += "An entry with this name does not appear in `data`."
225                 raise ValueError(err)
226 
227             else:
228 
229                 # Otherwise, assume the value somehow represents data
230 
231                 # Ignore empty data structures
232                 if isinstance(val, Sized) and len(val) == 0:
233                     continue
234 
235                 # If vector has no index, it must match length of data table
236                 if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):
237                     if isinstance(val, Sized) and len(data) != len(val):
238                         val_cls = val.__class__.__name__
239                         err = (
240                             f"Length of {val_cls} vectors must match length of `data`"
241                             f" when both are used, but `data` has length {len(data)}"
242                             f" and the vector passed to `{key}` has length {len(val)}."
243                         )
244                         raise ValueError(err)
245 
246                 plot_data[key] = val
247 
248                 # Try to infer the original name using pandas-like metadata
249                 if hasattr(val, "name"):
250                     names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424
251                 else:
252                     names[key] = None
253                     ids[key] = id(val)
254 
255         # Construct a tidy plot DataFrame. This will convert a number of
256         # types automatically, aligning on index in case of pandas objects
257         # TODO Note: this fails when variable specs *only* have scalars!
258         frame = pd.DataFrame(plot_data)
259 
260         return frame, names, ids

</code><intended_behavior>As this file likely involves data manipulation and preparation for plotting, it should properly manage datasets with missing values, ensuring that insertion of `pd.NA` does not lead to reversed axes. Updating or refining the method to handle `pd.NA` equivalently to `np.nan`, especially in regards to data sorting and ordering for plotting, could resolve the issue.</intended_behavior>]
2025-10-18 14:47:16.212 | INFO     | Search completed. Bug locations: [<file>seaborn/_core/plot.py</file>
<class>None</class>
<method>None</method>
<code>
1 """The classes for specifying and compiling a declarative visualization."""
2 from __future__ import annotations
3 
4 import io
5 import os
6 import re
7 import inspect
8 import itertools
9 import textwrap
10 from contextlib import contextmanager
11 from collections import abc
12 from collections.abc import Callable, Generator
13 from typing import Any, List, Literal, Optional, cast
14 from xml.etree import ElementTree
15 
16 from cycler import cycler
17 import pandas as pd
18 from pandas import DataFrame, Series, Index
19 import matplotlib as mpl
20 from matplotlib.axes import Axes
21 from matplotlib.artist import Artist
22 from matplotlib.figure import Figure
23 from PIL import Image
24 
25 from seaborn._marks.base import Mark
26 from seaborn._stats.base import Stat
27 from seaborn._core.data import PlotData
28 from seaborn._core.moves import Move
29 from seaborn._core.scales import Scale, Nominal
30 from seaborn._core.subplots import Subplots
31 from seaborn._core.groupby import GroupBy
32 from seaborn._core.properties import PROPERTIES, Property
33 from seaborn._core.typing import (
34     DataSource,
35     VariableSpec,
36     VariableSpecList,
37     OrderSpec,
38     Default,
39 )
40 from seaborn._core.exceptions import PlotSpecError
41 from seaborn._core.rules import categorical_order
42 from seaborn._compat import set_scale_obj, set_layout_engine
43 from seaborn.rcmod import axes_style, plotting_context
44 from seaborn.palettes import color_palette
45 from seaborn.utils import _version_predates
46 
47 from typing import TYPE_CHECKING, TypedDict
48 if TYPE_CHECKING:
49     from matplotlib.figure import SubFigure
50 
51 
52 default = Default()
53 
54 
55 # ---- Definitions for internal specs ---------------------------------------------- #
56 
57 
58 class Layer(TypedDict, total=False):
59 
60     mark: Mark  # TODO allow list?
61     stat: Stat | None  # TODO allow list?
62     move: Move | list[Move] | None
63     data: PlotData
64     source: DataSource
65     vars: dict[str, VariableSpec]
66     orient: str
67     legend: bool
68 
69 
70 class FacetSpec(TypedDict, total=False):
71 
72     variables: dict[str, VariableSpec]
73     structure: dict[str, list[str]]
74     wrap: int | None
75 
76 
77 class PairSpec(TypedDict, total=False):
78 
79     variables: dict[str, VariableSpec]
80     structure: dict[str, list[str]]
81     cross: bool
82     wrap: int | None
83 
84 
85 # --- Local helpers ---------------------------------------------------------------- #
86 
87 
88 @contextmanager
89 def theme_context(params: dict[str, Any]) -> Generator:
90     """Temporarily modify specifc matplotlib rcParams."""
91     orig_params = {k: mpl.rcParams[k] for k in params}
92     color_codes = "bgrmyck"
93     nice_colors = [*color_palette("deep6"), (.15, .15, .15)]
94     orig_colors = [mpl.colors.colorConverter.colors[x] for x in color_codes]
95     # TODO how to allow this to reflect the color cycle when relevant?
96     try:
97         mpl.rcParams.update(params)
98         for (code, color) in zip(color_codes, nice_colors):
99             mpl.colors.colorConverter.colors[code] = color
100         yield
101     finally:
102         mpl.rcParams.update(orig_params)
103         for (code, color) in zip(color_codes, orig_colors):
104             mpl.colors.colorConverter.colors[code] = color
105 
106 
107 def build_plot_signature(cls):
108     """
109     Decorator function for giving Plot a useful signature.
110 
111     Currently this mostly saves us some duplicated typing, but we would
112     like eventually to have a way of registering new semantic properties,
113     at which point dynamic signature generation would become more important.
114 
115     """
116     sig = inspect.signature(cls)
117     params = [
118         inspect.Parameter("args", inspect.Parameter.VAR_POSITIONAL),
119         inspect.Parameter("data", inspect.Parameter.KEYWORD_ONLY, default=None)
120     ]
121     params.extend([
122         inspect.Parameter(name, inspect.Parameter.KEYWORD_ONLY, default=None)
123         for name in PROPERTIES
124     ])
125     new_sig = sig.replace(parameters=params)
126     cls.__signature__ = new_sig
127 
128     known_properties = textwrap.fill(
129         ", ".join([f"|{p}|" for p in PROPERTIES]),
130         width=78, subsequent_indent=" " * 8,
131     )
132 
133     if cls.__doc__ is not None:  # support python -OO mode
134         cls.__doc__ = cls.__doc__.format(known_properties=known_properties)
135 
136     return cls
137 
138 
139 # ---- Plot configuration ---------------------------------------------------------- #
140 
141 
142 class ThemeConfig(mpl.RcParams):
143     """
144     Configuration object for the Plot.theme, using matplotlib rc parameters.
145     """
146     THEME_GROUPS = [
147         "axes", "figure", "font", "grid", "hatch", "legend", "lines",
148         "mathtext", "markers", "patch", "savefig", "scatter",
149         "xaxis", "xtick", "yaxis", "ytick",
150     ]
151 
152     def __init__(self):
153         super().__init__()
154         self.reset()
155 
156     @property
157     def _default(self) -> dict[str, Any]:
158 
159         return {
160             **self._filter_params(mpl.rcParamsDefault),
161             **axes_style("darkgrid"),
162             **plotting_context("notebook"),
163             "axes.prop_cycle": cycler("color", color_palette("deep")),
164         }
165 
166     def reset(self) -> None:
167         """Update the theme dictionary with seaborn's default values."""
168         self.update(self._default)
169 
170     def update(self, other: dict[str, Any] | None = None, /, **kwds):
171         """Update the theme with a dictionary or keyword arguments of rc parameters."""
172         if other is not None:
173             theme = self._filter_params(other)
174         else:
175             theme = {}
176         theme.update(kwds)
177         super().update(theme)
178 
179     def _filter_params(self, params: dict[str, Any]) -> dict[str, Any]:
180         """Restruct to thematic rc params."""
181         return {
182             k: v for k, v in params.items()
183             if any(k.startswith(p) for p in self.THEME_GROUPS)
184         }
185 
186     def _html_table(self, params: dict[str, Any]) -> list[str]:
187 
188         lines = ["<table>"]
189         for k, v in params.items():
190             row = f"<tr><td>{k}:</td><td style='text-align:left'>{v!r}</td></tr>"
191             lines.append(row)
192         lines.append("</table>")
193         return lines
194 
195     def _repr_html_(self) -> str:
196 
197         repr = [
198             "<div style='height: 300px'>",
199             "<div style='border-style: inset; border-width: 2px'>",
200             *self._html_table(self),
201             "</div>",
202             "</div>",
203         ]
204         return "\n".join(repr)
205 
206 
207 class DisplayConfig(TypedDict):
208     """Configuration for IPython's rich display hooks."""
209     format: Literal["png", "svg"]
210     scaling: float
211     hidpi: bool
212 
213 
214 class PlotConfig:
215     """Configuration for default behavior / appearance of class:`Plot` instances."""
216     def __init__(self):
217 
218         self._theme = ThemeConfig()
219         self._display = {"format": "png", "scaling": .85, "hidpi": True}
220 
221     @property
222     def theme(self) -> dict[str, Any]:
223         """
224         Dictionary of base theme parameters for :class:`Plot`.
225 
226         Keys and values correspond to matplotlib rc params, as documented here:
227         https://matplotlib.org/stable/tutorials/introductory/customizing.html
228 
229         """
230         return self._theme
231 
232     @property
233     def display(self) -> DisplayConfig:
234         """
235         Dictionary of parameters for rich display in Jupyter notebook.
236 
237         Valid parameters:
238 
239         - format ("png" or "svg"): Image format to produce
240         - scaling (float): Relative scaling of embedded image
241         - hidpi (bool): When True, double the DPI while preserving the size
242 
243         """
244         return self._display
245 
246 
247 # ---- The main interface for declarative plotting --------------------------------- #
248 
249 
250 @build_plot_signature
251 class Plot:
252     """
253     An interface for declaratively specifying statistical graphics.
254 
255     Plots are constructed by initializing this class and adding one or more
256     layers, comprising a `Mark` and optional `Stat` or `Move`.  Additionally,
257     faceting variables or variable pairings may be defined to divide the space
258     into multiple subplots. The mappings from data values to visual properties
259     can be parametrized using scales, although the plot will try to infer good
260     defaults when scales are not explicitly defined.
261 
262     The constructor accepts a data source (a :class:`pandas.DataFrame` or
263     dictionary with columnar values) and variable assignments. Variables can be
264     passed as keys to the data source or directly as data vectors.  If multiple
265     data-containing objects are provided, they will be index-aligned.
266 
267     The data source and variables defined in the constructor will be used for
268     all layers in the plot, unless overridden or disabled when adding a layer.
269 
270     The following variables can be defined in the constructor:
271         {known_properties}
272 
273     The `data`, `x`, and `y` variables can be passed as positional arguments or
274     using keywords. Whether the first positional argument is interpreted as a
275     data source or `x` variable depends on its type.
276 
277     The methods of this class return a copy of the instance; use chaining to
278     build up a plot through multiple calls. Methods can be called in any order.
279 
280     Most methods only add information to the plot spec; no actual processing
281     happens until the plot is shown or saved. It is also possible to compile
282     the plot without rendering it to access the lower-level representation.
283 
284     """
285     config = PlotConfig()
286 
287     _data: PlotData
288     _layers: list[Layer]
289 
290     _scales: dict[str, Scale]
291     _shares: dict[str, bool | str]
292     _limits: dict[str, tuple[Any, Any]]
293     _labels: dict[str, str | Callable[[str], str]]
294     _theme: dict[str, Any]
295 
296     _facet_spec: FacetSpec
297     _pair_spec: PairSpec
298 
299     _figure_spec: dict[str, Any]
300     _subplot_spec: dict[str, Any]
301     _layout_spec: dict[str, Any]
302 
303     def __init__(
304         self,
305         *args: DataSource | VariableSpec,
306         data: DataSource = None,
307         **variables: VariableSpec,
308     ):
309 
310         if args:
311             data, variables = self._resolve_positionals(args, data, variables)
312 
313         unknown = [x for x in variables if x not in PROPERTIES]
314         if unknown:
315             err = f"Plot() got unexpected keyword argument(s): {', '.join(unknown)}"
316             raise TypeError(err)
317 
318         self._data = PlotData(data, variables)
319 
320         self._layers = []
321 
322         self._scales = {}
323         self._shares = {}
324         self._limits = {}
325         self._labels = {}
326         self._theme = {}
327 
328         self._facet_spec = {}
329         self._pair_spec = {}
330 
331         self._figure_spec = {}
332         self._subplot_spec = {}
333         self._layout_spec = {}
334 
335         self._target = None
336 
337     def _resolve_positionals(
338         self,
339         args: tuple[DataSource | VariableSpec, ...],
340         data: DataSource,
341         variables: dict[str, VariableSpec],
342     ) -> tuple[DataSource, dict[str, VariableSpec]]:
343         """Handle positional arguments, which may contain data / x / y."""
344         if len(args) > 3:
345             err = "Plot() accepts no more than 3 positional arguments (data, x, y)."
346             raise TypeError(err)
347 
348         # TODO need some clearer way to differentiate data / vector here
349         # (There might be an abstract DataFrame class to use here?)
350         if isinstance(args[0], (abc.Mapping, pd.DataFrame)):
351             if data is not None:
352                 raise TypeError("`data` given by both name and position.")
353             data, args = args[0], args[1:]
354 
355         if len(args) == 2:
356             x, y = args
357         elif len(args) == 1:
358             x, y = *args, None
359         else:
360             x = y = None
361 
362         for name, var in zip("yx", (y, x)):
363             if var is not None:
364                 if name in variables:
365                     raise TypeError(f"`{name}` given by both name and position.")
366                 # Keep coordinates at the front of the variables dict
367                 # Cast type because we know this isn't a DataSource at this point
368                 variables = {name: cast(VariableSpec, var), **variables}
369 
370         return data, variables
371 
372     def __add__(self, other):
373 
374         if isinstance(other, Mark) or isinstance(other, Stat):
375             raise TypeError("Sorry, this isn't ggplot! Perhaps try Plot.add?")
376 
377         other_type = other.__class__.__name__
378         raise TypeError(f"Unsupported operand type(s) for +: 'Plot' and '{other_type}")
379 
380     def _repr_png_(self) -> tuple[bytes, dict[str, float]] | None:
381 
382         if Plot.config.display["format"] != "png":
383             return None
384         return self.plot()._repr_png_()
385 
386     def _repr_svg_(self) -> str | None:
387 
388         if Plot.config.display["format"] != "svg":
389             return None
390         return self.plot()._repr_svg_()
391 
392     def _clone(self) -> Plot:
393         """Generate a new object with the same information as the current spec."""
394         new = Plot()
395 
396         # TODO any way to enforce that data does not get mutated?
397         new._data = self._data
398 
399         new._layers.extend(self._layers)
400 
401         new._scales.update(self._scales)
402         new._shares.update(self._shares)
403         new._limits.update(self._limits)
404         new._labels.update(self._labels)
405         new._theme.update(self._theme)
406 
407         new._facet_spec.update(self._facet_spec)
408         new._pair_spec.update(self._pair_spec)
409 
410         new._figure_spec.update(self._figure_spec)
411         new._subplot_spec.update(self._subplot_spec)
412         new._layout_spec.update(self._layout_spec)
413 
414         new._target = self._target
415 
416         return new
417 
418     def _theme_with_defaults(self) -> dict[str, Any]:
419 
420         theme = self.config.theme.copy()
421         theme.update(self._theme)
422         return theme
423 
424     @property
425     def _variables(self) -> list[str]:
426 
427         variables = (
428             list(self._data.frame)
429             + list(self._pair_spec.get("variables", []))
430             + list(self._facet_spec.get("variables", []))
431         )
432         for layer in self._layers:
433             variables.extend(v for v in layer["vars"] if v not in variables)
434 
435         # Coerce to str in return to appease mypy; we know these will only
436         # ever be strings but I don't think we can type a DataFrame that way yet
437         return [str(v) for v in variables]
438 
439     def on(self, target: Axes | SubFigure | Figure) -> Plot:
440         """
441         Provide existing Matplotlib figure or axes for drawing the plot.
442 
443         When using this method, you will also need to explicitly call a method that
444         triggers compilation, such as :meth:`Plot.show` or :meth:`Plot.save`. If you
445         want to postprocess using matplotlib, you'd need to call :meth:`Plot.plot`
446         first to compile the plot without rendering it.
447 
448         Parameters
449         ----------
450         target : Axes, SubFigure, or Figure
451             Matplotlib object to use. Passing :class:`matplotlib.axes.Axes` will add
452             artists without otherwise modifying the figure. Otherwise, subplots will be
453             created within the space of the given :class:`matplotlib.figure.Figure` or
454             :class:`matplotlib.figure.SubFigure`.
455 
456         Examples
457         --------
458         .. include:: ../docstrings/objects.Plot.on.rst
459 
460         """
461         accepted_types: tuple  # Allow tuple of various length
462         if hasattr(mpl.figure, "SubFigure"):  # Added in mpl 3.4
463             accepted_types = (
464                 mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure
465             )
466             accepted_types_str = (
467                 f"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}"
468             )
469         else:
470             accepted_types = mpl.axes.Axes, mpl.figure.Figure
471             accepted_types_str = f"{mpl.axes.Axes} or {mpl.figure.Figure}"
472 
473         if not isinstance(target, accepted_types):
474             err = (
475                 f"The `Plot.on` target must be an instance of {accepted_types_str}. "
476                 f"You passed an instance of {target.__class__} instead."
477             )
478             raise TypeError(err)
479 
480         new = self._clone()
481         new._target = target
482 
483         return new
484 
485     def add(
486         self,
487         mark: Mark,
488         *transforms: Stat | Mark,
489         orient: str | None = None,
490         legend: bool = True,
491         data: DataSource = None,
492         **variables: VariableSpec,
493     ) -> Plot:
494         """
495         Specify a layer of the visualization in terms of mark and data transform(s).
496 
497         This is the main method for specifying how the data should be visualized.
498         It can be called multiple times with different arguments to define
499         a plot with multiple layers.
500 
501         Parameters
502         ----------
503         mark : :class:`Mark`
504             The visual representation of the data to use in this layer.
505         transforms : :class:`Stat` or :class:`Move`
506             Objects representing transforms to be applied before plotting the data.
507             Currently, at most one :class:`Stat` can be used, and it
508             must be passed first. This constraint will be relaxed in the future.
509         orient : "x", "y", "v", or "h"
510             The orientation of the mark, which also affects how transforms are computed.
511             Typically corresponds to the axis that defines groups for aggregation.
512             The "v" (vertical) and "h" (horizontal) options are synonyms for "x" / "y",
513             but may be more intuitive with some marks. When not provided, an
514             orientation will be inferred from characteristics of the data and scales.
515         legend : bool
516             Option to suppress the mark/mappings for this layer from the legend.
517         data : DataFrame or dict
518             Data source to override the global source provided in the constructor.
519         variables : data vectors or identifiers
520             Additional layer-specific variables, including variables that will be
521             passed directly to the transforms without scaling.
522 
523         Examples
524         --------
525         .. include:: ../docstrings/objects.Plot.add.rst
526 
527         """
528         if not isinstance(mark, Mark):
529             msg = f"mark must be a Mark instance, not {type(mark)!r}."
530             raise TypeError(msg)
531 
532         # TODO This API for transforms was a late decision, and previously Plot.add
533         # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.
534         # It will take some work to refactor the internals so that Stat and Move are
535         # treated identically, and until then well need to "unpack" the transforms
536         # here and enforce limitations on the order / types.
537 
538         stat: Optional[Stat]
539         move: Optional[List[Move]]
540         error = False
541         if not transforms:
542             stat, move = None, None
543         elif isinstance(transforms[0], Stat):
544             stat = transforms[0]
545             move = [m for m in transforms[1:] if isinstance(m, Move)]
546             error = len(move) != len(transforms) - 1
547         else:
548             stat = None
549             move = [m for m in transforms if isinstance(m, Move)]
550             error = len(move) != len(transforms)
551 
552         if error:
553             msg = " ".join([
554                 "Transforms must have at most one Stat type (in the first position),",
555                 "and all others must be a Move type. Given transform type(s):",
556                 ", ".join(str(type(t).__name__) for t in transforms) + "."
557             ])
558             raise TypeError(msg)
559 
560         new = self._clone()
561         new._layers.append({
562             "mark": mark,
563             "stat": stat,
564             "move": move,
565             # TODO it doesn't work to supply scalars to variables, but it should
566             "vars": variables,
567             "source": data,
568             "legend": legend,
569             "orient": {"v": "x", "h": "y"}.get(orient, orient),  # type: ignore
570         })
571 
572         return new
573 
574     def pair(
575         self,
576         x: VariableSpecList = None,
577         y: VariableSpecList = None,
578         wrap: int | None = None,
579         cross: bool = True,
580     ) -> Plot:
581         """
582         Produce subplots by pairing multiple `x` and/or `y` variables.
583 
584         Parameters
585         ----------
586         x, y : sequence(s) of data vectors or identifiers
587             Variables that will define the grid of subplots.
588         wrap : int
589             When using only `x` or `y`, "wrap" subplots across a two-dimensional grid
590             with this many columns (when using `x`) or rows (when using `y`).
591         cross : bool
592             When False, zip the `x` and `y` lists such that the first subplot gets the
593             first pair, the second gets the second pair, etc. Otherwise, create a
594             two-dimensional grid from the cartesian product of the lists.
595 
596         Examples
597         --------
598         .. include:: ../docstrings/objects.Plot.pair.rst
599 
600         """
601         # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows
602         # This may also be possible by setting `wrap=1`, but is that too unobvious?
603         # TODO PairGrid features not currently implemented: diagonals, corner
604 
605         pair_spec: PairSpec = {}
606 
607         axes = {"x": [] if x is None else x, "y": [] if y is None else y}
608         for axis, arg in axes.items():
609             if isinstance(arg, (str, int)):
610                 err = f"You must pass a sequence of variable keys to `{axis}`"
611                 raise TypeError(err)
612 
613         pair_spec["variables"] = {}
614         pair_spec["structure"] = {}
615 
616         for axis in "xy":
617             keys = []
618             for i, col in enumerate(axes[axis]):
619                 key = f"{axis}{i}"
620                 keys.append(key)
621                 pair_spec["variables"][key] = col
622 
623             if keys:
624                 pair_spec["structure"][axis] = keys
625 
626         if not cross and len(axes["x"]) != len(axes["y"]):
627             err = "Lengths of the `x` and `y` lists must match with cross=False"
628             raise ValueError(err)
629 
630         pair_spec["cross"] = cross
631         pair_spec["wrap"] = wrap
632 
633         new = self._clone()
634         new._pair_spec.update(pair_spec)
635         return new
636 
637     def facet(
638         self,
639         col: VariableSpec = None,
640         row: VariableSpec = None,
641         order: OrderSpec | dict[str, OrderSpec] = None,
642         wrap: int | None = None,
643     ) -> Plot:
644         """
645         Produce subplots with conditional subsets of the data.
646 
647         Parameters
648         ----------
649         col, row : data vectors or identifiers
650             Variables used to define subsets along the columns and/or rows of the grid.
651             Can be references to the global data source passed in the constructor.
652         order : list of strings, or dict with dimensional keys
653             Define the order of the faceting variables.
654         wrap : int
655             When using only `col` or `row`, wrap subplots across a two-dimensional
656             grid with this many subplots on the faceting dimension.
657 
658         Examples
659         --------
660         .. include:: ../docstrings/objects.Plot.facet.rst
661 
662         """
663         variables: dict[str, VariableSpec] = {}
664         if col is not None:
665             variables["col"] = col
666         if row is not None:
667             variables["row"] = row
668 
669         structure = {}
670         if isinstance(order, dict):
671             for dim in ["col", "row"]:
672                 dim_order = order.get(dim)
673                 if dim_order is not None:
674                     structure[dim] = list(dim_order)
675         elif order is not None:
676             if col is not None and row is not None:
677                 err = " ".join([
678                     "When faceting on both col= and row=, passing `order` as a list"
679                     "is ambiguous. Use a dict with 'col' and/or 'row' keys instead."
680                 ])
681                 raise RuntimeError(err)
682             elif col is not None:
683                 structure["col"] = list(order)
684             elif row is not None:
685                 structure["row"] = list(order)
686 
687         spec: FacetSpec = {
688             "variables": variables,
689             "structure": structure,
690             "wrap": wrap,
691         }
692 
693         new = self._clone()
694         new._facet_spec.update(spec)
695 
696         return new
697 
698     # TODO def twin()?
699 
700     def scale(self, **scales: Scale) -> Plot:
701         """
702         Specify mappings from data units to visual properties.
703 
704         Keywords correspond to variables defined in the plot, including coordinate
705         variables (`x`, `y`) and semantic variables (`color`, `pointsize`, etc.).
706 
707         A number of "magic" arguments are accepted, including:
708             - The name of a transform (e.g., `"log"`, `"sqrt"`)
709             - The name of a palette (e.g., `"viridis"`, `"muted"`)
710             - A tuple of values, defining the output range (e.g. `(1, 5)`)
711             - A dict, implying a :class:`Nominal` scale (e.g. `{"a": .2, "b": .5}`)
712             - A list of values, implying a :class:`Nominal` scale (e.g. `["b", "r"]`)
713 
714         For more explicit control, pass a scale spec object such as :class:`Continuous`
715         or :class:`Nominal`. Or pass `None` to use an "identity" scale, which treats
716         data values as literally encoding visual properties.
717 
718         Examples
719         --------
720         .. include:: ../docstrings/objects.Plot.scale.rst
721 
722         """
723         new = self._clone()
724         new._scales.update(scales)
725         return new
726 
727     def share(self, **shares: bool | str) -> Plot:
728         """
729         Control sharing of axis limits and ticks across subplots.
730 
731         Keywords correspond to variables defined in the plot, and values can be
732         boolean (to share across all subplots), or one of "row" or "col" (to share
733         more selectively across one dimension of a grid).
734 
735         Behavior for non-coordinate variables is currently undefined.
736 
737         Examples
738         --------
739         .. include:: ../docstrings/objects.Plot.share.rst
740 
741         """
742         new = self._clone()
743         new._shares.update(shares)
744         return new
745 
746     def limit(self, **limits: tuple[Any, Any]) -> Plot:
747         """
748         Control the range of visible data.
749 
750         Keywords correspond to variables defined in the plot, and values are a
751         `(min, max)` tuple (where either can be `None` to leave unset).
752 
753         Limits apply only to the axis; data outside the visible range are
754         still used for any stat transforms and added to the plot.
755 
756         Behavior for non-coordinate variables is currently undefined.
757 
758         Examples
759         --------
760         .. include:: ../docstrings/objects.Plot.limit.rst
761 
762         """
763         new = self._clone()
764         new._limits.update(limits)
765         return new
766 
767     def label(self, *, title=None, **variables: str | Callable[[str], str]) -> Plot:
768         """
769         Control the labels and titles for axes, legends, and subplots.
770 
771         Additional keywords correspond to variables defined in the plot.
772         Values can be one of the following types:
773 
774         - string (used literally; pass "" to clear the default label)
775         - function (called on the default label)
776 
777         For coordinate variables, the value sets the axis label.
778         For semantic variables, the value sets the legend title.
779         For faceting variables, `title=` modifies the subplot-specific label,
780         while `col=` and/or `row=` add a label for the faceting variable.
781         When using a single subplot, `title=` sets its title.
782 
783         Examples
784         --------
785         .. include:: ../docstrings/objects.Plot.label.rst
786 
787 
788         """
789         new = self._clone()
790         if title is not None:
791             new._labels["title"] = title
792         new._labels.update(variables)
793         return new
794 
795     def layout(
796         self,
797         *,
798         size: tuple[float, float] | Default = default,
799         engine: str | None | Default = default,
800     ) -> Plot:
801         """
802         Control the figure size and layout.
803 
804         .. note::
805 
806             Default figure sizes and the API for specifying the figure size are subject
807             to change in future "experimental" releases of the objects API. The default
808             layout engine may also change.
809 
810         Parameters
811         ----------
812         size : (width, height)
813             Size of the resulting figure, in inches. Size is inclusive of legend when
814             using pyplot, but not otherwise.
815         engine : {{"tight", "constrained", None}}
816             Name of method for automatically adjusting the layout to remove overlap.
817             The default depends on whether :meth:`Plot.on` is used.
818 
819         Examples
820         --------
821         .. include:: ../docstrings/objects.Plot.layout.rst
822 
823         """
824         # TODO add an "auto" mode for figsize that roughly scales with the rcParams
825         # figsize (so that works), but expands to prevent subplots from being squished
826         # Also should we have height=, aspect=, exclusive with figsize? Or working
827         # with figsize when only one is defined?
828 
829         new = self._clone()
830 
831         if size is not default:
832             new._figure_spec["figsize"] = size
833         if engine is not default:
834             new._layout_spec["engine"] = engine
835 
836         return new
837 
838     # TODO def legend (ugh)
839 
840     def theme(self, *args: dict[str, Any]) -> Plot:
841         """
842         Control the appearance of elements in the plot.
843 
844         .. note::
845 
846             The API for customizing plot appearance is not yet finalized.
847             Currently, the only valid argument is a dict of matplotlib rc parameters.
848             (This dict must be passed as a positional argument.)
849 
850             It is likely that this method will be enhanced in future releases.
851 
852         Matplotlib rc parameters are documented on the following page:
853         https://matplotlib.org/stable/tutorials/introductory/customizing.html
854 
855         Examples
856         --------
857         .. include:: ../docstrings/objects.Plot.theme.rst
858 
859         """
860         new = self._clone()
861 
862         # We can skip this whole block on Python 3.8+ with positional-only syntax
863         nargs = len(args)
864         if nargs != 1:
865             err = f"theme() takes 1 positional argument, but {nargs} were given"
866             raise TypeError(err)
867 
868         rc = mpl.RcParams(args[0])
869         new._theme.update(rc)
870 
871         return new
872 
873     def save(self, loc, **kwargs) -> Plot:
874         """
875         Compile the plot and write it to a buffer or file on disk.
876 
877         Parameters
878         ----------
879         loc : str, path, or buffer
880             Location on disk to save the figure, or a buffer to write into.
881         kwargs
882             Other keyword arguments are passed through to
883             :meth:`matplotlib.figure.Figure.savefig`.
884 
885         """
886         # TODO expose important keyword arguments in our signature?
887         with theme_context(self._theme_with_defaults()):
888             self._plot().save(loc, **kwargs)
889         return self
890 
891     def show(self, **kwargs) -> None:
892         """
893         Compile the plot and display it by hooking into pyplot.
894 
895         Calling this method is not necessary to render a plot in notebook context,
896         but it may be in other environments (e.g., in a terminal). After compiling the
897         plot, it calls :func:`matplotlib.pyplot.show` (passing any keyword parameters).
898 
899         Unlike other :class:`Plot` methods, there is no return value. This should be
900         the last method you call when specifying a plot.
901 
902         """
903         # TODO make pyplot configurable at the class level, and when not using,
904         # import IPython.display and call on self to populate cell output?
905 
906         # Keep an eye on whether matplotlib implements "attaching" an existing
907         # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024
908 
909         self.plot(pyplot=True).show(**kwargs)
910 
911     def plot(self, pyplot: bool = False) -> Plotter:
912         """
913         Compile the plot spec and return the Plotter object.
914         """
915         with theme_context(self._theme_with_defaults()):
916             return self._plot(pyplot)
917 
918     def _plot(self, pyplot: bool = False) -> Plotter:
919 
920         # TODO if we have _target object, pyplot should be determined by whether it
921         # is hooked into the pyplot state machine (how do we check?)
922 
923         plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())
924 
925         # Process the variable assignments and initialize the figure
926         common, layers = plotter._extract_data(self)
927         plotter._setup_figure(self, common, layers)
928 
929         # Process the scale spec for coordinate variables and transform their data
930         coord_vars = [v for v in self._variables if re.match(r"^x|y", v)]
931         plotter._setup_scales(self, common, layers, coord_vars)
932 
933         # Apply statistical transform(s)
934         plotter._compute_stats(self, layers)
935 
936         # Process scale spec for semantic variables and coordinates computed by stat
937         plotter._setup_scales(self, common, layers)
938 
939         # TODO Remove these after updating other methods
940         # ---- Maybe have debug= param that attaches these when True?
941         plotter._data = common
942         plotter._layers = layers
943 
944         # Process the data for each layer and add matplotlib artists
945         for layer in layers:
946             plotter._plot_layer(self, layer)
947 
948         # Add various figure decorations
949         plotter._make_legend(self)
950         plotter._finalize_figure(self)
951 
952         return plotter
953 
954 
955 # ---- The plot compilation engine ---------------------------------------------- #
956 
957 
958 class Plotter:
959     """
960     Engine for compiling a :class:`Plot` spec into a Matplotlib figure.
961 
962     This class is not intended to be instantiated directly by users.
963 
964     """
965     # TODO decide if we ever want these (Plot.plot(debug=True))?
966     _data: PlotData
967     _layers: list[Layer]
968     _figure: Figure
969 
970     def __init__(self, pyplot: bool, theme: dict[str, Any]):
971 
972         self._pyplot = pyplot
973         self._theme = theme
974         self._legend_contents: list[tuple[
975             tuple[str, str | int], list[Artist], list[str],
976         ]] = []
977         self._scales: dict[str, Scale] = {}
978 
979     def save(self, loc, **kwargs) -> Plotter:  # TODO type args
980         kwargs.setdefault("dpi", 96)
981         try:
982             loc = os.path.expanduser(loc)
983         except TypeError:
984             # loc may be a buffer in which case that would not work
985             pass
986         self._figure.savefig(loc, **kwargs)
987         return self
988 
989     def show(self, **kwargs) -> None:
990         """
991         Display the plot by hooking into pyplot.
992 
993         This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.
994 
995         """
996         # TODO if we did not create the Plotter with pyplot, is it possible to do this?
997         # If not we should clearly raise.
998         import matplotlib.pyplot as plt
999         with theme_context(self._theme):
1000             plt.show(**kwargs)
1001 
1002     # TODO API for accessing the underlying matplotlib objects
1003     # TODO what else is useful in the public API for this class?
1004 
1005     def _repr_png_(self) -> tuple[bytes, dict[str, float]] | None:
1006 
1007         # TODO use matplotlib backend directly instead of going through savefig?
1008 
1009         # TODO perhaps have self.show() flip a switch to disable this, so that
1010         # user does not end up with two versions of the figure in the output
1011 
1012         # TODO use bbox_inches="tight" like the inline backend?
1013         # pro: better results,  con: (sometimes) confusing results
1014         # Better solution would be to default (with option to change)
1015         # to using constrained/tight layout.
1016 
1017         if Plot.config.display["format"] != "png":
1018             return None
1019 
1020         buffer = io.BytesIO()
1021 
1022         factor = 2 if Plot.config.display["hidpi"] else 1
1023         scaling = Plot.config.display["scaling"] / factor
1024         dpi = 96 * factor  # TODO put dpi in Plot.config?
1025 
1026         with theme_context(self._theme):  # TODO _theme_with_defaults?
1027             self._figure.savefig(buffer, dpi=dpi, format="png", bbox_inches="tight")
1028         data = buffer.getvalue()
1029 
1030         w, h = Image.open(buffer).size
1031         metadata = {"width": w * scaling, "height": h * scaling}
1032         return data, metadata
1033 
1034     def _repr_svg_(self) -> str | None:
1035 
1036         if Plot.config.display["format"] != "svg":
1037             return None
1038 
1039         # TODO DPI for rasterized artists?
1040 
1041         scaling = Plot.config.display["scaling"]
1042 
1043         buffer = io.StringIO()
1044         with theme_context(self._theme):  # TODO _theme_with_defaults?
1045             self._figure.savefig(buffer, format="svg", bbox_inches="tight")
1046 
1047         root = ElementTree.fromstring(buffer.getvalue())
1048         w = scaling * float(root.attrib["width"][:-2])
1049         h = scaling * float(root.attrib["height"][:-2])
1050         root.attrib.update(width=f"{w}pt", height=f"{h}pt", viewbox=f"0 0 {w} {h}")
1051         ElementTree.ElementTree(root).write(out := io.BytesIO())
1052 
1053         return out.getvalue().decode()
1054 
1055     def _extract_data(self, p: Plot) -> tuple[PlotData, list[Layer]]:
1056 
1057         common_data = (
1058             p._data
1059             .join(None, p._facet_spec.get("variables"))
1060             .join(None, p._pair_spec.get("variables"))
1061         )
1062 
1063         layers: list[Layer] = []
1064         for layer in p._layers:
1065             spec = layer.copy()
1066             spec["data"] = common_data.join(layer.get("source"), layer.get("vars"))
1067             layers.append(spec)
1068 
1069         return common_data, layers
1070 
1071     def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -> str:
1072 
1073         label: str
1074         if var in p._labels:
1075             manual_label = p._labels[var]
1076             if callable(manual_label) and auto_label is not None:
1077                 label = manual_label(auto_label)
1078             else:
1079                 label = cast(str, manual_label)
1080         elif auto_label is None:
1081             label = ""
1082         else:
1083             label = auto_label
1084         return label
1085 
1086     def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -> None:
1087 
1088         # --- Parsing the faceting/pairing parameterization to specify figure grid
1089 
1090         subplot_spec = p._subplot_spec.copy()
1091         facet_spec = p._facet_spec.copy()
1092         pair_spec = p._pair_spec.copy()
1093 
1094         for axis in "xy":
1095             if axis in p._shares:
1096                 subplot_spec[f"share{axis}"] = p._shares[axis]
1097 
1098         for dim in ["col", "row"]:
1099             if dim in common.frame and dim not in facet_spec["structure"]:
1100                 order = categorical_order(common.frame[dim])
1101                 facet_spec["structure"][dim] = order
1102 
1103         self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)
1104 
1105         # --- Figure initialization
1106         self._figure = subplots.init_figure(
1107             pair_spec, self._pyplot, p._figure_spec, p._target,
1108         )
1109 
1110         # --- Figure annotation
1111         for sub in subplots:
1112             ax = sub["ax"]
1113             for axis in "xy":
1114                 axis_key = sub[axis]
1115 
1116                 # ~~ Axis labels
1117 
1118                 # TODO Should we make it possible to use only one x/y label for
1119                 # all rows/columns in a faceted plot? Maybe using sub{axis}label,
1120                 # although the alignments of the labels from that method leaves
1121                 # something to be desired (in terms of how it defines 'centered').
1122                 names = [
1123                     common.names.get(axis_key),
1124                     *(layer["data"].names.get(axis_key) for layer in layers)
1125                 ]
1126                 auto_label = next((name for name in names if name is not None), None)
1127                 label = self._resolve_label(p, axis_key, auto_label)
1128                 ax.set(**{f"{axis}label": label})
1129 
1130                 # ~~ Decoration visibility
1131 
1132                 # TODO there should be some override (in Plot.layout?) so that
1133                 # axis / tick labels can be shown on interior shared axes if desired
1134 
1135                 axis_obj = getattr(ax, f"{axis}axis")
1136                 visible_side = {"x": "bottom", "y": "left"}.get(axis)
1137                 show_axis_label = (
1138                     sub[visible_side]
1139                     or not p._pair_spec.get("cross", True)
1140                     or (
1141                         axis in p._pair_spec.get("structure", {})
1142                         and bool(p._pair_spec.get("wrap"))
1143                     )
1144                 )
1145                 axis_obj.get_label().set_visible(show_axis_label)
1146 
1147                 show_tick_labels = (
1148                     show_axis_label
1149                     or subplot_spec.get(f"share{axis}") not in (
1150                         True, "all", {"x": "col", "y": "row"}[axis]
1151                     )
1152                 )
1153                 for group in ("major", "minor"):
1154                     for t in getattr(axis_obj, f"get_{group}ticklabels")():
1155                         t.set_visible(show_tick_labels)
1156 
1157             # TODO we want right-side titles for row facets in most cases?
1158             # Let's have what we currently call "margin titles" but properly using the
1159             # ax.set_title interface (see my gist)
1160             title_parts = []
1161             for dim in ["col", "row"]:
1162                 if sub[dim] is not None:
1163                     val = self._resolve_label(p, "title", f"{sub[dim]}")
1164                     if dim in p._labels:
1165                         key = self._resolve_label(p, dim, common.names.get(dim))
1166                         val = f"{key} {val}"
1167                     title_parts.append(val)
1168 
1169             has_col = sub["col"] is not None
1170             has_row = sub["row"] is not None
1171             show_title = (
1172                 has_col and has_row
1173                 or (has_col or has_row) and p._facet_spec.get("wrap")
1174                 or (has_col and sub["top"])
1175                 # TODO or has_row and sub["right"] and <right titles>
1176                 or has_row  # TODO and not <right titles>
1177             )
1178             if title_parts:
1179                 title = " | ".join(title_parts)
1180                 title_text = ax.set_title(title)
1181                 title_text.set_visible(show_title)
1182             elif not (has_col or has_row):
1183                 title = self._resolve_label(p, "title", None)
1184                 title_text = ax.set_title(title)
1185 
1186     def _compute_stats(self, spec: Plot, layers: list[Layer]) -> None:
1187 
1188         grouping_vars = [v for v in PROPERTIES if v not in "xy"]
1189         grouping_vars += ["col", "row", "group"]
1190 
1191         pair_vars = spec._pair_spec.get("structure", {})
1192 
1193         for layer in layers:
1194 
1195             data = layer["data"]
1196             mark = layer["mark"]
1197             stat = layer["stat"]
1198 
1199             if stat is None:
1200                 continue
1201 
1202             iter_axes = itertools.product(*[
1203                 pair_vars.get(axis, [axis]) for axis in "xy"
1204             ])
1205 
1206             old = data.frame
1207 
1208             if pair_vars:
1209                 data.frames = {}
1210                 data.frame = data.frame.iloc[:0]  # TODO to simplify typing
1211 
1212             for coord_vars in iter_axes:
1213 
1214                 pairings = "xy", coord_vars
1215 
1216                 df = old.copy()
1217                 scales = self._scales.copy()
1218 
1219                 for axis, var in zip(*pairings):
1220                     if axis != var:
1221                         df = df.rename(columns={var: axis})
1222                         drop_cols = [x for x in df if re.match(rf"{axis}\d+", str(x))]
1223                         df = df.drop(drop_cols, axis=1)
1224                         scales[axis] = scales[var]
1225 
1226                 orient = layer["orient"] or mark._infer_orient(scales)
1227 
1228                 if stat.group_by_orient:
1229                     grouper = [orient, *grouping_vars]
1230                 else:
1231                     grouper = grouping_vars
1232                 groupby = GroupBy(grouper)
1233                 res = stat(df, groupby, orient, scales)
1234 
1235                 if pair_vars:
1236                     data.frames[coord_vars] = res
1237                 else:
1238                     data.frame = res
1239 
1240     def _get_scale(
1241         self, spec: Plot, var: str, prop: Property, values: Series
1242     ) -> Scale:
1243 
1244         if var in spec._scales:
1245             arg = spec._scales[var]
1246             if arg is None or isinstance(arg, Scale):
1247                 scale = arg
1248             else:
1249                 scale = prop.infer_scale(arg, values)
1250         else:
1251             scale = prop.default_scale(values)
1252 
1253         return scale
1254 
1255     def _get_subplot_data(self, df, var, view, share_state):
1256 
1257         if share_state in [True, "all"]:
1258             # The all-shared case is easiest, every subplot sees all the data
1259             seed_values = df[var]
1260         else:
1261             # Otherwise, we need to setup separate scales for different subplots
1262             if share_state in [False, "none"]:
1263                 # Fully independent axes are also easy: use each subplot's data
1264                 idx = self._get_subplot_index(df, view)
1265             elif share_state in df:
1266                 # Sharing within row/col is more complicated
1267                 use_rows = df[share_state] == view[share_state]
1268                 idx = df.index[use_rows]
1269             else:
1270                 # This configuration doesn't make much sense, but it's fine
1271                 idx = df.index
1272 
1273             seed_values = df.loc[idx, var]
1274 
1275         return seed_values
1276 
1277     def _setup_scales(
1278         self, p: Plot,
1279         common: PlotData,
1280         layers: list[Layer],
1281         variables: list[str] | None = None,
1282     ) -> None:
1283 
1284         if variables is None:
1285             # Add variables that have data but not a scale, which happens
1286             # because this method can be called multiple time, to handle
1287             # variables added during the Stat transform.
1288             variables = []
1289             for layer in layers:
1290                 variables.extend(layer["data"].frame.columns)
1291                 for df in layer["data"].frames.values():
1292                     variables.extend(str(v) for v in df if v not in variables)
1293             variables = [v for v in variables if v not in self._scales]
1294 
1295         for var in variables:
1296 
1297             # Determine whether this is a coordinate variable
1298             # (i.e., x/y, paired x/y, or derivative such as xmax)
1299             m = re.match(r"^(?P<coord>(?P<axis>x|y)\d*).*", var)
1300             if m is None:
1301                 coord = axis = None
1302             else:
1303                 coord = m["coord"]
1304                 axis = m["axis"]
1305 
1306             # Get keys that handle things like x0, xmax, properly where relevant
1307             prop_key = var if axis is None else axis
1308             scale_key = var if coord is None else coord
1309 
1310             if prop_key not in PROPERTIES:
1311                 continue
1312 
1313             # Concatenate layers, using only the relevant coordinate and faceting vars,
1314             # This is unnecessarily wasteful, as layer data will often be redundant.
1315             # But figuring out the minimal amount we need is more complicated.
1316             cols = [var, "col", "row"]
1317             parts = [common.frame.filter(cols)]
1318             for layer in layers:
1319                 parts.append(layer["data"].frame.filter(cols))
1320                 for df in layer["data"].frames.values():
1321                     parts.append(df.filter(cols))
1322             var_df = pd.concat(parts, ignore_index=True)
1323 
1324             prop = PROPERTIES[prop_key]
1325             scale = self._get_scale(p, scale_key, prop, var_df[var])
1326 
1327             if scale_key not in p._variables:
1328                 # TODO this implies that the variable was added by the stat
1329                 # It allows downstream orientation inference to work properly.
1330                 # But it feels rather hacky, so ideally revisit.
1331                 scale._priority = 0  # type: ignore
1332 
1333             if axis is None:
1334                 # We could think about having a broader concept of (un)shared properties
1335                 # In general, not something you want to do (different scales in facets)
1336                 # But could make sense e.g. with paired plots. Build later.
1337                 share_state = None
1338                 subplots = []
1339             else:
1340                 share_state = self._subplots.subplot_spec[f"share{axis}"]
1341                 subplots = [view for view in self._subplots if view[axis] == coord]
1342 
1343             # Shared categorical axes are broken on matplotlib<3.4.0.
1344             # https://github.com/matplotlib/matplotlib/pull/18308
1345             # This only affects us when sharing *paired* axes. This is a novel/niche
1346             # behavior, so we will raise rather than hack together a workaround.
1347             if axis is not None and _version_predates(mpl, "3.4"):
1348                 paired_axis = axis in p._pair_spec.get("structure", {})
1349                 cat_scale = isinstance(scale, Nominal)
1350                 ok_dim = {"x": "col", "y": "row"}[axis]
1351                 shared_axes = share_state not in [False, "none", ok_dim]
1352                 if paired_axis and cat_scale and shared_axes:
1353                     err = "Sharing paired categorical axes requires matplotlib>=3.4.0"
1354                     raise RuntimeError(err)
1355 
1356             if scale is None:
1357                 self._scales[var] = Scale._identity()
1358             else:
1359                 try:
1360                     self._scales[var] = scale._setup(var_df[var], prop)
1361                 except Exception as err:
1362                     raise PlotSpecError._during("Scale setup", var) from err
1363 
1364             if axis is None or (var != coord and coord in p._variables):
1365                 # Everything below here applies only to coordinate variables
1366                 continue
1367 
1368             # Set up an empty series to receive the transformed values.
1369             # We need this to handle piecemeal transforms of categories -> floats.
1370             transformed_data = []
1371             for layer in layers:
1372                 index = layer["data"].frame.index
1373                 empty_series = pd.Series(dtype=float, index=index, name=var)
1374                 transformed_data.append(empty_series)
1375 
1376             for view in subplots:
1377 
1378                 axis_obj = getattr(view["ax"], f"{axis}axis")
1379                 seed_values = self._get_subplot_data(var_df, var, view, share_state)
1380                 view_scale = scale._setup(seed_values, prop, axis=axis_obj)
1381                 set_scale_obj(view["ax"], axis, view_scale._matplotlib_scale)
1382 
1383                 for layer, new_series in zip(layers, transformed_data):
1384                     layer_df = layer["data"].frame
1385                     if var not in layer_df:
1386                         continue
1387 
1388                     idx = self._get_subplot_index(layer_df, view)
1389                     try:
1390                         new_series.loc[idx] = view_scale(layer_df.loc[idx, var])
1391                     except Exception as err:
1392                         spec_error = PlotSpecError._during("Scaling operation", var)
1393                         raise spec_error from err
1394 
1395             # Now the transformed data series are complete, set update the layer data
1396             for layer, new_series in zip(layers, transformed_data):
1397                 layer_df = layer["data"].frame
1398                 if var in layer_df:
1399                     layer_df[var] = new_series
1400 
1401     def _plot_layer(self, p: Plot, layer: Layer) -> None:
1402 
1403         data = layer["data"]
1404         mark = layer["mark"]
1405         move = layer["move"]
1406 
1407         default_grouping_vars = ["col", "row", "group"]  # TODO where best to define?
1408         grouping_properties = [v for v in PROPERTIES if v[0] not in "xy"]
1409 
1410         pair_variables = p._pair_spec.get("structure", {})
1411 
1412         for subplots, df, scales in self._generate_pairings(data, pair_variables):
1413 
1414             orient = layer["orient"] or mark._infer_orient(scales)
1415 
1416             def get_order(var):
1417                 # Ignore order for x/y: they have been scaled to numeric indices,
1418                 # so any original order is no longer valid. Default ordering rules
1419                 # sorted unique numbers will correctly reconstruct intended order
1420                 # TODO This is tricky, make sure we add some tests for this
1421                 if var not in "xy" and var in scales:
1422                     return getattr(scales[var], "order", None)
1423 
1424             if orient in df:
1425                 width = pd.Series(index=df.index, dtype=float)
1426                 for view in subplots:
1427                     view_idx = self._get_subplot_data(
1428                         df, orient, view, p._shares.get(orient)
1429                     ).index
1430                     view_df = df.loc[view_idx]
1431                     if "width" in mark._mappable_props:
1432                         view_width = mark._resolve(view_df, "width", None)
1433                     elif "width" in df:
1434                         view_width = view_df["width"]
1435                     else:
1436                         view_width = 0.8  # TODO what default?
1437                     spacing = scales[orient]._spacing(view_df.loc[view_idx, orient])
1438                     width.loc[view_idx] = view_width * spacing
1439                 df["width"] = width
1440 
1441             if "baseline" in mark._mappable_props:
1442                 # TODO what marks should have this?
1443                 # If we can set baseline with, e.g., Bar(), then the
1444                 # "other" (e.g. y for x oriented bars) parameterization
1445                 # is somewhat ambiguous.
1446                 baseline = mark._resolve(df, "baseline", None)
1447             else:
1448                 # TODO unlike width, we might not want to add baseline to data
1449                 # if the mark doesn't use it. Practically, there is a concern about
1450                 # Mark abstraction like Area / Ribbon
1451                 baseline = 0 if "baseline" not in df else df["baseline"]
1452             df["baseline"] = baseline
1453 
1454             if move is not None:
1455                 moves = move if isinstance(move, list) else [move]
1456                 for move_step in moves:
1457                     move_by = getattr(move_step, "by", None)
1458                     if move_by is None:
1459                         move_by = grouping_properties
1460                     move_groupers = [*move_by, *default_grouping_vars]
1461                     if move_step.group_by_orient:
1462                         move_groupers.insert(0, orient)
1463                     order = {var: get_order(var) for var in move_groupers}
1464                     groupby = GroupBy(order)
1465                     df = move_step(df, groupby, orient, scales)
1466 
1467             df = self._unscale_coords(subplots, df, orient)
1468 
1469             grouping_vars = mark._grouping_props + default_grouping_vars
1470             split_generator = self._setup_split_generator(grouping_vars, df, subplots)
1471 
1472             mark._plot(split_generator, scales, orient)
1473 
1474         # TODO is this the right place for this?
1475         for view in self._subplots:
1476             view["ax"].autoscale_view()
1477 
1478         if layer["legend"]:
1479             self._update_legend_contents(p, mark, data, scales)
1480 
1481     def _unscale_coords(
1482         self, subplots: list[dict], df: DataFrame, orient: str,
1483     ) -> DataFrame:
1484         # TODO do we still have numbers in the variable name at this point?
1485         coord_cols = [c for c in df if re.match(r"^[xy]\D*$", str(c))]
1486         out_df = (
1487             df
1488             .drop(coord_cols, axis=1)
1489             .reindex(df.columns, axis=1)  # So unscaled columns retain their place
1490             .copy(deep=False)
1491         )
1492 
1493         for view in subplots:
1494             view_df = self._filter_subplot_data(df, view)
1495             axes_df = view_df[coord_cols]
1496             for var, values in axes_df.items():
1497 
1498                 axis = getattr(view["ax"], f"{str(var)[0]}axis")
1499                 # TODO see https://github.com/matplotlib/matplotlib/issues/22713
1500                 transform = axis.get_transform().inverted().transform
1501                 inverted = transform(values)
1502                 out_df.loc[values.index, str(var)] = inverted
1503 
1504         return out_df
1505 
1506     def _generate_pairings(
1507         self, data: PlotData, pair_variables: dict,
1508     ) -> Generator[
1509         tuple[list[dict], DataFrame, dict[str, Scale]], None, None
1510     ]:
1511         # TODO retype return with subplot_spec or similar
1512 
1513         iter_axes = itertools.product(*[
1514             pair_variables.get(axis, [axis]) for axis in "xy"
1515         ])
1516 
1517         for x, y in iter_axes:
1518 
1519             subplots = []
1520             for view in self._subplots:
1521                 if (view["x"] == x) and (view["y"] == y):
1522                     subplots.append(view)
1523 
1524             if data.frame.empty and data.frames:
1525                 out_df = data.frames[(x, y)].copy()
1526             elif not pair_variables:
1527                 out_df = data.frame.copy()
1528             else:
1529                 if data.frame.empty and data.frames:
1530                     out_df = data.frames[(x, y)].copy()
1531                 else:
1532                     out_df = data.frame.copy()
1533 
1534             scales = self._scales.copy()
1535             if x in out_df:
1536                 scales["x"] = self._scales[x]
1537             if y in out_df:
1538                 scales["y"] = self._scales[y]
1539 
1540             for axis, var in zip("xy", (x, y)):
1541                 if axis != var:
1542                     out_df = out_df.rename(columns={var: axis})
1543                     cols = [col for col in out_df if re.match(rf"{axis}\d+", str(col))]
1544                     out_df = out_df.drop(cols, axis=1)
1545 
1546             yield subplots, out_df, scales
1547 
1548     def _get_subplot_index(self, df: DataFrame, subplot: dict) -> Index:
1549 
1550         dims = df.columns.intersection(["col", "row"])
1551         if dims.empty:
1552             return df.index
1553 
1554         keep_rows = pd.Series(True, df.index, dtype=bool)
1555         for dim in dims:
1556             keep_rows &= df[dim] == subplot[dim]
1557         return df.index[keep_rows]
1558 
1559     def _filter_subplot_data(self, df: DataFrame, subplot: dict) -> DataFrame:
1560         # TODO note redundancies with preceding function ... needs refactoring
1561         dims = df.columns.intersection(["col", "row"])
1562         if dims.empty:
1563             return df
1564 
1565         keep_rows = pd.Series(True, df.index, dtype=bool)
1566         for dim in dims:
1567             keep_rows &= df[dim] == subplot[dim]
1568         return df[keep_rows]
1569 
1570     def _setup_split_generator(
1571         self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],
1572     ) -> Callable[[], Generator]:
1573 
1574         grouping_keys = []
1575         grouping_vars = [
1576             v for v in grouping_vars if v in df and v not in ["col", "row"]
1577         ]
1578         for var in grouping_vars:
1579             order = getattr(self._scales[var], "order", None)
1580             if order is None:
1581                 order = categorical_order(df[var])
1582             grouping_keys.append(order)
1583 
1584         def split_generator(keep_na=False) -> Generator:
1585 
1586             for view in subplots:
1587 
1588                 axes_df = self._filter_subplot_data(df, view)
1589 
1590                 with pd.option_context("mode.use_inf_as_na", True):
1591                     if keep_na:
1592                         # The simpler thing to do would be x.dropna().reindex(x.index).
1593                         # But that doesn't work with the way that the subset iteration
1594                         # is written below, which assumes data for grouping vars.
1595                         # Matplotlib (usually?) masks nan data, so this should "work".
1596                         # Downstream code can also drop these rows, at some speed cost.
1597                         present = axes_df.notna().all(axis=1)
1598                         nulled = {}
1599                         for axis in "xy":
1600                             if axis in axes_df:
1601                                 nulled[axis] = axes_df[axis].where(present)
1602                         axes_df = axes_df.assign(**nulled)
1603                     else:
1604                         axes_df = axes_df.dropna()
1605 
1606                 subplot_keys = {}
1607                 for dim in ["col", "row"]:
1608                     if view[dim] is not None:
1609                         subplot_keys[dim] = view[dim]
1610 
1611                 if not grouping_vars or not any(grouping_keys):
1612                     if not axes_df.empty:
1613                         yield subplot_keys, axes_df.copy(), view["ax"]
1614                     continue
1615 
1616                 grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)
1617 
1618                 for key in itertools.product(*grouping_keys):
1619 
1620                     # Pandas fails with singleton tuple inputs
1621                     pd_key = key[0] if len(key) == 1 else key
1622 
1623                     try:
1624                         df_subset = grouped_df.get_group(pd_key)
1625                     except KeyError:
1626                         # TODO (from initial work on categorical plots refactor)
1627                         # We are adding this to allow backwards compatability
1628                         # with the empty artists that old categorical plots would
1629                         # add (before 0.12), which we may decide to break, in which
1630                         # case this option could be removed
1631                         df_subset = axes_df.loc[[]]
1632 
1633                     if df_subset.empty:
1634                         continue
1635 
1636                     sub_vars = dict(zip(grouping_vars, key))
1637                     sub_vars.update(subplot_keys)
1638 
1639                     # TODO need copy(deep=...) policy (here, above, anywhere else?)
1640                     yield sub_vars, df_subset.copy(), view["ax"]
1641 
1642         return split_generator
1643 
1644     def _update_legend_contents(
1645         self,
1646         p: Plot,
1647         mark: Mark,
1648         data: PlotData,
1649         scales: dict[str, Scale],
1650     ) -> None:
1651         """Add legend artists / labels for one layer in the plot."""
1652         if data.frame.empty and data.frames:
1653             legend_vars: list[str] = []
1654             for frame in data.frames.values():
1655                 frame_vars = frame.columns.intersection(list(scales))
1656                 legend_vars.extend(v for v in frame_vars if v not in legend_vars)
1657         else:
1658             legend_vars = list(data.frame.columns.intersection(list(scales)))
1659 
1660         # First pass: Identify the values that will be shown for each variable
1661         schema: list[tuple[
1662             tuple[str, str | int], list[str], tuple[list, list[str]]
1663         ]] = []
1664         schema = []
1665         for var in legend_vars:
1666             var_legend = scales[var]._legend
1667             if var_legend is not None:
1668                 values, labels = var_legend
1669                 for (_, part_id), part_vars, _ in schema:
1670                     if data.ids[var] == part_id:
1671                         # Allow multiple plot semantics to represent same data variable
1672                         part_vars.append(var)
1673                         break
1674                 else:
1675                     title = self._resolve_label(p, var, data.names[var])
1676                     entry = (title, data.ids[var]), [var], (values, labels)
1677                     schema.append(entry)
1678 
1679         # Second pass, generate an artist corresponding to each value
1680         contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []
1681         for key, variables, (values, labels) in schema:
1682             artists = []
1683             for val in values:
1684                 artist = mark._legend_artist(variables, val, scales)
1685                 if artist is not None:
1686                     artists.append(artist)
1687             if artists:
1688                 contents.append((key, artists, labels))
1689 
1690         self._legend_contents.extend(contents)
1691 
1692     def _make_legend(self, p: Plot) -> None:
1693         """Create the legend artist(s) and add onto the figure."""
1694         # Combine artists representing same information across layers
1695         # Input list has an entry for each distinct variable in each layer
1696         # Output dict has an entry for each distinct variable
1697         merged_contents: dict[
1698             tuple[str, str | int], tuple[list[Artist], list[str]],
1699         ] = {}
1700         for key, new_artists, labels in self._legend_contents:
1701             # Key is (name, id); we need the id to resolve variable uniqueness,
1702             # but will need the name in the next step to title the legend
1703             if key in merged_contents:
1704                 # Copy so inplace updates don't propagate back to legend_contents
1705                 existing_artists = merged_contents[key][0]
1706                 for i, artist in enumerate(existing_artists):
1707                     # Matplotlib accepts a tuple of artists and will overlay them
1708                     if isinstance(artist, tuple):
1709                         artist += new_artists[i],
1710                     else:
1711                         existing_artists[i] = artist, new_artists[i]
1712             else:
1713                 merged_contents[key] = new_artists.copy(), labels
1714 
1715         # TODO explain
1716         loc = "center right" if self._pyplot else "center left"
1717 
1718         base_legend = None
1719         for (name, _), (handles, labels) in merged_contents.items():
1720 
1721             legend = mpl.legend.Legend(
1722                 self._figure,
1723                 handles,
1724                 labels,
1725                 title=name,
1726                 loc=loc,
1727                 bbox_to_anchor=(.98, .55),
1728             )
1729 
1730             if base_legend:
1731                 # Matplotlib has no public API for this so it is a bit of a hack.
1732                 # Ideally we'd define our own legend class with more flexibility,
1733                 # but that is a lot of work!
1734                 base_legend_box = base_legend.get_children()[0]
1735                 this_legend_box = legend.get_children()[0]
1736                 base_legend_box.get_children().extend(this_legend_box.get_children())
1737             else:
1738                 base_legend = legend
1739                 self._figure.legends.append(legend)
1740 
1741     def _finalize_figure(self, p: Plot) -> None:
1742 
1743         for sub in self._subplots:
1744             ax = sub["ax"]
1745             for axis in "xy":
1746                 axis_key = sub[axis]
1747                 axis_obj = getattr(ax, f"{axis}axis")
1748 
1749                 # Axis limits
1750                 if axis_key in p._limits:
1751                     convert_units = getattr(ax, f"{axis}axis").convert_units
1752                     a, b = p._limits[axis_key]
1753                     lo = a if a is None else convert_units(a)
1754                     hi = b if b is None else convert_units(b)
1755                     if isinstance(a, str):
1756                         lo = cast(float, lo) - 0.5
1757                     if isinstance(b, str):
1758                         hi = cast(float, hi) + 0.5
1759                     ax.set(**{f"{axis}lim": (lo, hi)})
1760 
1761                 if axis_key in self._scales:  # TODO when would it not be?
1762                     self._scales[axis_key]._finalize(p, axis_obj)
1763 
1764         if (engine := p._layout_spec.get("engine", default)) is not default:
1765             # None is a valid arg for Figure.set_layout_engine, hence `default`
1766             set_layout_engine(self._figure, engine)
1767         elif p._target is None:
1768             # Don't modify the layout engine if the user supplied their own
1769             # matplotlib figure and didn't specify an engine through Plot
1770             # TODO switch default to "constrained"?
1771             # TODO either way, make configurable
1772             set_layout_engine(self._figure, "tight")

</code><intended_behavior>This file likely contains functions or methods that prepare data for plotting, including handling of missing values. The code should ensure that missing values (`pd.NA` or `np.nan`) do not influence the sorting or ordering of axes in plots. A specific method within this could potentially be handling data frames before they are plotted, which would need to be adjusted to uniformly treat `pd.NA` and `np.nan` to maintain axis ordering.</intended_behavior>, <file>seaborn/_core/data.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Components for parsing variable assignments and internally representing plot data.
3 """
4 from __future__ import annotations
5 
6 from collections.abc import Mapping, Sized
7 from typing import cast
8 
9 import pandas as pd
10 from pandas import DataFrame
11 
12 from seaborn._core.typing import DataSource, VariableSpec, ColumnName
13 
14 
15 class PlotData:
16     """
17     Data table with plot variable schema and mapping to original names.
18 
19     Contains logic for parsing variable specification arguments and updating
20     the table with layer-specific data and/or mappings.
21 
22     Parameters
23     ----------
24     data
25         Input data where variable names map to vector values.
26     variables
27         Keys are names of plot variables (x, y, ...) each value is one of:
28 
29         - name of a column (or index level, or dictionary entry) in `data`
30         - vector in any format that can construct a :class:`pandas.DataFrame`
31 
32     Attributes
33     ----------
34     frame
35         Data table with column names having defined plot variables.
36     names
37         Dictionary mapping plot variable names to names in source data structure(s).
38     ids
39         Dictionary mapping plot variable names to unique data source identifiers.
40 
41     """
42     frame: DataFrame
43     frames: dict[tuple, DataFrame]
44     names: dict[str, str | None]
45     ids: dict[str, str | int]
46     source_data: DataSource
47     source_vars: dict[str, VariableSpec]
48 
49     def __init__(
50         self,
51         data: DataSource,
52         variables: dict[str, VariableSpec],
53     ):
54 
55         frame, names, ids = self._assign_variables(data, variables)
56 
57         self.frame = frame
58         self.names = names
59         self.ids = ids
60 
61         self.frames = {}  # TODO this is a hack, remove
62 
63         self.source_data = data
64         self.source_vars = variables
65 
66     def __contains__(self, key: str) -> bool:
67         """Boolean check on whether a variable is defined in this dataset."""
68         if self.frame is None:
69             return any(key in df for df in self.frames.values())
70         return key in self.frame
71 
72     def join(
73         self,
74         data: DataSource,
75         variables: dict[str, VariableSpec] | None,
76     ) -> PlotData:
77         """Add, replace, or drop variables and return as a new dataset."""
78         # Inherit the original source of the upsteam data by default
79         if data is None:
80             data = self.source_data
81 
82         # TODO allow `data` to be a function (that is called on the source data?)
83 
84         if not variables:
85             variables = self.source_vars
86 
87         # Passing var=None implies that we do not want that variable in this layer
88         disinherit = [k for k, v in variables.items() if v is None]
89 
90         # Create a new dataset with just the info passed here
91         new = PlotData(data, variables)
92 
93         # -- Update the inherited DataSource with this new information
94 
95         drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]
96         parts = [self.frame.drop(columns=drop_cols), new.frame]
97 
98         # Because we are combining distinct columns, this is perhaps more
99         # naturally thought of as a "merge"/"join". But using concat because
100         # some simple testing suggests that it is marginally faster.
101         frame = pd.concat(parts, axis=1, sort=False, copy=False)
102 
103         names = {k: v for k, v in self.names.items() if k not in disinherit}
104         names.update(new.names)
105 
106         ids = {k: v for k, v in self.ids.items() if k not in disinherit}
107         ids.update(new.ids)
108 
109         new.frame = frame
110         new.names = names
111         new.ids = ids
112 
113         # Multiple chained operations should always inherit from the original object
114         new.source_data = self.source_data
115         new.source_vars = self.source_vars
116 
117         return new
118 
119     def _assign_variables(
120         self,
121         data: DataSource,
122         variables: dict[str, VariableSpec],
123     ) -> tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:
124         """
125         Assign values for plot variables given long-form data and/or vector inputs.
126 
127         Parameters
128         ----------
129         data
130             Input data where variable names map to vector values.
131         variables
132             Keys are names of plot variables (x, y, ...) each value is one of:
133 
134             - name of a column (or index level, or dictionary entry) in `data`
135             - vector in any format that can construct a :class:`pandas.DataFrame`
136 
137         Returns
138         -------
139         frame
140             Table mapping seaborn variables (x, y, color, ...) to data vectors.
141         names
142             Keys are defined seaborn variables; values are names inferred from
143             the inputs (or None when no name can be determined).
144         ids
145             Like the `names` dict, but `None` values are replaced by the `id()`
146             of the data object that defined the variable.
147 
148         Raises
149         ------
150         ValueError
151             When variables are strings that don't appear in `data`, or when they are
152             non-indexed vector datatypes that have a different length from `data`.
153 
154         """
155         source_data: Mapping | DataFrame
156         frame: DataFrame
157         names: dict[str, str | None]
158         ids: dict[str, str | int]
159 
160         plot_data = {}
161         names = {}
162         ids = {}
163 
164         given_data = data is not None
165         if data is not None:
166             source_data = data
167         else:
168             # Data is optional; all variables can be defined as vectors
169             # But simplify downstream code by always having a usable source data object
170             source_data = {}
171 
172         # TODO Generally interested in accepting a generic DataFrame interface
173         # Track https://data-apis.org/ for development
174 
175         # Variables can also be extracted from the index of a DataFrame
176         if isinstance(source_data, pd.DataFrame):
177             index = source_data.index.to_frame().to_dict("series")
178         else:
179             index = {}
180 
181         for key, val in variables.items():
182 
183             # Simply ignore variables with no specification
184             if val is None:
185                 continue
186 
187             # Try to treat the argument as a key for the data collection.
188             # But be flexible about what can be used as a key.
189             # Usually it will be a string, but allow other hashables when
190             # taking from the main data object. Allow only strings to reference
191             # fields in the index, because otherwise there is too much ambiguity.
192 
193             # TODO this will be rendered unnecessary by the following pandas fix:
194             # https://github.com/pandas-dev/pandas/pull/41283
195             try:
196                 hash(val)
197                 val_is_hashable = True
198             except TypeError:
199                 val_is_hashable = False
200 
201             val_as_data_key = (
202                 # See https://github.com/pandas-dev/pandas/pull/41283
203                 # (isinstance(val, abc.Hashable) and val in source_data)
204                 (val_is_hashable and val in source_data)
205                 or (isinstance(val, str) and val in index)
206             )
207 
208             if val_as_data_key:
209                 val = cast(ColumnName, val)
210                 if val in source_data:
211                     plot_data[key] = source_data[val]
212                 elif val in index:
213                     plot_data[key] = index[val]
214                 names[key] = ids[key] = str(val)
215 
216             elif isinstance(val, str):
217 
218                 # This looks like a column name but, lookup failed.
219 
220                 err = f"Could not interpret value `{val}` for `{key}`. "
221                 if not given_data:
222                     err += "Value is a string, but `data` was not passed."
223                 else:
224                     err += "An entry with this name does not appear in `data`."
225                 raise ValueError(err)
226 
227             else:
228 
229                 # Otherwise, assume the value somehow represents data
230 
231                 # Ignore empty data structures
232                 if isinstance(val, Sized) and len(val) == 0:
233                     continue
234 
235                 # If vector has no index, it must match length of data table
236                 if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):
237                     if isinstance(val, Sized) and len(data) != len(val):
238                         val_cls = val.__class__.__name__
239                         err = (
240                             f"Length of {val_cls} vectors must match length of `data`"
241                             f" when both are used, but `data` has length {len(data)}"
242                             f" and the vector passed to `{key}` has length {len(val)}."
243                         )
244                         raise ValueError(err)
245 
246                 plot_data[key] = val
247 
248                 # Try to infer the original name using pandas-like metadata
249                 if hasattr(val, "name"):
250                     names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424
251                 else:
252                     names[key] = None
253                     ids[key] = id(val)
254 
255         # Construct a tidy plot DataFrame. This will convert a number of
256         # types automatically, aligning on index in case of pandas objects
257         # TODO Note: this fails when variable specs *only* have scalars!
258         frame = pd.DataFrame(plot_data)
259 
260         return frame, names, ids

</code><intended_behavior>As this file likely involves data manipulation and preparation for plotting, it should properly manage datasets with missing values, ensuring that insertion of `pd.NA` does not lead to reversed axes. Updating or refining the method to handle `pd.NA` equivalently to `np.nan`, especially in regards to data sorting and ordering for plotting, could resolve the issue.</intended_behavior>]
2025-10-18 14:47:16.213 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 14:47:16.213 | INFO     | Search-only: skipping patch selection
2025-10-18 14:47:16.288 | INFO     | Task mwaskom__seaborn-3394 completed successfully.
2025-10-18 14:47:16.289 | INFO     | No patch generated. You can try running ACR again.
