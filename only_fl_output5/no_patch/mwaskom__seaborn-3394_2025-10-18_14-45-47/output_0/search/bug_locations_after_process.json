[
    {
        "rel_file_path": "seaborn/_core/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/_core/plot.py",
        "start": 1,
        "end": 1772,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"The classes for specifying and compiling a declarative visualization.\"\"\"\n2 from __future__ import annotations\n3 \n4 import io\n5 import os\n6 import re\n7 import inspect\n8 import itertools\n9 import textwrap\n10 from contextlib import contextmanager\n11 from collections import abc\n12 from collections.abc import Callable, Generator\n13 from typing import Any, List, Literal, Optional, cast\n14 from xml.etree import ElementTree\n15 \n16 from cycler import cycler\n17 import pandas as pd\n18 from pandas import DataFrame, Series, Index\n19 import matplotlib as mpl\n20 from matplotlib.axes import Axes\n21 from matplotlib.artist import Artist\n22 from matplotlib.figure import Figure\n23 from PIL import Image\n24 \n25 from seaborn._marks.base import Mark\n26 from seaborn._stats.base import Stat\n27 from seaborn._core.data import PlotData\n28 from seaborn._core.moves import Move\n29 from seaborn._core.scales import Scale, Nominal\n30 from seaborn._core.subplots import Subplots\n31 from seaborn._core.groupby import GroupBy\n32 from seaborn._core.properties import PROPERTIES, Property\n33 from seaborn._core.typing import (\n34     DataSource,\n35     VariableSpec,\n36     VariableSpecList,\n37     OrderSpec,\n38     Default,\n39 )\n40 from seaborn._core.exceptions import PlotSpecError\n41 from seaborn._core.rules import categorical_order\n42 from seaborn._compat import set_scale_obj, set_layout_engine\n43 from seaborn.rcmod import axes_style, plotting_context\n44 from seaborn.palettes import color_palette\n45 from seaborn.utils import _version_predates\n46 \n47 from typing import TYPE_CHECKING, TypedDict\n48 if TYPE_CHECKING:\n49     from matplotlib.figure import SubFigure\n50 \n51 \n52 default = Default()\n53 \n54 \n55 # ---- Definitions for internal specs ---------------------------------------------- #\n56 \n57 \n58 class Layer(TypedDict, total=False):\n59 \n60     mark: Mark  # TODO allow list?\n61     stat: Stat | None  # TODO allow list?\n62     move: Move | list[Move] | None\n63     data: PlotData\n64     source: DataSource\n65     vars: dict[str, VariableSpec]\n66     orient: str\n67     legend: bool\n68 \n69 \n70 class FacetSpec(TypedDict, total=False):\n71 \n72     variables: dict[str, VariableSpec]\n73     structure: dict[str, list[str]]\n74     wrap: int | None\n75 \n76 \n77 class PairSpec(TypedDict, total=False):\n78 \n79     variables: dict[str, VariableSpec]\n80     structure: dict[str, list[str]]\n81     cross: bool\n82     wrap: int | None\n83 \n84 \n85 # --- Local helpers ---------------------------------------------------------------- #\n86 \n87 \n88 @contextmanager\n89 def theme_context(params: dict[str, Any]) -> Generator:\n90     \"\"\"Temporarily modify specifc matplotlib rcParams.\"\"\"\n91     orig_params = {k: mpl.rcParams[k] for k in params}\n92     color_codes = \"bgrmyck\"\n93     nice_colors = [*color_palette(\"deep6\"), (.15, .15, .15)]\n94     orig_colors = [mpl.colors.colorConverter.colors[x] for x in color_codes]\n95     # TODO how to allow this to reflect the color cycle when relevant?\n96     try:\n97         mpl.rcParams.update(params)\n98         for (code, color) in zip(color_codes, nice_colors):\n99             mpl.colors.colorConverter.colors[code] = color\n100         yield\n101     finally:\n102         mpl.rcParams.update(orig_params)\n103         for (code, color) in zip(color_codes, orig_colors):\n104             mpl.colors.colorConverter.colors[code] = color\n105 \n106 \n107 def build_plot_signature(cls):\n108     \"\"\"\n109     Decorator function for giving Plot a useful signature.\n110 \n111     Currently this mostly saves us some duplicated typing, but we would\n112     like eventually to have a way of registering new semantic properties,\n113     at which point dynamic signature generation would become more important.\n114 \n115     \"\"\"\n116     sig = inspect.signature(cls)\n117     params = [\n118         inspect.Parameter(\"args\", inspect.Parameter.VAR_POSITIONAL),\n119         inspect.Parameter(\"data\", inspect.Parameter.KEYWORD_ONLY, default=None)\n120     ]\n121     params.extend([\n122         inspect.Parameter(name, inspect.Parameter.KEYWORD_ONLY, default=None)\n123         for name in PROPERTIES\n124     ])\n125     new_sig = sig.replace(parameters=params)\n126     cls.__signature__ = new_sig\n127 \n128     known_properties = textwrap.fill(\n129         \", \".join([f\"|{p}|\" for p in PROPERTIES]),\n130         width=78, subsequent_indent=\" \" * 8,\n131     )\n132 \n133     if cls.__doc__ is not None:  # support python -OO mode\n134         cls.__doc__ = cls.__doc__.format(known_properties=known_properties)\n135 \n136     return cls\n137 \n138 \n139 # ---- Plot configuration ---------------------------------------------------------- #\n140 \n141 \n142 class ThemeConfig(mpl.RcParams):\n143     \"\"\"\n144     Configuration object for the Plot.theme, using matplotlib rc parameters.\n145     \"\"\"\n146     THEME_GROUPS = [\n147         \"axes\", \"figure\", \"font\", \"grid\", \"hatch\", \"legend\", \"lines\",\n148         \"mathtext\", \"markers\", \"patch\", \"savefig\", \"scatter\",\n149         \"xaxis\", \"xtick\", \"yaxis\", \"ytick\",\n150     ]\n151 \n152     def __init__(self):\n153         super().__init__()\n154         self.reset()\n155 \n156     @property\n157     def _default(self) -> dict[str, Any]:\n158 \n159         return {\n160             **self._filter_params(mpl.rcParamsDefault),\n161             **axes_style(\"darkgrid\"),\n162             **plotting_context(\"notebook\"),\n163             \"axes.prop_cycle\": cycler(\"color\", color_palette(\"deep\")),\n164         }\n165 \n166     def reset(self) -> None:\n167         \"\"\"Update the theme dictionary with seaborn's default values.\"\"\"\n168         self.update(self._default)\n169 \n170     def update(self, other: dict[str, Any] | None = None, /, **kwds):\n171         \"\"\"Update the theme with a dictionary or keyword arguments of rc parameters.\"\"\"\n172         if other is not None:\n173             theme = self._filter_params(other)\n174         else:\n175             theme = {}\n176         theme.update(kwds)\n177         super().update(theme)\n178 \n179     def _filter_params(self, params: dict[str, Any]) -> dict[str, Any]:\n180         \"\"\"Restruct to thematic rc params.\"\"\"\n181         return {\n182             k: v for k, v in params.items()\n183             if any(k.startswith(p) for p in self.THEME_GROUPS)\n184         }\n185 \n186     def _html_table(self, params: dict[str, Any]) -> list[str]:\n187 \n188         lines = [\"<table>\"]\n189         for k, v in params.items():\n190             row = f\"<tr><td>{k}:</td><td style='text-align:left'>{v!r}</td></tr>\"\n191             lines.append(row)\n192         lines.append(\"</table>\")\n193         return lines\n194 \n195     def _repr_html_(self) -> str:\n196 \n197         repr = [\n198             \"<div style='height: 300px'>\",\n199             \"<div style='border-style: inset; border-width: 2px'>\",\n200             *self._html_table(self),\n201             \"</div>\",\n202             \"</div>\",\n203         ]\n204         return \"\\n\".join(repr)\n205 \n206 \n207 class DisplayConfig(TypedDict):\n208     \"\"\"Configuration for IPython's rich display hooks.\"\"\"\n209     format: Literal[\"png\", \"svg\"]\n210     scaling: float\n211     hidpi: bool\n212 \n213 \n214 class PlotConfig:\n215     \"\"\"Configuration for default behavior / appearance of class:`Plot` instances.\"\"\"\n216     def __init__(self):\n217 \n218         self._theme = ThemeConfig()\n219         self._display = {\"format\": \"png\", \"scaling\": .85, \"hidpi\": True}\n220 \n221     @property\n222     def theme(self) -> dict[str, Any]:\n223         \"\"\"\n224         Dictionary of base theme parameters for :class:`Plot`.\n225 \n226         Keys and values correspond to matplotlib rc params, as documented here:\n227         https://matplotlib.org/stable/tutorials/introductory/customizing.html\n228 \n229         \"\"\"\n230         return self._theme\n231 \n232     @property\n233     def display(self) -> DisplayConfig:\n234         \"\"\"\n235         Dictionary of parameters for rich display in Jupyter notebook.\n236 \n237         Valid parameters:\n238 \n239         - format (\"png\" or \"svg\"): Image format to produce\n240         - scaling (float): Relative scaling of embedded image\n241         - hidpi (bool): When True, double the DPI while preserving the size\n242 \n243         \"\"\"\n244         return self._display\n245 \n246 \n247 # ---- The main interface for declarative plotting --------------------------------- #\n248 \n249 \n250 @build_plot_signature\n251 class Plot:\n252     \"\"\"\n253     An interface for declaratively specifying statistical graphics.\n254 \n255     Plots are constructed by initializing this class and adding one or more\n256     layers, comprising a `Mark` and optional `Stat` or `Move`.  Additionally,\n257     faceting variables or variable pairings may be defined to divide the space\n258     into multiple subplots. The mappings from data values to visual properties\n259     can be parametrized using scales, although the plot will try to infer good\n260     defaults when scales are not explicitly defined.\n261 \n262     The constructor accepts a data source (a :class:`pandas.DataFrame` or\n263     dictionary with columnar values) and variable assignments. Variables can be\n264     passed as keys to the data source or directly as data vectors.  If multiple\n265     data-containing objects are provided, they will be index-aligned.\n266 \n267     The data source and variables defined in the constructor will be used for\n268     all layers in the plot, unless overridden or disabled when adding a layer.\n269 \n270     The following variables can be defined in the constructor:\n271         {known_properties}\n272 \n273     The `data`, `x`, and `y` variables can be passed as positional arguments or\n274     using keywords. Whether the first positional argument is interpreted as a\n275     data source or `x` variable depends on its type.\n276 \n277     The methods of this class return a copy of the instance; use chaining to\n278     build up a plot through multiple calls. Methods can be called in any order.\n279 \n280     Most methods only add information to the plot spec; no actual processing\n281     happens until the plot is shown or saved. It is also possible to compile\n282     the plot without rendering it to access the lower-level representation.\n283 \n284     \"\"\"\n285     config = PlotConfig()\n286 \n287     _data: PlotData\n288     _layers: list[Layer]\n289 \n290     _scales: dict[str, Scale]\n291     _shares: dict[str, bool | str]\n292     _limits: dict[str, tuple[Any, Any]]\n293     _labels: dict[str, str | Callable[[str], str]]\n294     _theme: dict[str, Any]\n295 \n296     _facet_spec: FacetSpec\n297     _pair_spec: PairSpec\n298 \n299     _figure_spec: dict[str, Any]\n300     _subplot_spec: dict[str, Any]\n301     _layout_spec: dict[str, Any]\n302 \n303     def __init__(\n304         self,\n305         *args: DataSource | VariableSpec,\n306         data: DataSource = None,\n307         **variables: VariableSpec,\n308     ):\n309 \n310         if args:\n311             data, variables = self._resolve_positionals(args, data, variables)\n312 \n313         unknown = [x for x in variables if x not in PROPERTIES]\n314         if unknown:\n315             err = f\"Plot() got unexpected keyword argument(s): {', '.join(unknown)}\"\n316             raise TypeError(err)\n317 \n318         self._data = PlotData(data, variables)\n319 \n320         self._layers = []\n321 \n322         self._scales = {}\n323         self._shares = {}\n324         self._limits = {}\n325         self._labels = {}\n326         self._theme = {}\n327 \n328         self._facet_spec = {}\n329         self._pair_spec = {}\n330 \n331         self._figure_spec = {}\n332         self._subplot_spec = {}\n333         self._layout_spec = {}\n334 \n335         self._target = None\n336 \n337     def _resolve_positionals(\n338         self,\n339         args: tuple[DataSource | VariableSpec, ...],\n340         data: DataSource,\n341         variables: dict[str, VariableSpec],\n342     ) -> tuple[DataSource, dict[str, VariableSpec]]:\n343         \"\"\"Handle positional arguments, which may contain data / x / y.\"\"\"\n344         if len(args) > 3:\n345             err = \"Plot() accepts no more than 3 positional arguments (data, x, y).\"\n346             raise TypeError(err)\n347 \n348         # TODO need some clearer way to differentiate data / vector here\n349         # (There might be an abstract DataFrame class to use here?)\n350         if isinstance(args[0], (abc.Mapping, pd.DataFrame)):\n351             if data is not None:\n352                 raise TypeError(\"`data` given by both name and position.\")\n353             data, args = args[0], args[1:]\n354 \n355         if len(args) == 2:\n356             x, y = args\n357         elif len(args) == 1:\n358             x, y = *args, None\n359         else:\n360             x = y = None\n361 \n362         for name, var in zip(\"yx\", (y, x)):\n363             if var is not None:\n364                 if name in variables:\n365                     raise TypeError(f\"`{name}` given by both name and position.\")\n366                 # Keep coordinates at the front of the variables dict\n367                 # Cast type because we know this isn't a DataSource at this point\n368                 variables = {name: cast(VariableSpec, var), **variables}\n369 \n370         return data, variables\n371 \n372     def __add__(self, other):\n373 \n374         if isinstance(other, Mark) or isinstance(other, Stat):\n375             raise TypeError(\"Sorry, this isn't ggplot! Perhaps try Plot.add?\")\n376 \n377         other_type = other.__class__.__name__\n378         raise TypeError(f\"Unsupported operand type(s) for +: 'Plot' and '{other_type}\")\n379 \n380     def _repr_png_(self) -> tuple[bytes, dict[str, float]] | None:\n381 \n382         if Plot.config.display[\"format\"] != \"png\":\n383             return None\n384         return self.plot()._repr_png_()\n385 \n386     def _repr_svg_(self) -> str | None:\n387 \n388         if Plot.config.display[\"format\"] != \"svg\":\n389             return None\n390         return self.plot()._repr_svg_()\n391 \n392     def _clone(self) -> Plot:\n393         \"\"\"Generate a new object with the same information as the current spec.\"\"\"\n394         new = Plot()\n395 \n396         # TODO any way to enforce that data does not get mutated?\n397         new._data = self._data\n398 \n399         new._layers.extend(self._layers)\n400 \n401         new._scales.update(self._scales)\n402         new._shares.update(self._shares)\n403         new._limits.update(self._limits)\n404         new._labels.update(self._labels)\n405         new._theme.update(self._theme)\n406 \n407         new._facet_spec.update(self._facet_spec)\n408         new._pair_spec.update(self._pair_spec)\n409 \n410         new._figure_spec.update(self._figure_spec)\n411         new._subplot_spec.update(self._subplot_spec)\n412         new._layout_spec.update(self._layout_spec)\n413 \n414         new._target = self._target\n415 \n416         return new\n417 \n418     def _theme_with_defaults(self) -> dict[str, Any]:\n419 \n420         theme = self.config.theme.copy()\n421         theme.update(self._theme)\n422         return theme\n423 \n424     @property\n425     def _variables(self) -> list[str]:\n426 \n427         variables = (\n428             list(self._data.frame)\n429             + list(self._pair_spec.get(\"variables\", []))\n430             + list(self._facet_spec.get(\"variables\", []))\n431         )\n432         for layer in self._layers:\n433             variables.extend(v for v in layer[\"vars\"] if v not in variables)\n434 \n435         # Coerce to str in return to appease mypy; we know these will only\n436         # ever be strings but I don't think we can type a DataFrame that way yet\n437         return [str(v) for v in variables]\n438 \n439     def on(self, target: Axes | SubFigure | Figure) -> Plot:\n440         \"\"\"\n441         Provide existing Matplotlib figure or axes for drawing the plot.\n442 \n443         When using this method, you will also need to explicitly call a method that\n444         triggers compilation, such as :meth:`Plot.show` or :meth:`Plot.save`. If you\n445         want to postprocess using matplotlib, you'd need to call :meth:`Plot.plot`\n446         first to compile the plot without rendering it.\n447 \n448         Parameters\n449         ----------\n450         target : Axes, SubFigure, or Figure\n451             Matplotlib object to use. Passing :class:`matplotlib.axes.Axes` will add\n452             artists without otherwise modifying the figure. Otherwise, subplots will be\n453             created within the space of the given :class:`matplotlib.figure.Figure` or\n454             :class:`matplotlib.figure.SubFigure`.\n455 \n456         Examples\n457         --------\n458         .. include:: ../docstrings/objects.Plot.on.rst\n459 \n460         \"\"\"\n461         accepted_types: tuple  # Allow tuple of various length\n462         if hasattr(mpl.figure, \"SubFigure\"):  # Added in mpl 3.4\n463             accepted_types = (\n464                 mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure\n465             )\n466             accepted_types_str = (\n467                 f\"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}\"\n468             )\n469         else:\n470             accepted_types = mpl.axes.Axes, mpl.figure.Figure\n471             accepted_types_str = f\"{mpl.axes.Axes} or {mpl.figure.Figure}\"\n472 \n473         if not isinstance(target, accepted_types):\n474             err = (\n475                 f\"The `Plot.on` target must be an instance of {accepted_types_str}. \"\n476                 f\"You passed an instance of {target.__class__} instead.\"\n477             )\n478             raise TypeError(err)\n479 \n480         new = self._clone()\n481         new._target = target\n482 \n483         return new\n484 \n485     def add(\n486         self,\n487         mark: Mark,\n488         *transforms: Stat | Mark,\n489         orient: str | None = None,\n490         legend: bool = True,\n491         data: DataSource = None,\n492         **variables: VariableSpec,\n493     ) -> Plot:\n494         \"\"\"\n495         Specify a layer of the visualization in terms of mark and data transform(s).\n496 \n497         This is the main method for specifying how the data should be visualized.\n498         It can be called multiple times with different arguments to define\n499         a plot with multiple layers.\n500 \n501         Parameters\n502         ----------\n503         mark : :class:`Mark`\n504             The visual representation of the data to use in this layer.\n505         transforms : :class:`Stat` or :class:`Move`\n506             Objects representing transforms to be applied before plotting the data.\n507             Currently, at most one :class:`Stat` can be used, and it\n508             must be passed first. This constraint will be relaxed in the future.\n509         orient : \"x\", \"y\", \"v\", or \"h\"\n510             The orientation of the mark, which also affects how transforms are computed.\n511             Typically corresponds to the axis that defines groups for aggregation.\n512             The \"v\" (vertical) and \"h\" (horizontal) options are synonyms for \"x\" / \"y\",\n513             but may be more intuitive with some marks. When not provided, an\n514             orientation will be inferred from characteristics of the data and scales.\n515         legend : bool\n516             Option to suppress the mark/mappings for this layer from the legend.\n517         data : DataFrame or dict\n518             Data source to override the global source provided in the constructor.\n519         variables : data vectors or identifiers\n520             Additional layer-specific variables, including variables that will be\n521             passed directly to the transforms without scaling.\n522 \n523         Examples\n524         --------\n525         .. include:: ../docstrings/objects.Plot.add.rst\n526 \n527         \"\"\"\n528         if not isinstance(mark, Mark):\n529             msg = f\"mark must be a Mark instance, not {type(mark)!r}.\"\n530             raise TypeError(msg)\n531 \n532         # TODO This API for transforms was a late decision, and previously Plot.add\n533         # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.\n534         # It will take some work to refactor the internals so that Stat and Move are\n535         # treated identically, and until then well need to \"unpack\" the transforms\n536         # here and enforce limitations on the order / types.\n537 \n538         stat: Optional[Stat]\n539         move: Optional[List[Move]]\n540         error = False\n541         if not transforms:\n542             stat, move = None, None\n543         elif isinstance(transforms[0], Stat):\n544             stat = transforms[0]\n545             move = [m for m in transforms[1:] if isinstance(m, Move)]\n546             error = len(move) != len(transforms) - 1\n547         else:\n548             stat = None\n549             move = [m for m in transforms if isinstance(m, Move)]\n550             error = len(move) != len(transforms)\n551 \n552         if error:\n553             msg = \" \".join([\n554                 \"Transforms must have at most one Stat type (in the first position),\",\n555                 \"and all others must be a Move type. Given transform type(s):\",\n556                 \", \".join(str(type(t).__name__) for t in transforms) + \".\"\n557             ])\n558             raise TypeError(msg)\n559 \n560         new = self._clone()\n561         new._layers.append({\n562             \"mark\": mark,\n563             \"stat\": stat,\n564             \"move\": move,\n565             # TODO it doesn't work to supply scalars to variables, but it should\n566             \"vars\": variables,\n567             \"source\": data,\n568             \"legend\": legend,\n569             \"orient\": {\"v\": \"x\", \"h\": \"y\"}.get(orient, orient),  # type: ignore\n570         })\n571 \n572         return new\n573 \n574     def pair(\n575         self,\n576         x: VariableSpecList = None,\n577         y: VariableSpecList = None,\n578         wrap: int | None = None,\n579         cross: bool = True,\n580     ) -> Plot:\n581         \"\"\"\n582         Produce subplots by pairing multiple `x` and/or `y` variables.\n583 \n584         Parameters\n585         ----------\n586         x, y : sequence(s) of data vectors or identifiers\n587             Variables that will define the grid of subplots.\n588         wrap : int\n589             When using only `x` or `y`, \"wrap\" subplots across a two-dimensional grid\n590             with this many columns (when using `x`) or rows (when using `y`).\n591         cross : bool\n592             When False, zip the `x` and `y` lists such that the first subplot gets the\n593             first pair, the second gets the second pair, etc. Otherwise, create a\n594             two-dimensional grid from the cartesian product of the lists.\n595 \n596         Examples\n597         --------\n598         .. include:: ../docstrings/objects.Plot.pair.rst\n599 \n600         \"\"\"\n601         # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows\n602         # This may also be possible by setting `wrap=1`, but is that too unobvious?\n603         # TODO PairGrid features not currently implemented: diagonals, corner\n604 \n605         pair_spec: PairSpec = {}\n606 \n607         axes = {\"x\": [] if x is None else x, \"y\": [] if y is None else y}\n608         for axis, arg in axes.items():\n609             if isinstance(arg, (str, int)):\n610                 err = f\"You must pass a sequence of variable keys to `{axis}`\"\n611                 raise TypeError(err)\n612 \n613         pair_spec[\"variables\"] = {}\n614         pair_spec[\"structure\"] = {}\n615 \n616         for axis in \"xy\":\n617             keys = []\n618             for i, col in enumerate(axes[axis]):\n619                 key = f\"{axis}{i}\"\n620                 keys.append(key)\n621                 pair_spec[\"variables\"][key] = col\n622 \n623             if keys:\n624                 pair_spec[\"structure\"][axis] = keys\n625 \n626         if not cross and len(axes[\"x\"]) != len(axes[\"y\"]):\n627             err = \"Lengths of the `x` and `y` lists must match with cross=False\"\n628             raise ValueError(err)\n629 \n630         pair_spec[\"cross\"] = cross\n631         pair_spec[\"wrap\"] = wrap\n632 \n633         new = self._clone()\n634         new._pair_spec.update(pair_spec)\n635         return new\n636 \n637     def facet(\n638         self,\n639         col: VariableSpec = None,\n640         row: VariableSpec = None,\n641         order: OrderSpec | dict[str, OrderSpec] = None,\n642         wrap: int | None = None,\n643     ) -> Plot:\n644         \"\"\"\n645         Produce subplots with conditional subsets of the data.\n646 \n647         Parameters\n648         ----------\n649         col, row : data vectors or identifiers\n650             Variables used to define subsets along the columns and/or rows of the grid.\n651             Can be references to the global data source passed in the constructor.\n652         order : list of strings, or dict with dimensional keys\n653             Define the order of the faceting variables.\n654         wrap : int\n655             When using only `col` or `row`, wrap subplots across a two-dimensional\n656             grid with this many subplots on the faceting dimension.\n657 \n658         Examples\n659         --------\n660         .. include:: ../docstrings/objects.Plot.facet.rst\n661 \n662         \"\"\"\n663         variables: dict[str, VariableSpec] = {}\n664         if col is not None:\n665             variables[\"col\"] = col\n666         if row is not None:\n667             variables[\"row\"] = row\n668 \n669         structure = {}\n670         if isinstance(order, dict):\n671             for dim in [\"col\", \"row\"]:\n672                 dim_order = order.get(dim)\n673                 if dim_order is not None:\n674                     structure[dim] = list(dim_order)\n675         elif order is not None:\n676             if col is not None and row is not None:\n677                 err = \" \".join([\n678                     \"When faceting on both col= and row=, passing `order` as a list\"\n679                     \"is ambiguous. Use a dict with 'col' and/or 'row' keys instead.\"\n680                 ])\n681                 raise RuntimeError(err)\n682             elif col is not None:\n683                 structure[\"col\"] = list(order)\n684             elif row is not None:\n685                 structure[\"row\"] = list(order)\n686 \n687         spec: FacetSpec = {\n688             \"variables\": variables,\n689             \"structure\": structure,\n690             \"wrap\": wrap,\n691         }\n692 \n693         new = self._clone()\n694         new._facet_spec.update(spec)\n695 \n696         return new\n697 \n698     # TODO def twin()?\n699 \n700     def scale(self, **scales: Scale) -> Plot:\n701         \"\"\"\n702         Specify mappings from data units to visual properties.\n703 \n704         Keywords correspond to variables defined in the plot, including coordinate\n705         variables (`x`, `y`) and semantic variables (`color`, `pointsize`, etc.).\n706 \n707         A number of \"magic\" arguments are accepted, including:\n708             - The name of a transform (e.g., `\"log\"`, `\"sqrt\"`)\n709             - The name of a palette (e.g., `\"viridis\"`, `\"muted\"`)\n710             - A tuple of values, defining the output range (e.g. `(1, 5)`)\n711             - A dict, implying a :class:`Nominal` scale (e.g. `{\"a\": .2, \"b\": .5}`)\n712             - A list of values, implying a :class:`Nominal` scale (e.g. `[\"b\", \"r\"]`)\n713 \n714         For more explicit control, pass a scale spec object such as :class:`Continuous`\n715         or :class:`Nominal`. Or pass `None` to use an \"identity\" scale, which treats\n716         data values as literally encoding visual properties.\n717 \n718         Examples\n719         --------\n720         .. include:: ../docstrings/objects.Plot.scale.rst\n721 \n722         \"\"\"\n723         new = self._clone()\n724         new._scales.update(scales)\n725         return new\n726 \n727     def share(self, **shares: bool | str) -> Plot:\n728         \"\"\"\n729         Control sharing of axis limits and ticks across subplots.\n730 \n731         Keywords correspond to variables defined in the plot, and values can be\n732         boolean (to share across all subplots), or one of \"row\" or \"col\" (to share\n733         more selectively across one dimension of a grid).\n734 \n735         Behavior for non-coordinate variables is currently undefined.\n736 \n737         Examples\n738         --------\n739         .. include:: ../docstrings/objects.Plot.share.rst\n740 \n741         \"\"\"\n742         new = self._clone()\n743         new._shares.update(shares)\n744         return new\n745 \n746     def limit(self, **limits: tuple[Any, Any]) -> Plot:\n747         \"\"\"\n748         Control the range of visible data.\n749 \n750         Keywords correspond to variables defined in the plot, and values are a\n751         `(min, max)` tuple (where either can be `None` to leave unset).\n752 \n753         Limits apply only to the axis; data outside the visible range are\n754         still used for any stat transforms and added to the plot.\n755 \n756         Behavior for non-coordinate variables is currently undefined.\n757 \n758         Examples\n759         --------\n760         .. include:: ../docstrings/objects.Plot.limit.rst\n761 \n762         \"\"\"\n763         new = self._clone()\n764         new._limits.update(limits)\n765         return new\n766 \n767     def label(self, *, title=None, **variables: str | Callable[[str], str]) -> Plot:\n768         \"\"\"\n769         Control the labels and titles for axes, legends, and subplots.\n770 \n771         Additional keywords correspond to variables defined in the plot.\n772         Values can be one of the following types:\n773 \n774         - string (used literally; pass \"\" to clear the default label)\n775         - function (called on the default label)\n776 \n777         For coordinate variables, the value sets the axis label.\n778         For semantic variables, the value sets the legend title.\n779         For faceting variables, `title=` modifies the subplot-specific label,\n780         while `col=` and/or `row=` add a label for the faceting variable.\n781         When using a single subplot, `title=` sets its title.\n782 \n783         Examples\n784         --------\n785         .. include:: ../docstrings/objects.Plot.label.rst\n786 \n787 \n788         \"\"\"\n789         new = self._clone()\n790         if title is not None:\n791             new._labels[\"title\"] = title\n792         new._labels.update(variables)\n793         return new\n794 \n795     def layout(\n796         self,\n797         *,\n798         size: tuple[float, float] | Default = default,\n799         engine: str | None | Default = default,\n800     ) -> Plot:\n801         \"\"\"\n802         Control the figure size and layout.\n803 \n804         .. note::\n805 \n806             Default figure sizes and the API for specifying the figure size are subject\n807             to change in future \"experimental\" releases of the objects API. The default\n808             layout engine may also change.\n809 \n810         Parameters\n811         ----------\n812         size : (width, height)\n813             Size of the resulting figure, in inches. Size is inclusive of legend when\n814             using pyplot, but not otherwise.\n815         engine : {{\"tight\", \"constrained\", None}}\n816             Name of method for automatically adjusting the layout to remove overlap.\n817             The default depends on whether :meth:`Plot.on` is used.\n818 \n819         Examples\n820         --------\n821         .. include:: ../docstrings/objects.Plot.layout.rst\n822 \n823         \"\"\"\n824         # TODO add an \"auto\" mode for figsize that roughly scales with the rcParams\n825         # figsize (so that works), but expands to prevent subplots from being squished\n826         # Also should we have height=, aspect=, exclusive with figsize? Or working\n827         # with figsize when only one is defined?\n828 \n829         new = self._clone()\n830 \n831         if size is not default:\n832             new._figure_spec[\"figsize\"] = size\n833         if engine is not default:\n834             new._layout_spec[\"engine\"] = engine\n835 \n836         return new\n837 \n838     # TODO def legend (ugh)\n839 \n840     def theme(self, *args: dict[str, Any]) -> Plot:\n841         \"\"\"\n842         Control the appearance of elements in the plot.\n843 \n844         .. note::\n845 \n846             The API for customizing plot appearance is not yet finalized.\n847             Currently, the only valid argument is a dict of matplotlib rc parameters.\n848             (This dict must be passed as a positional argument.)\n849 \n850             It is likely that this method will be enhanced in future releases.\n851 \n852         Matplotlib rc parameters are documented on the following page:\n853         https://matplotlib.org/stable/tutorials/introductory/customizing.html\n854 \n855         Examples\n856         --------\n857         .. include:: ../docstrings/objects.Plot.theme.rst\n858 \n859         \"\"\"\n860         new = self._clone()\n861 \n862         # We can skip this whole block on Python 3.8+ with positional-only syntax\n863         nargs = len(args)\n864         if nargs != 1:\n865             err = f\"theme() takes 1 positional argument, but {nargs} were given\"\n866             raise TypeError(err)\n867 \n868         rc = mpl.RcParams(args[0])\n869         new._theme.update(rc)\n870 \n871         return new\n872 \n873     def save(self, loc, **kwargs) -> Plot:\n874         \"\"\"\n875         Compile the plot and write it to a buffer or file on disk.\n876 \n877         Parameters\n878         ----------\n879         loc : str, path, or buffer\n880             Location on disk to save the figure, or a buffer to write into.\n881         kwargs\n882             Other keyword arguments are passed through to\n883             :meth:`matplotlib.figure.Figure.savefig`.\n884 \n885         \"\"\"\n886         # TODO expose important keyword arguments in our signature?\n887         with theme_context(self._theme_with_defaults()):\n888             self._plot().save(loc, **kwargs)\n889         return self\n890 \n891     def show(self, **kwargs) -> None:\n892         \"\"\"\n893         Compile the plot and display it by hooking into pyplot.\n894 \n895         Calling this method is not necessary to render a plot in notebook context,\n896         but it may be in other environments (e.g., in a terminal). After compiling the\n897         plot, it calls :func:`matplotlib.pyplot.show` (passing any keyword parameters).\n898 \n899         Unlike other :class:`Plot` methods, there is no return value. This should be\n900         the last method you call when specifying a plot.\n901 \n902         \"\"\"\n903         # TODO make pyplot configurable at the class level, and when not using,\n904         # import IPython.display and call on self to populate cell output?\n905 \n906         # Keep an eye on whether matplotlib implements \"attaching\" an existing\n907         # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024\n908 \n909         self.plot(pyplot=True).show(**kwargs)\n910 \n911     def plot(self, pyplot: bool = False) -> Plotter:\n912         \"\"\"\n913         Compile the plot spec and return the Plotter object.\n914         \"\"\"\n915         with theme_context(self._theme_with_defaults()):\n916             return self._plot(pyplot)\n917 \n918     def _plot(self, pyplot: bool = False) -> Plotter:\n919 \n920         # TODO if we have _target object, pyplot should be determined by whether it\n921         # is hooked into the pyplot state machine (how do we check?)\n922 \n923         plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())\n924 \n925         # Process the variable assignments and initialize the figure\n926         common, layers = plotter._extract_data(self)\n927         plotter._setup_figure(self, common, layers)\n928 \n929         # Process the scale spec for coordinate variables and transform their data\n930         coord_vars = [v for v in self._variables if re.match(r\"^x|y\", v)]\n931         plotter._setup_scales(self, common, layers, coord_vars)\n932 \n933         # Apply statistical transform(s)\n934         plotter._compute_stats(self, layers)\n935 \n936         # Process scale spec for semantic variables and coordinates computed by stat\n937         plotter._setup_scales(self, common, layers)\n938 \n939         # TODO Remove these after updating other methods\n940         # ---- Maybe have debug= param that attaches these when True?\n941         plotter._data = common\n942         plotter._layers = layers\n943 \n944         # Process the data for each layer and add matplotlib artists\n945         for layer in layers:\n946             plotter._plot_layer(self, layer)\n947 \n948         # Add various figure decorations\n949         plotter._make_legend(self)\n950         plotter._finalize_figure(self)\n951 \n952         return plotter\n953 \n954 \n955 # ---- The plot compilation engine ---------------------------------------------- #\n956 \n957 \n958 class Plotter:\n959     \"\"\"\n960     Engine for compiling a :class:`Plot` spec into a Matplotlib figure.\n961 \n962     This class is not intended to be instantiated directly by users.\n963 \n964     \"\"\"\n965     # TODO decide if we ever want these (Plot.plot(debug=True))?\n966     _data: PlotData\n967     _layers: list[Layer]\n968     _figure: Figure\n969 \n970     def __init__(self, pyplot: bool, theme: dict[str, Any]):\n971 \n972         self._pyplot = pyplot\n973         self._theme = theme\n974         self._legend_contents: list[tuple[\n975             tuple[str, str | int], list[Artist], list[str],\n976         ]] = []\n977         self._scales: dict[str, Scale] = {}\n978 \n979     def save(self, loc, **kwargs) -> Plotter:  # TODO type args\n980         kwargs.setdefault(\"dpi\", 96)\n981         try:\n982             loc = os.path.expanduser(loc)\n983         except TypeError:\n984             # loc may be a buffer in which case that would not work\n985             pass\n986         self._figure.savefig(loc, **kwargs)\n987         return self\n988 \n989     def show(self, **kwargs) -> None:\n990         \"\"\"\n991         Display the plot by hooking into pyplot.\n992 \n993         This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.\n994 \n995         \"\"\"\n996         # TODO if we did not create the Plotter with pyplot, is it possible to do this?\n997         # If not we should clearly raise.\n998         import matplotlib.pyplot as plt\n999         with theme_context(self._theme):\n1000             plt.show(**kwargs)\n1001 \n1002     # TODO API for accessing the underlying matplotlib objects\n1003     # TODO what else is useful in the public API for this class?\n1004 \n1005     def _repr_png_(self) -> tuple[bytes, dict[str, float]] | None:\n1006 \n1007         # TODO use matplotlib backend directly instead of going through savefig?\n1008 \n1009         # TODO perhaps have self.show() flip a switch to disable this, so that\n1010         # user does not end up with two versions of the figure in the output\n1011 \n1012         # TODO use bbox_inches=\"tight\" like the inline backend?\n1013         # pro: better results,  con: (sometimes) confusing results\n1014         # Better solution would be to default (with option to change)\n1015         # to using constrained/tight layout.\n1016 \n1017         if Plot.config.display[\"format\"] != \"png\":\n1018             return None\n1019 \n1020         buffer = io.BytesIO()\n1021 \n1022         factor = 2 if Plot.config.display[\"hidpi\"] else 1\n1023         scaling = Plot.config.display[\"scaling\"] / factor\n1024         dpi = 96 * factor  # TODO put dpi in Plot.config?\n1025 \n1026         with theme_context(self._theme):  # TODO _theme_with_defaults?\n1027             self._figure.savefig(buffer, dpi=dpi, format=\"png\", bbox_inches=\"tight\")\n1028         data = buffer.getvalue()\n1029 \n1030         w, h = Image.open(buffer).size\n1031         metadata = {\"width\": w * scaling, \"height\": h * scaling}\n1032         return data, metadata\n1033 \n1034     def _repr_svg_(self) -> str | None:\n1035 \n1036         if Plot.config.display[\"format\"] != \"svg\":\n1037             return None\n1038 \n1039         # TODO DPI for rasterized artists?\n1040 \n1041         scaling = Plot.config.display[\"scaling\"]\n1042 \n1043         buffer = io.StringIO()\n1044         with theme_context(self._theme):  # TODO _theme_with_defaults?\n1045             self._figure.savefig(buffer, format=\"svg\", bbox_inches=\"tight\")\n1046 \n1047         root = ElementTree.fromstring(buffer.getvalue())\n1048         w = scaling * float(root.attrib[\"width\"][:-2])\n1049         h = scaling * float(root.attrib[\"height\"][:-2])\n1050         root.attrib.update(width=f\"{w}pt\", height=f\"{h}pt\", viewbox=f\"0 0 {w} {h}\")\n1051         ElementTree.ElementTree(root).write(out := io.BytesIO())\n1052 \n1053         return out.getvalue().decode()\n1054 \n1055     def _extract_data(self, p: Plot) -> tuple[PlotData, list[Layer]]:\n1056 \n1057         common_data = (\n1058             p._data\n1059             .join(None, p._facet_spec.get(\"variables\"))\n1060             .join(None, p._pair_spec.get(\"variables\"))\n1061         )\n1062 \n1063         layers: list[Layer] = []\n1064         for layer in p._layers:\n1065             spec = layer.copy()\n1066             spec[\"data\"] = common_data.join(layer.get(\"source\"), layer.get(\"vars\"))\n1067             layers.append(spec)\n1068 \n1069         return common_data, layers\n1070 \n1071     def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -> str:\n1072 \n1073         label: str\n1074         if var in p._labels:\n1075             manual_label = p._labels[var]\n1076             if callable(manual_label) and auto_label is not None:\n1077                 label = manual_label(auto_label)\n1078             else:\n1079                 label = cast(str, manual_label)\n1080         elif auto_label is None:\n1081             label = \"\"\n1082         else:\n1083             label = auto_label\n1084         return label\n1085 \n1086     def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -> None:\n1087 \n1088         # --- Parsing the faceting/pairing parameterization to specify figure grid\n1089 \n1090         subplot_spec = p._subplot_spec.copy()\n1091         facet_spec = p._facet_spec.copy()\n1092         pair_spec = p._pair_spec.copy()\n1093 \n1094         for axis in \"xy\":\n1095             if axis in p._shares:\n1096                 subplot_spec[f\"share{axis}\"] = p._shares[axis]\n1097 \n1098         for dim in [\"col\", \"row\"]:\n1099             if dim in common.frame and dim not in facet_spec[\"structure\"]:\n1100                 order = categorical_order(common.frame[dim])\n1101                 facet_spec[\"structure\"][dim] = order\n1102 \n1103         self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)\n1104 \n1105         # --- Figure initialization\n1106         self._figure = subplots.init_figure(\n1107             pair_spec, self._pyplot, p._figure_spec, p._target,\n1108         )\n1109 \n1110         # --- Figure annotation\n1111         for sub in subplots:\n1112             ax = sub[\"ax\"]\n1113             for axis in \"xy\":\n1114                 axis_key = sub[axis]\n1115 \n1116                 # ~~ Axis labels\n1117 \n1118                 # TODO Should we make it possible to use only one x/y label for\n1119                 # all rows/columns in a faceted plot? Maybe using sub{axis}label,\n1120                 # although the alignments of the labels from that method leaves\n1121                 # something to be desired (in terms of how it defines 'centered').\n1122                 names = [\n1123                     common.names.get(axis_key),\n1124                     *(layer[\"data\"].names.get(axis_key) for layer in layers)\n1125                 ]\n1126                 auto_label = next((name for name in names if name is not None), None)\n1127                 label = self._resolve_label(p, axis_key, auto_label)\n1128                 ax.set(**{f\"{axis}label\": label})\n1129 \n1130                 # ~~ Decoration visibility\n1131 \n1132                 # TODO there should be some override (in Plot.layout?) so that\n1133                 # axis / tick labels can be shown on interior shared axes if desired\n1134 \n1135                 axis_obj = getattr(ax, f\"{axis}axis\")\n1136                 visible_side = {\"x\": \"bottom\", \"y\": \"left\"}.get(axis)\n1137                 show_axis_label = (\n1138                     sub[visible_side]\n1139                     or not p._pair_spec.get(\"cross\", True)\n1140                     or (\n1141                         axis in p._pair_spec.get(\"structure\", {})\n1142                         and bool(p._pair_spec.get(\"wrap\"))\n1143                     )\n1144                 )\n1145                 axis_obj.get_label().set_visible(show_axis_label)\n1146 \n1147                 show_tick_labels = (\n1148                     show_axis_label\n1149                     or subplot_spec.get(f\"share{axis}\") not in (\n1150                         True, \"all\", {\"x\": \"col\", \"y\": \"row\"}[axis]\n1151                     )\n1152                 )\n1153                 for group in (\"major\", \"minor\"):\n1154                     for t in getattr(axis_obj, f\"get_{group}ticklabels\")():\n1155                         t.set_visible(show_tick_labels)\n1156 \n1157             # TODO we want right-side titles for row facets in most cases?\n1158             # Let's have what we currently call \"margin titles\" but properly using the\n1159             # ax.set_title interface (see my gist)\n1160             title_parts = []\n1161             for dim in [\"col\", \"row\"]:\n1162                 if sub[dim] is not None:\n1163                     val = self._resolve_label(p, \"title\", f\"{sub[dim]}\")\n1164                     if dim in p._labels:\n1165                         key = self._resolve_label(p, dim, common.names.get(dim))\n1166                         val = f\"{key} {val}\"\n1167                     title_parts.append(val)\n1168 \n1169             has_col = sub[\"col\"] is not None\n1170             has_row = sub[\"row\"] is not None\n1171             show_title = (\n1172                 has_col and has_row\n1173                 or (has_col or has_row) and p._facet_spec.get(\"wrap\")\n1174                 or (has_col and sub[\"top\"])\n1175                 # TODO or has_row and sub[\"right\"] and <right titles>\n1176                 or has_row  # TODO and not <right titles>\n1177             )\n1178             if title_parts:\n1179                 title = \" | \".join(title_parts)\n1180                 title_text = ax.set_title(title)\n1181                 title_text.set_visible(show_title)\n1182             elif not (has_col or has_row):\n1183                 title = self._resolve_label(p, \"title\", None)\n1184                 title_text = ax.set_title(title)\n1185 \n1186     def _compute_stats(self, spec: Plot, layers: list[Layer]) -> None:\n1187 \n1188         grouping_vars = [v for v in PROPERTIES if v not in \"xy\"]\n1189         grouping_vars += [\"col\", \"row\", \"group\"]\n1190 \n1191         pair_vars = spec._pair_spec.get(\"structure\", {})\n1192 \n1193         for layer in layers:\n1194 \n1195             data = layer[\"data\"]\n1196             mark = layer[\"mark\"]\n1197             stat = layer[\"stat\"]\n1198 \n1199             if stat is None:\n1200                 continue\n1201 \n1202             iter_axes = itertools.product(*[\n1203                 pair_vars.get(axis, [axis]) for axis in \"xy\"\n1204             ])\n1205 \n1206             old = data.frame\n1207 \n1208             if pair_vars:\n1209                 data.frames = {}\n1210                 data.frame = data.frame.iloc[:0]  # TODO to simplify typing\n1211 \n1212             for coord_vars in iter_axes:\n1213 \n1214                 pairings = \"xy\", coord_vars\n1215 \n1216                 df = old.copy()\n1217                 scales = self._scales.copy()\n1218 \n1219                 for axis, var in zip(*pairings):\n1220                     if axis != var:\n1221                         df = df.rename(columns={var: axis})\n1222                         drop_cols = [x for x in df if re.match(rf\"{axis}\\d+\", str(x))]\n1223                         df = df.drop(drop_cols, axis=1)\n1224                         scales[axis] = scales[var]\n1225 \n1226                 orient = layer[\"orient\"] or mark._infer_orient(scales)\n1227 \n1228                 if stat.group_by_orient:\n1229                     grouper = [orient, *grouping_vars]\n1230                 else:\n1231                     grouper = grouping_vars\n1232                 groupby = GroupBy(grouper)\n1233                 res = stat(df, groupby, orient, scales)\n1234 \n1235                 if pair_vars:\n1236                     data.frames[coord_vars] = res\n1237                 else:\n1238                     data.frame = res\n1239 \n1240     def _get_scale(\n1241         self, spec: Plot, var: str, prop: Property, values: Series\n1242     ) -> Scale:\n1243 \n1244         if var in spec._scales:\n1245             arg = spec._scales[var]\n1246             if arg is None or isinstance(arg, Scale):\n1247                 scale = arg\n1248             else:\n1249                 scale = prop.infer_scale(arg, values)\n1250         else:\n1251             scale = prop.default_scale(values)\n1252 \n1253         return scale\n1254 \n1255     def _get_subplot_data(self, df, var, view, share_state):\n1256 \n1257         if share_state in [True, \"all\"]:\n1258             # The all-shared case is easiest, every subplot sees all the data\n1259             seed_values = df[var]\n1260         else:\n1261             # Otherwise, we need to setup separate scales for different subplots\n1262             if share_state in [False, \"none\"]:\n1263                 # Fully independent axes are also easy: use each subplot's data\n1264                 idx = self._get_subplot_index(df, view)\n1265             elif share_state in df:\n1266                 # Sharing within row/col is more complicated\n1267                 use_rows = df[share_state] == view[share_state]\n1268                 idx = df.index[use_rows]\n1269             else:\n1270                 # This configuration doesn't make much sense, but it's fine\n1271                 idx = df.index\n1272 \n1273             seed_values = df.loc[idx, var]\n1274 \n1275         return seed_values\n1276 \n1277     def _setup_scales(\n1278         self, p: Plot,\n1279         common: PlotData,\n1280         layers: list[Layer],\n1281         variables: list[str] | None = None,\n1282     ) -> None:\n1283 \n1284         if variables is None:\n1285             # Add variables that have data but not a scale, which happens\n1286             # because this method can be called multiple time, to handle\n1287             # variables added during the Stat transform.\n1288             variables = []\n1289             for layer in layers:\n1290                 variables.extend(layer[\"data\"].frame.columns)\n1291                 for df in layer[\"data\"].frames.values():\n1292                     variables.extend(str(v) for v in df if v not in variables)\n1293             variables = [v for v in variables if v not in self._scales]\n1294 \n1295         for var in variables:\n1296 \n1297             # Determine whether this is a coordinate variable\n1298             # (i.e., x/y, paired x/y, or derivative such as xmax)\n1299             m = re.match(r\"^(?P<coord>(?P<axis>x|y)\\d*).*\", var)\n1300             if m is None:\n1301                 coord = axis = None\n1302             else:\n1303                 coord = m[\"coord\"]\n1304                 axis = m[\"axis\"]\n1305 \n1306             # Get keys that handle things like x0, xmax, properly where relevant\n1307             prop_key = var if axis is None else axis\n1308             scale_key = var if coord is None else coord\n1309 \n1310             if prop_key not in PROPERTIES:\n1311                 continue\n1312 \n1313             # Concatenate layers, using only the relevant coordinate and faceting vars,\n1314             # This is unnecessarily wasteful, as layer data will often be redundant.\n1315             # But figuring out the minimal amount we need is more complicated.\n1316             cols = [var, \"col\", \"row\"]\n1317             parts = [common.frame.filter(cols)]\n1318             for layer in layers:\n1319                 parts.append(layer[\"data\"].frame.filter(cols))\n1320                 for df in layer[\"data\"].frames.values():\n1321                     parts.append(df.filter(cols))\n1322             var_df = pd.concat(parts, ignore_index=True)\n1323 \n1324             prop = PROPERTIES[prop_key]\n1325             scale = self._get_scale(p, scale_key, prop, var_df[var])\n1326 \n1327             if scale_key not in p._variables:\n1328                 # TODO this implies that the variable was added by the stat\n1329                 # It allows downstream orientation inference to work properly.\n1330                 # But it feels rather hacky, so ideally revisit.\n1331                 scale._priority = 0  # type: ignore\n1332 \n1333             if axis is None:\n1334                 # We could think about having a broader concept of (un)shared properties\n1335                 # In general, not something you want to do (different scales in facets)\n1336                 # But could make sense e.g. with paired plots. Build later.\n1337                 share_state = None\n1338                 subplots = []\n1339             else:\n1340                 share_state = self._subplots.subplot_spec[f\"share{axis}\"]\n1341                 subplots = [view for view in self._subplots if view[axis] == coord]\n1342 \n1343             # Shared categorical axes are broken on matplotlib<3.4.0.\n1344             # https://github.com/matplotlib/matplotlib/pull/18308\n1345             # This only affects us when sharing *paired* axes. This is a novel/niche\n1346             # behavior, so we will raise rather than hack together a workaround.\n1347             if axis is not None and _version_predates(mpl, \"3.4\"):\n1348                 paired_axis = axis in p._pair_spec.get(\"structure\", {})\n1349                 cat_scale = isinstance(scale, Nominal)\n1350                 ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]\n1351                 shared_axes = share_state not in [False, \"none\", ok_dim]\n1352                 if paired_axis and cat_scale and shared_axes:\n1353                     err = \"Sharing paired categorical axes requires matplotlib>=3.4.0\"\n1354                     raise RuntimeError(err)\n1355 \n1356             if scale is None:\n1357                 self._scales[var] = Scale._identity()\n1358             else:\n1359                 try:\n1360                     self._scales[var] = scale._setup(var_df[var], prop)\n1361                 except Exception as err:\n1362                     raise PlotSpecError._during(\"Scale setup\", var) from err\n1363 \n1364             if axis is None or (var != coord and coord in p._variables):\n1365                 # Everything below here applies only to coordinate variables\n1366                 continue\n1367 \n1368             # Set up an empty series to receive the transformed values.\n1369             # We need this to handle piecemeal transforms of categories -> floats.\n1370             transformed_data = []\n1371             for layer in layers:\n1372                 index = layer[\"data\"].frame.index\n1373                 empty_series = pd.Series(dtype=float, index=index, name=var)\n1374                 transformed_data.append(empty_series)\n1375 \n1376             for view in subplots:\n1377 \n1378                 axis_obj = getattr(view[\"ax\"], f\"{axis}axis\")\n1379                 seed_values = self._get_subplot_data(var_df, var, view, share_state)\n1380                 view_scale = scale._setup(seed_values, prop, axis=axis_obj)\n1381                 set_scale_obj(view[\"ax\"], axis, view_scale._matplotlib_scale)\n1382 \n1383                 for layer, new_series in zip(layers, transformed_data):\n1384                     layer_df = layer[\"data\"].frame\n1385                     if var not in layer_df:\n1386                         continue\n1387 \n1388                     idx = self._get_subplot_index(layer_df, view)\n1389                     try:\n1390                         new_series.loc[idx] = view_scale(layer_df.loc[idx, var])\n1391                     except Exception as err:\n1392                         spec_error = PlotSpecError._during(\"Scaling operation\", var)\n1393                         raise spec_error from err\n1394 \n1395             # Now the transformed data series are complete, set update the layer data\n1396             for layer, new_series in zip(layers, transformed_data):\n1397                 layer_df = layer[\"data\"].frame\n1398                 if var in layer_df:\n1399                     layer_df[var] = new_series\n1400 \n1401     def _plot_layer(self, p: Plot, layer: Layer) -> None:\n1402 \n1403         data = layer[\"data\"]\n1404         mark = layer[\"mark\"]\n1405         move = layer[\"move\"]\n1406 \n1407         default_grouping_vars = [\"col\", \"row\", \"group\"]  # TODO where best to define?\n1408         grouping_properties = [v for v in PROPERTIES if v[0] not in \"xy\"]\n1409 \n1410         pair_variables = p._pair_spec.get(\"structure\", {})\n1411 \n1412         for subplots, df, scales in self._generate_pairings(data, pair_variables):\n1413 \n1414             orient = layer[\"orient\"] or mark._infer_orient(scales)\n1415 \n1416             def get_order(var):\n1417                 # Ignore order for x/y: they have been scaled to numeric indices,\n1418                 # so any original order is no longer valid. Default ordering rules\n1419                 # sorted unique numbers will correctly reconstruct intended order\n1420                 # TODO This is tricky, make sure we add some tests for this\n1421                 if var not in \"xy\" and var in scales:\n1422                     return getattr(scales[var], \"order\", None)\n1423 \n1424             if orient in df:\n1425                 width = pd.Series(index=df.index, dtype=float)\n1426                 for view in subplots:\n1427                     view_idx = self._get_subplot_data(\n1428                         df, orient, view, p._shares.get(orient)\n1429                     ).index\n1430                     view_df = df.loc[view_idx]\n1431                     if \"width\" in mark._mappable_props:\n1432                         view_width = mark._resolve(view_df, \"width\", None)\n1433                     elif \"width\" in df:\n1434                         view_width = view_df[\"width\"]\n1435                     else:\n1436                         view_width = 0.8  # TODO what default?\n1437                     spacing = scales[orient]._spacing(view_df.loc[view_idx, orient])\n1438                     width.loc[view_idx] = view_width * spacing\n1439                 df[\"width\"] = width\n1440 \n1441             if \"baseline\" in mark._mappable_props:\n1442                 # TODO what marks should have this?\n1443                 # If we can set baseline with, e.g., Bar(), then the\n1444                 # \"other\" (e.g. y for x oriented bars) parameterization\n1445                 # is somewhat ambiguous.\n1446                 baseline = mark._resolve(df, \"baseline\", None)\n1447             else:\n1448                 # TODO unlike width, we might not want to add baseline to data\n1449                 # if the mark doesn't use it. Practically, there is a concern about\n1450                 # Mark abstraction like Area / Ribbon\n1451                 baseline = 0 if \"baseline\" not in df else df[\"baseline\"]\n1452             df[\"baseline\"] = baseline\n1453 \n1454             if move is not None:\n1455                 moves = move if isinstance(move, list) else [move]\n1456                 for move_step in moves:\n1457                     move_by = getattr(move_step, \"by\", None)\n1458                     if move_by is None:\n1459                         move_by = grouping_properties\n1460                     move_groupers = [*move_by, *default_grouping_vars]\n1461                     if move_step.group_by_orient:\n1462                         move_groupers.insert(0, orient)\n1463                     order = {var: get_order(var) for var in move_groupers}\n1464                     groupby = GroupBy(order)\n1465                     df = move_step(df, groupby, orient, scales)\n1466 \n1467             df = self._unscale_coords(subplots, df, orient)\n1468 \n1469             grouping_vars = mark._grouping_props + default_grouping_vars\n1470             split_generator = self._setup_split_generator(grouping_vars, df, subplots)\n1471 \n1472             mark._plot(split_generator, scales, orient)\n1473 \n1474         # TODO is this the right place for this?\n1475         for view in self._subplots:\n1476             view[\"ax\"].autoscale_view()\n1477 \n1478         if layer[\"legend\"]:\n1479             self._update_legend_contents(p, mark, data, scales)\n1480 \n1481     def _unscale_coords(\n1482         self, subplots: list[dict], df: DataFrame, orient: str,\n1483     ) -> DataFrame:\n1484         # TODO do we still have numbers in the variable name at this point?\n1485         coord_cols = [c for c in df if re.match(r\"^[xy]\\D*$\", str(c))]\n1486         out_df = (\n1487             df\n1488             .drop(coord_cols, axis=1)\n1489             .reindex(df.columns, axis=1)  # So unscaled columns retain their place\n1490             .copy(deep=False)\n1491         )\n1492 \n1493         for view in subplots:\n1494             view_df = self._filter_subplot_data(df, view)\n1495             axes_df = view_df[coord_cols]\n1496             for var, values in axes_df.items():\n1497 \n1498                 axis = getattr(view[\"ax\"], f\"{str(var)[0]}axis\")\n1499                 # TODO see https://github.com/matplotlib/matplotlib/issues/22713\n1500                 transform = axis.get_transform().inverted().transform\n1501                 inverted = transform(values)\n1502                 out_df.loc[values.index, str(var)] = inverted\n1503 \n1504         return out_df\n1505 \n1506     def _generate_pairings(\n1507         self, data: PlotData, pair_variables: dict,\n1508     ) -> Generator[\n1509         tuple[list[dict], DataFrame, dict[str, Scale]], None, None\n1510     ]:\n1511         # TODO retype return with subplot_spec or similar\n1512 \n1513         iter_axes = itertools.product(*[\n1514             pair_variables.get(axis, [axis]) for axis in \"xy\"\n1515         ])\n1516 \n1517         for x, y in iter_axes:\n1518 \n1519             subplots = []\n1520             for view in self._subplots:\n1521                 if (view[\"x\"] == x) and (view[\"y\"] == y):\n1522                     subplots.append(view)\n1523 \n1524             if data.frame.empty and data.frames:\n1525                 out_df = data.frames[(x, y)].copy()\n1526             elif not pair_variables:\n1527                 out_df = data.frame.copy()\n1528             else:\n1529                 if data.frame.empty and data.frames:\n1530                     out_df = data.frames[(x, y)].copy()\n1531                 else:\n1532                     out_df = data.frame.copy()\n1533 \n1534             scales = self._scales.copy()\n1535             if x in out_df:\n1536                 scales[\"x\"] = self._scales[x]\n1537             if y in out_df:\n1538                 scales[\"y\"] = self._scales[y]\n1539 \n1540             for axis, var in zip(\"xy\", (x, y)):\n1541                 if axis != var:\n1542                     out_df = out_df.rename(columns={var: axis})\n1543                     cols = [col for col in out_df if re.match(rf\"{axis}\\d+\", str(col))]\n1544                     out_df = out_df.drop(cols, axis=1)\n1545 \n1546             yield subplots, out_df, scales\n1547 \n1548     def _get_subplot_index(self, df: DataFrame, subplot: dict) -> Index:\n1549 \n1550         dims = df.columns.intersection([\"col\", \"row\"])\n1551         if dims.empty:\n1552             return df.index\n1553 \n1554         keep_rows = pd.Series(True, df.index, dtype=bool)\n1555         for dim in dims:\n1556             keep_rows &= df[dim] == subplot[dim]\n1557         return df.index[keep_rows]\n1558 \n1559     def _filter_subplot_data(self, df: DataFrame, subplot: dict) -> DataFrame:\n1560         # TODO note redundancies with preceding function ... needs refactoring\n1561         dims = df.columns.intersection([\"col\", \"row\"])\n1562         if dims.empty:\n1563             return df\n1564 \n1565         keep_rows = pd.Series(True, df.index, dtype=bool)\n1566         for dim in dims:\n1567             keep_rows &= df[dim] == subplot[dim]\n1568         return df[keep_rows]\n1569 \n1570     def _setup_split_generator(\n1571         self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],\n1572     ) -> Callable[[], Generator]:\n1573 \n1574         grouping_keys = []\n1575         grouping_vars = [\n1576             v for v in grouping_vars if v in df and v not in [\"col\", \"row\"]\n1577         ]\n1578         for var in grouping_vars:\n1579             order = getattr(self._scales[var], \"order\", None)\n1580             if order is None:\n1581                 order = categorical_order(df[var])\n1582             grouping_keys.append(order)\n1583 \n1584         def split_generator(keep_na=False) -> Generator:\n1585 \n1586             for view in subplots:\n1587 \n1588                 axes_df = self._filter_subplot_data(df, view)\n1589 \n1590                 with pd.option_context(\"mode.use_inf_as_na\", True):\n1591                     if keep_na:\n1592                         # The simpler thing to do would be x.dropna().reindex(x.index).\n1593                         # But that doesn't work with the way that the subset iteration\n1594                         # is written below, which assumes data for grouping vars.\n1595                         # Matplotlib (usually?) masks nan data, so this should \"work\".\n1596                         # Downstream code can also drop these rows, at some speed cost.\n1597                         present = axes_df.notna().all(axis=1)\n1598                         nulled = {}\n1599                         for axis in \"xy\":\n1600                             if axis in axes_df:\n1601                                 nulled[axis] = axes_df[axis].where(present)\n1602                         axes_df = axes_df.assign(**nulled)\n1603                     else:\n1604                         axes_df = axes_df.dropna()\n1605 \n1606                 subplot_keys = {}\n1607                 for dim in [\"col\", \"row\"]:\n1608                     if view[dim] is not None:\n1609                         subplot_keys[dim] = view[dim]\n1610 \n1611                 if not grouping_vars or not any(grouping_keys):\n1612                     if not axes_df.empty:\n1613                         yield subplot_keys, axes_df.copy(), view[\"ax\"]\n1614                     continue\n1615 \n1616                 grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)\n1617 \n1618                 for key in itertools.product(*grouping_keys):\n1619 \n1620                     # Pandas fails with singleton tuple inputs\n1621                     pd_key = key[0] if len(key) == 1 else key\n1622 \n1623                     try:\n1624                         df_subset = grouped_df.get_group(pd_key)\n1625                     except KeyError:\n1626                         # TODO (from initial work on categorical plots refactor)\n1627                         # We are adding this to allow backwards compatability\n1628                         # with the empty artists that old categorical plots would\n1629                         # add (before 0.12), which we may decide to break, in which\n1630                         # case this option could be removed\n1631                         df_subset = axes_df.loc[[]]\n1632 \n1633                     if df_subset.empty:\n1634                         continue\n1635 \n1636                     sub_vars = dict(zip(grouping_vars, key))\n1637                     sub_vars.update(subplot_keys)\n1638 \n1639                     # TODO need copy(deep=...) policy (here, above, anywhere else?)\n1640                     yield sub_vars, df_subset.copy(), view[\"ax\"]\n1641 \n1642         return split_generator\n1643 \n1644     def _update_legend_contents(\n1645         self,\n1646         p: Plot,\n1647         mark: Mark,\n1648         data: PlotData,\n1649         scales: dict[str, Scale],\n1650     ) -> None:\n1651         \"\"\"Add legend artists / labels for one layer in the plot.\"\"\"\n1652         if data.frame.empty and data.frames:\n1653             legend_vars: list[str] = []\n1654             for frame in data.frames.values():\n1655                 frame_vars = frame.columns.intersection(list(scales))\n1656                 legend_vars.extend(v for v in frame_vars if v not in legend_vars)\n1657         else:\n1658             legend_vars = list(data.frame.columns.intersection(list(scales)))\n1659 \n1660         # First pass: Identify the values that will be shown for each variable\n1661         schema: list[tuple[\n1662             tuple[str, str | int], list[str], tuple[list, list[str]]\n1663         ]] = []\n1664         schema = []\n1665         for var in legend_vars:\n1666             var_legend = scales[var]._legend\n1667             if var_legend is not None:\n1668                 values, labels = var_legend\n1669                 for (_, part_id), part_vars, _ in schema:\n1670                     if data.ids[var] == part_id:\n1671                         # Allow multiple plot semantics to represent same data variable\n1672                         part_vars.append(var)\n1673                         break\n1674                 else:\n1675                     title = self._resolve_label(p, var, data.names[var])\n1676                     entry = (title, data.ids[var]), [var], (values, labels)\n1677                     schema.append(entry)\n1678 \n1679         # Second pass, generate an artist corresponding to each value\n1680         contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []\n1681         for key, variables, (values, labels) in schema:\n1682             artists = []\n1683             for val in values:\n1684                 artist = mark._legend_artist(variables, val, scales)\n1685                 if artist is not None:\n1686                     artists.append(artist)\n1687             if artists:\n1688                 contents.append((key, artists, labels))\n1689 \n1690         self._legend_contents.extend(contents)\n1691 \n1692     def _make_legend(self, p: Plot) -> None:\n1693         \"\"\"Create the legend artist(s) and add onto the figure.\"\"\"\n1694         # Combine artists representing same information across layers\n1695         # Input list has an entry for each distinct variable in each layer\n1696         # Output dict has an entry for each distinct variable\n1697         merged_contents: dict[\n1698             tuple[str, str | int], tuple[list[Artist], list[str]],\n1699         ] = {}\n1700         for key, new_artists, labels in self._legend_contents:\n1701             # Key is (name, id); we need the id to resolve variable uniqueness,\n1702             # but will need the name in the next step to title the legend\n1703             if key in merged_contents:\n1704                 # Copy so inplace updates don't propagate back to legend_contents\n1705                 existing_artists = merged_contents[key][0]\n1706                 for i, artist in enumerate(existing_artists):\n1707                     # Matplotlib accepts a tuple of artists and will overlay them\n1708                     if isinstance(artist, tuple):\n1709                         artist += new_artists[i],\n1710                     else:\n1711                         existing_artists[i] = artist, new_artists[i]\n1712             else:\n1713                 merged_contents[key] = new_artists.copy(), labels\n1714 \n1715         # TODO explain\n1716         loc = \"center right\" if self._pyplot else \"center left\"\n1717 \n1718         base_legend = None\n1719         for (name, _), (handles, labels) in merged_contents.items():\n1720 \n1721             legend = mpl.legend.Legend(\n1722                 self._figure,\n1723                 handles,\n1724                 labels,\n1725                 title=name,\n1726                 loc=loc,\n1727                 bbox_to_anchor=(.98, .55),\n1728             )\n1729 \n1730             if base_legend:\n1731                 # Matplotlib has no public API for this so it is a bit of a hack.\n1732                 # Ideally we'd define our own legend class with more flexibility,\n1733                 # but that is a lot of work!\n1734                 base_legend_box = base_legend.get_children()[0]\n1735                 this_legend_box = legend.get_children()[0]\n1736                 base_legend_box.get_children().extend(this_legend_box.get_children())\n1737             else:\n1738                 base_legend = legend\n1739                 self._figure.legends.append(legend)\n1740 \n1741     def _finalize_figure(self, p: Plot) -> None:\n1742 \n1743         for sub in self._subplots:\n1744             ax = sub[\"ax\"]\n1745             for axis in \"xy\":\n1746                 axis_key = sub[axis]\n1747                 axis_obj = getattr(ax, f\"{axis}axis\")\n1748 \n1749                 # Axis limits\n1750                 if axis_key in p._limits:\n1751                     convert_units = getattr(ax, f\"{axis}axis\").convert_units\n1752                     a, b = p._limits[axis_key]\n1753                     lo = a if a is None else convert_units(a)\n1754                     hi = b if b is None else convert_units(b)\n1755                     if isinstance(a, str):\n1756                         lo = cast(float, lo) - 0.5\n1757                     if isinstance(b, str):\n1758                         hi = cast(float, hi) + 0.5\n1759                     ax.set(**{f\"{axis}lim\": (lo, hi)})\n1760 \n1761                 if axis_key in self._scales:  # TODO when would it not be?\n1762                     self._scales[axis_key]._finalize(p, axis_obj)\n1763 \n1764         if (engine := p._layout_spec.get(\"engine\", default)) is not default:\n1765             # None is a valid arg for Figure.set_layout_engine, hence `default`\n1766             set_layout_engine(self._figure, engine)\n1767         elif p._target is None:\n1768             # Don't modify the layout engine if the user supplied their own\n1769             # matplotlib figure and didn't specify an engine through Plot\n1770             # TODO switch default to \"constrained\"?\n1771             # TODO either way, make configurable\n1772             set_layout_engine(self._figure, \"tight\")\n",
        "intended_behavior": "This file likely contains functions or methods that prepare data for plotting, including handling of missing values. The code should ensure that missing values (`pd.NA` or `np.nan`) do not influence the sorting or ordering of axes in plots. A specific method within this could potentially be handling data frames before they are plotted, which would need to be adjusted to uniformly treat `pd.NA` and `np.nan` to maintain axis ordering."
    },
    {
        "rel_file_path": "seaborn/_core/data.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/_core/data.py",
        "start": 1,
        "end": 260,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Components for parsing variable assignments and internally representing plot data.\n3 \"\"\"\n4 from __future__ import annotations\n5 \n6 from collections.abc import Mapping, Sized\n7 from typing import cast\n8 \n9 import pandas as pd\n10 from pandas import DataFrame\n11 \n12 from seaborn._core.typing import DataSource, VariableSpec, ColumnName\n13 \n14 \n15 class PlotData:\n16     \"\"\"\n17     Data table with plot variable schema and mapping to original names.\n18 \n19     Contains logic for parsing variable specification arguments and updating\n20     the table with layer-specific data and/or mappings.\n21 \n22     Parameters\n23     ----------\n24     data\n25         Input data where variable names map to vector values.\n26     variables\n27         Keys are names of plot variables (x, y, ...) each value is one of:\n28 \n29         - name of a column (or index level, or dictionary entry) in `data`\n30         - vector in any format that can construct a :class:`pandas.DataFrame`\n31 \n32     Attributes\n33     ----------\n34     frame\n35         Data table with column names having defined plot variables.\n36     names\n37         Dictionary mapping plot variable names to names in source data structure(s).\n38     ids\n39         Dictionary mapping plot variable names to unique data source identifiers.\n40 \n41     \"\"\"\n42     frame: DataFrame\n43     frames: dict[tuple, DataFrame]\n44     names: dict[str, str | None]\n45     ids: dict[str, str | int]\n46     source_data: DataSource\n47     source_vars: dict[str, VariableSpec]\n48 \n49     def __init__(\n50         self,\n51         data: DataSource,\n52         variables: dict[str, VariableSpec],\n53     ):\n54 \n55         frame, names, ids = self._assign_variables(data, variables)\n56 \n57         self.frame = frame\n58         self.names = names\n59         self.ids = ids\n60 \n61         self.frames = {}  # TODO this is a hack, remove\n62 \n63         self.source_data = data\n64         self.source_vars = variables\n65 \n66     def __contains__(self, key: str) -> bool:\n67         \"\"\"Boolean check on whether a variable is defined in this dataset.\"\"\"\n68         if self.frame is None:\n69             return any(key in df for df in self.frames.values())\n70         return key in self.frame\n71 \n72     def join(\n73         self,\n74         data: DataSource,\n75         variables: dict[str, VariableSpec] | None,\n76     ) -> PlotData:\n77         \"\"\"Add, replace, or drop variables and return as a new dataset.\"\"\"\n78         # Inherit the original source of the upsteam data by default\n79         if data is None:\n80             data = self.source_data\n81 \n82         # TODO allow `data` to be a function (that is called on the source data?)\n83 \n84         if not variables:\n85             variables = self.source_vars\n86 \n87         # Passing var=None implies that we do not want that variable in this layer\n88         disinherit = [k for k, v in variables.items() if v is None]\n89 \n90         # Create a new dataset with just the info passed here\n91         new = PlotData(data, variables)\n92 \n93         # -- Update the inherited DataSource with this new information\n94 \n95         drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]\n96         parts = [self.frame.drop(columns=drop_cols), new.frame]\n97 \n98         # Because we are combining distinct columns, this is perhaps more\n99         # naturally thought of as a \"merge\"/\"join\". But using concat because\n100         # some simple testing suggests that it is marginally faster.\n101         frame = pd.concat(parts, axis=1, sort=False, copy=False)\n102 \n103         names = {k: v for k, v in self.names.items() if k not in disinherit}\n104         names.update(new.names)\n105 \n106         ids = {k: v for k, v in self.ids.items() if k not in disinherit}\n107         ids.update(new.ids)\n108 \n109         new.frame = frame\n110         new.names = names\n111         new.ids = ids\n112 \n113         # Multiple chained operations should always inherit from the original object\n114         new.source_data = self.source_data\n115         new.source_vars = self.source_vars\n116 \n117         return new\n118 \n119     def _assign_variables(\n120         self,\n121         data: DataSource,\n122         variables: dict[str, VariableSpec],\n123     ) -> tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:\n124         \"\"\"\n125         Assign values for plot variables given long-form data and/or vector inputs.\n126 \n127         Parameters\n128         ----------\n129         data\n130             Input data where variable names map to vector values.\n131         variables\n132             Keys are names of plot variables (x, y, ...) each value is one of:\n133 \n134             - name of a column (or index level, or dictionary entry) in `data`\n135             - vector in any format that can construct a :class:`pandas.DataFrame`\n136 \n137         Returns\n138         -------\n139         frame\n140             Table mapping seaborn variables (x, y, color, ...) to data vectors.\n141         names\n142             Keys are defined seaborn variables; values are names inferred from\n143             the inputs (or None when no name can be determined).\n144         ids\n145             Like the `names` dict, but `None` values are replaced by the `id()`\n146             of the data object that defined the variable.\n147 \n148         Raises\n149         ------\n150         ValueError\n151             When variables are strings that don't appear in `data`, or when they are\n152             non-indexed vector datatypes that have a different length from `data`.\n153 \n154         \"\"\"\n155         source_data: Mapping | DataFrame\n156         frame: DataFrame\n157         names: dict[str, str | None]\n158         ids: dict[str, str | int]\n159 \n160         plot_data = {}\n161         names = {}\n162         ids = {}\n163 \n164         given_data = data is not None\n165         if data is not None:\n166             source_data = data\n167         else:\n168             # Data is optional; all variables can be defined as vectors\n169             # But simplify downstream code by always having a usable source data object\n170             source_data = {}\n171 \n172         # TODO Generally interested in accepting a generic DataFrame interface\n173         # Track https://data-apis.org/ for development\n174 \n175         # Variables can also be extracted from the index of a DataFrame\n176         if isinstance(source_data, pd.DataFrame):\n177             index = source_data.index.to_frame().to_dict(\"series\")\n178         else:\n179             index = {}\n180 \n181         for key, val in variables.items():\n182 \n183             # Simply ignore variables with no specification\n184             if val is None:\n185                 continue\n186 \n187             # Try to treat the argument as a key for the data collection.\n188             # But be flexible about what can be used as a key.\n189             # Usually it will be a string, but allow other hashables when\n190             # taking from the main data object. Allow only strings to reference\n191             # fields in the index, because otherwise there is too much ambiguity.\n192 \n193             # TODO this will be rendered unnecessary by the following pandas fix:\n194             # https://github.com/pandas-dev/pandas/pull/41283\n195             try:\n196                 hash(val)\n197                 val_is_hashable = True\n198             except TypeError:\n199                 val_is_hashable = False\n200 \n201             val_as_data_key = (\n202                 # See https://github.com/pandas-dev/pandas/pull/41283\n203                 # (isinstance(val, abc.Hashable) and val in source_data)\n204                 (val_is_hashable and val in source_data)\n205                 or (isinstance(val, str) and val in index)\n206             )\n207 \n208             if val_as_data_key:\n209                 val = cast(ColumnName, val)\n210                 if val in source_data:\n211                     plot_data[key] = source_data[val]\n212                 elif val in index:\n213                     plot_data[key] = index[val]\n214                 names[key] = ids[key] = str(val)\n215 \n216             elif isinstance(val, str):\n217 \n218                 # This looks like a column name but, lookup failed.\n219 \n220                 err = f\"Could not interpret value `{val}` for `{key}`. \"\n221                 if not given_data:\n222                     err += \"Value is a string, but `data` was not passed.\"\n223                 else:\n224                     err += \"An entry with this name does not appear in `data`.\"\n225                 raise ValueError(err)\n226 \n227             else:\n228 \n229                 # Otherwise, assume the value somehow represents data\n230 \n231                 # Ignore empty data structures\n232                 if isinstance(val, Sized) and len(val) == 0:\n233                     continue\n234 \n235                 # If vector has no index, it must match length of data table\n236                 if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):\n237                     if isinstance(val, Sized) and len(data) != len(val):\n238                         val_cls = val.__class__.__name__\n239                         err = (\n240                             f\"Length of {val_cls} vectors must match length of `data`\"\n241                             f\" when both are used, but `data` has length {len(data)}\"\n242                             f\" and the vector passed to `{key}` has length {len(val)}.\"\n243                         )\n244                         raise ValueError(err)\n245 \n246                 plot_data[key] = val\n247 \n248                 # Try to infer the original name using pandas-like metadata\n249                 if hasattr(val, \"name\"):\n250                     names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424\n251                 else:\n252                     names[key] = None\n253                     ids[key] = id(val)\n254 \n255         # Construct a tidy plot DataFrame. This will convert a number of\n256         # types automatically, aligning on index in case of pandas objects\n257         # TODO Note: this fails when variable specs *only* have scalars!\n258         frame = pd.DataFrame(plot_data)\n259 \n260         return frame, names, ids\n",
        "intended_behavior": "As this file likely involves data manipulation and preparation for plotting, it should properly manage datasets with missing values, ensuring that insertion of `pd.NA` does not lead to reversed axes. Updating or refining the method to handle `pd.NA` equivalently to `np.nan`, especially in regards to data sorting and ordering for plotting, could resolve the issue."
    }
]