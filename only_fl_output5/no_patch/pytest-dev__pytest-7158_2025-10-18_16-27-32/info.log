2025-10-18 16:27:32.259 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 16:27:35.283 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=355, output_tokens=12, cost=0.003910
2025-10-18 16:27:52.789 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=535, output_tokens=764, cost=0.028270
2025-10-18 16:27:53.959 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:28:00.719 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=657, output_tokens=314, cost=0.015990
2025-10-18 16:28:00.728 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:28:03.911 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=668, output_tokens=61, cost=0.008510
2025-10-18 16:28:03.913 | DEBUG    | Extracted a valid json.
2025-10-18 16:28:03.913 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"format_skip_report\")",
        "search_method(\"collect\")",
        "search_method(\"report_generation\")",
        "search_code(\"relative path\")",
        "search_code(\"file path\")"
    ],
    "bug_locations": []
}
2025-10-18 16:28:03.965 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 16:28:03.966 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 16:28:20.164 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1756, output_tokens=670, cost=0.037660
2025-10-18 16:28:20.179 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:28:29.302 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2642, output_tokens=345, cost=0.036770
2025-10-18 16:28:29.309 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:28:37.130 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=699, output_tokens=301, cost=0.016020
2025-10-18 16:28:37.131 | DEBUG    | Extracted a valid json.
2025-10-18 16:28:37.131 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "src/_pytest/main.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely interacts with handling test collection and execution paths, including how paths are reported in console outputs. The specific location where skip reports are formatted should ensure that file paths are adjusted to reflect their relative paths from the invocation directory. If file paths are presented as absolute paths during the formatting of skip messages, a modification is needed to convert these paths to be relative based on the current directory from which pytest was invoked. This would resolve the issue by displaying paths in the skip report as the user expects, maintaining uniformity with how paths are referenced throughout pytest's output."
        },
        {
            "file": "src/_pytest/python.py",
            "class": "",
            "method": "",
            "intended_behavior": "Given the extensive role of this file in handling Python test items, including their collection and reporting, a deeper look into the methods that prepare test reports, especially skipped tests, might be required. The intended behavior here would be to ensure that when tests are skipped, and the reports are being prepared, any paths are accurately construed relative to the invocation point or adjusted accordingly if the computation of relative paths is found to be incorrect or not applied at this stage. This adjustment would correct the issue where paths are not shown as expected when tests are skipped."
        }
    ]
}
2025-10-18 16:28:37.143 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/main.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ core implementation of testing process: init, session, runtest loop. """
2 import fnmatch
3 import functools
4 import importlib
5 import os
6 import sys
7 from typing import Callable
8 from typing import Dict
9 from typing import FrozenSet
10 from typing import List
11 from typing import Optional
12 from typing import Sequence
13 from typing import Tuple
14 from typing import Union
15 
16 import attr
17 import py
18 
19 import _pytest._code
20 from _pytest import nodes
21 from _pytest.compat import TYPE_CHECKING
22 from _pytest.config import Config
23 from _pytest.config import directory_arg
24 from _pytest.config import ExitCode
25 from _pytest.config import hookimpl
26 from _pytest.config import UsageError
27 from _pytest.fixtures import FixtureManager
28 from _pytest.outcomes import exit
29 from _pytest.reports import CollectReport
30 from _pytest.runner import collect_one_node
31 from _pytest.runner import SetupState
32 
33 
34 if TYPE_CHECKING:
35     from typing import Type
36     from typing_extensions import Literal
37 
38     from _pytest.python import Package
39 
40 
41 def pytest_addoption(parser):
42     parser.addini(
43         "norecursedirs",
44         "directory patterns to avoid for recursion",
45         type="args",
46         default=[".*", "build", "dist", "CVS", "_darcs", "{arch}", "*.egg", "venv"],
47     )
48     parser.addini(
49         "testpaths",
50         "directories to search for tests when no files or directories are given in the "
51         "command line.",
52         type="args",
53         default=[],
54     )
55     group = parser.getgroup("general", "running and selection options")
56     group._addoption(
57         "-x",
58         "--exitfirst",
59         action="store_const",
60         dest="maxfail",
61         const=1,
62         help="exit instantly on first error or failed test.",
63     )
64     group._addoption(
65         "--maxfail",
66         metavar="num",
67         action="store",
68         type=int,
69         dest="maxfail",
70         default=0,
71         help="exit after first num failures or errors.",
72     )
73     group._addoption(
74         "--strict-markers",
75         "--strict",
76         action="store_true",
77         help="markers not registered in the `markers` section of the configuration file raise errors.",
78     )
79     group._addoption(
80         "-c",
81         metavar="file",
82         type=str,
83         dest="inifilename",
84         help="load configuration from `file` instead of trying to locate one of the implicit "
85         "configuration files.",
86     )
87     group._addoption(
88         "--continue-on-collection-errors",
89         action="store_true",
90         default=False,
91         dest="continue_on_collection_errors",
92         help="Force test execution even if collection errors occur.",
93     )
94     group._addoption(
95         "--rootdir",
96         action="store",
97         dest="rootdir",
98         help="Define root directory for tests. Can be relative path: 'root_dir', './root_dir', "
99         "'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: "
100         "'$HOME/root_dir'.",
101     )
102 
103     group = parser.getgroup("collect", "collection")
104     group.addoption(
105         "--collectonly",
106         "--collect-only",
107         "--co",
108         action="store_true",
109         help="only collect tests, don't execute them.",
110     )
111     group.addoption(
112         "--pyargs",
113         action="store_true",
114         help="try to interpret all arguments as python packages.",
115     )
116     group.addoption(
117         "--ignore",
118         action="append",
119         metavar="path",
120         help="ignore path during collection (multi-allowed).",
121     )
122     group.addoption(
123         "--ignore-glob",
124         action="append",
125         metavar="path",
126         help="ignore path pattern during collection (multi-allowed).",
127     )
128     group.addoption(
129         "--deselect",
130         action="append",
131         metavar="nodeid_prefix",
132         help="deselect item (via node id prefix) during collection (multi-allowed).",
133     )
134     group.addoption(
135         "--confcutdir",
136         dest="confcutdir",
137         default=None,
138         metavar="dir",
139         type=functools.partial(directory_arg, optname="--confcutdir"),
140         help="only load conftest.py's relative to specified dir.",
141     )
142     group.addoption(
143         "--noconftest",
144         action="store_true",
145         dest="noconftest",
146         default=False,
147         help="Don't load any conftest.py files.",
148     )
149     group.addoption(
150         "--keepduplicates",
151         "--keep-duplicates",
152         action="store_true",
153         dest="keepduplicates",
154         default=False,
155         help="Keep duplicate tests.",
156     )
157     group.addoption(
158         "--collect-in-virtualenv",
159         action="store_true",
160         dest="collect_in_virtualenv",
161         default=False,
162         help="Don't ignore tests in a local virtualenv directory",
163     )
164 
165     group = parser.getgroup("debugconfig", "test session debugging and configuration")
166     group.addoption(
167         "--basetemp",
168         dest="basetemp",
169         default=None,
170         metavar="dir",
171         help=(
172             "base temporary directory for this test run."
173             "(warning: this directory is removed if it exists)"
174         ),
175     )
176 
177 
178 def wrap_session(
179     config: Config, doit: Callable[[Config, "Session"], Optional[Union[int, ExitCode]]]
180 ) -> Union[int, ExitCode]:
181     """Skeleton command line program"""
182     session = Session.from_config(config)
183     session.exitstatus = ExitCode.OK
184     initstate = 0
185     try:
186         try:
187             config._do_configure()
188             initstate = 1
189             config.hook.pytest_sessionstart(session=session)
190             initstate = 2
191             session.exitstatus = doit(config, session) or 0
192         except UsageError:
193             session.exitstatus = ExitCode.USAGE_ERROR
194             raise
195         except Failed:
196             session.exitstatus = ExitCode.TESTS_FAILED
197         except (KeyboardInterrupt, exit.Exception):
198             excinfo = _pytest._code.ExceptionInfo.from_current()
199             exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]
200             if isinstance(excinfo.value, exit.Exception):
201                 if excinfo.value.returncode is not None:
202                     exitstatus = excinfo.value.returncode
203                 if initstate < 2:
204                     sys.stderr.write(
205                         "{}: {}\n".format(excinfo.typename, excinfo.value.msg)
206                     )
207             config.hook.pytest_keyboard_interrupt(excinfo=excinfo)
208             session.exitstatus = exitstatus
209         except:  # noqa
210             session.exitstatus = ExitCode.INTERNAL_ERROR
211             excinfo = _pytest._code.ExceptionInfo.from_current()
212             try:
213                 config.notify_exception(excinfo, config.option)
214             except exit.Exception as exc:
215                 if exc.returncode is not None:
216                     session.exitstatus = exc.returncode
217                 sys.stderr.write("{}: {}\n".format(type(exc).__name__, exc))
218             else:
219                 if excinfo.errisinstance(SystemExit):
220                     sys.stderr.write("mainloop: caught unexpected SystemExit!\n")
221 
222     finally:
223         # Explicitly break reference cycle.
224         excinfo = None  # type: ignore
225         session.startdir.chdir()
226         if initstate >= 2:
227             try:
228                 config.hook.pytest_sessionfinish(
229                     session=session, exitstatus=session.exitstatus
230                 )
231             except exit.Exception as exc:
232                 if exc.returncode is not None:
233                     session.exitstatus = exc.returncode
234                 sys.stderr.write("{}: {}\n".format(type(exc).__name__, exc))
235         config._ensure_unconfigure()
236     return session.exitstatus
237 
238 
239 def pytest_cmdline_main(config):
240     return wrap_session(config, _main)
241 
242 
243 def _main(config: Config, session: "Session") -> Optional[Union[int, ExitCode]]:
244     """ default command line protocol for initialization, session,
245     running tests and reporting. """
246     config.hook.pytest_collection(session=session)
247     config.hook.pytest_runtestloop(session=session)
248 
249     if session.testsfailed:
250         return ExitCode.TESTS_FAILED
251     elif session.testscollected == 0:
252         return ExitCode.NO_TESTS_COLLECTED
253     return None
254 
255 
256 def pytest_collection(session):
257     return session.perform_collect()
258 
259 
260 def pytest_runtestloop(session):
261     if session.testsfailed and not session.config.option.continue_on_collection_errors:
262         raise session.Interrupted(
263             "%d error%s during collection"
264             % (session.testsfailed, "s" if session.testsfailed != 1 else "")
265         )
266 
267     if session.config.option.collectonly:
268         return True
269 
270     for i, item in enumerate(session.items):
271         nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
272         item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)
273         if session.shouldfail:
274             raise session.Failed(session.shouldfail)
275         if session.shouldstop:
276             raise session.Interrupted(session.shouldstop)
277     return True
278 
279 
280 def _in_venv(path):
281     """Attempts to detect if ``path`` is the root of a Virtual Environment by
282     checking for the existence of the appropriate activate script"""
283     bindir = path.join("Scripts" if sys.platform.startswith("win") else "bin")
284     if not bindir.isdir():
285         return False
286     activates = (
287         "activate",
288         "activate.csh",
289         "activate.fish",
290         "Activate",
291         "Activate.bat",
292         "Activate.ps1",
293     )
294     return any([fname.basename in activates for fname in bindir.listdir()])
295 
296 
297 def pytest_ignore_collect(
298     path: py.path.local, config: Config
299 ) -> "Optional[Literal[True]]":
300     ignore_paths = config._getconftest_pathlist("collect_ignore", path=path.dirpath())
301     ignore_paths = ignore_paths or []
302     excludeopt = config.getoption("ignore")
303     if excludeopt:
304         ignore_paths.extend([py.path.local(x) for x in excludeopt])
305 
306     if py.path.local(path) in ignore_paths:
307         return True
308 
309     ignore_globs = config._getconftest_pathlist(
310         "collect_ignore_glob", path=path.dirpath()
311     )
312     ignore_globs = ignore_globs or []
313     excludeglobopt = config.getoption("ignore_glob")
314     if excludeglobopt:
315         ignore_globs.extend([py.path.local(x) for x in excludeglobopt])
316 
317     if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):
318         return True
319 
320     allow_in_venv = config.getoption("collect_in_virtualenv")
321     if not allow_in_venv and _in_venv(path):
322         return True
323     return None
324 
325 
326 def pytest_collection_modifyitems(items, config):
327     deselect_prefixes = tuple(config.getoption("deselect") or [])
328     if not deselect_prefixes:
329         return
330 
331     remaining = []
332     deselected = []
333     for colitem in items:
334         if colitem.nodeid.startswith(deselect_prefixes):
335             deselected.append(colitem)
336         else:
337             remaining.append(colitem)
338 
339     if deselected:
340         config.hook.pytest_deselected(items=deselected)
341         items[:] = remaining
342 
343 
344 class NoMatch(Exception):
345     """ raised if matching cannot locate a matching names. """
346 
347 
348 class Interrupted(KeyboardInterrupt):
349     """ signals an interrupted test run. """
350 
351     __module__ = "builtins"  # for py3
352 
353 
354 class Failed(Exception):
355     """ signals a stop as failed test run. """
356 
357 
358 @attr.s
359 class _bestrelpath_cache(dict):
360     path = attr.ib(type=py.path.local)
361 
362     def __missing__(self, path: py.path.local) -> str:
363         r = self.path.bestrelpath(path)  # type: str
364         self[path] = r
365         return r
366 
367 
368 class Session(nodes.FSCollector):
369     Interrupted = Interrupted
370     Failed = Failed
371     # Set on the session by runner.pytest_sessionstart.
372     _setupstate = None  # type: SetupState
373     # Set on the session by fixtures.pytest_sessionstart.
374     _fixturemanager = None  # type: FixtureManager
375     exitstatus = None  # type: Union[int, ExitCode]
376 
377     def __init__(self, config: Config) -> None:
378         nodes.FSCollector.__init__(
379             self, config.rootdir, parent=None, config=config, session=self, nodeid=""
380         )
381         self.testsfailed = 0
382         self.testscollected = 0
383         self.shouldstop = False
384         self.shouldfail = False
385         self.trace = config.trace.root.get("collection")
386         self.startdir = config.invocation_dir
387         self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]
388 
389         # Keep track of any collected nodes in here, so we don't duplicate fixtures
390         self._collection_node_cache1 = (
391             {}
392         )  # type: Dict[py.path.local, Sequence[nodes.Collector]]
393         self._collection_node_cache2 = (
394             {}
395         )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]
396         self._collection_node_cache3 = (
397             {}
398         )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]
399 
400         # Dirnames of pkgs with dunder-init files.
401         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]
402 
403         self._bestrelpathcache = _bestrelpath_cache(
404             config.rootdir
405         )  # type: Dict[py.path.local, str]
406 
407         self.config.pluginmanager.register(self, name="session")
408 
409     @classmethod
410     def from_config(cls, config):
411         return cls._create(config)
412 
413     def __repr__(self):
414         return "<%s %s exitstatus=%r testsfailed=%d testscollected=%d>" % (
415             self.__class__.__name__,
416             self.name,
417             getattr(self, "exitstatus", "<UNSET>"),
418             self.testsfailed,
419             self.testscollected,
420         )
421 
422     def _node_location_to_relpath(self, node_path: py.path.local) -> str:
423         # bestrelpath is a quite slow function
424         return self._bestrelpathcache[node_path]
425 
426     @hookimpl(tryfirst=True)
427     def pytest_collectstart(self):
428         if self.shouldfail:
429             raise self.Failed(self.shouldfail)
430         if self.shouldstop:
431             raise self.Interrupted(self.shouldstop)
432 
433     @hookimpl(tryfirst=True)
434     def pytest_runtest_logreport(self, report):
435         if report.failed and not hasattr(report, "wasxfail"):
436             self.testsfailed += 1
437             maxfail = self.config.getvalue("maxfail")
438             if maxfail and self.testsfailed >= maxfail:
439                 self.shouldfail = "stopping after %d failures" % (self.testsfailed)
440 
441     pytest_collectreport = pytest_runtest_logreport
442 
443     def isinitpath(self, path):
444         return path in self._initialpaths
445 
446     def gethookproxy(self, fspath: py.path.local):
447         return super()._gethookproxy(fspath)
448 
449     def perform_collect(self, args=None, genitems=True):
450         hook = self.config.hook
451         try:
452             items = self._perform_collect(args, genitems)
453             self.config.pluginmanager.check_pending()
454             hook.pytest_collection_modifyitems(
455                 session=self, config=self.config, items=items
456             )
457         finally:
458             hook.pytest_collection_finish(session=self)
459         self.testscollected = len(items)
460         return items
461 
462     def _perform_collect(self, args, genitems):
463         if args is None:
464             args = self.config.args
465         self.trace("perform_collect", self, args)
466         self.trace.root.indent += 1
467         self._notfound = []
468         initialpaths = []  # type: List[py.path.local]
469         self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]
470         self.items = items = []
471         for arg in args:
472             fspath, parts = self._parsearg(arg)
473             self._initial_parts.append((fspath, parts))
474             initialpaths.append(fspath)
475         self._initialpaths = frozenset(initialpaths)
476         rep = collect_one_node(self)
477         self.ihook.pytest_collectreport(report=rep)
478         self.trace.root.indent -= 1
479         if self._notfound:
480             errors = []
481             for arg, exc in self._notfound:
482                 line = "(no name {!r} in any of {!r})".format(arg, exc.args[0])
483                 errors.append("not found: {}\n{}".format(arg, line))
484             raise UsageError(*errors)
485         if not genitems:
486             return rep.result
487         else:
488             if rep.passed:
489                 for node in rep.result:
490                     self.items.extend(self.genitems(node))
491             return items
492 
493     def collect(self):
494         for fspath, parts in self._initial_parts:
495             self.trace("processing argument", (fspath, parts))
496             self.trace.root.indent += 1
497             try:
498                 yield from self._collect(fspath, parts)
499             except NoMatch as exc:
500                 report_arg = "::".join((str(fspath), *parts))
501                 # we are inside a make_report hook so
502                 # we cannot directly pass through the exception
503                 self._notfound.append((report_arg, exc))
504 
505             self.trace.root.indent -= 1
506         self._collection_node_cache1.clear()
507         self._collection_node_cache2.clear()
508         self._collection_node_cache3.clear()
509         self._collection_pkg_roots.clear()
510 
511     def _collect(self, argpath, names):
512         from _pytest.python import Package
513 
514         # Start with a Session root, and delve to argpath item (dir or file)
515         # and stack all Packages found on the way.
516         # No point in finding packages when collecting doctests
517         if not self.config.getoption("doctestmodules", False):
518             pm = self.config.pluginmanager
519             for parent in reversed(argpath.parts()):
520                 if pm._confcutdir and pm._confcutdir.relto(parent):
521                     break
522 
523                 if parent.isdir():
524                     pkginit = parent.join("__init__.py")
525                     if pkginit.isfile():
526                         if pkginit not in self._collection_node_cache1:
527                             col = self._collectfile(pkginit, handle_dupes=False)
528                             if col:
529                                 if isinstance(col[0], Package):
530                                     self._collection_pkg_roots[parent] = col[0]
531                                 # always store a list in the cache, matchnodes expects it
532                                 self._collection_node_cache1[col[0].fspath] = [col[0]]
533 
534         # If it's a directory argument, recurse and look for any Subpackages.
535         # Let the Package collector deal with subnodes, don't collect here.
536         if argpath.check(dir=1):
537             assert not names, "invalid arg {!r}".format((argpath, names))
538 
539             seen_dirs = set()
540             for path in argpath.visit(
541                 fil=self._visit_filter, rec=self._recurse, bf=True, sort=True
542             ):
543                 dirpath = path.dirpath()
544                 if dirpath not in seen_dirs:
545                     # Collect packages first.
546                     seen_dirs.add(dirpath)
547                     pkginit = dirpath.join("__init__.py")
548                     if pkginit.exists():
549                         for x in self._collectfile(pkginit):
550                             yield x
551                             if isinstance(x, Package):
552                                 self._collection_pkg_roots[dirpath] = x
553                 if dirpath in self._collection_pkg_roots:
554                     # Do not collect packages here.
555                     continue
556 
557                 for x in self._collectfile(path):
558                     key = (type(x), x.fspath)
559                     if key in self._collection_node_cache2:
560                         yield self._collection_node_cache2[key]
561                     else:
562                         self._collection_node_cache2[key] = x
563                         yield x
564         else:
565             assert argpath.check(file=1)
566 
567             if argpath in self._collection_node_cache1:
568                 col = self._collection_node_cache1[argpath]
569             else:
570                 collect_root = self._collection_pkg_roots.get(argpath.dirname, self)
571                 col = collect_root._collectfile(argpath, handle_dupes=False)
572                 if col:
573                     self._collection_node_cache1[argpath] = col
574             m = self.matchnodes(col, names)
575             # If __init__.py was the only file requested, then the matched node will be
576             # the corresponding Package, and the first yielded item will be the __init__
577             # Module itself, so just use that. If this special case isn't taken, then all
578             # the files in the package will be yielded.
579             if argpath.basename == "__init__.py":
580                 try:
581                     yield next(m[0].collect())
582                 except StopIteration:
583                     # The package collects nothing with only an __init__.py
584                     # file in it, which gets ignored by the default
585                     # "python_files" option.
586                     pass
587                 return
588             yield from m
589 
590     @staticmethod
591     def _visit_filter(f):
592         return f.check(file=1)
593 
594     def _tryconvertpyarg(self, x):
595         """Convert a dotted module name to path."""
596         try:
597             spec = importlib.util.find_spec(x)
598         # AttributeError: looks like package module, but actually filename
599         # ImportError: module does not exist
600         # ValueError: not a module name
601         except (AttributeError, ImportError, ValueError):
602             return x
603         if spec is None or spec.origin in {None, "namespace"}:
604             return x
605         elif spec.submodule_search_locations:
606             return os.path.dirname(spec.origin)
607         else:
608             return spec.origin
609 
610     def _parsearg(self, arg):
611         """ return (fspath, names) tuple after checking the file exists. """
612         strpath, *parts = str(arg).split("::")
613         if self.config.option.pyargs:
614             strpath = self._tryconvertpyarg(strpath)
615         relpath = strpath.replace("/", os.sep)
616         fspath = self.config.invocation_dir.join(relpath, abs=True)
617         if not fspath.check():
618             if self.config.option.pyargs:
619                 raise UsageError(
620                     "file or package not found: " + arg + " (missing __init__.py?)"
621                 )
622             raise UsageError("file not found: " + arg)
623         fspath = fspath.realpath()
624         return (fspath, parts)
625 
626     def matchnodes(self, matching, names):
627         self.trace("matchnodes", matching, names)
628         self.trace.root.indent += 1
629         nodes = self._matchnodes(matching, names)
630         num = len(nodes)
631         self.trace("matchnodes finished -> ", num, "nodes")
632         self.trace.root.indent -= 1
633         if num == 0:
634             raise NoMatch(matching, names[:1])
635         return nodes
636 
637     def _matchnodes(self, matching, names):
638         if not matching or not names:
639             return matching
640         name = names[0]
641         assert name
642         nextnames = names[1:]
643         resultnodes = []
644         for node in matching:
645             if isinstance(node, nodes.Item):
646                 if not names:
647                     resultnodes.append(node)
648                 continue
649             assert isinstance(node, nodes.Collector)
650             key = (type(node), node.nodeid)
651             if key in self._collection_node_cache3:
652                 rep = self._collection_node_cache3[key]
653             else:
654                 rep = collect_one_node(node)
655                 self._collection_node_cache3[key] = rep
656             if rep.passed:
657                 has_matched = False
658                 for x in rep.result:
659                     # TODO: remove parametrized workaround once collection structure contains parametrization
660                     if x.name == name or x.name.split("[")[0] == name:
661                         resultnodes.extend(self.matchnodes([x], nextnames))
662                         has_matched = True
663                 # XXX accept IDs that don't have "()" for class instances
664                 if not has_matched and len(rep.result) == 1 and x.name == "()":
665                     nextnames.insert(0, name)
666                     resultnodes.extend(self.matchnodes([x], nextnames))
667             else:
668                 # report collection failures here to avoid failing to run some test
669                 # specified in the command line because the module could not be
670                 # imported (#134)
671                 node.ihook.pytest_collectreport(report=rep)
672         return resultnodes
673 
674     def genitems(self, node):
675         self.trace("genitems", node)
676         if isinstance(node, nodes.Item):
677             node.ihook.pytest_itemcollected(item=node)
678             yield node
679         else:
680             assert isinstance(node, nodes.Collector)
681             rep = collect_one_node(node)
682             if rep.passed:
683                 for subnode in rep.result:
684                     yield from self.genitems(subnode)
685             node.ihook.pytest_collectreport(report=rep)

</code><intended_behavior>This file likely interacts with handling test collection and execution paths, including how paths are reported in console outputs. The specific location where skip reports are formatted should ensure that file paths are adjusted to reflect their relative paths from the invocation directory. If file paths are presented as absolute paths during the formatting of skip messages, a modification is needed to convert these paths to be relative based on the current directory from which pytest was invoked. This would resolve the issue by displaying paths in the skip report as the user expects, maintaining uniformity with how paths are referenced throughout pytest's output.</intended_behavior>, <file>src/_pytest/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Python test discovery, setup and run of test functions. """
2 import enum
3 import fnmatch
4 import inspect
5 import itertools
6 import os
7 import sys
8 import typing
9 import warnings
10 from collections import Counter
11 from collections import defaultdict
12 from collections.abc import Sequence
13 from functools import partial
14 from typing import Callable
15 from typing import Dict
16 from typing import Iterable
17 from typing import List
18 from typing import Optional
19 from typing import Tuple
20 from typing import Union
21 
22 import py
23 
24 import _pytest
25 from _pytest import fixtures
26 from _pytest import nodes
27 from _pytest._code import filter_traceback
28 from _pytest._code.code import ExceptionInfo
29 from _pytest._code.source import getfslineno
30 from _pytest._io import TerminalWriter
31 from _pytest._io.saferepr import saferepr
32 from _pytest.compat import ascii_escaped
33 from _pytest.compat import get_default_arg_names
34 from _pytest.compat import get_real_func
35 from _pytest.compat import getimfunc
36 from _pytest.compat import getlocation
37 from _pytest.compat import is_async_function
38 from _pytest.compat import is_generator
39 from _pytest.compat import NOTSET
40 from _pytest.compat import REGEX_TYPE
41 from _pytest.compat import safe_getattr
42 from _pytest.compat import safe_isclass
43 from _pytest.compat import STRING_TYPES
44 from _pytest.config import Config
45 from _pytest.config import hookimpl
46 from _pytest.deprecated import FUNCARGNAMES
47 from _pytest.fixtures import FuncFixtureInfo
48 from _pytest.mark import MARK_GEN
49 from _pytest.mark import ParameterSet
50 from _pytest.mark.structures import get_unpacked_marks
51 from _pytest.mark.structures import Mark
52 from _pytest.mark.structures import normalize_mark_list
53 from _pytest.outcomes import fail
54 from _pytest.outcomes import skip
55 from _pytest.pathlib import parts
56 from _pytest.warning_types import PytestCollectionWarning
57 from _pytest.warning_types import PytestUnhandledCoroutineWarning
58 
59 
60 def pyobj_property(name):
61     def get(self):
62         node = self.getparent(getattr(__import__("pytest"), name))
63         if node is not None:
64             return node.obj
65 
66     doc = "python {} object this node was collected from (can be None).".format(
67         name.lower()
68     )
69     return property(get, None, None, doc)
70 
71 
72 def pytest_addoption(parser):
73     group = parser.getgroup("general")
74     group.addoption(
75         "--fixtures",
76         "--funcargs",
77         action="store_true",
78         dest="showfixtures",
79         default=False,
80         help="show available fixtures, sorted by plugin appearance "
81         "(fixtures with leading '_' are only shown with '-v')",
82     )
83     group.addoption(
84         "--fixtures-per-test",
85         action="store_true",
86         dest="show_fixtures_per_test",
87         default=False,
88         help="show fixtures per test",
89     )
90     parser.addini(
91         "python_files",
92         type="args",
93         # NOTE: default is also used in AssertionRewritingHook.
94         default=["test_*.py", "*_test.py"],
95         help="glob-style file patterns for Python test module discovery",
96     )
97     parser.addini(
98         "python_classes",
99         type="args",
100         default=["Test"],
101         help="prefixes or glob names for Python test class discovery",
102     )
103     parser.addini(
104         "python_functions",
105         type="args",
106         default=["test"],
107         help="prefixes or glob names for Python test function and method discovery",
108     )
109     parser.addini(
110         "disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
111         type="bool",
112         default=False,
113         help="disable string escape non-ascii characters, might cause unwanted "
114         "side effects(use at your own risk)",
115     )
116 
117     group.addoption(
118         "--import-mode",
119         default="prepend",
120         choices=["prepend", "append"],
121         dest="importmode",
122         help="prepend/append to sys.path when importing test modules, "
123         "default is to prepend.",
124     )
125 
126 
127 def pytest_cmdline_main(config):
128     if config.option.showfixtures:
129         showfixtures(config)
130         return 0
131     if config.option.show_fixtures_per_test:
132         show_fixtures_per_test(config)
133         return 0
134 
135 
136 def pytest_generate_tests(metafunc: "Metafunc") -> None:
137     for marker in metafunc.definition.iter_markers(name="parametrize"):
138         # TODO: Fix this type-ignore (overlapping kwargs).
139         metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821
140 
141 
142 def pytest_configure(config):
143     config.addinivalue_line(
144         "markers",
145         "parametrize(argnames, argvalues): call a test function multiple "
146         "times passing in different arguments in turn. argvalues generally "
147         "needs to be a list of values if argnames specifies only one name "
148         "or a list of tuples of values if argnames specifies multiple names. "
149         "Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
150         "decorated test function, one with arg1=1 and another with arg1=2."
151         "see https://docs.pytest.org/en/latest/parametrize.html for more info "
152         "and examples.",
153     )
154     config.addinivalue_line(
155         "markers",
156         "usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
157         "all of the specified fixtures. see "
158         "https://docs.pytest.org/en/latest/fixture.html#usefixtures ",
159     )
160 
161 
162 def async_warn_and_skip(nodeid: str) -> None:
163     msg = "async def functions are not natively supported and have been skipped.\n"
164     msg += (
165         "You need to install a suitable plugin for your async framework, for example:\n"
166     )
167     msg += "  - pytest-asyncio\n"
168     msg += "  - pytest-trio\n"
169     msg += "  - pytest-tornasync\n"
170     msg += "  - pytest-twisted"
171     warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))
172     skip(msg="async def function and no async plugin installed (see warnings)")
173 
174 
175 @hookimpl(trylast=True)
176 def pytest_pyfunc_call(pyfuncitem: "Function"):
177     testfunction = pyfuncitem.obj
178     if is_async_function(testfunction):
179         async_warn_and_skip(pyfuncitem.nodeid)
180     funcargs = pyfuncitem.funcargs
181     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
182     result = testfunction(**testargs)
183     if hasattr(result, "__await__") or hasattr(result, "__aiter__"):
184         async_warn_and_skip(pyfuncitem.nodeid)
185     return True
186 
187 
188 def pytest_collect_file(path, parent):
189     ext = path.ext
190     if ext == ".py":
191         if not parent.session.isinitpath(path):
192             if not path_matches_patterns(
193                 path, parent.config.getini("python_files") + ["__init__.py"]
194             ):
195                 return
196         ihook = parent.session.gethookproxy(path)
197         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)
198 
199 
200 def path_matches_patterns(path, patterns):
201     """Returns True if the given py.path.local matches one of the patterns in the list of globs given"""
202     return any(path.fnmatch(pattern) for pattern in patterns)
203 
204 
205 def pytest_pycollect_makemodule(path, parent):
206     if path.basename == "__init__.py":
207         return Package.from_parent(parent, fspath=path)
208     return Module.from_parent(parent, fspath=path)
209 
210 
211 @hookimpl(hookwrapper=True)
212 def pytest_pycollect_makeitem(collector, name, obj):
213     outcome = yield
214     res = outcome.get_result()
215     if res is not None:
216         return
217     # nothing was collected elsewhere, let's do it here
218     if safe_isclass(obj):
219         if collector.istestclass(obj, name):
220             outcome.force_result(Class.from_parent(collector, name=name, obj=obj))
221     elif collector.istestfunction(obj, name):
222         # mock seems to store unbound methods (issue473), normalize it
223         obj = getattr(obj, "__func__", obj)
224         # We need to try and unwrap the function if it's a functools.partial
225         # or a functools.wrapped.
226         # We mustn't if it's been wrapped with mock.patch (python 2 only)
227         if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):
228             filename, lineno = getfslineno(obj)
229             warnings.warn_explicit(
230                 message=PytestCollectionWarning(
231                     "cannot collect %r because it is not a function." % name
232                 ),
233                 category=None,
234                 filename=str(filename),
235                 lineno=lineno + 1,
236             )
237         elif getattr(obj, "__test__", True):
238             if is_generator(obj):
239                 res = Function.from_parent(collector, name=name)
240                 reason = "yield tests were removed in pytest 4.0 - {name} will be ignored".format(
241                     name=name
242                 )
243                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))
244                 res.warn(PytestCollectionWarning(reason))
245             else:
246                 res = list(collector._genfunctions(name, obj))
247             outcome.force_result(res)
248 
249 
250 class PyobjMixin:
251     module = pyobj_property("Module")
252     cls = pyobj_property("Class")
253     instance = pyobj_property("Instance")
254     _ALLOW_MARKERS = True
255 
256     @property
257     def obj(self):
258         """Underlying Python object."""
259         obj = getattr(self, "_obj", None)
260         if obj is None:
261             self._obj = obj = self._getobj()
262             # XXX evil hack
263             # used to avoid Instance collector marker duplication
264             if self._ALLOW_MARKERS:
265                 self.own_markers.extend(get_unpacked_marks(self.obj))
266         return obj
267 
268     @obj.setter
269     def obj(self, value):
270         self._obj = value
271 
272     def _getobj(self):
273         """Gets the underlying Python object. May be overwritten by subclasses."""
274         return getattr(self.parent.obj, self.name)
275 
276     def getmodpath(self, stopatmodule=True, includemodule=False):
277         """ return python path relative to the containing module. """
278         chain = self.listchain()
279         chain.reverse()
280         parts = []
281         for node in chain:
282             if isinstance(node, Instance):
283                 continue
284             name = node.name
285             if isinstance(node, Module):
286                 name = os.path.splitext(name)[0]
287                 if stopatmodule:
288                     if includemodule:
289                         parts.append(name)
290                     break
291             parts.append(name)
292         parts.reverse()
293         return ".".join(parts)
294 
295     def reportinfo(self) -> Tuple[Union[py.path.local, str], int, str]:
296         # XXX caching?
297         obj = self.obj
298         compat_co_firstlineno = getattr(obj, "compat_co_firstlineno", None)
299         if isinstance(compat_co_firstlineno, int):
300             # nose compatibility
301             file_path = sys.modules[obj.__module__].__file__
302             if file_path.endswith(".pyc"):
303                 file_path = file_path[:-1]
304             fspath = file_path  # type: Union[py.path.local, str]
305             lineno = compat_co_firstlineno
306         else:
307             fspath, lineno = getfslineno(obj)
308         modpath = self.getmodpath()
309         assert isinstance(lineno, int)
310         return fspath, lineno, modpath
311 
312 
313 class PyCollector(PyobjMixin, nodes.Collector):
314     def funcnamefilter(self, name):
315         return self._matches_prefix_or_glob_option("python_functions", name)
316 
317     def isnosetest(self, obj):
318         """ Look for the __test__ attribute, which is applied by the
319         @nose.tools.istest decorator
320         """
321         # We explicitly check for "is True" here to not mistakenly treat
322         # classes with a custom __getattr__ returning something truthy (like a
323         # function) as test classes.
324         return safe_getattr(obj, "__test__", False) is True
325 
326     def classnamefilter(self, name):
327         return self._matches_prefix_or_glob_option("python_classes", name)
328 
329     def istestfunction(self, obj, name):
330         if self.funcnamefilter(name) or self.isnosetest(obj):
331             if isinstance(obj, staticmethod):
332                 # static methods need to be unwrapped
333                 obj = safe_getattr(obj, "__func__", False)
334             return (
335                 safe_getattr(obj, "__call__", False)
336                 and fixtures.getfixturemarker(obj) is None
337             )
338         else:
339             return False
340 
341     def istestclass(self, obj, name):
342         return self.classnamefilter(name) or self.isnosetest(obj)
343 
344     def _matches_prefix_or_glob_option(self, option_name, name):
345         """
346         checks if the given name matches the prefix or glob-pattern defined
347         in ini configuration.
348         """
349         for option in self.config.getini(option_name):
350             if name.startswith(option):
351                 return True
352             # check that name looks like a glob-string before calling fnmatch
353             # because this is called for every name in each collected module,
354             # and fnmatch is somewhat expensive to call
355             elif ("*" in option or "?" in option or "[" in option) and fnmatch.fnmatch(
356                 name, option
357             ):
358                 return True
359         return False
360 
361     def collect(self):
362         if not getattr(self.obj, "__test__", True):
363             return []
364 
365         # NB. we avoid random getattrs and peek in the __dict__ instead
366         # (XXX originally introduced from a PyPy need, still true?)
367         dicts = [getattr(self.obj, "__dict__", {})]
368         for basecls in inspect.getmro(self.obj.__class__):
369             dicts.append(basecls.__dict__)
370         seen = {}
371         values = []
372         for dic in dicts:
373             for name, obj in list(dic.items()):
374                 if name in seen:
375                     continue
376                 seen[name] = True
377                 res = self._makeitem(name, obj)
378                 if res is None:
379                     continue
380                 if not isinstance(res, list):
381                     res = [res]
382                 values.extend(res)
383 
384         def sort_key(item):
385             fspath, lineno, _ = item.reportinfo()
386             return (str(fspath), lineno)
387 
388         values.sort(key=sort_key)
389         return values
390 
391     def _makeitem(self, name, obj):
392         # assert self.ihook.fspath == self.fspath, self
393         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)
394 
395     def _genfunctions(self, name, funcobj):
396         module = self.getparent(Module).obj
397         clscol = self.getparent(Class)
398         cls = clscol and clscol.obj or None
399         fm = self.session._fixturemanager
400 
401         definition = FunctionDefinition.from_parent(self, name=name, callobj=funcobj)
402         fixtureinfo = definition._fixtureinfo
403 
404         metafunc = Metafunc(
405             definition, fixtureinfo, self.config, cls=cls, module=module
406         )
407         methods = []
408         if hasattr(module, "pytest_generate_tests"):
409             methods.append(module.pytest_generate_tests)
410         if hasattr(cls, "pytest_generate_tests"):
411             methods.append(cls().pytest_generate_tests)
412 
413         self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))
414 
415         if not metafunc._calls:
416             yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)
417         else:
418             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs
419             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)
420 
421             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures
422             # with direct parametrization, so make sure we update what the
423             # function really needs.
424             fixtureinfo.prune_dependency_tree()
425 
426             for callspec in metafunc._calls:
427                 subname = "{}[{}]".format(name, callspec.id)
428                 yield Function.from_parent(
429                     self,
430                     name=subname,
431                     callspec=callspec,
432                     callobj=funcobj,
433                     fixtureinfo=fixtureinfo,
434                     keywords={callspec.id: True},
435                     originalname=name,
436                 )
437 
438 
439 class Module(nodes.File, PyCollector):
440     """ Collector for test classes and functions. """
441 
442     def _getobj(self):
443         return self._importtestmodule()
444 
445     def collect(self):
446         self._inject_setup_module_fixture()
447         self._inject_setup_function_fixture()
448         self.session._fixturemanager.parsefactories(self)
449         return super().collect()
450 
451     def _inject_setup_module_fixture(self):
452         """Injects a hidden autouse, module scoped fixture into the collected module object
453         that invokes setUpModule/tearDownModule if either or both are available.
454 
455         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
456         other fixtures (#517).
457         """
458         setup_module = _get_first_non_fixture_func(
459             self.obj, ("setUpModule", "setup_module")
460         )
461         teardown_module = _get_first_non_fixture_func(
462             self.obj, ("tearDownModule", "teardown_module")
463         )
464 
465         if setup_module is None and teardown_module is None:
466             return
467 
468         @fixtures.fixture(autouse=True, scope="module")
469         def xunit_setup_module_fixture(request):
470             if setup_module is not None:
471                 _call_with_optional_argument(setup_module, request.module)
472             yield
473             if teardown_module is not None:
474                 _call_with_optional_argument(teardown_module, request.module)
475 
476         self.obj.__pytest_setup_module = xunit_setup_module_fixture
477 
478     def _inject_setup_function_fixture(self):
479         """Injects a hidden autouse, function scoped fixture into the collected module object
480         that invokes setup_function/teardown_function if either or both are available.
481 
482         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
483         other fixtures (#517).
484         """
485         setup_function = _get_first_non_fixture_func(self.obj, ("setup_function",))
486         teardown_function = _get_first_non_fixture_func(
487             self.obj, ("teardown_function",)
488         )
489         if setup_function is None and teardown_function is None:
490             return
491 
492         @fixtures.fixture(autouse=True, scope="function")
493         def xunit_setup_function_fixture(request):
494             if request.instance is not None:
495                 # in this case we are bound to an instance, so we need to let
496                 # setup_method handle this
497                 yield
498                 return
499             if setup_function is not None:
500                 _call_with_optional_argument(setup_function, request.function)
501             yield
502             if teardown_function is not None:
503                 _call_with_optional_argument(teardown_function, request.function)
504 
505         self.obj.__pytest_setup_function = xunit_setup_function_fixture
506 
507     def _importtestmodule(self):
508         # we assume we are only called once per module
509         importmode = self.config.getoption("--import-mode")
510         try:
511             mod = self.fspath.pyimport(ensuresyspath=importmode)
512         except SyntaxError:
513             raise self.CollectError(ExceptionInfo.from_current().getrepr(style="short"))
514         except self.fspath.ImportMismatchError as e:
515             raise self.CollectError(
516                 "import file mismatch:\n"
517                 "imported module %r has this __file__ attribute:\n"
518                 "  %s\n"
519                 "which is not the same as the test file we want to collect:\n"
520                 "  %s\n"
521                 "HINT: remove __pycache__ / .pyc files and/or use a "
522                 "unique basename for your test file modules" % e.args
523             )
524         except ImportError:
525             exc_info = ExceptionInfo.from_current()
526             if self.config.getoption("verbose") < 2:
527                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)
528             exc_repr = (
529                 exc_info.getrepr(style="short")
530                 if exc_info.traceback
531                 else exc_info.exconly()
532             )
533             formatted_tb = str(exc_repr)
534             raise self.CollectError(
535                 "ImportError while importing test module '{fspath}'.\n"
536                 "Hint: make sure your test modules/packages have valid Python names.\n"
537                 "Traceback:\n"
538                 "{traceback}".format(fspath=self.fspath, traceback=formatted_tb)
539             )
540         except _pytest.runner.Skipped as e:
541             if e.allow_module_level:
542                 raise
543             raise self.CollectError(
544                 "Using pytest.skip outside of a test is not allowed. "
545                 "To decorate a test function, use the @pytest.mark.skip "
546                 "or @pytest.mark.skipif decorators instead, and to skip a "
547                 "module use `pytestmark = pytest.mark.{skip,skipif}."
548             )
549         self.config.pluginmanager.consider_module(mod)
550         return mod
551 
552 
553 class Package(Module):
554     def __init__(
555         self,
556         fspath: py.path.local,
557         parent: nodes.Collector,
558         # NOTE: following args are unused:
559         config=None,
560         session=None,
561         nodeid=None,
562     ) -> None:
563         # NOTE: could be just the following, but kept as-is for compat.
564         # nodes.FSCollector.__init__(self, fspath, parent=parent)
565         session = parent.session
566         nodes.FSCollector.__init__(
567             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid
568         )
569 
570         self.name = fspath.dirname
571 
572     def setup(self):
573         # not using fixtures to call setup_module here because autouse fixtures
574         # from packages are not called automatically (#4085)
575         setup_module = _get_first_non_fixture_func(
576             self.obj, ("setUpModule", "setup_module")
577         )
578         if setup_module is not None:
579             _call_with_optional_argument(setup_module, self.obj)
580 
581         teardown_module = _get_first_non_fixture_func(
582             self.obj, ("tearDownModule", "teardown_module")
583         )
584         if teardown_module is not None:
585             func = partial(_call_with_optional_argument, teardown_module, self.obj)
586             self.addfinalizer(func)
587 
588     def gethookproxy(self, fspath: py.path.local):
589         return super()._gethookproxy(fspath)
590 
591     def isinitpath(self, path):
592         return path in self.session._initialpaths
593 
594     def collect(self):
595         this_path = self.fspath.dirpath()
596         init_module = this_path.join("__init__.py")
597         if init_module.check(file=1) and path_matches_patterns(
598             init_module, self.config.getini("python_files")
599         ):
600             yield Module.from_parent(self, fspath=init_module)
601         pkg_prefixes = set()
602         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):
603             # We will visit our own __init__.py file, in which case we skip it.
604             is_file = path.isfile()
605             if is_file:
606                 if path.basename == "__init__.py" and path.dirpath() == this_path:
607                     continue
608 
609             parts_ = parts(path.strpath)
610             if any(
611                 pkg_prefix in parts_ and pkg_prefix.join("__init__.py") != path
612                 for pkg_prefix in pkg_prefixes
613             ):
614                 continue
615 
616             if is_file:
617                 yield from self._collectfile(path)
618             elif not path.isdir():
619                 # Broken symlink or invalid/missing file.
620                 continue
621             elif path.join("__init__.py").check(file=1):
622                 pkg_prefixes.add(path)
623 
624 
625 def _call_with_optional_argument(func, arg):
626     """Call the given function with the given argument if func accepts one argument, otherwise
627     calls func without arguments"""
628     arg_count = func.__code__.co_argcount
629     if inspect.ismethod(func):
630         arg_count -= 1
631     if arg_count:
632         func(arg)
633     else:
634         func()
635 
636 
637 def _get_first_non_fixture_func(obj, names):
638     """Return the attribute from the given object to be used as a setup/teardown
639     xunit-style function, but only if not marked as a fixture to
640     avoid calling it twice.
641     """
642     for name in names:
643         meth = getattr(obj, name, None)
644         if meth is not None and fixtures.getfixturemarker(meth) is None:
645             return meth
646 
647 
648 class Class(PyCollector):
649     """ Collector for test methods. """
650 
651     @classmethod
652     def from_parent(cls, parent, *, name, obj=None):
653         """
654         The public constructor
655         """
656         return super().from_parent(name=name, parent=parent)
657 
658     def collect(self):
659         if not safe_getattr(self.obj, "__test__", True):
660             return []
661         if hasinit(self.obj):
662             self.warn(
663                 PytestCollectionWarning(
664                     "cannot collect test class %r because it has a "
665                     "__init__ constructor (from: %s)"
666                     % (self.obj.__name__, self.parent.nodeid)
667                 )
668             )
669             return []
670         elif hasnew(self.obj):
671             self.warn(
672                 PytestCollectionWarning(
673                     "cannot collect test class %r because it has a "
674                     "__new__ constructor (from: %s)"
675                     % (self.obj.__name__, self.parent.nodeid)
676                 )
677             )
678             return []
679 
680         self._inject_setup_class_fixture()
681         self._inject_setup_method_fixture()
682 
683         return [Instance.from_parent(self, name="()")]
684 
685     def _inject_setup_class_fixture(self):
686         """Injects a hidden autouse, class scoped fixture into the collected class object
687         that invokes setup_class/teardown_class if either or both are available.
688 
689         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
690         other fixtures (#517).
691         """
692         setup_class = _get_first_non_fixture_func(self.obj, ("setup_class",))
693         teardown_class = getattr(self.obj, "teardown_class", None)
694         if setup_class is None and teardown_class is None:
695             return
696 
697         @fixtures.fixture(autouse=True, scope="class")
698         def xunit_setup_class_fixture(cls):
699             if setup_class is not None:
700                 func = getimfunc(setup_class)
701                 _call_with_optional_argument(func, self.obj)
702             yield
703             if teardown_class is not None:
704                 func = getimfunc(teardown_class)
705                 _call_with_optional_argument(func, self.obj)
706 
707         self.obj.__pytest_setup_class = xunit_setup_class_fixture
708 
709     def _inject_setup_method_fixture(self):
710         """Injects a hidden autouse, function scoped fixture into the collected class object
711         that invokes setup_method/teardown_method if either or both are available.
712 
713         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
714         other fixtures (#517).
715         """
716         setup_method = _get_first_non_fixture_func(self.obj, ("setup_method",))
717         teardown_method = getattr(self.obj, "teardown_method", None)
718         if setup_method is None and teardown_method is None:
719             return
720 
721         @fixtures.fixture(autouse=True, scope="function")
722         def xunit_setup_method_fixture(self, request):
723             method = request.function
724             if setup_method is not None:
725                 func = getattr(self, "setup_method")
726                 _call_with_optional_argument(func, method)
727             yield
728             if teardown_method is not None:
729                 func = getattr(self, "teardown_method")
730                 _call_with_optional_argument(func, method)
731 
732         self.obj.__pytest_setup_method = xunit_setup_method_fixture
733 
734 
735 class Instance(PyCollector):
736     _ALLOW_MARKERS = False  # hack, destroy later
737     # instances share the object with their parents in a way
738     # that duplicates markers instances if not taken out
739     # can be removed at node structure reorganization time
740 
741     def _getobj(self):
742         return self.parent.obj()
743 
744     def collect(self):
745         self.session._fixturemanager.parsefactories(self)
746         return super().collect()
747 
748     def newinstance(self):
749         self.obj = self._getobj()
750         return self.obj
751 
752 
753 def hasinit(obj):
754     init = getattr(obj, "__init__", None)
755     if init:
756         return init != object.__init__
757 
758 
759 def hasnew(obj):
760     new = getattr(obj, "__new__", None)
761     if new:
762         return new != object.__new__
763 
764 
765 class CallSpec2:
766     def __init__(self, metafunc):
767         self.metafunc = metafunc
768         self.funcargs = {}
769         self._idlist = []
770         self.params = {}
771         self._arg2scopenum = {}  # used for sorting parametrized resources
772         self.marks = []
773         self.indices = {}
774 
775     def copy(self):
776         cs = CallSpec2(self.metafunc)
777         cs.funcargs.update(self.funcargs)
778         cs.params.update(self.params)
779         cs.marks.extend(self.marks)
780         cs.indices.update(self.indices)
781         cs._arg2scopenum.update(self._arg2scopenum)
782         cs._idlist = list(self._idlist)
783         return cs
784 
785     def _checkargnotcontained(self, arg):
786         if arg in self.params or arg in self.funcargs:
787             raise ValueError("duplicate {!r}".format(arg))
788 
789     def getparam(self, name):
790         try:
791             return self.params[name]
792         except KeyError:
793             raise ValueError(name)
794 
795     @property
796     def id(self):
797         return "-".join(map(str, self._idlist))
798 
799     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):
800         for arg, val in zip(argnames, valset):
801             self._checkargnotcontained(arg)
802             valtype_for_arg = valtypes[arg]
803             getattr(self, valtype_for_arg)[arg] = val
804             self.indices[arg] = param_index
805             self._arg2scopenum[arg] = scopenum
806         self._idlist.append(id)
807         self.marks.extend(normalize_mark_list(marks))
808 
809 
810 class Metafunc:
811     """
812     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.
813     They help to inspect a test function and to generate tests according to
814     test configuration or values specified in the class or module where a
815     test function is defined.
816     """
817 
818     def __init__(
819         self,
820         definition: "FunctionDefinition",
821         fixtureinfo: fixtures.FuncFixtureInfo,
822         config: Config,
823         cls=None,
824         module=None,
825     ) -> None:
826         self.definition = definition
827 
828         #: access to the :class:`_pytest.config.Config` object for the test session
829         self.config = config
830 
831         #: the module object where the test function is defined in.
832         self.module = module
833 
834         #: underlying python test function
835         self.function = definition.obj
836 
837         #: set of fixture names required by the test function
838         self.fixturenames = fixtureinfo.names_closure
839 
840         #: class object where the test function is defined in or ``None``.
841         self.cls = cls
842 
843         self._calls = []  # type: List[CallSpec2]
844         self._arg2fixturedefs = fixtureinfo.name2fixturedefs
845 
846     @property
847     def funcargnames(self):
848         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
849         warnings.warn(FUNCARGNAMES, stacklevel=2)
850         return self.fixturenames
851 
852     def parametrize(
853         self,
854         argnames: Union[str, List[str], Tuple[str, ...]],
855         argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],
856         indirect: Union[bool, typing.Sequence[str]] = False,
857         ids: Optional[
858             Union[
859                 Iterable[Union[None, str, float, int, bool]],
860                 Callable[[object], Optional[object]],
861             ]
862         ] = None,
863         scope: "Optional[str]" = None,
864         *,
865         _param_mark: Optional[Mark] = None
866     ) -> None:
867         """ Add new invocations to the underlying test function using the list
868         of argvalues for the given argnames.  Parametrization is performed
869         during the collection phase.  If you need to setup expensive resources
870         see about setting indirect to do it rather at test setup time.
871 
872         :arg argnames: a comma-separated string denoting one or more argument
873                        names, or a list/tuple of argument strings.
874 
875         :arg argvalues: The list of argvalues determines how often a
876             test is invoked with different argument values.  If only one
877             argname was specified argvalues is a list of values.  If N
878             argnames were specified, argvalues must be a list of N-tuples,
879             where each tuple-element specifies a value for its respective
880             argname.
881 
882         :arg indirect: The list of argnames or boolean. A list of arguments'
883             names (subset of argnames). If True the list contains all names from
884             the argnames. Each argvalue corresponding to an argname in this list will
885             be passed as request.param to its respective argname fixture
886             function so that it can perform more expensive setups during the
887             setup phase of a test rather than at collection time.
888 
889         :arg ids: sequence of (or generator for) ids for ``argvalues``,
890               or a callable to return part of the id for each argvalue.
891 
892             With sequences (and generators like ``itertools.count()``) the
893             returned ids should be of type ``string``, ``int``, ``float``,
894             ``bool``, or ``None``.
895             They are mapped to the corresponding index in ``argvalues``.
896             ``None`` means to use the auto-generated id.
897 
898             If it is a callable it will be called for each entry in
899             ``argvalues``, and the return value is used as part of the
900             auto-generated id for the whole set (where parts are joined with
901             dashes ("-")).
902             This is useful to provide more specific ids for certain items, e.g.
903             dates.  Returning ``None`` will use an auto-generated id.
904 
905             If no ids are provided they will be generated automatically from
906             the argvalues.
907 
908         :arg scope: if specified it denotes the scope of the parameters.
909             The scope is used for grouping tests by parameter instances.
910             It will also override any fixture-function defined scope, allowing
911             to set a dynamic scope using test context or configuration.
912         """
913         from _pytest.fixtures import scope2index
914 
915         argnames, parameters = ParameterSet._for_parametrize(
916             argnames,
917             argvalues,
918             self.function,
919             self.config,
920             function_definition=self.definition,
921         )
922         del argvalues
923 
924         if "request" in argnames:
925             fail(
926                 "'request' is a reserved name and cannot be used in @pytest.mark.parametrize",
927                 pytrace=False,
928             )
929 
930         if scope is None:
931             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)
932 
933         self._validate_if_using_arg_names(argnames, indirect)
934 
935         arg_values_types = self._resolve_arg_value_types(argnames, indirect)
936 
937         self._validate_explicit_parameters(argnames, indirect)
938 
939         # Use any already (possibly) generated ids with parametrize Marks.
940         if _param_mark and _param_mark._param_ids_from:
941             generated_ids = _param_mark._param_ids_from._param_ids_generated
942             if generated_ids is not None:
943                 ids = generated_ids
944 
945         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)
946 
947         # Store used (possibly generated) ids with parametrize Marks.
948         if _param_mark and _param_mark._param_ids_from and generated_ids is None:
949             object.__setattr__(_param_mark._param_ids_from, "_param_ids_generated", ids)
950 
951         scopenum = scope2index(
952             scope, descr="parametrize() call in {}".format(self.function.__name__)
953         )
954 
955         # create the new calls: if we are parametrize() multiple times (by applying the decorator
956         # more than once) then we accumulate those calls generating the cartesian product
957         # of all calls
958         newcalls = []
959         for callspec in self._calls or [CallSpec2(self)]:
960             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):
961                 newcallspec = callspec.copy()
962                 newcallspec.setmulti2(
963                     arg_values_types,
964                     argnames,
965                     param_set.values,
966                     param_id,
967                     param_set.marks,
968                     scopenum,
969                     param_index,
970                 )
971                 newcalls.append(newcallspec)
972         self._calls = newcalls
973 
974     def _resolve_arg_ids(
975         self,
976         argnames: typing.Sequence[str],
977         ids: Optional[
978             Union[
979                 Iterable[Union[None, str, float, int, bool]],
980                 Callable[[object], Optional[object]],
981             ]
982         ],
983         parameters: typing.Sequence[ParameterSet],
984         item,
985     ) -> List[str]:
986         """Resolves the actual ids for the given argnames, based on the ``ids`` parameter given
987         to ``parametrize``.
988 
989         :param List[str] argnames: list of argument names passed to ``parametrize()``.
990         :param ids: the ids parameter of the parametrized call (see docs).
991         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.
992         :param Item item: the item that generated this parametrized call.
993         :rtype: List[str]
994         :return: the list of ids for each argname given
995         """
996         if ids is None:
997             idfn = None
998             ids_ = None
999         elif callable(ids):
1000             idfn = ids
1001             ids_ = None
1002         else:
1003             idfn = None
1004             ids_ = self._validate_ids(ids, parameters, self.function.__name__)
1005         return idmaker(argnames, parameters, idfn, ids_, self.config, item=item)
1006 
1007     def _validate_ids(
1008         self,
1009         ids: Iterable[Union[None, str, float, int, bool]],
1010         parameters: typing.Sequence[ParameterSet],
1011         func_name: str,
1012     ) -> List[Union[None, str]]:
1013         try:
1014             num_ids = len(ids)  # type: ignore[arg-type] # noqa: F821
1015         except TypeError:
1016             try:
1017                 iter(ids)
1018             except TypeError:
1019                 raise TypeError("ids must be a callable or an iterable")
1020             num_ids = len(parameters)
1021 
1022         # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849
1023         if num_ids != len(parameters) and num_ids != 0:
1024             msg = "In {}: {} parameter sets specified, with different number of ids: {}"
1025             fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)
1026 
1027         new_ids = []
1028         for idx, id_value in enumerate(itertools.islice(ids, num_ids)):
1029             if id_value is None or isinstance(id_value, str):
1030                 new_ids.append(id_value)
1031             elif isinstance(id_value, (float, int, bool)):
1032                 new_ids.append(str(id_value))
1033             else:
1034                 msg = "In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}"
1035                 fail(
1036                     msg.format(func_name, saferepr(id_value), type(id_value), idx),
1037                     pytrace=False,
1038                 )
1039         return new_ids
1040 
1041     def _resolve_arg_value_types(
1042         self,
1043         argnames: typing.Sequence[str],
1044         indirect: Union[bool, typing.Sequence[str]],
1045     ) -> Dict[str, str]:
1046         """Resolves if each parametrized argument must be considered a parameter to a fixture or a "funcarg"
1047         to the function, based on the ``indirect`` parameter of the parametrized() call.
1048 
1049         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1050         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1051         :rtype: Dict[str, str]
1052             A dict mapping each arg name to either:
1053             * "params" if the argname should be the parameter of a fixture of the same name.
1054             * "funcargs" if the argname should be a parameter to the parametrized test function.
1055         """
1056         if isinstance(indirect, bool):
1057             valtypes = dict.fromkeys(argnames, "params" if indirect else "funcargs")
1058         elif isinstance(indirect, Sequence):
1059             valtypes = dict.fromkeys(argnames, "funcargs")
1060             for arg in indirect:
1061                 if arg not in argnames:
1062                     fail(
1063                         "In {}: indirect fixture '{}' doesn't exist".format(
1064                             self.function.__name__, arg
1065                         ),
1066                         pytrace=False,
1067                     )
1068                 valtypes[arg] = "params"
1069         else:
1070             fail(
1071                 "In {func}: expected Sequence or boolean for indirect, got {type}".format(
1072                     type=type(indirect).__name__, func=self.function.__name__
1073                 ),
1074                 pytrace=False,
1075             )
1076         return valtypes
1077 
1078     def _validate_if_using_arg_names(
1079         self,
1080         argnames: typing.Sequence[str],
1081         indirect: Union[bool, typing.Sequence[str]],
1082     ) -> None:
1083         """
1084         Check if all argnames are being used, by default values, or directly/indirectly.
1085 
1086         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1087         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1088         :raise ValueError: if validation fails.
1089         """
1090         default_arg_names = set(get_default_arg_names(self.function))
1091         func_name = self.function.__name__
1092         for arg in argnames:
1093             if arg not in self.fixturenames:
1094                 if arg in default_arg_names:
1095                     fail(
1096                         "In {}: function already takes an argument '{}' with a default value".format(
1097                             func_name, arg
1098                         ),
1099                         pytrace=False,
1100                     )
1101                 else:
1102                     if isinstance(indirect, Sequence):
1103                         name = "fixture" if arg in indirect else "argument"
1104                     else:
1105                         name = "fixture" if indirect else "argument"
1106                     fail(
1107                         "In {}: function uses no {} '{}'".format(func_name, name, arg),
1108                         pytrace=False,
1109                     )
1110 
1111     def _validate_explicit_parameters(
1112         self,
1113         argnames: typing.Sequence[str],
1114         indirect: Union[bool, typing.Sequence[str]],
1115     ) -> None:
1116         """
1117         The argnames in *parametrize* should either be declared explicitly via
1118         indirect list or in the function signature
1119 
1120         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1121         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1122         :raise ValueError: if validation fails
1123         """
1124         if isinstance(indirect, bool):
1125             parametrized_argnames = [] if indirect else argnames
1126         else:
1127             parametrized_argnames = [arg for arg in argnames if arg not in indirect]
1128 
1129         if not parametrized_argnames:
1130             return
1131 
1132         funcargnames = _pytest.compat.getfuncargnames(self.function)
1133         usefixtures = fixtures.get_use_fixtures_for_node(self.definition)
1134 
1135         for arg in parametrized_argnames:
1136             if arg not in funcargnames and arg not in usefixtures:
1137                 func_name = self.function.__name__
1138                 msg = (
1139                     'In function "{func_name}":\n'
1140                     'Parameter "{arg}" should be declared explicitly via indirect or in function itself'
1141                 ).format(func_name=func_name, arg=arg)
1142                 fail(msg, pytrace=False)
1143 
1144 
1145 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):
1146     """Find the most appropriate scope for a parametrized call based on its arguments.
1147 
1148     When there's at least one direct argument, always use "function" scope.
1149 
1150     When a test function is parametrized and all its arguments are indirect
1151     (e.g. fixtures), return the most narrow scope based on the fixtures used.
1152 
1153     Related to issue #1832, based on code posted by @Kingdread.
1154     """
1155     from _pytest.fixtures import scopes
1156 
1157     if isinstance(indirect, (list, tuple)):
1158         all_arguments_are_fixtures = len(indirect) == len(argnames)
1159     else:
1160         all_arguments_are_fixtures = bool(indirect)
1161 
1162     if all_arguments_are_fixtures:
1163         fixturedefs = arg2fixturedefs or {}
1164         used_scopes = [
1165             fixturedef[0].scope
1166             for name, fixturedef in fixturedefs.items()
1167             if name in argnames
1168         ]
1169         if used_scopes:
1170             # Takes the most narrow scope from used fixtures
1171             for scope in reversed(scopes):
1172                 if scope in used_scopes:
1173                     return scope
1174 
1175     return "function"
1176 
1177 
1178 def _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:
1179     if config is None:
1180         escape_option = False
1181     else:
1182         escape_option = config.getini(
1183             "disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
1184         )
1185     # TODO: If escaping is turned off and the user passes bytes,
1186     #       will return a bytes. For now we ignore this but the
1187     #       code *probably* doesn't handle this case.
1188     return val if escape_option else ascii_escaped(val)  # type: ignore
1189 
1190 
1191 def _idval(
1192     val: object,
1193     argname: str,
1194     idx: int,
1195     idfn: Optional[Callable[[object], Optional[object]]],
1196     item,
1197     config: Optional[Config],
1198 ) -> str:
1199     if idfn:
1200         try:
1201             generated_id = idfn(val)
1202             if generated_id is not None:
1203                 val = generated_id
1204         except Exception as e:
1205             msg = "{}: error raised while trying to determine id of parameter '{}' at position {}"
1206             msg = msg.format(item.nodeid, argname, idx)
1207             raise ValueError(msg) from e
1208     elif config:
1209         hook_id = config.hook.pytest_make_parametrize_id(
1210             config=config, val=val, argname=argname
1211         )  # type: Optional[str]
1212         if hook_id:
1213             return hook_id
1214 
1215     if isinstance(val, STRING_TYPES):
1216         return _ascii_escaped_by_config(val, config)
1217     elif val is None or isinstance(val, (float, int, bool)):
1218         return str(val)
1219     elif isinstance(val, REGEX_TYPE):
1220         return ascii_escaped(val.pattern)
1221     elif isinstance(val, enum.Enum):
1222         return str(val)
1223     elif isinstance(getattr(val, "__name__", None), str):
1224         # name of a class, function, module, etc.
1225         name = getattr(val, "__name__")  # type: str
1226         return name
1227     return str(argname) + str(idx)
1228 
1229 
1230 def _idvalset(
1231     idx: int,
1232     parameterset: ParameterSet,
1233     argnames: Iterable[str],
1234     idfn: Optional[Callable[[object], Optional[object]]],
1235     ids: Optional[List[Union[None, str]]],
1236     item,
1237     config: Optional[Config],
1238 ):
1239     if parameterset.id is not None:
1240         return parameterset.id
1241     id = None if ids is None or idx >= len(ids) else ids[idx]
1242     if id is None:
1243         this_id = [
1244             _idval(val, argname, idx, idfn, item=item, config=config)
1245             for val, argname in zip(parameterset.values, argnames)
1246         ]
1247         return "-".join(this_id)
1248     else:
1249         return _ascii_escaped_by_config(id, config)
1250 
1251 
1252 def idmaker(
1253     argnames: Iterable[str],
1254     parametersets: Iterable[ParameterSet],
1255     idfn: Optional[Callable[[object], Optional[object]]] = None,
1256     ids: Optional[List[Union[None, str]]] = None,
1257     config: Optional[Config] = None,
1258     item=None,
1259 ) -> List[str]:
1260     resolved_ids = [
1261         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)
1262         for valindex, parameterset in enumerate(parametersets)
1263     ]
1264 
1265     # All IDs must be unique!
1266     unique_ids = set(resolved_ids)
1267     if len(unique_ids) != len(resolved_ids):
1268 
1269         # Record the number of occurrences of each test ID
1270         test_id_counts = Counter(resolved_ids)
1271 
1272         # Map the test ID to its next suffix
1273         test_id_suffixes = defaultdict(int)  # type: Dict[str, int]
1274 
1275         # Suffix non-unique IDs to make them unique
1276         for index, test_id in enumerate(resolved_ids):
1277             if test_id_counts[test_id] > 1:
1278                 resolved_ids[index] = "{}{}".format(test_id, test_id_suffixes[test_id])
1279                 test_id_suffixes[test_id] += 1
1280 
1281     return resolved_ids
1282 
1283 
1284 def show_fixtures_per_test(config):
1285     from _pytest.main import wrap_session
1286 
1287     return wrap_session(config, _show_fixtures_per_test)
1288 
1289 
1290 def _show_fixtures_per_test(config, session):
1291     import _pytest.config
1292 
1293     session.perform_collect()
1294     curdir = py.path.local()
1295     tw = _pytest.config.create_terminal_writer(config)
1296     verbose = config.getvalue("verbose")
1297 
1298     def get_best_relpath(func):
1299         loc = getlocation(func, curdir)
1300         return curdir.bestrelpath(loc)
1301 
1302     def write_fixture(fixture_def):
1303         argname = fixture_def.argname
1304         if verbose <= 0 and argname.startswith("_"):
1305             return
1306         if verbose > 0:
1307             bestrel = get_best_relpath(fixture_def.func)
1308             funcargspec = "{} -- {}".format(argname, bestrel)
1309         else:
1310             funcargspec = argname
1311         tw.line(funcargspec, green=True)
1312         fixture_doc = inspect.getdoc(fixture_def.func)
1313         if fixture_doc:
1314             write_docstring(tw, fixture_doc)
1315         else:
1316             tw.line("    no docstring available", red=True)
1317 
1318     def write_item(item):
1319         try:
1320             info = item._fixtureinfo
1321         except AttributeError:
1322             # doctests items have no _fixtureinfo attribute
1323             return
1324         if not info.name2fixturedefs:
1325             # this test item does not use any fixtures
1326             return
1327         tw.line()
1328         tw.sep("-", "fixtures used by {}".format(item.name))
1329         tw.sep("-", "({})".format(get_best_relpath(item.function)))
1330         # dict key not used in loop but needed for sorting
1331         for _, fixturedefs in sorted(info.name2fixturedefs.items()):
1332             assert fixturedefs is not None
1333             if not fixturedefs:
1334                 continue
1335             # last item is expected to be the one used by the test item
1336             write_fixture(fixturedefs[-1])
1337 
1338     for session_item in session.items:
1339         write_item(session_item)
1340 
1341 
1342 def showfixtures(config):
1343     from _pytest.main import wrap_session
1344 
1345     return wrap_session(config, _showfixtures_main)
1346 
1347 
1348 def _showfixtures_main(config, session):
1349     import _pytest.config
1350 
1351     session.perform_collect()
1352     curdir = py.path.local()
1353     tw = _pytest.config.create_terminal_writer(config)
1354     verbose = config.getvalue("verbose")
1355 
1356     fm = session._fixturemanager
1357 
1358     available = []
1359     seen = set()
1360 
1361     for argname, fixturedefs in fm._arg2fixturedefs.items():
1362         assert fixturedefs is not None
1363         if not fixturedefs:
1364             continue
1365         for fixturedef in fixturedefs:
1366             loc = getlocation(fixturedef.func, curdir)
1367             if (fixturedef.argname, loc) in seen:
1368                 continue
1369             seen.add((fixturedef.argname, loc))
1370             available.append(
1371                 (
1372                     len(fixturedef.baseid),
1373                     fixturedef.func.__module__,
1374                     curdir.bestrelpath(loc),
1375                     fixturedef.argname,
1376                     fixturedef,
1377                 )
1378             )
1379 
1380     available.sort()
1381     currentmodule = None
1382     for baseid, module, bestrel, argname, fixturedef in available:
1383         if currentmodule != module:
1384             if not module.startswith("_pytest."):
1385                 tw.line()
1386                 tw.sep("-", "fixtures defined from {}".format(module))
1387                 currentmodule = module
1388         if verbose <= 0 and argname[0] == "_":
1389             continue
1390         tw.write(argname, green=True)
1391         if fixturedef.scope != "function":
1392             tw.write(" [%s scope]" % fixturedef.scope, cyan=True)
1393         if verbose > 0:
1394             tw.write(" -- %s" % bestrel, yellow=True)
1395         tw.write("\n")
1396         loc = getlocation(fixturedef.func, curdir)
1397         doc = inspect.getdoc(fixturedef.func)
1398         if doc:
1399             write_docstring(tw, doc)
1400         else:
1401             tw.line("    {}: no docstring available".format(loc), red=True)
1402         tw.line()
1403 
1404 
1405 def write_docstring(tw: TerminalWriter, doc: str, indent: str = "    ") -> None:
1406     for line in doc.split("\n"):
1407         tw.write(indent + line + "\n")
1408 
1409 
1410 class Function(PyobjMixin, nodes.Item):
1411     """ a Function Item is responsible for setting up and executing a
1412     Python test function.
1413     """
1414 
1415     # disable since functions handle it themselves
1416     _ALLOW_MARKERS = False
1417 
1418     def __init__(
1419         self,
1420         name,
1421         parent,
1422         args=None,
1423         config=None,
1424         callspec: Optional[CallSpec2] = None,
1425         callobj=NOTSET,
1426         keywords=None,
1427         session=None,
1428         fixtureinfo: Optional[FuncFixtureInfo] = None,
1429         originalname=None,
1430     ) -> None:
1431         super().__init__(name, parent, config=config, session=session)
1432         self._args = args
1433         if callobj is not NOTSET:
1434             self.obj = callobj
1435 
1436         self.keywords.update(self.obj.__dict__)
1437         self.own_markers.extend(get_unpacked_marks(self.obj))
1438         if callspec:
1439             self.callspec = callspec
1440             # this is total hostile and a mess
1441             # keywords are broken by design by now
1442             # this will be redeemed later
1443             for mark in callspec.marks:
1444                 # feel free to cry, this was broken for years before
1445                 # and keywords cant fix it per design
1446                 self.keywords[mark.name] = mark
1447             self.own_markers.extend(normalize_mark_list(callspec.marks))
1448         if keywords:
1449             self.keywords.update(keywords)
1450 
1451         # todo: this is a hell of a hack
1452         # https://github.com/pytest-dev/pytest/issues/4569
1453 
1454         self.keywords.update(
1455             {
1456                 mark.name: True
1457                 for mark in self.iter_markers()
1458                 if mark.name not in self.keywords
1459             }
1460         )
1461 
1462         if fixtureinfo is None:
1463             fixtureinfo = self.session._fixturemanager.getfixtureinfo(
1464                 self, self.obj, self.cls, funcargs=True
1465             )
1466         self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo
1467         self.fixturenames = fixtureinfo.names_closure
1468         self._initrequest()
1469 
1470         #: original function name, without any decorations (for example
1471         #: parametrization adds a ``"[...]"`` suffix to function names).
1472         #:
1473         #: .. versionadded:: 3.0
1474         self.originalname = originalname
1475 
1476     @classmethod
1477     def from_parent(cls, parent, **kw):  # todo: determine sound type limitations
1478         """
1479         The public  constructor
1480         """
1481         return super().from_parent(parent=parent, **kw)
1482 
1483     def _initrequest(self):
1484         self.funcargs = {}
1485         self._request = fixtures.FixtureRequest(self)
1486 
1487     @property
1488     def function(self):
1489         "underlying python 'function' object"
1490         return getimfunc(self.obj)
1491 
1492     def _getobj(self):
1493         name = self.name
1494         i = name.find("[")  # parametrization
1495         if i != -1:
1496             name = name[:i]
1497         return getattr(self.parent.obj, name)
1498 
1499     @property
1500     def _pyfuncitem(self):
1501         "(compatonly) for code expecting pytest-2.2 style request objects"
1502         return self
1503 
1504     @property
1505     def funcargnames(self):
1506         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
1507         warnings.warn(FUNCARGNAMES, stacklevel=2)
1508         return self.fixturenames
1509 
1510     def runtest(self) -> None:
1511         """ execute the underlying test function. """
1512         self.ihook.pytest_pyfunc_call(pyfuncitem=self)
1513 
1514     def setup(self) -> None:
1515         if isinstance(self.parent, Instance):
1516             self.parent.newinstance()
1517             self.obj = self._getobj()
1518         self._request._fillfixtures()
1519 
1520     def _prunetraceback(self, excinfo: ExceptionInfo) -> None:
1521         if hasattr(self, "_obj") and not self.config.getoption("fulltrace", False):
1522             code = _pytest._code.Code(get_real_func(self.obj))
1523             path, firstlineno = code.path, code.firstlineno
1524             traceback = excinfo.traceback
1525             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)
1526             if ntraceback == traceback:
1527                 ntraceback = ntraceback.cut(path=path)
1528                 if ntraceback == traceback:
1529                     ntraceback = ntraceback.filter(filter_traceback)
1530                     if not ntraceback:
1531                         ntraceback = traceback
1532 
1533             excinfo.traceback = ntraceback.filter()
1534             # issue364: mark all but first and last frames to
1535             # only show a single-line message for each frame
1536             if self.config.getoption("tbstyle", "auto") == "auto":
1537                 if len(excinfo.traceback) > 2:
1538                     for entry in excinfo.traceback[1:-1]:
1539                         entry.set_repr_style("short")
1540 
1541     def repr_failure(self, excinfo, outerr=None):
1542         assert outerr is None, "XXX outerr usage is deprecated"
1543         style = self.config.getoption("tbstyle", "auto")
1544         if style == "auto":
1545             style = "long"
1546         return self._repr_failure_py(excinfo, style=style)
1547 
1548 
1549 class FunctionDefinition(Function):
1550     """
1551     internal hack until we get actual definition nodes instead of the
1552     crappy metafunc hack
1553     """
1554 
1555     def runtest(self) -> None:
1556         raise RuntimeError("function definitions are not supposed to be used")
1557 
1558     setup = runtest

</code><intended_behavior>Given the extensive role of this file in handling Python test items, including their collection and reporting, a deeper look into the methods that prepare test reports, especially skipped tests, might be required. The intended behavior here would be to ensure that when tests are skipped, and the reports are being prepared, any paths are accurately construed relative to the invocation point or adjusted accordingly if the computation of relative paths is found to be incorrect or not applied at this stage. This adjustment would correct the issue where paths are not shown as expected when tests are skipped.</intended_behavior>]
2025-10-18 16:28:37.143 | INFO     | Search completed. Bug locations: [<file>src/_pytest/main.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ core implementation of testing process: init, session, runtest loop. """
2 import fnmatch
3 import functools
4 import importlib
5 import os
6 import sys
7 from typing import Callable
8 from typing import Dict
9 from typing import FrozenSet
10 from typing import List
11 from typing import Optional
12 from typing import Sequence
13 from typing import Tuple
14 from typing import Union
15 
16 import attr
17 import py
18 
19 import _pytest._code
20 from _pytest import nodes
21 from _pytest.compat import TYPE_CHECKING
22 from _pytest.config import Config
23 from _pytest.config import directory_arg
24 from _pytest.config import ExitCode
25 from _pytest.config import hookimpl
26 from _pytest.config import UsageError
27 from _pytest.fixtures import FixtureManager
28 from _pytest.outcomes import exit
29 from _pytest.reports import CollectReport
30 from _pytest.runner import collect_one_node
31 from _pytest.runner import SetupState
32 
33 
34 if TYPE_CHECKING:
35     from typing import Type
36     from typing_extensions import Literal
37 
38     from _pytest.python import Package
39 
40 
41 def pytest_addoption(parser):
42     parser.addini(
43         "norecursedirs",
44         "directory patterns to avoid for recursion",
45         type="args",
46         default=[".*", "build", "dist", "CVS", "_darcs", "{arch}", "*.egg", "venv"],
47     )
48     parser.addini(
49         "testpaths",
50         "directories to search for tests when no files or directories are given in the "
51         "command line.",
52         type="args",
53         default=[],
54     )
55     group = parser.getgroup("general", "running and selection options")
56     group._addoption(
57         "-x",
58         "--exitfirst",
59         action="store_const",
60         dest="maxfail",
61         const=1,
62         help="exit instantly on first error or failed test.",
63     )
64     group._addoption(
65         "--maxfail",
66         metavar="num",
67         action="store",
68         type=int,
69         dest="maxfail",
70         default=0,
71         help="exit after first num failures or errors.",
72     )
73     group._addoption(
74         "--strict-markers",
75         "--strict",
76         action="store_true",
77         help="markers not registered in the `markers` section of the configuration file raise errors.",
78     )
79     group._addoption(
80         "-c",
81         metavar="file",
82         type=str,
83         dest="inifilename",
84         help="load configuration from `file` instead of trying to locate one of the implicit "
85         "configuration files.",
86     )
87     group._addoption(
88         "--continue-on-collection-errors",
89         action="store_true",
90         default=False,
91         dest="continue_on_collection_errors",
92         help="Force test execution even if collection errors occur.",
93     )
94     group._addoption(
95         "--rootdir",
96         action="store",
97         dest="rootdir",
98         help="Define root directory for tests. Can be relative path: 'root_dir', './root_dir', "
99         "'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: "
100         "'$HOME/root_dir'.",
101     )
102 
103     group = parser.getgroup("collect", "collection")
104     group.addoption(
105         "--collectonly",
106         "--collect-only",
107         "--co",
108         action="store_true",
109         help="only collect tests, don't execute them.",
110     )
111     group.addoption(
112         "--pyargs",
113         action="store_true",
114         help="try to interpret all arguments as python packages.",
115     )
116     group.addoption(
117         "--ignore",
118         action="append",
119         metavar="path",
120         help="ignore path during collection (multi-allowed).",
121     )
122     group.addoption(
123         "--ignore-glob",
124         action="append",
125         metavar="path",
126         help="ignore path pattern during collection (multi-allowed).",
127     )
128     group.addoption(
129         "--deselect",
130         action="append",
131         metavar="nodeid_prefix",
132         help="deselect item (via node id prefix) during collection (multi-allowed).",
133     )
134     group.addoption(
135         "--confcutdir",
136         dest="confcutdir",
137         default=None,
138         metavar="dir",
139         type=functools.partial(directory_arg, optname="--confcutdir"),
140         help="only load conftest.py's relative to specified dir.",
141     )
142     group.addoption(
143         "--noconftest",
144         action="store_true",
145         dest="noconftest",
146         default=False,
147         help="Don't load any conftest.py files.",
148     )
149     group.addoption(
150         "--keepduplicates",
151         "--keep-duplicates",
152         action="store_true",
153         dest="keepduplicates",
154         default=False,
155         help="Keep duplicate tests.",
156     )
157     group.addoption(
158         "--collect-in-virtualenv",
159         action="store_true",
160         dest="collect_in_virtualenv",
161         default=False,
162         help="Don't ignore tests in a local virtualenv directory",
163     )
164 
165     group = parser.getgroup("debugconfig", "test session debugging and configuration")
166     group.addoption(
167         "--basetemp",
168         dest="basetemp",
169         default=None,
170         metavar="dir",
171         help=(
172             "base temporary directory for this test run."
173             "(warning: this directory is removed if it exists)"
174         ),
175     )
176 
177 
178 def wrap_session(
179     config: Config, doit: Callable[[Config, "Session"], Optional[Union[int, ExitCode]]]
180 ) -> Union[int, ExitCode]:
181     """Skeleton command line program"""
182     session = Session.from_config(config)
183     session.exitstatus = ExitCode.OK
184     initstate = 0
185     try:
186         try:
187             config._do_configure()
188             initstate = 1
189             config.hook.pytest_sessionstart(session=session)
190             initstate = 2
191             session.exitstatus = doit(config, session) or 0
192         except UsageError:
193             session.exitstatus = ExitCode.USAGE_ERROR
194             raise
195         except Failed:
196             session.exitstatus = ExitCode.TESTS_FAILED
197         except (KeyboardInterrupt, exit.Exception):
198             excinfo = _pytest._code.ExceptionInfo.from_current()
199             exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]
200             if isinstance(excinfo.value, exit.Exception):
201                 if excinfo.value.returncode is not None:
202                     exitstatus = excinfo.value.returncode
203                 if initstate < 2:
204                     sys.stderr.write(
205                         "{}: {}\n".format(excinfo.typename, excinfo.value.msg)
206                     )
207             config.hook.pytest_keyboard_interrupt(excinfo=excinfo)
208             session.exitstatus = exitstatus
209         except:  # noqa
210             session.exitstatus = ExitCode.INTERNAL_ERROR
211             excinfo = _pytest._code.ExceptionInfo.from_current()
212             try:
213                 config.notify_exception(excinfo, config.option)
214             except exit.Exception as exc:
215                 if exc.returncode is not None:
216                     session.exitstatus = exc.returncode
217                 sys.stderr.write("{}: {}\n".format(type(exc).__name__, exc))
218             else:
219                 if excinfo.errisinstance(SystemExit):
220                     sys.stderr.write("mainloop: caught unexpected SystemExit!\n")
221 
222     finally:
223         # Explicitly break reference cycle.
224         excinfo = None  # type: ignore
225         session.startdir.chdir()
226         if initstate >= 2:
227             try:
228                 config.hook.pytest_sessionfinish(
229                     session=session, exitstatus=session.exitstatus
230                 )
231             except exit.Exception as exc:
232                 if exc.returncode is not None:
233                     session.exitstatus = exc.returncode
234                 sys.stderr.write("{}: {}\n".format(type(exc).__name__, exc))
235         config._ensure_unconfigure()
236     return session.exitstatus
237 
238 
239 def pytest_cmdline_main(config):
240     return wrap_session(config, _main)
241 
242 
243 def _main(config: Config, session: "Session") -> Optional[Union[int, ExitCode]]:
244     """ default command line protocol for initialization, session,
245     running tests and reporting. """
246     config.hook.pytest_collection(session=session)
247     config.hook.pytest_runtestloop(session=session)
248 
249     if session.testsfailed:
250         return ExitCode.TESTS_FAILED
251     elif session.testscollected == 0:
252         return ExitCode.NO_TESTS_COLLECTED
253     return None
254 
255 
256 def pytest_collection(session):
257     return session.perform_collect()
258 
259 
260 def pytest_runtestloop(session):
261     if session.testsfailed and not session.config.option.continue_on_collection_errors:
262         raise session.Interrupted(
263             "%d error%s during collection"
264             % (session.testsfailed, "s" if session.testsfailed != 1 else "")
265         )
266 
267     if session.config.option.collectonly:
268         return True
269 
270     for i, item in enumerate(session.items):
271         nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
272         item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)
273         if session.shouldfail:
274             raise session.Failed(session.shouldfail)
275         if session.shouldstop:
276             raise session.Interrupted(session.shouldstop)
277     return True
278 
279 
280 def _in_venv(path):
281     """Attempts to detect if ``path`` is the root of a Virtual Environment by
282     checking for the existence of the appropriate activate script"""
283     bindir = path.join("Scripts" if sys.platform.startswith("win") else "bin")
284     if not bindir.isdir():
285         return False
286     activates = (
287         "activate",
288         "activate.csh",
289         "activate.fish",
290         "Activate",
291         "Activate.bat",
292         "Activate.ps1",
293     )
294     return any([fname.basename in activates for fname in bindir.listdir()])
295 
296 
297 def pytest_ignore_collect(
298     path: py.path.local, config: Config
299 ) -> "Optional[Literal[True]]":
300     ignore_paths = config._getconftest_pathlist("collect_ignore", path=path.dirpath())
301     ignore_paths = ignore_paths or []
302     excludeopt = config.getoption("ignore")
303     if excludeopt:
304         ignore_paths.extend([py.path.local(x) for x in excludeopt])
305 
306     if py.path.local(path) in ignore_paths:
307         return True
308 
309     ignore_globs = config._getconftest_pathlist(
310         "collect_ignore_glob", path=path.dirpath()
311     )
312     ignore_globs = ignore_globs or []
313     excludeglobopt = config.getoption("ignore_glob")
314     if excludeglobopt:
315         ignore_globs.extend([py.path.local(x) for x in excludeglobopt])
316 
317     if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):
318         return True
319 
320     allow_in_venv = config.getoption("collect_in_virtualenv")
321     if not allow_in_venv and _in_venv(path):
322         return True
323     return None
324 
325 
326 def pytest_collection_modifyitems(items, config):
327     deselect_prefixes = tuple(config.getoption("deselect") or [])
328     if not deselect_prefixes:
329         return
330 
331     remaining = []
332     deselected = []
333     for colitem in items:
334         if colitem.nodeid.startswith(deselect_prefixes):
335             deselected.append(colitem)
336         else:
337             remaining.append(colitem)
338 
339     if deselected:
340         config.hook.pytest_deselected(items=deselected)
341         items[:] = remaining
342 
343 
344 class NoMatch(Exception):
345     """ raised if matching cannot locate a matching names. """
346 
347 
348 class Interrupted(KeyboardInterrupt):
349     """ signals an interrupted test run. """
350 
351     __module__ = "builtins"  # for py3
352 
353 
354 class Failed(Exception):
355     """ signals a stop as failed test run. """
356 
357 
358 @attr.s
359 class _bestrelpath_cache(dict):
360     path = attr.ib(type=py.path.local)
361 
362     def __missing__(self, path: py.path.local) -> str:
363         r = self.path.bestrelpath(path)  # type: str
364         self[path] = r
365         return r
366 
367 
368 class Session(nodes.FSCollector):
369     Interrupted = Interrupted
370     Failed = Failed
371     # Set on the session by runner.pytest_sessionstart.
372     _setupstate = None  # type: SetupState
373     # Set on the session by fixtures.pytest_sessionstart.
374     _fixturemanager = None  # type: FixtureManager
375     exitstatus = None  # type: Union[int, ExitCode]
376 
377     def __init__(self, config: Config) -> None:
378         nodes.FSCollector.__init__(
379             self, config.rootdir, parent=None, config=config, session=self, nodeid=""
380         )
381         self.testsfailed = 0
382         self.testscollected = 0
383         self.shouldstop = False
384         self.shouldfail = False
385         self.trace = config.trace.root.get("collection")
386         self.startdir = config.invocation_dir
387         self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]
388 
389         # Keep track of any collected nodes in here, so we don't duplicate fixtures
390         self._collection_node_cache1 = (
391             {}
392         )  # type: Dict[py.path.local, Sequence[nodes.Collector]]
393         self._collection_node_cache2 = (
394             {}
395         )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]
396         self._collection_node_cache3 = (
397             {}
398         )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]
399 
400         # Dirnames of pkgs with dunder-init files.
401         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]
402 
403         self._bestrelpathcache = _bestrelpath_cache(
404             config.rootdir
405         )  # type: Dict[py.path.local, str]
406 
407         self.config.pluginmanager.register(self, name="session")
408 
409     @classmethod
410     def from_config(cls, config):
411         return cls._create(config)
412 
413     def __repr__(self):
414         return "<%s %s exitstatus=%r testsfailed=%d testscollected=%d>" % (
415             self.__class__.__name__,
416             self.name,
417             getattr(self, "exitstatus", "<UNSET>"),
418             self.testsfailed,
419             self.testscollected,
420         )
421 
422     def _node_location_to_relpath(self, node_path: py.path.local) -> str:
423         # bestrelpath is a quite slow function
424         return self._bestrelpathcache[node_path]
425 
426     @hookimpl(tryfirst=True)
427     def pytest_collectstart(self):
428         if self.shouldfail:
429             raise self.Failed(self.shouldfail)
430         if self.shouldstop:
431             raise self.Interrupted(self.shouldstop)
432 
433     @hookimpl(tryfirst=True)
434     def pytest_runtest_logreport(self, report):
435         if report.failed and not hasattr(report, "wasxfail"):
436             self.testsfailed += 1
437             maxfail = self.config.getvalue("maxfail")
438             if maxfail and self.testsfailed >= maxfail:
439                 self.shouldfail = "stopping after %d failures" % (self.testsfailed)
440 
441     pytest_collectreport = pytest_runtest_logreport
442 
443     def isinitpath(self, path):
444         return path in self._initialpaths
445 
446     def gethookproxy(self, fspath: py.path.local):
447         return super()._gethookproxy(fspath)
448 
449     def perform_collect(self, args=None, genitems=True):
450         hook = self.config.hook
451         try:
452             items = self._perform_collect(args, genitems)
453             self.config.pluginmanager.check_pending()
454             hook.pytest_collection_modifyitems(
455                 session=self, config=self.config, items=items
456             )
457         finally:
458             hook.pytest_collection_finish(session=self)
459         self.testscollected = len(items)
460         return items
461 
462     def _perform_collect(self, args, genitems):
463         if args is None:
464             args = self.config.args
465         self.trace("perform_collect", self, args)
466         self.trace.root.indent += 1
467         self._notfound = []
468         initialpaths = []  # type: List[py.path.local]
469         self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]
470         self.items = items = []
471         for arg in args:
472             fspath, parts = self._parsearg(arg)
473             self._initial_parts.append((fspath, parts))
474             initialpaths.append(fspath)
475         self._initialpaths = frozenset(initialpaths)
476         rep = collect_one_node(self)
477         self.ihook.pytest_collectreport(report=rep)
478         self.trace.root.indent -= 1
479         if self._notfound:
480             errors = []
481             for arg, exc in self._notfound:
482                 line = "(no name {!r} in any of {!r})".format(arg, exc.args[0])
483                 errors.append("not found: {}\n{}".format(arg, line))
484             raise UsageError(*errors)
485         if not genitems:
486             return rep.result
487         else:
488             if rep.passed:
489                 for node in rep.result:
490                     self.items.extend(self.genitems(node))
491             return items
492 
493     def collect(self):
494         for fspath, parts in self._initial_parts:
495             self.trace("processing argument", (fspath, parts))
496             self.trace.root.indent += 1
497             try:
498                 yield from self._collect(fspath, parts)
499             except NoMatch as exc:
500                 report_arg = "::".join((str(fspath), *parts))
501                 # we are inside a make_report hook so
502                 # we cannot directly pass through the exception
503                 self._notfound.append((report_arg, exc))
504 
505             self.trace.root.indent -= 1
506         self._collection_node_cache1.clear()
507         self._collection_node_cache2.clear()
508         self._collection_node_cache3.clear()
509         self._collection_pkg_roots.clear()
510 
511     def _collect(self, argpath, names):
512         from _pytest.python import Package
513 
514         # Start with a Session root, and delve to argpath item (dir or file)
515         # and stack all Packages found on the way.
516         # No point in finding packages when collecting doctests
517         if not self.config.getoption("doctestmodules", False):
518             pm = self.config.pluginmanager
519             for parent in reversed(argpath.parts()):
520                 if pm._confcutdir and pm._confcutdir.relto(parent):
521                     break
522 
523                 if parent.isdir():
524                     pkginit = parent.join("__init__.py")
525                     if pkginit.isfile():
526                         if pkginit not in self._collection_node_cache1:
527                             col = self._collectfile(pkginit, handle_dupes=False)
528                             if col:
529                                 if isinstance(col[0], Package):
530                                     self._collection_pkg_roots[parent] = col[0]
531                                 # always store a list in the cache, matchnodes expects it
532                                 self._collection_node_cache1[col[0].fspath] = [col[0]]
533 
534         # If it's a directory argument, recurse and look for any Subpackages.
535         # Let the Package collector deal with subnodes, don't collect here.
536         if argpath.check(dir=1):
537             assert not names, "invalid arg {!r}".format((argpath, names))
538 
539             seen_dirs = set()
540             for path in argpath.visit(
541                 fil=self._visit_filter, rec=self._recurse, bf=True, sort=True
542             ):
543                 dirpath = path.dirpath()
544                 if dirpath not in seen_dirs:
545                     # Collect packages first.
546                     seen_dirs.add(dirpath)
547                     pkginit = dirpath.join("__init__.py")
548                     if pkginit.exists():
549                         for x in self._collectfile(pkginit):
550                             yield x
551                             if isinstance(x, Package):
552                                 self._collection_pkg_roots[dirpath] = x
553                 if dirpath in self._collection_pkg_roots:
554                     # Do not collect packages here.
555                     continue
556 
557                 for x in self._collectfile(path):
558                     key = (type(x), x.fspath)
559                     if key in self._collection_node_cache2:
560                         yield self._collection_node_cache2[key]
561                     else:
562                         self._collection_node_cache2[key] = x
563                         yield x
564         else:
565             assert argpath.check(file=1)
566 
567             if argpath in self._collection_node_cache1:
568                 col = self._collection_node_cache1[argpath]
569             else:
570                 collect_root = self._collection_pkg_roots.get(argpath.dirname, self)
571                 col = collect_root._collectfile(argpath, handle_dupes=False)
572                 if col:
573                     self._collection_node_cache1[argpath] = col
574             m = self.matchnodes(col, names)
575             # If __init__.py was the only file requested, then the matched node will be
576             # the corresponding Package, and the first yielded item will be the __init__
577             # Module itself, so just use that. If this special case isn't taken, then all
578             # the files in the package will be yielded.
579             if argpath.basename == "__init__.py":
580                 try:
581                     yield next(m[0].collect())
582                 except StopIteration:
583                     # The package collects nothing with only an __init__.py
584                     # file in it, which gets ignored by the default
585                     # "python_files" option.
586                     pass
587                 return
588             yield from m
589 
590     @staticmethod
591     def _visit_filter(f):
592         return f.check(file=1)
593 
594     def _tryconvertpyarg(self, x):
595         """Convert a dotted module name to path."""
596         try:
597             spec = importlib.util.find_spec(x)
598         # AttributeError: looks like package module, but actually filename
599         # ImportError: module does not exist
600         # ValueError: not a module name
601         except (AttributeError, ImportError, ValueError):
602             return x
603         if spec is None or spec.origin in {None, "namespace"}:
604             return x
605         elif spec.submodule_search_locations:
606             return os.path.dirname(spec.origin)
607         else:
608             return spec.origin
609 
610     def _parsearg(self, arg):
611         """ return (fspath, names) tuple after checking the file exists. """
612         strpath, *parts = str(arg).split("::")
613         if self.config.option.pyargs:
614             strpath = self._tryconvertpyarg(strpath)
615         relpath = strpath.replace("/", os.sep)
616         fspath = self.config.invocation_dir.join(relpath, abs=True)
617         if not fspath.check():
618             if self.config.option.pyargs:
619                 raise UsageError(
620                     "file or package not found: " + arg + " (missing __init__.py?)"
621                 )
622             raise UsageError("file not found: " + arg)
623         fspath = fspath.realpath()
624         return (fspath, parts)
625 
626     def matchnodes(self, matching, names):
627         self.trace("matchnodes", matching, names)
628         self.trace.root.indent += 1
629         nodes = self._matchnodes(matching, names)
630         num = len(nodes)
631         self.trace("matchnodes finished -> ", num, "nodes")
632         self.trace.root.indent -= 1
633         if num == 0:
634             raise NoMatch(matching, names[:1])
635         return nodes
636 
637     def _matchnodes(self, matching, names):
638         if not matching or not names:
639             return matching
640         name = names[0]
641         assert name
642         nextnames = names[1:]
643         resultnodes = []
644         for node in matching:
645             if isinstance(node, nodes.Item):
646                 if not names:
647                     resultnodes.append(node)
648                 continue
649             assert isinstance(node, nodes.Collector)
650             key = (type(node), node.nodeid)
651             if key in self._collection_node_cache3:
652                 rep = self._collection_node_cache3[key]
653             else:
654                 rep = collect_one_node(node)
655                 self._collection_node_cache3[key] = rep
656             if rep.passed:
657                 has_matched = False
658                 for x in rep.result:
659                     # TODO: remove parametrized workaround once collection structure contains parametrization
660                     if x.name == name or x.name.split("[")[0] == name:
661                         resultnodes.extend(self.matchnodes([x], nextnames))
662                         has_matched = True
663                 # XXX accept IDs that don't have "()" for class instances
664                 if not has_matched and len(rep.result) == 1 and x.name == "()":
665                     nextnames.insert(0, name)
666                     resultnodes.extend(self.matchnodes([x], nextnames))
667             else:
668                 # report collection failures here to avoid failing to run some test
669                 # specified in the command line because the module could not be
670                 # imported (#134)
671                 node.ihook.pytest_collectreport(report=rep)
672         return resultnodes
673 
674     def genitems(self, node):
675         self.trace("genitems", node)
676         if isinstance(node, nodes.Item):
677             node.ihook.pytest_itemcollected(item=node)
678             yield node
679         else:
680             assert isinstance(node, nodes.Collector)
681             rep = collect_one_node(node)
682             if rep.passed:
683                 for subnode in rep.result:
684                     yield from self.genitems(subnode)
685             node.ihook.pytest_collectreport(report=rep)

</code><intended_behavior>This file likely interacts with handling test collection and execution paths, including how paths are reported in console outputs. The specific location where skip reports are formatted should ensure that file paths are adjusted to reflect their relative paths from the invocation directory. If file paths are presented as absolute paths during the formatting of skip messages, a modification is needed to convert these paths to be relative based on the current directory from which pytest was invoked. This would resolve the issue by displaying paths in the skip report as the user expects, maintaining uniformity with how paths are referenced throughout pytest's output.</intended_behavior>, <file>src/_pytest/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Python test discovery, setup and run of test functions. """
2 import enum
3 import fnmatch
4 import inspect
5 import itertools
6 import os
7 import sys
8 import typing
9 import warnings
10 from collections import Counter
11 from collections import defaultdict
12 from collections.abc import Sequence
13 from functools import partial
14 from typing import Callable
15 from typing import Dict
16 from typing import Iterable
17 from typing import List
18 from typing import Optional
19 from typing import Tuple
20 from typing import Union
21 
22 import py
23 
24 import _pytest
25 from _pytest import fixtures
26 from _pytest import nodes
27 from _pytest._code import filter_traceback
28 from _pytest._code.code import ExceptionInfo
29 from _pytest._code.source import getfslineno
30 from _pytest._io import TerminalWriter
31 from _pytest._io.saferepr import saferepr
32 from _pytest.compat import ascii_escaped
33 from _pytest.compat import get_default_arg_names
34 from _pytest.compat import get_real_func
35 from _pytest.compat import getimfunc
36 from _pytest.compat import getlocation
37 from _pytest.compat import is_async_function
38 from _pytest.compat import is_generator
39 from _pytest.compat import NOTSET
40 from _pytest.compat import REGEX_TYPE
41 from _pytest.compat import safe_getattr
42 from _pytest.compat import safe_isclass
43 from _pytest.compat import STRING_TYPES
44 from _pytest.config import Config
45 from _pytest.config import hookimpl
46 from _pytest.deprecated import FUNCARGNAMES
47 from _pytest.fixtures import FuncFixtureInfo
48 from _pytest.mark import MARK_GEN
49 from _pytest.mark import ParameterSet
50 from _pytest.mark.structures import get_unpacked_marks
51 from _pytest.mark.structures import Mark
52 from _pytest.mark.structures import normalize_mark_list
53 from _pytest.outcomes import fail
54 from _pytest.outcomes import skip
55 from _pytest.pathlib import parts
56 from _pytest.warning_types import PytestCollectionWarning
57 from _pytest.warning_types import PytestUnhandledCoroutineWarning
58 
59 
60 def pyobj_property(name):
61     def get(self):
62         node = self.getparent(getattr(__import__("pytest"), name))
63         if node is not None:
64             return node.obj
65 
66     doc = "python {} object this node was collected from (can be None).".format(
67         name.lower()
68     )
69     return property(get, None, None, doc)
70 
71 
72 def pytest_addoption(parser):
73     group = parser.getgroup("general")
74     group.addoption(
75         "--fixtures",
76         "--funcargs",
77         action="store_true",
78         dest="showfixtures",
79         default=False,
80         help="show available fixtures, sorted by plugin appearance "
81         "(fixtures with leading '_' are only shown with '-v')",
82     )
83     group.addoption(
84         "--fixtures-per-test",
85         action="store_true",
86         dest="show_fixtures_per_test",
87         default=False,
88         help="show fixtures per test",
89     )
90     parser.addini(
91         "python_files",
92         type="args",
93         # NOTE: default is also used in AssertionRewritingHook.
94         default=["test_*.py", "*_test.py"],
95         help="glob-style file patterns for Python test module discovery",
96     )
97     parser.addini(
98         "python_classes",
99         type="args",
100         default=["Test"],
101         help="prefixes or glob names for Python test class discovery",
102     )
103     parser.addini(
104         "python_functions",
105         type="args",
106         default=["test"],
107         help="prefixes or glob names for Python test function and method discovery",
108     )
109     parser.addini(
110         "disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
111         type="bool",
112         default=False,
113         help="disable string escape non-ascii characters, might cause unwanted "
114         "side effects(use at your own risk)",
115     )
116 
117     group.addoption(
118         "--import-mode",
119         default="prepend",
120         choices=["prepend", "append"],
121         dest="importmode",
122         help="prepend/append to sys.path when importing test modules, "
123         "default is to prepend.",
124     )
125 
126 
127 def pytest_cmdline_main(config):
128     if config.option.showfixtures:
129         showfixtures(config)
130         return 0
131     if config.option.show_fixtures_per_test:
132         show_fixtures_per_test(config)
133         return 0
134 
135 
136 def pytest_generate_tests(metafunc: "Metafunc") -> None:
137     for marker in metafunc.definition.iter_markers(name="parametrize"):
138         # TODO: Fix this type-ignore (overlapping kwargs).
139         metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821
140 
141 
142 def pytest_configure(config):
143     config.addinivalue_line(
144         "markers",
145         "parametrize(argnames, argvalues): call a test function multiple "
146         "times passing in different arguments in turn. argvalues generally "
147         "needs to be a list of values if argnames specifies only one name "
148         "or a list of tuples of values if argnames specifies multiple names. "
149         "Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
150         "decorated test function, one with arg1=1 and another with arg1=2."
151         "see https://docs.pytest.org/en/latest/parametrize.html for more info "
152         "and examples.",
153     )
154     config.addinivalue_line(
155         "markers",
156         "usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
157         "all of the specified fixtures. see "
158         "https://docs.pytest.org/en/latest/fixture.html#usefixtures ",
159     )
160 
161 
162 def async_warn_and_skip(nodeid: str) -> None:
163     msg = "async def functions are not natively supported and have been skipped.\n"
164     msg += (
165         "You need to install a suitable plugin for your async framework, for example:\n"
166     )
167     msg += "  - pytest-asyncio\n"
168     msg += "  - pytest-trio\n"
169     msg += "  - pytest-tornasync\n"
170     msg += "  - pytest-twisted"
171     warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))
172     skip(msg="async def function and no async plugin installed (see warnings)")
173 
174 
175 @hookimpl(trylast=True)
176 def pytest_pyfunc_call(pyfuncitem: "Function"):
177     testfunction = pyfuncitem.obj
178     if is_async_function(testfunction):
179         async_warn_and_skip(pyfuncitem.nodeid)
180     funcargs = pyfuncitem.funcargs
181     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
182     result = testfunction(**testargs)
183     if hasattr(result, "__await__") or hasattr(result, "__aiter__"):
184         async_warn_and_skip(pyfuncitem.nodeid)
185     return True
186 
187 
188 def pytest_collect_file(path, parent):
189     ext = path.ext
190     if ext == ".py":
191         if not parent.session.isinitpath(path):
192             if not path_matches_patterns(
193                 path, parent.config.getini("python_files") + ["__init__.py"]
194             ):
195                 return
196         ihook = parent.session.gethookproxy(path)
197         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)
198 
199 
200 def path_matches_patterns(path, patterns):
201     """Returns True if the given py.path.local matches one of the patterns in the list of globs given"""
202     return any(path.fnmatch(pattern) for pattern in patterns)
203 
204 
205 def pytest_pycollect_makemodule(path, parent):
206     if path.basename == "__init__.py":
207         return Package.from_parent(parent, fspath=path)
208     return Module.from_parent(parent, fspath=path)
209 
210 
211 @hookimpl(hookwrapper=True)
212 def pytest_pycollect_makeitem(collector, name, obj):
213     outcome = yield
214     res = outcome.get_result()
215     if res is not None:
216         return
217     # nothing was collected elsewhere, let's do it here
218     if safe_isclass(obj):
219         if collector.istestclass(obj, name):
220             outcome.force_result(Class.from_parent(collector, name=name, obj=obj))
221     elif collector.istestfunction(obj, name):
222         # mock seems to store unbound methods (issue473), normalize it
223         obj = getattr(obj, "__func__", obj)
224         # We need to try and unwrap the function if it's a functools.partial
225         # or a functools.wrapped.
226         # We mustn't if it's been wrapped with mock.patch (python 2 only)
227         if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):
228             filename, lineno = getfslineno(obj)
229             warnings.warn_explicit(
230                 message=PytestCollectionWarning(
231                     "cannot collect %r because it is not a function." % name
232                 ),
233                 category=None,
234                 filename=str(filename),
235                 lineno=lineno + 1,
236             )
237         elif getattr(obj, "__test__", True):
238             if is_generator(obj):
239                 res = Function.from_parent(collector, name=name)
240                 reason = "yield tests were removed in pytest 4.0 - {name} will be ignored".format(
241                     name=name
242                 )
243                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))
244                 res.warn(PytestCollectionWarning(reason))
245             else:
246                 res = list(collector._genfunctions(name, obj))
247             outcome.force_result(res)
248 
249 
250 class PyobjMixin:
251     module = pyobj_property("Module")
252     cls = pyobj_property("Class")
253     instance = pyobj_property("Instance")
254     _ALLOW_MARKERS = True
255 
256     @property
257     def obj(self):
258         """Underlying Python object."""
259         obj = getattr(self, "_obj", None)
260         if obj is None:
261             self._obj = obj = self._getobj()
262             # XXX evil hack
263             # used to avoid Instance collector marker duplication
264             if self._ALLOW_MARKERS:
265                 self.own_markers.extend(get_unpacked_marks(self.obj))
266         return obj
267 
268     @obj.setter
269     def obj(self, value):
270         self._obj = value
271 
272     def _getobj(self):
273         """Gets the underlying Python object. May be overwritten by subclasses."""
274         return getattr(self.parent.obj, self.name)
275 
276     def getmodpath(self, stopatmodule=True, includemodule=False):
277         """ return python path relative to the containing module. """
278         chain = self.listchain()
279         chain.reverse()
280         parts = []
281         for node in chain:
282             if isinstance(node, Instance):
283                 continue
284             name = node.name
285             if isinstance(node, Module):
286                 name = os.path.splitext(name)[0]
287                 if stopatmodule:
288                     if includemodule:
289                         parts.append(name)
290                     break
291             parts.append(name)
292         parts.reverse()
293         return ".".join(parts)
294 
295     def reportinfo(self) -> Tuple[Union[py.path.local, str], int, str]:
296         # XXX caching?
297         obj = self.obj
298         compat_co_firstlineno = getattr(obj, "compat_co_firstlineno", None)
299         if isinstance(compat_co_firstlineno, int):
300             # nose compatibility
301             file_path = sys.modules[obj.__module__].__file__
302             if file_path.endswith(".pyc"):
303                 file_path = file_path[:-1]
304             fspath = file_path  # type: Union[py.path.local, str]
305             lineno = compat_co_firstlineno
306         else:
307             fspath, lineno = getfslineno(obj)
308         modpath = self.getmodpath()
309         assert isinstance(lineno, int)
310         return fspath, lineno, modpath
311 
312 
313 class PyCollector(PyobjMixin, nodes.Collector):
314     def funcnamefilter(self, name):
315         return self._matches_prefix_or_glob_option("python_functions", name)
316 
317     def isnosetest(self, obj):
318         """ Look for the __test__ attribute, which is applied by the
319         @nose.tools.istest decorator
320         """
321         # We explicitly check for "is True" here to not mistakenly treat
322         # classes with a custom __getattr__ returning something truthy (like a
323         # function) as test classes.
324         return safe_getattr(obj, "__test__", False) is True
325 
326     def classnamefilter(self, name):
327         return self._matches_prefix_or_glob_option("python_classes", name)
328 
329     def istestfunction(self, obj, name):
330         if self.funcnamefilter(name) or self.isnosetest(obj):
331             if isinstance(obj, staticmethod):
332                 # static methods need to be unwrapped
333                 obj = safe_getattr(obj, "__func__", False)
334             return (
335                 safe_getattr(obj, "__call__", False)
336                 and fixtures.getfixturemarker(obj) is None
337             )
338         else:
339             return False
340 
341     def istestclass(self, obj, name):
342         return self.classnamefilter(name) or self.isnosetest(obj)
343 
344     def _matches_prefix_or_glob_option(self, option_name, name):
345         """
346         checks if the given name matches the prefix or glob-pattern defined
347         in ini configuration.
348         """
349         for option in self.config.getini(option_name):
350             if name.startswith(option):
351                 return True
352             # check that name looks like a glob-string before calling fnmatch
353             # because this is called for every name in each collected module,
354             # and fnmatch is somewhat expensive to call
355             elif ("*" in option or "?" in option or "[" in option) and fnmatch.fnmatch(
356                 name, option
357             ):
358                 return True
359         return False
360 
361     def collect(self):
362         if not getattr(self.obj, "__test__", True):
363             return []
364 
365         # NB. we avoid random getattrs and peek in the __dict__ instead
366         # (XXX originally introduced from a PyPy need, still true?)
367         dicts = [getattr(self.obj, "__dict__", {})]
368         for basecls in inspect.getmro(self.obj.__class__):
369             dicts.append(basecls.__dict__)
370         seen = {}
371         values = []
372         for dic in dicts:
373             for name, obj in list(dic.items()):
374                 if name in seen:
375                     continue
376                 seen[name] = True
377                 res = self._makeitem(name, obj)
378                 if res is None:
379                     continue
380                 if not isinstance(res, list):
381                     res = [res]
382                 values.extend(res)
383 
384         def sort_key(item):
385             fspath, lineno, _ = item.reportinfo()
386             return (str(fspath), lineno)
387 
388         values.sort(key=sort_key)
389         return values
390 
391     def _makeitem(self, name, obj):
392         # assert self.ihook.fspath == self.fspath, self
393         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)
394 
395     def _genfunctions(self, name, funcobj):
396         module = self.getparent(Module).obj
397         clscol = self.getparent(Class)
398         cls = clscol and clscol.obj or None
399         fm = self.session._fixturemanager
400 
401         definition = FunctionDefinition.from_parent(self, name=name, callobj=funcobj)
402         fixtureinfo = definition._fixtureinfo
403 
404         metafunc = Metafunc(
405             definition, fixtureinfo, self.config, cls=cls, module=module
406         )
407         methods = []
408         if hasattr(module, "pytest_generate_tests"):
409             methods.append(module.pytest_generate_tests)
410         if hasattr(cls, "pytest_generate_tests"):
411             methods.append(cls().pytest_generate_tests)
412 
413         self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))
414 
415         if not metafunc._calls:
416             yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)
417         else:
418             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs
419             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)
420 
421             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures
422             # with direct parametrization, so make sure we update what the
423             # function really needs.
424             fixtureinfo.prune_dependency_tree()
425 
426             for callspec in metafunc._calls:
427                 subname = "{}[{}]".format(name, callspec.id)
428                 yield Function.from_parent(
429                     self,
430                     name=subname,
431                     callspec=callspec,
432                     callobj=funcobj,
433                     fixtureinfo=fixtureinfo,
434                     keywords={callspec.id: True},
435                     originalname=name,
436                 )
437 
438 
439 class Module(nodes.File, PyCollector):
440     """ Collector for test classes and functions. """
441 
442     def _getobj(self):
443         return self._importtestmodule()
444 
445     def collect(self):
446         self._inject_setup_module_fixture()
447         self._inject_setup_function_fixture()
448         self.session._fixturemanager.parsefactories(self)
449         return super().collect()
450 
451     def _inject_setup_module_fixture(self):
452         """Injects a hidden autouse, module scoped fixture into the collected module object
453         that invokes setUpModule/tearDownModule if either or both are available.
454 
455         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
456         other fixtures (#517).
457         """
458         setup_module = _get_first_non_fixture_func(
459             self.obj, ("setUpModule", "setup_module")
460         )
461         teardown_module = _get_first_non_fixture_func(
462             self.obj, ("tearDownModule", "teardown_module")
463         )
464 
465         if setup_module is None and teardown_module is None:
466             return
467 
468         @fixtures.fixture(autouse=True, scope="module")
469         def xunit_setup_module_fixture(request):
470             if setup_module is not None:
471                 _call_with_optional_argument(setup_module, request.module)
472             yield
473             if teardown_module is not None:
474                 _call_with_optional_argument(teardown_module, request.module)
475 
476         self.obj.__pytest_setup_module = xunit_setup_module_fixture
477 
478     def _inject_setup_function_fixture(self):
479         """Injects a hidden autouse, function scoped fixture into the collected module object
480         that invokes setup_function/teardown_function if either or both are available.
481 
482         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
483         other fixtures (#517).
484         """
485         setup_function = _get_first_non_fixture_func(self.obj, ("setup_function",))
486         teardown_function = _get_first_non_fixture_func(
487             self.obj, ("teardown_function",)
488         )
489         if setup_function is None and teardown_function is None:
490             return
491 
492         @fixtures.fixture(autouse=True, scope="function")
493         def xunit_setup_function_fixture(request):
494             if request.instance is not None:
495                 # in this case we are bound to an instance, so we need to let
496                 # setup_method handle this
497                 yield
498                 return
499             if setup_function is not None:
500                 _call_with_optional_argument(setup_function, request.function)
501             yield
502             if teardown_function is not None:
503                 _call_with_optional_argument(teardown_function, request.function)
504 
505         self.obj.__pytest_setup_function = xunit_setup_function_fixture
506 
507     def _importtestmodule(self):
508         # we assume we are only called once per module
509         importmode = self.config.getoption("--import-mode")
510         try:
511             mod = self.fspath.pyimport(ensuresyspath=importmode)
512         except SyntaxError:
513             raise self.CollectError(ExceptionInfo.from_current().getrepr(style="short"))
514         except self.fspath.ImportMismatchError as e:
515             raise self.CollectError(
516                 "import file mismatch:\n"
517                 "imported module %r has this __file__ attribute:\n"
518                 "  %s\n"
519                 "which is not the same as the test file we want to collect:\n"
520                 "  %s\n"
521                 "HINT: remove __pycache__ / .pyc files and/or use a "
522                 "unique basename for your test file modules" % e.args
523             )
524         except ImportError:
525             exc_info = ExceptionInfo.from_current()
526             if self.config.getoption("verbose") < 2:
527                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)
528             exc_repr = (
529                 exc_info.getrepr(style="short")
530                 if exc_info.traceback
531                 else exc_info.exconly()
532             )
533             formatted_tb = str(exc_repr)
534             raise self.CollectError(
535                 "ImportError while importing test module '{fspath}'.\n"
536                 "Hint: make sure your test modules/packages have valid Python names.\n"
537                 "Traceback:\n"
538                 "{traceback}".format(fspath=self.fspath, traceback=formatted_tb)
539             )
540         except _pytest.runner.Skipped as e:
541             if e.allow_module_level:
542                 raise
543             raise self.CollectError(
544                 "Using pytest.skip outside of a test is not allowed. "
545                 "To decorate a test function, use the @pytest.mark.skip "
546                 "or @pytest.mark.skipif decorators instead, and to skip a "
547                 "module use `pytestmark = pytest.mark.{skip,skipif}."
548             )
549         self.config.pluginmanager.consider_module(mod)
550         return mod
551 
552 
553 class Package(Module):
554     def __init__(
555         self,
556         fspath: py.path.local,
557         parent: nodes.Collector,
558         # NOTE: following args are unused:
559         config=None,
560         session=None,
561         nodeid=None,
562     ) -> None:
563         # NOTE: could be just the following, but kept as-is for compat.
564         # nodes.FSCollector.__init__(self, fspath, parent=parent)
565         session = parent.session
566         nodes.FSCollector.__init__(
567             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid
568         )
569 
570         self.name = fspath.dirname
571 
572     def setup(self):
573         # not using fixtures to call setup_module here because autouse fixtures
574         # from packages are not called automatically (#4085)
575         setup_module = _get_first_non_fixture_func(
576             self.obj, ("setUpModule", "setup_module")
577         )
578         if setup_module is not None:
579             _call_with_optional_argument(setup_module, self.obj)
580 
581         teardown_module = _get_first_non_fixture_func(
582             self.obj, ("tearDownModule", "teardown_module")
583         )
584         if teardown_module is not None:
585             func = partial(_call_with_optional_argument, teardown_module, self.obj)
586             self.addfinalizer(func)
587 
588     def gethookproxy(self, fspath: py.path.local):
589         return super()._gethookproxy(fspath)
590 
591     def isinitpath(self, path):
592         return path in self.session._initialpaths
593 
594     def collect(self):
595         this_path = self.fspath.dirpath()
596         init_module = this_path.join("__init__.py")
597         if init_module.check(file=1) and path_matches_patterns(
598             init_module, self.config.getini("python_files")
599         ):
600             yield Module.from_parent(self, fspath=init_module)
601         pkg_prefixes = set()
602         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):
603             # We will visit our own __init__.py file, in which case we skip it.
604             is_file = path.isfile()
605             if is_file:
606                 if path.basename == "__init__.py" and path.dirpath() == this_path:
607                     continue
608 
609             parts_ = parts(path.strpath)
610             if any(
611                 pkg_prefix in parts_ and pkg_prefix.join("__init__.py") != path
612                 for pkg_prefix in pkg_prefixes
613             ):
614                 continue
615 
616             if is_file:
617                 yield from self._collectfile(path)
618             elif not path.isdir():
619                 # Broken symlink or invalid/missing file.
620                 continue
621             elif path.join("__init__.py").check(file=1):
622                 pkg_prefixes.add(path)
623 
624 
625 def _call_with_optional_argument(func, arg):
626     """Call the given function with the given argument if func accepts one argument, otherwise
627     calls func without arguments"""
628     arg_count = func.__code__.co_argcount
629     if inspect.ismethod(func):
630         arg_count -= 1
631     if arg_count:
632         func(arg)
633     else:
634         func()
635 
636 
637 def _get_first_non_fixture_func(obj, names):
638     """Return the attribute from the given object to be used as a setup/teardown
639     xunit-style function, but only if not marked as a fixture to
640     avoid calling it twice.
641     """
642     for name in names:
643         meth = getattr(obj, name, None)
644         if meth is not None and fixtures.getfixturemarker(meth) is None:
645             return meth
646 
647 
648 class Class(PyCollector):
649     """ Collector for test methods. """
650 
651     @classmethod
652     def from_parent(cls, parent, *, name, obj=None):
653         """
654         The public constructor
655         """
656         return super().from_parent(name=name, parent=parent)
657 
658     def collect(self):
659         if not safe_getattr(self.obj, "__test__", True):
660             return []
661         if hasinit(self.obj):
662             self.warn(
663                 PytestCollectionWarning(
664                     "cannot collect test class %r because it has a "
665                     "__init__ constructor (from: %s)"
666                     % (self.obj.__name__, self.parent.nodeid)
667                 )
668             )
669             return []
670         elif hasnew(self.obj):
671             self.warn(
672                 PytestCollectionWarning(
673                     "cannot collect test class %r because it has a "
674                     "__new__ constructor (from: %s)"
675                     % (self.obj.__name__, self.parent.nodeid)
676                 )
677             )
678             return []
679 
680         self._inject_setup_class_fixture()
681         self._inject_setup_method_fixture()
682 
683         return [Instance.from_parent(self, name="()")]
684 
685     def _inject_setup_class_fixture(self):
686         """Injects a hidden autouse, class scoped fixture into the collected class object
687         that invokes setup_class/teardown_class if either or both are available.
688 
689         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
690         other fixtures (#517).
691         """
692         setup_class = _get_first_non_fixture_func(self.obj, ("setup_class",))
693         teardown_class = getattr(self.obj, "teardown_class", None)
694         if setup_class is None and teardown_class is None:
695             return
696 
697         @fixtures.fixture(autouse=True, scope="class")
698         def xunit_setup_class_fixture(cls):
699             if setup_class is not None:
700                 func = getimfunc(setup_class)
701                 _call_with_optional_argument(func, self.obj)
702             yield
703             if teardown_class is not None:
704                 func = getimfunc(teardown_class)
705                 _call_with_optional_argument(func, self.obj)
706 
707         self.obj.__pytest_setup_class = xunit_setup_class_fixture
708 
709     def _inject_setup_method_fixture(self):
710         """Injects a hidden autouse, function scoped fixture into the collected class object
711         that invokes setup_method/teardown_method if either or both are available.
712 
713         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
714         other fixtures (#517).
715         """
716         setup_method = _get_first_non_fixture_func(self.obj, ("setup_method",))
717         teardown_method = getattr(self.obj, "teardown_method", None)
718         if setup_method is None and teardown_method is None:
719             return
720 
721         @fixtures.fixture(autouse=True, scope="function")
722         def xunit_setup_method_fixture(self, request):
723             method = request.function
724             if setup_method is not None:
725                 func = getattr(self, "setup_method")
726                 _call_with_optional_argument(func, method)
727             yield
728             if teardown_method is not None:
729                 func = getattr(self, "teardown_method")
730                 _call_with_optional_argument(func, method)
731 
732         self.obj.__pytest_setup_method = xunit_setup_method_fixture
733 
734 
735 class Instance(PyCollector):
736     _ALLOW_MARKERS = False  # hack, destroy later
737     # instances share the object with their parents in a way
738     # that duplicates markers instances if not taken out
739     # can be removed at node structure reorganization time
740 
741     def _getobj(self):
742         return self.parent.obj()
743 
744     def collect(self):
745         self.session._fixturemanager.parsefactories(self)
746         return super().collect()
747 
748     def newinstance(self):
749         self.obj = self._getobj()
750         return self.obj
751 
752 
753 def hasinit(obj):
754     init = getattr(obj, "__init__", None)
755     if init:
756         return init != object.__init__
757 
758 
759 def hasnew(obj):
760     new = getattr(obj, "__new__", None)
761     if new:
762         return new != object.__new__
763 
764 
765 class CallSpec2:
766     def __init__(self, metafunc):
767         self.metafunc = metafunc
768         self.funcargs = {}
769         self._idlist = []
770         self.params = {}
771         self._arg2scopenum = {}  # used for sorting parametrized resources
772         self.marks = []
773         self.indices = {}
774 
775     def copy(self):
776         cs = CallSpec2(self.metafunc)
777         cs.funcargs.update(self.funcargs)
778         cs.params.update(self.params)
779         cs.marks.extend(self.marks)
780         cs.indices.update(self.indices)
781         cs._arg2scopenum.update(self._arg2scopenum)
782         cs._idlist = list(self._idlist)
783         return cs
784 
785     def _checkargnotcontained(self, arg):
786         if arg in self.params or arg in self.funcargs:
787             raise ValueError("duplicate {!r}".format(arg))
788 
789     def getparam(self, name):
790         try:
791             return self.params[name]
792         except KeyError:
793             raise ValueError(name)
794 
795     @property
796     def id(self):
797         return "-".join(map(str, self._idlist))
798 
799     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):
800         for arg, val in zip(argnames, valset):
801             self._checkargnotcontained(arg)
802             valtype_for_arg = valtypes[arg]
803             getattr(self, valtype_for_arg)[arg] = val
804             self.indices[arg] = param_index
805             self._arg2scopenum[arg] = scopenum
806         self._idlist.append(id)
807         self.marks.extend(normalize_mark_list(marks))
808 
809 
810 class Metafunc:
811     """
812     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.
813     They help to inspect a test function and to generate tests according to
814     test configuration or values specified in the class or module where a
815     test function is defined.
816     """
817 
818     def __init__(
819         self,
820         definition: "FunctionDefinition",
821         fixtureinfo: fixtures.FuncFixtureInfo,
822         config: Config,
823         cls=None,
824         module=None,
825     ) -> None:
826         self.definition = definition
827 
828         #: access to the :class:`_pytest.config.Config` object for the test session
829         self.config = config
830 
831         #: the module object where the test function is defined in.
832         self.module = module
833 
834         #: underlying python test function
835         self.function = definition.obj
836 
837         #: set of fixture names required by the test function
838         self.fixturenames = fixtureinfo.names_closure
839 
840         #: class object where the test function is defined in or ``None``.
841         self.cls = cls
842 
843         self._calls = []  # type: List[CallSpec2]
844         self._arg2fixturedefs = fixtureinfo.name2fixturedefs
845 
846     @property
847     def funcargnames(self):
848         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
849         warnings.warn(FUNCARGNAMES, stacklevel=2)
850         return self.fixturenames
851 
852     def parametrize(
853         self,
854         argnames: Union[str, List[str], Tuple[str, ...]],
855         argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],
856         indirect: Union[bool, typing.Sequence[str]] = False,
857         ids: Optional[
858             Union[
859                 Iterable[Union[None, str, float, int, bool]],
860                 Callable[[object], Optional[object]],
861             ]
862         ] = None,
863         scope: "Optional[str]" = None,
864         *,
865         _param_mark: Optional[Mark] = None
866     ) -> None:
867         """ Add new invocations to the underlying test function using the list
868         of argvalues for the given argnames.  Parametrization is performed
869         during the collection phase.  If you need to setup expensive resources
870         see about setting indirect to do it rather at test setup time.
871 
872         :arg argnames: a comma-separated string denoting one or more argument
873                        names, or a list/tuple of argument strings.
874 
875         :arg argvalues: The list of argvalues determines how often a
876             test is invoked with different argument values.  If only one
877             argname was specified argvalues is a list of values.  If N
878             argnames were specified, argvalues must be a list of N-tuples,
879             where each tuple-element specifies a value for its respective
880             argname.
881 
882         :arg indirect: The list of argnames or boolean. A list of arguments'
883             names (subset of argnames). If True the list contains all names from
884             the argnames. Each argvalue corresponding to an argname in this list will
885             be passed as request.param to its respective argname fixture
886             function so that it can perform more expensive setups during the
887             setup phase of a test rather than at collection time.
888 
889         :arg ids: sequence of (or generator for) ids for ``argvalues``,
890               or a callable to return part of the id for each argvalue.
891 
892             With sequences (and generators like ``itertools.count()``) the
893             returned ids should be of type ``string``, ``int``, ``float``,
894             ``bool``, or ``None``.
895             They are mapped to the corresponding index in ``argvalues``.
896             ``None`` means to use the auto-generated id.
897 
898             If it is a callable it will be called for each entry in
899             ``argvalues``, and the return value is used as part of the
900             auto-generated id for the whole set (where parts are joined with
901             dashes ("-")).
902             This is useful to provide more specific ids for certain items, e.g.
903             dates.  Returning ``None`` will use an auto-generated id.
904 
905             If no ids are provided they will be generated automatically from
906             the argvalues.
907 
908         :arg scope: if specified it denotes the scope of the parameters.
909             The scope is used for grouping tests by parameter instances.
910             It will also override any fixture-function defined scope, allowing
911             to set a dynamic scope using test context or configuration.
912         """
913         from _pytest.fixtures import scope2index
914 
915         argnames, parameters = ParameterSet._for_parametrize(
916             argnames,
917             argvalues,
918             self.function,
919             self.config,
920             function_definition=self.definition,
921         )
922         del argvalues
923 
924         if "request" in argnames:
925             fail(
926                 "'request' is a reserved name and cannot be used in @pytest.mark.parametrize",
927                 pytrace=False,
928             )
929 
930         if scope is None:
931             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)
932 
933         self._validate_if_using_arg_names(argnames, indirect)
934 
935         arg_values_types = self._resolve_arg_value_types(argnames, indirect)
936 
937         self._validate_explicit_parameters(argnames, indirect)
938 
939         # Use any already (possibly) generated ids with parametrize Marks.
940         if _param_mark and _param_mark._param_ids_from:
941             generated_ids = _param_mark._param_ids_from._param_ids_generated
942             if generated_ids is not None:
943                 ids = generated_ids
944 
945         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)
946 
947         # Store used (possibly generated) ids with parametrize Marks.
948         if _param_mark and _param_mark._param_ids_from and generated_ids is None:
949             object.__setattr__(_param_mark._param_ids_from, "_param_ids_generated", ids)
950 
951         scopenum = scope2index(
952             scope, descr="parametrize() call in {}".format(self.function.__name__)
953         )
954 
955         # create the new calls: if we are parametrize() multiple times (by applying the decorator
956         # more than once) then we accumulate those calls generating the cartesian product
957         # of all calls
958         newcalls = []
959         for callspec in self._calls or [CallSpec2(self)]:
960             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):
961                 newcallspec = callspec.copy()
962                 newcallspec.setmulti2(
963                     arg_values_types,
964                     argnames,
965                     param_set.values,
966                     param_id,
967                     param_set.marks,
968                     scopenum,
969                     param_index,
970                 )
971                 newcalls.append(newcallspec)
972         self._calls = newcalls
973 
974     def _resolve_arg_ids(
975         self,
976         argnames: typing.Sequence[str],
977         ids: Optional[
978             Union[
979                 Iterable[Union[None, str, float, int, bool]],
980                 Callable[[object], Optional[object]],
981             ]
982         ],
983         parameters: typing.Sequence[ParameterSet],
984         item,
985     ) -> List[str]:
986         """Resolves the actual ids for the given argnames, based on the ``ids`` parameter given
987         to ``parametrize``.
988 
989         :param List[str] argnames: list of argument names passed to ``parametrize()``.
990         :param ids: the ids parameter of the parametrized call (see docs).
991         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.
992         :param Item item: the item that generated this parametrized call.
993         :rtype: List[str]
994         :return: the list of ids for each argname given
995         """
996         if ids is None:
997             idfn = None
998             ids_ = None
999         elif callable(ids):
1000             idfn = ids
1001             ids_ = None
1002         else:
1003             idfn = None
1004             ids_ = self._validate_ids(ids, parameters, self.function.__name__)
1005         return idmaker(argnames, parameters, idfn, ids_, self.config, item=item)
1006 
1007     def _validate_ids(
1008         self,
1009         ids: Iterable[Union[None, str, float, int, bool]],
1010         parameters: typing.Sequence[ParameterSet],
1011         func_name: str,
1012     ) -> List[Union[None, str]]:
1013         try:
1014             num_ids = len(ids)  # type: ignore[arg-type] # noqa: F821
1015         except TypeError:
1016             try:
1017                 iter(ids)
1018             except TypeError:
1019                 raise TypeError("ids must be a callable or an iterable")
1020             num_ids = len(parameters)
1021 
1022         # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849
1023         if num_ids != len(parameters) and num_ids != 0:
1024             msg = "In {}: {} parameter sets specified, with different number of ids: {}"
1025             fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)
1026 
1027         new_ids = []
1028         for idx, id_value in enumerate(itertools.islice(ids, num_ids)):
1029             if id_value is None or isinstance(id_value, str):
1030                 new_ids.append(id_value)
1031             elif isinstance(id_value, (float, int, bool)):
1032                 new_ids.append(str(id_value))
1033             else:
1034                 msg = "In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}"
1035                 fail(
1036                     msg.format(func_name, saferepr(id_value), type(id_value), idx),
1037                     pytrace=False,
1038                 )
1039         return new_ids
1040 
1041     def _resolve_arg_value_types(
1042         self,
1043         argnames: typing.Sequence[str],
1044         indirect: Union[bool, typing.Sequence[str]],
1045     ) -> Dict[str, str]:
1046         """Resolves if each parametrized argument must be considered a parameter to a fixture or a "funcarg"
1047         to the function, based on the ``indirect`` parameter of the parametrized() call.
1048 
1049         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1050         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1051         :rtype: Dict[str, str]
1052             A dict mapping each arg name to either:
1053             * "params" if the argname should be the parameter of a fixture of the same name.
1054             * "funcargs" if the argname should be a parameter to the parametrized test function.
1055         """
1056         if isinstance(indirect, bool):
1057             valtypes = dict.fromkeys(argnames, "params" if indirect else "funcargs")
1058         elif isinstance(indirect, Sequence):
1059             valtypes = dict.fromkeys(argnames, "funcargs")
1060             for arg in indirect:
1061                 if arg not in argnames:
1062                     fail(
1063                         "In {}: indirect fixture '{}' doesn't exist".format(
1064                             self.function.__name__, arg
1065                         ),
1066                         pytrace=False,
1067                     )
1068                 valtypes[arg] = "params"
1069         else:
1070             fail(
1071                 "In {func}: expected Sequence or boolean for indirect, got {type}".format(
1072                     type=type(indirect).__name__, func=self.function.__name__
1073                 ),
1074                 pytrace=False,
1075             )
1076         return valtypes
1077 
1078     def _validate_if_using_arg_names(
1079         self,
1080         argnames: typing.Sequence[str],
1081         indirect: Union[bool, typing.Sequence[str]],
1082     ) -> None:
1083         """
1084         Check if all argnames are being used, by default values, or directly/indirectly.
1085 
1086         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1087         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1088         :raise ValueError: if validation fails.
1089         """
1090         default_arg_names = set(get_default_arg_names(self.function))
1091         func_name = self.function.__name__
1092         for arg in argnames:
1093             if arg not in self.fixturenames:
1094                 if arg in default_arg_names:
1095                     fail(
1096                         "In {}: function already takes an argument '{}' with a default value".format(
1097                             func_name, arg
1098                         ),
1099                         pytrace=False,
1100                     )
1101                 else:
1102                     if isinstance(indirect, Sequence):
1103                         name = "fixture" if arg in indirect else "argument"
1104                     else:
1105                         name = "fixture" if indirect else "argument"
1106                     fail(
1107                         "In {}: function uses no {} '{}'".format(func_name, name, arg),
1108                         pytrace=False,
1109                     )
1110 
1111     def _validate_explicit_parameters(
1112         self,
1113         argnames: typing.Sequence[str],
1114         indirect: Union[bool, typing.Sequence[str]],
1115     ) -> None:
1116         """
1117         The argnames in *parametrize* should either be declared explicitly via
1118         indirect list or in the function signature
1119 
1120         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1121         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1122         :raise ValueError: if validation fails
1123         """
1124         if isinstance(indirect, bool):
1125             parametrized_argnames = [] if indirect else argnames
1126         else:
1127             parametrized_argnames = [arg for arg in argnames if arg not in indirect]
1128 
1129         if not parametrized_argnames:
1130             return
1131 
1132         funcargnames = _pytest.compat.getfuncargnames(self.function)
1133         usefixtures = fixtures.get_use_fixtures_for_node(self.definition)
1134 
1135         for arg in parametrized_argnames:
1136             if arg not in funcargnames and arg not in usefixtures:
1137                 func_name = self.function.__name__
1138                 msg = (
1139                     'In function "{func_name}":\n'
1140                     'Parameter "{arg}" should be declared explicitly via indirect or in function itself'
1141                 ).format(func_name=func_name, arg=arg)
1142                 fail(msg, pytrace=False)
1143 
1144 
1145 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):
1146     """Find the most appropriate scope for a parametrized call based on its arguments.
1147 
1148     When there's at least one direct argument, always use "function" scope.
1149 
1150     When a test function is parametrized and all its arguments are indirect
1151     (e.g. fixtures), return the most narrow scope based on the fixtures used.
1152 
1153     Related to issue #1832, based on code posted by @Kingdread.
1154     """
1155     from _pytest.fixtures import scopes
1156 
1157     if isinstance(indirect, (list, tuple)):
1158         all_arguments_are_fixtures = len(indirect) == len(argnames)
1159     else:
1160         all_arguments_are_fixtures = bool(indirect)
1161 
1162     if all_arguments_are_fixtures:
1163         fixturedefs = arg2fixturedefs or {}
1164         used_scopes = [
1165             fixturedef[0].scope
1166             for name, fixturedef in fixturedefs.items()
1167             if name in argnames
1168         ]
1169         if used_scopes:
1170             # Takes the most narrow scope from used fixtures
1171             for scope in reversed(scopes):
1172                 if scope in used_scopes:
1173                     return scope
1174 
1175     return "function"
1176 
1177 
1178 def _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:
1179     if config is None:
1180         escape_option = False
1181     else:
1182         escape_option = config.getini(
1183             "disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
1184         )
1185     # TODO: If escaping is turned off and the user passes bytes,
1186     #       will return a bytes. For now we ignore this but the
1187     #       code *probably* doesn't handle this case.
1188     return val if escape_option else ascii_escaped(val)  # type: ignore
1189 
1190 
1191 def _idval(
1192     val: object,
1193     argname: str,
1194     idx: int,
1195     idfn: Optional[Callable[[object], Optional[object]]],
1196     item,
1197     config: Optional[Config],
1198 ) -> str:
1199     if idfn:
1200         try:
1201             generated_id = idfn(val)
1202             if generated_id is not None:
1203                 val = generated_id
1204         except Exception as e:
1205             msg = "{}: error raised while trying to determine id of parameter '{}' at position {}"
1206             msg = msg.format(item.nodeid, argname, idx)
1207             raise ValueError(msg) from e
1208     elif config:
1209         hook_id = config.hook.pytest_make_parametrize_id(
1210             config=config, val=val, argname=argname
1211         )  # type: Optional[str]
1212         if hook_id:
1213             return hook_id
1214 
1215     if isinstance(val, STRING_TYPES):
1216         return _ascii_escaped_by_config(val, config)
1217     elif val is None or isinstance(val, (float, int, bool)):
1218         return str(val)
1219     elif isinstance(val, REGEX_TYPE):
1220         return ascii_escaped(val.pattern)
1221     elif isinstance(val, enum.Enum):
1222         return str(val)
1223     elif isinstance(getattr(val, "__name__", None), str):
1224         # name of a class, function, module, etc.
1225         name = getattr(val, "__name__")  # type: str
1226         return name
1227     return str(argname) + str(idx)
1228 
1229 
1230 def _idvalset(
1231     idx: int,
1232     parameterset: ParameterSet,
1233     argnames: Iterable[str],
1234     idfn: Optional[Callable[[object], Optional[object]]],
1235     ids: Optional[List[Union[None, str]]],
1236     item,
1237     config: Optional[Config],
1238 ):
1239     if parameterset.id is not None:
1240         return parameterset.id
1241     id = None if ids is None or idx >= len(ids) else ids[idx]
1242     if id is None:
1243         this_id = [
1244             _idval(val, argname, idx, idfn, item=item, config=config)
1245             for val, argname in zip(parameterset.values, argnames)
1246         ]
1247         return "-".join(this_id)
1248     else:
1249         return _ascii_escaped_by_config(id, config)
1250 
1251 
1252 def idmaker(
1253     argnames: Iterable[str],
1254     parametersets: Iterable[ParameterSet],
1255     idfn: Optional[Callable[[object], Optional[object]]] = None,
1256     ids: Optional[List[Union[None, str]]] = None,
1257     config: Optional[Config] = None,
1258     item=None,
1259 ) -> List[str]:
1260     resolved_ids = [
1261         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)
1262         for valindex, parameterset in enumerate(parametersets)
1263     ]
1264 
1265     # All IDs must be unique!
1266     unique_ids = set(resolved_ids)
1267     if len(unique_ids) != len(resolved_ids):
1268 
1269         # Record the number of occurrences of each test ID
1270         test_id_counts = Counter(resolved_ids)
1271 
1272         # Map the test ID to its next suffix
1273         test_id_suffixes = defaultdict(int)  # type: Dict[str, int]
1274 
1275         # Suffix non-unique IDs to make them unique
1276         for index, test_id in enumerate(resolved_ids):
1277             if test_id_counts[test_id] > 1:
1278                 resolved_ids[index] = "{}{}".format(test_id, test_id_suffixes[test_id])
1279                 test_id_suffixes[test_id] += 1
1280 
1281     return resolved_ids
1282 
1283 
1284 def show_fixtures_per_test(config):
1285     from _pytest.main import wrap_session
1286 
1287     return wrap_session(config, _show_fixtures_per_test)
1288 
1289 
1290 def _show_fixtures_per_test(config, session):
1291     import _pytest.config
1292 
1293     session.perform_collect()
1294     curdir = py.path.local()
1295     tw = _pytest.config.create_terminal_writer(config)
1296     verbose = config.getvalue("verbose")
1297 
1298     def get_best_relpath(func):
1299         loc = getlocation(func, curdir)
1300         return curdir.bestrelpath(loc)
1301 
1302     def write_fixture(fixture_def):
1303         argname = fixture_def.argname
1304         if verbose <= 0 and argname.startswith("_"):
1305             return
1306         if verbose > 0:
1307             bestrel = get_best_relpath(fixture_def.func)
1308             funcargspec = "{} -- {}".format(argname, bestrel)
1309         else:
1310             funcargspec = argname
1311         tw.line(funcargspec, green=True)
1312         fixture_doc = inspect.getdoc(fixture_def.func)
1313         if fixture_doc:
1314             write_docstring(tw, fixture_doc)
1315         else:
1316             tw.line("    no docstring available", red=True)
1317 
1318     def write_item(item):
1319         try:
1320             info = item._fixtureinfo
1321         except AttributeError:
1322             # doctests items have no _fixtureinfo attribute
1323             return
1324         if not info.name2fixturedefs:
1325             # this test item does not use any fixtures
1326             return
1327         tw.line()
1328         tw.sep("-", "fixtures used by {}".format(item.name))
1329         tw.sep("-", "({})".format(get_best_relpath(item.function)))
1330         # dict key not used in loop but needed for sorting
1331         for _, fixturedefs in sorted(info.name2fixturedefs.items()):
1332             assert fixturedefs is not None
1333             if not fixturedefs:
1334                 continue
1335             # last item is expected to be the one used by the test item
1336             write_fixture(fixturedefs[-1])
1337 
1338     for session_item in session.items:
1339         write_item(session_item)
1340 
1341 
1342 def showfixtures(config):
1343     from _pytest.main import wrap_session
1344 
1345     return wrap_session(config, _showfixtures_main)
1346 
1347 
1348 def _showfixtures_main(config, session):
1349     import _pytest.config
1350 
1351     session.perform_collect()
1352     curdir = py.path.local()
1353     tw = _pytest.config.create_terminal_writer(config)
1354     verbose = config.getvalue("verbose")
1355 
1356     fm = session._fixturemanager
1357 
1358     available = []
1359     seen = set()
1360 
1361     for argname, fixturedefs in fm._arg2fixturedefs.items():
1362         assert fixturedefs is not None
1363         if not fixturedefs:
1364             continue
1365         for fixturedef in fixturedefs:
1366             loc = getlocation(fixturedef.func, curdir)
1367             if (fixturedef.argname, loc) in seen:
1368                 continue
1369             seen.add((fixturedef.argname, loc))
1370             available.append(
1371                 (
1372                     len(fixturedef.baseid),
1373                     fixturedef.func.__module__,
1374                     curdir.bestrelpath(loc),
1375                     fixturedef.argname,
1376                     fixturedef,
1377                 )
1378             )
1379 
1380     available.sort()
1381     currentmodule = None
1382     for baseid, module, bestrel, argname, fixturedef in available:
1383         if currentmodule != module:
1384             if not module.startswith("_pytest."):
1385                 tw.line()
1386                 tw.sep("-", "fixtures defined from {}".format(module))
1387                 currentmodule = module
1388         if verbose <= 0 and argname[0] == "_":
1389             continue
1390         tw.write(argname, green=True)
1391         if fixturedef.scope != "function":
1392             tw.write(" [%s scope]" % fixturedef.scope, cyan=True)
1393         if verbose > 0:
1394             tw.write(" -- %s" % bestrel, yellow=True)
1395         tw.write("\n")
1396         loc = getlocation(fixturedef.func, curdir)
1397         doc = inspect.getdoc(fixturedef.func)
1398         if doc:
1399             write_docstring(tw, doc)
1400         else:
1401             tw.line("    {}: no docstring available".format(loc), red=True)
1402         tw.line()
1403 
1404 
1405 def write_docstring(tw: TerminalWriter, doc: str, indent: str = "    ") -> None:
1406     for line in doc.split("\n"):
1407         tw.write(indent + line + "\n")
1408 
1409 
1410 class Function(PyobjMixin, nodes.Item):
1411     """ a Function Item is responsible for setting up and executing a
1412     Python test function.
1413     """
1414 
1415     # disable since functions handle it themselves
1416     _ALLOW_MARKERS = False
1417 
1418     def __init__(
1419         self,
1420         name,
1421         parent,
1422         args=None,
1423         config=None,
1424         callspec: Optional[CallSpec2] = None,
1425         callobj=NOTSET,
1426         keywords=None,
1427         session=None,
1428         fixtureinfo: Optional[FuncFixtureInfo] = None,
1429         originalname=None,
1430     ) -> None:
1431         super().__init__(name, parent, config=config, session=session)
1432         self._args = args
1433         if callobj is not NOTSET:
1434             self.obj = callobj
1435 
1436         self.keywords.update(self.obj.__dict__)
1437         self.own_markers.extend(get_unpacked_marks(self.obj))
1438         if callspec:
1439             self.callspec = callspec
1440             # this is total hostile and a mess
1441             # keywords are broken by design by now
1442             # this will be redeemed later
1443             for mark in callspec.marks:
1444                 # feel free to cry, this was broken for years before
1445                 # and keywords cant fix it per design
1446                 self.keywords[mark.name] = mark
1447             self.own_markers.extend(normalize_mark_list(callspec.marks))
1448         if keywords:
1449             self.keywords.update(keywords)
1450 
1451         # todo: this is a hell of a hack
1452         # https://github.com/pytest-dev/pytest/issues/4569
1453 
1454         self.keywords.update(
1455             {
1456                 mark.name: True
1457                 for mark in self.iter_markers()
1458                 if mark.name not in self.keywords
1459             }
1460         )
1461 
1462         if fixtureinfo is None:
1463             fixtureinfo = self.session._fixturemanager.getfixtureinfo(
1464                 self, self.obj, self.cls, funcargs=True
1465             )
1466         self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo
1467         self.fixturenames = fixtureinfo.names_closure
1468         self._initrequest()
1469 
1470         #: original function name, without any decorations (for example
1471         #: parametrization adds a ``"[...]"`` suffix to function names).
1472         #:
1473         #: .. versionadded:: 3.0
1474         self.originalname = originalname
1475 
1476     @classmethod
1477     def from_parent(cls, parent, **kw):  # todo: determine sound type limitations
1478         """
1479         The public  constructor
1480         """
1481         return super().from_parent(parent=parent, **kw)
1482 
1483     def _initrequest(self):
1484         self.funcargs = {}
1485         self._request = fixtures.FixtureRequest(self)
1486 
1487     @property
1488     def function(self):
1489         "underlying python 'function' object"
1490         return getimfunc(self.obj)
1491 
1492     def _getobj(self):
1493         name = self.name
1494         i = name.find("[")  # parametrization
1495         if i != -1:
1496             name = name[:i]
1497         return getattr(self.parent.obj, name)
1498 
1499     @property
1500     def _pyfuncitem(self):
1501         "(compatonly) for code expecting pytest-2.2 style request objects"
1502         return self
1503 
1504     @property
1505     def funcargnames(self):
1506         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
1507         warnings.warn(FUNCARGNAMES, stacklevel=2)
1508         return self.fixturenames
1509 
1510     def runtest(self) -> None:
1511         """ execute the underlying test function. """
1512         self.ihook.pytest_pyfunc_call(pyfuncitem=self)
1513 
1514     def setup(self) -> None:
1515         if isinstance(self.parent, Instance):
1516             self.parent.newinstance()
1517             self.obj = self._getobj()
1518         self._request._fillfixtures()
1519 
1520     def _prunetraceback(self, excinfo: ExceptionInfo) -> None:
1521         if hasattr(self, "_obj") and not self.config.getoption("fulltrace", False):
1522             code = _pytest._code.Code(get_real_func(self.obj))
1523             path, firstlineno = code.path, code.firstlineno
1524             traceback = excinfo.traceback
1525             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)
1526             if ntraceback == traceback:
1527                 ntraceback = ntraceback.cut(path=path)
1528                 if ntraceback == traceback:
1529                     ntraceback = ntraceback.filter(filter_traceback)
1530                     if not ntraceback:
1531                         ntraceback = traceback
1532 
1533             excinfo.traceback = ntraceback.filter()
1534             # issue364: mark all but first and last frames to
1535             # only show a single-line message for each frame
1536             if self.config.getoption("tbstyle", "auto") == "auto":
1537                 if len(excinfo.traceback) > 2:
1538                     for entry in excinfo.traceback[1:-1]:
1539                         entry.set_repr_style("short")
1540 
1541     def repr_failure(self, excinfo, outerr=None):
1542         assert outerr is None, "XXX outerr usage is deprecated"
1543         style = self.config.getoption("tbstyle", "auto")
1544         if style == "auto":
1545             style = "long"
1546         return self._repr_failure_py(excinfo, style=style)
1547 
1548 
1549 class FunctionDefinition(Function):
1550     """
1551     internal hack until we get actual definition nodes instead of the
1552     crappy metafunc hack
1553     """
1554 
1555     def runtest(self) -> None:
1556         raise RuntimeError("function definitions are not supposed to be used")
1557 
1558     setup = runtest

</code><intended_behavior>Given the extensive role of this file in handling Python test items, including their collection and reporting, a deeper look into the methods that prepare test reports, especially skipped tests, might be required. The intended behavior here would be to ensure that when tests are skipped, and the reports are being prepared, any paths are accurately construed relative to the invocation point or adjusted accordingly if the computation of relative paths is found to be incorrect or not applied at this stage. This adjustment would correct the issue where paths are not shown as expected when tests are skipped.</intended_behavior>]
2025-10-18 16:28:37.144 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 16:28:37.144 | INFO     | Search-only: skipping patch selection
2025-10-18 16:28:37.228 | INFO     | Task pytest-dev__pytest-7158 completed successfully.
2025-10-18 16:28:37.229 | INFO     | No patch generated. You can try running ACR again.
