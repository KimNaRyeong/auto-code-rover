[
    {
        "rel_file_path": "src/_pytest/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__5.4/src/_pytest/main.py",
        "start": 1,
        "end": 685,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" core implementation of testing process: init, session, runtest loop. \"\"\"\n2 import fnmatch\n3 import functools\n4 import importlib\n5 import os\n6 import sys\n7 from typing import Callable\n8 from typing import Dict\n9 from typing import FrozenSet\n10 from typing import List\n11 from typing import Optional\n12 from typing import Sequence\n13 from typing import Tuple\n14 from typing import Union\n15 \n16 import attr\n17 import py\n18 \n19 import _pytest._code\n20 from _pytest import nodes\n21 from _pytest.compat import TYPE_CHECKING\n22 from _pytest.config import Config\n23 from _pytest.config import directory_arg\n24 from _pytest.config import ExitCode\n25 from _pytest.config import hookimpl\n26 from _pytest.config import UsageError\n27 from _pytest.fixtures import FixtureManager\n28 from _pytest.outcomes import exit\n29 from _pytest.reports import CollectReport\n30 from _pytest.runner import collect_one_node\n31 from _pytest.runner import SetupState\n32 \n33 \n34 if TYPE_CHECKING:\n35     from typing import Type\n36     from typing_extensions import Literal\n37 \n38     from _pytest.python import Package\n39 \n40 \n41 def pytest_addoption(parser):\n42     parser.addini(\n43         \"norecursedirs\",\n44         \"directory patterns to avoid for recursion\",\n45         type=\"args\",\n46         default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n47     )\n48     parser.addini(\n49         \"testpaths\",\n50         \"directories to search for tests when no files or directories are given in the \"\n51         \"command line.\",\n52         type=\"args\",\n53         default=[],\n54     )\n55     group = parser.getgroup(\"general\", \"running and selection options\")\n56     group._addoption(\n57         \"-x\",\n58         \"--exitfirst\",\n59         action=\"store_const\",\n60         dest=\"maxfail\",\n61         const=1,\n62         help=\"exit instantly on first error or failed test.\",\n63     )\n64     group._addoption(\n65         \"--maxfail\",\n66         metavar=\"num\",\n67         action=\"store\",\n68         type=int,\n69         dest=\"maxfail\",\n70         default=0,\n71         help=\"exit after first num failures or errors.\",\n72     )\n73     group._addoption(\n74         \"--strict-markers\",\n75         \"--strict\",\n76         action=\"store_true\",\n77         help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n78     )\n79     group._addoption(\n80         \"-c\",\n81         metavar=\"file\",\n82         type=str,\n83         dest=\"inifilename\",\n84         help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n85         \"configuration files.\",\n86     )\n87     group._addoption(\n88         \"--continue-on-collection-errors\",\n89         action=\"store_true\",\n90         default=False,\n91         dest=\"continue_on_collection_errors\",\n92         help=\"Force test execution even if collection errors occur.\",\n93     )\n94     group._addoption(\n95         \"--rootdir\",\n96         action=\"store\",\n97         dest=\"rootdir\",\n98         help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n99         \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n100         \"'$HOME/root_dir'.\",\n101     )\n102 \n103     group = parser.getgroup(\"collect\", \"collection\")\n104     group.addoption(\n105         \"--collectonly\",\n106         \"--collect-only\",\n107         \"--co\",\n108         action=\"store_true\",\n109         help=\"only collect tests, don't execute them.\",\n110     )\n111     group.addoption(\n112         \"--pyargs\",\n113         action=\"store_true\",\n114         help=\"try to interpret all arguments as python packages.\",\n115     )\n116     group.addoption(\n117         \"--ignore\",\n118         action=\"append\",\n119         metavar=\"path\",\n120         help=\"ignore path during collection (multi-allowed).\",\n121     )\n122     group.addoption(\n123         \"--ignore-glob\",\n124         action=\"append\",\n125         metavar=\"path\",\n126         help=\"ignore path pattern during collection (multi-allowed).\",\n127     )\n128     group.addoption(\n129         \"--deselect\",\n130         action=\"append\",\n131         metavar=\"nodeid_prefix\",\n132         help=\"deselect item (via node id prefix) during collection (multi-allowed).\",\n133     )\n134     group.addoption(\n135         \"--confcutdir\",\n136         dest=\"confcutdir\",\n137         default=None,\n138         metavar=\"dir\",\n139         type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n140         help=\"only load conftest.py's relative to specified dir.\",\n141     )\n142     group.addoption(\n143         \"--noconftest\",\n144         action=\"store_true\",\n145         dest=\"noconftest\",\n146         default=False,\n147         help=\"Don't load any conftest.py files.\",\n148     )\n149     group.addoption(\n150         \"--keepduplicates\",\n151         \"--keep-duplicates\",\n152         action=\"store_true\",\n153         dest=\"keepduplicates\",\n154         default=False,\n155         help=\"Keep duplicate tests.\",\n156     )\n157     group.addoption(\n158         \"--collect-in-virtualenv\",\n159         action=\"store_true\",\n160         dest=\"collect_in_virtualenv\",\n161         default=False,\n162         help=\"Don't ignore tests in a local virtualenv directory\",\n163     )\n164 \n165     group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n166     group.addoption(\n167         \"--basetemp\",\n168         dest=\"basetemp\",\n169         default=None,\n170         metavar=\"dir\",\n171         help=(\n172             \"base temporary directory for this test run.\"\n173             \"(warning: this directory is removed if it exists)\"\n174         ),\n175     )\n176 \n177 \n178 def wrap_session(\n179     config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n180 ) -> Union[int, ExitCode]:\n181     \"\"\"Skeleton command line program\"\"\"\n182     session = Session.from_config(config)\n183     session.exitstatus = ExitCode.OK\n184     initstate = 0\n185     try:\n186         try:\n187             config._do_configure()\n188             initstate = 1\n189             config.hook.pytest_sessionstart(session=session)\n190             initstate = 2\n191             session.exitstatus = doit(config, session) or 0\n192         except UsageError:\n193             session.exitstatus = ExitCode.USAGE_ERROR\n194             raise\n195         except Failed:\n196             session.exitstatus = ExitCode.TESTS_FAILED\n197         except (KeyboardInterrupt, exit.Exception):\n198             excinfo = _pytest._code.ExceptionInfo.from_current()\n199             exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n200             if isinstance(excinfo.value, exit.Exception):\n201                 if excinfo.value.returncode is not None:\n202                     exitstatus = excinfo.value.returncode\n203                 if initstate < 2:\n204                     sys.stderr.write(\n205                         \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n206                     )\n207             config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n208             session.exitstatus = exitstatus\n209         except:  # noqa\n210             session.exitstatus = ExitCode.INTERNAL_ERROR\n211             excinfo = _pytest._code.ExceptionInfo.from_current()\n212             try:\n213                 config.notify_exception(excinfo, config.option)\n214             except exit.Exception as exc:\n215                 if exc.returncode is not None:\n216                     session.exitstatus = exc.returncode\n217                 sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n218             else:\n219                 if excinfo.errisinstance(SystemExit):\n220                     sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n221 \n222     finally:\n223         # Explicitly break reference cycle.\n224         excinfo = None  # type: ignore\n225         session.startdir.chdir()\n226         if initstate >= 2:\n227             try:\n228                 config.hook.pytest_sessionfinish(\n229                     session=session, exitstatus=session.exitstatus\n230                 )\n231             except exit.Exception as exc:\n232                 if exc.returncode is not None:\n233                     session.exitstatus = exc.returncode\n234                 sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n235         config._ensure_unconfigure()\n236     return session.exitstatus\n237 \n238 \n239 def pytest_cmdline_main(config):\n240     return wrap_session(config, _main)\n241 \n242 \n243 def _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n244     \"\"\" default command line protocol for initialization, session,\n245     running tests and reporting. \"\"\"\n246     config.hook.pytest_collection(session=session)\n247     config.hook.pytest_runtestloop(session=session)\n248 \n249     if session.testsfailed:\n250         return ExitCode.TESTS_FAILED\n251     elif session.testscollected == 0:\n252         return ExitCode.NO_TESTS_COLLECTED\n253     return None\n254 \n255 \n256 def pytest_collection(session):\n257     return session.perform_collect()\n258 \n259 \n260 def pytest_runtestloop(session):\n261     if session.testsfailed and not session.config.option.continue_on_collection_errors:\n262         raise session.Interrupted(\n263             \"%d error%s during collection\"\n264             % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n265         )\n266 \n267     if session.config.option.collectonly:\n268         return True\n269 \n270     for i, item in enumerate(session.items):\n271         nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n272         item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n273         if session.shouldfail:\n274             raise session.Failed(session.shouldfail)\n275         if session.shouldstop:\n276             raise session.Interrupted(session.shouldstop)\n277     return True\n278 \n279 \n280 def _in_venv(path):\n281     \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n282     checking for the existence of the appropriate activate script\"\"\"\n283     bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n284     if not bindir.isdir():\n285         return False\n286     activates = (\n287         \"activate\",\n288         \"activate.csh\",\n289         \"activate.fish\",\n290         \"Activate\",\n291         \"Activate.bat\",\n292         \"Activate.ps1\",\n293     )\n294     return any([fname.basename in activates for fname in bindir.listdir()])\n295 \n296 \n297 def pytest_ignore_collect(\n298     path: py.path.local, config: Config\n299 ) -> \"Optional[Literal[True]]\":\n300     ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n301     ignore_paths = ignore_paths or []\n302     excludeopt = config.getoption(\"ignore\")\n303     if excludeopt:\n304         ignore_paths.extend([py.path.local(x) for x in excludeopt])\n305 \n306     if py.path.local(path) in ignore_paths:\n307         return True\n308 \n309     ignore_globs = config._getconftest_pathlist(\n310         \"collect_ignore_glob\", path=path.dirpath()\n311     )\n312     ignore_globs = ignore_globs or []\n313     excludeglobopt = config.getoption(\"ignore_glob\")\n314     if excludeglobopt:\n315         ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n316 \n317     if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):\n318         return True\n319 \n320     allow_in_venv = config.getoption(\"collect_in_virtualenv\")\n321     if not allow_in_venv and _in_venv(path):\n322         return True\n323     return None\n324 \n325 \n326 def pytest_collection_modifyitems(items, config):\n327     deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n328     if not deselect_prefixes:\n329         return\n330 \n331     remaining = []\n332     deselected = []\n333     for colitem in items:\n334         if colitem.nodeid.startswith(deselect_prefixes):\n335             deselected.append(colitem)\n336         else:\n337             remaining.append(colitem)\n338 \n339     if deselected:\n340         config.hook.pytest_deselected(items=deselected)\n341         items[:] = remaining\n342 \n343 \n344 class NoMatch(Exception):\n345     \"\"\" raised if matching cannot locate a matching names. \"\"\"\n346 \n347 \n348 class Interrupted(KeyboardInterrupt):\n349     \"\"\" signals an interrupted test run. \"\"\"\n350 \n351     __module__ = \"builtins\"  # for py3\n352 \n353 \n354 class Failed(Exception):\n355     \"\"\" signals a stop as failed test run. \"\"\"\n356 \n357 \n358 @attr.s\n359 class _bestrelpath_cache(dict):\n360     path = attr.ib(type=py.path.local)\n361 \n362     def __missing__(self, path: py.path.local) -> str:\n363         r = self.path.bestrelpath(path)  # type: str\n364         self[path] = r\n365         return r\n366 \n367 \n368 class Session(nodes.FSCollector):\n369     Interrupted = Interrupted\n370     Failed = Failed\n371     # Set on the session by runner.pytest_sessionstart.\n372     _setupstate = None  # type: SetupState\n373     # Set on the session by fixtures.pytest_sessionstart.\n374     _fixturemanager = None  # type: FixtureManager\n375     exitstatus = None  # type: Union[int, ExitCode]\n376 \n377     def __init__(self, config: Config) -> None:\n378         nodes.FSCollector.__init__(\n379             self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n380         )\n381         self.testsfailed = 0\n382         self.testscollected = 0\n383         self.shouldstop = False\n384         self.shouldfail = False\n385         self.trace = config.trace.root.get(\"collection\")\n386         self.startdir = config.invocation_dir\n387         self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n388 \n389         # Keep track of any collected nodes in here, so we don't duplicate fixtures\n390         self._collection_node_cache1 = (\n391             {}\n392         )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n393         self._collection_node_cache2 = (\n394             {}\n395         )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n396         self._collection_node_cache3 = (\n397             {}\n398         )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n399 \n400         # Dirnames of pkgs with dunder-init files.\n401         self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n402 \n403         self._bestrelpathcache = _bestrelpath_cache(\n404             config.rootdir\n405         )  # type: Dict[py.path.local, str]\n406 \n407         self.config.pluginmanager.register(self, name=\"session\")\n408 \n409     @classmethod\n410     def from_config(cls, config):\n411         return cls._create(config)\n412 \n413     def __repr__(self):\n414         return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n415             self.__class__.__name__,\n416             self.name,\n417             getattr(self, \"exitstatus\", \"<UNSET>\"),\n418             self.testsfailed,\n419             self.testscollected,\n420         )\n421 \n422     def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n423         # bestrelpath is a quite slow function\n424         return self._bestrelpathcache[node_path]\n425 \n426     @hookimpl(tryfirst=True)\n427     def pytest_collectstart(self):\n428         if self.shouldfail:\n429             raise self.Failed(self.shouldfail)\n430         if self.shouldstop:\n431             raise self.Interrupted(self.shouldstop)\n432 \n433     @hookimpl(tryfirst=True)\n434     def pytest_runtest_logreport(self, report):\n435         if report.failed and not hasattr(report, \"wasxfail\"):\n436             self.testsfailed += 1\n437             maxfail = self.config.getvalue(\"maxfail\")\n438             if maxfail and self.testsfailed >= maxfail:\n439                 self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n440 \n441     pytest_collectreport = pytest_runtest_logreport\n442 \n443     def isinitpath(self, path):\n444         return path in self._initialpaths\n445 \n446     def gethookproxy(self, fspath: py.path.local):\n447         return super()._gethookproxy(fspath)\n448 \n449     def perform_collect(self, args=None, genitems=True):\n450         hook = self.config.hook\n451         try:\n452             items = self._perform_collect(args, genitems)\n453             self.config.pluginmanager.check_pending()\n454             hook.pytest_collection_modifyitems(\n455                 session=self, config=self.config, items=items\n456             )\n457         finally:\n458             hook.pytest_collection_finish(session=self)\n459         self.testscollected = len(items)\n460         return items\n461 \n462     def _perform_collect(self, args, genitems):\n463         if args is None:\n464             args = self.config.args\n465         self.trace(\"perform_collect\", self, args)\n466         self.trace.root.indent += 1\n467         self._notfound = []\n468         initialpaths = []  # type: List[py.path.local]\n469         self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n470         self.items = items = []\n471         for arg in args:\n472             fspath, parts = self._parsearg(arg)\n473             self._initial_parts.append((fspath, parts))\n474             initialpaths.append(fspath)\n475         self._initialpaths = frozenset(initialpaths)\n476         rep = collect_one_node(self)\n477         self.ihook.pytest_collectreport(report=rep)\n478         self.trace.root.indent -= 1\n479         if self._notfound:\n480             errors = []\n481             for arg, exc in self._notfound:\n482                 line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n483                 errors.append(\"not found: {}\\n{}\".format(arg, line))\n484             raise UsageError(*errors)\n485         if not genitems:\n486             return rep.result\n487         else:\n488             if rep.passed:\n489                 for node in rep.result:\n490                     self.items.extend(self.genitems(node))\n491             return items\n492 \n493     def collect(self):\n494         for fspath, parts in self._initial_parts:\n495             self.trace(\"processing argument\", (fspath, parts))\n496             self.trace.root.indent += 1\n497             try:\n498                 yield from self._collect(fspath, parts)\n499             except NoMatch as exc:\n500                 report_arg = \"::\".join((str(fspath), *parts))\n501                 # we are inside a make_report hook so\n502                 # we cannot directly pass through the exception\n503                 self._notfound.append((report_arg, exc))\n504 \n505             self.trace.root.indent -= 1\n506         self._collection_node_cache1.clear()\n507         self._collection_node_cache2.clear()\n508         self._collection_node_cache3.clear()\n509         self._collection_pkg_roots.clear()\n510 \n511     def _collect(self, argpath, names):\n512         from _pytest.python import Package\n513 \n514         # Start with a Session root, and delve to argpath item (dir or file)\n515         # and stack all Packages found on the way.\n516         # No point in finding packages when collecting doctests\n517         if not self.config.getoption(\"doctestmodules\", False):\n518             pm = self.config.pluginmanager\n519             for parent in reversed(argpath.parts()):\n520                 if pm._confcutdir and pm._confcutdir.relto(parent):\n521                     break\n522 \n523                 if parent.isdir():\n524                     pkginit = parent.join(\"__init__.py\")\n525                     if pkginit.isfile():\n526                         if pkginit not in self._collection_node_cache1:\n527                             col = self._collectfile(pkginit, handle_dupes=False)\n528                             if col:\n529                                 if isinstance(col[0], Package):\n530                                     self._collection_pkg_roots[parent] = col[0]\n531                                 # always store a list in the cache, matchnodes expects it\n532                                 self._collection_node_cache1[col[0].fspath] = [col[0]]\n533 \n534         # If it's a directory argument, recurse and look for any Subpackages.\n535         # Let the Package collector deal with subnodes, don't collect here.\n536         if argpath.check(dir=1):\n537             assert not names, \"invalid arg {!r}\".format((argpath, names))\n538 \n539             seen_dirs = set()\n540             for path in argpath.visit(\n541                 fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n542             ):\n543                 dirpath = path.dirpath()\n544                 if dirpath not in seen_dirs:\n545                     # Collect packages first.\n546                     seen_dirs.add(dirpath)\n547                     pkginit = dirpath.join(\"__init__.py\")\n548                     if pkginit.exists():\n549                         for x in self._collectfile(pkginit):\n550                             yield x\n551                             if isinstance(x, Package):\n552                                 self._collection_pkg_roots[dirpath] = x\n553                 if dirpath in self._collection_pkg_roots:\n554                     # Do not collect packages here.\n555                     continue\n556 \n557                 for x in self._collectfile(path):\n558                     key = (type(x), x.fspath)\n559                     if key in self._collection_node_cache2:\n560                         yield self._collection_node_cache2[key]\n561                     else:\n562                         self._collection_node_cache2[key] = x\n563                         yield x\n564         else:\n565             assert argpath.check(file=1)\n566 \n567             if argpath in self._collection_node_cache1:\n568                 col = self._collection_node_cache1[argpath]\n569             else:\n570                 collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n571                 col = collect_root._collectfile(argpath, handle_dupes=False)\n572                 if col:\n573                     self._collection_node_cache1[argpath] = col\n574             m = self.matchnodes(col, names)\n575             # If __init__.py was the only file requested, then the matched node will be\n576             # the corresponding Package, and the first yielded item will be the __init__\n577             # Module itself, so just use that. If this special case isn't taken, then all\n578             # the files in the package will be yielded.\n579             if argpath.basename == \"__init__.py\":\n580                 try:\n581                     yield next(m[0].collect())\n582                 except StopIteration:\n583                     # The package collects nothing with only an __init__.py\n584                     # file in it, which gets ignored by the default\n585                     # \"python_files\" option.\n586                     pass\n587                 return\n588             yield from m\n589 \n590     @staticmethod\n591     def _visit_filter(f):\n592         return f.check(file=1)\n593 \n594     def _tryconvertpyarg(self, x):\n595         \"\"\"Convert a dotted module name to path.\"\"\"\n596         try:\n597             spec = importlib.util.find_spec(x)\n598         # AttributeError: looks like package module, but actually filename\n599         # ImportError: module does not exist\n600         # ValueError: not a module name\n601         except (AttributeError, ImportError, ValueError):\n602             return x\n603         if spec is None or spec.origin in {None, \"namespace\"}:\n604             return x\n605         elif spec.submodule_search_locations:\n606             return os.path.dirname(spec.origin)\n607         else:\n608             return spec.origin\n609 \n610     def _parsearg(self, arg):\n611         \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n612         strpath, *parts = str(arg).split(\"::\")\n613         if self.config.option.pyargs:\n614             strpath = self._tryconvertpyarg(strpath)\n615         relpath = strpath.replace(\"/\", os.sep)\n616         fspath = self.config.invocation_dir.join(relpath, abs=True)\n617         if not fspath.check():\n618             if self.config.option.pyargs:\n619                 raise UsageError(\n620                     \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n621                 )\n622             raise UsageError(\"file not found: \" + arg)\n623         fspath = fspath.realpath()\n624         return (fspath, parts)\n625 \n626     def matchnodes(self, matching, names):\n627         self.trace(\"matchnodes\", matching, names)\n628         self.trace.root.indent += 1\n629         nodes = self._matchnodes(matching, names)\n630         num = len(nodes)\n631         self.trace(\"matchnodes finished -> \", num, \"nodes\")\n632         self.trace.root.indent -= 1\n633         if num == 0:\n634             raise NoMatch(matching, names[:1])\n635         return nodes\n636 \n637     def _matchnodes(self, matching, names):\n638         if not matching or not names:\n639             return matching\n640         name = names[0]\n641         assert name\n642         nextnames = names[1:]\n643         resultnodes = []\n644         for node in matching:\n645             if isinstance(node, nodes.Item):\n646                 if not names:\n647                     resultnodes.append(node)\n648                 continue\n649             assert isinstance(node, nodes.Collector)\n650             key = (type(node), node.nodeid)\n651             if key in self._collection_node_cache3:\n652                 rep = self._collection_node_cache3[key]\n653             else:\n654                 rep = collect_one_node(node)\n655                 self._collection_node_cache3[key] = rep\n656             if rep.passed:\n657                 has_matched = False\n658                 for x in rep.result:\n659                     # TODO: remove parametrized workaround once collection structure contains parametrization\n660                     if x.name == name or x.name.split(\"[\")[0] == name:\n661                         resultnodes.extend(self.matchnodes([x], nextnames))\n662                         has_matched = True\n663                 # XXX accept IDs that don't have \"()\" for class instances\n664                 if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n665                     nextnames.insert(0, name)\n666                     resultnodes.extend(self.matchnodes([x], nextnames))\n667             else:\n668                 # report collection failures here to avoid failing to run some test\n669                 # specified in the command line because the module could not be\n670                 # imported (#134)\n671                 node.ihook.pytest_collectreport(report=rep)\n672         return resultnodes\n673 \n674     def genitems(self, node):\n675         self.trace(\"genitems\", node)\n676         if isinstance(node, nodes.Item):\n677             node.ihook.pytest_itemcollected(item=node)\n678             yield node\n679         else:\n680             assert isinstance(node, nodes.Collector)\n681             rep = collect_one_node(node)\n682             if rep.passed:\n683                 for subnode in rep.result:\n684                     yield from self.genitems(subnode)\n685             node.ihook.pytest_collectreport(report=rep)\n",
        "intended_behavior": "This file likely interacts with handling test collection and execution paths, including how paths are reported in console outputs. The specific location where skip reports are formatted should ensure that file paths are adjusted to reflect their relative paths from the invocation directory. If file paths are presented as absolute paths during the formatting of skip messages, a modification is needed to convert these paths to be relative based on the current directory from which pytest was invoked. This would resolve the issue by displaying paths in the skip report as the user expects, maintaining uniformity with how paths are referenced throughout pytest's output."
    },
    {
        "rel_file_path": "src/_pytest/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__5.4/src/_pytest/python.py",
        "start": 1,
        "end": 1558,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Python test discovery, setup and run of test functions. \"\"\"\n2 import enum\n3 import fnmatch\n4 import inspect\n5 import itertools\n6 import os\n7 import sys\n8 import typing\n9 import warnings\n10 from collections import Counter\n11 from collections import defaultdict\n12 from collections.abc import Sequence\n13 from functools import partial\n14 from typing import Callable\n15 from typing import Dict\n16 from typing import Iterable\n17 from typing import List\n18 from typing import Optional\n19 from typing import Tuple\n20 from typing import Union\n21 \n22 import py\n23 \n24 import _pytest\n25 from _pytest import fixtures\n26 from _pytest import nodes\n27 from _pytest._code import filter_traceback\n28 from _pytest._code.code import ExceptionInfo\n29 from _pytest._code.source import getfslineno\n30 from _pytest._io import TerminalWriter\n31 from _pytest._io.saferepr import saferepr\n32 from _pytest.compat import ascii_escaped\n33 from _pytest.compat import get_default_arg_names\n34 from _pytest.compat import get_real_func\n35 from _pytest.compat import getimfunc\n36 from _pytest.compat import getlocation\n37 from _pytest.compat import is_async_function\n38 from _pytest.compat import is_generator\n39 from _pytest.compat import NOTSET\n40 from _pytest.compat import REGEX_TYPE\n41 from _pytest.compat import safe_getattr\n42 from _pytest.compat import safe_isclass\n43 from _pytest.compat import STRING_TYPES\n44 from _pytest.config import Config\n45 from _pytest.config import hookimpl\n46 from _pytest.deprecated import FUNCARGNAMES\n47 from _pytest.fixtures import FuncFixtureInfo\n48 from _pytest.mark import MARK_GEN\n49 from _pytest.mark import ParameterSet\n50 from _pytest.mark.structures import get_unpacked_marks\n51 from _pytest.mark.structures import Mark\n52 from _pytest.mark.structures import normalize_mark_list\n53 from _pytest.outcomes import fail\n54 from _pytest.outcomes import skip\n55 from _pytest.pathlib import parts\n56 from _pytest.warning_types import PytestCollectionWarning\n57 from _pytest.warning_types import PytestUnhandledCoroutineWarning\n58 \n59 \n60 def pyobj_property(name):\n61     def get(self):\n62         node = self.getparent(getattr(__import__(\"pytest\"), name))\n63         if node is not None:\n64             return node.obj\n65 \n66     doc = \"python {} object this node was collected from (can be None).\".format(\n67         name.lower()\n68     )\n69     return property(get, None, None, doc)\n70 \n71 \n72 def pytest_addoption(parser):\n73     group = parser.getgroup(\"general\")\n74     group.addoption(\n75         \"--fixtures\",\n76         \"--funcargs\",\n77         action=\"store_true\",\n78         dest=\"showfixtures\",\n79         default=False,\n80         help=\"show available fixtures, sorted by plugin appearance \"\n81         \"(fixtures with leading '_' are only shown with '-v')\",\n82     )\n83     group.addoption(\n84         \"--fixtures-per-test\",\n85         action=\"store_true\",\n86         dest=\"show_fixtures_per_test\",\n87         default=False,\n88         help=\"show fixtures per test\",\n89     )\n90     parser.addini(\n91         \"python_files\",\n92         type=\"args\",\n93         # NOTE: default is also used in AssertionRewritingHook.\n94         default=[\"test_*.py\", \"*_test.py\"],\n95         help=\"glob-style file patterns for Python test module discovery\",\n96     )\n97     parser.addini(\n98         \"python_classes\",\n99         type=\"args\",\n100         default=[\"Test\"],\n101         help=\"prefixes or glob names for Python test class discovery\",\n102     )\n103     parser.addini(\n104         \"python_functions\",\n105         type=\"args\",\n106         default=[\"test\"],\n107         help=\"prefixes or glob names for Python test function and method discovery\",\n108     )\n109     parser.addini(\n110         \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\",\n111         type=\"bool\",\n112         default=False,\n113         help=\"disable string escape non-ascii characters, might cause unwanted \"\n114         \"side effects(use at your own risk)\",\n115     )\n116 \n117     group.addoption(\n118         \"--import-mode\",\n119         default=\"prepend\",\n120         choices=[\"prepend\", \"append\"],\n121         dest=\"importmode\",\n122         help=\"prepend/append to sys.path when importing test modules, \"\n123         \"default is to prepend.\",\n124     )\n125 \n126 \n127 def pytest_cmdline_main(config):\n128     if config.option.showfixtures:\n129         showfixtures(config)\n130         return 0\n131     if config.option.show_fixtures_per_test:\n132         show_fixtures_per_test(config)\n133         return 0\n134 \n135 \n136 def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n137     for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n138         # TODO: Fix this type-ignore (overlapping kwargs).\n139         metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821\n140 \n141 \n142 def pytest_configure(config):\n143     config.addinivalue_line(\n144         \"markers\",\n145         \"parametrize(argnames, argvalues): call a test function multiple \"\n146         \"times passing in different arguments in turn. argvalues generally \"\n147         \"needs to be a list of values if argnames specifies only one name \"\n148         \"or a list of tuples of values if argnames specifies multiple names. \"\n149         \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n150         \"decorated test function, one with arg1=1 and another with arg1=2.\"\n151         \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n152         \"and examples.\",\n153     )\n154     config.addinivalue_line(\n155         \"markers\",\n156         \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n157         \"all of the specified fixtures. see \"\n158         \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n159     )\n160 \n161 \n162 def async_warn_and_skip(nodeid: str) -> None:\n163     msg = \"async def functions are not natively supported and have been skipped.\\n\"\n164     msg += (\n165         \"You need to install a suitable plugin for your async framework, for example:\\n\"\n166     )\n167     msg += \"  - pytest-asyncio\\n\"\n168     msg += \"  - pytest-trio\\n\"\n169     msg += \"  - pytest-tornasync\\n\"\n170     msg += \"  - pytest-twisted\"\n171     warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n172     skip(msg=\"async def function and no async plugin installed (see warnings)\")\n173 \n174 \n175 @hookimpl(trylast=True)\n176 def pytest_pyfunc_call(pyfuncitem: \"Function\"):\n177     testfunction = pyfuncitem.obj\n178     if is_async_function(testfunction):\n179         async_warn_and_skip(pyfuncitem.nodeid)\n180     funcargs = pyfuncitem.funcargs\n181     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n182     result = testfunction(**testargs)\n183     if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n184         async_warn_and_skip(pyfuncitem.nodeid)\n185     return True\n186 \n187 \n188 def pytest_collect_file(path, parent):\n189     ext = path.ext\n190     if ext == \".py\":\n191         if not parent.session.isinitpath(path):\n192             if not path_matches_patterns(\n193                 path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n194             ):\n195                 return\n196         ihook = parent.session.gethookproxy(path)\n197         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n198 \n199 \n200 def path_matches_patterns(path, patterns):\n201     \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n202     return any(path.fnmatch(pattern) for pattern in patterns)\n203 \n204 \n205 def pytest_pycollect_makemodule(path, parent):\n206     if path.basename == \"__init__.py\":\n207         return Package.from_parent(parent, fspath=path)\n208     return Module.from_parent(parent, fspath=path)\n209 \n210 \n211 @hookimpl(hookwrapper=True)\n212 def pytest_pycollect_makeitem(collector, name, obj):\n213     outcome = yield\n214     res = outcome.get_result()\n215     if res is not None:\n216         return\n217     # nothing was collected elsewhere, let's do it here\n218     if safe_isclass(obj):\n219         if collector.istestclass(obj, name):\n220             outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n221     elif collector.istestfunction(obj, name):\n222         # mock seems to store unbound methods (issue473), normalize it\n223         obj = getattr(obj, \"__func__\", obj)\n224         # We need to try and unwrap the function if it's a functools.partial\n225         # or a functools.wrapped.\n226         # We mustn't if it's been wrapped with mock.patch (python 2 only)\n227         if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n228             filename, lineno = getfslineno(obj)\n229             warnings.warn_explicit(\n230                 message=PytestCollectionWarning(\n231                     \"cannot collect %r because it is not a function.\" % name\n232                 ),\n233                 category=None,\n234                 filename=str(filename),\n235                 lineno=lineno + 1,\n236             )\n237         elif getattr(obj, \"__test__\", True):\n238             if is_generator(obj):\n239                 res = Function.from_parent(collector, name=name)\n240                 reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n241                     name=name\n242                 )\n243                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n244                 res.warn(PytestCollectionWarning(reason))\n245             else:\n246                 res = list(collector._genfunctions(name, obj))\n247             outcome.force_result(res)\n248 \n249 \n250 class PyobjMixin:\n251     module = pyobj_property(\"Module\")\n252     cls = pyobj_property(\"Class\")\n253     instance = pyobj_property(\"Instance\")\n254     _ALLOW_MARKERS = True\n255 \n256     @property\n257     def obj(self):\n258         \"\"\"Underlying Python object.\"\"\"\n259         obj = getattr(self, \"_obj\", None)\n260         if obj is None:\n261             self._obj = obj = self._getobj()\n262             # XXX evil hack\n263             # used to avoid Instance collector marker duplication\n264             if self._ALLOW_MARKERS:\n265                 self.own_markers.extend(get_unpacked_marks(self.obj))\n266         return obj\n267 \n268     @obj.setter\n269     def obj(self, value):\n270         self._obj = value\n271 \n272     def _getobj(self):\n273         \"\"\"Gets the underlying Python object. May be overwritten by subclasses.\"\"\"\n274         return getattr(self.parent.obj, self.name)\n275 \n276     def getmodpath(self, stopatmodule=True, includemodule=False):\n277         \"\"\" return python path relative to the containing module. \"\"\"\n278         chain = self.listchain()\n279         chain.reverse()\n280         parts = []\n281         for node in chain:\n282             if isinstance(node, Instance):\n283                 continue\n284             name = node.name\n285             if isinstance(node, Module):\n286                 name = os.path.splitext(name)[0]\n287                 if stopatmodule:\n288                     if includemodule:\n289                         parts.append(name)\n290                     break\n291             parts.append(name)\n292         parts.reverse()\n293         return \".\".join(parts)\n294 \n295     def reportinfo(self) -> Tuple[Union[py.path.local, str], int, str]:\n296         # XXX caching?\n297         obj = self.obj\n298         compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n299         if isinstance(compat_co_firstlineno, int):\n300             # nose compatibility\n301             file_path = sys.modules[obj.__module__].__file__\n302             if file_path.endswith(\".pyc\"):\n303                 file_path = file_path[:-1]\n304             fspath = file_path  # type: Union[py.path.local, str]\n305             lineno = compat_co_firstlineno\n306         else:\n307             fspath, lineno = getfslineno(obj)\n308         modpath = self.getmodpath()\n309         assert isinstance(lineno, int)\n310         return fspath, lineno, modpath\n311 \n312 \n313 class PyCollector(PyobjMixin, nodes.Collector):\n314     def funcnamefilter(self, name):\n315         return self._matches_prefix_or_glob_option(\"python_functions\", name)\n316 \n317     def isnosetest(self, obj):\n318         \"\"\" Look for the __test__ attribute, which is applied by the\n319         @nose.tools.istest decorator\n320         \"\"\"\n321         # We explicitly check for \"is True\" here to not mistakenly treat\n322         # classes with a custom __getattr__ returning something truthy (like a\n323         # function) as test classes.\n324         return safe_getattr(obj, \"__test__\", False) is True\n325 \n326     def classnamefilter(self, name):\n327         return self._matches_prefix_or_glob_option(\"python_classes\", name)\n328 \n329     def istestfunction(self, obj, name):\n330         if self.funcnamefilter(name) or self.isnosetest(obj):\n331             if isinstance(obj, staticmethod):\n332                 # static methods need to be unwrapped\n333                 obj = safe_getattr(obj, \"__func__\", False)\n334             return (\n335                 safe_getattr(obj, \"__call__\", False)\n336                 and fixtures.getfixturemarker(obj) is None\n337             )\n338         else:\n339             return False\n340 \n341     def istestclass(self, obj, name):\n342         return self.classnamefilter(name) or self.isnosetest(obj)\n343 \n344     def _matches_prefix_or_glob_option(self, option_name, name):\n345         \"\"\"\n346         checks if the given name matches the prefix or glob-pattern defined\n347         in ini configuration.\n348         \"\"\"\n349         for option in self.config.getini(option_name):\n350             if name.startswith(option):\n351                 return True\n352             # check that name looks like a glob-string before calling fnmatch\n353             # because this is called for every name in each collected module,\n354             # and fnmatch is somewhat expensive to call\n355             elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n356                 name, option\n357             ):\n358                 return True\n359         return False\n360 \n361     def collect(self):\n362         if not getattr(self.obj, \"__test__\", True):\n363             return []\n364 \n365         # NB. we avoid random getattrs and peek in the __dict__ instead\n366         # (XXX originally introduced from a PyPy need, still true?)\n367         dicts = [getattr(self.obj, \"__dict__\", {})]\n368         for basecls in inspect.getmro(self.obj.__class__):\n369             dicts.append(basecls.__dict__)\n370         seen = {}\n371         values = []\n372         for dic in dicts:\n373             for name, obj in list(dic.items()):\n374                 if name in seen:\n375                     continue\n376                 seen[name] = True\n377                 res = self._makeitem(name, obj)\n378                 if res is None:\n379                     continue\n380                 if not isinstance(res, list):\n381                     res = [res]\n382                 values.extend(res)\n383 \n384         def sort_key(item):\n385             fspath, lineno, _ = item.reportinfo()\n386             return (str(fspath), lineno)\n387 \n388         values.sort(key=sort_key)\n389         return values\n390 \n391     def _makeitem(self, name, obj):\n392         # assert self.ihook.fspath == self.fspath, self\n393         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)\n394 \n395     def _genfunctions(self, name, funcobj):\n396         module = self.getparent(Module).obj\n397         clscol = self.getparent(Class)\n398         cls = clscol and clscol.obj or None\n399         fm = self.session._fixturemanager\n400 \n401         definition = FunctionDefinition.from_parent(self, name=name, callobj=funcobj)\n402         fixtureinfo = definition._fixtureinfo\n403 \n404         metafunc = Metafunc(\n405             definition, fixtureinfo, self.config, cls=cls, module=module\n406         )\n407         methods = []\n408         if hasattr(module, \"pytest_generate_tests\"):\n409             methods.append(module.pytest_generate_tests)\n410         if hasattr(cls, \"pytest_generate_tests\"):\n411             methods.append(cls().pytest_generate_tests)\n412 \n413         self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))\n414 \n415         if not metafunc._calls:\n416             yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\n417         else:\n418             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs\n419             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n420 \n421             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n422             # with direct parametrization, so make sure we update what the\n423             # function really needs.\n424             fixtureinfo.prune_dependency_tree()\n425 \n426             for callspec in metafunc._calls:\n427                 subname = \"{}[{}]\".format(name, callspec.id)\n428                 yield Function.from_parent(\n429                     self,\n430                     name=subname,\n431                     callspec=callspec,\n432                     callobj=funcobj,\n433                     fixtureinfo=fixtureinfo,\n434                     keywords={callspec.id: True},\n435                     originalname=name,\n436                 )\n437 \n438 \n439 class Module(nodes.File, PyCollector):\n440     \"\"\" Collector for test classes and functions. \"\"\"\n441 \n442     def _getobj(self):\n443         return self._importtestmodule()\n444 \n445     def collect(self):\n446         self._inject_setup_module_fixture()\n447         self._inject_setup_function_fixture()\n448         self.session._fixturemanager.parsefactories(self)\n449         return super().collect()\n450 \n451     def _inject_setup_module_fixture(self):\n452         \"\"\"Injects a hidden autouse, module scoped fixture into the collected module object\n453         that invokes setUpModule/tearDownModule if either or both are available.\n454 \n455         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n456         other fixtures (#517).\n457         \"\"\"\n458         setup_module = _get_first_non_fixture_func(\n459             self.obj, (\"setUpModule\", \"setup_module\")\n460         )\n461         teardown_module = _get_first_non_fixture_func(\n462             self.obj, (\"tearDownModule\", \"teardown_module\")\n463         )\n464 \n465         if setup_module is None and teardown_module is None:\n466             return\n467 \n468         @fixtures.fixture(autouse=True, scope=\"module\")\n469         def xunit_setup_module_fixture(request):\n470             if setup_module is not None:\n471                 _call_with_optional_argument(setup_module, request.module)\n472             yield\n473             if teardown_module is not None:\n474                 _call_with_optional_argument(teardown_module, request.module)\n475 \n476         self.obj.__pytest_setup_module = xunit_setup_module_fixture\n477 \n478     def _inject_setup_function_fixture(self):\n479         \"\"\"Injects a hidden autouse, function scoped fixture into the collected module object\n480         that invokes setup_function/teardown_function if either or both are available.\n481 \n482         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n483         other fixtures (#517).\n484         \"\"\"\n485         setup_function = _get_first_non_fixture_func(self.obj, (\"setup_function\",))\n486         teardown_function = _get_first_non_fixture_func(\n487             self.obj, (\"teardown_function\",)\n488         )\n489         if setup_function is None and teardown_function is None:\n490             return\n491 \n492         @fixtures.fixture(autouse=True, scope=\"function\")\n493         def xunit_setup_function_fixture(request):\n494             if request.instance is not None:\n495                 # in this case we are bound to an instance, so we need to let\n496                 # setup_method handle this\n497                 yield\n498                 return\n499             if setup_function is not None:\n500                 _call_with_optional_argument(setup_function, request.function)\n501             yield\n502             if teardown_function is not None:\n503                 _call_with_optional_argument(teardown_function, request.function)\n504 \n505         self.obj.__pytest_setup_function = xunit_setup_function_fixture\n506 \n507     def _importtestmodule(self):\n508         # we assume we are only called once per module\n509         importmode = self.config.getoption(\"--import-mode\")\n510         try:\n511             mod = self.fspath.pyimport(ensuresyspath=importmode)\n512         except SyntaxError:\n513             raise self.CollectError(ExceptionInfo.from_current().getrepr(style=\"short\"))\n514         except self.fspath.ImportMismatchError as e:\n515             raise self.CollectError(\n516                 \"import file mismatch:\\n\"\n517                 \"imported module %r has this __file__ attribute:\\n\"\n518                 \"  %s\\n\"\n519                 \"which is not the same as the test file we want to collect:\\n\"\n520                 \"  %s\\n\"\n521                 \"HINT: remove __pycache__ / .pyc files and/or use a \"\n522                 \"unique basename for your test file modules\" % e.args\n523             )\n524         except ImportError:\n525             exc_info = ExceptionInfo.from_current()\n526             if self.config.getoption(\"verbose\") < 2:\n527                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n528             exc_repr = (\n529                 exc_info.getrepr(style=\"short\")\n530                 if exc_info.traceback\n531                 else exc_info.exconly()\n532             )\n533             formatted_tb = str(exc_repr)\n534             raise self.CollectError(\n535                 \"ImportError while importing test module '{fspath}'.\\n\"\n536                 \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n537                 \"Traceback:\\n\"\n538                 \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n539             )\n540         except _pytest.runner.Skipped as e:\n541             if e.allow_module_level:\n542                 raise\n543             raise self.CollectError(\n544                 \"Using pytest.skip outside of a test is not allowed. \"\n545                 \"To decorate a test function, use the @pytest.mark.skip \"\n546                 \"or @pytest.mark.skipif decorators instead, and to skip a \"\n547                 \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n548             )\n549         self.config.pluginmanager.consider_module(mod)\n550         return mod\n551 \n552 \n553 class Package(Module):\n554     def __init__(\n555         self,\n556         fspath: py.path.local,\n557         parent: nodes.Collector,\n558         # NOTE: following args are unused:\n559         config=None,\n560         session=None,\n561         nodeid=None,\n562     ) -> None:\n563         # NOTE: could be just the following, but kept as-is for compat.\n564         # nodes.FSCollector.__init__(self, fspath, parent=parent)\n565         session = parent.session\n566         nodes.FSCollector.__init__(\n567             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid\n568         )\n569 \n570         self.name = fspath.dirname\n571 \n572     def setup(self):\n573         # not using fixtures to call setup_module here because autouse fixtures\n574         # from packages are not called automatically (#4085)\n575         setup_module = _get_first_non_fixture_func(\n576             self.obj, (\"setUpModule\", \"setup_module\")\n577         )\n578         if setup_module is not None:\n579             _call_with_optional_argument(setup_module, self.obj)\n580 \n581         teardown_module = _get_first_non_fixture_func(\n582             self.obj, (\"tearDownModule\", \"teardown_module\")\n583         )\n584         if teardown_module is not None:\n585             func = partial(_call_with_optional_argument, teardown_module, self.obj)\n586             self.addfinalizer(func)\n587 \n588     def gethookproxy(self, fspath: py.path.local):\n589         return super()._gethookproxy(fspath)\n590 \n591     def isinitpath(self, path):\n592         return path in self.session._initialpaths\n593 \n594     def collect(self):\n595         this_path = self.fspath.dirpath()\n596         init_module = this_path.join(\"__init__.py\")\n597         if init_module.check(file=1) and path_matches_patterns(\n598             init_module, self.config.getini(\"python_files\")\n599         ):\n600             yield Module.from_parent(self, fspath=init_module)\n601         pkg_prefixes = set()\n602         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):\n603             # We will visit our own __init__.py file, in which case we skip it.\n604             is_file = path.isfile()\n605             if is_file:\n606                 if path.basename == \"__init__.py\" and path.dirpath() == this_path:\n607                     continue\n608 \n609             parts_ = parts(path.strpath)\n610             if any(\n611                 pkg_prefix in parts_ and pkg_prefix.join(\"__init__.py\") != path\n612                 for pkg_prefix in pkg_prefixes\n613             ):\n614                 continue\n615 \n616             if is_file:\n617                 yield from self._collectfile(path)\n618             elif not path.isdir():\n619                 # Broken symlink or invalid/missing file.\n620                 continue\n621             elif path.join(\"__init__.py\").check(file=1):\n622                 pkg_prefixes.add(path)\n623 \n624 \n625 def _call_with_optional_argument(func, arg):\n626     \"\"\"Call the given function with the given argument if func accepts one argument, otherwise\n627     calls func without arguments\"\"\"\n628     arg_count = func.__code__.co_argcount\n629     if inspect.ismethod(func):\n630         arg_count -= 1\n631     if arg_count:\n632         func(arg)\n633     else:\n634         func()\n635 \n636 \n637 def _get_first_non_fixture_func(obj, names):\n638     \"\"\"Return the attribute from the given object to be used as a setup/teardown\n639     xunit-style function, but only if not marked as a fixture to\n640     avoid calling it twice.\n641     \"\"\"\n642     for name in names:\n643         meth = getattr(obj, name, None)\n644         if meth is not None and fixtures.getfixturemarker(meth) is None:\n645             return meth\n646 \n647 \n648 class Class(PyCollector):\n649     \"\"\" Collector for test methods. \"\"\"\n650 \n651     @classmethod\n652     def from_parent(cls, parent, *, name, obj=None):\n653         \"\"\"\n654         The public constructor\n655         \"\"\"\n656         return super().from_parent(name=name, parent=parent)\n657 \n658     def collect(self):\n659         if not safe_getattr(self.obj, \"__test__\", True):\n660             return []\n661         if hasinit(self.obj):\n662             self.warn(\n663                 PytestCollectionWarning(\n664                     \"cannot collect test class %r because it has a \"\n665                     \"__init__ constructor (from: %s)\"\n666                     % (self.obj.__name__, self.parent.nodeid)\n667                 )\n668             )\n669             return []\n670         elif hasnew(self.obj):\n671             self.warn(\n672                 PytestCollectionWarning(\n673                     \"cannot collect test class %r because it has a \"\n674                     \"__new__ constructor (from: %s)\"\n675                     % (self.obj.__name__, self.parent.nodeid)\n676                 )\n677             )\n678             return []\n679 \n680         self._inject_setup_class_fixture()\n681         self._inject_setup_method_fixture()\n682 \n683         return [Instance.from_parent(self, name=\"()\")]\n684 \n685     def _inject_setup_class_fixture(self):\n686         \"\"\"Injects a hidden autouse, class scoped fixture into the collected class object\n687         that invokes setup_class/teardown_class if either or both are available.\n688 \n689         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n690         other fixtures (#517).\n691         \"\"\"\n692         setup_class = _get_first_non_fixture_func(self.obj, (\"setup_class\",))\n693         teardown_class = getattr(self.obj, \"teardown_class\", None)\n694         if setup_class is None and teardown_class is None:\n695             return\n696 \n697         @fixtures.fixture(autouse=True, scope=\"class\")\n698         def xunit_setup_class_fixture(cls):\n699             if setup_class is not None:\n700                 func = getimfunc(setup_class)\n701                 _call_with_optional_argument(func, self.obj)\n702             yield\n703             if teardown_class is not None:\n704                 func = getimfunc(teardown_class)\n705                 _call_with_optional_argument(func, self.obj)\n706 \n707         self.obj.__pytest_setup_class = xunit_setup_class_fixture\n708 \n709     def _inject_setup_method_fixture(self):\n710         \"\"\"Injects a hidden autouse, function scoped fixture into the collected class object\n711         that invokes setup_method/teardown_method if either or both are available.\n712 \n713         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n714         other fixtures (#517).\n715         \"\"\"\n716         setup_method = _get_first_non_fixture_func(self.obj, (\"setup_method\",))\n717         teardown_method = getattr(self.obj, \"teardown_method\", None)\n718         if setup_method is None and teardown_method is None:\n719             return\n720 \n721         @fixtures.fixture(autouse=True, scope=\"function\")\n722         def xunit_setup_method_fixture(self, request):\n723             method = request.function\n724             if setup_method is not None:\n725                 func = getattr(self, \"setup_method\")\n726                 _call_with_optional_argument(func, method)\n727             yield\n728             if teardown_method is not None:\n729                 func = getattr(self, \"teardown_method\")\n730                 _call_with_optional_argument(func, method)\n731 \n732         self.obj.__pytest_setup_method = xunit_setup_method_fixture\n733 \n734 \n735 class Instance(PyCollector):\n736     _ALLOW_MARKERS = False  # hack, destroy later\n737     # instances share the object with their parents in a way\n738     # that duplicates markers instances if not taken out\n739     # can be removed at node structure reorganization time\n740 \n741     def _getobj(self):\n742         return self.parent.obj()\n743 \n744     def collect(self):\n745         self.session._fixturemanager.parsefactories(self)\n746         return super().collect()\n747 \n748     def newinstance(self):\n749         self.obj = self._getobj()\n750         return self.obj\n751 \n752 \n753 def hasinit(obj):\n754     init = getattr(obj, \"__init__\", None)\n755     if init:\n756         return init != object.__init__\n757 \n758 \n759 def hasnew(obj):\n760     new = getattr(obj, \"__new__\", None)\n761     if new:\n762         return new != object.__new__\n763 \n764 \n765 class CallSpec2:\n766     def __init__(self, metafunc):\n767         self.metafunc = metafunc\n768         self.funcargs = {}\n769         self._idlist = []\n770         self.params = {}\n771         self._arg2scopenum = {}  # used for sorting parametrized resources\n772         self.marks = []\n773         self.indices = {}\n774 \n775     def copy(self):\n776         cs = CallSpec2(self.metafunc)\n777         cs.funcargs.update(self.funcargs)\n778         cs.params.update(self.params)\n779         cs.marks.extend(self.marks)\n780         cs.indices.update(self.indices)\n781         cs._arg2scopenum.update(self._arg2scopenum)\n782         cs._idlist = list(self._idlist)\n783         return cs\n784 \n785     def _checkargnotcontained(self, arg):\n786         if arg in self.params or arg in self.funcargs:\n787             raise ValueError(\"duplicate {!r}\".format(arg))\n788 \n789     def getparam(self, name):\n790         try:\n791             return self.params[name]\n792         except KeyError:\n793             raise ValueError(name)\n794 \n795     @property\n796     def id(self):\n797         return \"-\".join(map(str, self._idlist))\n798 \n799     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):\n800         for arg, val in zip(argnames, valset):\n801             self._checkargnotcontained(arg)\n802             valtype_for_arg = valtypes[arg]\n803             getattr(self, valtype_for_arg)[arg] = val\n804             self.indices[arg] = param_index\n805             self._arg2scopenum[arg] = scopenum\n806         self._idlist.append(id)\n807         self.marks.extend(normalize_mark_list(marks))\n808 \n809 \n810 class Metafunc:\n811     \"\"\"\n812     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n813     They help to inspect a test function and to generate tests according to\n814     test configuration or values specified in the class or module where a\n815     test function is defined.\n816     \"\"\"\n817 \n818     def __init__(\n819         self,\n820         definition: \"FunctionDefinition\",\n821         fixtureinfo: fixtures.FuncFixtureInfo,\n822         config: Config,\n823         cls=None,\n824         module=None,\n825     ) -> None:\n826         self.definition = definition\n827 \n828         #: access to the :class:`_pytest.config.Config` object for the test session\n829         self.config = config\n830 \n831         #: the module object where the test function is defined in.\n832         self.module = module\n833 \n834         #: underlying python test function\n835         self.function = definition.obj\n836 \n837         #: set of fixture names required by the test function\n838         self.fixturenames = fixtureinfo.names_closure\n839 \n840         #: class object where the test function is defined in or ``None``.\n841         self.cls = cls\n842 \n843         self._calls = []  # type: List[CallSpec2]\n844         self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n845 \n846     @property\n847     def funcargnames(self):\n848         \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n849         warnings.warn(FUNCARGNAMES, stacklevel=2)\n850         return self.fixturenames\n851 \n852     def parametrize(\n853         self,\n854         argnames: Union[str, List[str], Tuple[str, ...]],\n855         argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n856         indirect: Union[bool, typing.Sequence[str]] = False,\n857         ids: Optional[\n858             Union[\n859                 Iterable[Union[None, str, float, int, bool]],\n860                 Callable[[object], Optional[object]],\n861             ]\n862         ] = None,\n863         scope: \"Optional[str]\" = None,\n864         *,\n865         _param_mark: Optional[Mark] = None\n866     ) -> None:\n867         \"\"\" Add new invocations to the underlying test function using the list\n868         of argvalues for the given argnames.  Parametrization is performed\n869         during the collection phase.  If you need to setup expensive resources\n870         see about setting indirect to do it rather at test setup time.\n871 \n872         :arg argnames: a comma-separated string denoting one or more argument\n873                        names, or a list/tuple of argument strings.\n874 \n875         :arg argvalues: The list of argvalues determines how often a\n876             test is invoked with different argument values.  If only one\n877             argname was specified argvalues is a list of values.  If N\n878             argnames were specified, argvalues must be a list of N-tuples,\n879             where each tuple-element specifies a value for its respective\n880             argname.\n881 \n882         :arg indirect: The list of argnames or boolean. A list of arguments'\n883             names (subset of argnames). If True the list contains all names from\n884             the argnames. Each argvalue corresponding to an argname in this list will\n885             be passed as request.param to its respective argname fixture\n886             function so that it can perform more expensive setups during the\n887             setup phase of a test rather than at collection time.\n888 \n889         :arg ids: sequence of (or generator for) ids for ``argvalues``,\n890               or a callable to return part of the id for each argvalue.\n891 \n892             With sequences (and generators like ``itertools.count()``) the\n893             returned ids should be of type ``string``, ``int``, ``float``,\n894             ``bool``, or ``None``.\n895             They are mapped to the corresponding index in ``argvalues``.\n896             ``None`` means to use the auto-generated id.\n897 \n898             If it is a callable it will be called for each entry in\n899             ``argvalues``, and the return value is used as part of the\n900             auto-generated id for the whole set (where parts are joined with\n901             dashes (\"-\")).\n902             This is useful to provide more specific ids for certain items, e.g.\n903             dates.  Returning ``None`` will use an auto-generated id.\n904 \n905             If no ids are provided they will be generated automatically from\n906             the argvalues.\n907 \n908         :arg scope: if specified it denotes the scope of the parameters.\n909             The scope is used for grouping tests by parameter instances.\n910             It will also override any fixture-function defined scope, allowing\n911             to set a dynamic scope using test context or configuration.\n912         \"\"\"\n913         from _pytest.fixtures import scope2index\n914 \n915         argnames, parameters = ParameterSet._for_parametrize(\n916             argnames,\n917             argvalues,\n918             self.function,\n919             self.config,\n920             function_definition=self.definition,\n921         )\n922         del argvalues\n923 \n924         if \"request\" in argnames:\n925             fail(\n926                 \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n927                 pytrace=False,\n928             )\n929 \n930         if scope is None:\n931             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n932 \n933         self._validate_if_using_arg_names(argnames, indirect)\n934 \n935         arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n936 \n937         self._validate_explicit_parameters(argnames, indirect)\n938 \n939         # Use any already (possibly) generated ids with parametrize Marks.\n940         if _param_mark and _param_mark._param_ids_from:\n941             generated_ids = _param_mark._param_ids_from._param_ids_generated\n942             if generated_ids is not None:\n943                 ids = generated_ids\n944 \n945         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)\n946 \n947         # Store used (possibly generated) ids with parametrize Marks.\n948         if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n949             object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n950 \n951         scopenum = scope2index(\n952             scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n953         )\n954 \n955         # create the new calls: if we are parametrize() multiple times (by applying the decorator\n956         # more than once) then we accumulate those calls generating the cartesian product\n957         # of all calls\n958         newcalls = []\n959         for callspec in self._calls or [CallSpec2(self)]:\n960             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n961                 newcallspec = callspec.copy()\n962                 newcallspec.setmulti2(\n963                     arg_values_types,\n964                     argnames,\n965                     param_set.values,\n966                     param_id,\n967                     param_set.marks,\n968                     scopenum,\n969                     param_index,\n970                 )\n971                 newcalls.append(newcallspec)\n972         self._calls = newcalls\n973 \n974     def _resolve_arg_ids(\n975         self,\n976         argnames: typing.Sequence[str],\n977         ids: Optional[\n978             Union[\n979                 Iterable[Union[None, str, float, int, bool]],\n980                 Callable[[object], Optional[object]],\n981             ]\n982         ],\n983         parameters: typing.Sequence[ParameterSet],\n984         item,\n985     ) -> List[str]:\n986         \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n987         to ``parametrize``.\n988 \n989         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n990         :param ids: the ids parameter of the parametrized call (see docs).\n991         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n992         :param Item item: the item that generated this parametrized call.\n993         :rtype: List[str]\n994         :return: the list of ids for each argname given\n995         \"\"\"\n996         if ids is None:\n997             idfn = None\n998             ids_ = None\n999         elif callable(ids):\n1000             idfn = ids\n1001             ids_ = None\n1002         else:\n1003             idfn = None\n1004             ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n1005         return idmaker(argnames, parameters, idfn, ids_, self.config, item=item)\n1006 \n1007     def _validate_ids(\n1008         self,\n1009         ids: Iterable[Union[None, str, float, int, bool]],\n1010         parameters: typing.Sequence[ParameterSet],\n1011         func_name: str,\n1012     ) -> List[Union[None, str]]:\n1013         try:\n1014             num_ids = len(ids)  # type: ignore[arg-type] # noqa: F821\n1015         except TypeError:\n1016             try:\n1017                 iter(ids)\n1018             except TypeError:\n1019                 raise TypeError(\"ids must be a callable or an iterable\")\n1020             num_ids = len(parameters)\n1021 \n1022         # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n1023         if num_ids != len(parameters) and num_ids != 0:\n1024             msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n1025             fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n1026 \n1027         new_ids = []\n1028         for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n1029             if id_value is None or isinstance(id_value, str):\n1030                 new_ids.append(id_value)\n1031             elif isinstance(id_value, (float, int, bool)):\n1032                 new_ids.append(str(id_value))\n1033             else:\n1034                 msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n1035                 fail(\n1036                     msg.format(func_name, saferepr(id_value), type(id_value), idx),\n1037                     pytrace=False,\n1038                 )\n1039         return new_ids\n1040 \n1041     def _resolve_arg_value_types(\n1042         self,\n1043         argnames: typing.Sequence[str],\n1044         indirect: Union[bool, typing.Sequence[str]],\n1045     ) -> Dict[str, str]:\n1046         \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n1047         to the function, based on the ``indirect`` parameter of the parametrized() call.\n1048 \n1049         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1050         :param indirect: same ``indirect`` parameter of ``parametrize()``.\n1051         :rtype: Dict[str, str]\n1052             A dict mapping each arg name to either:\n1053             * \"params\" if the argname should be the parameter of a fixture of the same name.\n1054             * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n1055         \"\"\"\n1056         if isinstance(indirect, bool):\n1057             valtypes = dict.fromkeys(argnames, \"params\" if indirect else \"funcargs\")\n1058         elif isinstance(indirect, Sequence):\n1059             valtypes = dict.fromkeys(argnames, \"funcargs\")\n1060             for arg in indirect:\n1061                 if arg not in argnames:\n1062                     fail(\n1063                         \"In {}: indirect fixture '{}' doesn't exist\".format(\n1064                             self.function.__name__, arg\n1065                         ),\n1066                         pytrace=False,\n1067                     )\n1068                 valtypes[arg] = \"params\"\n1069         else:\n1070             fail(\n1071                 \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n1072                     type=type(indirect).__name__, func=self.function.__name__\n1073                 ),\n1074                 pytrace=False,\n1075             )\n1076         return valtypes\n1077 \n1078     def _validate_if_using_arg_names(\n1079         self,\n1080         argnames: typing.Sequence[str],\n1081         indirect: Union[bool, typing.Sequence[str]],\n1082     ) -> None:\n1083         \"\"\"\n1084         Check if all argnames are being used, by default values, or directly/indirectly.\n1085 \n1086         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1087         :param indirect: same ``indirect`` parameter of ``parametrize()``.\n1088         :raise ValueError: if validation fails.\n1089         \"\"\"\n1090         default_arg_names = set(get_default_arg_names(self.function))\n1091         func_name = self.function.__name__\n1092         for arg in argnames:\n1093             if arg not in self.fixturenames:\n1094                 if arg in default_arg_names:\n1095                     fail(\n1096                         \"In {}: function already takes an argument '{}' with a default value\".format(\n1097                             func_name, arg\n1098                         ),\n1099                         pytrace=False,\n1100                     )\n1101                 else:\n1102                     if isinstance(indirect, Sequence):\n1103                         name = \"fixture\" if arg in indirect else \"argument\"\n1104                     else:\n1105                         name = \"fixture\" if indirect else \"argument\"\n1106                     fail(\n1107                         \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n1108                         pytrace=False,\n1109                     )\n1110 \n1111     def _validate_explicit_parameters(\n1112         self,\n1113         argnames: typing.Sequence[str],\n1114         indirect: Union[bool, typing.Sequence[str]],\n1115     ) -> None:\n1116         \"\"\"\n1117         The argnames in *parametrize* should either be declared explicitly via\n1118         indirect list or in the function signature\n1119 \n1120         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1121         :param indirect: same ``indirect`` parameter of ``parametrize()``.\n1122         :raise ValueError: if validation fails\n1123         \"\"\"\n1124         if isinstance(indirect, bool):\n1125             parametrized_argnames = [] if indirect else argnames\n1126         else:\n1127             parametrized_argnames = [arg for arg in argnames if arg not in indirect]\n1128 \n1129         if not parametrized_argnames:\n1130             return\n1131 \n1132         funcargnames = _pytest.compat.getfuncargnames(self.function)\n1133         usefixtures = fixtures.get_use_fixtures_for_node(self.definition)\n1134 \n1135         for arg in parametrized_argnames:\n1136             if arg not in funcargnames and arg not in usefixtures:\n1137                 func_name = self.function.__name__\n1138                 msg = (\n1139                     'In function \"{func_name}\":\\n'\n1140                     'Parameter \"{arg}\" should be declared explicitly via indirect or in function itself'\n1141                 ).format(func_name=func_name, arg=arg)\n1142                 fail(msg, pytrace=False)\n1143 \n1144 \n1145 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):\n1146     \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n1147 \n1148     When there's at least one direct argument, always use \"function\" scope.\n1149 \n1150     When a test function is parametrized and all its arguments are indirect\n1151     (e.g. fixtures), return the most narrow scope based on the fixtures used.\n1152 \n1153     Related to issue #1832, based on code posted by @Kingdread.\n1154     \"\"\"\n1155     from _pytest.fixtures import scopes\n1156 \n1157     if isinstance(indirect, (list, tuple)):\n1158         all_arguments_are_fixtures = len(indirect) == len(argnames)\n1159     else:\n1160         all_arguments_are_fixtures = bool(indirect)\n1161 \n1162     if all_arguments_are_fixtures:\n1163         fixturedefs = arg2fixturedefs or {}\n1164         used_scopes = [\n1165             fixturedef[0].scope\n1166             for name, fixturedef in fixturedefs.items()\n1167             if name in argnames\n1168         ]\n1169         if used_scopes:\n1170             # Takes the most narrow scope from used fixtures\n1171             for scope in reversed(scopes):\n1172                 if scope in used_scopes:\n1173                     return scope\n1174 \n1175     return \"function\"\n1176 \n1177 \n1178 def _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n1179     if config is None:\n1180         escape_option = False\n1181     else:\n1182         escape_option = config.getini(\n1183             \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\"\n1184         )\n1185     # TODO: If escaping is turned off and the user passes bytes,\n1186     #       will return a bytes. For now we ignore this but the\n1187     #       code *probably* doesn't handle this case.\n1188     return val if escape_option else ascii_escaped(val)  # type: ignore\n1189 \n1190 \n1191 def _idval(\n1192     val: object,\n1193     argname: str,\n1194     idx: int,\n1195     idfn: Optional[Callable[[object], Optional[object]]],\n1196     item,\n1197     config: Optional[Config],\n1198 ) -> str:\n1199     if idfn:\n1200         try:\n1201             generated_id = idfn(val)\n1202             if generated_id is not None:\n1203                 val = generated_id\n1204         except Exception as e:\n1205             msg = \"{}: error raised while trying to determine id of parameter '{}' at position {}\"\n1206             msg = msg.format(item.nodeid, argname, idx)\n1207             raise ValueError(msg) from e\n1208     elif config:\n1209         hook_id = config.hook.pytest_make_parametrize_id(\n1210             config=config, val=val, argname=argname\n1211         )  # type: Optional[str]\n1212         if hook_id:\n1213             return hook_id\n1214 \n1215     if isinstance(val, STRING_TYPES):\n1216         return _ascii_escaped_by_config(val, config)\n1217     elif val is None or isinstance(val, (float, int, bool)):\n1218         return str(val)\n1219     elif isinstance(val, REGEX_TYPE):\n1220         return ascii_escaped(val.pattern)\n1221     elif isinstance(val, enum.Enum):\n1222         return str(val)\n1223     elif isinstance(getattr(val, \"__name__\", None), str):\n1224         # name of a class, function, module, etc.\n1225         name = getattr(val, \"__name__\")  # type: str\n1226         return name\n1227     return str(argname) + str(idx)\n1228 \n1229 \n1230 def _idvalset(\n1231     idx: int,\n1232     parameterset: ParameterSet,\n1233     argnames: Iterable[str],\n1234     idfn: Optional[Callable[[object], Optional[object]]],\n1235     ids: Optional[List[Union[None, str]]],\n1236     item,\n1237     config: Optional[Config],\n1238 ):\n1239     if parameterset.id is not None:\n1240         return parameterset.id\n1241     id = None if ids is None or idx >= len(ids) else ids[idx]\n1242     if id is None:\n1243         this_id = [\n1244             _idval(val, argname, idx, idfn, item=item, config=config)\n1245             for val, argname in zip(parameterset.values, argnames)\n1246         ]\n1247         return \"-\".join(this_id)\n1248     else:\n1249         return _ascii_escaped_by_config(id, config)\n1250 \n1251 \n1252 def idmaker(\n1253     argnames: Iterable[str],\n1254     parametersets: Iterable[ParameterSet],\n1255     idfn: Optional[Callable[[object], Optional[object]]] = None,\n1256     ids: Optional[List[Union[None, str]]] = None,\n1257     config: Optional[Config] = None,\n1258     item=None,\n1259 ) -> List[str]:\n1260     resolved_ids = [\n1261         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)\n1262         for valindex, parameterset in enumerate(parametersets)\n1263     ]\n1264 \n1265     # All IDs must be unique!\n1266     unique_ids = set(resolved_ids)\n1267     if len(unique_ids) != len(resolved_ids):\n1268 \n1269         # Record the number of occurrences of each test ID\n1270         test_id_counts = Counter(resolved_ids)\n1271 \n1272         # Map the test ID to its next suffix\n1273         test_id_suffixes = defaultdict(int)  # type: Dict[str, int]\n1274 \n1275         # Suffix non-unique IDs to make them unique\n1276         for index, test_id in enumerate(resolved_ids):\n1277             if test_id_counts[test_id] > 1:\n1278                 resolved_ids[index] = \"{}{}\".format(test_id, test_id_suffixes[test_id])\n1279                 test_id_suffixes[test_id] += 1\n1280 \n1281     return resolved_ids\n1282 \n1283 \n1284 def show_fixtures_per_test(config):\n1285     from _pytest.main import wrap_session\n1286 \n1287     return wrap_session(config, _show_fixtures_per_test)\n1288 \n1289 \n1290 def _show_fixtures_per_test(config, session):\n1291     import _pytest.config\n1292 \n1293     session.perform_collect()\n1294     curdir = py.path.local()\n1295     tw = _pytest.config.create_terminal_writer(config)\n1296     verbose = config.getvalue(\"verbose\")\n1297 \n1298     def get_best_relpath(func):\n1299         loc = getlocation(func, curdir)\n1300         return curdir.bestrelpath(loc)\n1301 \n1302     def write_fixture(fixture_def):\n1303         argname = fixture_def.argname\n1304         if verbose <= 0 and argname.startswith(\"_\"):\n1305             return\n1306         if verbose > 0:\n1307             bestrel = get_best_relpath(fixture_def.func)\n1308             funcargspec = \"{} -- {}\".format(argname, bestrel)\n1309         else:\n1310             funcargspec = argname\n1311         tw.line(funcargspec, green=True)\n1312         fixture_doc = inspect.getdoc(fixture_def.func)\n1313         if fixture_doc:\n1314             write_docstring(tw, fixture_doc)\n1315         else:\n1316             tw.line(\"    no docstring available\", red=True)\n1317 \n1318     def write_item(item):\n1319         try:\n1320             info = item._fixtureinfo\n1321         except AttributeError:\n1322             # doctests items have no _fixtureinfo attribute\n1323             return\n1324         if not info.name2fixturedefs:\n1325             # this test item does not use any fixtures\n1326             return\n1327         tw.line()\n1328         tw.sep(\"-\", \"fixtures used by {}\".format(item.name))\n1329         tw.sep(\"-\", \"({})\".format(get_best_relpath(item.function)))\n1330         # dict key not used in loop but needed for sorting\n1331         for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n1332             assert fixturedefs is not None\n1333             if not fixturedefs:\n1334                 continue\n1335             # last item is expected to be the one used by the test item\n1336             write_fixture(fixturedefs[-1])\n1337 \n1338     for session_item in session.items:\n1339         write_item(session_item)\n1340 \n1341 \n1342 def showfixtures(config):\n1343     from _pytest.main import wrap_session\n1344 \n1345     return wrap_session(config, _showfixtures_main)\n1346 \n1347 \n1348 def _showfixtures_main(config, session):\n1349     import _pytest.config\n1350 \n1351     session.perform_collect()\n1352     curdir = py.path.local()\n1353     tw = _pytest.config.create_terminal_writer(config)\n1354     verbose = config.getvalue(\"verbose\")\n1355 \n1356     fm = session._fixturemanager\n1357 \n1358     available = []\n1359     seen = set()\n1360 \n1361     for argname, fixturedefs in fm._arg2fixturedefs.items():\n1362         assert fixturedefs is not None\n1363         if not fixturedefs:\n1364             continue\n1365         for fixturedef in fixturedefs:\n1366             loc = getlocation(fixturedef.func, curdir)\n1367             if (fixturedef.argname, loc) in seen:\n1368                 continue\n1369             seen.add((fixturedef.argname, loc))\n1370             available.append(\n1371                 (\n1372                     len(fixturedef.baseid),\n1373                     fixturedef.func.__module__,\n1374                     curdir.bestrelpath(loc),\n1375                     fixturedef.argname,\n1376                     fixturedef,\n1377                 )\n1378             )\n1379 \n1380     available.sort()\n1381     currentmodule = None\n1382     for baseid, module, bestrel, argname, fixturedef in available:\n1383         if currentmodule != module:\n1384             if not module.startswith(\"_pytest.\"):\n1385                 tw.line()\n1386                 tw.sep(\"-\", \"fixtures defined from {}\".format(module))\n1387                 currentmodule = module\n1388         if verbose <= 0 and argname[0] == \"_\":\n1389             continue\n1390         tw.write(argname, green=True)\n1391         if fixturedef.scope != \"function\":\n1392             tw.write(\" [%s scope]\" % fixturedef.scope, cyan=True)\n1393         if verbose > 0:\n1394             tw.write(\" -- %s\" % bestrel, yellow=True)\n1395         tw.write(\"\\n\")\n1396         loc = getlocation(fixturedef.func, curdir)\n1397         doc = inspect.getdoc(fixturedef.func)\n1398         if doc:\n1399             write_docstring(tw, doc)\n1400         else:\n1401             tw.line(\"    {}: no docstring available\".format(loc), red=True)\n1402         tw.line()\n1403 \n1404 \n1405 def write_docstring(tw: TerminalWriter, doc: str, indent: str = \"    \") -> None:\n1406     for line in doc.split(\"\\n\"):\n1407         tw.write(indent + line + \"\\n\")\n1408 \n1409 \n1410 class Function(PyobjMixin, nodes.Item):\n1411     \"\"\" a Function Item is responsible for setting up and executing a\n1412     Python test function.\n1413     \"\"\"\n1414 \n1415     # disable since functions handle it themselves\n1416     _ALLOW_MARKERS = False\n1417 \n1418     def __init__(\n1419         self,\n1420         name,\n1421         parent,\n1422         args=None,\n1423         config=None,\n1424         callspec: Optional[CallSpec2] = None,\n1425         callobj=NOTSET,\n1426         keywords=None,\n1427         session=None,\n1428         fixtureinfo: Optional[FuncFixtureInfo] = None,\n1429         originalname=None,\n1430     ) -> None:\n1431         super().__init__(name, parent, config=config, session=session)\n1432         self._args = args\n1433         if callobj is not NOTSET:\n1434             self.obj = callobj\n1435 \n1436         self.keywords.update(self.obj.__dict__)\n1437         self.own_markers.extend(get_unpacked_marks(self.obj))\n1438         if callspec:\n1439             self.callspec = callspec\n1440             # this is total hostile and a mess\n1441             # keywords are broken by design by now\n1442             # this will be redeemed later\n1443             for mark in callspec.marks:\n1444                 # feel free to cry, this was broken for years before\n1445                 # and keywords cant fix it per design\n1446                 self.keywords[mark.name] = mark\n1447             self.own_markers.extend(normalize_mark_list(callspec.marks))\n1448         if keywords:\n1449             self.keywords.update(keywords)\n1450 \n1451         # todo: this is a hell of a hack\n1452         # https://github.com/pytest-dev/pytest/issues/4569\n1453 \n1454         self.keywords.update(\n1455             {\n1456                 mark.name: True\n1457                 for mark in self.iter_markers()\n1458                 if mark.name not in self.keywords\n1459             }\n1460         )\n1461 \n1462         if fixtureinfo is None:\n1463             fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n1464                 self, self.obj, self.cls, funcargs=True\n1465             )\n1466         self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n1467         self.fixturenames = fixtureinfo.names_closure\n1468         self._initrequest()\n1469 \n1470         #: original function name, without any decorations (for example\n1471         #: parametrization adds a ``\"[...]\"`` suffix to function names).\n1472         #:\n1473         #: .. versionadded:: 3.0\n1474         self.originalname = originalname\n1475 \n1476     @classmethod\n1477     def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n1478         \"\"\"\n1479         The public  constructor\n1480         \"\"\"\n1481         return super().from_parent(parent=parent, **kw)\n1482 \n1483     def _initrequest(self):\n1484         self.funcargs = {}\n1485         self._request = fixtures.FixtureRequest(self)\n1486 \n1487     @property\n1488     def function(self):\n1489         \"underlying python 'function' object\"\n1490         return getimfunc(self.obj)\n1491 \n1492     def _getobj(self):\n1493         name = self.name\n1494         i = name.find(\"[\")  # parametrization\n1495         if i != -1:\n1496             name = name[:i]\n1497         return getattr(self.parent.obj, name)\n1498 \n1499     @property\n1500     def _pyfuncitem(self):\n1501         \"(compatonly) for code expecting pytest-2.2 style request objects\"\n1502         return self\n1503 \n1504     @property\n1505     def funcargnames(self):\n1506         \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n1507         warnings.warn(FUNCARGNAMES, stacklevel=2)\n1508         return self.fixturenames\n1509 \n1510     def runtest(self) -> None:\n1511         \"\"\" execute the underlying test function. \"\"\"\n1512         self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n1513 \n1514     def setup(self) -> None:\n1515         if isinstance(self.parent, Instance):\n1516             self.parent.newinstance()\n1517             self.obj = self._getobj()\n1518         self._request._fillfixtures()\n1519 \n1520     def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n1521         if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n1522             code = _pytest._code.Code(get_real_func(self.obj))\n1523             path, firstlineno = code.path, code.firstlineno\n1524             traceback = excinfo.traceback\n1525             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n1526             if ntraceback == traceback:\n1527                 ntraceback = ntraceback.cut(path=path)\n1528                 if ntraceback == traceback:\n1529                     ntraceback = ntraceback.filter(filter_traceback)\n1530                     if not ntraceback:\n1531                         ntraceback = traceback\n1532 \n1533             excinfo.traceback = ntraceback.filter()\n1534             # issue364: mark all but first and last frames to\n1535             # only show a single-line message for each frame\n1536             if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n1537                 if len(excinfo.traceback) > 2:\n1538                     for entry in excinfo.traceback[1:-1]:\n1539                         entry.set_repr_style(\"short\")\n1540 \n1541     def repr_failure(self, excinfo, outerr=None):\n1542         assert outerr is None, \"XXX outerr usage is deprecated\"\n1543         style = self.config.getoption(\"tbstyle\", \"auto\")\n1544         if style == \"auto\":\n1545             style = \"long\"\n1546         return self._repr_failure_py(excinfo, style=style)\n1547 \n1548 \n1549 class FunctionDefinition(Function):\n1550     \"\"\"\n1551     internal hack until we get actual definition nodes instead of the\n1552     crappy metafunc hack\n1553     \"\"\"\n1554 \n1555     def runtest(self) -> None:\n1556         raise RuntimeError(\"function definitions are not supposed to be used\")\n1557 \n1558     setup = runtest\n",
        "intended_behavior": "Given the extensive role of this file in handling Python test items, including their collection and reporting, a deeper look into the methods that prepare test reports, especially skipped tests, might be required. The intended behavior here would be to ensure that when tests are skipped, and the reports are being prepared, any paths are accurately construed relative to the invocation point or adjusted accordingly if the computation of relative paths is found to be incorrect or not applied at this stage. This adjustment would correct the issue where paths are not shown as expected when tests are skipped."
    }
]