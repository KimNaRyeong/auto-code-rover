[
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/models/fields/related.py",
        "start": 1403,
        "end": 1410,
        "class_name": "ManyToManyField",
        "method_name": "check",
        "code": "1403     def check(self, **kwargs):\n1404         return [\n1405             *super().check(**kwargs),\n1406             *self._check_unique(**kwargs),\n1407             *self._check_relationship_model(**kwargs),\n1408             *self._check_ignored_options(**kwargs),\n1409             *self._check_table_uniqueness(**kwargs),\n1410         ]\n",
        "intended_behavior": "Enhance this method to include a new system check verifying whether a ManyToManyField with a custom through model is being used in conjunction with filter_horizontal or filter_vertical options in a ModelAdmin definition. Since the direct relationship between ManyToManyField instances and ModelAdmin instances might not be straightforward to establish within this context, the feasible approach is to issue a guideline or warning in the Django documentation or framework messages indicating the incompatibility of filter_horizontal and filter_vertical with ManyToManyField(through=\"...\")."
    },
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/models/fields/related.py",
        "start": 1324,
        "end": 2005,
        "class_name": "ManyToManyField",
        "method_name": null,
        "code": "1324 class ManyToManyField(RelatedField):\n1325     \"\"\"\n1326     Provide a many-to-many relation by using an intermediary model that\n1327     holds two ForeignKey fields pointed at the two sides of the relation.\n1328 \n1329     Unless a ``through`` model was provided, ManyToManyField will use the\n1330     create_many_to_many_intermediary_model factory to automatically generate\n1331     the intermediary model.\n1332     \"\"\"\n1333 \n1334     # Field flags\n1335     many_to_many = True\n1336     many_to_one = False\n1337     one_to_many = False\n1338     one_to_one = False\n1339 \n1340     rel_class = ManyToManyRel\n1341 \n1342     description = _(\"Many-to-many relationship\")\n1343 \n1344     def __init__(\n1345         self,\n1346         to,\n1347         related_name=None,\n1348         related_query_name=None,\n1349         limit_choices_to=None,\n1350         symmetrical=None,\n1351         through=None,\n1352         through_fields=None,\n1353         db_constraint=True,\n1354         db_table=None,\n1355         swappable=True,\n1356         **kwargs,\n1357     ):\n1358         try:\n1359             to._meta\n1360         except AttributeError:\n1361             if not isinstance(to, str):\n1362                 raise TypeError(\n1363                     \"%s(%r) is invalid. First parameter to ManyToManyField \"\n1364                     \"must be either a model, a model name, or the string %r\"\n1365                     % (\n1366                         self.__class__.__name__,\n1367                         to,\n1368                         RECURSIVE_RELATIONSHIP_CONSTANT,\n1369                     )\n1370                 )\n1371 \n1372         if symmetrical is None:\n1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT\n1374 \n1375         if through is not None and db_table is not None:\n1376             raise ValueError(\n1377                 \"Cannot specify a db_table if an intermediary model is used.\"\n1378             )\n1379 \n1380         kwargs[\"rel\"] = self.rel_class(\n1381             self,\n1382             to,\n1383             related_name=related_name,\n1384             related_query_name=related_query_name,\n1385             limit_choices_to=limit_choices_to,\n1386             symmetrical=symmetrical,\n1387             through=through,\n1388             through_fields=through_fields,\n1389             db_constraint=db_constraint,\n1390         )\n1391         self.has_null_arg = \"null\" in kwargs\n1392 \n1393         super().__init__(\n1394             related_name=related_name,\n1395             related_query_name=related_query_name,\n1396             limit_choices_to=limit_choices_to,\n1397             **kwargs,\n1398         )\n1399 \n1400         self.db_table = db_table\n1401         self.swappable = swappable\n1402 \n1403     def check(self, **kwargs):\n1404         return [\n1405             *super().check(**kwargs),\n1406             *self._check_unique(**kwargs),\n1407             *self._check_relationship_model(**kwargs),\n1408             *self._check_ignored_options(**kwargs),\n1409             *self._check_table_uniqueness(**kwargs),\n1410         ]\n1411 \n1412     def _check_unique(self, **kwargs):\n1413         if self.unique:\n1414             return [\n1415                 checks.Error(\n1416                     \"ManyToManyFields cannot be unique.\",\n1417                     obj=self,\n1418                     id=\"fields.E330\",\n1419                 )\n1420             ]\n1421         return []\n1422 \n1423     def _check_ignored_options(self, **kwargs):\n1424         warnings = []\n1425 \n1426         if self.has_null_arg:\n1427             warnings.append(\n1428                 checks.Warning(\n1429                     \"null has no effect on ManyToManyField.\",\n1430                     obj=self,\n1431                     id=\"fields.W340\",\n1432                 )\n1433             )\n1434 \n1435         if self._validators:\n1436             warnings.append(\n1437                 checks.Warning(\n1438                     \"ManyToManyField does not support validators.\",\n1439                     obj=self,\n1440                     id=\"fields.W341\",\n1441                 )\n1442             )\n1443         if self.remote_field.symmetrical and self._related_name:\n1444             warnings.append(\n1445                 checks.Warning(\n1446                     \"related_name has no effect on ManyToManyField \"\n1447                     'with a symmetrical relationship, e.g. to \"self\".',\n1448                     obj=self,\n1449                     id=\"fields.W345\",\n1450                 )\n1451             )\n1452         if self.db_comment:\n1453             warnings.append(\n1454                 checks.Warning(\n1455                     \"db_comment has no effect on ManyToManyField.\",\n1456                     obj=self,\n1457                     id=\"fields.W346\",\n1458                 )\n1459             )\n1460 \n1461         return warnings\n1462 \n1463     def _check_relationship_model(self, from_model=None, **kwargs):\n1464         if hasattr(self.remote_field.through, \"_meta\"):\n1465             qualified_model_name = \"%s.%s\" % (\n1466                 self.remote_field.through._meta.app_label,\n1467                 self.remote_field.through.__name__,\n1468             )\n1469         else:\n1470             qualified_model_name = self.remote_field.through\n1471 \n1472         errors = []\n1473 \n1474         if self.remote_field.through not in self.opts.apps.get_models(\n1475             include_auto_created=True\n1476         ):\n1477             # The relationship model is not installed.\n1478             errors.append(\n1479                 checks.Error(\n1480                     \"Field specifies a many-to-many relation through model \"\n1481                     \"'%s', which has not been installed.\" % qualified_model_name,\n1482                     obj=self,\n1483                     id=\"fields.E331\",\n1484                 )\n1485             )\n1486 \n1487         else:\n1488             assert from_model is not None, (\n1489                 \"ManyToManyField with intermediate \"\n1490                 \"tables cannot be checked if you don't pass the model \"\n1491                 \"where the field is attached to.\"\n1492             )\n1493             # Set some useful local variables\n1494             to_model = resolve_relation(from_model, self.remote_field.model)\n1495             from_model_name = from_model._meta.object_name\n1496             if isinstance(to_model, str):\n1497                 to_model_name = to_model\n1498             else:\n1499                 to_model_name = to_model._meta.object_name\n1500             relationship_model_name = self.remote_field.through._meta.object_name\n1501             self_referential = from_model == to_model\n1502             # Count foreign keys in intermediate model\n1503             if self_referential:\n1504                 seen_self = sum(\n1505                     from_model == getattr(field.remote_field, \"model\", None)\n1506                     for field in self.remote_field.through._meta.fields\n1507                 )\n1508 \n1509                 if seen_self > 2 and not self.remote_field.through_fields:\n1510                     errors.append(\n1511                         checks.Error(\n1512                             \"The model is used as an intermediate model by \"\n1513                             \"'%s', but it has more than two foreign keys \"\n1514                             \"to '%s', which is ambiguous. You must specify \"\n1515                             \"which two foreign keys Django should use via the \"\n1516                             \"through_fields keyword argument.\"\n1517                             % (self, from_model_name),\n1518                             hint=(\n1519                                 \"Use through_fields to specify which two foreign keys \"\n1520                                 \"Django should use.\"\n1521                             ),\n1522                             obj=self.remote_field.through,\n1523                             id=\"fields.E333\",\n1524                         )\n1525                     )\n1526 \n1527             else:\n1528                 # Count foreign keys in relationship model\n1529                 seen_from = sum(\n1530                     from_model == getattr(field.remote_field, \"model\", None)\n1531                     for field in self.remote_field.through._meta.fields\n1532                 )\n1533                 seen_to = sum(\n1534                     to_model == getattr(field.remote_field, \"model\", None)\n1535                     for field in self.remote_field.through._meta.fields\n1536                 )\n1537 \n1538                 if seen_from > 1 and not self.remote_field.through_fields:\n1539                     errors.append(\n1540                         checks.Error(\n1541                             (\n1542                                 \"The model is used as an intermediate model by \"\n1543                                 \"'%s', but it has more than one foreign key \"\n1544                                 \"from '%s', which is ambiguous. You must specify \"\n1545                                 \"which foreign key Django should use via the \"\n1546                                 \"through_fields keyword argument.\"\n1547                             )\n1548                             % (self, from_model_name),\n1549                             hint=(\n1550                                 \"If you want to create a recursive relationship, \"\n1551                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1552                             )\n1553                             % (\n1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1555                                 relationship_model_name,\n1556                             ),\n1557                             obj=self,\n1558                             id=\"fields.E334\",\n1559                         )\n1560                     )\n1561 \n1562                 if seen_to > 1 and not self.remote_field.through_fields:\n1563                     errors.append(\n1564                         checks.Error(\n1565                             \"The model is used as an intermediate model by \"\n1566                             \"'%s', but it has more than one foreign key \"\n1567                             \"to '%s', which is ambiguous. You must specify \"\n1568                             \"which foreign key Django should use via the \"\n1569                             \"through_fields keyword argument.\" % (self, to_model_name),\n1570                             hint=(\n1571                                 \"If you want to create a recursive relationship, \"\n1572                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1573                             )\n1574                             % (\n1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1576                                 relationship_model_name,\n1577                             ),\n1578                             obj=self,\n1579                             id=\"fields.E335\",\n1580                         )\n1581                     )\n1582 \n1583                 if seen_from == 0 or seen_to == 0:\n1584                     errors.append(\n1585                         checks.Error(\n1586                             \"The model is used as an intermediate model by \"\n1587                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\"\n1588                             % (self, from_model_name, to_model_name),\n1589                             obj=self.remote_field.through,\n1590                             id=\"fields.E336\",\n1591                         )\n1592                     )\n1593 \n1594         # Validate `through_fields`.\n1595         if self.remote_field.through_fields is not None:\n1596             # Validate that we're given an iterable of at least two items\n1597             # and that none of them is \"falsy\".\n1598             if not (\n1599                 len(self.remote_field.through_fields) >= 2\n1600                 and self.remote_field.through_fields[0]\n1601                 and self.remote_field.through_fields[1]\n1602             ):\n1603                 errors.append(\n1604                     checks.Error(\n1605                         \"Field specifies 'through_fields' but does not provide \"\n1606                         \"the names of the two link fields that should be used \"\n1607                         \"for the relation through model '%s'.\" % qualified_model_name,\n1608                         hint=(\n1609                             \"Make sure you specify 'through_fields' as \"\n1610                             \"through_fields=('field1', 'field2')\"\n1611                         ),\n1612                         obj=self,\n1613                         id=\"fields.E337\",\n1614                     )\n1615                 )\n1616 \n1617             # Validate the given through fields -- they should be actual\n1618             # fields on the through model, and also be foreign keys to the\n1619             # expected models.\n1620             else:\n1621                 assert from_model is not None, (\n1622                     \"ManyToManyField with intermediate \"\n1623                     \"tables cannot be checked if you don't pass the model \"\n1624                     \"where the field is attached to.\"\n1625                 )\n1626 \n1627                 source, through, target = (\n1628                     from_model,\n1629                     self.remote_field.through,\n1630                     self.remote_field.model,\n1631                 )\n1632                 source_field_name, target_field_name = self.remote_field.through_fields[\n1633                     :2\n1634                 ]\n1635 \n1636                 for field_name, related_model in (\n1637                     (source_field_name, source),\n1638                     (target_field_name, target),\n1639                 ):\n1640                     possible_field_names = []\n1641                     for f in through._meta.fields:\n1642                         if (\n1643                             hasattr(f, \"remote_field\")\n1644                             and getattr(f.remote_field, \"model\", None) == related_model\n1645                         ):\n1646                             possible_field_names.append(f.name)\n1647                     if possible_field_names:\n1648                         hint = (\n1649                             \"Did you mean one of the following foreign keys to '%s': \"\n1650                             \"%s?\"\n1651                             % (\n1652                                 related_model._meta.object_name,\n1653                                 \", \".join(possible_field_names),\n1654                             )\n1655                         )\n1656                     else:\n1657                         hint = None\n1658 \n1659                     try:\n1660                         field = through._meta.get_field(field_name)\n1661                     except exceptions.FieldDoesNotExist:\n1662                         errors.append(\n1663                             checks.Error(\n1664                                 \"The intermediary model '%s' has no field '%s'.\"\n1665                                 % (qualified_model_name, field_name),\n1666                                 hint=hint,\n1667                                 obj=self,\n1668                                 id=\"fields.E338\",\n1669                             )\n1670                         )\n1671                     else:\n1672                         if not (\n1673                             hasattr(field, \"remote_field\")\n1674                             and getattr(field.remote_field, \"model\", None)\n1675                             == related_model\n1676                         ):\n1677                             errors.append(\n1678                                 checks.Error(\n1679                                     \"'%s.%s' is not a foreign key to '%s'.\"\n1680                                     % (\n1681                                         through._meta.object_name,\n1682                                         field_name,\n1683                                         related_model._meta.object_name,\n1684                                     ),\n1685                                     hint=hint,\n1686                                     obj=self,\n1687                                     id=\"fields.E339\",\n1688                                 )\n1689                             )\n1690 \n1691         return errors\n1692 \n1693     def _check_table_uniqueness(self, **kwargs):\n1694         if (\n1695             isinstance(self.remote_field.through, str)\n1696             or not self.remote_field.through._meta.managed\n1697         ):\n1698             return []\n1699         registered_tables = {\n1700             model._meta.db_table: model\n1701             for model in self.opts.apps.get_models(include_auto_created=True)\n1702             if model != self.remote_field.through and model._meta.managed\n1703         }\n1704         m2m_db_table = self.m2m_db_table()\n1705         model = registered_tables.get(m2m_db_table)\n1706         # The second condition allows multiple m2m relations on a model if\n1707         # some point to a through model that proxies another through model.\n1708         if (\n1709             model\n1710             and model._meta.concrete_model\n1711             != self.remote_field.through._meta.concrete_model\n1712         ):\n1713             if model._meta.auto_created:\n1714 \n1715                 def _get_field_name(model):\n1716                     for field in model._meta.auto_created._meta.many_to_many:\n1717                         if field.remote_field.through is model:\n1718                             return field.name\n1719 \n1720                 opts = model._meta.auto_created._meta\n1721                 clashing_obj = \"%s.%s\" % (opts.label, _get_field_name(model))\n1722             else:\n1723                 clashing_obj = model._meta.label\n1724             if settings.DATABASE_ROUTERS:\n1725                 error_class, error_id = checks.Warning, \"fields.W344\"\n1726                 error_hint = (\n1727                     \"You have configured settings.DATABASE_ROUTERS. Verify \"\n1728                     \"that the table of %r is correctly routed to a separate \"\n1729                     \"database.\" % clashing_obj\n1730                 )\n1731             else:\n1732                 error_class, error_id = checks.Error, \"fields.E340\"\n1733                 error_hint = None\n1734             return [\n1735                 error_class(\n1736                     \"The field's intermediary table '%s' clashes with the \"\n1737                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1738                     obj=self,\n1739                     hint=error_hint,\n1740                     id=error_id,\n1741                 )\n1742             ]\n1743         return []\n1744 \n1745     def deconstruct(self):\n1746         name, path, args, kwargs = super().deconstruct()\n1747         # Handle the simpler arguments.\n1748         if self.db_table is not None:\n1749             kwargs[\"db_table\"] = self.db_table\n1750         if self.remote_field.db_constraint is not True:\n1751             kwargs[\"db_constraint\"] = self.remote_field.db_constraint\n1752         # Lowercase model names as they should be treated as case-insensitive.\n1753         if isinstance(self.remote_field.model, str):\n1754             if \".\" in self.remote_field.model:\n1755                 app_label, model_name = self.remote_field.model.split(\".\")\n1756                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n1757             else:\n1758                 kwargs[\"to\"] = self.remote_field.model.lower()\n1759         else:\n1760             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n1761         if getattr(self.remote_field, \"through\", None) is not None:\n1762             if isinstance(self.remote_field.through, str):\n1763                 kwargs[\"through\"] = self.remote_field.through\n1764             elif not self.remote_field.through._meta.auto_created:\n1765                 kwargs[\"through\"] = self.remote_field.through._meta.label\n1766         # If swappable is True, then see if we're actually pointing to the target\n1767         # of a swap.\n1768         swappable_setting = self.swappable_setting\n1769         if swappable_setting is not None:\n1770             # If it's already a settings reference, error.\n1771             if hasattr(kwargs[\"to\"], \"setting_name\"):\n1772                 if kwargs[\"to\"].setting_name != swappable_setting:\n1773                     raise ValueError(\n1774                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1775                         \"model that is swapped in place of more than one model \"\n1776                         \"(%s and %s)\" % (kwargs[\"to\"].setting_name, swappable_setting)\n1777                     )\n1778 \n1779             kwargs[\"to\"] = SettingsReference(\n1780                 kwargs[\"to\"],\n1781                 swappable_setting,\n1782             )\n1783         return name, path, args, kwargs\n1784 \n1785     def _get_path_info(self, direct=False, filtered_relation=None):\n1786         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1787         int_model = self.remote_field.through\n1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1790         if direct:\n1791             join1infos = linkfield1.reverse_path_infos\n1792             if filtered_relation:\n1793                 join2infos = linkfield2.get_path_info(filtered_relation)\n1794             else:\n1795                 join2infos = linkfield2.path_infos\n1796         else:\n1797             join1infos = linkfield2.reverse_path_infos\n1798             if filtered_relation:\n1799                 join2infos = linkfield1.get_path_info(filtered_relation)\n1800             else:\n1801                 join2infos = linkfield1.path_infos\n1802         # Get join infos between the last model of join 1 and the first model\n1803         # of join 2. Assume the only reason these may differ is due to model\n1804         # inheritance.\n1805         join1_final = join1infos[-1].to_opts\n1806         join2_initial = join2infos[0].from_opts\n1807         if join1_final is join2_initial:\n1808             intermediate_infos = []\n1809         elif issubclass(join1_final.model, join2_initial.model):\n1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1811         else:\n1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1813 \n1814         return [*join1infos, *intermediate_infos, *join2infos]\n1815 \n1816     def get_path_info(self, filtered_relation=None):\n1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1818 \n1819     @cached_property\n1820     def path_infos(self):\n1821         return self.get_path_info()\n1822 \n1823     def get_reverse_path_info(self, filtered_relation=None):\n1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1825 \n1826     @cached_property\n1827     def reverse_path_infos(self):\n1828         return self.get_reverse_path_info()\n1829 \n1830     def _get_m2m_db_table(self, opts):\n1831         \"\"\"\n1832         Function that can be curried to provide the m2m table name for this\n1833         relation.\n1834         \"\"\"\n1835         if self.remote_field.through is not None:\n1836             return self.remote_field.through._meta.db_table\n1837         elif self.db_table:\n1838             return self.db_table\n1839         else:\n1840             m2m_table_name = \"%s_%s\" % (utils.strip_quotes(opts.db_table), self.name)\n1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1842 \n1843     def _get_m2m_attr(self, related, attr):\n1844         \"\"\"\n1845         Function that can be curried to provide the source accessor or DB\n1846         column name for the m2m table.\n1847         \"\"\"\n1848         cache_attr = \"_m2m_%s_cache\" % attr\n1849         if hasattr(self, cache_attr):\n1850             return getattr(self, cache_attr)\n1851         if self.remote_field.through_fields is not None:\n1852             link_field_name = self.remote_field.through_fields[0]\n1853         else:\n1854             link_field_name = None\n1855         for f in self.remote_field.through._meta.fields:\n1856             if (\n1857                 f.is_relation\n1858                 and f.remote_field.model == related.related_model\n1859                 and (link_field_name is None or link_field_name == f.name)\n1860             ):\n1861                 setattr(self, cache_attr, getattr(f, attr))\n1862                 return getattr(self, cache_attr)\n1863 \n1864     def _get_m2m_reverse_attr(self, related, attr):\n1865         \"\"\"\n1866         Function that can be curried to provide the related accessor or DB\n1867         column name for the m2m table.\n1868         \"\"\"\n1869         cache_attr = \"_m2m_reverse_%s_cache\" % attr\n1870         if hasattr(self, cache_attr):\n1871             return getattr(self, cache_attr)\n1872         found = False\n1873         if self.remote_field.through_fields is not None:\n1874             link_field_name = self.remote_field.through_fields[1]\n1875         else:\n1876             link_field_name = None\n1877         for f in self.remote_field.through._meta.fields:\n1878             if f.is_relation and f.remote_field.model == related.model:\n1879                 if link_field_name is None and related.related_model == related.model:\n1880                     # If this is an m2m-intermediate to self,\n1881                     # the first foreign key you find will be\n1882                     # the source column. Keep searching for\n1883                     # the second foreign key.\n1884                     if found:\n1885                         setattr(self, cache_attr, getattr(f, attr))\n1886                         break\n1887                     else:\n1888                         found = True\n1889                 elif link_field_name is None or link_field_name == f.name:\n1890                     setattr(self, cache_attr, getattr(f, attr))\n1891                     break\n1892         return getattr(self, cache_attr)\n1893 \n1894     def contribute_to_class(self, cls, name, **kwargs):\n1895         # To support multiple relations to self, it's useful to have a non-None\n1896         # related name on symmetrical relations for internal reasons. The\n1897         # concept doesn't make a lot of sense externally (\"you want me to\n1898         # specify *what* on my non-reversible relation?!\"), so we set it up\n1899         # automatically. The funky name reduces the chance of an accidental\n1900         # clash.\n1901         if self.remote_field.symmetrical and (\n1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT\n1903             or self.remote_field.model == cls._meta.object_name\n1904         ):\n1905             self.remote_field.related_name = \"%s_rel_+\" % name\n1906         elif self.remote_field.is_hidden():\n1907             # If the backwards relation is disabled, replace the original\n1908             # related_name with one generated from the m2m field name. Django\n1909             # still uses backwards relations internally and we need to avoid\n1910             # clashes between multiple m2m fields with related_name == '+'.\n1911             self.remote_field.related_name = \"_%s_%s_%s_+\" % (\n1912                 cls._meta.app_label,\n1913                 cls.__name__.lower(),\n1914                 name,\n1915             )\n1916 \n1917         super().contribute_to_class(cls, name, **kwargs)\n1918 \n1919         # The intermediate m2m model is not auto created if:\n1920         #  1) There is a manually specified intermediate, or\n1921         #  2) The class owning the m2m field is abstract.\n1922         #  3) The class owning the m2m field has been swapped out.\n1923         if not cls._meta.abstract:\n1924             if self.remote_field.through:\n1925 \n1926                 def resolve_through_model(_, model, field):\n1927                     field.remote_field.through = model\n1928 \n1929                 lazy_related_operation(\n1930                     resolve_through_model, cls, self.remote_field.through, field=self\n1931                 )\n1932             elif not cls._meta.swapped:\n1933                 self.remote_field.through = create_many_to_many_intermediary_model(\n1934                     self, cls\n1935                 )\n1936 \n1937         # Add the descriptor for the m2m relation.\n1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1939 \n1940         # Set up the accessor for the m2m table name for the relation.\n1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1942 \n1943     def contribute_to_related_class(self, cls, related):\n1944         # Internal M2Ms (i.e., those with a related name ending with '+')\n1945         # and swapped models don't get a related descriptor.\n1946         if (\n1947             not self.remote_field.is_hidden()\n1948             and not related.related_model._meta.swapped\n1949         ):\n1950             setattr(\n1951                 cls,\n1952                 related.get_accessor_name(),\n1953                 ManyToManyDescriptor(self.remote_field, reverse=True),\n1954             )\n1955 \n1956         # Set up the accessors for the column names on the m2m table.\n1957         self.m2m_column_name = partial(self._get_m2m_attr, related, \"column\")\n1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, \"column\")\n1959 \n1960         self.m2m_field_name = partial(self._get_m2m_attr, related, \"name\")\n1961         self.m2m_reverse_field_name = partial(\n1962             self._get_m2m_reverse_attr, related, \"name\"\n1963         )\n1964 \n1965         get_m2m_rel = partial(self._get_m2m_attr, related, \"remote_field\")\n1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1967         get_m2m_reverse_rel = partial(\n1968             self._get_m2m_reverse_attr, related, \"remote_field\"\n1969         )\n1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1971 \n1972     def set_attributes_from_rel(self):\n1973         pass\n1974 \n1975     def value_from_object(self, obj):\n1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1977 \n1978     def save_form_data(self, instance, data):\n1979         getattr(instance, self.attname).set(data)\n1980 \n1981     def formfield(self, *, using=None, **kwargs):\n1982         defaults = {\n1983             \"form_class\": forms.ModelMultipleChoiceField,\n1984             \"queryset\": self.remote_field.model._default_manager.using(using),\n1985             **kwargs,\n1986         }\n1987         # If initial is passed in, it's a list of related objects, but the\n1988         # MultipleChoiceField takes a list of IDs.\n1989         if defaults.get(\"initial\") is not None:\n1990             initial = defaults[\"initial\"]\n1991             if callable(initial):\n1992                 initial = initial()\n1993             defaults[\"initial\"] = [i.pk for i in initial]\n1994         return super().formfield(**defaults)\n1995 \n1996     def db_check(self, connection):\n1997         return None\n1998 \n1999     def db_type(self, connection):\n2000         # A ManyToManyField is not represented by a single column,\n2001         # so return None.\n2002         return None\n2003 \n2004     def db_parameters(self, connection):\n2005         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]