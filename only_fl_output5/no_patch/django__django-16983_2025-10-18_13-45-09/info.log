2025-10-18 13:45:10.095 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 13:45:14.909 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=262, output_tokens=12, cost=0.002980
2025-10-18 13:45:14.910 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 13:45:14.914 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:45:24.783 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=570, output_tokens=338, cost=0.015840
2025-10-18 13:45:24.823 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:45:28.135 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=74, cost=0.009140
2025-10-18 13:45:28.136 | DEBUG    | Extracted a valid json.
2025-10-18 13:45:28.137 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class(\"filter_horizontal\", \"ModelAdmin\")",
        "search_method_in_class(\"filter_vertical\", \"ModelAdmin\")",
        "search_method_in_class(\"check\", \"ManyToManyField\")",
        "search_code(\"ManyToManyField(through=\")"
    ],
    "bug_locations": []
}
2025-10-18 13:45:28.177 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:45:28.178 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:45:44.893 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1250, output_tokens=689, cost=0.033170
2025-10-18 13:45:44.908 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:45:55.886 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2155, output_tokens=446, cost=0.034930
2025-10-18 13:45:55.896 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:46:01.907 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=800, output_tokens=214, cost=0.014420
2025-10-18 13:46:01.908 | DEBUG    | Extracted a valid json.
2025-10-18 13:46:01.908 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"system checks ModelAdmin\")",
        "search_code(\"admin check framework\")"
    ],
    "bug_locations": [
        {
            "file": "django/db/models/fields/related.py",
            "class": "ManyToManyField",
            "method": "check",
            "intended_behavior": "This method should include a new validation check that ensures `filter_horizontal` or `filter_vertical` is not used with `ManyToManyField` configured with a custom through model. This check should generate a warning or error within the Django system checks framework if such a configuration is detected, guiding developers to avoid this unsupported setup."
        },
        {
            "file": "",
            "class": "",
            "method": "",
            "intended_behavior": "Extend the validation logic to ensure `filter_horizontal` and `filter_vertical` are compatible with the fields they are configured to manage, explicitly checking against the unsupported `ManyToManyField` with a custom `through` attribute."
        }
    ]
}
2025-10-18 13:46:01.972 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:46:01.973 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:46:14.509 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2758, output_tokens=562, cost=0.044440
2025-10-18 13:46:14.519 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:46:27.553 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3536, output_tokens=560, cost=0.052160
2025-10-18 13:46:27.562 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:46:31.468 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=914, output_tokens=157, cost=0.013850
2025-10-18 13:46:31.469 | DEBUG    | Extracted a valid json.
2025-10-18 13:46:31.469 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/related.py",
            "class": "ManyToManyField",
            "method": "check",
            "intended_behavior": "Enhance this method to include a new system check verifying whether a ManyToManyField with a custom through model is being used in conjunction with filter_horizontal or filter_vertical options in a ModelAdmin definition. Since the direct relationship between ManyToManyField instances and ModelAdmin instances might not be straightforward to establish within this context, the feasible approach is to issue a guideline or warning in the Django documentation or framework messages indicating the incompatibility of filter_horizontal and filter_vertical with ManyToManyField(through=\"...\")."
        }
    ]
}
2025-10-18 13:46:31.472 | DEBUG    | Found override of check in RelatedField
2025-10-18 13:46:31.472 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x761e6b526c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x761d7b11a3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x761d78dc3800>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x761d7b11a480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x761d78d3bf50>
    └ <function run_task_in_subprocess at 0x761d7b11a660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x761d78d3bf50>
    │        │      └ <function run_raw_task at 0x761d7b11a700>
    │        └ <function ProcessPoolExecutor.submit at 0x761e6ae72020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x761e6ae71da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x761e6ae71ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x761e6ae71f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x761e6b02cea0>
    └ <ForkProcess name='ForkProcess-205' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-205' parent=497161 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x761e6b09e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-205' parent=497161 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-205' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-205' parent=497161 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-205' parent=497161 started>
    │    └ <function Popen._launch at 0x761d7911b7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x761d7a57e6f0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x761e6b02d8a0>
           └ <ForkProcess name='ForkProcess-205' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x761e6b02ce00>
    └ <ForkProcess name='ForkProcess-205' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-205' parent=497161 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x761d795c47d0>, <multiprocessing.queues.SimpleQueue object at 0x761d795c6d...
    │    │        └ <ForkProcess name='ForkProcess-205' parent=497161 started>
    │    └ <function _process_worker at 0x761e6ae711c0>
    └ <ForkProcess name='ForkProcess-205' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x761d7a57e720>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         └ <function run_raw_task at 0x761d7b11a700>
        └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output5/django__django-16983_2025-10-18_13-45-09'
             │            │    └ <function RawSweTask.to_task at 0x761d7b1196c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x761d7a57e720>
             └ <function do_inference at 0x761d7b11a8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x761d7b228400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x761d7b9b84a0>
       │                 │         │            └ SweTask(task_id='django__django-16983', problem_statement='Add system check for filter_horizontal/filter_vertical on ManyToMa...
       │                 │         └ <app.manage.ProjectApiManager object at 0x761d7b21d610>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output5/django__django-16983_2025-10-18_13-45-09/output_0')
       └ <function _run_one_task at 0x761d7b2298a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x761d7b431bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
                                  └ <app.manage.ProjectApiManager object at 0x761d7b21d610>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'django/db/models/fields/related.py', 'class': 'ManyToManyField', 'method': 'check', 'intended_behavior': 'Enhance t...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x761d7b4318a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ 'check'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/mo...
    │    │                      │   └ 'ManyToManyField'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/mo...
    │    └ <function SearchBackend._get_inherited_methods at 0x761d7b431800>
    └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'RelatedField', 'method_name': 'check'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x761d7b430f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x761d7b6a3170>, {'class_name': 'RelatedField', 'method_name': 'check'})
           └ <function SearchBackend.search_method_in_class at 0x761d7b430ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-18 13:46:31.480 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>check</method>
<code>
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]

</code><intended_behavior>Enhance this method to include a new system check verifying whether a ManyToManyField with a custom through model is being used in conjunction with filter_horizontal or filter_vertical options in a ModelAdmin definition. Since the direct relationship between ManyToManyField instances and ModelAdmin instances might not be straightforward to establish within this context, the feasible approach is to issue a guideline or warning in the Django documentation or framework messages indicating the incompatibility of filter_horizontal and filter_vertical with ManyToManyField(through="...").</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1324 class ManyToManyField(RelatedField):
1325     """
1326     Provide a many-to-many relation by using an intermediary model that
1327     holds two ForeignKey fields pointed at the two sides of the relation.
1328 
1329     Unless a ``through`` model was provided, ManyToManyField will use the
1330     create_many_to_many_intermediary_model factory to automatically generate
1331     the intermediary model.
1332     """
1333 
1334     # Field flags
1335     many_to_many = True
1336     many_to_one = False
1337     one_to_many = False
1338     one_to_one = False
1339 
1340     rel_class = ManyToManyRel
1341 
1342     description = _("Many-to-many relationship")
1343 
1344     def __init__(
1345         self,
1346         to,
1347         related_name=None,
1348         related_query_name=None,
1349         limit_choices_to=None,
1350         symmetrical=None,
1351         through=None,
1352         through_fields=None,
1353         db_constraint=True,
1354         db_table=None,
1355         swappable=True,
1356         **kwargs,
1357     ):
1358         try:
1359             to._meta
1360         except AttributeError:
1361             if not isinstance(to, str):
1362                 raise TypeError(
1363                     "%s(%r) is invalid. First parameter to ManyToManyField "
1364                     "must be either a model, a model name, or the string %r"
1365                     % (
1366                         self.__class__.__name__,
1367                         to,
1368                         RECURSIVE_RELATIONSHIP_CONSTANT,
1369                     )
1370                 )
1371 
1372         if symmetrical is None:
1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1374 
1375         if through is not None and db_table is not None:
1376             raise ValueError(
1377                 "Cannot specify a db_table if an intermediary model is used."
1378             )
1379 
1380         kwargs["rel"] = self.rel_class(
1381             self,
1382             to,
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             symmetrical=symmetrical,
1387             through=through,
1388             through_fields=through_fields,
1389             db_constraint=db_constraint,
1390         )
1391         self.has_null_arg = "null" in kwargs
1392 
1393         super().__init__(
1394             related_name=related_name,
1395             related_query_name=related_query_name,
1396             limit_choices_to=limit_choices_to,
1397             **kwargs,
1398         )
1399 
1400         self.db_table = db_table
1401         self.swappable = swappable
1402 
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]
1411 
1412     def _check_unique(self, **kwargs):
1413         if self.unique:
1414             return [
1415                 checks.Error(
1416                     "ManyToManyFields cannot be unique.",
1417                     obj=self,
1418                     id="fields.E330",
1419                 )
1420             ]
1421         return []
1422 
1423     def _check_ignored_options(self, **kwargs):
1424         warnings = []
1425 
1426         if self.has_null_arg:
1427             warnings.append(
1428                 checks.Warning(
1429                     "null has no effect on ManyToManyField.",
1430                     obj=self,
1431                     id="fields.W340",
1432                 )
1433             )
1434 
1435         if self._validators:
1436             warnings.append(
1437                 checks.Warning(
1438                     "ManyToManyField does not support validators.",
1439                     obj=self,
1440                     id="fields.W341",
1441                 )
1442             )
1443         if self.remote_field.symmetrical and self._related_name:
1444             warnings.append(
1445                 checks.Warning(
1446                     "related_name has no effect on ManyToManyField "
1447                     'with a symmetrical relationship, e.g. to "self".',
1448                     obj=self,
1449                     id="fields.W345",
1450                 )
1451             )
1452         if self.db_comment:
1453             warnings.append(
1454                 checks.Warning(
1455                     "db_comment has no effect on ManyToManyField.",
1456                     obj=self,
1457                     id="fields.W346",
1458                 )
1459             )
1460 
1461         return warnings
1462 
1463     def _check_relationship_model(self, from_model=None, **kwargs):
1464         if hasattr(self.remote_field.through, "_meta"):
1465             qualified_model_name = "%s.%s" % (
1466                 self.remote_field.through._meta.app_label,
1467                 self.remote_field.through.__name__,
1468             )
1469         else:
1470             qualified_model_name = self.remote_field.through
1471 
1472         errors = []
1473 
1474         if self.remote_field.through not in self.opts.apps.get_models(
1475             include_auto_created=True
1476         ):
1477             # The relationship model is not installed.
1478             errors.append(
1479                 checks.Error(
1480                     "Field specifies a many-to-many relation through model "
1481                     "'%s', which has not been installed." % qualified_model_name,
1482                     obj=self,
1483                     id="fields.E331",
1484                 )
1485             )
1486 
1487         else:
1488             assert from_model is not None, (
1489                 "ManyToManyField with intermediate "
1490                 "tables cannot be checked if you don't pass the model "
1491                 "where the field is attached to."
1492             )
1493             # Set some useful local variables
1494             to_model = resolve_relation(from_model, self.remote_field.model)
1495             from_model_name = from_model._meta.object_name
1496             if isinstance(to_model, str):
1497                 to_model_name = to_model
1498             else:
1499                 to_model_name = to_model._meta.object_name
1500             relationship_model_name = self.remote_field.through._meta.object_name
1501             self_referential = from_model == to_model
1502             # Count foreign keys in intermediate model
1503             if self_referential:
1504                 seen_self = sum(
1505                     from_model == getattr(field.remote_field, "model", None)
1506                     for field in self.remote_field.through._meta.fields
1507                 )
1508 
1509                 if seen_self > 2 and not self.remote_field.through_fields:
1510                     errors.append(
1511                         checks.Error(
1512                             "The model is used as an intermediate model by "
1513                             "'%s', but it has more than two foreign keys "
1514                             "to '%s', which is ambiguous. You must specify "
1515                             "which two foreign keys Django should use via the "
1516                             "through_fields keyword argument."
1517                             % (self, from_model_name),
1518                             hint=(
1519                                 "Use through_fields to specify which two foreign keys "
1520                                 "Django should use."
1521                             ),
1522                             obj=self.remote_field.through,
1523                             id="fields.E333",
1524                         )
1525                     )
1526 
1527             else:
1528                 # Count foreign keys in relationship model
1529                 seen_from = sum(
1530                     from_model == getattr(field.remote_field, "model", None)
1531                     for field in self.remote_field.through._meta.fields
1532                 )
1533                 seen_to = sum(
1534                     to_model == getattr(field.remote_field, "model", None)
1535                     for field in self.remote_field.through._meta.fields
1536                 )
1537 
1538                 if seen_from > 1 and not self.remote_field.through_fields:
1539                     errors.append(
1540                         checks.Error(
1541                             (
1542                                 "The model is used as an intermediate model by "
1543                                 "'%s', but it has more than one foreign key "
1544                                 "from '%s', which is ambiguous. You must specify "
1545                                 "which foreign key Django should use via the "
1546                                 "through_fields keyword argument."
1547                             )
1548                             % (self, from_model_name),
1549                             hint=(
1550                                 "If you want to create a recursive relationship, "
1551                                 'use ManyToManyField("%s", through="%s").'
1552                             )
1553                             % (
1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1555                                 relationship_model_name,
1556                             ),
1557                             obj=self,
1558                             id="fields.E334",
1559                         )
1560                     )
1561 
1562                 if seen_to > 1 and not self.remote_field.through_fields:
1563                     errors.append(
1564                         checks.Error(
1565                             "The model is used as an intermediate model by "
1566                             "'%s', but it has more than one foreign key "
1567                             "to '%s', which is ambiguous. You must specify "
1568                             "which foreign key Django should use via the "
1569                             "through_fields keyword argument." % (self, to_model_name),
1570                             hint=(
1571                                 "If you want to create a recursive relationship, "
1572                                 'use ManyToManyField("%s", through="%s").'
1573                             )
1574                             % (
1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1576                                 relationship_model_name,
1577                             ),
1578                             obj=self,
1579                             id="fields.E335",
1580                         )
1581                     )
1582 
1583                 if seen_from == 0 or seen_to == 0:
1584                     errors.append(
1585                         checks.Error(
1586                             "The model is used as an intermediate model by "
1587                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1588                             % (self, from_model_name, to_model_name),
1589                             obj=self.remote_field.through,
1590                             id="fields.E336",
1591                         )
1592                     )
1593 
1594         # Validate `through_fields`.
1595         if self.remote_field.through_fields is not None:
1596             # Validate that we're given an iterable of at least two items
1597             # and that none of them is "falsy".
1598             if not (
1599                 len(self.remote_field.through_fields) >= 2
1600                 and self.remote_field.through_fields[0]
1601                 and self.remote_field.through_fields[1]
1602             ):
1603                 errors.append(
1604                     checks.Error(
1605                         "Field specifies 'through_fields' but does not provide "
1606                         "the names of the two link fields that should be used "
1607                         "for the relation through model '%s'." % qualified_model_name,
1608                         hint=(
1609                             "Make sure you specify 'through_fields' as "
1610                             "through_fields=('field1', 'field2')"
1611                         ),
1612                         obj=self,
1613                         id="fields.E337",
1614                     )
1615                 )
1616 
1617             # Validate the given through fields -- they should be actual
1618             # fields on the through model, and also be foreign keys to the
1619             # expected models.
1620             else:
1621                 assert from_model is not None, (
1622                     "ManyToManyField with intermediate "
1623                     "tables cannot be checked if you don't pass the model "
1624                     "where the field is attached to."
1625                 )
1626 
1627                 source, through, target = (
1628                     from_model,
1629                     self.remote_field.through,
1630                     self.remote_field.model,
1631                 )
1632                 source_field_name, target_field_name = self.remote_field.through_fields[
1633                     :2
1634                 ]
1635 
1636                 for field_name, related_model in (
1637                     (source_field_name, source),
1638                     (target_field_name, target),
1639                 ):
1640                     possible_field_names = []
1641                     for f in through._meta.fields:
1642                         if (
1643                             hasattr(f, "remote_field")
1644                             and getattr(f.remote_field, "model", None) == related_model
1645                         ):
1646                             possible_field_names.append(f.name)
1647                     if possible_field_names:
1648                         hint = (
1649                             "Did you mean one of the following foreign keys to '%s': "
1650                             "%s?"
1651                             % (
1652                                 related_model._meta.object_name,
1653                                 ", ".join(possible_field_names),
1654                             )
1655                         )
1656                     else:
1657                         hint = None
1658 
1659                     try:
1660                         field = through._meta.get_field(field_name)
1661                     except exceptions.FieldDoesNotExist:
1662                         errors.append(
1663                             checks.Error(
1664                                 "The intermediary model '%s' has no field '%s'."
1665                                 % (qualified_model_name, field_name),
1666                                 hint=hint,
1667                                 obj=self,
1668                                 id="fields.E338",
1669                             )
1670                         )
1671                     else:
1672                         if not (
1673                             hasattr(field, "remote_field")
1674                             and getattr(field.remote_field, "model", None)
1675                             == related_model
1676                         ):
1677                             errors.append(
1678                                 checks.Error(
1679                                     "'%s.%s' is not a foreign key to '%s'."
1680                                     % (
1681                                         through._meta.object_name,
1682                                         field_name,
1683                                         related_model._meta.object_name,
1684                                     ),
1685                                     hint=hint,
1686                                     obj=self,
1687                                     id="fields.E339",
1688                                 )
1689                             )
1690 
1691         return errors
1692 
1693     def _check_table_uniqueness(self, **kwargs):
1694         if (
1695             isinstance(self.remote_field.through, str)
1696             or not self.remote_field.through._meta.managed
1697         ):
1698             return []
1699         registered_tables = {
1700             model._meta.db_table: model
1701             for model in self.opts.apps.get_models(include_auto_created=True)
1702             if model != self.remote_field.through and model._meta.managed
1703         }
1704         m2m_db_table = self.m2m_db_table()
1705         model = registered_tables.get(m2m_db_table)
1706         # The second condition allows multiple m2m relations on a model if
1707         # some point to a through model that proxies another through model.
1708         if (
1709             model
1710             and model._meta.concrete_model
1711             != self.remote_field.through._meta.concrete_model
1712         ):
1713             if model._meta.auto_created:
1714 
1715                 def _get_field_name(model):
1716                     for field in model._meta.auto_created._meta.many_to_many:
1717                         if field.remote_field.through is model:
1718                             return field.name
1719 
1720                 opts = model._meta.auto_created._meta
1721                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1722             else:
1723                 clashing_obj = model._meta.label
1724             if settings.DATABASE_ROUTERS:
1725                 error_class, error_id = checks.Warning, "fields.W344"
1726                 error_hint = (
1727                     "You have configured settings.DATABASE_ROUTERS. Verify "
1728                     "that the table of %r is correctly routed to a separate "
1729                     "database." % clashing_obj
1730                 )
1731             else:
1732                 error_class, error_id = checks.Error, "fields.E340"
1733                 error_hint = None
1734             return [
1735                 error_class(
1736                     "The field's intermediary table '%s' clashes with the "
1737                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1738                     obj=self,
1739                     hint=error_hint,
1740                     id=error_id,
1741                 )
1742             ]
1743         return []
1744 
1745     def deconstruct(self):
1746         name, path, args, kwargs = super().deconstruct()
1747         # Handle the simpler arguments.
1748         if self.db_table is not None:
1749             kwargs["db_table"] = self.db_table
1750         if self.remote_field.db_constraint is not True:
1751             kwargs["db_constraint"] = self.remote_field.db_constraint
1752         # Lowercase model names as they should be treated as case-insensitive.
1753         if isinstance(self.remote_field.model, str):
1754             if "." in self.remote_field.model:
1755                 app_label, model_name = self.remote_field.model.split(".")
1756                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1757             else:
1758                 kwargs["to"] = self.remote_field.model.lower()
1759         else:
1760             kwargs["to"] = self.remote_field.model._meta.label_lower
1761         if getattr(self.remote_field, "through", None) is not None:
1762             if isinstance(self.remote_field.through, str):
1763                 kwargs["through"] = self.remote_field.through
1764             elif not self.remote_field.through._meta.auto_created:
1765                 kwargs["through"] = self.remote_field.through._meta.label
1766         # If swappable is True, then see if we're actually pointing to the target
1767         # of a swap.
1768         swappable_setting = self.swappable_setting
1769         if swappable_setting is not None:
1770             # If it's already a settings reference, error.
1771             if hasattr(kwargs["to"], "setting_name"):
1772                 if kwargs["to"].setting_name != swappable_setting:
1773                     raise ValueError(
1774                         "Cannot deconstruct a ManyToManyField pointing to a "
1775                         "model that is swapped in place of more than one model "
1776                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1777                     )
1778 
1779             kwargs["to"] = SettingsReference(
1780                 kwargs["to"],
1781                 swappable_setting,
1782             )
1783         return name, path, args, kwargs
1784 
1785     def _get_path_info(self, direct=False, filtered_relation=None):
1786         """Called by both direct and indirect m2m traversal."""
1787         int_model = self.remote_field.through
1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1790         if direct:
1791             join1infos = linkfield1.reverse_path_infos
1792             if filtered_relation:
1793                 join2infos = linkfield2.get_path_info(filtered_relation)
1794             else:
1795                 join2infos = linkfield2.path_infos
1796         else:
1797             join1infos = linkfield2.reverse_path_infos
1798             if filtered_relation:
1799                 join2infos = linkfield1.get_path_info(filtered_relation)
1800             else:
1801                 join2infos = linkfield1.path_infos
1802         # Get join infos between the last model of join 1 and the first model
1803         # of join 2. Assume the only reason these may differ is due to model
1804         # inheritance.
1805         join1_final = join1infos[-1].to_opts
1806         join2_initial = join2infos[0].from_opts
1807         if join1_final is join2_initial:
1808             intermediate_infos = []
1809         elif issubclass(join1_final.model, join2_initial.model):
1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1811         else:
1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1813 
1814         return [*join1infos, *intermediate_infos, *join2infos]
1815 
1816     def get_path_info(self, filtered_relation=None):
1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1818 
1819     @cached_property
1820     def path_infos(self):
1821         return self.get_path_info()
1822 
1823     def get_reverse_path_info(self, filtered_relation=None):
1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1825 
1826     @cached_property
1827     def reverse_path_infos(self):
1828         return self.get_reverse_path_info()
1829 
1830     def _get_m2m_db_table(self, opts):
1831         """
1832         Function that can be curried to provide the m2m table name for this
1833         relation.
1834         """
1835         if self.remote_field.through is not None:
1836             return self.remote_field.through._meta.db_table
1837         elif self.db_table:
1838             return self.db_table
1839         else:
1840             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1842 
1843     def _get_m2m_attr(self, related, attr):
1844         """
1845         Function that can be curried to provide the source accessor or DB
1846         column name for the m2m table.
1847         """
1848         cache_attr = "_m2m_%s_cache" % attr
1849         if hasattr(self, cache_attr):
1850             return getattr(self, cache_attr)
1851         if self.remote_field.through_fields is not None:
1852             link_field_name = self.remote_field.through_fields[0]
1853         else:
1854             link_field_name = None
1855         for f in self.remote_field.through._meta.fields:
1856             if (
1857                 f.is_relation
1858                 and f.remote_field.model == related.related_model
1859                 and (link_field_name is None or link_field_name == f.name)
1860             ):
1861                 setattr(self, cache_attr, getattr(f, attr))
1862                 return getattr(self, cache_attr)
1863 
1864     def _get_m2m_reverse_attr(self, related, attr):
1865         """
1866         Function that can be curried to provide the related accessor or DB
1867         column name for the m2m table.
1868         """
1869         cache_attr = "_m2m_reverse_%s_cache" % attr
1870         if hasattr(self, cache_attr):
1871             return getattr(self, cache_attr)
1872         found = False
1873         if self.remote_field.through_fields is not None:
1874             link_field_name = self.remote_field.through_fields[1]
1875         else:
1876             link_field_name = None
1877         for f in self.remote_field.through._meta.fields:
1878             if f.is_relation and f.remote_field.model == related.model:
1879                 if link_field_name is None and related.related_model == related.model:
1880                     # If this is an m2m-intermediate to self,
1881                     # the first foreign key you find will be
1882                     # the source column. Keep searching for
1883                     # the second foreign key.
1884                     if found:
1885                         setattr(self, cache_attr, getattr(f, attr))
1886                         break
1887                     else:
1888                         found = True
1889                 elif link_field_name is None or link_field_name == f.name:
1890                     setattr(self, cache_attr, getattr(f, attr))
1891                     break
1892         return getattr(self, cache_attr)
1893 
1894     def contribute_to_class(self, cls, name, **kwargs):
1895         # To support multiple relations to self, it's useful to have a non-None
1896         # related name on symmetrical relations for internal reasons. The
1897         # concept doesn't make a lot of sense externally ("you want me to
1898         # specify *what* on my non-reversible relation?!"), so we set it up
1899         # automatically. The funky name reduces the chance of an accidental
1900         # clash.
1901         if self.remote_field.symmetrical and (
1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1903             or self.remote_field.model == cls._meta.object_name
1904         ):
1905             self.remote_field.related_name = "%s_rel_+" % name
1906         elif self.remote_field.is_hidden():
1907             # If the backwards relation is disabled, replace the original
1908             # related_name with one generated from the m2m field name. Django
1909             # still uses backwards relations internally and we need to avoid
1910             # clashes between multiple m2m fields with related_name == '+'.
1911             self.remote_field.related_name = "_%s_%s_%s_+" % (
1912                 cls._meta.app_label,
1913                 cls.__name__.lower(),
1914                 name,
1915             )
1916 
1917         super().contribute_to_class(cls, name, **kwargs)
1918 
1919         # The intermediate m2m model is not auto created if:
1920         #  1) There is a manually specified intermediate, or
1921         #  2) The class owning the m2m field is abstract.
1922         #  3) The class owning the m2m field has been swapped out.
1923         if not cls._meta.abstract:
1924             if self.remote_field.through:
1925 
1926                 def resolve_through_model(_, model, field):
1927                     field.remote_field.through = model
1928 
1929                 lazy_related_operation(
1930                     resolve_through_model, cls, self.remote_field.through, field=self
1931                 )
1932             elif not cls._meta.swapped:
1933                 self.remote_field.through = create_many_to_many_intermediary_model(
1934                     self, cls
1935                 )
1936 
1937         # Add the descriptor for the m2m relation.
1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1939 
1940         # Set up the accessor for the m2m table name for the relation.
1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1942 
1943     def contribute_to_related_class(self, cls, related):
1944         # Internal M2Ms (i.e., those with a related name ending with '+')
1945         # and swapped models don't get a related descriptor.
1946         if (
1947             not self.remote_field.is_hidden()
1948             and not related.related_model._meta.swapped
1949         ):
1950             setattr(
1951                 cls,
1952                 related.get_accessor_name(),
1953                 ManyToManyDescriptor(self.remote_field, reverse=True),
1954             )
1955 
1956         # Set up the accessors for the column names on the m2m table.
1957         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1959 
1960         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1961         self.m2m_reverse_field_name = partial(
1962             self._get_m2m_reverse_attr, related, "name"
1963         )
1964 
1965         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1967         get_m2m_reverse_rel = partial(
1968             self._get_m2m_reverse_attr, related, "remote_field"
1969         )
1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1971 
1972     def set_attributes_from_rel(self):
1973         pass
1974 
1975     def value_from_object(self, obj):
1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1977 
1978     def save_form_data(self, instance, data):
1979         getattr(instance, self.attname).set(data)
1980 
1981     def formfield(self, *, using=None, **kwargs):
1982         defaults = {
1983             "form_class": forms.ModelMultipleChoiceField,
1984             "queryset": self.remote_field.model._default_manager.using(using),
1985             **kwargs,
1986         }
1987         # If initial is passed in, it's a list of related objects, but the
1988         # MultipleChoiceField takes a list of IDs.
1989         if defaults.get("initial") is not None:
1990             initial = defaults["initial"]
1991             if callable(initial):
1992                 initial = initial()
1993             defaults["initial"] = [i.pk for i in initial]
1994         return super().formfield(**defaults)
1995 
1996     def db_check(self, connection):
1997         return None
1998 
1999     def db_type(self, connection):
2000         # A ManyToManyField is not represented by a single column,
2001         # so return None.
2002         return None
2003 
2004     def db_parameters(self, connection):
2005         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 13:46:31.481 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>check</method>
<code>
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]

</code><intended_behavior>Enhance this method to include a new system check verifying whether a ManyToManyField with a custom through model is being used in conjunction with filter_horizontal or filter_vertical options in a ModelAdmin definition. Since the direct relationship between ManyToManyField instances and ModelAdmin instances might not be straightforward to establish within this context, the feasible approach is to issue a guideline or warning in the Django documentation or framework messages indicating the incompatibility of filter_horizontal and filter_vertical with ManyToManyField(through="...").</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1324 class ManyToManyField(RelatedField):
1325     """
1326     Provide a many-to-many relation by using an intermediary model that
1327     holds two ForeignKey fields pointed at the two sides of the relation.
1328 
1329     Unless a ``through`` model was provided, ManyToManyField will use the
1330     create_many_to_many_intermediary_model factory to automatically generate
1331     the intermediary model.
1332     """
1333 
1334     # Field flags
1335     many_to_many = True
1336     many_to_one = False
1337     one_to_many = False
1338     one_to_one = False
1339 
1340     rel_class = ManyToManyRel
1341 
1342     description = _("Many-to-many relationship")
1343 
1344     def __init__(
1345         self,
1346         to,
1347         related_name=None,
1348         related_query_name=None,
1349         limit_choices_to=None,
1350         symmetrical=None,
1351         through=None,
1352         through_fields=None,
1353         db_constraint=True,
1354         db_table=None,
1355         swappable=True,
1356         **kwargs,
1357     ):
1358         try:
1359             to._meta
1360         except AttributeError:
1361             if not isinstance(to, str):
1362                 raise TypeError(
1363                     "%s(%r) is invalid. First parameter to ManyToManyField "
1364                     "must be either a model, a model name, or the string %r"
1365                     % (
1366                         self.__class__.__name__,
1367                         to,
1368                         RECURSIVE_RELATIONSHIP_CONSTANT,
1369                     )
1370                 )
1371 
1372         if symmetrical is None:
1373             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1374 
1375         if through is not None and db_table is not None:
1376             raise ValueError(
1377                 "Cannot specify a db_table if an intermediary model is used."
1378             )
1379 
1380         kwargs["rel"] = self.rel_class(
1381             self,
1382             to,
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             symmetrical=symmetrical,
1387             through=through,
1388             through_fields=through_fields,
1389             db_constraint=db_constraint,
1390         )
1391         self.has_null_arg = "null" in kwargs
1392 
1393         super().__init__(
1394             related_name=related_name,
1395             related_query_name=related_query_name,
1396             limit_choices_to=limit_choices_to,
1397             **kwargs,
1398         )
1399 
1400         self.db_table = db_table
1401         self.swappable = swappable
1402 
1403     def check(self, **kwargs):
1404         return [
1405             *super().check(**kwargs),
1406             *self._check_unique(**kwargs),
1407             *self._check_relationship_model(**kwargs),
1408             *self._check_ignored_options(**kwargs),
1409             *self._check_table_uniqueness(**kwargs),
1410         ]
1411 
1412     def _check_unique(self, **kwargs):
1413         if self.unique:
1414             return [
1415                 checks.Error(
1416                     "ManyToManyFields cannot be unique.",
1417                     obj=self,
1418                     id="fields.E330",
1419                 )
1420             ]
1421         return []
1422 
1423     def _check_ignored_options(self, **kwargs):
1424         warnings = []
1425 
1426         if self.has_null_arg:
1427             warnings.append(
1428                 checks.Warning(
1429                     "null has no effect on ManyToManyField.",
1430                     obj=self,
1431                     id="fields.W340",
1432                 )
1433             )
1434 
1435         if self._validators:
1436             warnings.append(
1437                 checks.Warning(
1438                     "ManyToManyField does not support validators.",
1439                     obj=self,
1440                     id="fields.W341",
1441                 )
1442             )
1443         if self.remote_field.symmetrical and self._related_name:
1444             warnings.append(
1445                 checks.Warning(
1446                     "related_name has no effect on ManyToManyField "
1447                     'with a symmetrical relationship, e.g. to "self".',
1448                     obj=self,
1449                     id="fields.W345",
1450                 )
1451             )
1452         if self.db_comment:
1453             warnings.append(
1454                 checks.Warning(
1455                     "db_comment has no effect on ManyToManyField.",
1456                     obj=self,
1457                     id="fields.W346",
1458                 )
1459             )
1460 
1461         return warnings
1462 
1463     def _check_relationship_model(self, from_model=None, **kwargs):
1464         if hasattr(self.remote_field.through, "_meta"):
1465             qualified_model_name = "%s.%s" % (
1466                 self.remote_field.through._meta.app_label,
1467                 self.remote_field.through.__name__,
1468             )
1469         else:
1470             qualified_model_name = self.remote_field.through
1471 
1472         errors = []
1473 
1474         if self.remote_field.through not in self.opts.apps.get_models(
1475             include_auto_created=True
1476         ):
1477             # The relationship model is not installed.
1478             errors.append(
1479                 checks.Error(
1480                     "Field specifies a many-to-many relation through model "
1481                     "'%s', which has not been installed." % qualified_model_name,
1482                     obj=self,
1483                     id="fields.E331",
1484                 )
1485             )
1486 
1487         else:
1488             assert from_model is not None, (
1489                 "ManyToManyField with intermediate "
1490                 "tables cannot be checked if you don't pass the model "
1491                 "where the field is attached to."
1492             )
1493             # Set some useful local variables
1494             to_model = resolve_relation(from_model, self.remote_field.model)
1495             from_model_name = from_model._meta.object_name
1496             if isinstance(to_model, str):
1497                 to_model_name = to_model
1498             else:
1499                 to_model_name = to_model._meta.object_name
1500             relationship_model_name = self.remote_field.through._meta.object_name
1501             self_referential = from_model == to_model
1502             # Count foreign keys in intermediate model
1503             if self_referential:
1504                 seen_self = sum(
1505                     from_model == getattr(field.remote_field, "model", None)
1506                     for field in self.remote_field.through._meta.fields
1507                 )
1508 
1509                 if seen_self > 2 and not self.remote_field.through_fields:
1510                     errors.append(
1511                         checks.Error(
1512                             "The model is used as an intermediate model by "
1513                             "'%s', but it has more than two foreign keys "
1514                             "to '%s', which is ambiguous. You must specify "
1515                             "which two foreign keys Django should use via the "
1516                             "through_fields keyword argument."
1517                             % (self, from_model_name),
1518                             hint=(
1519                                 "Use through_fields to specify which two foreign keys "
1520                                 "Django should use."
1521                             ),
1522                             obj=self.remote_field.through,
1523                             id="fields.E333",
1524                         )
1525                     )
1526 
1527             else:
1528                 # Count foreign keys in relationship model
1529                 seen_from = sum(
1530                     from_model == getattr(field.remote_field, "model", None)
1531                     for field in self.remote_field.through._meta.fields
1532                 )
1533                 seen_to = sum(
1534                     to_model == getattr(field.remote_field, "model", None)
1535                     for field in self.remote_field.through._meta.fields
1536                 )
1537 
1538                 if seen_from > 1 and not self.remote_field.through_fields:
1539                     errors.append(
1540                         checks.Error(
1541                             (
1542                                 "The model is used as an intermediate model by "
1543                                 "'%s', but it has more than one foreign key "
1544                                 "from '%s', which is ambiguous. You must specify "
1545                                 "which foreign key Django should use via the "
1546                                 "through_fields keyword argument."
1547                             )
1548                             % (self, from_model_name),
1549                             hint=(
1550                                 "If you want to create a recursive relationship, "
1551                                 'use ManyToManyField("%s", through="%s").'
1552                             )
1553                             % (
1554                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1555                                 relationship_model_name,
1556                             ),
1557                             obj=self,
1558                             id="fields.E334",
1559                         )
1560                     )
1561 
1562                 if seen_to > 1 and not self.remote_field.through_fields:
1563                     errors.append(
1564                         checks.Error(
1565                             "The model is used as an intermediate model by "
1566                             "'%s', but it has more than one foreign key "
1567                             "to '%s', which is ambiguous. You must specify "
1568                             "which foreign key Django should use via the "
1569                             "through_fields keyword argument." % (self, to_model_name),
1570                             hint=(
1571                                 "If you want to create a recursive relationship, "
1572                                 'use ManyToManyField("%s", through="%s").'
1573                             )
1574                             % (
1575                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1576                                 relationship_model_name,
1577                             ),
1578                             obj=self,
1579                             id="fields.E335",
1580                         )
1581                     )
1582 
1583                 if seen_from == 0 or seen_to == 0:
1584                     errors.append(
1585                         checks.Error(
1586                             "The model is used as an intermediate model by "
1587                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1588                             % (self, from_model_name, to_model_name),
1589                             obj=self.remote_field.through,
1590                             id="fields.E336",
1591                         )
1592                     )
1593 
1594         # Validate `through_fields`.
1595         if self.remote_field.through_fields is not None:
1596             # Validate that we're given an iterable of at least two items
1597             # and that none of them is "falsy".
1598             if not (
1599                 len(self.remote_field.through_fields) >= 2
1600                 and self.remote_field.through_fields[0]
1601                 and self.remote_field.through_fields[1]
1602             ):
1603                 errors.append(
1604                     checks.Error(
1605                         "Field specifies 'through_fields' but does not provide "
1606                         "the names of the two link fields that should be used "
1607                         "for the relation through model '%s'." % qualified_model_name,
1608                         hint=(
1609                             "Make sure you specify 'through_fields' as "
1610                             "through_fields=('field1', 'field2')"
1611                         ),
1612                         obj=self,
1613                         id="fields.E337",
1614                     )
1615                 )
1616 
1617             # Validate the given through fields -- they should be actual
1618             # fields on the through model, and also be foreign keys to the
1619             # expected models.
1620             else:
1621                 assert from_model is not None, (
1622                     "ManyToManyField with intermediate "
1623                     "tables cannot be checked if you don't pass the model "
1624                     "where the field is attached to."
1625                 )
1626 
1627                 source, through, target = (
1628                     from_model,
1629                     self.remote_field.through,
1630                     self.remote_field.model,
1631                 )
1632                 source_field_name, target_field_name = self.remote_field.through_fields[
1633                     :2
1634                 ]
1635 
1636                 for field_name, related_model in (
1637                     (source_field_name, source),
1638                     (target_field_name, target),
1639                 ):
1640                     possible_field_names = []
1641                     for f in through._meta.fields:
1642                         if (
1643                             hasattr(f, "remote_field")
1644                             and getattr(f.remote_field, "model", None) == related_model
1645                         ):
1646                             possible_field_names.append(f.name)
1647                     if possible_field_names:
1648                         hint = (
1649                             "Did you mean one of the following foreign keys to '%s': "
1650                             "%s?"
1651                             % (
1652                                 related_model._meta.object_name,
1653                                 ", ".join(possible_field_names),
1654                             )
1655                         )
1656                     else:
1657                         hint = None
1658 
1659                     try:
1660                         field = through._meta.get_field(field_name)
1661                     except exceptions.FieldDoesNotExist:
1662                         errors.append(
1663                             checks.Error(
1664                                 "The intermediary model '%s' has no field '%s'."
1665                                 % (qualified_model_name, field_name),
1666                                 hint=hint,
1667                                 obj=self,
1668                                 id="fields.E338",
1669                             )
1670                         )
1671                     else:
1672                         if not (
1673                             hasattr(field, "remote_field")
1674                             and getattr(field.remote_field, "model", None)
1675                             == related_model
1676                         ):
1677                             errors.append(
1678                                 checks.Error(
1679                                     "'%s.%s' is not a foreign key to '%s'."
1680                                     % (
1681                                         through._meta.object_name,
1682                                         field_name,
1683                                         related_model._meta.object_name,
1684                                     ),
1685                                     hint=hint,
1686                                     obj=self,
1687                                     id="fields.E339",
1688                                 )
1689                             )
1690 
1691         return errors
1692 
1693     def _check_table_uniqueness(self, **kwargs):
1694         if (
1695             isinstance(self.remote_field.through, str)
1696             or not self.remote_field.through._meta.managed
1697         ):
1698             return []
1699         registered_tables = {
1700             model._meta.db_table: model
1701             for model in self.opts.apps.get_models(include_auto_created=True)
1702             if model != self.remote_field.through and model._meta.managed
1703         }
1704         m2m_db_table = self.m2m_db_table()
1705         model = registered_tables.get(m2m_db_table)
1706         # The second condition allows multiple m2m relations on a model if
1707         # some point to a through model that proxies another through model.
1708         if (
1709             model
1710             and model._meta.concrete_model
1711             != self.remote_field.through._meta.concrete_model
1712         ):
1713             if model._meta.auto_created:
1714 
1715                 def _get_field_name(model):
1716                     for field in model._meta.auto_created._meta.many_to_many:
1717                         if field.remote_field.through is model:
1718                             return field.name
1719 
1720                 opts = model._meta.auto_created._meta
1721                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1722             else:
1723                 clashing_obj = model._meta.label
1724             if settings.DATABASE_ROUTERS:
1725                 error_class, error_id = checks.Warning, "fields.W344"
1726                 error_hint = (
1727                     "You have configured settings.DATABASE_ROUTERS. Verify "
1728                     "that the table of %r is correctly routed to a separate "
1729                     "database." % clashing_obj
1730                 )
1731             else:
1732                 error_class, error_id = checks.Error, "fields.E340"
1733                 error_hint = None
1734             return [
1735                 error_class(
1736                     "The field's intermediary table '%s' clashes with the "
1737                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1738                     obj=self,
1739                     hint=error_hint,
1740                     id=error_id,
1741                 )
1742             ]
1743         return []
1744 
1745     def deconstruct(self):
1746         name, path, args, kwargs = super().deconstruct()
1747         # Handle the simpler arguments.
1748         if self.db_table is not None:
1749             kwargs["db_table"] = self.db_table
1750         if self.remote_field.db_constraint is not True:
1751             kwargs["db_constraint"] = self.remote_field.db_constraint
1752         # Lowercase model names as they should be treated as case-insensitive.
1753         if isinstance(self.remote_field.model, str):
1754             if "." in self.remote_field.model:
1755                 app_label, model_name = self.remote_field.model.split(".")
1756                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1757             else:
1758                 kwargs["to"] = self.remote_field.model.lower()
1759         else:
1760             kwargs["to"] = self.remote_field.model._meta.label_lower
1761         if getattr(self.remote_field, "through", None) is not None:
1762             if isinstance(self.remote_field.through, str):
1763                 kwargs["through"] = self.remote_field.through
1764             elif not self.remote_field.through._meta.auto_created:
1765                 kwargs["through"] = self.remote_field.through._meta.label
1766         # If swappable is True, then see if we're actually pointing to the target
1767         # of a swap.
1768         swappable_setting = self.swappable_setting
1769         if swappable_setting is not None:
1770             # If it's already a settings reference, error.
1771             if hasattr(kwargs["to"], "setting_name"):
1772                 if kwargs["to"].setting_name != swappable_setting:
1773                     raise ValueError(
1774                         "Cannot deconstruct a ManyToManyField pointing to a "
1775                         "model that is swapped in place of more than one model "
1776                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1777                     )
1778 
1779             kwargs["to"] = SettingsReference(
1780                 kwargs["to"],
1781                 swappable_setting,
1782             )
1783         return name, path, args, kwargs
1784 
1785     def _get_path_info(self, direct=False, filtered_relation=None):
1786         """Called by both direct and indirect m2m traversal."""
1787         int_model = self.remote_field.through
1788         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1789         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1790         if direct:
1791             join1infos = linkfield1.reverse_path_infos
1792             if filtered_relation:
1793                 join2infos = linkfield2.get_path_info(filtered_relation)
1794             else:
1795                 join2infos = linkfield2.path_infos
1796         else:
1797             join1infos = linkfield2.reverse_path_infos
1798             if filtered_relation:
1799                 join2infos = linkfield1.get_path_info(filtered_relation)
1800             else:
1801                 join2infos = linkfield1.path_infos
1802         # Get join infos between the last model of join 1 and the first model
1803         # of join 2. Assume the only reason these may differ is due to model
1804         # inheritance.
1805         join1_final = join1infos[-1].to_opts
1806         join2_initial = join2infos[0].from_opts
1807         if join1_final is join2_initial:
1808             intermediate_infos = []
1809         elif issubclass(join1_final.model, join2_initial.model):
1810             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1811         else:
1812             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1813 
1814         return [*join1infos, *intermediate_infos, *join2infos]
1815 
1816     def get_path_info(self, filtered_relation=None):
1817         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1818 
1819     @cached_property
1820     def path_infos(self):
1821         return self.get_path_info()
1822 
1823     def get_reverse_path_info(self, filtered_relation=None):
1824         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1825 
1826     @cached_property
1827     def reverse_path_infos(self):
1828         return self.get_reverse_path_info()
1829 
1830     def _get_m2m_db_table(self, opts):
1831         """
1832         Function that can be curried to provide the m2m table name for this
1833         relation.
1834         """
1835         if self.remote_field.through is not None:
1836             return self.remote_field.through._meta.db_table
1837         elif self.db_table:
1838             return self.db_table
1839         else:
1840             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1841             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1842 
1843     def _get_m2m_attr(self, related, attr):
1844         """
1845         Function that can be curried to provide the source accessor or DB
1846         column name for the m2m table.
1847         """
1848         cache_attr = "_m2m_%s_cache" % attr
1849         if hasattr(self, cache_attr):
1850             return getattr(self, cache_attr)
1851         if self.remote_field.through_fields is not None:
1852             link_field_name = self.remote_field.through_fields[0]
1853         else:
1854             link_field_name = None
1855         for f in self.remote_field.through._meta.fields:
1856             if (
1857                 f.is_relation
1858                 and f.remote_field.model == related.related_model
1859                 and (link_field_name is None or link_field_name == f.name)
1860             ):
1861                 setattr(self, cache_attr, getattr(f, attr))
1862                 return getattr(self, cache_attr)
1863 
1864     def _get_m2m_reverse_attr(self, related, attr):
1865         """
1866         Function that can be curried to provide the related accessor or DB
1867         column name for the m2m table.
1868         """
1869         cache_attr = "_m2m_reverse_%s_cache" % attr
1870         if hasattr(self, cache_attr):
1871             return getattr(self, cache_attr)
1872         found = False
1873         if self.remote_field.through_fields is not None:
1874             link_field_name = self.remote_field.through_fields[1]
1875         else:
1876             link_field_name = None
1877         for f in self.remote_field.through._meta.fields:
1878             if f.is_relation and f.remote_field.model == related.model:
1879                 if link_field_name is None and related.related_model == related.model:
1880                     # If this is an m2m-intermediate to self,
1881                     # the first foreign key you find will be
1882                     # the source column. Keep searching for
1883                     # the second foreign key.
1884                     if found:
1885                         setattr(self, cache_attr, getattr(f, attr))
1886                         break
1887                     else:
1888                         found = True
1889                 elif link_field_name is None or link_field_name == f.name:
1890                     setattr(self, cache_attr, getattr(f, attr))
1891                     break
1892         return getattr(self, cache_attr)
1893 
1894     def contribute_to_class(self, cls, name, **kwargs):
1895         # To support multiple relations to self, it's useful to have a non-None
1896         # related name on symmetrical relations for internal reasons. The
1897         # concept doesn't make a lot of sense externally ("you want me to
1898         # specify *what* on my non-reversible relation?!"), so we set it up
1899         # automatically. The funky name reduces the chance of an accidental
1900         # clash.
1901         if self.remote_field.symmetrical and (
1902             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1903             or self.remote_field.model == cls._meta.object_name
1904         ):
1905             self.remote_field.related_name = "%s_rel_+" % name
1906         elif self.remote_field.is_hidden():
1907             # If the backwards relation is disabled, replace the original
1908             # related_name with one generated from the m2m field name. Django
1909             # still uses backwards relations internally and we need to avoid
1910             # clashes between multiple m2m fields with related_name == '+'.
1911             self.remote_field.related_name = "_%s_%s_%s_+" % (
1912                 cls._meta.app_label,
1913                 cls.__name__.lower(),
1914                 name,
1915             )
1916 
1917         super().contribute_to_class(cls, name, **kwargs)
1918 
1919         # The intermediate m2m model is not auto created if:
1920         #  1) There is a manually specified intermediate, or
1921         #  2) The class owning the m2m field is abstract.
1922         #  3) The class owning the m2m field has been swapped out.
1923         if not cls._meta.abstract:
1924             if self.remote_field.through:
1925 
1926                 def resolve_through_model(_, model, field):
1927                     field.remote_field.through = model
1928 
1929                 lazy_related_operation(
1930                     resolve_through_model, cls, self.remote_field.through, field=self
1931                 )
1932             elif not cls._meta.swapped:
1933                 self.remote_field.through = create_many_to_many_intermediary_model(
1934                     self, cls
1935                 )
1936 
1937         # Add the descriptor for the m2m relation.
1938         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1939 
1940         # Set up the accessor for the m2m table name for the relation.
1941         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1942 
1943     def contribute_to_related_class(self, cls, related):
1944         # Internal M2Ms (i.e., those with a related name ending with '+')
1945         # and swapped models don't get a related descriptor.
1946         if (
1947             not self.remote_field.is_hidden()
1948             and not related.related_model._meta.swapped
1949         ):
1950             setattr(
1951                 cls,
1952                 related.get_accessor_name(),
1953                 ManyToManyDescriptor(self.remote_field, reverse=True),
1954             )
1955 
1956         # Set up the accessors for the column names on the m2m table.
1957         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1958         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1959 
1960         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1961         self.m2m_reverse_field_name = partial(
1962             self._get_m2m_reverse_attr, related, "name"
1963         )
1964 
1965         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1966         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1967         get_m2m_reverse_rel = partial(
1968             self._get_m2m_reverse_attr, related, "remote_field"
1969         )
1970         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1971 
1972     def set_attributes_from_rel(self):
1973         pass
1974 
1975     def value_from_object(self, obj):
1976         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1977 
1978     def save_form_data(self, instance, data):
1979         getattr(instance, self.attname).set(data)
1980 
1981     def formfield(self, *, using=None, **kwargs):
1982         defaults = {
1983             "form_class": forms.ModelMultipleChoiceField,
1984             "queryset": self.remote_field.model._default_manager.using(using),
1985             **kwargs,
1986         }
1987         # If initial is passed in, it's a list of related objects, but the
1988         # MultipleChoiceField takes a list of IDs.
1989         if defaults.get("initial") is not None:
1990             initial = defaults["initial"]
1991             if callable(initial):
1992                 initial = initial()
1993             defaults["initial"] = [i.pk for i in initial]
1994         return super().formfield(**defaults)
1995 
1996     def db_check(self, connection):
1997         return None
1998 
1999     def db_type(self, connection):
2000         # A ManyToManyField is not represented by a single column,
2001         # so return None.
2002         return None
2003 
2004     def db_parameters(self, connection):
2005         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 13:46:31.481 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 13:46:31.481 | INFO     | Search-only: skipping patch selection
2025-10-18 13:46:31.618 | INFO     | Task django__django-16983 completed successfully.
2025-10-18 13:46:31.619 | INFO     | No patch generated. You can try running ACR again.
