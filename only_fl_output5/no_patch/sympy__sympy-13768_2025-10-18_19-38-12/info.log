2025-10-18 19:38:12.285 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 19:38:24.441 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=173, output_tokens=12, cost=0.002090
2025-10-18 19:38:24.442 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 19:38:24.446 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:38:33.494 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=480, output_tokens=381, cost=0.016230
2025-10-18 19:38:33.548 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:38:36.228 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=735, output_tokens=41, cost=0.008580
2025-10-18 19:38:36.229 | DEBUG    | Extracted a valid json.
2025-10-18 19:38:36.229 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"dot\")",
        "search_code(\"dimension mismatch\")",
        "search_class(\"Matrix\")"
    ],
    "bug_locations": []
}
2025-10-18 19:38:36.297 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 19:38:36.297 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 19:38:53.551 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1413, output_tokens=853, cost=0.039720
2025-10-18 19:38:53.564 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:39:01.363 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2482, output_tokens=363, cost=0.035710
2025-10-18 19:39:01.371 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:39:06.038 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=717, output_tokens=147, cost=0.011580
2025-10-18 19:39:06.039 | DEBUG    | Extracted a valid json.
2025-10-18 19:39:06.039 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method_in_file(\"dot\", \"sympy/matrices/matrices.py\")"],
    "bug_locations":[{"file": "sympy/matrices/matrices.py", "class": "", "method": "dot", "intended_behavior": "The `.dot()` method within this file should be precisely analyzing the dimensions of both matrices involved in the operation before proceeding with the calculation. It should explicitly check the dimensions of the matrices involved in the dot product operation before attempting the operation and raise a clear and informative error message if the dimensions do not allow for a valid dot product operation. This change aims to make error handling more robust and user-friendly in cases of dimension incompatibility."}]
}
2025-10-18 19:39:06.072 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 19:39:06.072 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 19:39:18.512 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4208, output_tokens=579, cost=0.059450
2025-10-18 19:39:18.524 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:39:26.426 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5003, output_tokens=338, cost=0.060170
2025-10-18 19:39:26.434 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:39:34.674 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=321, cost=0.016550
2025-10-18 19:39:34.675 | DEBUG    | Extracted a valid json.
2025-10-18 19:39:34.675 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "sympy/matrices/matrices.py", "class": "MatrixBase", "method": "dot", "intended_behavior": "The `dot` method within the `MatrixBase` class should be updated to include a more rigorous dimension compatibility check specifically targeting the scenarios described in the issue. The objective is to ensure that when `b` is neither a row vector (1 x m) nor a column vector (n x 1) relative to the dimensions of `self`, the method should raise a `ShapeError` with a clear and actionable message. This update aims to:\n\n- Perform an early check in the method to identify dimension mismatches that would result in undefined or unexpected results for the dot product operation. For instance, before allowing any transformations (transposing of matrices) or calculations, the method should assert that if `self` is a two-dimensional matrix, then `b` must be a vector or a matrix where one dimension matches exactly and the other is 1 (adhering strictly to matrix multiplication rules).\n\n- Update the error message for the `ShapeError` to provide specific guidance on compatible dimensions based on the dimensions of `self`, guiding the user on how to rectify their input without having to guess what might have gone wrong.\n\nThis refined behavior will make the method's functionality more robust against misusage while ensuring that the flexibility in handling various shapes (vectors versus matrices) for the dot product does not compromise the mathematical correctness or user expectations."}]
}
2025-10-18 19:39:34.687 | DEBUG    | Bug location extracted successfully: [<file>sympy/matrices/matrices.py</file>
<class>MatrixBase</class>
<method>dot</method>
<code>
2400     def dot(self, b):
2401         """Return the dot product of Matrix self and b relaxing the condition
2402         of compatible dimensions: if either the number of rows or columns are
2403         the same as the length of b then the dot product is returned. If self
2404         is a row or column vector, a scalar is returned. Otherwise, a list
2405         of results is returned (and in that case the number of columns in self
2406         must match the length of b).
2407 
2408         Examples
2409         ========
2410 
2411         >>> from sympy import Matrix
2412         >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
2413         >>> v = [1, 1, 1]
2414         >>> M.row(0).dot(v)
2415         6
2416         >>> M.col(0).dot(v)
2417         12
2418         >>> M.dot(v)
2419         [6, 15, 24]
2420 
2421         See Also
2422         ========
2423 
2424         cross
2425         multiply
2426         multiply_elementwise
2427         """
2428         from .dense import Matrix
2429 
2430         if not isinstance(b, MatrixBase):
2431             if is_sequence(b):
2432                 if len(b) != self.cols and len(b) != self.rows:
2433                     raise ShapeError(
2434                         "Dimensions incorrect for dot product: %s, %s" % (
2435                             self.shape, len(b)))
2436                 return self.dot(Matrix(b))
2437             else:
2438                 raise TypeError(
2439                     "`b` must be an ordered iterable or Matrix, not %s." %
2440                     type(b))
2441 
2442         mat = self
2443         if mat.cols == b.rows:
2444             if b.cols != 1:
2445                 mat = mat.T
2446                 b = b.T
2447             prod = flatten((mat * b).tolist())
2448             if len(prod) == 1:
2449                 return prod[0]
2450             return prod
2451         if mat.cols == b.cols:
2452             return mat.dot(b.T)
2453         elif mat.rows == b.rows:
2454             return mat.T.dot(b)
2455         else:
2456             raise ShapeError("Dimensions incorrect for dot product: %s, %s" % (
2457                 self.shape, b.shape))

</code><intended_behavior>The `dot` method within the `MatrixBase` class should be updated to include a more rigorous dimension compatibility check specifically targeting the scenarios described in the issue. The objective is to ensure that when `b` is neither a row vector (1 x m) nor a column vector (n x 1) relative to the dimensions of `self`, the method should raise a `ShapeError` with a clear and actionable message. This update aims to:

- Perform an early check in the method to identify dimension mismatches that would result in undefined or unexpected results for the dot product operation. For instance, before allowing any transformations (transposing of matrices) or calculations, the method should assert that if `self` is a two-dimensional matrix, then `b` must be a vector or a matrix where one dimension matches exactly and the other is 1 (adhering strictly to matrix multiplication rules).

- Update the error message for the `ShapeError` to provide specific guidance on compatible dimensions based on the dimensions of `self`, guiding the user on how to rectify their input without having to guess what might have gone wrong.

This refined behavior will make the method's functionality more robust against misusage while ensuring that the flexibility in handling various shapes (vectors versus matrices) for the dot product does not compromise the mathematical correctness or user expectations.</intended_behavior>, <file>sympy/matrices/matrices.py</file>
<class>MatrixBase</class>
<method>None</method>
<code>
1855 class MatrixBase(MatrixDeprecated,
1856                  MatrixCalculus,
1857                  MatrixEigen,
1858                  MatrixCommon):
1859     """Base class for matrix objects."""
1860     # Added just for numpy compatibility
1861     __array_priority__ = 11
1862 
1863     is_Matrix = True
1864     _class_priority = 3
1865     _sympify = staticmethod(sympify)
1866 
1867     __hash__ = None  # Mutable
1868 
1869     def __array__(self):
1870         from .dense import matrix2numpy
1871         return matrix2numpy(self)
1872 
1873     def __getattr__(self, attr):
1874         if attr in ('diff', 'integrate', 'limit'):
1875             def doit(*args):
1876                 item_doit = lambda item: getattr(item, attr)(*args)
1877                 return self.applyfunc(item_doit)
1878 
1879             return doit
1880         else:
1881             raise AttributeError(
1882                 "%s has no attribute %s." % (self.__class__.__name__, attr))
1883 
1884     def __len__(self):
1885         """Return the number of elements of self.
1886 
1887         Implemented mainly so bool(Matrix()) == False.
1888         """
1889         return self.rows * self.cols
1890 
1891     def __mathml__(self):
1892         mml = ""
1893         for i in range(self.rows):
1894             mml += "<matrixrow>"
1895             for j in range(self.cols):
1896                 mml += self[i, j].__mathml__()
1897             mml += "</matrixrow>"
1898         return "<matrix>" + mml + "</matrix>"
1899 
1900     # needed for python 2 compatibility
1901     def __ne__(self, other):
1902         return not self == other
1903 
1904     def _matrix_pow_by_jordan_blocks(self, num):
1905         from sympy.matrices import diag, MutableMatrix
1906         from sympy import binomial
1907 
1908         def jordan_cell_power(jc, n):
1909             N = jc.shape[0]
1910             l = jc[0, 0]
1911             if l == 0 and (n < N - 1) != False:
1912                 raise ValueError("Matrix det == 0; not invertible")
1913             elif l == 0 and N > 1 and n % 1 != 0:
1914                 raise ValueError("Non-integer power cannot be evaluated")
1915             for i in range(N):
1916                 for j in range(N-i):
1917                     bn = binomial(n, i)
1918                     if isinstance(bn, binomial):
1919                         bn = bn._eval_expand_func()
1920                     jc[j, i+j] = l**(n-i)*bn
1921 
1922         P, J = self.jordan_form()
1923         jordan_cells = J.get_diag_blocks()
1924         # Make sure jordan_cells matrices are mutable:
1925         jordan_cells = [MutableMatrix(j) for j in jordan_cells]
1926         for j in jordan_cells:
1927             jordan_cell_power(j, num)
1928         return self._new(P*diag(*jordan_cells)*P.inv())
1929 
1930     def __repr__(self):
1931         return sstr(self)
1932 
1933     def __str__(self):
1934         if self.rows == 0 or self.cols == 0:
1935             return 'Matrix(%s, %s, [])' % (self.rows, self.cols)
1936         return "Matrix(%s)" % str(self.tolist())
1937 
1938     def _diagonalize_clear_subproducts(self):
1939         del self._is_symbolic
1940         del self._is_symmetric
1941         del self._eigenvects
1942 
1943     def _format_str(self, printer=None):
1944         if not printer:
1945             from sympy.printing.str import StrPrinter
1946             printer = StrPrinter()
1947         # Handle zero dimensions:
1948         if self.rows == 0 or self.cols == 0:
1949             return 'Matrix(%s, %s, [])' % (self.rows, self.cols)
1950         if self.rows == 1:
1951             return "Matrix([%s])" % self.table(printer, rowsep=',\n')
1952         return "Matrix([\n%s])" % self.table(printer, rowsep=',\n')
1953 
1954     @classmethod
1955     def _handle_creation_inputs(cls, *args, **kwargs):
1956         """Return the number of rows, cols and flat matrix elements.
1957 
1958         Examples
1959         ========
1960 
1961         >>> from sympy import Matrix, I
1962 
1963         Matrix can be constructed as follows:
1964 
1965         * from a nested list of iterables
1966 
1967         >>> Matrix( ((1, 2+I), (3, 4)) )
1968         Matrix([
1969         [1, 2 + I],
1970         [3,     4]])
1971 
1972         * from un-nested iterable (interpreted as a column)
1973 
1974         >>> Matrix( [1, 2] )
1975         Matrix([
1976         [1],
1977         [2]])
1978 
1979         * from un-nested iterable with dimensions
1980 
1981         >>> Matrix(1, 2, [1, 2] )
1982         Matrix([[1, 2]])
1983 
1984         * from no arguments (a 0 x 0 matrix)
1985 
1986         >>> Matrix()
1987         Matrix(0, 0, [])
1988 
1989         * from a rule
1990 
1991         >>> Matrix(2, 2, lambda i, j: i/(j + 1) )
1992         Matrix([
1993         [0,   0],
1994         [1, 1/2]])
1995 
1996         """
1997         from sympy.matrices.sparse import SparseMatrix
1998 
1999         flat_list = None
2000 
2001         if len(args) == 1:
2002             # Matrix(SparseMatrix(...))
2003             if isinstance(args[0], SparseMatrix):
2004                 return args[0].rows, args[0].cols, flatten(args[0].tolist())
2005 
2006             # Matrix(Matrix(...))
2007             elif isinstance(args[0], MatrixBase):
2008                 return args[0].rows, args[0].cols, args[0]._mat
2009 
2010             # Matrix(MatrixSymbol('X', 2, 2))
2011             elif isinstance(args[0], Basic) and args[0].is_Matrix:
2012                 return args[0].rows, args[0].cols, args[0].as_explicit()._mat
2013 
2014             # Matrix(numpy.ones((2, 2)))
2015             elif hasattr(args[0], "__array__"):
2016                 # NumPy array or matrix or some other object that implements
2017                 # __array__. So let's first use this method to get a
2018                 # numpy.array() and then make a python list out of it.
2019                 arr = args[0].__array__()
2020                 if len(arr.shape) == 2:
2021                     rows, cols = arr.shape[0], arr.shape[1]
2022                     flat_list = [cls._sympify(i) for i in arr.ravel()]
2023                     return rows, cols, flat_list
2024                 elif len(arr.shape) == 1:
2025                     rows, cols = arr.shape[0], 1
2026                     flat_list = [S.Zero] * rows
2027                     for i in range(len(arr)):
2028                         flat_list[i] = cls._sympify(arr[i])
2029                     return rows, cols, flat_list
2030                 else:
2031                     raise NotImplementedError(
2032                         "SymPy supports just 1D and 2D matrices")
2033 
2034             # Matrix([1, 2, 3]) or Matrix([[1, 2], [3, 4]])
2035             elif is_sequence(args[0]) \
2036                     and not isinstance(args[0], DeferredVector):
2037                 in_mat = []
2038                 ncol = set()
2039                 for row in args[0]:
2040                     if isinstance(row, MatrixBase):
2041                         in_mat.extend(row.tolist())
2042                         if row.cols or row.rows:  # only pay attention if it's not 0x0
2043                             ncol.add(row.cols)
2044                     else:
2045                         in_mat.append(row)
2046                         try:
2047                             ncol.add(len(row))
2048                         except TypeError:
2049                             ncol.add(1)
2050                 if len(ncol) > 1:
2051                     raise ValueError("Got rows of variable lengths: %s" %
2052                                      sorted(list(ncol)))
2053                 cols = ncol.pop() if ncol else 0
2054                 rows = len(in_mat) if cols else 0
2055                 if rows:
2056                     if not is_sequence(in_mat[0]):
2057                         cols = 1
2058                         flat_list = [cls._sympify(i) for i in in_mat]
2059                         return rows, cols, flat_list
2060                 flat_list = []
2061                 for j in range(rows):
2062                     for i in range(cols):
2063                         flat_list.append(cls._sympify(in_mat[j][i]))
2064 
2065         elif len(args) == 3:
2066             rows = as_int(args[0])
2067             cols = as_int(args[1])
2068 
2069             if rows < 0 or cols < 0:
2070                 raise ValueError("Cannot create a {} x {} matrix. "
2071                                  "Both dimensions must be positive".format(rows, cols))
2072 
2073             # Matrix(2, 2, lambda i, j: i+j)
2074             if len(args) == 3 and isinstance(args[2], collections.Callable):
2075                 op = args[2]
2076                 flat_list = []
2077                 for i in range(rows):
2078                     flat_list.extend(
2079                         [cls._sympify(op(cls._sympify(i), cls._sympify(j)))
2080                          for j in range(cols)])
2081 
2082             # Matrix(2, 2, [1, 2, 3, 4])
2083             elif len(args) == 3 and is_sequence(args[2]):
2084                 flat_list = args[2]
2085                 if len(flat_list) != rows * cols:
2086                     raise ValueError(
2087                         'List length should be equal to rows*columns')
2088                 flat_list = [cls._sympify(i) for i in flat_list]
2089 
2090 
2091         # Matrix()
2092         elif len(args) == 0:
2093             # Empty Matrix
2094             rows = cols = 0
2095             flat_list = []
2096 
2097         if flat_list is None:
2098             raise TypeError("Data type not understood")
2099 
2100         return rows, cols, flat_list
2101 
2102     def _setitem(self, key, value):
2103         """Helper to set value at location given by key.
2104 
2105         Examples
2106         ========
2107 
2108         >>> from sympy import Matrix, I, zeros, ones
2109         >>> m = Matrix(((1, 2+I), (3, 4)))
2110         >>> m
2111         Matrix([
2112         [1, 2 + I],
2113         [3,     4]])
2114         >>> m[1, 0] = 9
2115         >>> m
2116         Matrix([
2117         [1, 2 + I],
2118         [9,     4]])
2119         >>> m[1, 0] = [[0, 1]]
2120 
2121         To replace row r you assign to position r*m where m
2122         is the number of columns:
2123 
2124         >>> M = zeros(4)
2125         >>> m = M.cols
2126         >>> M[3*m] = ones(1, m)*2; M
2127         Matrix([
2128         [0, 0, 0, 0],
2129         [0, 0, 0, 0],
2130         [0, 0, 0, 0],
2131         [2, 2, 2, 2]])
2132 
2133         And to replace column c you can assign to position c:
2134 
2135         >>> M[2] = ones(m, 1)*4; M
2136         Matrix([
2137         [0, 0, 4, 0],
2138         [0, 0, 4, 0],
2139         [0, 0, 4, 0],
2140         [2, 2, 4, 2]])
2141         """
2142         from .dense import Matrix
2143 
2144         is_slice = isinstance(key, slice)
2145         i, j = key = self.key2ij(key)
2146         is_mat = isinstance(value, MatrixBase)
2147         if type(i) is slice or type(j) is slice:
2148             if is_mat:
2149                 self.copyin_matrix(key, value)
2150                 return
2151             if not isinstance(value, Expr) and is_sequence(value):
2152                 self.copyin_list(key, value)
2153                 return
2154             raise ValueError('unexpected value: %s' % value)
2155         else:
2156             if (not is_mat and
2157                     not isinstance(value, Basic) and is_sequence(value)):
2158                 value = Matrix(value)
2159                 is_mat = True
2160             if is_mat:
2161                 if is_slice:
2162                     key = (slice(*divmod(i, self.cols)),
2163                            slice(*divmod(j, self.cols)))
2164                 else:
2165                     key = (slice(i, i + value.rows),
2166                            slice(j, j + value.cols))
2167                 self.copyin_matrix(key, value)
2168             else:
2169                 return i, j, self._sympify(value)
2170             return
2171 
2172     def add(self, b):
2173         """Return self + b """
2174         return self + b
2175 
2176     def cholesky_solve(self, rhs):
2177         """Solves Ax = B using Cholesky decomposition,
2178         for a general square non-singular matrix.
2179         For a non-square matrix with rows > cols,
2180         the least squares solution is returned.
2181 
2182         See Also
2183         ========
2184 
2185         lower_triangular_solve
2186         upper_triangular_solve
2187         gauss_jordan_solve
2188         diagonal_solve
2189         LDLsolve
2190         LUsolve
2191         QRsolve
2192         pinv_solve
2193         """
2194         if self.is_hermitian:
2195             L = self._cholesky()
2196         elif self.rows >= self.cols:
2197             L = (self.H * self)._cholesky()
2198             rhs = self.H * rhs
2199         else:
2200             raise NotImplementedError('Under-determined System. '
2201                                       'Try M.gauss_jordan_solve(rhs)')
2202         Y = L._lower_triangular_solve(rhs)
2203         return (L.H)._upper_triangular_solve(Y)
2204 
2205     def cholesky(self):
2206         """Returns the Cholesky decomposition L of a matrix A
2207         such that L * L.H = A
2208 
2209         A must be a Hermitian positive-definite matrix.
2210 
2211         Examples
2212         ========
2213 
2214         >>> from sympy.matrices import Matrix
2215         >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
2216         >>> A.cholesky()
2217         Matrix([
2218         [ 5, 0, 0],
2219         [ 3, 3, 0],
2220         [-1, 1, 3]])
2221         >>> A.cholesky() * A.cholesky().T
2222         Matrix([
2223         [25, 15, -5],
2224         [15, 18,  0],
2225         [-5,  0, 11]])
2226 
2227         The matrix can have complex entries:
2228 
2229         >>> from sympy import I
2230         >>> A = Matrix(((9, 3*I), (-3*I, 5)))
2231         >>> A.cholesky()
2232         Matrix([
2233         [ 3, 0],
2234         [-I, 2]])
2235         >>> A.cholesky() * A.cholesky().H
2236         Matrix([
2237         [   9, 3*I],
2238         [-3*I,   5]])
2239 
2240         See Also
2241         ========
2242 
2243         LDLdecomposition
2244         LUdecomposition
2245         QRdecomposition
2246         """
2247 
2248         if not self.is_square:
2249             raise NonSquareMatrixError("Matrix must be square.")
2250         if not self.is_hermitian:
2251             raise ValueError("Matrix must be Hermitian.")
2252         return self._cholesky()
2253 
2254     def condition_number(self):
2255         """Returns the condition number of a matrix.
2256 
2257         This is the maximum singular value divided by the minimum singular value
2258 
2259         Examples
2260         ========
2261 
2262         >>> from sympy import Matrix, S
2263         >>> A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]])
2264         >>> A.condition_number()
2265         100
2266 
2267         See Also
2268         ========
2269 
2270         singular_values
2271         """
2272         if not self:
2273             return S.Zero
2274         singularvalues = self.singular_values()
2275         return Max(*singularvalues) / Min(*singularvalues)
2276 
2277     def copy(self):
2278         """
2279         Returns the copy of a matrix.
2280 
2281         Examples
2282         ========
2283 
2284         >>> from sympy import Matrix
2285         >>> A = Matrix(2, 2, [1, 2, 3, 4])
2286         >>> A.copy()
2287         Matrix([
2288         [1, 2],
2289         [3, 4]])
2290 
2291         """
2292         return self._new(self.rows, self.cols, self._mat)
2293 
2294     def cross(self, b):
2295         r"""
2296         Return the cross product of ``self`` and ``b`` relaxing the condition
2297         of compatible dimensions: if each has 3 elements, a matrix of the
2298         same type and shape as ``self`` will be returned. If ``b`` has the same
2299         shape as ``self`` then common identities for the cross product (like
2300         `a \times b = - b \times a`) will hold.
2301 
2302         Parameters
2303         ==========
2304             b : 3x1 or 1x3 Matrix
2305 
2306         See Also
2307         ========
2308 
2309         dot
2310         multiply
2311         multiply_elementwise
2312         """
2313         if not is_sequence(b):
2314             raise TypeError(
2315                 "`b` must be an ordered iterable or Matrix, not %s." %
2316                 type(b))
2317         if not (self.rows * self.cols == b.rows * b.cols == 3):
2318             raise ShapeError("Dimensions incorrect for cross product: %s x %s" %
2319                              ((self.rows, self.cols), (b.rows, b.cols)))
2320         else:
2321             return self._new(self.rows, self.cols, (
2322                 (self[1] * b[2] - self[2] * b[1]),
2323                 (self[2] * b[0] - self[0] * b[2]),
2324                 (self[0] * b[1] - self[1] * b[0])))
2325 
2326     @property
2327     def D(self):
2328         """Return Dirac conjugate (if self.rows == 4).
2329 
2330         Examples
2331         ========
2332 
2333         >>> from sympy import Matrix, I, eye
2334         >>> m = Matrix((0, 1 + I, 2, 3))
2335         >>> m.D
2336         Matrix([[0, 1 - I, -2, -3]])
2337         >>> m = (eye(4) + I*eye(4))
2338         >>> m[0, 3] = 2
2339         >>> m.D
2340         Matrix([
2341         [1 - I,     0,      0,      0],
2342         [    0, 1 - I,      0,      0],
2343         [    0,     0, -1 + I,      0],
2344         [    2,     0,      0, -1 + I]])
2345 
2346         If the matrix does not have 4 rows an AttributeError will be raised
2347         because this property is only defined for matrices with 4 rows.
2348 
2349         >>> Matrix(eye(2)).D
2350         Traceback (most recent call last):
2351         ...
2352         AttributeError: Matrix has no attribute D.
2353 
2354         See Also
2355         ========
2356 
2357         conjugate: By-element conjugation
2358         H: Hermite conjugation
2359         """
2360         from sympy.physics.matrices import mgamma
2361         if self.rows != 4:
2362             # In Python 3.2, properties can only return an AttributeError
2363             # so we can't raise a ShapeError -- see commit which added the
2364             # first line of this inline comment. Also, there is no need
2365             # for a message since MatrixBase will raise the AttributeError
2366             raise AttributeError
2367         return self.H * mgamma(0)
2368 
2369     def diagonal_solve(self, rhs):
2370         """Solves Ax = B efficiently, where A is a diagonal Matrix,
2371         with non-zero diagonal entries.
2372 
2373         Examples
2374         ========
2375 
2376         >>> from sympy.matrices import Matrix, eye
2377         >>> A = eye(2)*2
2378         >>> B = Matrix([[1, 2], [3, 4]])
2379         >>> A.diagonal_solve(B) == B/2
2380         True
2381 
2382         See Also
2383         ========
2384 
2385         lower_triangular_solve
2386         upper_triangular_solve
2387         gauss_jordan_solve
2388         cholesky_solve
2389         LDLsolve
2390         LUsolve
2391         QRsolve
2392         pinv_solve
2393         """
2394         if not self.is_diagonal:
2395             raise TypeError("Matrix should be diagonal")
2396         if rhs.rows != self.rows:
2397             raise TypeError("Size mis-match")
2398         return self._diagonal_solve(rhs)
2399 
2400     def dot(self, b):
2401         """Return the dot product of Matrix self and b relaxing the condition
2402         of compatible dimensions: if either the number of rows or columns are
2403         the same as the length of b then the dot product is returned. If self
2404         is a row or column vector, a scalar is returned. Otherwise, a list
2405         of results is returned (and in that case the number of columns in self
2406         must match the length of b).
2407 
2408         Examples
2409         ========
2410 
2411         >>> from sympy import Matrix
2412         >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
2413         >>> v = [1, 1, 1]
2414         >>> M.row(0).dot(v)
2415         6
2416         >>> M.col(0).dot(v)
2417         12
2418         >>> M.dot(v)
2419         [6, 15, 24]
2420 
2421         See Also
2422         ========
2423 
2424         cross
2425         multiply
2426         multiply_elementwise
2427         """
2428         from .dense import Matrix
2429 
2430         if not isinstance(b, MatrixBase):
2431             if is_sequence(b):
2432                 if len(b) != self.cols and len(b) != self.rows:
2433                     raise ShapeError(
2434                         "Dimensions incorrect for dot product: %s, %s" % (
2435                             self.shape, len(b)))
2436                 return self.dot(Matrix(b))
2437             else:
2438                 raise TypeError(
2439                     "`b` must be an ordered iterable or Matrix, not %s." %
2440                     type(b))
2441 
2442         mat = self
2443         if mat.cols == b.rows:
2444             if b.cols != 1:
2445                 mat = mat.T
2446                 b = b.T
2447             prod = flatten((mat * b).tolist())
2448             if len(prod) == 1:
2449                 return prod[0]
2450             return prod
2451         if mat.cols == b.cols:
2452             return mat.dot(b.T)
2453         elif mat.rows == b.rows:
2454             return mat.T.dot(b)
2455         else:
2456             raise ShapeError("Dimensions incorrect for dot product: %s, %s" % (
2457                 self.shape, b.shape))
2458 
2459     def dual(self):
2460         """Returns the dual of a matrix, which is:
2461 
2462         `(1/2)*levicivita(i, j, k, l)*M(k, l)` summed over indices `k` and `l`
2463 
2464         Since the levicivita method is anti_symmetric for any pairwise
2465         exchange of indices, the dual of a symmetric matrix is the zero
2466         matrix. Strictly speaking the dual defined here assumes that the
2467         'matrix' `M` is a contravariant anti_symmetric second rank tensor,
2468         so that the dual is a covariant second rank tensor.
2469 
2470         """
2471         from sympy import LeviCivita
2472         from sympy.matrices import zeros
2473 
2474         M, n = self[:, :], self.rows
2475         work = zeros(n)
2476         if self.is_symmetric():
2477             return work
2478 
2479         for i in range(1, n):
2480             for j in range(1, n):
2481                 acum = 0
2482                 for k in range(1, n):
2483                     acum += LeviCivita(i, j, 0, k) * M[0, k]
2484                 work[i, j] = acum
2485                 work[j, i] = -acum
2486 
2487         for l in range(1, n):
2488             acum = 0
2489             for a in range(1, n):
2490                 for b in range(1, n):
2491                     acum += LeviCivita(0, l, a, b) * M[a, b]
2492             acum /= 2
2493             work[0, l] = -acum
2494             work[l, 0] = acum
2495 
2496         return work
2497 
2498     def exp(self):
2499         """Return the exponentiation of a square matrix."""
2500         if not self.is_square:
2501             raise NonSquareMatrixError(
2502                 "Exponentiation is valid only for square matrices")
2503         try:
2504             P, J = self.jordan_form()
2505             cells = J.get_diag_blocks()
2506         except MatrixError:
2507             raise NotImplementedError(
2508                 "Exponentiation is implemented only for matrices for which the Jordan normal form can be computed")
2509 
2510         def _jblock_exponential(b):
2511             # This function computes the matrix exponential for one single Jordan block
2512             nr = b.rows
2513             l = b[0, 0]
2514             if nr == 1:
2515                 res = exp(l)
2516             else:
2517                 from sympy import eye
2518                 # extract the diagonal part
2519                 d = b[0, 0] * eye(nr)
2520                 # and the nilpotent part
2521                 n = b - d
2522                 # compute its exponential
2523                 nex = eye(nr)
2524                 for i in range(1, nr):
2525                     nex = nex + n ** i / factorial(i)
2526                 # combine the two parts
2527                 res = exp(b[0, 0]) * nex
2528             return (res)
2529 
2530         blocks = list(map(_jblock_exponential, cells))
2531         from sympy.matrices import diag
2532         from sympy import re
2533         eJ = diag(*blocks)
2534         # n = self.rows
2535         ret = P * eJ * P.inv()
2536         if all(value.is_real for value in self.values()):
2537             return type(self)(re(ret))
2538         else:
2539             return type(self)(ret)
2540 
2541     def gauss_jordan_solve(self, b, freevar=False):
2542         """
2543         Solves Ax = b using Gauss Jordan elimination.
2544 
2545         There may be zero, one, or infinite solutions.  If one solution
2546         exists, it will be returned. If infinite solutions exist, it will
2547         be returned parametrically. If no solutions exist, It will throw
2548         ValueError.
2549 
2550         Parameters
2551         ==========
2552 
2553         b : Matrix
2554             The right hand side of the equation to be solved for.  Must have
2555             the same number of rows as matrix A.
2556 
2557         freevar : List
2558             If the system is underdetermined (e.g. A has more columns than
2559             rows), infinite solutions are possible, in terms of arbitrary
2560             values of free variables. Then the index of the free variables
2561             in the solutions (column Matrix) will be returned by freevar, if
2562             the flag `freevar` is set to `True`.
2563 
2564         Returns
2565         =======
2566 
2567         x : Matrix
2568             The matrix that will satisfy Ax = B.  Will have as many rows as
2569             matrix A has columns, and as many columns as matrix B.
2570 
2571         params : Matrix
2572             If the system is underdetermined (e.g. A has more columns than
2573             rows), infinite solutions are possible, in terms of arbitrary
2574             parameters. These arbitrary parameters are returned as params
2575             Matrix.
2576 
2577         Examples
2578         ========
2579 
2580         >>> from sympy import Matrix
2581         >>> A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])
2582         >>> b = Matrix([7, 12, 4])
2583         >>> sol, params = A.gauss_jordan_solve(b)
2584         >>> sol
2585         Matrix([
2586         [-2*tau0 - 3*tau1 + 2],
2587         [                 tau0],
2588         [           2*tau1 + 5],
2589         [                 tau1]])
2590         >>> params
2591         Matrix([
2592         [tau0],
2593         [tau1]])
2594 
2595         >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
2596         >>> b = Matrix([3, 6, 9])
2597         >>> sol, params = A.gauss_jordan_solve(b)
2598         >>> sol
2599         Matrix([
2600         [-1],
2601         [ 2],
2602         [ 0]])
2603         >>> params
2604         Matrix(0, 1, [])
2605 
2606         See Also
2607         ========
2608 
2609         lower_triangular_solve
2610         upper_triangular_solve
2611         cholesky_solve
2612         diagonal_solve
2613         LDLsolve
2614         LUsolve
2615         QRsolve
2616         pinv
2617 
2618         References
2619         ==========
2620 
2621         .. [1] http://en.wikipedia.org/wiki/Gaussian_elimination
2622 
2623         """
2624         from sympy.matrices import Matrix, zeros
2625 
2626         aug = self.hstack(self.copy(), b.copy())
2627         row, col = aug[:, :-1].shape
2628 
2629         # solve by reduced row echelon form
2630         A, pivots = aug.rref(simplify=True)
2631         A, v = A[:, :-1], A[:, -1]
2632         pivots = list(filter(lambda p: p < col, pivots))
2633         rank = len(pivots)
2634 
2635         # Bring to block form
2636         permutation = Matrix(range(col)).T
2637         A = A.vstack(A, permutation)
2638 
2639         for i, c in enumerate(pivots):
2640             A.col_swap(i, c)
2641 
2642         A, permutation = A[:-1, :], A[-1, :]
2643 
2644         # check for existence of solutions
2645         # rank of aug Matrix should be equal to rank of coefficient matrix
2646         if not v[rank:, 0].is_zero:
2647             raise ValueError("Linear system has no solution")
2648 
2649         # Get index of free symbols (free parameters)
2650         free_var_index = permutation[
2651                          len(pivots):]  # non-pivots columns are free variables
2652 
2653         # Free parameters
2654         # what are current unnumbered free symbol names?
2655         name = _uniquely_named_symbol('tau', aug,
2656             compare=lambda i: str(i).rstrip('1234567890')).name
2657         gen = numbered_symbols(name)
2658         tau = Matrix([next(gen) for k in range(col - rank)]).reshape(col - rank, 1)
2659 
2660         # Full parametric solution
2661         V = A[:rank, rank:]
2662         vt = v[:rank, 0]
2663         free_sol = tau.vstack(vt - V * tau, tau)
2664 
2665         # Undo permutation
2666         sol = zeros(col, 1)
2667         for k, v in enumerate(free_sol):
2668             sol[permutation[k], 0] = v
2669 
2670         if freevar:
2671             return sol, tau, free_var_index
2672         else:
2673             return sol, tau
2674 
2675     def inv_mod(self, m):
2676         r"""
2677         Returns the inverse of the matrix `K` (mod `m`), if it exists.
2678 
2679         Method to find the matrix inverse of `K` (mod `m`) implemented in this function:
2680 
2681         * Compute `\mathrm{adj}(K) = \mathrm{cof}(K)^t`, the adjoint matrix of `K`.
2682 
2683         * Compute `r = 1/\mathrm{det}(K) \pmod m`.
2684 
2685         * `K^{-1} = r\cdot \mathrm{adj}(K) \pmod m`.
2686 
2687         Examples
2688         ========
2689 
2690         >>> from sympy import Matrix
2691         >>> A = Matrix(2, 2, [1, 2, 3, 4])
2692         >>> A.inv_mod(5)
2693         Matrix([
2694         [3, 1],
2695         [4, 2]])
2696         >>> A.inv_mod(3)
2697         Matrix([
2698         [1, 1],
2699         [0, 1]])
2700 
2701         """
2702         from sympy.ntheory import totient
2703         if not self.is_square:
2704             raise NonSquareMatrixError()
2705         N = self.cols
2706         phi = totient(m)
2707         det_K = self.det()
2708         if gcd(det_K, m) != 1:
2709             raise ValueError('Matrix is not invertible (mod %d)' % m)
2710         det_inv = pow(int(det_K), int(phi - 1), int(m))
2711         K_adj = self.adjugate()
2712         K_inv = self.__class__(N, N,
2713                                [det_inv * K_adj[i, j] % m for i in range(N) for
2714                                 j in range(N)])
2715         return K_inv
2716 
2717     def inverse_ADJ(self, iszerofunc=_iszero):
2718         """Calculates the inverse using the adjugate matrix and a determinant.
2719 
2720         See Also
2721         ========
2722 
2723         inv
2724         inverse_LU
2725         inverse_GE
2726         """
2727         if not self.is_square:
2728             raise NonSquareMatrixError("A Matrix must be square to invert.")
2729 
2730         d = self.det(method='berkowitz')
2731         zero = d.equals(0)
2732         if zero is None:
2733             # if equals() can't decide, will rref be able to?
2734             ok = self.rref(simplify=True)[0]
2735             zero = any(iszerofunc(ok[j, j]) for j in range(ok.rows))
2736         if zero:
2737             raise ValueError("Matrix det == 0; not invertible.")
2738 
2739         return self.adjugate() / d
2740 
2741     def inverse_GE(self, iszerofunc=_iszero):
2742         """Calculates the inverse using Gaussian elimination.
2743 
2744         See Also
2745         ========
2746 
2747         inv
2748         inverse_LU
2749         inverse_ADJ
2750         """
2751         from .dense import Matrix
2752         if not self.is_square:
2753             raise NonSquareMatrixError("A Matrix must be square to invert.")
2754 
2755         big = Matrix.hstack(self.as_mutable(), Matrix.eye(self.rows))
2756         red = big.rref(iszerofunc=iszerofunc, simplify=True)[0]
2757         if any(iszerofunc(red[j, j]) for j in range(red.rows)):
2758             raise ValueError("Matrix det == 0; not invertible.")
2759 
2760         return self._new(red[:, big.rows:])
2761 
2762     def inverse_LU(self, iszerofunc=_iszero):
2763         """Calculates the inverse using LU decomposition.
2764 
2765         See Also
2766         ========
2767 
2768         inv
2769         inverse_GE
2770         inverse_ADJ
2771         """
2772         if not self.is_square:
2773             raise NonSquareMatrixError()
2774 
2775         ok = self.rref(simplify=True)[0]
2776         if any(iszerofunc(ok[j, j]) for j in range(ok.rows)):
2777             raise ValueError("Matrix det == 0; not invertible.")
2778 
2779         return self.LUsolve(self.eye(self.rows), iszerofunc=_iszero)
2780 
2781     def inv(self, method=None, **kwargs):
2782         """
2783         Return the inverse of a matrix.
2784 
2785         CASE 1: If the matrix is a dense matrix.
2786 
2787         Return the matrix inverse using the method indicated (default
2788         is Gauss elimination).
2789 
2790         Parameters
2791         ==========
2792 
2793         method : ('GE', 'LU', or 'ADJ')
2794 
2795         Notes
2796         =====
2797 
2798         According to the ``method`` keyword, it calls the appropriate method:
2799 
2800           GE .... inverse_GE(); default
2801           LU .... inverse_LU()
2802           ADJ ... inverse_ADJ()
2803 
2804         See Also
2805         ========
2806 
2807         inverse_LU
2808         inverse_GE
2809         inverse_ADJ
2810 
2811         Raises
2812         ------
2813         ValueError
2814             If the determinant of the matrix is zero.
2815 
2816         CASE 2: If the matrix is a sparse matrix.
2817 
2818         Return the matrix inverse using Cholesky or LDL (default).
2819 
2820         kwargs
2821         ======
2822 
2823         method : ('CH', 'LDL')
2824 
2825         Notes
2826         =====
2827 
2828         According to the ``method`` keyword, it calls the appropriate method:
2829 
2830           LDL ... inverse_LDL(); default
2831           CH .... inverse_CH()
2832 
2833         Raises
2834         ------
2835         ValueError
2836             If the determinant of the matrix is zero.
2837 
2838         """
2839         if not self.is_square:
2840             raise NonSquareMatrixError()
2841         if method is not None:
2842             kwargs['method'] = method
2843         return self._eval_inverse(**kwargs)
2844 
2845     def is_nilpotent(self):
2846         """Checks if a matrix is nilpotent.
2847 
2848         A matrix B is nilpotent if for some integer k, B**k is
2849         a zero matrix.
2850 
2851         Examples
2852         ========
2853 
2854         >>> from sympy import Matrix
2855         >>> a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]])
2856         >>> a.is_nilpotent()
2857         True
2858 
2859         >>> a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]])
2860         >>> a.is_nilpotent()
2861         False
2862         """
2863         if not self:
2864             return True
2865         if not self.is_square:
2866             raise NonSquareMatrixError(
2867                 "Nilpotency is valid only for square matrices")
2868         x = _uniquely_named_symbol('x', self)
2869         p = self.charpoly(x)
2870         if p.args[0] == x ** self.rows:
2871             return True
2872         return False
2873 
2874     def key2bounds(self, keys):
2875         """Converts a key with potentially mixed types of keys (integer and slice)
2876         into a tuple of ranges and raises an error if any index is out of self's
2877         range.
2878 
2879         See Also
2880         ========
2881 
2882         key2ij
2883         """
2884 
2885         islice, jslice = [isinstance(k, slice) for k in keys]
2886         if islice:
2887             if not self.rows:
2888                 rlo = rhi = 0
2889             else:
2890                 rlo, rhi = keys[0].indices(self.rows)[:2]
2891         else:
2892             rlo = a2idx(keys[0], self.rows)
2893             rhi = rlo + 1
2894         if jslice:
2895             if not self.cols:
2896                 clo = chi = 0
2897             else:
2898                 clo, chi = keys[1].indices(self.cols)[:2]
2899         else:
2900             clo = a2idx(keys[1], self.cols)
2901             chi = clo + 1
2902         return rlo, rhi, clo, chi
2903 
2904     def key2ij(self, key):
2905         """Converts key into canonical form, converting integers or indexable
2906         items into valid integers for self's range or returning slices
2907         unchanged.
2908 
2909         See Also
2910         ========
2911 
2912         key2bounds
2913         """
2914         if is_sequence(key):
2915             if not len(key) == 2:
2916                 raise TypeError('key must be a sequence of length 2')
2917             return [a2idx(i, n) if not isinstance(i, slice) else i
2918                     for i, n in zip(key, self.shape)]
2919         elif isinstance(key, slice):
2920             return key.indices(len(self))[:2]
2921         else:
2922             return divmod(a2idx(key, len(self)), self.cols)
2923 
2924     def LDLdecomposition(self):
2925         """Returns the LDL Decomposition (L, D) of matrix A,
2926         such that L * D * L.H == A
2927         This method eliminates the use of square root.
2928         Further this ensures that all the diagonal entries of L are 1.
2929         A must be a Hermitian positive-definite matrix.
2930 
2931         Examples
2932         ========
2933 
2934         >>> from sympy.matrices import Matrix, eye
2935         >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
2936         >>> L, D = A.LDLdecomposition()
2937         >>> L
2938         Matrix([
2939         [   1,   0, 0],
2940         [ 3/5,   1, 0],
2941         [-1/5, 1/3, 1]])
2942         >>> D
2943         Matrix([
2944         [25, 0, 0],
2945         [ 0, 9, 0],
2946         [ 0, 0, 9]])
2947         >>> L * D * L.T * A.inv() == eye(A.rows)
2948         True
2949 
2950         The matrix can have complex entries:
2951 
2952         >>> from sympy import I
2953         >>> A = Matrix(((9, 3*I), (-3*I, 5)))
2954         >>> L, D = A.LDLdecomposition()
2955         >>> L
2956         Matrix([
2957         [   1, 0],
2958         [-I/3, 1]])
2959         >>> D
2960         Matrix([
2961         [9, 0],
2962         [0, 4]])
2963         >>> L*D*L.H == A
2964         True
2965 
2966         See Also
2967         ========
2968 
2969         cholesky
2970         LUdecomposition
2971         QRdecomposition
2972         """
2973         if not self.is_square:
2974             raise NonSquareMatrixError("Matrix must be square.")
2975         if not self.is_hermitian:
2976             raise ValueError("Matrix must be Hermitian.")
2977         return self._LDLdecomposition()
2978 
2979     def LDLsolve(self, rhs):
2980         """Solves Ax = B using LDL decomposition,
2981         for a general square and non-singular matrix.
2982 
2983         For a non-square matrix with rows > cols,
2984         the least squares solution is returned.
2985 
2986         Examples
2987         ========
2988 
2989         >>> from sympy.matrices import Matrix, eye
2990         >>> A = eye(2)*2
2991         >>> B = Matrix([[1, 2], [3, 4]])
2992         >>> A.LDLsolve(B) == B/2
2993         True
2994 
2995         See Also
2996         ========
2997 
2998         LDLdecomposition
2999         lower_triangular_solve
3000         upper_triangular_solve
3001         gauss_jordan_solve
3002         cholesky_solve
3003         diagonal_solve
3004         LUsolve
3005         QRsolve
3006         pinv_solve
3007         """
3008         if self.is_hermitian:
3009             L, D = self.LDLdecomposition()
3010         elif self.rows >= self.cols:
3011             L, D = (self.H * self).LDLdecomposition()
3012             rhs = self.H * rhs
3013         else:
3014             raise NotImplementedError('Under-determined System. '
3015                                       'Try M.gauss_jordan_solve(rhs)')
3016         Y = L._lower_triangular_solve(rhs)
3017         Z = D._diagonal_solve(Y)
3018         return (L.H)._upper_triangular_solve(Z)
3019 
3020     def lower_triangular_solve(self, rhs):
3021         """Solves Ax = B, where A is a lower triangular matrix.
3022 
3023         See Also
3024         ========
3025 
3026         upper_triangular_solve
3027         gauss_jordan_solve
3028         cholesky_solve
3029         diagonal_solve
3030         LDLsolve
3031         LUsolve
3032         QRsolve
3033         pinv_solve
3034         """
3035 
3036         if not self.is_square:
3037             raise NonSquareMatrixError("Matrix must be square.")
3038         if rhs.rows != self.rows:
3039             raise ShapeError("Matrices size mismatch.")
3040         if not self.is_lower:
3041             raise ValueError("Matrix must be lower triangular.")
3042         return self._lower_triangular_solve(rhs)
3043 
3044     def LUdecomposition(self,
3045                         iszerofunc=_iszero,
3046                         simpfunc=None,
3047                         rankcheck=False):
3048         """Returns (L, U, perm) where L is a lower triangular matrix with unit
3049         diagonal, U is an upper triangular matrix, and perm is a list of row
3050         swap index pairs. If A is the original matrix, then
3051         A = (L*U).permuteBkwd(perm), and the row permutation matrix P such
3052         that P*A = L*U can be computed by P=eye(A.row).permuteFwd(perm).
3053 
3054         See documentation for LUCombined for details about the keyword argument
3055         rankcheck, iszerofunc, and simpfunc.
3056 
3057         Examples
3058         ========
3059 
3060         >>> from sympy import Matrix
3061         >>> a = Matrix([[4, 3], [6, 3]])
3062         >>> L, U, _ = a.LUdecomposition()
3063         >>> L
3064         Matrix([
3065         [  1, 0],
3066         [3/2, 1]])
3067         >>> U
3068         Matrix([
3069         [4,    3],
3070         [0, -3/2]])
3071 
3072         See Also
3073         ========
3074 
3075         cholesky
3076         LDLdecomposition
3077         QRdecomposition
3078         LUdecomposition_Simple
3079         LUdecompositionFF
3080         LUsolve
3081         """
3082 
3083         combined, p = self.LUdecomposition_Simple(iszerofunc=iszerofunc,
3084                                                   simpfunc=simpfunc,
3085                                                   rankcheck=rankcheck)
3086 
3087         # L is lower triangular self.rows x self.rows
3088         # U is upper triangular self.rows x self.cols
3089         # L has unit diagonal. For each column in combined, the subcolumn
3090         # below the diagonal of combined is shared by L.
3091         # If L has more columns than combined, then the remaining subcolumns
3092         # below the diagonal of L are zero.
3093         # The upper triangular portion of L and combined are equal.
3094         def entry_L(i, j):
3095             if i < j:
3096                 # Super diagonal entry
3097                 return S.Zero
3098             elif i == j:
3099                 return S.One
3100             elif j < combined.cols:
3101                 return combined[i, j]
3102             # Subdiagonal entry of L with no corresponding
3103             # entry in combined
3104             return S.Zero
3105 
3106         def entry_U(i, j):
3107             return S.Zero if i > j else combined[i, j]
3108 
3109         L = self._new(combined.rows, combined.rows, entry_L)
3110         U = self._new(combined.rows, combined.cols, entry_U)
3111 
3112         return L, U, p
3113 
3114 
3115     def LUdecomposition_Simple(self,
3116                                iszerofunc=_iszero,
3117                                simpfunc=None,
3118                                rankcheck=False):
3119         """Compute an lu decomposition of m x n matrix A, where P*A = L*U
3120 
3121         * L is m x m lower triangular with unit diagonal
3122         * U is m x n upper triangular
3123         * P is an m x m permutation matrix
3124 
3125         Returns an m x n matrix lu, and an m element list perm where each
3126         element of perm is a pair of row exchange indices.
3127 
3128         The factors L and U are stored in lu as follows:
3129         The subdiagonal elements of L are stored in the subdiagonal elements
3130         of lu, that is lu[i, j] = L[i, j] whenever i > j.
3131         The elements on the diagonal of L are all 1, and are not explicitly
3132         stored.
3133         U is stored in the upper triangular portion of lu, that is
3134         lu[i ,j] = U[i, j] whenever i <= j.
3135         The output matrix can be visualized as:
3136 
3137             Matrix([
3138                 [u, u, u, u],
3139                 [l, u, u, u],
3140                 [l, l, u, u],
3141                 [l, l, l, u]])
3142 
3143         where l represents a subdiagonal entry of the L factor, and u
3144         represents an entry from the upper triangular entry of the U
3145         factor.
3146 
3147         perm is a list row swap index pairs such that if A is the original
3148         matrix, then A = (L*U).permuteBkwd(perm), and the row permutation
3149         matrix P such that ``P*A = L*U`` can be computed by
3150         ``P=eye(A.row).permuteFwd(perm)``.
3151 
3152         The keyword argument rankcheck determines if this function raises a
3153         ValueError when passed a matrix whose rank is strictly less than
3154         min(num rows, num cols). The default behavior is to decompose a rank
3155         deficient matrix. Pass rankcheck=True to raise a
3156         ValueError instead. (This mimics the previous behavior of this function).
3157 
3158         The keyword arguments iszerofunc and simpfunc are used by the pivot
3159         search algorithm.
3160         iszerofunc is a callable that returns a boolean indicating if its
3161         input is zero, or None if it cannot make the determination.
3162         simpfunc is a callable that simplifies its input.
3163         The default is simpfunc=None, which indicate that the pivot search
3164         algorithm should not attempt to simplify any candidate pivots.
3165         If simpfunc fails to simplify its input, then it must return its input
3166         instead of a copy.
3167 
3168         When a matrix contains symbolic entries, the pivot search algorithm
3169         differs from the case where every entry can be categorized as zero or
3170         nonzero.
3171         The algorithm searches column by column through the submatrix whose
3172         top left entry coincides with the pivot position.
3173         If it exists, the pivot is the first entry in the current search
3174         column that iszerofunc guarantees is nonzero.
3175         If no such candidate exists, then each candidate pivot is simplified
3176         if simpfunc is not None.
3177         The search is repeated, with the difference that a candidate may be
3178         the pivot if ``iszerofunc()`` cannot guarantee that it is nonzero.
3179         In the second search the pivot is the first candidate that
3180         iszerofunc can guarantee is nonzero.
3181         If no such candidate exists, then the pivot is the first candidate
3182         for which iszerofunc returns None.
3183         If no such candidate exists, then the search is repeated in the next
3184         column to the right.
3185         The pivot search algorithm differs from the one in `rref()`, which
3186         relies on ``_find_reasonable_pivot()``.
3187         Future versions of ``LUdecomposition_simple()`` may use
3188         ``_find_reasonable_pivot()``.
3189 
3190         See Also
3191         ========
3192 
3193         LUdecomposition
3194         LUdecompositionFF
3195         LUsolve
3196         """
3197 
3198         if rankcheck:
3199             # https://github.com/sympy/sympy/issues/9796
3200             pass
3201 
3202         if self.rows == 0 or self.cols == 0:
3203             # Define LU decomposition of a matrix with no entries as a matrix
3204             # of the same dimensions with all zero entries.
3205             return self.zeros(self.rows, self.cols), []
3206 
3207         lu = self.as_mutable()
3208         row_swaps = []
3209 
3210         pivot_col = 0
3211         for pivot_row in range(0, lu.rows - 1):
3212             # Search for pivot. Prefer entry that iszeropivot determines
3213             # is nonzero, over entry that iszeropivot cannot guarantee
3214             # is  zero.
3215             # XXX `_find_reasonable_pivot` uses slow zero testing. Blocked by bug #10279
3216             # Future versions of LUdecomposition_simple can pass iszerofunc and simpfunc
3217             # to _find_reasonable_pivot().
3218             # In pass 3 of _find_reasonable_pivot(), the predicate in `if x.equals(S.Zero):`
3219             # calls sympy.simplify(), and not the simplification function passed in via
3220             # the keyword argument simpfunc.
3221 
3222             iszeropivot = True
3223             while pivot_col != self.cols and iszeropivot:
3224                 sub_col = (lu[r, pivot_col] for r in range(pivot_row, self.rows))
3225                 pivot_row_offset, pivot_value, is_assumed_non_zero, ind_simplified_pairs =\
3226                     _find_reasonable_pivot_naive(sub_col, iszerofunc, simpfunc)
3227                 iszeropivot = pivot_value is None
3228                 if iszeropivot:
3229                     # All candidate pivots in this column are zero.
3230                     # Proceed to next column.
3231                     pivot_col += 1
3232 
3233             if rankcheck and pivot_col != pivot_row:
3234                 # All entries including and below the pivot position are
3235                 # zero, which indicates that the rank of the matrix is
3236                 # strictly less than min(num rows, num cols)
3237                 # Mimic behavior of previous implementation, by throwing a
3238                 # ValueError.
3239                 raise ValueError("Rank of matrix is strictly less than"
3240                                  " number of rows or columns."
3241                                  " Pass keyword argument"
3242                                  " rankcheck=False to compute"
3243                                  " the LU decomposition of this matrix.")
3244 
3245             candidate_pivot_row = None if pivot_row_offset is None else pivot_row + pivot_row_offset
3246 
3247             if candidate_pivot_row is None and iszeropivot:
3248                 # If candidate_pivot_row is None and iszeropivot is True
3249                 # after pivot search has completed, then the submatrix
3250                 # below and to the right of (pivot_row, pivot_col) is
3251                 # all zeros, indicating that Gaussian elimination is
3252                 # complete.
3253                 return lu, row_swaps
3254 
3255             # Update entries simplified during pivot search.
3256             for offset, val in ind_simplified_pairs:
3257                 lu[pivot_row + offset, pivot_col] = val
3258 
3259             if pivot_row != candidate_pivot_row:
3260                 # Row swap book keeping:
3261                 # Record which rows were swapped.
3262                 # Update stored portion of L factor by multiplying L on the
3263                 # left and right with the current permutation.
3264                 # Swap rows of U.
3265                 row_swaps.append([pivot_row, candidate_pivot_row])
3266 
3267                 # Update L.
3268                 lu[pivot_row, 0:pivot_row], lu[candidate_pivot_row, 0:pivot_row] = \
3269                     lu[candidate_pivot_row, 0:pivot_row], lu[pivot_row, 0:pivot_row]
3270 
3271                 # Swap pivot row of U with candidate pivot row.
3272                 lu[pivot_row, pivot_col:lu.cols], lu[candidate_pivot_row, pivot_col:lu.cols] = \
3273                     lu[candidate_pivot_row, pivot_col:lu.cols], lu[pivot_row, pivot_col:lu.cols]
3274 
3275             # Introduce zeros below the pivot by adding a multiple of the
3276             # pivot row to a row under it, and store the result in the
3277             # row under it.
3278             # Only entries in the target row whose index is greater than
3279             # start_col may be nonzero.
3280             start_col = pivot_col + 1
3281             for row in range(pivot_row + 1, lu.rows):
3282                 # Store factors of L in the subcolumn below
3283                 # (pivot_row, pivot_row).
3284                 lu[row, pivot_row] =\
3285                     lu[row, pivot_col]/lu[pivot_row, pivot_col]
3286 
3287                 # Form the linear combination of the pivot row and the current
3288                 # row below the pivot row that zeros the entries below the pivot.
3289                 # Employing slicing instead of a loop here raises
3290                 # NotImplementedError: Cannot add Zero to MutableSparseMatrix
3291                 # in sympy/matrices/tests/test_sparse.py.
3292                 # c = pivot_row + 1 if pivot_row == pivot_col else pivot_col
3293                 for c in range(start_col, lu.cols):
3294                     lu[row, c] = lu[row, c] - lu[row, pivot_row]*lu[pivot_row, c]
3295 
3296             if pivot_row != pivot_col:
3297                 # matrix rank < min(num rows, num cols),
3298                 # so factors of L are not stored directly below the pivot.
3299                 # These entries are zero by construction, so don't bother
3300                 # computing them.
3301                 for row in range(pivot_row + 1, lu.rows):
3302                     lu[row, pivot_col] = S.Zero
3303 
3304             pivot_col += 1
3305             if pivot_col == lu.cols:
3306                 # All candidate pivots are zero implies that Gaussian
3307                 # elimination is complete.
3308                 return lu, row_swaps
3309 
3310         return lu, row_swaps
3311 
3312     def LUdecompositionFF(self):
3313         """Compute a fraction-free LU decomposition.
3314 
3315         Returns 4 matrices P, L, D, U such that PA = L D**-1 U.
3316         If the elements of the matrix belong to some integral domain I, then all
3317         elements of L, D and U are guaranteed to belong to I.
3318 
3319         **Reference**
3320             - W. Zhou & D.J. Jeffrey, "Fraction-free matrix factors: new forms
3321               for LU and QR factors". Frontiers in Computer Science in China,
3322               Vol 2, no. 1, pp. 67-80, 2008.
3323 
3324         See Also
3325         ========
3326 
3327         LUdecomposition
3328         LUdecomposition_Simple
3329         LUsolve
3330         """
3331         from sympy.matrices import SparseMatrix
3332         zeros = SparseMatrix.zeros
3333         eye = SparseMatrix.eye
3334 
3335         n, m = self.rows, self.cols
3336         U, L, P = self.as_mutable(), eye(n), eye(n)
3337         DD = zeros(n, n)
3338         oldpivot = 1
3339 
3340         for k in range(n - 1):
3341             if U[k, k] == 0:
3342                 for kpivot in range(k + 1, n):
3343                     if U[kpivot, k]:
3344                         break
3345                 else:
3346                     raise ValueError("Matrix is not full rank")
3347                 U[k, k:], U[kpivot, k:] = U[kpivot, k:], U[k, k:]
3348                 L[k, :k], L[kpivot, :k] = L[kpivot, :k], L[k, :k]
3349                 P[k, :], P[kpivot, :] = P[kpivot, :], P[k, :]
3350             L[k, k] = Ukk = U[k, k]
3351             DD[k, k] = oldpivot * Ukk
3352             for i in range(k + 1, n):
3353                 L[i, k] = Uik = U[i, k]
3354                 for j in range(k + 1, m):
3355                     U[i, j] = (Ukk * U[i, j] - U[k, j] * Uik) / oldpivot
3356                 U[i, k] = 0
3357             oldpivot = Ukk
3358         DD[n - 1, n - 1] = oldpivot
3359         return P, L, DD, U
3360 
3361     def LUsolve(self, rhs, iszerofunc=_iszero):
3362         """Solve the linear system Ax = rhs for x where A = self.
3363 
3364         This is for symbolic matrices, for real or complex ones use
3365         mpmath.lu_solve or mpmath.qr_solve.
3366 
3367         See Also
3368         ========
3369 
3370         lower_triangular_solve
3371         upper_triangular_solve
3372         gauss_jordan_solve
3373         cholesky_solve
3374         diagonal_solve
3375         LDLsolve
3376         QRsolve
3377         pinv_solve
3378         LUdecomposition
3379         """
3380         if rhs.rows != self.rows:
3381             raise ShapeError(
3382                 "`self` and `rhs` must have the same number of rows.")
3383 
3384         A, perm = self.LUdecomposition_Simple(iszerofunc=_iszero)
3385         n = self.rows
3386         b = rhs.permute_rows(perm).as_mutable()
3387         # forward substitution, all diag entries are scaled to 1
3388         for i in range(n):
3389             for j in range(i):
3390                 scale = A[i, j]
3391                 b.zip_row_op(i, j, lambda x, y: x - y * scale)
3392         # backward substitution
3393         for i in range(n - 1, -1, -1):
3394             for j in range(i + 1, n):
3395                 scale = A[i, j]
3396                 b.zip_row_op(i, j, lambda x, y: x - y * scale)
3397             scale = A[i, i]
3398             b.row_op(i, lambda x, _: x / scale)
3399         return rhs.__class__(b)
3400 
3401     def multiply(self, b):
3402         """Returns self*b
3403 
3404         See Also
3405         ========
3406 
3407         dot
3408         cross
3409         multiply_elementwise
3410         """
3411         return self * b
3412 
3413     def normalized(self):
3414         """Return the normalized version of ``self``.
3415 
3416         See Also
3417         ========
3418 
3419         norm
3420         """
3421         if self.rows != 1 and self.cols != 1:
3422             raise ShapeError("A Matrix must be a vector to normalize.")
3423         norm = self.norm()
3424         out = self.applyfunc(lambda i: i / norm)
3425         return out
3426 
3427     def norm(self, ord=None):
3428         """Return the Norm of a Matrix or Vector.
3429         In the simplest case this is the geometric size of the vector
3430         Other norms can be specified by the ord parameter
3431 
3432 
3433         =====  ============================  ==========================
3434         ord    norm for matrices             norm for vectors
3435         =====  ============================  ==========================
3436         None   Frobenius norm                2-norm
3437         'fro'  Frobenius norm                - does not exist
3438         inf    maximum row sum               max(abs(x))
3439         -inf   --                            min(abs(x))
3440         1      maximum column sum            as below
3441         -1     --                            as below
3442         2      2-norm (largest sing. value)  as below
3443         -2     smallest singular value       as below
3444         other  - does not exist              sum(abs(x)**ord)**(1./ord)
3445         =====  ============================  ==========================
3446 
3447         Examples
3448         ========
3449 
3450         >>> from sympy import Matrix, Symbol, trigsimp, cos, sin, oo
3451         >>> x = Symbol('x', real=True)
3452         >>> v = Matrix([cos(x), sin(x)])
3453         >>> trigsimp( v.norm() )
3454         1
3455         >>> v.norm(10)
3456         (sin(x)**10 + cos(x)**10)**(1/10)
3457         >>> A = Matrix([[1, 1], [1, 1]])
3458         >>> A.norm(1) # maximum sum of absolute values of A is 2
3459         2
3460         >>> A.norm(2) # Spectral norm (max of |Ax|/|x| under 2-vector-norm)
3461         2
3462         >>> A.norm(-2) # Inverse spectral norm (smallest singular value)
3463         0
3464         >>> A.norm() # Frobenius Norm
3465         2
3466         >>> A.norm(oo) # Infinity Norm
3467         2
3468         >>> Matrix([1, -2]).norm(oo)
3469         2
3470         >>> Matrix([-1, 2]).norm(-oo)
3471         1
3472 
3473         See Also
3474         ========
3475 
3476         normalized
3477         """
3478         # Row or Column Vector Norms
3479         vals = list(self.values()) or [0]
3480         if self.rows == 1 or self.cols == 1:
3481             if ord == 2 or ord is None:  # Common case sqrt(<x, x>)
3482                 return sqrt(Add(*(abs(i) ** 2 for i in vals)))
3483 
3484             elif ord == 1:  # sum(abs(x))
3485                 return Add(*(abs(i) for i in vals))
3486 
3487             elif ord == S.Infinity:  # max(abs(x))
3488                 return Max(*[abs(i) for i in vals])
3489 
3490             elif ord == S.NegativeInfinity:  # min(abs(x))
3491                 return Min(*[abs(i) for i in vals])
3492 
3493             # Otherwise generalize the 2-norm, Sum(x_i**ord)**(1/ord)
3494             # Note that while useful this is not mathematically a norm
3495             try:
3496                 return Pow(Add(*(abs(i) ** ord for i in vals)), S(1) / ord)
3497             except (NotImplementedError, TypeError):
3498                 raise ValueError("Expected order to be Number, Symbol, oo")
3499 
3500         # Matrix Norms
3501         else:
3502             if ord == 1:  # Maximum column sum
3503                 m = self.applyfunc(abs)
3504                 return Max(*[sum(m.col(i)) for i in range(m.cols)])
3505 
3506             elif ord == 2:  # Spectral Norm
3507                 # Maximum singular value
3508                 return Max(*self.singular_values())
3509 
3510             elif ord == -2:
3511                 # Minimum singular value
3512                 return Min(*self.singular_values())
3513 
3514             elif ord == S.Infinity:   # Infinity Norm - Maximum row sum
3515                 m = self.applyfunc(abs)
3516                 return Max(*[sum(m.row(i)) for i in range(m.rows)])
3517 
3518             elif (ord is None or isinstance(ord,
3519                                             string_types) and ord.lower() in
3520                 ['f', 'fro', 'frobenius', 'vector']):
3521                 # Reshape as vector and send back to norm function
3522                 return self.vec().norm(ord=2)
3523 
3524             else:
3525                 raise NotImplementedError("Matrix Norms under development")
3526 
3527     def pinv_solve(self, B, arbitrary_matrix=None):
3528         """Solve Ax = B using the Moore-Penrose pseudoinverse.
3529 
3530         There may be zero, one, or infinite solutions.  If one solution
3531         exists, it will be returned.  If infinite solutions exist, one will
3532         be returned based on the value of arbitrary_matrix.  If no solutions
3533         exist, the least-squares solution is returned.
3534 
3535         Parameters
3536         ==========
3537 
3538         B : Matrix
3539             The right hand side of the equation to be solved for.  Must have
3540             the same number of rows as matrix A.
3541         arbitrary_matrix : Matrix
3542             If the system is underdetermined (e.g. A has more columns than
3543             rows), infinite solutions are possible, in terms of an arbitrary
3544             matrix.  This parameter may be set to a specific matrix to use
3545             for that purpose; if so, it must be the same shape as x, with as
3546             many rows as matrix A has columns, and as many columns as matrix
3547             B.  If left as None, an appropriate matrix containing dummy
3548             symbols in the form of ``wn_m`` will be used, with n and m being
3549             row and column position of each symbol.
3550 
3551         Returns
3552         =======
3553 
3554         x : Matrix
3555             The matrix that will satisfy Ax = B.  Will have as many rows as
3556             matrix A has columns, and as many columns as matrix B.
3557 
3558         Examples
3559         ========
3560 
3561         >>> from sympy import Matrix
3562         >>> A = Matrix([[1, 2, 3], [4, 5, 6]])
3563         >>> B = Matrix([7, 8])
3564         >>> A.pinv_solve(B)
3565         Matrix([
3566         [ _w0_0/6 - _w1_0/3 + _w2_0/6 - 55/18],
3567         [-_w0_0/3 + 2*_w1_0/3 - _w2_0/3 + 1/9],
3568         [ _w0_0/6 - _w1_0/3 + _w2_0/6 + 59/18]])
3569         >>> A.pinv_solve(B, arbitrary_matrix=Matrix([0, 0, 0]))
3570         Matrix([
3571         [-55/18],
3572         [   1/9],
3573         [ 59/18]])
3574 
3575         See Also
3576         ========
3577 
3578         lower_triangular_solve
3579         upper_triangular_solve
3580         gauss_jordan_solve
3581         cholesky_solve
3582         diagonal_solve
3583         LDLsolve
3584         LUsolve
3585         QRsolve
3586         pinv
3587 
3588         Notes
3589         =====
3590 
3591         This may return either exact solutions or least squares solutions.
3592         To determine which, check ``A * A.pinv() * B == B``.  It will be
3593         True if exact solutions exist, and False if only a least-squares
3594         solution exists.  Be aware that the left hand side of that equation
3595         may need to be simplified to correctly compare to the right hand
3596         side.
3597 
3598         References
3599         ==========
3600 
3601         .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system
3602 
3603         """
3604         from sympy.matrices import eye
3605         A = self
3606         A_pinv = self.pinv()
3607         if arbitrary_matrix is None:
3608             rows, cols = A.cols, B.cols
3609             w = symbols('w:{0}_:{1}'.format(rows, cols), cls=Dummy)
3610             arbitrary_matrix = self.__class__(cols, rows, w).T
3611         return A_pinv * B + (eye(A.cols) - A_pinv * A) * arbitrary_matrix
3612 
3613     def pinv(self):
3614         """Calculate the Moore-Penrose pseudoinverse of the matrix.
3615 
3616         The Moore-Penrose pseudoinverse exists and is unique for any matrix.
3617         If the matrix is invertible, the pseudoinverse is the same as the
3618         inverse.
3619 
3620         Examples
3621         ========
3622 
3623         >>> from sympy import Matrix
3624         >>> Matrix([[1, 2, 3], [4, 5, 6]]).pinv()
3625         Matrix([
3626         [-17/18,  4/9],
3627         [  -1/9,  1/9],
3628         [ 13/18, -2/9]])
3629 
3630         See Also
3631         ========
3632 
3633         inv
3634         pinv_solve
3635 
3636         References
3637         ==========
3638 
3639         .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse
3640 
3641         """
3642         A = self
3643         AH = self.H
3644         # Trivial case: pseudoinverse of all-zero matrix is its transpose.
3645         if A.is_zero:
3646             return AH
3647         try:
3648             if self.rows >= self.cols:
3649                 return (AH * A).inv() * AH
3650             else:
3651                 return AH * (A * AH).inv()
3652         except ValueError:
3653             # Matrix is not full rank, so A*AH cannot be inverted.
3654             raise NotImplementedError('Rank-deficient matrices are not yet '
3655                                       'supported.')
3656 
3657     def print_nonzero(self, symb="X"):
3658         """Shows location of non-zero entries for fast shape lookup.
3659 
3660         Examples
3661         ========
3662 
3663         >>> from sympy.matrices import Matrix, eye
3664         >>> m = Matrix(2, 3, lambda i, j: i*3+j)
3665         >>> m
3666         Matrix([
3667         [0, 1, 2],
3668         [3, 4, 5]])
3669         >>> m.print_nonzero()
3670         [ XX]
3671         [XXX]
3672         >>> m = eye(4)
3673         >>> m.print_nonzero("x")
3674         [x   ]
3675         [ x  ]
3676         [  x ]
3677         [   x]
3678 
3679         """
3680         s = []
3681         for i in range(self.rows):
3682             line = []
3683             for j in range(self.cols):
3684                 if self[i, j] == 0:
3685                     line.append(" ")
3686                 else:
3687                     line.append(str(symb))
3688             s.append("[%s]" % ''.join(line))
3689         print('\n'.join(s))
3690 
3691     def project(self, v):
3692         """Return the projection of ``self`` onto the line containing ``v``.
3693 
3694         Examples
3695         ========
3696 
3697         >>> from sympy import Matrix, S, sqrt
3698         >>> V = Matrix([sqrt(3)/2, S.Half])
3699         >>> x = Matrix([[1, 0]])
3700         >>> V.project(x)
3701         Matrix([[sqrt(3)/2, 0]])
3702         >>> V.project(-x)
3703         Matrix([[sqrt(3)/2, 0]])
3704         """
3705         return v * (self.dot(v) / v.dot(v))
3706 
3707     def QRdecomposition(self):
3708         """Return Q, R where A = Q*R, Q is orthogonal and R is upper triangular.
3709 
3710         Examples
3711         ========
3712 
3713         This is the example from wikipedia:
3714 
3715         >>> from sympy import Matrix
3716         >>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])
3717         >>> Q, R = A.QRdecomposition()
3718         >>> Q
3719         Matrix([
3720         [ 6/7, -69/175, -58/175],
3721         [ 3/7, 158/175,   6/175],
3722         [-2/7,    6/35,  -33/35]])
3723         >>> R
3724         Matrix([
3725         [14,  21, -14],
3726         [ 0, 175, -70],
3727         [ 0,   0,  35]])
3728         >>> A == Q*R
3729         True
3730 
3731         QR factorization of an identity matrix:
3732 
3733         >>> A = Matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
3734         >>> Q, R = A.QRdecomposition()
3735         >>> Q
3736         Matrix([
3737         [1, 0, 0],
3738         [0, 1, 0],
3739         [0, 0, 1]])
3740         >>> R
3741         Matrix([
3742         [1, 0, 0],
3743         [0, 1, 0],
3744         [0, 0, 1]])
3745 
3746         See Also
3747         ========
3748 
3749         cholesky
3750         LDLdecomposition
3751         LUdecomposition
3752         QRsolve
3753         """
3754         cls = self.__class__
3755         mat = self.as_mutable()
3756 
3757         if not mat.rows >= mat.cols:
3758             raise MatrixError(
3759                 "The number of rows must be greater than columns")
3760         n = mat.rows
3761         m = mat.cols
3762         rank = n
3763         row_reduced = mat.rref()[0]
3764         for i in range(row_reduced.rows):
3765             if row_reduced.row(i).norm() == 0:
3766                 rank -= 1
3767         if not rank == mat.cols:
3768             raise MatrixError("The rank of the matrix must match the columns")
3769         Q, R = mat.zeros(n, m), mat.zeros(m)
3770         for j in range(m):  # for each column vector
3771             tmp = mat[:, j]  # take original v
3772             for i in range(j):
3773                 # subtract the project of mat on new vector
3774                 tmp -= Q[:, i] * mat[:, j].dot(Q[:, i])
3775                 tmp.expand()
3776             # normalize it
3777             R[j, j] = tmp.norm()
3778             Q[:, j] = tmp / R[j, j]
3779             if Q[:, j].norm() != 1:
3780                 raise NotImplementedError(
3781                     "Could not normalize the vector %d." % j)
3782             for i in range(j):
3783                 R[i, j] = Q[:, i].dot(mat[:, j])
3784         return cls(Q), cls(R)
3785 
3786     def QRsolve(self, b):
3787         """Solve the linear system 'Ax = b'.
3788 
3789         'self' is the matrix 'A', the method argument is the vector
3790         'b'.  The method returns the solution vector 'x'.  If 'b' is a
3791         matrix, the system is solved for each column of 'b' and the
3792         return value is a matrix of the same shape as 'b'.
3793 
3794         This method is slower (approximately by a factor of 2) but
3795         more stable for floating-point arithmetic than the LUsolve method.
3796         However, LUsolve usually uses an exact arithmetic, so you don't need
3797         to use QRsolve.
3798 
3799         This is mainly for educational purposes and symbolic matrices, for real
3800         (or complex) matrices use mpmath.qr_solve.
3801 
3802         See Also
3803         ========
3804 
3805         lower_triangular_solve
3806         upper_triangular_solve
3807         gauss_jordan_solve
3808         cholesky_solve
3809         diagonal_solve
3810         LDLsolve
3811         LUsolve
3812         pinv_solve
3813         QRdecomposition
3814         """
3815 
3816         Q, R = self.as_mutable().QRdecomposition()
3817         y = Q.T * b
3818 
3819         # back substitution to solve R*x = y:
3820         # We build up the result "backwards" in the vector 'x' and reverse it
3821         # only in the end.
3822         x = []
3823         n = R.rows
3824         for j in range(n - 1, -1, -1):
3825             tmp = y[j, :]
3826             for k in range(j + 1, n):
3827                 tmp -= R[j, k] * x[n - 1 - k]
3828             x.append(tmp / R[j, j])
3829         return self._new([row._mat for row in reversed(x)])
3830 
3831     def solve_least_squares(self, rhs, method='CH'):
3832         """Return the least-square fit to the data.
3833 
3834         By default the cholesky_solve routine is used (method='CH'); other
3835         methods of matrix inversion can be used. To find out which are
3836         available, see the docstring of the .inv() method.
3837 
3838         Examples
3839         ========
3840 
3841         >>> from sympy.matrices import Matrix, ones
3842         >>> A = Matrix([1, 2, 3])
3843         >>> B = Matrix([2, 3, 4])
3844         >>> S = Matrix(A.row_join(B))
3845         >>> S
3846         Matrix([
3847         [1, 2],
3848         [2, 3],
3849         [3, 4]])
3850 
3851         If each line of S represent coefficients of Ax + By
3852         and x and y are [2, 3] then S*xy is:
3853 
3854         >>> r = S*Matrix([2, 3]); r
3855         Matrix([
3856         [ 8],
3857         [13],
3858         [18]])
3859 
3860         But let's add 1 to the middle value and then solve for the
3861         least-squares value of xy:
3862 
3863         >>> xy = S.solve_least_squares(Matrix([8, 14, 18])); xy
3864         Matrix([
3865         [ 5/3],
3866         [10/3]])
3867 
3868         The error is given by S*xy - r:
3869 
3870         >>> S*xy - r
3871         Matrix([
3872         [1/3],
3873         [1/3],
3874         [1/3]])
3875         >>> _.norm().n(2)
3876         0.58
3877 
3878         If a different xy is used, the norm will be higher:
3879 
3880         >>> xy += ones(2, 1)/10
3881         >>> (S*xy - r).norm().n(2)
3882         1.5
3883 
3884         """
3885         if method == 'CH':
3886             return self.cholesky_solve(rhs)
3887         t = self.H
3888         return (t * self).inv(method=method) * t * rhs
3889 
3890     def solve(self, rhs, method='GE'):
3891         """Return solution to self*soln = rhs using given inversion method.
3892 
3893         For a list of possible inversion methods, see the .inv() docstring.
3894         """
3895 
3896         if not self.is_square:
3897             if self.rows < self.cols:
3898                 raise ValueError('Under-determined system. '
3899                                  'Try M.gauss_jordan_solve(rhs)')
3900             elif self.rows > self.cols:
3901                 raise ValueError('For over-determined system, M, having '
3902                                  'more rows than columns, try M.solve_least_squares(rhs).')
3903         else:
3904             return self.inv(method=method) * rhs
3905 
3906     def table(self, printer, rowstart='[', rowend=']', rowsep='\n',
3907               colsep=', ', align='right'):
3908         r"""
3909         String form of Matrix as a table.
3910 
3911         ``printer`` is the printer to use for on the elements (generally
3912         something like StrPrinter())
3913 
3914         ``rowstart`` is the string used to start each row (by default '[').
3915 
3916         ``rowend`` is the string used to end each row (by default ']').
3917 
3918         ``rowsep`` is the string used to separate rows (by default a newline).
3919 
3920         ``colsep`` is the string used to separate columns (by default ', ').
3921 
3922         ``align`` defines how the elements are aligned. Must be one of 'left',
3923         'right', or 'center'.  You can also use '<', '>', and '^' to mean the
3924         same thing, respectively.
3925 
3926         This is used by the string printer for Matrix.
3927 
3928         Examples
3929         ========
3930 
3931         >>> from sympy import Matrix
3932         >>> from sympy.printing.str import StrPrinter
3933         >>> M = Matrix([[1, 2], [-33, 4]])
3934         >>> printer = StrPrinter()
3935         >>> M.table(printer)
3936         '[  1, 2]\n[-33, 4]'
3937         >>> print(M.table(printer))
3938         [  1, 2]
3939         [-33, 4]
3940         >>> print(M.table(printer, rowsep=',\n'))
3941         [  1, 2],
3942         [-33, 4]
3943         >>> print('[%s]' % M.table(printer, rowsep=',\n'))
3944         [[  1, 2],
3945         [-33, 4]]
3946         >>> print(M.table(printer, colsep=' '))
3947         [  1 2]
3948         [-33 4]
3949         >>> print(M.table(printer, align='center'))
3950         [ 1 , 2]
3951         [-33, 4]
3952         >>> print(M.table(printer, rowstart='{', rowend='}'))
3953         {  1, 2}
3954         {-33, 4}
3955         """
3956         # Handle zero dimensions:
3957         if self.rows == 0 or self.cols == 0:
3958             return '[]'
3959         # Build table of string representations of the elements
3960         res = []
3961         # Track per-column max lengths for pretty alignment
3962         maxlen = [0] * self.cols
3963         for i in range(self.rows):
3964             res.append([])
3965             for j in range(self.cols):
3966                 s = printer._print(self[i, j])
3967                 res[-1].append(s)
3968                 maxlen[j] = max(len(s), maxlen[j])
3969         # Patch strings together
3970         align = {
3971             'left': 'ljust',
3972             'right': 'rjust',
3973             'center': 'center',
3974             '<': 'ljust',
3975             '>': 'rjust',
3976             '^': 'center',
3977         }[align]
3978         for i, row in enumerate(res):
3979             for j, elem in enumerate(row):
3980                 row[j] = getattr(elem, align)(maxlen[j])
3981             res[i] = rowstart + colsep.join(row) + rowend
3982         return rowsep.join(res)
3983 
3984     def upper_triangular_solve(self, rhs):
3985         """Solves Ax = B, where A is an upper triangular matrix.
3986 
3987         See Also
3988         ========
3989 
3990         lower_triangular_solve
3991         gauss_jordan_solve
3992         cholesky_solve
3993         diagonal_solve
3994         LDLsolve
3995         LUsolve
3996         QRsolve
3997         pinv_solve
3998         """
3999         if not self.is_square:
4000             raise NonSquareMatrixError("Matrix must be square.")
4001         if rhs.rows != self.rows:
4002             raise TypeError("Matrix size mismatch.")
4003         if not self.is_upper:
4004             raise TypeError("Matrix is not upper triangular.")
4005         return self._upper_triangular_solve(rhs)
4006 
4007     def vech(self, diagonal=True, check_symmetry=True):
4008         """Return the unique elements of a symmetric Matrix as a one column matrix
4009         by stacking the elements in the lower triangle.
4010 
4011         Arguments:
4012         diagonal -- include the diagonal cells of self or not
4013         check_symmetry -- checks symmetry of self but not completely reliably
4014 
4015         Examples
4016         ========
4017 
4018         >>> from sympy import Matrix
4019         >>> m=Matrix([[1, 2], [2, 3]])
4020         >>> m
4021         Matrix([
4022         [1, 2],
4023         [2, 3]])
4024         >>> m.vech()
4025         Matrix([
4026         [1],
4027         [2],
4028         [3]])
4029         >>> m.vech(diagonal=False)
4030         Matrix([[2]])
4031 
4032         See Also
4033         ========
4034 
4035         vec
4036         """
4037         from sympy.matrices import zeros
4038 
4039         c = self.cols
4040         if c != self.rows:
4041             raise ShapeError("Matrix must be square")
4042         if check_symmetry:
4043             self.simplify()
4044             if self != self.transpose():
4045                 raise ValueError(
4046                     "Matrix appears to be asymmetric; consider check_symmetry=False")
4047         count = 0
4048         if diagonal:
4049             v = zeros(c * (c + 1) // 2, 1)
4050             for j in range(c):
4051                 for i in range(j, c):
4052                     v[count] = self[i, j]
4053                     count += 1
4054         else:
4055             v = zeros(c * (c - 1) // 2, 1)
4056             for j in range(c):
4057                 for i in range(j + 1, c):
4058                     v[count] = self[i, j]
4059                     count += 1
4060         return v

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 19:39:34.687 | INFO     | Search completed. Bug locations: [<file>sympy/matrices/matrices.py</file>
<class>MatrixBase</class>
<method>dot</method>
<code>
2400     def dot(self, b):
2401         """Return the dot product of Matrix self and b relaxing the condition
2402         of compatible dimensions: if either the number of rows or columns are
2403         the same as the length of b then the dot product is returned. If self
2404         is a row or column vector, a scalar is returned. Otherwise, a list
2405         of results is returned (and in that case the number of columns in self
2406         must match the length of b).
2407 
2408         Examples
2409         ========
2410 
2411         >>> from sympy import Matrix
2412         >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
2413         >>> v = [1, 1, 1]
2414         >>> M.row(0).dot(v)
2415         6
2416         >>> M.col(0).dot(v)
2417         12
2418         >>> M.dot(v)
2419         [6, 15, 24]
2420 
2421         See Also
2422         ========
2423 
2424         cross
2425         multiply
2426         multiply_elementwise
2427         """
2428         from .dense import Matrix
2429 
2430         if not isinstance(b, MatrixBase):
2431             if is_sequence(b):
2432                 if len(b) != self.cols and len(b) != self.rows:
2433                     raise ShapeError(
2434                         "Dimensions incorrect for dot product: %s, %s" % (
2435                             self.shape, len(b)))
2436                 return self.dot(Matrix(b))
2437             else:
2438                 raise TypeError(
2439                     "`b` must be an ordered iterable or Matrix, not %s." %
2440                     type(b))
2441 
2442         mat = self
2443         if mat.cols == b.rows:
2444             if b.cols != 1:
2445                 mat = mat.T
2446                 b = b.T
2447             prod = flatten((mat * b).tolist())
2448             if len(prod) == 1:
2449                 return prod[0]
2450             return prod
2451         if mat.cols == b.cols:
2452             return mat.dot(b.T)
2453         elif mat.rows == b.rows:
2454             return mat.T.dot(b)
2455         else:
2456             raise ShapeError("Dimensions incorrect for dot product: %s, %s" % (
2457                 self.shape, b.shape))

</code><intended_behavior>The `dot` method within the `MatrixBase` class should be updated to include a more rigorous dimension compatibility check specifically targeting the scenarios described in the issue. The objective is to ensure that when `b` is neither a row vector (1 x m) nor a column vector (n x 1) relative to the dimensions of `self`, the method should raise a `ShapeError` with a clear and actionable message. This update aims to:

- Perform an early check in the method to identify dimension mismatches that would result in undefined or unexpected results for the dot product operation. For instance, before allowing any transformations (transposing of matrices) or calculations, the method should assert that if `self` is a two-dimensional matrix, then `b` must be a vector or a matrix where one dimension matches exactly and the other is 1 (adhering strictly to matrix multiplication rules).

- Update the error message for the `ShapeError` to provide specific guidance on compatible dimensions based on the dimensions of `self`, guiding the user on how to rectify their input without having to guess what might have gone wrong.

This refined behavior will make the method's functionality more robust against misusage while ensuring that the flexibility in handling various shapes (vectors versus matrices) for the dot product does not compromise the mathematical correctness or user expectations.</intended_behavior>, <file>sympy/matrices/matrices.py</file>
<class>MatrixBase</class>
<method>None</method>
<code>
1855 class MatrixBase(MatrixDeprecated,
1856                  MatrixCalculus,
1857                  MatrixEigen,
1858                  MatrixCommon):
1859     """Base class for matrix objects."""
1860     # Added just for numpy compatibility
1861     __array_priority__ = 11
1862 
1863     is_Matrix = True
1864     _class_priority = 3
1865     _sympify = staticmethod(sympify)
1866 
1867     __hash__ = None  # Mutable
1868 
1869     def __array__(self):
1870         from .dense import matrix2numpy
1871         return matrix2numpy(self)
1872 
1873     def __getattr__(self, attr):
1874         if attr in ('diff', 'integrate', 'limit'):
1875             def doit(*args):
1876                 item_doit = lambda item: getattr(item, attr)(*args)
1877                 return self.applyfunc(item_doit)
1878 
1879             return doit
1880         else:
1881             raise AttributeError(
1882                 "%s has no attribute %s." % (self.__class__.__name__, attr))
1883 
1884     def __len__(self):
1885         """Return the number of elements of self.
1886 
1887         Implemented mainly so bool(Matrix()) == False.
1888         """
1889         return self.rows * self.cols
1890 
1891     def __mathml__(self):
1892         mml = ""
1893         for i in range(self.rows):
1894             mml += "<matrixrow>"
1895             for j in range(self.cols):
1896                 mml += self[i, j].__mathml__()
1897             mml += "</matrixrow>"
1898         return "<matrix>" + mml + "</matrix>"
1899 
1900     # needed for python 2 compatibility
1901     def __ne__(self, other):
1902         return not self == other
1903 
1904     def _matrix_pow_by_jordan_blocks(self, num):
1905         from sympy.matrices import diag, MutableMatrix
1906         from sympy import binomial
1907 
1908         def jordan_cell_power(jc, n):
1909             N = jc.shape[0]
1910             l = jc[0, 0]
1911             if l == 0 and (n < N - 1) != False:
1912                 raise ValueError("Matrix det == 0; not invertible")
1913             elif l == 0 and N > 1 and n % 1 != 0:
1914                 raise ValueError("Non-integer power cannot be evaluated")
1915             for i in range(N):
1916                 for j in range(N-i):
1917                     bn = binomial(n, i)
1918                     if isinstance(bn, binomial):
1919                         bn = bn._eval_expand_func()
1920                     jc[j, i+j] = l**(n-i)*bn
1921 
1922         P, J = self.jordan_form()
1923         jordan_cells = J.get_diag_blocks()
1924         # Make sure jordan_cells matrices are mutable:
1925         jordan_cells = [MutableMatrix(j) for j in jordan_cells]
1926         for j in jordan_cells:
1927             jordan_cell_power(j, num)
1928         return self._new(P*diag(*jordan_cells)*P.inv())
1929 
1930     def __repr__(self):
1931         return sstr(self)
1932 
1933     def __str__(self):
1934         if self.rows == 0 or self.cols == 0:
1935             return 'Matrix(%s, %s, [])' % (self.rows, self.cols)
1936         return "Matrix(%s)" % str(self.tolist())
1937 
1938     def _diagonalize_clear_subproducts(self):
1939         del self._is_symbolic
1940         del self._is_symmetric
1941         del self._eigenvects
1942 
1943     def _format_str(self, printer=None):
1944         if not printer:
1945             from sympy.printing.str import StrPrinter
1946             printer = StrPrinter()
1947         # Handle zero dimensions:
1948         if self.rows == 0 or self.cols == 0:
1949             return 'Matrix(%s, %s, [])' % (self.rows, self.cols)
1950         if self.rows == 1:
1951             return "Matrix([%s])" % self.table(printer, rowsep=',\n')
1952         return "Matrix([\n%s])" % self.table(printer, rowsep=',\n')
1953 
1954     @classmethod
1955     def _handle_creation_inputs(cls, *args, **kwargs):
1956         """Return the number of rows, cols and flat matrix elements.
1957 
1958         Examples
1959         ========
1960 
1961         >>> from sympy import Matrix, I
1962 
1963         Matrix can be constructed as follows:
1964 
1965         * from a nested list of iterables
1966 
1967         >>> Matrix( ((1, 2+I), (3, 4)) )
1968         Matrix([
1969         [1, 2 + I],
1970         [3,     4]])
1971 
1972         * from un-nested iterable (interpreted as a column)
1973 
1974         >>> Matrix( [1, 2] )
1975         Matrix([
1976         [1],
1977         [2]])
1978 
1979         * from un-nested iterable with dimensions
1980 
1981         >>> Matrix(1, 2, [1, 2] )
1982         Matrix([[1, 2]])
1983 
1984         * from no arguments (a 0 x 0 matrix)
1985 
1986         >>> Matrix()
1987         Matrix(0, 0, [])
1988 
1989         * from a rule
1990 
1991         >>> Matrix(2, 2, lambda i, j: i/(j + 1) )
1992         Matrix([
1993         [0,   0],
1994         [1, 1/2]])
1995 
1996         """
1997         from sympy.matrices.sparse import SparseMatrix
1998 
1999         flat_list = None
2000 
2001         if len(args) == 1:
2002             # Matrix(SparseMatrix(...))
2003             if isinstance(args[0], SparseMatrix):
2004                 return args[0].rows, args[0].cols, flatten(args[0].tolist())
2005 
2006             # Matrix(Matrix(...))
2007             elif isinstance(args[0], MatrixBase):
2008                 return args[0].rows, args[0].cols, args[0]._mat
2009 
2010             # Matrix(MatrixSymbol('X', 2, 2))
2011             elif isinstance(args[0], Basic) and args[0].is_Matrix:
2012                 return args[0].rows, args[0].cols, args[0].as_explicit()._mat
2013 
2014             # Matrix(numpy.ones((2, 2)))
2015             elif hasattr(args[0], "__array__"):
2016                 # NumPy array or matrix or some other object that implements
2017                 # __array__. So let's first use this method to get a
2018                 # numpy.array() and then make a python list out of it.
2019                 arr = args[0].__array__()
2020                 if len(arr.shape) == 2:
2021                     rows, cols = arr.shape[0], arr.shape[1]
2022                     flat_list = [cls._sympify(i) for i in arr.ravel()]
2023                     return rows, cols, flat_list
2024                 elif len(arr.shape) == 1:
2025                     rows, cols = arr.shape[0], 1
2026                     flat_list = [S.Zero] * rows
2027                     for i in range(len(arr)):
2028                         flat_list[i] = cls._sympify(arr[i])
2029                     return rows, cols, flat_list
2030                 else:
2031                     raise NotImplementedError(
2032                         "SymPy supports just 1D and 2D matrices")
2033 
2034             # Matrix([1, 2, 3]) or Matrix([[1, 2], [3, 4]])
2035             elif is_sequence(args[0]) \
2036                     and not isinstance(args[0], DeferredVector):
2037                 in_mat = []
2038                 ncol = set()
2039                 for row in args[0]:
2040                     if isinstance(row, MatrixBase):
2041                         in_mat.extend(row.tolist())
2042                         if row.cols or row.rows:  # only pay attention if it's not 0x0
2043                             ncol.add(row.cols)
2044                     else:
2045                         in_mat.append(row)
2046                         try:
2047                             ncol.add(len(row))
2048                         except TypeError:
2049                             ncol.add(1)
2050                 if len(ncol) > 1:
2051                     raise ValueError("Got rows of variable lengths: %s" %
2052                                      sorted(list(ncol)))
2053                 cols = ncol.pop() if ncol else 0
2054                 rows = len(in_mat) if cols else 0
2055                 if rows:
2056                     if not is_sequence(in_mat[0]):
2057                         cols = 1
2058                         flat_list = [cls._sympify(i) for i in in_mat]
2059                         return rows, cols, flat_list
2060                 flat_list = []
2061                 for j in range(rows):
2062                     for i in range(cols):
2063                         flat_list.append(cls._sympify(in_mat[j][i]))
2064 
2065         elif len(args) == 3:
2066             rows = as_int(args[0])
2067             cols = as_int(args[1])
2068 
2069             if rows < 0 or cols < 0:
2070                 raise ValueError("Cannot create a {} x {} matrix. "
2071                                  "Both dimensions must be positive".format(rows, cols))
2072 
2073             # Matrix(2, 2, lambda i, j: i+j)
2074             if len(args) == 3 and isinstance(args[2], collections.Callable):
2075                 op = args[2]
2076                 flat_list = []
2077                 for i in range(rows):
2078                     flat_list.extend(
2079                         [cls._sympify(op(cls._sympify(i), cls._sympify(j)))
2080                          for j in range(cols)])
2081 
2082             # Matrix(2, 2, [1, 2, 3, 4])
2083             elif len(args) == 3 and is_sequence(args[2]):
2084                 flat_list = args[2]
2085                 if len(flat_list) != rows * cols:
2086                     raise ValueError(
2087                         'List length should be equal to rows*columns')
2088                 flat_list = [cls._sympify(i) for i in flat_list]
2089 
2090 
2091         # Matrix()
2092         elif len(args) == 0:
2093             # Empty Matrix
2094             rows = cols = 0
2095             flat_list = []
2096 
2097         if flat_list is None:
2098             raise TypeError("Data type not understood")
2099 
2100         return rows, cols, flat_list
2101 
2102     def _setitem(self, key, value):
2103         """Helper to set value at location given by key.
2104 
2105         Examples
2106         ========
2107 
2108         >>> from sympy import Matrix, I, zeros, ones
2109         >>> m = Matrix(((1, 2+I), (3, 4)))
2110         >>> m
2111         Matrix([
2112         [1, 2 + I],
2113         [3,     4]])
2114         >>> m[1, 0] = 9
2115         >>> m
2116         Matrix([
2117         [1, 2 + I],
2118         [9,     4]])
2119         >>> m[1, 0] = [[0, 1]]
2120 
2121         To replace row r you assign to position r*m where m
2122         is the number of columns:
2123 
2124         >>> M = zeros(4)
2125         >>> m = M.cols
2126         >>> M[3*m] = ones(1, m)*2; M
2127         Matrix([
2128         [0, 0, 0, 0],
2129         [0, 0, 0, 0],
2130         [0, 0, 0, 0],
2131         [2, 2, 2, 2]])
2132 
2133         And to replace column c you can assign to position c:
2134 
2135         >>> M[2] = ones(m, 1)*4; M
2136         Matrix([
2137         [0, 0, 4, 0],
2138         [0, 0, 4, 0],
2139         [0, 0, 4, 0],
2140         [2, 2, 4, 2]])
2141         """
2142         from .dense import Matrix
2143 
2144         is_slice = isinstance(key, slice)
2145         i, j = key = self.key2ij(key)
2146         is_mat = isinstance(value, MatrixBase)
2147         if type(i) is slice or type(j) is slice:
2148             if is_mat:
2149                 self.copyin_matrix(key, value)
2150                 return
2151             if not isinstance(value, Expr) and is_sequence(value):
2152                 self.copyin_list(key, value)
2153                 return
2154             raise ValueError('unexpected value: %s' % value)
2155         else:
2156             if (not is_mat and
2157                     not isinstance(value, Basic) and is_sequence(value)):
2158                 value = Matrix(value)
2159                 is_mat = True
2160             if is_mat:
2161                 if is_slice:
2162                     key = (slice(*divmod(i, self.cols)),
2163                            slice(*divmod(j, self.cols)))
2164                 else:
2165                     key = (slice(i, i + value.rows),
2166                            slice(j, j + value.cols))
2167                 self.copyin_matrix(key, value)
2168             else:
2169                 return i, j, self._sympify(value)
2170             return
2171 
2172     def add(self, b):
2173         """Return self + b """
2174         return self + b
2175 
2176     def cholesky_solve(self, rhs):
2177         """Solves Ax = B using Cholesky decomposition,
2178         for a general square non-singular matrix.
2179         For a non-square matrix with rows > cols,
2180         the least squares solution is returned.
2181 
2182         See Also
2183         ========
2184 
2185         lower_triangular_solve
2186         upper_triangular_solve
2187         gauss_jordan_solve
2188         diagonal_solve
2189         LDLsolve
2190         LUsolve
2191         QRsolve
2192         pinv_solve
2193         """
2194         if self.is_hermitian:
2195             L = self._cholesky()
2196         elif self.rows >= self.cols:
2197             L = (self.H * self)._cholesky()
2198             rhs = self.H * rhs
2199         else:
2200             raise NotImplementedError('Under-determined System. '
2201                                       'Try M.gauss_jordan_solve(rhs)')
2202         Y = L._lower_triangular_solve(rhs)
2203         return (L.H)._upper_triangular_solve(Y)
2204 
2205     def cholesky(self):
2206         """Returns the Cholesky decomposition L of a matrix A
2207         such that L * L.H = A
2208 
2209         A must be a Hermitian positive-definite matrix.
2210 
2211         Examples
2212         ========
2213 
2214         >>> from sympy.matrices import Matrix
2215         >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
2216         >>> A.cholesky()
2217         Matrix([
2218         [ 5, 0, 0],
2219         [ 3, 3, 0],
2220         [-1, 1, 3]])
2221         >>> A.cholesky() * A.cholesky().T
2222         Matrix([
2223         [25, 15, -5],
2224         [15, 18,  0],
2225         [-5,  0, 11]])
2226 
2227         The matrix can have complex entries:
2228 
2229         >>> from sympy import I
2230         >>> A = Matrix(((9, 3*I), (-3*I, 5)))
2231         >>> A.cholesky()
2232         Matrix([
2233         [ 3, 0],
2234         [-I, 2]])
2235         >>> A.cholesky() * A.cholesky().H
2236         Matrix([
2237         [   9, 3*I],
2238         [-3*I,   5]])
2239 
2240         See Also
2241         ========
2242 
2243         LDLdecomposition
2244         LUdecomposition
2245         QRdecomposition
2246         """
2247 
2248         if not self.is_square:
2249             raise NonSquareMatrixError("Matrix must be square.")
2250         if not self.is_hermitian:
2251             raise ValueError("Matrix must be Hermitian.")
2252         return self._cholesky()
2253 
2254     def condition_number(self):
2255         """Returns the condition number of a matrix.
2256 
2257         This is the maximum singular value divided by the minimum singular value
2258 
2259         Examples
2260         ========
2261 
2262         >>> from sympy import Matrix, S
2263         >>> A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]])
2264         >>> A.condition_number()
2265         100
2266 
2267         See Also
2268         ========
2269 
2270         singular_values
2271         """
2272         if not self:
2273             return S.Zero
2274         singularvalues = self.singular_values()
2275         return Max(*singularvalues) / Min(*singularvalues)
2276 
2277     def copy(self):
2278         """
2279         Returns the copy of a matrix.
2280 
2281         Examples
2282         ========
2283 
2284         >>> from sympy import Matrix
2285         >>> A = Matrix(2, 2, [1, 2, 3, 4])
2286         >>> A.copy()
2287         Matrix([
2288         [1, 2],
2289         [3, 4]])
2290 
2291         """
2292         return self._new(self.rows, self.cols, self._mat)
2293 
2294     def cross(self, b):
2295         r"""
2296         Return the cross product of ``self`` and ``b`` relaxing the condition
2297         of compatible dimensions: if each has 3 elements, a matrix of the
2298         same type and shape as ``self`` will be returned. If ``b`` has the same
2299         shape as ``self`` then common identities for the cross product (like
2300         `a \times b = - b \times a`) will hold.
2301 
2302         Parameters
2303         ==========
2304             b : 3x1 or 1x3 Matrix
2305 
2306         See Also
2307         ========
2308 
2309         dot
2310         multiply
2311         multiply_elementwise
2312         """
2313         if not is_sequence(b):
2314             raise TypeError(
2315                 "`b` must be an ordered iterable or Matrix, not %s." %
2316                 type(b))
2317         if not (self.rows * self.cols == b.rows * b.cols == 3):
2318             raise ShapeError("Dimensions incorrect for cross product: %s x %s" %
2319                              ((self.rows, self.cols), (b.rows, b.cols)))
2320         else:
2321             return self._new(self.rows, self.cols, (
2322                 (self[1] * b[2] - self[2] * b[1]),
2323                 (self[2] * b[0] - self[0] * b[2]),
2324                 (self[0] * b[1] - self[1] * b[0])))
2325 
2326     @property
2327     def D(self):
2328         """Return Dirac conjugate (if self.rows == 4).
2329 
2330         Examples
2331         ========
2332 
2333         >>> from sympy import Matrix, I, eye
2334         >>> m = Matrix((0, 1 + I, 2, 3))
2335         >>> m.D
2336         Matrix([[0, 1 - I, -2, -3]])
2337         >>> m = (eye(4) + I*eye(4))
2338         >>> m[0, 3] = 2
2339         >>> m.D
2340         Matrix([
2341         [1 - I,     0,      0,      0],
2342         [    0, 1 - I,      0,      0],
2343         [    0,     0, -1 + I,      0],
2344         [    2,     0,      0, -1 + I]])
2345 
2346         If the matrix does not have 4 rows an AttributeError will be raised
2347         because this property is only defined for matrices with 4 rows.
2348 
2349         >>> Matrix(eye(2)).D
2350         Traceback (most recent call last):
2351         ...
2352         AttributeError: Matrix has no attribute D.
2353 
2354         See Also
2355         ========
2356 
2357         conjugate: By-element conjugation
2358         H: Hermite conjugation
2359         """
2360         from sympy.physics.matrices import mgamma
2361         if self.rows != 4:
2362             # In Python 3.2, properties can only return an AttributeError
2363             # so we can't raise a ShapeError -- see commit which added the
2364             # first line of this inline comment. Also, there is no need
2365             # for a message since MatrixBase will raise the AttributeError
2366             raise AttributeError
2367         return self.H * mgamma(0)
2368 
2369     def diagonal_solve(self, rhs):
2370         """Solves Ax = B efficiently, where A is a diagonal Matrix,
2371         with non-zero diagonal entries.
2372 
2373         Examples
2374         ========
2375 
2376         >>> from sympy.matrices import Matrix, eye
2377         >>> A = eye(2)*2
2378         >>> B = Matrix([[1, 2], [3, 4]])
2379         >>> A.diagonal_solve(B) == B/2
2380         True
2381 
2382         See Also
2383         ========
2384 
2385         lower_triangular_solve
2386         upper_triangular_solve
2387         gauss_jordan_solve
2388         cholesky_solve
2389         LDLsolve
2390         LUsolve
2391         QRsolve
2392         pinv_solve
2393         """
2394         if not self.is_diagonal:
2395             raise TypeError("Matrix should be diagonal")
2396         if rhs.rows != self.rows:
2397             raise TypeError("Size mis-match")
2398         return self._diagonal_solve(rhs)
2399 
2400     def dot(self, b):
2401         """Return the dot product of Matrix self and b relaxing the condition
2402         of compatible dimensions: if either the number of rows or columns are
2403         the same as the length of b then the dot product is returned. If self
2404         is a row or column vector, a scalar is returned. Otherwise, a list
2405         of results is returned (and in that case the number of columns in self
2406         must match the length of b).
2407 
2408         Examples
2409         ========
2410 
2411         >>> from sympy import Matrix
2412         >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
2413         >>> v = [1, 1, 1]
2414         >>> M.row(0).dot(v)
2415         6
2416         >>> M.col(0).dot(v)
2417         12
2418         >>> M.dot(v)
2419         [6, 15, 24]
2420 
2421         See Also
2422         ========
2423 
2424         cross
2425         multiply
2426         multiply_elementwise
2427         """
2428         from .dense import Matrix
2429 
2430         if not isinstance(b, MatrixBase):
2431             if is_sequence(b):
2432                 if len(b) != self.cols and len(b) != self.rows:
2433                     raise ShapeError(
2434                         "Dimensions incorrect for dot product: %s, %s" % (
2435                             self.shape, len(b)))
2436                 return self.dot(Matrix(b))
2437             else:
2438                 raise TypeError(
2439                     "`b` must be an ordered iterable or Matrix, not %s." %
2440                     type(b))
2441 
2442         mat = self
2443         if mat.cols == b.rows:
2444             if b.cols != 1:
2445                 mat = mat.T
2446                 b = b.T
2447             prod = flatten((mat * b).tolist())
2448             if len(prod) == 1:
2449                 return prod[0]
2450             return prod
2451         if mat.cols == b.cols:
2452             return mat.dot(b.T)
2453         elif mat.rows == b.rows:
2454             return mat.T.dot(b)
2455         else:
2456             raise ShapeError("Dimensions incorrect for dot product: %s, %s" % (
2457                 self.shape, b.shape))
2458 
2459     def dual(self):
2460         """Returns the dual of a matrix, which is:
2461 
2462         `(1/2)*levicivita(i, j, k, l)*M(k, l)` summed over indices `k` and `l`
2463 
2464         Since the levicivita method is anti_symmetric for any pairwise
2465         exchange of indices, the dual of a symmetric matrix is the zero
2466         matrix. Strictly speaking the dual defined here assumes that the
2467         'matrix' `M` is a contravariant anti_symmetric second rank tensor,
2468         so that the dual is a covariant second rank tensor.
2469 
2470         """
2471         from sympy import LeviCivita
2472         from sympy.matrices import zeros
2473 
2474         M, n = self[:, :], self.rows
2475         work = zeros(n)
2476         if self.is_symmetric():
2477             return work
2478 
2479         for i in range(1, n):
2480             for j in range(1, n):
2481                 acum = 0
2482                 for k in range(1, n):
2483                     acum += LeviCivita(i, j, 0, k) * M[0, k]
2484                 work[i, j] = acum
2485                 work[j, i] = -acum
2486 
2487         for l in range(1, n):
2488             acum = 0
2489             for a in range(1, n):
2490                 for b in range(1, n):
2491                     acum += LeviCivita(0, l, a, b) * M[a, b]
2492             acum /= 2
2493             work[0, l] = -acum
2494             work[l, 0] = acum
2495 
2496         return work
2497 
2498     def exp(self):
2499         """Return the exponentiation of a square matrix."""
2500         if not self.is_square:
2501             raise NonSquareMatrixError(
2502                 "Exponentiation is valid only for square matrices")
2503         try:
2504             P, J = self.jordan_form()
2505             cells = J.get_diag_blocks()
2506         except MatrixError:
2507             raise NotImplementedError(
2508                 "Exponentiation is implemented only for matrices for which the Jordan normal form can be computed")
2509 
2510         def _jblock_exponential(b):
2511             # This function computes the matrix exponential for one single Jordan block
2512             nr = b.rows
2513             l = b[0, 0]
2514             if nr == 1:
2515                 res = exp(l)
2516             else:
2517                 from sympy import eye
2518                 # extract the diagonal part
2519                 d = b[0, 0] * eye(nr)
2520                 # and the nilpotent part
2521                 n = b - d
2522                 # compute its exponential
2523                 nex = eye(nr)
2524                 for i in range(1, nr):
2525                     nex = nex + n ** i / factorial(i)
2526                 # combine the two parts
2527                 res = exp(b[0, 0]) * nex
2528             return (res)
2529 
2530         blocks = list(map(_jblock_exponential, cells))
2531         from sympy.matrices import diag
2532         from sympy import re
2533         eJ = diag(*blocks)
2534         # n = self.rows
2535         ret = P * eJ * P.inv()
2536         if all(value.is_real for value in self.values()):
2537             return type(self)(re(ret))
2538         else:
2539             return type(self)(ret)
2540 
2541     def gauss_jordan_solve(self, b, freevar=False):
2542         """
2543         Solves Ax = b using Gauss Jordan elimination.
2544 
2545         There may be zero, one, or infinite solutions.  If one solution
2546         exists, it will be returned. If infinite solutions exist, it will
2547         be returned parametrically. If no solutions exist, It will throw
2548         ValueError.
2549 
2550         Parameters
2551         ==========
2552 
2553         b : Matrix
2554             The right hand side of the equation to be solved for.  Must have
2555             the same number of rows as matrix A.
2556 
2557         freevar : List
2558             If the system is underdetermined (e.g. A has more columns than
2559             rows), infinite solutions are possible, in terms of arbitrary
2560             values of free variables. Then the index of the free variables
2561             in the solutions (column Matrix) will be returned by freevar, if
2562             the flag `freevar` is set to `True`.
2563 
2564         Returns
2565         =======
2566 
2567         x : Matrix
2568             The matrix that will satisfy Ax = B.  Will have as many rows as
2569             matrix A has columns, and as many columns as matrix B.
2570 
2571         params : Matrix
2572             If the system is underdetermined (e.g. A has more columns than
2573             rows), infinite solutions are possible, in terms of arbitrary
2574             parameters. These arbitrary parameters are returned as params
2575             Matrix.
2576 
2577         Examples
2578         ========
2579 
2580         >>> from sympy import Matrix
2581         >>> A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])
2582         >>> b = Matrix([7, 12, 4])
2583         >>> sol, params = A.gauss_jordan_solve(b)
2584         >>> sol
2585         Matrix([
2586         [-2*tau0 - 3*tau1 + 2],
2587         [                 tau0],
2588         [           2*tau1 + 5],
2589         [                 tau1]])
2590         >>> params
2591         Matrix([
2592         [tau0],
2593         [tau1]])
2594 
2595         >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
2596         >>> b = Matrix([3, 6, 9])
2597         >>> sol, params = A.gauss_jordan_solve(b)
2598         >>> sol
2599         Matrix([
2600         [-1],
2601         [ 2],
2602         [ 0]])
2603         >>> params
2604         Matrix(0, 1, [])
2605 
2606         See Also
2607         ========
2608 
2609         lower_triangular_solve
2610         upper_triangular_solve
2611         cholesky_solve
2612         diagonal_solve
2613         LDLsolve
2614         LUsolve
2615         QRsolve
2616         pinv
2617 
2618         References
2619         ==========
2620 
2621         .. [1] http://en.wikipedia.org/wiki/Gaussian_elimination
2622 
2623         """
2624         from sympy.matrices import Matrix, zeros
2625 
2626         aug = self.hstack(self.copy(), b.copy())
2627         row, col = aug[:, :-1].shape
2628 
2629         # solve by reduced row echelon form
2630         A, pivots = aug.rref(simplify=True)
2631         A, v = A[:, :-1], A[:, -1]
2632         pivots = list(filter(lambda p: p < col, pivots))
2633         rank = len(pivots)
2634 
2635         # Bring to block form
2636         permutation = Matrix(range(col)).T
2637         A = A.vstack(A, permutation)
2638 
2639         for i, c in enumerate(pivots):
2640             A.col_swap(i, c)
2641 
2642         A, permutation = A[:-1, :], A[-1, :]
2643 
2644         # check for existence of solutions
2645         # rank of aug Matrix should be equal to rank of coefficient matrix
2646         if not v[rank:, 0].is_zero:
2647             raise ValueError("Linear system has no solution")
2648 
2649         # Get index of free symbols (free parameters)
2650         free_var_index = permutation[
2651                          len(pivots):]  # non-pivots columns are free variables
2652 
2653         # Free parameters
2654         # what are current unnumbered free symbol names?
2655         name = _uniquely_named_symbol('tau', aug,
2656             compare=lambda i: str(i).rstrip('1234567890')).name
2657         gen = numbered_symbols(name)
2658         tau = Matrix([next(gen) for k in range(col - rank)]).reshape(col - rank, 1)
2659 
2660         # Full parametric solution
2661         V = A[:rank, rank:]
2662         vt = v[:rank, 0]
2663         free_sol = tau.vstack(vt - V * tau, tau)
2664 
2665         # Undo permutation
2666         sol = zeros(col, 1)
2667         for k, v in enumerate(free_sol):
2668             sol[permutation[k], 0] = v
2669 
2670         if freevar:
2671             return sol, tau, free_var_index
2672         else:
2673             return sol, tau
2674 
2675     def inv_mod(self, m):
2676         r"""
2677         Returns the inverse of the matrix `K` (mod `m`), if it exists.
2678 
2679         Method to find the matrix inverse of `K` (mod `m`) implemented in this function:
2680 
2681         * Compute `\mathrm{adj}(K) = \mathrm{cof}(K)^t`, the adjoint matrix of `K`.
2682 
2683         * Compute `r = 1/\mathrm{det}(K) \pmod m`.
2684 
2685         * `K^{-1} = r\cdot \mathrm{adj}(K) \pmod m`.
2686 
2687         Examples
2688         ========
2689 
2690         >>> from sympy import Matrix
2691         >>> A = Matrix(2, 2, [1, 2, 3, 4])
2692         >>> A.inv_mod(5)
2693         Matrix([
2694         [3, 1],
2695         [4, 2]])
2696         >>> A.inv_mod(3)
2697         Matrix([
2698         [1, 1],
2699         [0, 1]])
2700 
2701         """
2702         from sympy.ntheory import totient
2703         if not self.is_square:
2704             raise NonSquareMatrixError()
2705         N = self.cols
2706         phi = totient(m)
2707         det_K = self.det()
2708         if gcd(det_K, m) != 1:
2709             raise ValueError('Matrix is not invertible (mod %d)' % m)
2710         det_inv = pow(int(det_K), int(phi - 1), int(m))
2711         K_adj = self.adjugate()
2712         K_inv = self.__class__(N, N,
2713                                [det_inv * K_adj[i, j] % m for i in range(N) for
2714                                 j in range(N)])
2715         return K_inv
2716 
2717     def inverse_ADJ(self, iszerofunc=_iszero):
2718         """Calculates the inverse using the adjugate matrix and a determinant.
2719 
2720         See Also
2721         ========
2722 
2723         inv
2724         inverse_LU
2725         inverse_GE
2726         """
2727         if not self.is_square:
2728             raise NonSquareMatrixError("A Matrix must be square to invert.")
2729 
2730         d = self.det(method='berkowitz')
2731         zero = d.equals(0)
2732         if zero is None:
2733             # if equals() can't decide, will rref be able to?
2734             ok = self.rref(simplify=True)[0]
2735             zero = any(iszerofunc(ok[j, j]) for j in range(ok.rows))
2736         if zero:
2737             raise ValueError("Matrix det == 0; not invertible.")
2738 
2739         return self.adjugate() / d
2740 
2741     def inverse_GE(self, iszerofunc=_iszero):
2742         """Calculates the inverse using Gaussian elimination.
2743 
2744         See Also
2745         ========
2746 
2747         inv
2748         inverse_LU
2749         inverse_ADJ
2750         """
2751         from .dense import Matrix
2752         if not self.is_square:
2753             raise NonSquareMatrixError("A Matrix must be square to invert.")
2754 
2755         big = Matrix.hstack(self.as_mutable(), Matrix.eye(self.rows))
2756         red = big.rref(iszerofunc=iszerofunc, simplify=True)[0]
2757         if any(iszerofunc(red[j, j]) for j in range(red.rows)):
2758             raise ValueError("Matrix det == 0; not invertible.")
2759 
2760         return self._new(red[:, big.rows:])
2761 
2762     def inverse_LU(self, iszerofunc=_iszero):
2763         """Calculates the inverse using LU decomposition.
2764 
2765         See Also
2766         ========
2767 
2768         inv
2769         inverse_GE
2770         inverse_ADJ
2771         """
2772         if not self.is_square:
2773             raise NonSquareMatrixError()
2774 
2775         ok = self.rref(simplify=True)[0]
2776         if any(iszerofunc(ok[j, j]) for j in range(ok.rows)):
2777             raise ValueError("Matrix det == 0; not invertible.")
2778 
2779         return self.LUsolve(self.eye(self.rows), iszerofunc=_iszero)
2780 
2781     def inv(self, method=None, **kwargs):
2782         """
2783         Return the inverse of a matrix.
2784 
2785         CASE 1: If the matrix is a dense matrix.
2786 
2787         Return the matrix inverse using the method indicated (default
2788         is Gauss elimination).
2789 
2790         Parameters
2791         ==========
2792 
2793         method : ('GE', 'LU', or 'ADJ')
2794 
2795         Notes
2796         =====
2797 
2798         According to the ``method`` keyword, it calls the appropriate method:
2799 
2800           GE .... inverse_GE(); default
2801           LU .... inverse_LU()
2802           ADJ ... inverse_ADJ()
2803 
2804         See Also
2805         ========
2806 
2807         inverse_LU
2808         inverse_GE
2809         inverse_ADJ
2810 
2811         Raises
2812         ------
2813         ValueError
2814             If the determinant of the matrix is zero.
2815 
2816         CASE 2: If the matrix is a sparse matrix.
2817 
2818         Return the matrix inverse using Cholesky or LDL (default).
2819 
2820         kwargs
2821         ======
2822 
2823         method : ('CH', 'LDL')
2824 
2825         Notes
2826         =====
2827 
2828         According to the ``method`` keyword, it calls the appropriate method:
2829 
2830           LDL ... inverse_LDL(); default
2831           CH .... inverse_CH()
2832 
2833         Raises
2834         ------
2835         ValueError
2836             If the determinant of the matrix is zero.
2837 
2838         """
2839         if not self.is_square:
2840             raise NonSquareMatrixError()
2841         if method is not None:
2842             kwargs['method'] = method
2843         return self._eval_inverse(**kwargs)
2844 
2845     def is_nilpotent(self):
2846         """Checks if a matrix is nilpotent.
2847 
2848         A matrix B is nilpotent if for some integer k, B**k is
2849         a zero matrix.
2850 
2851         Examples
2852         ========
2853 
2854         >>> from sympy import Matrix
2855         >>> a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]])
2856         >>> a.is_nilpotent()
2857         True
2858 
2859         >>> a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]])
2860         >>> a.is_nilpotent()
2861         False
2862         """
2863         if not self:
2864             return True
2865         if not self.is_square:
2866             raise NonSquareMatrixError(
2867                 "Nilpotency is valid only for square matrices")
2868         x = _uniquely_named_symbol('x', self)
2869         p = self.charpoly(x)
2870         if p.args[0] == x ** self.rows:
2871             return True
2872         return False
2873 
2874     def key2bounds(self, keys):
2875         """Converts a key with potentially mixed types of keys (integer and slice)
2876         into a tuple of ranges and raises an error if any index is out of self's
2877         range.
2878 
2879         See Also
2880         ========
2881 
2882         key2ij
2883         """
2884 
2885         islice, jslice = [isinstance(k, slice) for k in keys]
2886         if islice:
2887             if not self.rows:
2888                 rlo = rhi = 0
2889             else:
2890                 rlo, rhi = keys[0].indices(self.rows)[:2]
2891         else:
2892             rlo = a2idx(keys[0], self.rows)
2893             rhi = rlo + 1
2894         if jslice:
2895             if not self.cols:
2896                 clo = chi = 0
2897             else:
2898                 clo, chi = keys[1].indices(self.cols)[:2]
2899         else:
2900             clo = a2idx(keys[1], self.cols)
2901             chi = clo + 1
2902         return rlo, rhi, clo, chi
2903 
2904     def key2ij(self, key):
2905         """Converts key into canonical form, converting integers or indexable
2906         items into valid integers for self's range or returning slices
2907         unchanged.
2908 
2909         See Also
2910         ========
2911 
2912         key2bounds
2913         """
2914         if is_sequence(key):
2915             if not len(key) == 2:
2916                 raise TypeError('key must be a sequence of length 2')
2917             return [a2idx(i, n) if not isinstance(i, slice) else i
2918                     for i, n in zip(key, self.shape)]
2919         elif isinstance(key, slice):
2920             return key.indices(len(self))[:2]
2921         else:
2922             return divmod(a2idx(key, len(self)), self.cols)
2923 
2924     def LDLdecomposition(self):
2925         """Returns the LDL Decomposition (L, D) of matrix A,
2926         such that L * D * L.H == A
2927         This method eliminates the use of square root.
2928         Further this ensures that all the diagonal entries of L are 1.
2929         A must be a Hermitian positive-definite matrix.
2930 
2931         Examples
2932         ========
2933 
2934         >>> from sympy.matrices import Matrix, eye
2935         >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
2936         >>> L, D = A.LDLdecomposition()
2937         >>> L
2938         Matrix([
2939         [   1,   0, 0],
2940         [ 3/5,   1, 0],
2941         [-1/5, 1/3, 1]])
2942         >>> D
2943         Matrix([
2944         [25, 0, 0],
2945         [ 0, 9, 0],
2946         [ 0, 0, 9]])
2947         >>> L * D * L.T * A.inv() == eye(A.rows)
2948         True
2949 
2950         The matrix can have complex entries:
2951 
2952         >>> from sympy import I
2953         >>> A = Matrix(((9, 3*I), (-3*I, 5)))
2954         >>> L, D = A.LDLdecomposition()
2955         >>> L
2956         Matrix([
2957         [   1, 0],
2958         [-I/3, 1]])
2959         >>> D
2960         Matrix([
2961         [9, 0],
2962         [0, 4]])
2963         >>> L*D*L.H == A
2964         True
2965 
2966         See Also
2967         ========
2968 
2969         cholesky
2970         LUdecomposition
2971         QRdecomposition
2972         """
2973         if not self.is_square:
2974             raise NonSquareMatrixError("Matrix must be square.")
2975         if not self.is_hermitian:
2976             raise ValueError("Matrix must be Hermitian.")
2977         return self._LDLdecomposition()
2978 
2979     def LDLsolve(self, rhs):
2980         """Solves Ax = B using LDL decomposition,
2981         for a general square and non-singular matrix.
2982 
2983         For a non-square matrix with rows > cols,
2984         the least squares solution is returned.
2985 
2986         Examples
2987         ========
2988 
2989         >>> from sympy.matrices import Matrix, eye
2990         >>> A = eye(2)*2
2991         >>> B = Matrix([[1, 2], [3, 4]])
2992         >>> A.LDLsolve(B) == B/2
2993         True
2994 
2995         See Also
2996         ========
2997 
2998         LDLdecomposition
2999         lower_triangular_solve
3000         upper_triangular_solve
3001         gauss_jordan_solve
3002         cholesky_solve
3003         diagonal_solve
3004         LUsolve
3005         QRsolve
3006         pinv_solve
3007         """
3008         if self.is_hermitian:
3009             L, D = self.LDLdecomposition()
3010         elif self.rows >= self.cols:
3011             L, D = (self.H * self).LDLdecomposition()
3012             rhs = self.H * rhs
3013         else:
3014             raise NotImplementedError('Under-determined System. '
3015                                       'Try M.gauss_jordan_solve(rhs)')
3016         Y = L._lower_triangular_solve(rhs)
3017         Z = D._diagonal_solve(Y)
3018         return (L.H)._upper_triangular_solve(Z)
3019 
3020     def lower_triangular_solve(self, rhs):
3021         """Solves Ax = B, where A is a lower triangular matrix.
3022 
3023         See Also
3024         ========
3025 
3026         upper_triangular_solve
3027         gauss_jordan_solve
3028         cholesky_solve
3029         diagonal_solve
3030         LDLsolve
3031         LUsolve
3032         QRsolve
3033         pinv_solve
3034         """
3035 
3036         if not self.is_square:
3037             raise NonSquareMatrixError("Matrix must be square.")
3038         if rhs.rows != self.rows:
3039             raise ShapeError("Matrices size mismatch.")
3040         if not self.is_lower:
3041             raise ValueError("Matrix must be lower triangular.")
3042         return self._lower_triangular_solve(rhs)
3043 
3044     def LUdecomposition(self,
3045                         iszerofunc=_iszero,
3046                         simpfunc=None,
3047                         rankcheck=False):
3048         """Returns (L, U, perm) where L is a lower triangular matrix with unit
3049         diagonal, U is an upper triangular matrix, and perm is a list of row
3050         swap index pairs. If A is the original matrix, then
3051         A = (L*U).permuteBkwd(perm), and the row permutation matrix P such
3052         that P*A = L*U can be computed by P=eye(A.row).permuteFwd(perm).
3053 
3054         See documentation for LUCombined for details about the keyword argument
3055         rankcheck, iszerofunc, and simpfunc.
3056 
3057         Examples
3058         ========
3059 
3060         >>> from sympy import Matrix
3061         >>> a = Matrix([[4, 3], [6, 3]])
3062         >>> L, U, _ = a.LUdecomposition()
3063         >>> L
3064         Matrix([
3065         [  1, 0],
3066         [3/2, 1]])
3067         >>> U
3068         Matrix([
3069         [4,    3],
3070         [0, -3/2]])
3071 
3072         See Also
3073         ========
3074 
3075         cholesky
3076         LDLdecomposition
3077         QRdecomposition
3078         LUdecomposition_Simple
3079         LUdecompositionFF
3080         LUsolve
3081         """
3082 
3083         combined, p = self.LUdecomposition_Simple(iszerofunc=iszerofunc,
3084                                                   simpfunc=simpfunc,
3085                                                   rankcheck=rankcheck)
3086 
3087         # L is lower triangular self.rows x self.rows
3088         # U is upper triangular self.rows x self.cols
3089         # L has unit diagonal. For each column in combined, the subcolumn
3090         # below the diagonal of combined is shared by L.
3091         # If L has more columns than combined, then the remaining subcolumns
3092         # below the diagonal of L are zero.
3093         # The upper triangular portion of L and combined are equal.
3094         def entry_L(i, j):
3095             if i < j:
3096                 # Super diagonal entry
3097                 return S.Zero
3098             elif i == j:
3099                 return S.One
3100             elif j < combined.cols:
3101                 return combined[i, j]
3102             # Subdiagonal entry of L with no corresponding
3103             # entry in combined
3104             return S.Zero
3105 
3106         def entry_U(i, j):
3107             return S.Zero if i > j else combined[i, j]
3108 
3109         L = self._new(combined.rows, combined.rows, entry_L)
3110         U = self._new(combined.rows, combined.cols, entry_U)
3111 
3112         return L, U, p
3113 
3114 
3115     def LUdecomposition_Simple(self,
3116                                iszerofunc=_iszero,
3117                                simpfunc=None,
3118                                rankcheck=False):
3119         """Compute an lu decomposition of m x n matrix A, where P*A = L*U
3120 
3121         * L is m x m lower triangular with unit diagonal
3122         * U is m x n upper triangular
3123         * P is an m x m permutation matrix
3124 
3125         Returns an m x n matrix lu, and an m element list perm where each
3126         element of perm is a pair of row exchange indices.
3127 
3128         The factors L and U are stored in lu as follows:
3129         The subdiagonal elements of L are stored in the subdiagonal elements
3130         of lu, that is lu[i, j] = L[i, j] whenever i > j.
3131         The elements on the diagonal of L are all 1, and are not explicitly
3132         stored.
3133         U is stored in the upper triangular portion of lu, that is
3134         lu[i ,j] = U[i, j] whenever i <= j.
3135         The output matrix can be visualized as:
3136 
3137             Matrix([
3138                 [u, u, u, u],
3139                 [l, u, u, u],
3140                 [l, l, u, u],
3141                 [l, l, l, u]])
3142 
3143         where l represents a subdiagonal entry of the L factor, and u
3144         represents an entry from the upper triangular entry of the U
3145         factor.
3146 
3147         perm is a list row swap index pairs such that if A is the original
3148         matrix, then A = (L*U).permuteBkwd(perm), and the row permutation
3149         matrix P such that ``P*A = L*U`` can be computed by
3150         ``P=eye(A.row).permuteFwd(perm)``.
3151 
3152         The keyword argument rankcheck determines if this function raises a
3153         ValueError when passed a matrix whose rank is strictly less than
3154         min(num rows, num cols). The default behavior is to decompose a rank
3155         deficient matrix. Pass rankcheck=True to raise a
3156         ValueError instead. (This mimics the previous behavior of this function).
3157 
3158         The keyword arguments iszerofunc and simpfunc are used by the pivot
3159         search algorithm.
3160         iszerofunc is a callable that returns a boolean indicating if its
3161         input is zero, or None if it cannot make the determination.
3162         simpfunc is a callable that simplifies its input.
3163         The default is simpfunc=None, which indicate that the pivot search
3164         algorithm should not attempt to simplify any candidate pivots.
3165         If simpfunc fails to simplify its input, then it must return its input
3166         instead of a copy.
3167 
3168         When a matrix contains symbolic entries, the pivot search algorithm
3169         differs from the case where every entry can be categorized as zero or
3170         nonzero.
3171         The algorithm searches column by column through the submatrix whose
3172         top left entry coincides with the pivot position.
3173         If it exists, the pivot is the first entry in the current search
3174         column that iszerofunc guarantees is nonzero.
3175         If no such candidate exists, then each candidate pivot is simplified
3176         if simpfunc is not None.
3177         The search is repeated, with the difference that a candidate may be
3178         the pivot if ``iszerofunc()`` cannot guarantee that it is nonzero.
3179         In the second search the pivot is the first candidate that
3180         iszerofunc can guarantee is nonzero.
3181         If no such candidate exists, then the pivot is the first candidate
3182         for which iszerofunc returns None.
3183         If no such candidate exists, then the search is repeated in the next
3184         column to the right.
3185         The pivot search algorithm differs from the one in `rref()`, which
3186         relies on ``_find_reasonable_pivot()``.
3187         Future versions of ``LUdecomposition_simple()`` may use
3188         ``_find_reasonable_pivot()``.
3189 
3190         See Also
3191         ========
3192 
3193         LUdecomposition
3194         LUdecompositionFF
3195         LUsolve
3196         """
3197 
3198         if rankcheck:
3199             # https://github.com/sympy/sympy/issues/9796
3200             pass
3201 
3202         if self.rows == 0 or self.cols == 0:
3203             # Define LU decomposition of a matrix with no entries as a matrix
3204             # of the same dimensions with all zero entries.
3205             return self.zeros(self.rows, self.cols), []
3206 
3207         lu = self.as_mutable()
3208         row_swaps = []
3209 
3210         pivot_col = 0
3211         for pivot_row in range(0, lu.rows - 1):
3212             # Search for pivot. Prefer entry that iszeropivot determines
3213             # is nonzero, over entry that iszeropivot cannot guarantee
3214             # is  zero.
3215             # XXX `_find_reasonable_pivot` uses slow zero testing. Blocked by bug #10279
3216             # Future versions of LUdecomposition_simple can pass iszerofunc and simpfunc
3217             # to _find_reasonable_pivot().
3218             # In pass 3 of _find_reasonable_pivot(), the predicate in `if x.equals(S.Zero):`
3219             # calls sympy.simplify(), and not the simplification function passed in via
3220             # the keyword argument simpfunc.
3221 
3222             iszeropivot = True
3223             while pivot_col != self.cols and iszeropivot:
3224                 sub_col = (lu[r, pivot_col] for r in range(pivot_row, self.rows))
3225                 pivot_row_offset, pivot_value, is_assumed_non_zero, ind_simplified_pairs =\
3226                     _find_reasonable_pivot_naive(sub_col, iszerofunc, simpfunc)
3227                 iszeropivot = pivot_value is None
3228                 if iszeropivot:
3229                     # All candidate pivots in this column are zero.
3230                     # Proceed to next column.
3231                     pivot_col += 1
3232 
3233             if rankcheck and pivot_col != pivot_row:
3234                 # All entries including and below the pivot position are
3235                 # zero, which indicates that the rank of the matrix is
3236                 # strictly less than min(num rows, num cols)
3237                 # Mimic behavior of previous implementation, by throwing a
3238                 # ValueError.
3239                 raise ValueError("Rank of matrix is strictly less than"
3240                                  " number of rows or columns."
3241                                  " Pass keyword argument"
3242                                  " rankcheck=False to compute"
3243                                  " the LU decomposition of this matrix.")
3244 
3245             candidate_pivot_row = None if pivot_row_offset is None else pivot_row + pivot_row_offset
3246 
3247             if candidate_pivot_row is None and iszeropivot:
3248                 # If candidate_pivot_row is None and iszeropivot is True
3249                 # after pivot search has completed, then the submatrix
3250                 # below and to the right of (pivot_row, pivot_col) is
3251                 # all zeros, indicating that Gaussian elimination is
3252                 # complete.
3253                 return lu, row_swaps
3254 
3255             # Update entries simplified during pivot search.
3256             for offset, val in ind_simplified_pairs:
3257                 lu[pivot_row + offset, pivot_col] = val
3258 
3259             if pivot_row != candidate_pivot_row:
3260                 # Row swap book keeping:
3261                 # Record which rows were swapped.
3262                 # Update stored portion of L factor by multiplying L on the
3263                 # left and right with the current permutation.
3264                 # Swap rows of U.
3265                 row_swaps.append([pivot_row, candidate_pivot_row])
3266 
3267                 # Update L.
3268                 lu[pivot_row, 0:pivot_row], lu[candidate_pivot_row, 0:pivot_row] = \
3269                     lu[candidate_pivot_row, 0:pivot_row], lu[pivot_row, 0:pivot_row]
3270 
3271                 # Swap pivot row of U with candidate pivot row.
3272                 lu[pivot_row, pivot_col:lu.cols], lu[candidate_pivot_row, pivot_col:lu.cols] = \
3273                     lu[candidate_pivot_row, pivot_col:lu.cols], lu[pivot_row, pivot_col:lu.cols]
3274 
3275             # Introduce zeros below the pivot by adding a multiple of the
3276             # pivot row to a row under it, and store the result in the
3277             # row under it.
3278             # Only entries in the target row whose index is greater than
3279             # start_col may be nonzero.
3280             start_col = pivot_col + 1
3281             for row in range(pivot_row + 1, lu.rows):
3282                 # Store factors of L in the subcolumn below
3283                 # (pivot_row, pivot_row).
3284                 lu[row, pivot_row] =\
3285                     lu[row, pivot_col]/lu[pivot_row, pivot_col]
3286 
3287                 # Form the linear combination of the pivot row and the current
3288                 # row below the pivot row that zeros the entries below the pivot.
3289                 # Employing slicing instead of a loop here raises
3290                 # NotImplementedError: Cannot add Zero to MutableSparseMatrix
3291                 # in sympy/matrices/tests/test_sparse.py.
3292                 # c = pivot_row + 1 if pivot_row == pivot_col else pivot_col
3293                 for c in range(start_col, lu.cols):
3294                     lu[row, c] = lu[row, c] - lu[row, pivot_row]*lu[pivot_row, c]
3295 
3296             if pivot_row != pivot_col:
3297                 # matrix rank < min(num rows, num cols),
3298                 # so factors of L are not stored directly below the pivot.
3299                 # These entries are zero by construction, so don't bother
3300                 # computing them.
3301                 for row in range(pivot_row + 1, lu.rows):
3302                     lu[row, pivot_col] = S.Zero
3303 
3304             pivot_col += 1
3305             if pivot_col == lu.cols:
3306                 # All candidate pivots are zero implies that Gaussian
3307                 # elimination is complete.
3308                 return lu, row_swaps
3309 
3310         return lu, row_swaps
3311 
3312     def LUdecompositionFF(self):
3313         """Compute a fraction-free LU decomposition.
3314 
3315         Returns 4 matrices P, L, D, U such that PA = L D**-1 U.
3316         If the elements of the matrix belong to some integral domain I, then all
3317         elements of L, D and U are guaranteed to belong to I.
3318 
3319         **Reference**
3320             - W. Zhou & D.J. Jeffrey, "Fraction-free matrix factors: new forms
3321               for LU and QR factors". Frontiers in Computer Science in China,
3322               Vol 2, no. 1, pp. 67-80, 2008.
3323 
3324         See Also
3325         ========
3326 
3327         LUdecomposition
3328         LUdecomposition_Simple
3329         LUsolve
3330         """
3331         from sympy.matrices import SparseMatrix
3332         zeros = SparseMatrix.zeros
3333         eye = SparseMatrix.eye
3334 
3335         n, m = self.rows, self.cols
3336         U, L, P = self.as_mutable(), eye(n), eye(n)
3337         DD = zeros(n, n)
3338         oldpivot = 1
3339 
3340         for k in range(n - 1):
3341             if U[k, k] == 0:
3342                 for kpivot in range(k + 1, n):
3343                     if U[kpivot, k]:
3344                         break
3345                 else:
3346                     raise ValueError("Matrix is not full rank")
3347                 U[k, k:], U[kpivot, k:] = U[kpivot, k:], U[k, k:]
3348                 L[k, :k], L[kpivot, :k] = L[kpivot, :k], L[k, :k]
3349                 P[k, :], P[kpivot, :] = P[kpivot, :], P[k, :]
3350             L[k, k] = Ukk = U[k, k]
3351             DD[k, k] = oldpivot * Ukk
3352             for i in range(k + 1, n):
3353                 L[i, k] = Uik = U[i, k]
3354                 for j in range(k + 1, m):
3355                     U[i, j] = (Ukk * U[i, j] - U[k, j] * Uik) / oldpivot
3356                 U[i, k] = 0
3357             oldpivot = Ukk
3358         DD[n - 1, n - 1] = oldpivot
3359         return P, L, DD, U
3360 
3361     def LUsolve(self, rhs, iszerofunc=_iszero):
3362         """Solve the linear system Ax = rhs for x where A = self.
3363 
3364         This is for symbolic matrices, for real or complex ones use
3365         mpmath.lu_solve or mpmath.qr_solve.
3366 
3367         See Also
3368         ========
3369 
3370         lower_triangular_solve
3371         upper_triangular_solve
3372         gauss_jordan_solve
3373         cholesky_solve
3374         diagonal_solve
3375         LDLsolve
3376         QRsolve
3377         pinv_solve
3378         LUdecomposition
3379         """
3380         if rhs.rows != self.rows:
3381             raise ShapeError(
3382                 "`self` and `rhs` must have the same number of rows.")
3383 
3384         A, perm = self.LUdecomposition_Simple(iszerofunc=_iszero)
3385         n = self.rows
3386         b = rhs.permute_rows(perm).as_mutable()
3387         # forward substitution, all diag entries are scaled to 1
3388         for i in range(n):
3389             for j in range(i):
3390                 scale = A[i, j]
3391                 b.zip_row_op(i, j, lambda x, y: x - y * scale)
3392         # backward substitution
3393         for i in range(n - 1, -1, -1):
3394             for j in range(i + 1, n):
3395                 scale = A[i, j]
3396                 b.zip_row_op(i, j, lambda x, y: x - y * scale)
3397             scale = A[i, i]
3398             b.row_op(i, lambda x, _: x / scale)
3399         return rhs.__class__(b)
3400 
3401     def multiply(self, b):
3402         """Returns self*b
3403 
3404         See Also
3405         ========
3406 
3407         dot
3408         cross
3409         multiply_elementwise
3410         """
3411         return self * b
3412 
3413     def normalized(self):
3414         """Return the normalized version of ``self``.
3415 
3416         See Also
3417         ========
3418 
3419         norm
3420         """
3421         if self.rows != 1 and self.cols != 1:
3422             raise ShapeError("A Matrix must be a vector to normalize.")
3423         norm = self.norm()
3424         out = self.applyfunc(lambda i: i / norm)
3425         return out
3426 
3427     def norm(self, ord=None):
3428         """Return the Norm of a Matrix or Vector.
3429         In the simplest case this is the geometric size of the vector
3430         Other norms can be specified by the ord parameter
3431 
3432 
3433         =====  ============================  ==========================
3434         ord    norm for matrices             norm for vectors
3435         =====  ============================  ==========================
3436         None   Frobenius norm                2-norm
3437         'fro'  Frobenius norm                - does not exist
3438         inf    maximum row sum               max(abs(x))
3439         -inf   --                            min(abs(x))
3440         1      maximum column sum            as below
3441         -1     --                            as below
3442         2      2-norm (largest sing. value)  as below
3443         -2     smallest singular value       as below
3444         other  - does not exist              sum(abs(x)**ord)**(1./ord)
3445         =====  ============================  ==========================
3446 
3447         Examples
3448         ========
3449 
3450         >>> from sympy import Matrix, Symbol, trigsimp, cos, sin, oo
3451         >>> x = Symbol('x', real=True)
3452         >>> v = Matrix([cos(x), sin(x)])
3453         >>> trigsimp( v.norm() )
3454         1
3455         >>> v.norm(10)
3456         (sin(x)**10 + cos(x)**10)**(1/10)
3457         >>> A = Matrix([[1, 1], [1, 1]])
3458         >>> A.norm(1) # maximum sum of absolute values of A is 2
3459         2
3460         >>> A.norm(2) # Spectral norm (max of |Ax|/|x| under 2-vector-norm)
3461         2
3462         >>> A.norm(-2) # Inverse spectral norm (smallest singular value)
3463         0
3464         >>> A.norm() # Frobenius Norm
3465         2
3466         >>> A.norm(oo) # Infinity Norm
3467         2
3468         >>> Matrix([1, -2]).norm(oo)
3469         2
3470         >>> Matrix([-1, 2]).norm(-oo)
3471         1
3472 
3473         See Also
3474         ========
3475 
3476         normalized
3477         """
3478         # Row or Column Vector Norms
3479         vals = list(self.values()) or [0]
3480         if self.rows == 1 or self.cols == 1:
3481             if ord == 2 or ord is None:  # Common case sqrt(<x, x>)
3482                 return sqrt(Add(*(abs(i) ** 2 for i in vals)))
3483 
3484             elif ord == 1:  # sum(abs(x))
3485                 return Add(*(abs(i) for i in vals))
3486 
3487             elif ord == S.Infinity:  # max(abs(x))
3488                 return Max(*[abs(i) for i in vals])
3489 
3490             elif ord == S.NegativeInfinity:  # min(abs(x))
3491                 return Min(*[abs(i) for i in vals])
3492 
3493             # Otherwise generalize the 2-norm, Sum(x_i**ord)**(1/ord)
3494             # Note that while useful this is not mathematically a norm
3495             try:
3496                 return Pow(Add(*(abs(i) ** ord for i in vals)), S(1) / ord)
3497             except (NotImplementedError, TypeError):
3498                 raise ValueError("Expected order to be Number, Symbol, oo")
3499 
3500         # Matrix Norms
3501         else:
3502             if ord == 1:  # Maximum column sum
3503                 m = self.applyfunc(abs)
3504                 return Max(*[sum(m.col(i)) for i in range(m.cols)])
3505 
3506             elif ord == 2:  # Spectral Norm
3507                 # Maximum singular value
3508                 return Max(*self.singular_values())
3509 
3510             elif ord == -2:
3511                 # Minimum singular value
3512                 return Min(*self.singular_values())
3513 
3514             elif ord == S.Infinity:   # Infinity Norm - Maximum row sum
3515                 m = self.applyfunc(abs)
3516                 return Max(*[sum(m.row(i)) for i in range(m.rows)])
3517 
3518             elif (ord is None or isinstance(ord,
3519                                             string_types) and ord.lower() in
3520                 ['f', 'fro', 'frobenius', 'vector']):
3521                 # Reshape as vector and send back to norm function
3522                 return self.vec().norm(ord=2)
3523 
3524             else:
3525                 raise NotImplementedError("Matrix Norms under development")
3526 
3527     def pinv_solve(self, B, arbitrary_matrix=None):
3528         """Solve Ax = B using the Moore-Penrose pseudoinverse.
3529 
3530         There may be zero, one, or infinite solutions.  If one solution
3531         exists, it will be returned.  If infinite solutions exist, one will
3532         be returned based on the value of arbitrary_matrix.  If no solutions
3533         exist, the least-squares solution is returned.
3534 
3535         Parameters
3536         ==========
3537 
3538         B : Matrix
3539             The right hand side of the equation to be solved for.  Must have
3540             the same number of rows as matrix A.
3541         arbitrary_matrix : Matrix
3542             If the system is underdetermined (e.g. A has more columns than
3543             rows), infinite solutions are possible, in terms of an arbitrary
3544             matrix.  This parameter may be set to a specific matrix to use
3545             for that purpose; if so, it must be the same shape as x, with as
3546             many rows as matrix A has columns, and as many columns as matrix
3547             B.  If left as None, an appropriate matrix containing dummy
3548             symbols in the form of ``wn_m`` will be used, with n and m being
3549             row and column position of each symbol.
3550 
3551         Returns
3552         =======
3553 
3554         x : Matrix
3555             The matrix that will satisfy Ax = B.  Will have as many rows as
3556             matrix A has columns, and as many columns as matrix B.
3557 
3558         Examples
3559         ========
3560 
3561         >>> from sympy import Matrix
3562         >>> A = Matrix([[1, 2, 3], [4, 5, 6]])
3563         >>> B = Matrix([7, 8])
3564         >>> A.pinv_solve(B)
3565         Matrix([
3566         [ _w0_0/6 - _w1_0/3 + _w2_0/6 - 55/18],
3567         [-_w0_0/3 + 2*_w1_0/3 - _w2_0/3 + 1/9],
3568         [ _w0_0/6 - _w1_0/3 + _w2_0/6 + 59/18]])
3569         >>> A.pinv_solve(B, arbitrary_matrix=Matrix([0, 0, 0]))
3570         Matrix([
3571         [-55/18],
3572         [   1/9],
3573         [ 59/18]])
3574 
3575         See Also
3576         ========
3577 
3578         lower_triangular_solve
3579         upper_triangular_solve
3580         gauss_jordan_solve
3581         cholesky_solve
3582         diagonal_solve
3583         LDLsolve
3584         LUsolve
3585         QRsolve
3586         pinv
3587 
3588         Notes
3589         =====
3590 
3591         This may return either exact solutions or least squares solutions.
3592         To determine which, check ``A * A.pinv() * B == B``.  It will be
3593         True if exact solutions exist, and False if only a least-squares
3594         solution exists.  Be aware that the left hand side of that equation
3595         may need to be simplified to correctly compare to the right hand
3596         side.
3597 
3598         References
3599         ==========
3600 
3601         .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system
3602 
3603         """
3604         from sympy.matrices import eye
3605         A = self
3606         A_pinv = self.pinv()
3607         if arbitrary_matrix is None:
3608             rows, cols = A.cols, B.cols
3609             w = symbols('w:{0}_:{1}'.format(rows, cols), cls=Dummy)
3610             arbitrary_matrix = self.__class__(cols, rows, w).T
3611         return A_pinv * B + (eye(A.cols) - A_pinv * A) * arbitrary_matrix
3612 
3613     def pinv(self):
3614         """Calculate the Moore-Penrose pseudoinverse of the matrix.
3615 
3616         The Moore-Penrose pseudoinverse exists and is unique for any matrix.
3617         If the matrix is invertible, the pseudoinverse is the same as the
3618         inverse.
3619 
3620         Examples
3621         ========
3622 
3623         >>> from sympy import Matrix
3624         >>> Matrix([[1, 2, 3], [4, 5, 6]]).pinv()
3625         Matrix([
3626         [-17/18,  4/9],
3627         [  -1/9,  1/9],
3628         [ 13/18, -2/9]])
3629 
3630         See Also
3631         ========
3632 
3633         inv
3634         pinv_solve
3635 
3636         References
3637         ==========
3638 
3639         .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse
3640 
3641         """
3642         A = self
3643         AH = self.H
3644         # Trivial case: pseudoinverse of all-zero matrix is its transpose.
3645         if A.is_zero:
3646             return AH
3647         try:
3648             if self.rows >= self.cols:
3649                 return (AH * A).inv() * AH
3650             else:
3651                 return AH * (A * AH).inv()
3652         except ValueError:
3653             # Matrix is not full rank, so A*AH cannot be inverted.
3654             raise NotImplementedError('Rank-deficient matrices are not yet '
3655                                       'supported.')
3656 
3657     def print_nonzero(self, symb="X"):
3658         """Shows location of non-zero entries for fast shape lookup.
3659 
3660         Examples
3661         ========
3662 
3663         >>> from sympy.matrices import Matrix, eye
3664         >>> m = Matrix(2, 3, lambda i, j: i*3+j)
3665         >>> m
3666         Matrix([
3667         [0, 1, 2],
3668         [3, 4, 5]])
3669         >>> m.print_nonzero()
3670         [ XX]
3671         [XXX]
3672         >>> m = eye(4)
3673         >>> m.print_nonzero("x")
3674         [x   ]
3675         [ x  ]
3676         [  x ]
3677         [   x]
3678 
3679         """
3680         s = []
3681         for i in range(self.rows):
3682             line = []
3683             for j in range(self.cols):
3684                 if self[i, j] == 0:
3685                     line.append(" ")
3686                 else:
3687                     line.append(str(symb))
3688             s.append("[%s]" % ''.join(line))
3689         print('\n'.join(s))
3690 
3691     def project(self, v):
3692         """Return the projection of ``self`` onto the line containing ``v``.
3693 
3694         Examples
3695         ========
3696 
3697         >>> from sympy import Matrix, S, sqrt
3698         >>> V = Matrix([sqrt(3)/2, S.Half])
3699         >>> x = Matrix([[1, 0]])
3700         >>> V.project(x)
3701         Matrix([[sqrt(3)/2, 0]])
3702         >>> V.project(-x)
3703         Matrix([[sqrt(3)/2, 0]])
3704         """
3705         return v * (self.dot(v) / v.dot(v))
3706 
3707     def QRdecomposition(self):
3708         """Return Q, R where A = Q*R, Q is orthogonal and R is upper triangular.
3709 
3710         Examples
3711         ========
3712 
3713         This is the example from wikipedia:
3714 
3715         >>> from sympy import Matrix
3716         >>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])
3717         >>> Q, R = A.QRdecomposition()
3718         >>> Q
3719         Matrix([
3720         [ 6/7, -69/175, -58/175],
3721         [ 3/7, 158/175,   6/175],
3722         [-2/7,    6/35,  -33/35]])
3723         >>> R
3724         Matrix([
3725         [14,  21, -14],
3726         [ 0, 175, -70],
3727         [ 0,   0,  35]])
3728         >>> A == Q*R
3729         True
3730 
3731         QR factorization of an identity matrix:
3732 
3733         >>> A = Matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
3734         >>> Q, R = A.QRdecomposition()
3735         >>> Q
3736         Matrix([
3737         [1, 0, 0],
3738         [0, 1, 0],
3739         [0, 0, 1]])
3740         >>> R
3741         Matrix([
3742         [1, 0, 0],
3743         [0, 1, 0],
3744         [0, 0, 1]])
3745 
3746         See Also
3747         ========
3748 
3749         cholesky
3750         LDLdecomposition
3751         LUdecomposition
3752         QRsolve
3753         """
3754         cls = self.__class__
3755         mat = self.as_mutable()
3756 
3757         if not mat.rows >= mat.cols:
3758             raise MatrixError(
3759                 "The number of rows must be greater than columns")
3760         n = mat.rows
3761         m = mat.cols
3762         rank = n
3763         row_reduced = mat.rref()[0]
3764         for i in range(row_reduced.rows):
3765             if row_reduced.row(i).norm() == 0:
3766                 rank -= 1
3767         if not rank == mat.cols:
3768             raise MatrixError("The rank of the matrix must match the columns")
3769         Q, R = mat.zeros(n, m), mat.zeros(m)
3770         for j in range(m):  # for each column vector
3771             tmp = mat[:, j]  # take original v
3772             for i in range(j):
3773                 # subtract the project of mat on new vector
3774                 tmp -= Q[:, i] * mat[:, j].dot(Q[:, i])
3775                 tmp.expand()
3776             # normalize it
3777             R[j, j] = tmp.norm()
3778             Q[:, j] = tmp / R[j, j]
3779             if Q[:, j].norm() != 1:
3780                 raise NotImplementedError(
3781                     "Could not normalize the vector %d." % j)
3782             for i in range(j):
3783                 R[i, j] = Q[:, i].dot(mat[:, j])
3784         return cls(Q), cls(R)
3785 
3786     def QRsolve(self, b):
3787         """Solve the linear system 'Ax = b'.
3788 
3789         'self' is the matrix 'A', the method argument is the vector
3790         'b'.  The method returns the solution vector 'x'.  If 'b' is a
3791         matrix, the system is solved for each column of 'b' and the
3792         return value is a matrix of the same shape as 'b'.
3793 
3794         This method is slower (approximately by a factor of 2) but
3795         more stable for floating-point arithmetic than the LUsolve method.
3796         However, LUsolve usually uses an exact arithmetic, so you don't need
3797         to use QRsolve.
3798 
3799         This is mainly for educational purposes and symbolic matrices, for real
3800         (or complex) matrices use mpmath.qr_solve.
3801 
3802         See Also
3803         ========
3804 
3805         lower_triangular_solve
3806         upper_triangular_solve
3807         gauss_jordan_solve
3808         cholesky_solve
3809         diagonal_solve
3810         LDLsolve
3811         LUsolve
3812         pinv_solve
3813         QRdecomposition
3814         """
3815 
3816         Q, R = self.as_mutable().QRdecomposition()
3817         y = Q.T * b
3818 
3819         # back substitution to solve R*x = y:
3820         # We build up the result "backwards" in the vector 'x' and reverse it
3821         # only in the end.
3822         x = []
3823         n = R.rows
3824         for j in range(n - 1, -1, -1):
3825             tmp = y[j, :]
3826             for k in range(j + 1, n):
3827                 tmp -= R[j, k] * x[n - 1 - k]
3828             x.append(tmp / R[j, j])
3829         return self._new([row._mat for row in reversed(x)])
3830 
3831     def solve_least_squares(self, rhs, method='CH'):
3832         """Return the least-square fit to the data.
3833 
3834         By default the cholesky_solve routine is used (method='CH'); other
3835         methods of matrix inversion can be used. To find out which are
3836         available, see the docstring of the .inv() method.
3837 
3838         Examples
3839         ========
3840 
3841         >>> from sympy.matrices import Matrix, ones
3842         >>> A = Matrix([1, 2, 3])
3843         >>> B = Matrix([2, 3, 4])
3844         >>> S = Matrix(A.row_join(B))
3845         >>> S
3846         Matrix([
3847         [1, 2],
3848         [2, 3],
3849         [3, 4]])
3850 
3851         If each line of S represent coefficients of Ax + By
3852         and x and y are [2, 3] then S*xy is:
3853 
3854         >>> r = S*Matrix([2, 3]); r
3855         Matrix([
3856         [ 8],
3857         [13],
3858         [18]])
3859 
3860         But let's add 1 to the middle value and then solve for the
3861         least-squares value of xy:
3862 
3863         >>> xy = S.solve_least_squares(Matrix([8, 14, 18])); xy
3864         Matrix([
3865         [ 5/3],
3866         [10/3]])
3867 
3868         The error is given by S*xy - r:
3869 
3870         >>> S*xy - r
3871         Matrix([
3872         [1/3],
3873         [1/3],
3874         [1/3]])
3875         >>> _.norm().n(2)
3876         0.58
3877 
3878         If a different xy is used, the norm will be higher:
3879 
3880         >>> xy += ones(2, 1)/10
3881         >>> (S*xy - r).norm().n(2)
3882         1.5
3883 
3884         """
3885         if method == 'CH':
3886             return self.cholesky_solve(rhs)
3887         t = self.H
3888         return (t * self).inv(method=method) * t * rhs
3889 
3890     def solve(self, rhs, method='GE'):
3891         """Return solution to self*soln = rhs using given inversion method.
3892 
3893         For a list of possible inversion methods, see the .inv() docstring.
3894         """
3895 
3896         if not self.is_square:
3897             if self.rows < self.cols:
3898                 raise ValueError('Under-determined system. '
3899                                  'Try M.gauss_jordan_solve(rhs)')
3900             elif self.rows > self.cols:
3901                 raise ValueError('For over-determined system, M, having '
3902                                  'more rows than columns, try M.solve_least_squares(rhs).')
3903         else:
3904             return self.inv(method=method) * rhs
3905 
3906     def table(self, printer, rowstart='[', rowend=']', rowsep='\n',
3907               colsep=', ', align='right'):
3908         r"""
3909         String form of Matrix as a table.
3910 
3911         ``printer`` is the printer to use for on the elements (generally
3912         something like StrPrinter())
3913 
3914         ``rowstart`` is the string used to start each row (by default '[').
3915 
3916         ``rowend`` is the string used to end each row (by default ']').
3917 
3918         ``rowsep`` is the string used to separate rows (by default a newline).
3919 
3920         ``colsep`` is the string used to separate columns (by default ', ').
3921 
3922         ``align`` defines how the elements are aligned. Must be one of 'left',
3923         'right', or 'center'.  You can also use '<', '>', and '^' to mean the
3924         same thing, respectively.
3925 
3926         This is used by the string printer for Matrix.
3927 
3928         Examples
3929         ========
3930 
3931         >>> from sympy import Matrix
3932         >>> from sympy.printing.str import StrPrinter
3933         >>> M = Matrix([[1, 2], [-33, 4]])
3934         >>> printer = StrPrinter()
3935         >>> M.table(printer)
3936         '[  1, 2]\n[-33, 4]'
3937         >>> print(M.table(printer))
3938         [  1, 2]
3939         [-33, 4]
3940         >>> print(M.table(printer, rowsep=',\n'))
3941         [  1, 2],
3942         [-33, 4]
3943         >>> print('[%s]' % M.table(printer, rowsep=',\n'))
3944         [[  1, 2],
3945         [-33, 4]]
3946         >>> print(M.table(printer, colsep=' '))
3947         [  1 2]
3948         [-33 4]
3949         >>> print(M.table(printer, align='center'))
3950         [ 1 , 2]
3951         [-33, 4]
3952         >>> print(M.table(printer, rowstart='{', rowend='}'))
3953         {  1, 2}
3954         {-33, 4}
3955         """
3956         # Handle zero dimensions:
3957         if self.rows == 0 or self.cols == 0:
3958             return '[]'
3959         # Build table of string representations of the elements
3960         res = []
3961         # Track per-column max lengths for pretty alignment
3962         maxlen = [0] * self.cols
3963         for i in range(self.rows):
3964             res.append([])
3965             for j in range(self.cols):
3966                 s = printer._print(self[i, j])
3967                 res[-1].append(s)
3968                 maxlen[j] = max(len(s), maxlen[j])
3969         # Patch strings together
3970         align = {
3971             'left': 'ljust',
3972             'right': 'rjust',
3973             'center': 'center',
3974             '<': 'ljust',
3975             '>': 'rjust',
3976             '^': 'center',
3977         }[align]
3978         for i, row in enumerate(res):
3979             for j, elem in enumerate(row):
3980                 row[j] = getattr(elem, align)(maxlen[j])
3981             res[i] = rowstart + colsep.join(row) + rowend
3982         return rowsep.join(res)
3983 
3984     def upper_triangular_solve(self, rhs):
3985         """Solves Ax = B, where A is an upper triangular matrix.
3986 
3987         See Also
3988         ========
3989 
3990         lower_triangular_solve
3991         gauss_jordan_solve
3992         cholesky_solve
3993         diagonal_solve
3994         LDLsolve
3995         LUsolve
3996         QRsolve
3997         pinv_solve
3998         """
3999         if not self.is_square:
4000             raise NonSquareMatrixError("Matrix must be square.")
4001         if rhs.rows != self.rows:
4002             raise TypeError("Matrix size mismatch.")
4003         if not self.is_upper:
4004             raise TypeError("Matrix is not upper triangular.")
4005         return self._upper_triangular_solve(rhs)
4006 
4007     def vech(self, diagonal=True, check_symmetry=True):
4008         """Return the unique elements of a symmetric Matrix as a one column matrix
4009         by stacking the elements in the lower triangle.
4010 
4011         Arguments:
4012         diagonal -- include the diagonal cells of self or not
4013         check_symmetry -- checks symmetry of self but not completely reliably
4014 
4015         Examples
4016         ========
4017 
4018         >>> from sympy import Matrix
4019         >>> m=Matrix([[1, 2], [2, 3]])
4020         >>> m
4021         Matrix([
4022         [1, 2],
4023         [2, 3]])
4024         >>> m.vech()
4025         Matrix([
4026         [1],
4027         [2],
4028         [3]])
4029         >>> m.vech(diagonal=False)
4030         Matrix([[2]])
4031 
4032         See Also
4033         ========
4034 
4035         vec
4036         """
4037         from sympy.matrices import zeros
4038 
4039         c = self.cols
4040         if c != self.rows:
4041             raise ShapeError("Matrix must be square")
4042         if check_symmetry:
4043             self.simplify()
4044             if self != self.transpose():
4045                 raise ValueError(
4046                     "Matrix appears to be asymmetric; consider check_symmetry=False")
4047         count = 0
4048         if diagonal:
4049             v = zeros(c * (c + 1) // 2, 1)
4050             for j in range(c):
4051                 for i in range(j, c):
4052                     v[count] = self[i, j]
4053                     count += 1
4054         else:
4055             v = zeros(c * (c - 1) // 2, 1)
4056             for j in range(c):
4057                 for i in range(j + 1, c):
4058                     v[count] = self[i, j]
4059                     count += 1
4060         return v

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 19:39:34.687 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 19:39:34.688 | INFO     | Search-only: skipping patch selection
2025-10-18 19:39:34.825 | INFO     | Task sympy__sympy-13768 completed successfully.
2025-10-18 19:39:34.826 | INFO     | No patch generated. You can try running ACR again.
