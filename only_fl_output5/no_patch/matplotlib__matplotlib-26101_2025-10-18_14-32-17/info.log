2025-10-18 14:32:17.195 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 14:32:22.728 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=336, output_tokens=12, cost=0.003720
2025-10-18 14:32:35.368 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=516, output_tokens=510, cost=0.020460
2025-10-18 14:32:36.756 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:32:44.575 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=642, output_tokens=319, cost=0.015990
2025-10-18 14:32:44.582 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:32:47.414 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=673, output_tokens=59, cost=0.008500
2025-10-18 14:32:47.415 | DEBUG    | Extracted a valid json.
2025-10-18 14:32:47.415 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Axes\")",
        "search_class(\"Text\")",
        "search_class(\"MarkerStyle\")",
        "search_method(\"draw_marker\")",
        "search_method(\"set_marker\")"
    ],
    "bug_locations": []
}
2025-10-18 14:32:47.533 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:32:47.533 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:33:08.217 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8105, output_tokens=846, cost=0.106430
2025-10-18 14:33:08.224 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:33:17.330 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9167, output_tokens=370, cost=0.102770
2025-10-18 14:33:17.334 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:33:27.799 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=724, output_tokens=364, cost=0.018160
2025-10-18 14:33:27.800 | DEBUG    | Extracted a valid json.
2025-10-18 14:33:27.800 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "lib/matplotlib/markers.py",
            "class": "MarkerStyle",
            "method": "_set_mathtext_path",
            "intended_behavior": "This method should ensure that when mathtext is used to define a marker, it is correctly centered on the plot point it represents. To fix the issue, the method should be adjusted or extended to calculate the center of the mathtext marker accurately and render it so that it aligns perfectly with the intended plot coordinates. This might involve recalculating the anchor point for the mathtext marker or adjusting how the marker's bounding box is computed to ensure central alignment. The change should ensure that mathtext markers behave consistently with other marker types in terms of alignment, without affecting how non-mathtext markers are rendered."
        },
        {
            "file": "lib/matplotlib/text.py",
            "class": "Text",
            "method": "",
            "intended_behavior": "In the context of aligning mathtext markers, if adjustments within the `Text` class could impact the rendering of mathtext (such as alignment and positioning), the class should ensure that any mathtext rendered as part of a marker is centered based on the text's bounding box dimensions. The class should provide a mechanism to calculate and apply the correct alignment for mathtext specifically when it is used as a marker. This ensures that mathtext markers are rendered with the same center alignment as other markers, preserving the visual consistency across different marker types. Any modification should cater specifically to scenarios where text is used as a marker, ensuring that general text rendering functionality remains unaltered for regular plot annotations or labels."
        }
    ]
}
2025-10-18 14:33:27.805 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/markers.py</file>
<class>MarkerStyle</class>
<method>_set_mathtext_path</method>
<code>
497     def _set_mathtext_path(self):
498         """
499         Draw mathtext markers '$...$' using `.TextPath` object.
500 
501         Submitted by tcb
502         """
503         from matplotlib.text import TextPath
504 
505         # again, the properties could be initialised just once outside
506         # this function
507         text = TextPath(xy=(0, 0), s=self.get_marker(),
508                         usetex=mpl.rcParams['text.usetex'])
509         if len(text.vertices) == 0:
510             return
511 
512         xmin, ymin = text.vertices.min(axis=0)
513         xmax, ymax = text.vertices.max(axis=0)
514         width = xmax - xmin
515         height = ymax - ymin
516         max_dim = max(width, height)
517         self._transform = Affine2D() \
518             .translate(-xmin + 0.5 * -width, -ymin + 0.5 * -height) \
519             .scale(1.0 / max_dim)
520         self._path = text
521         self._snap = False

</code><intended_behavior>This method should ensure that when mathtext is used to define a marker, it is correctly centered on the plot point it represents. To fix the issue, the method should be adjusted or extended to calculate the center of the mathtext marker accurately and render it so that it aligns perfectly with the intended plot coordinates. This might involve recalculating the anchor point for the mathtext marker or adjusting how the marker's bounding box is computed to ensure central alignment. The change should ensure that mathtext markers behave consistently with other marker types in terms of alignment, without affecting how non-mathtext markers are rendered.</intended_behavior>, <file>lib/matplotlib/markers.py</file>
<class>MarkerStyle</class>
<method>None</method>
<code>
155 class MarkerStyle:
156     """
157     A class representing marker types.
158 
159     Instances are immutable. If you need to change anything, create a new
160     instance.
161 
162     Attributes
163     ----------
164     markers : dict
165         All known markers.
166     filled_markers : tuple
167         All known filled markers. This is a subset of *markers*.
168     fillstyles : tuple
169         The supported fillstyles.
170     """
171 
172     markers = {
173         '.': 'point',
174         ',': 'pixel',
175         'o': 'circle',
176         'v': 'triangle_down',
177         '^': 'triangle_up',
178         '<': 'triangle_left',
179         '>': 'triangle_right',
180         '1': 'tri_down',
181         '2': 'tri_up',
182         '3': 'tri_left',
183         '4': 'tri_right',
184         '8': 'octagon',
185         's': 'square',
186         'p': 'pentagon',
187         '*': 'star',
188         'h': 'hexagon1',
189         'H': 'hexagon2',
190         '+': 'plus',
191         'x': 'x',
192         'D': 'diamond',
193         'd': 'thin_diamond',
194         '|': 'vline',
195         '_': 'hline',
196         'P': 'plus_filled',
197         'X': 'x_filled',
198         TICKLEFT: 'tickleft',
199         TICKRIGHT: 'tickright',
200         TICKUP: 'tickup',
201         TICKDOWN: 'tickdown',
202         CARETLEFT: 'caretleft',
203         CARETRIGHT: 'caretright',
204         CARETUP: 'caretup',
205         CARETDOWN: 'caretdown',
206         CARETLEFTBASE: 'caretleftbase',
207         CARETRIGHTBASE: 'caretrightbase',
208         CARETUPBASE: 'caretupbase',
209         CARETDOWNBASE: 'caretdownbase',
210         "None": 'nothing',
211         "none": 'nothing',
212         ' ': 'nothing',
213         '': 'nothing'
214     }
215 
216     # Just used for informational purposes.  is_filled()
217     # is calculated in the _set_* functions.
218     filled_markers = (
219         '.', 'o', 'v', '^', '<', '>', '8', 's', 'p', '*', 'h', 'H', 'D', 'd',
220         'P', 'X')
221 
222     fillstyles = ('full', 'left', 'right', 'bottom', 'top', 'none')
223     _half_fillstyles = ('left', 'right', 'bottom', 'top')
224 
225     def __init__(self, marker,
226                  fillstyle=None, transform=None, capstyle=None, joinstyle=None):
227         """
228         Parameters
229         ----------
230         marker : str, array-like, Path, MarkerStyle, or None
231             - Another instance of *MarkerStyle* copies the details of that
232               ``marker``.
233             - *None* means no marker.  This is the deprecated default.
234             - For other possible marker values, see the module docstring
235               `matplotlib.markers`.
236 
237         fillstyle : str, default: :rc:`markers.fillstyle`
238             One of 'full', 'left', 'right', 'bottom', 'top', 'none'.
239 
240         transform : transforms.Transform, default: None
241             Transform that will be combined with the native transform of the
242             marker.
243 
244         capstyle : `.CapStyle` or %(CapStyle)s, default: None
245             Cap style that will override the default cap style of the marker.
246 
247         joinstyle : `.JoinStyle` or %(JoinStyle)s, default: None
248             Join style that will override the default join style of the marker.
249         """
250         self._marker_function = None
251         self._user_transform = transform
252         self._user_capstyle = CapStyle(capstyle) if capstyle is not None else None
253         self._user_joinstyle = JoinStyle(joinstyle) if joinstyle is not None else None
254         self._set_fillstyle(fillstyle)
255         self._set_marker(marker)
256 
257     def _recache(self):
258         if self._marker_function is None:
259             return
260         self._path = _empty_path
261         self._transform = IdentityTransform()
262         self._alt_path = None
263         self._alt_transform = None
264         self._snap_threshold = None
265         self._joinstyle = JoinStyle.round
266         self._capstyle = self._user_capstyle or CapStyle.butt
267         # Initial guess: Assume the marker is filled unless the fillstyle is
268         # set to 'none'. The marker function will override this for unfilled
269         # markers.
270         self._filled = self._fillstyle != 'none'
271         self._marker_function()
272 
273     def __bool__(self):
274         return bool(len(self._path.vertices))
275 
276     def is_filled(self):
277         return self._filled
278 
279     def get_fillstyle(self):
280         return self._fillstyle
281 
282     def _set_fillstyle(self, fillstyle):
283         """
284         Set the fillstyle.
285 
286         Parameters
287         ----------
288         fillstyle : {'full', 'left', 'right', 'bottom', 'top', 'none'}
289             The part of the marker surface that is colored with
290             markerfacecolor.
291         """
292         if fillstyle is None:
293             fillstyle = mpl.rcParams['markers.fillstyle']
294         _api.check_in_list(self.fillstyles, fillstyle=fillstyle)
295         self._fillstyle = fillstyle
296         self._recache()
297 
298     def get_joinstyle(self):
299         return self._joinstyle.name
300 
301     def get_capstyle(self):
302         return self._capstyle.name
303 
304     def get_marker(self):
305         return self._marker
306 
307     def _set_marker(self, marker):
308         """
309         Set the marker.
310 
311         Parameters
312         ----------
313         marker : str, array-like, Path, MarkerStyle, or None, default: None
314             - Another instance of *MarkerStyle* copies the details of that
315               ``marker``.
316             - *None* means no marker.
317             - For other possible marker values see the module docstring
318               `matplotlib.markers`.
319         """
320         if (isinstance(marker, np.ndarray) and marker.ndim == 2 and
321                 marker.shape[1] == 2):
322             self._marker_function = self._set_vertices
323         elif isinstance(marker, str) and cbook.is_math_text(marker):
324             self._marker_function = self._set_mathtext_path
325         elif isinstance(marker, Path):
326             self._marker_function = self._set_path_marker
327         elif (isinstance(marker, Sized) and len(marker) in (2, 3) and
328                 marker[1] in (0, 1, 2)):
329             self._marker_function = self._set_tuple_marker
330         elif (not isinstance(marker, (np.ndarray, list)) and
331               marker in self.markers):
332             self._marker_function = getattr(
333                 self, '_set_' + self.markers[marker])
334         elif isinstance(marker, MarkerStyle):
335             self.__dict__ = copy.deepcopy(marker.__dict__)
336 
337         else:
338             try:
339                 Path(marker)
340                 self._marker_function = self._set_vertices
341             except ValueError as err:
342                 raise ValueError(
343                     f'Unrecognized marker style {marker!r}') from err
344 
345         if not isinstance(marker, MarkerStyle):
346             self._marker = marker
347             self._recache()
348 
349     def get_path(self):
350         """
351         Return a `.Path` for the primary part of the marker.
352 
353         For unfilled markers this is the whole marker, for filled markers,
354         this is the area to be drawn with *markerfacecolor*.
355         """
356         return self._path
357 
358     def get_transform(self):
359         """
360         Return the transform to be applied to the `.Path` from
361         `MarkerStyle.get_path()`.
362         """
363         if self._user_transform is None:
364             return self._transform.frozen()
365         else:
366             return (self._transform + self._user_transform).frozen()
367 
368     def get_alt_path(self):
369         """
370         Return a `.Path` for the alternate part of the marker.
371 
372         For unfilled markers, this is *None*; for filled markers, this is the
373         area to be drawn with *markerfacecoloralt*.
374         """
375         return self._alt_path
376 
377     def get_alt_transform(self):
378         """
379         Return the transform to be applied to the `.Path` from
380         `MarkerStyle.get_alt_path()`.
381         """
382         if self._user_transform is None:
383             return self._alt_transform.frozen()
384         else:
385             return (self._alt_transform + self._user_transform).frozen()
386 
387     def get_snap_threshold(self):
388         return self._snap_threshold
389 
390     def get_user_transform(self):
391         """Return user supplied part of marker transform."""
392         if self._user_transform is not None:
393             return self._user_transform.frozen()
394 
395     def transformed(self, transform: Affine2D):
396         """
397         Return a new version of this marker with the transform applied.
398 
399         Parameters
400         ----------
401         transform : `~matplotlib.transforms.Affine2D`, default: None
402             Transform will be combined with current user supplied transform.
403         """
404         new_marker = MarkerStyle(self)
405         if new_marker._user_transform is not None:
406             new_marker._user_transform += transform
407         else:
408             new_marker._user_transform = transform
409         return new_marker
410 
411     def rotated(self, *, deg=None, rad=None):
412         """
413         Return a new version of this marker rotated by specified angle.
414 
415         Parameters
416         ----------
417         deg : float, default: None
418             Rotation angle in degrees.
419 
420         rad : float, default: None
421             Rotation angle in radians.
422 
423         .. note:: You must specify exactly one of deg or rad.
424         """
425         if deg is None and rad is None:
426             raise ValueError('One of deg or rad is required')
427         if deg is not None and rad is not None:
428             raise ValueError('Only one of deg and rad can be supplied')
429         new_marker = MarkerStyle(self)
430         if new_marker._user_transform is None:
431             new_marker._user_transform = Affine2D()
432 
433         if deg is not None:
434             new_marker._user_transform.rotate_deg(deg)
435         if rad is not None:
436             new_marker._user_transform.rotate(rad)
437 
438         return new_marker
439 
440     def scaled(self, sx, sy=None):
441         """
442         Return new marker scaled by specified scale factors.
443 
444         If *sy* is None, the same scale is applied in both the *x*- and
445         *y*-directions.
446 
447         Parameters
448         ----------
449         sx : float
450             *X*-direction scaling factor.
451         sy : float, default: None
452             *Y*-direction scaling factor.
453         """
454         if sy is None:
455             sy = sx
456 
457         new_marker = MarkerStyle(self)
458         _transform = new_marker._user_transform or Affine2D()
459         new_marker._user_transform = _transform.scale(sx, sy)
460         return new_marker
461 
462     def _set_nothing(self):
463         self._filled = False
464 
465     def _set_custom_marker(self, path):
466         rescale = np.max(np.abs(path.vertices))  # max of x's and y's.
467         self._transform = Affine2D().scale(0.5 / rescale)
468         self._path = path
469 
470     def _set_path_marker(self):
471         self._set_custom_marker(self._marker)
472 
473     def _set_vertices(self):
474         self._set_custom_marker(Path(self._marker))
475 
476     def _set_tuple_marker(self):
477         marker = self._marker
478         if len(marker) == 2:
479             numsides, rotation = marker[0], 0.0
480         elif len(marker) == 3:
481             numsides, rotation = marker[0], marker[2]
482         symstyle = marker[1]
483         if symstyle == 0:
484             self._path = Path.unit_regular_polygon(numsides)
485             self._joinstyle = self._user_joinstyle or JoinStyle.miter
486         elif symstyle == 1:
487             self._path = Path.unit_regular_star(numsides)
488             self._joinstyle = self._user_joinstyle or JoinStyle.bevel
489         elif symstyle == 2:
490             self._path = Path.unit_regular_asterisk(numsides)
491             self._filled = False
492             self._joinstyle = self._user_joinstyle or JoinStyle.bevel
493         else:
494             raise ValueError(f"Unexpected tuple marker: {marker}")
495         self._transform = Affine2D().scale(0.5).rotate_deg(rotation)
496 
497     def _set_mathtext_path(self):
498         """
499         Draw mathtext markers '$...$' using `.TextPath` object.
500 
501         Submitted by tcb
502         """
503         from matplotlib.text import TextPath
504 
505         # again, the properties could be initialised just once outside
506         # this function
507         text = TextPath(xy=(0, 0), s=self.get_marker(),
508                         usetex=mpl.rcParams['text.usetex'])
509         if len(text.vertices) == 0:
510             return
511 
512         xmin, ymin = text.vertices.min(axis=0)
513         xmax, ymax = text.vertices.max(axis=0)
514         width = xmax - xmin
515         height = ymax - ymin
516         max_dim = max(width, height)
517         self._transform = Affine2D() \
518             .translate(-xmin + 0.5 * -width, -ymin + 0.5 * -height) \
519             .scale(1.0 / max_dim)
520         self._path = text
521         self._snap = False
522 
523     def _half_fill(self):
524         return self.get_fillstyle() in self._half_fillstyles
525 
526     def _set_circle(self, size=1.0):
527         self._transform = Affine2D().scale(0.5 * size)
528         self._snap_threshold = np.inf
529         if not self._half_fill():
530             self._path = Path.unit_circle()
531         else:
532             self._path = self._alt_path = Path.unit_circle_righthalf()
533             fs = self.get_fillstyle()
534             self._transform.rotate_deg(
535                 {'right': 0, 'top': 90, 'left': 180, 'bottom': 270}[fs])
536             self._alt_transform = self._transform.frozen().rotate_deg(180.)
537 
538     def _set_point(self):
539         self._set_circle(size=0.5)
540 
541     def _set_pixel(self):
542         self._path = Path.unit_rectangle()
543         # Ideally, you'd want -0.5, -0.5 here, but then the snapping
544         # algorithm in the Agg backend will round this to a 2x2
545         # rectangle from (-1, -1) to (1, 1).  By offsetting it
546         # slightly, we can force it to be (0, 0) to (1, 1), which both
547         # makes it only be a single pixel and places it correctly
548         # aligned to 1-width stroking (i.e. the ticks).  This hack is
549         # the best of a number of bad alternatives, mainly because the
550         # backends are not aware of what marker is actually being used
551         # beyond just its path data.
552         self._transform = Affine2D().translate(-0.49999, -0.49999)
553         self._snap_threshold = None
554 
555     _triangle_path = Path._create_closed([[0, 1], [-1, -1], [1, -1]])
556     # Going down halfway looks to small.  Golden ratio is too far.
557     _triangle_path_u = Path._create_closed([[0, 1], [-3/5, -1/5], [3/5, -1/5]])
558     _triangle_path_d = Path._create_closed(
559         [[-3/5, -1/5], [3/5, -1/5], [1, -1], [-1, -1]])
560     _triangle_path_l = Path._create_closed([[0, 1], [0, -1], [-1, -1]])
561     _triangle_path_r = Path._create_closed([[0, 1], [0, -1], [1, -1]])
562 
563     def _set_triangle(self, rot, skip):
564         self._transform = Affine2D().scale(0.5).rotate_deg(rot)
565         self._snap_threshold = 5.0
566 
567         if not self._half_fill():
568             self._path = self._triangle_path
569         else:
570             mpaths = [self._triangle_path_u,
571                       self._triangle_path_l,
572                       self._triangle_path_d,
573                       self._triangle_path_r]
574 
575             fs = self.get_fillstyle()
576             if fs == 'top':
577                 self._path = mpaths[(0 + skip) % 4]
578                 self._alt_path = mpaths[(2 + skip) % 4]
579             elif fs == 'bottom':
580                 self._path = mpaths[(2 + skip) % 4]
581                 self._alt_path = mpaths[(0 + skip) % 4]
582             elif fs == 'left':
583                 self._path = mpaths[(1 + skip) % 4]
584                 self._alt_path = mpaths[(3 + skip) % 4]
585             else:
586                 self._path = mpaths[(3 + skip) % 4]
587                 self._alt_path = mpaths[(1 + skip) % 4]
588 
589             self._alt_transform = self._transform
590 
591         self._joinstyle = self._user_joinstyle or JoinStyle.miter
592 
593     def _set_triangle_up(self):
594         return self._set_triangle(0.0, 0)
595 
596     def _set_triangle_down(self):
597         return self._set_triangle(180.0, 2)
598 
599     def _set_triangle_left(self):
600         return self._set_triangle(90.0, 3)
601 
602     def _set_triangle_right(self):
603         return self._set_triangle(270.0, 1)
604 
605     def _set_square(self):
606         self._transform = Affine2D().translate(-0.5, -0.5)
607         self._snap_threshold = 2.0
608         if not self._half_fill():
609             self._path = Path.unit_rectangle()
610         else:
611             # Build a bottom filled square out of two rectangles, one filled.
612             self._path = Path([[0.0, 0.0], [1.0, 0.0], [1.0, 0.5],
613                                [0.0, 0.5], [0.0, 0.0]])
614             self._alt_path = Path([[0.0, 0.5], [1.0, 0.5], [1.0, 1.0],
615                                    [0.0, 1.0], [0.0, 0.5]])
616             fs = self.get_fillstyle()
617             rotate = {'bottom': 0, 'right': 90, 'top': 180, 'left': 270}[fs]
618             self._transform.rotate_deg(rotate)
619             self._alt_transform = self._transform
620 
621         self._joinstyle = self._user_joinstyle or JoinStyle.miter
622 
623     def _set_diamond(self):
624         self._transform = Affine2D().translate(-0.5, -0.5).rotate_deg(45)
625         self._snap_threshold = 5.0
626         if not self._half_fill():
627             self._path = Path.unit_rectangle()
628         else:
629             self._path = Path([[0, 0], [1, 0], [1, 1], [0, 0]])
630             self._alt_path = Path([[0, 0], [0, 1], [1, 1], [0, 0]])
631             fs = self.get_fillstyle()
632             rotate = {'right': 0, 'top': 90, 'left': 180, 'bottom': 270}[fs]
633             self._transform.rotate_deg(rotate)
634             self._alt_transform = self._transform
635         self._joinstyle = self._user_joinstyle or JoinStyle.miter
636 
637     def _set_thin_diamond(self):
638         self._set_diamond()
639         self._transform.scale(0.6, 1.0)
640 
641     def _set_pentagon(self):
642         self._transform = Affine2D().scale(0.5)
643         self._snap_threshold = 5.0
644 
645         polypath = Path.unit_regular_polygon(5)
646 
647         if not self._half_fill():
648             self._path = polypath
649         else:
650             verts = polypath.vertices
651             y = (1 + np.sqrt(5)) / 4.
652             top = Path(verts[[0, 1, 4, 0]])
653             bottom = Path(verts[[1, 2, 3, 4, 1]])
654             left = Path([verts[0], verts[1], verts[2], [0, -y], verts[0]])
655             right = Path([verts[0], verts[4], verts[3], [0, -y], verts[0]])
656             self._path, self._alt_path = {
657                 'top': (top, bottom), 'bottom': (bottom, top),
658                 'left': (left, right), 'right': (right, left),
659             }[self.get_fillstyle()]
660             self._alt_transform = self._transform
661 
662         self._joinstyle = self._user_joinstyle or JoinStyle.miter
663 
664     def _set_star(self):
665         self._transform = Affine2D().scale(0.5)
666         self._snap_threshold = 5.0
667 
668         polypath = Path.unit_regular_star(5, innerCircle=0.381966)
669 
670         if not self._half_fill():
671             self._path = polypath
672         else:
673             verts = polypath.vertices
674             top = Path(np.concatenate([verts[0:4], verts[7:10], verts[0:1]]))
675             bottom = Path(np.concatenate([verts[3:8], verts[3:4]]))
676             left = Path(np.concatenate([verts[0:6], verts[0:1]]))
677             right = Path(np.concatenate([verts[0:1], verts[5:10], verts[0:1]]))
678             self._path, self._alt_path = {
679                 'top': (top, bottom), 'bottom': (bottom, top),
680                 'left': (left, right), 'right': (right, left),
681             }[self.get_fillstyle()]
682             self._alt_transform = self._transform
683 
684         self._joinstyle = self._user_joinstyle or JoinStyle.bevel
685 
686     def _set_hexagon1(self):
687         self._transform = Affine2D().scale(0.5)
688         self._snap_threshold = None
689 
690         polypath = Path.unit_regular_polygon(6)
691 
692         if not self._half_fill():
693             self._path = polypath
694         else:
695             verts = polypath.vertices
696             # not drawing inside lines
697             x = np.abs(np.cos(5 * np.pi / 6.))
698             top = Path(np.concatenate([[(-x, 0)], verts[[1, 0, 5]], [(x, 0)]]))
699             bottom = Path(np.concatenate([[(-x, 0)], verts[2:5], [(x, 0)]]))
700             left = Path(verts[0:4])
701             right = Path(verts[[0, 5, 4, 3]])
702             self._path, self._alt_path = {
703                 'top': (top, bottom), 'bottom': (bottom, top),
704                 'left': (left, right), 'right': (right, left),
705             }[self.get_fillstyle()]
706             self._alt_transform = self._transform
707 
708         self._joinstyle = self._user_joinstyle or JoinStyle.miter
709 
710     def _set_hexagon2(self):
711         self._transform = Affine2D().scale(0.5).rotate_deg(30)
712         self._snap_threshold = None
713 
714         polypath = Path.unit_regular_polygon(6)
715 
716         if not self._half_fill():
717             self._path = polypath
718         else:
719             verts = polypath.vertices
720             # not drawing inside lines
721             x, y = np.sqrt(3) / 4, 3 / 4.
722             top = Path(verts[[1, 0, 5, 4, 1]])
723             bottom = Path(verts[1:5])
724             left = Path(np.concatenate([
725                 [(x, y)], verts[:3], [(-x, -y), (x, y)]]))
726             right = Path(np.concatenate([
727                 [(x, y)], verts[5:2:-1], [(-x, -y)]]))
728             self._path, self._alt_path = {
729                 'top': (top, bottom), 'bottom': (bottom, top),
730                 'left': (left, right), 'right': (right, left),
731             }[self.get_fillstyle()]
732             self._alt_transform = self._transform
733 
734         self._joinstyle = self._user_joinstyle or JoinStyle.miter
735 
736     def _set_octagon(self):
737         self._transform = Affine2D().scale(0.5)
738         self._snap_threshold = 5.0
739 
740         polypath = Path.unit_regular_polygon(8)
741 
742         if not self._half_fill():
743             self._transform.rotate_deg(22.5)
744             self._path = polypath
745         else:
746             x = np.sqrt(2.) / 4.
747             self._path = self._alt_path = Path(
748                 [[0, -1], [0, 1], [-x, 1], [-1, x],
749                  [-1, -x], [-x, -1], [0, -1]])
750             fs = self.get_fillstyle()
751             self._transform.rotate_deg(
752                 {'left': 0, 'bottom': 90, 'right': 180, 'top': 270}[fs])
753             self._alt_transform = self._transform.frozen().rotate_deg(180.0)
754 
755         self._joinstyle = self._user_joinstyle or JoinStyle.miter
756 
757     _line_marker_path = Path([[0.0, -1.0], [0.0, 1.0]])
758 
759     def _set_vline(self):
760         self._transform = Affine2D().scale(0.5)
761         self._snap_threshold = 1.0
762         self._filled = False
763         self._path = self._line_marker_path
764 
765     def _set_hline(self):
766         self._set_vline()
767         self._transform = self._transform.rotate_deg(90)
768 
769     _tickhoriz_path = Path([[0.0, 0.0], [1.0, 0.0]])
770 
771     def _set_tickleft(self):
772         self._transform = Affine2D().scale(-1.0, 1.0)
773         self._snap_threshold = 1.0
774         self._filled = False
775         self._path = self._tickhoriz_path
776 
777     def _set_tickright(self):
778         self._transform = Affine2D().scale(1.0, 1.0)
779         self._snap_threshold = 1.0
780         self._filled = False
781         self._path = self._tickhoriz_path
782 
783     _tickvert_path = Path([[-0.0, 0.0], [-0.0, 1.0]])
784 
785     def _set_tickup(self):
786         self._transform = Affine2D().scale(1.0, 1.0)
787         self._snap_threshold = 1.0
788         self._filled = False
789         self._path = self._tickvert_path
790 
791     def _set_tickdown(self):
792         self._transform = Affine2D().scale(1.0, -1.0)
793         self._snap_threshold = 1.0
794         self._filled = False
795         self._path = self._tickvert_path
796 
797     _tri_path = Path([[0.0, 0.0], [0.0, -1.0],
798                       [0.0, 0.0], [0.8, 0.5],
799                       [0.0, 0.0], [-0.8, 0.5]],
800                      [Path.MOVETO, Path.LINETO,
801                       Path.MOVETO, Path.LINETO,
802                       Path.MOVETO, Path.LINETO])
803 
804     def _set_tri_down(self):
805         self._transform = Affine2D().scale(0.5)
806         self._snap_threshold = 5.0
807         self._filled = False
808         self._path = self._tri_path
809 
810     def _set_tri_up(self):
811         self._set_tri_down()
812         self._transform = self._transform.rotate_deg(180)
813 
814     def _set_tri_left(self):
815         self._set_tri_down()
816         self._transform = self._transform.rotate_deg(270)
817 
818     def _set_tri_right(self):
819         self._set_tri_down()
820         self._transform = self._transform.rotate_deg(90)
821 
822     _caret_path = Path([[-1.0, 1.5], [0.0, 0.0], [1.0, 1.5]])
823 
824     def _set_caretdown(self):
825         self._transform = Affine2D().scale(0.5)
826         self._snap_threshold = 3.0
827         self._filled = False
828         self._path = self._caret_path
829         self._joinstyle = self._user_joinstyle or JoinStyle.miter
830 
831     def _set_caretup(self):
832         self._set_caretdown()
833         self._transform = self._transform.rotate_deg(180)
834 
835     def _set_caretleft(self):
836         self._set_caretdown()
837         self._transform = self._transform.rotate_deg(270)
838 
839     def _set_caretright(self):
840         self._set_caretdown()
841         self._transform = self._transform.rotate_deg(90)
842 
843     _caret_path_base = Path([[-1.0, 0.0], [0.0, -1.5], [1.0, 0]])
844 
845     def _set_caretdownbase(self):
846         self._set_caretdown()
847         self._path = self._caret_path_base
848 
849     def _set_caretupbase(self):
850         self._set_caretdownbase()
851         self._transform = self._transform.rotate_deg(180)
852 
853     def _set_caretleftbase(self):
854         self._set_caretdownbase()
855         self._transform = self._transform.rotate_deg(270)
856 
857     def _set_caretrightbase(self):
858         self._set_caretdownbase()
859         self._transform = self._transform.rotate_deg(90)
860 
861     _plus_path = Path([[-1.0, 0.0], [1.0, 0.0],
862                        [0.0, -1.0], [0.0, 1.0]],
863                       [Path.MOVETO, Path.LINETO,
864                        Path.MOVETO, Path.LINETO])
865 
866     def _set_plus(self):
867         self._transform = Affine2D().scale(0.5)
868         self._snap_threshold = 1.0
869         self._filled = False
870         self._path = self._plus_path
871 
872     _x_path = Path([[-1.0, -1.0], [1.0, 1.0],
873                     [-1.0, 1.0], [1.0, -1.0]],
874                    [Path.MOVETO, Path.LINETO,
875                     Path.MOVETO, Path.LINETO])
876 
877     def _set_x(self):
878         self._transform = Affine2D().scale(0.5)
879         self._snap_threshold = 3.0
880         self._filled = False
881         self._path = self._x_path
882 
883     _plus_filled_path = Path._create_closed(np.array([
884         (-1, -3), (+1, -3), (+1, -1), (+3, -1), (+3, +1), (+1, +1),
885         (+1, +3), (-1, +3), (-1, +1), (-3, +1), (-3, -1), (-1, -1)]) / 6)
886     _plus_filled_path_t = Path._create_closed(np.array([
887         (+3, 0), (+3, +1), (+1, +1), (+1, +3),
888         (-1, +3), (-1, +1), (-3, +1), (-3, 0)]) / 6)
889 
890     def _set_plus_filled(self):
891         self._transform = Affine2D()
892         self._snap_threshold = 5.0
893         self._joinstyle = self._user_joinstyle or JoinStyle.miter
894         if not self._half_fill():
895             self._path = self._plus_filled_path
896         else:
897             # Rotate top half path to support all partitions
898             self._path = self._alt_path = self._plus_filled_path_t
899             fs = self.get_fillstyle()
900             self._transform.rotate_deg(
901                 {'top': 0, 'left': 90, 'bottom': 180, 'right': 270}[fs])
902             self._alt_transform = self._transform.frozen().rotate_deg(180)
903 
904     _x_filled_path = Path._create_closed(np.array([
905         (-1, -2), (0, -1), (+1, -2), (+2, -1), (+1, 0), (+2, +1),
906         (+1, +2), (0, +1), (-1, +2), (-2, +1), (-1, 0), (-2, -1)]) / 4)
907     _x_filled_path_t = Path._create_closed(np.array([
908         (+1, 0), (+2, +1), (+1, +2), (0, +1),
909         (-1, +2), (-2, +1), (-1, 0)]) / 4)
910 
911     def _set_x_filled(self):
912         self._transform = Affine2D()
913         self._snap_threshold = 5.0
914         self._joinstyle = self._user_joinstyle or JoinStyle.miter
915         if not self._half_fill():
916             self._path = self._x_filled_path
917         else:
918             # Rotate top half path to support all partitions
919             self._path = self._alt_path = self._x_filled_path_t
920             fs = self.get_fillstyle()
921             self._transform.rotate_deg(
922                 {'top': 0, 'left': 90, 'bottom': 180, 'right': 270}[fs])
923             self._alt_transform = self._transform.frozen().rotate_deg(180)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/text.py</file>
<class>Text</class>
<method>None</method>
<code>
95 class Text(Artist):
96     """Handle storing and drawing of text in window or data coordinates."""
97 
98     zorder = 3
99     _charsize_cache = dict()
100 
101     def __repr__(self):
102         return f"Text({self._x}, {self._y}, {self._text!r})"
103 
104     def __init__(self,
105                  x=0, y=0, text='', *,
106                  color=None,           # defaults to rc params
107                  verticalalignment='baseline',
108                  horizontalalignment='left',
109                  multialignment=None,
110                  fontproperties=None,  # defaults to FontProperties()
111                  rotation=None,
112                  linespacing=None,
113                  rotation_mode=None,
114                  usetex=None,          # defaults to rcParams['text.usetex']
115                  wrap=False,
116                  transform_rotates_text=False,
117                  parse_math=None,    # defaults to rcParams['text.parse_math']
118                  antialiased=None,  # defaults to rcParams['text.antialiased']
119                  **kwargs
120                  ):
121         """
122         Create a `.Text` instance at *x*, *y* with string *text*.
123 
124         The text is aligned relative to the anchor point (*x*, *y*) according
125         to ``horizontalalignment`` (default: 'left') and ``verticalalignment``
126         (default: 'bottom'). See also
127         :doc:`/gallery/text_labels_and_annotations/text_alignment`.
128 
129         While Text accepts the 'label' keyword argument, by default it is not
130         added to the handles of a legend.
131 
132         Valid keyword arguments are:
133 
134         %(Text:kwdoc)s
135         """
136         super().__init__()
137         self._x, self._y = x, y
138         self._text = ''
139         self._antialiased = mpl.rcParams['text.antialiased']
140         self._reset_visual_defaults(
141             text=text,
142             color=color,
143             fontproperties=fontproperties,
144             usetex=usetex,
145             parse_math=parse_math,
146             wrap=wrap,
147             verticalalignment=verticalalignment,
148             horizontalalignment=horizontalalignment,
149             multialignment=multialignment,
150             rotation=rotation,
151             transform_rotates_text=transform_rotates_text,
152             linespacing=linespacing,
153             rotation_mode=rotation_mode,
154             antialiased=antialiased
155         )
156         self.update(kwargs)
157 
158     def _reset_visual_defaults(
159         self,
160         text='',
161         color=None,
162         fontproperties=None,
163         usetex=None,
164         parse_math=None,
165         wrap=False,
166         verticalalignment='baseline',
167         horizontalalignment='left',
168         multialignment=None,
169         rotation=None,
170         transform_rotates_text=False,
171         linespacing=None,
172         rotation_mode=None,
173         antialiased=None
174     ):
175         self.set_text(text)
176         self.set_color(
177             color if color is not None else mpl.rcParams["text.color"])
178         self.set_fontproperties(fontproperties)
179         self.set_usetex(usetex)
180         self.set_parse_math(parse_math if parse_math is not None else
181                             mpl.rcParams['text.parse_math'])
182         self.set_wrap(wrap)
183         self.set_verticalalignment(verticalalignment)
184         self.set_horizontalalignment(horizontalalignment)
185         self._multialignment = multialignment
186         self.set_rotation(rotation)
187         self._transform_rotates_text = transform_rotates_text
188         self._bbox_patch = None  # a FancyBboxPatch instance
189         self._renderer = None
190         if linespacing is None:
191             linespacing = 1.2  # Maybe use rcParam later.
192         self.set_linespacing(linespacing)
193         self.set_rotation_mode(rotation_mode)
194         if antialiased is not None:
195             self.set_antialiased(antialiased)
196 
197     def update(self, kwargs):
198         # docstring inherited
199         kwargs = cbook.normalize_kwargs(kwargs, Text)
200         sentinel = object()  # bbox can be None, so use another sentinel.
201         # Update fontproperties first, as it has lowest priority.
202         fontproperties = kwargs.pop("fontproperties", sentinel)
203         if fontproperties is not sentinel:
204             self.set_fontproperties(fontproperties)
205         # Update bbox last, as it depends on font properties.
206         bbox = kwargs.pop("bbox", sentinel)
207         super().update(kwargs)
208         if bbox is not sentinel:
209             self.set_bbox(bbox)
210 
211     def __getstate__(self):
212         d = super().__getstate__()
213         # remove the cached _renderer (if it exists)
214         d['_renderer'] = None
215         return d
216 
217     def contains(self, mouseevent):
218         """
219         Return whether the mouse event occurred inside the axis-aligned
220         bounding-box of the text.
221         """
222         if (self._different_canvas(mouseevent) or not self.get_visible()
223                 or self._renderer is None):
224             return False, {}
225         # Explicitly use Text.get_window_extent(self) and not
226         # self.get_window_extent() so that Annotation.contains does not
227         # accidentally cover the entire annotation bounding box.
228         bbox = Text.get_window_extent(self)
229         inside = (bbox.x0 <= mouseevent.x <= bbox.x1
230                   and bbox.y0 <= mouseevent.y <= bbox.y1)
231         cattr = {}
232         # if the text has a surrounding patch, also check containment for it,
233         # and merge the results with the results for the text.
234         if self._bbox_patch:
235             patch_inside, patch_cattr = self._bbox_patch.contains(mouseevent)
236             inside = inside or patch_inside
237             cattr["bbox_patch"] = patch_cattr
238         return inside, cattr
239 
240     def _get_xy_display(self):
241         """
242         Get the (possibly unit converted) transformed x, y in display coords.
243         """
244         x, y = self.get_unitless_position()
245         return self.get_transform().transform((x, y))
246 
247     def _get_multialignment(self):
248         if self._multialignment is not None:
249             return self._multialignment
250         else:
251             return self._horizontalalignment
252 
253     def _char_index_at(self, x):
254         """
255         Calculate the index closest to the coordinate x in display space.
256 
257         The position of text[index] is assumed to be the sum of the widths
258         of all preceding characters text[:index].
259 
260         This works only on single line texts.
261         """
262         if not self._text:
263             return 0
264 
265         text = self._text
266 
267         fontproperties = str(self._fontproperties)
268         if fontproperties not in Text._charsize_cache:
269             Text._charsize_cache[fontproperties] = dict()
270 
271         charsize_cache = Text._charsize_cache[fontproperties]
272         for char in set(text):
273             if char not in charsize_cache:
274                 self.set_text(char)
275                 bb = self.get_window_extent()
276                 charsize_cache[char] = bb.x1 - bb.x0
277 
278         self.set_text(text)
279         bb = self.get_window_extent()
280 
281         size_accum = np.cumsum([0] + [charsize_cache[x] for x in text])
282         std_x = x - bb.x0
283         return (np.abs(size_accum - std_x)).argmin()
284 
285     def get_rotation(self):
286         """Return the text angle in degrees between 0 and 360."""
287         if self.get_transform_rotates_text():
288             return self.get_transform().transform_angles(
289                 [self._rotation], [self.get_unitless_position()]).item(0)
290         else:
291             return self._rotation
292 
293     def get_transform_rotates_text(self):
294         """
295         Return whether rotations of the transform affect the text direction.
296         """
297         return self._transform_rotates_text
298 
299     def set_rotation_mode(self, m):
300         """
301         Set text rotation mode.
302 
303         Parameters
304         ----------
305         m : {None, 'default', 'anchor'}
306             If ``None`` or ``"default"``, the text will be first rotated, then
307             aligned according to their horizontal and vertical alignments.  If
308             ``"anchor"``, then alignment occurs before rotation.
309         """
310         _api.check_in_list(["anchor", "default", None], rotation_mode=m)
311         self._rotation_mode = m
312         self.stale = True
313 
314     def get_rotation_mode(self):
315         """Return the text rotation mode."""
316         return self._rotation_mode
317 
318     def set_antialiased(self, antialiased):
319         """
320         Set whether to use antialiased rendering.
321 
322         Parameters
323         ----------
324         antialiased : bool
325 
326         Notes
327         -----
328         Antialiasing will be determined by :rc:`text.antialiased`
329         and the parameter *antialiased* will have no effect if the text contains
330         math expressions.
331         """
332         self._antialiased = antialiased
333         self.stale = True
334 
335     def get_antialiased(self):
336         """Return whether antialiased rendering is used."""
337         return self._antialiased
338 
339     def update_from(self, other):
340         # docstring inherited
341         super().update_from(other)
342         self._color = other._color
343         self._multialignment = other._multialignment
344         self._verticalalignment = other._verticalalignment
345         self._horizontalalignment = other._horizontalalignment
346         self._fontproperties = other._fontproperties.copy()
347         self._usetex = other._usetex
348         self._rotation = other._rotation
349         self._transform_rotates_text = other._transform_rotates_text
350         self._picker = other._picker
351         self._linespacing = other._linespacing
352         self._antialiased = other._antialiased
353         self.stale = True
354 
355     def _get_layout(self, renderer):
356         """
357         Return the extent (bbox) of the text together with
358         multiple-alignment information. Note that it returns an extent
359         of a rotated text when necessary.
360         """
361         thisx, thisy = 0.0, 0.0
362         lines = self._get_wrapped_text().split("\n")  # Ensures lines is not empty.
363 
364         ws = []
365         hs = []
366         xs = []
367         ys = []
368 
369         # Full vertical extent of font, including ascenders and descenders:
370         _, lp_h, lp_d = _get_text_metrics_with_cache(
371             renderer, "lp", self._fontproperties,
372             ismath="TeX" if self.get_usetex() else False, dpi=self.figure.dpi)
373         min_dy = (lp_h - lp_d) * self._linespacing
374 
375         for i, line in enumerate(lines):
376             clean_line, ismath = self._preprocess_math(line)
377             if clean_line:
378                 w, h, d = _get_text_metrics_with_cache(
379                     renderer, clean_line, self._fontproperties,
380                     ismath=ismath, dpi=self.figure.dpi)
381             else:
382                 w = h = d = 0
383 
384             # For multiline text, increase the line spacing when the text
385             # net-height (excluding baseline) is larger than that of a "l"
386             # (e.g., use of superscripts), which seems what TeX does.
387             h = max(h, lp_h)
388             d = max(d, lp_d)
389 
390             ws.append(w)
391             hs.append(h)
392 
393             # Metrics of the last line that are needed later:
394             baseline = (h - d) - thisy
395 
396             if i == 0:
397                 # position at baseline
398                 thisy = -(h - d)
399             else:
400                 # put baseline a good distance from bottom of previous line
401                 thisy -= max(min_dy, (h - d) * self._linespacing)
402 
403             xs.append(thisx)  # == 0.
404             ys.append(thisy)
405 
406             thisy -= d
407 
408         # Metrics of the last line that are needed later:
409         descent = d
410 
411         # Bounding box definition:
412         width = max(ws)
413         xmin = 0
414         xmax = width
415         ymax = 0
416         ymin = ys[-1] - descent  # baseline of last line minus its descent
417 
418         # get the rotation matrix
419         M = Affine2D().rotate_deg(self.get_rotation())
420 
421         # now offset the individual text lines within the box
422         malign = self._get_multialignment()
423         if malign == 'left':
424             offset_layout = [(x, y) for x, y in zip(xs, ys)]
425         elif malign == 'center':
426             offset_layout = [(x + width / 2 - w / 2, y)
427                              for x, y, w in zip(xs, ys, ws)]
428         elif malign == 'right':
429             offset_layout = [(x + width - w, y)
430                              for x, y, w in zip(xs, ys, ws)]
431 
432         # the corners of the unrotated bounding box
433         corners_horiz = np.array(
434             [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)])
435 
436         # now rotate the bbox
437         corners_rotated = M.transform(corners_horiz)
438         # compute the bounds of the rotated box
439         xmin = corners_rotated[:, 0].min()
440         xmax = corners_rotated[:, 0].max()
441         ymin = corners_rotated[:, 1].min()
442         ymax = corners_rotated[:, 1].max()
443         width = xmax - xmin
444         height = ymax - ymin
445 
446         # Now move the box to the target position offset the display
447         # bbox by alignment
448         halign = self._horizontalalignment
449         valign = self._verticalalignment
450 
451         rotation_mode = self.get_rotation_mode()
452         if rotation_mode != "anchor":
453             # compute the text location in display coords and the offsets
454             # necessary to align the bbox with that location
455             if halign == 'center':
456                 offsetx = (xmin + xmax) / 2
457             elif halign == 'right':
458                 offsetx = xmax
459             else:
460                 offsetx = xmin
461 
462             if valign == 'center':
463                 offsety = (ymin + ymax) / 2
464             elif valign == 'top':
465                 offsety = ymax
466             elif valign == 'baseline':
467                 offsety = ymin + descent
468             elif valign == 'center_baseline':
469                 offsety = ymin + height - baseline / 2.0
470             else:
471                 offsety = ymin
472         else:
473             xmin1, ymin1 = corners_horiz[0]
474             xmax1, ymax1 = corners_horiz[2]
475 
476             if halign == 'center':
477                 offsetx = (xmin1 + xmax1) / 2.0
478             elif halign == 'right':
479                 offsetx = xmax1
480             else:
481                 offsetx = xmin1
482 
483             if valign == 'center':
484                 offsety = (ymin1 + ymax1) / 2.0
485             elif valign == 'top':
486                 offsety = ymax1
487             elif valign == 'baseline':
488                 offsety = ymax1 - baseline
489             elif valign == 'center_baseline':
490                 offsety = ymax1 - baseline / 2.0
491             else:
492                 offsety = ymin1
493 
494             offsetx, offsety = M.transform((offsetx, offsety))
495 
496         xmin -= offsetx
497         ymin -= offsety
498 
499         bbox = Bbox.from_bounds(xmin, ymin, width, height)
500 
501         # now rotate the positions around the first (x, y) position
502         xys = M.transform(offset_layout) - (offsetx, offsety)
503 
504         return bbox, list(zip(lines, zip(ws, hs), *xys.T)), descent
505 
506     def set_bbox(self, rectprops):
507         """
508         Draw a bounding box around self.
509 
510         Parameters
511         ----------
512         rectprops : dict with properties for `.patches.FancyBboxPatch`
513              The default boxstyle is 'square'. The mutation
514              scale of the `.patches.FancyBboxPatch` is set to the fontsize.
515 
516         Examples
517         --------
518         ::
519 
520             t.set_bbox(dict(facecolor='red', alpha=0.5))
521         """
522 
523         if rectprops is not None:
524             props = rectprops.copy()
525             boxstyle = props.pop("boxstyle", None)
526             pad = props.pop("pad", None)
527             if boxstyle is None:
528                 boxstyle = "square"
529                 if pad is None:
530                     pad = 4  # points
531                 pad /= self.get_size()  # to fraction of font size
532             else:
533                 if pad is None:
534                     pad = 0.3
535             # boxstyle could be a callable or a string
536             if isinstance(boxstyle, str) and "pad" not in boxstyle:
537                 boxstyle += ",pad=%0.2f" % pad
538             self._bbox_patch = FancyBboxPatch(
539                 (0, 0), 1, 1,
540                 boxstyle=boxstyle, transform=IdentityTransform(), **props)
541         else:
542             self._bbox_patch = None
543 
544         self._update_clip_properties()
545 
546     def get_bbox_patch(self):
547         """
548         Return the bbox Patch, or None if the `.patches.FancyBboxPatch`
549         is not made.
550         """
551         return self._bbox_patch
552 
553     def update_bbox_position_size(self, renderer):
554         """
555         Update the location and the size of the bbox.
556 
557         This method should be used when the position and size of the bbox needs
558         to be updated before actually drawing the bbox.
559         """
560         if self._bbox_patch:
561             # don't use self.get_unitless_position here, which refers to text
562             # position in Text:
563             posx = float(self.convert_xunits(self._x))
564             posy = float(self.convert_yunits(self._y))
565             posx, posy = self.get_transform().transform((posx, posy))
566 
567             x_box, y_box, w_box, h_box = _get_textbox(self, renderer)
568             self._bbox_patch.set_bounds(0., 0., w_box, h_box)
569             self._bbox_patch.set_transform(
570                 Affine2D()
571                 .rotate_deg(self.get_rotation())
572                 .translate(posx + x_box, posy + y_box))
573             fontsize_in_pixel = renderer.points_to_pixels(self.get_size())
574             self._bbox_patch.set_mutation_scale(fontsize_in_pixel)
575 
576     def _update_clip_properties(self):
577         clipprops = dict(clip_box=self.clipbox,
578                          clip_path=self._clippath,
579                          clip_on=self._clipon)
580         if self._bbox_patch:
581             self._bbox_patch.update(clipprops)
582 
583     def set_clip_box(self, clipbox):
584         # docstring inherited.
585         super().set_clip_box(clipbox)
586         self._update_clip_properties()
587 
588     def set_clip_path(self, path, transform=None):
589         # docstring inherited.
590         super().set_clip_path(path, transform)
591         self._update_clip_properties()
592 
593     def set_clip_on(self, b):
594         # docstring inherited.
595         super().set_clip_on(b)
596         self._update_clip_properties()
597 
598     def get_wrap(self):
599         """Return whether the text can be wrapped."""
600         return self._wrap
601 
602     def set_wrap(self, wrap):
603         """
604         Set whether the text can be wrapped.
605 
606         Parameters
607         ----------
608         wrap : bool
609 
610         Notes
611         -----
612         Wrapping does not work together with
613         ``savefig(..., bbox_inches='tight')`` (which is also used internally
614         by ``%matplotlib inline`` in IPython/Jupyter). The 'tight' setting
615         rescales the canvas to accommodate all content and happens before
616         wrapping.
617         """
618         self._wrap = wrap
619 
620     def _get_wrap_line_width(self):
621         """
622         Return the maximum line width for wrapping text based on the current
623         orientation.
624         """
625         x0, y0 = self.get_transform().transform(self.get_position())
626         figure_box = self.get_figure().get_window_extent()
627 
628         # Calculate available width based on text alignment
629         alignment = self.get_horizontalalignment()
630         self.set_rotation_mode('anchor')
631         rotation = self.get_rotation()
632 
633         left = self._get_dist_to_box(rotation, x0, y0, figure_box)
634         right = self._get_dist_to_box(
635             (180 + rotation) % 360, x0, y0, figure_box)
636 
637         if alignment == 'left':
638             line_width = left
639         elif alignment == 'right':
640             line_width = right
641         else:
642             line_width = 2 * min(left, right)
643 
644         return line_width
645 
646     def _get_dist_to_box(self, rotation, x0, y0, figure_box):
647         """
648         Return the distance from the given points to the boundaries of a
649         rotated box, in pixels.
650         """
651         if rotation > 270:
652             quad = rotation - 270
653             h1 = y0 / math.cos(math.radians(quad))
654             h2 = (figure_box.x1 - x0) / math.cos(math.radians(90 - quad))
655         elif rotation > 180:
656             quad = rotation - 180
657             h1 = x0 / math.cos(math.radians(quad))
658             h2 = y0 / math.cos(math.radians(90 - quad))
659         elif rotation > 90:
660             quad = rotation - 90
661             h1 = (figure_box.y1 - y0) / math.cos(math.radians(quad))
662             h2 = x0 / math.cos(math.radians(90 - quad))
663         else:
664             h1 = (figure_box.x1 - x0) / math.cos(math.radians(rotation))
665             h2 = (figure_box.y1 - y0) / math.cos(math.radians(90 - rotation))
666 
667         return min(h1, h2)
668 
669     def _get_rendered_text_width(self, text):
670         """
671         Return the width of a given text string, in pixels.
672         """
673 
674         w, h, d = self._renderer.get_text_width_height_descent(
675             text,
676             self.get_fontproperties(),
677             cbook.is_math_text(text))
678         return math.ceil(w)
679 
680     def _get_wrapped_text(self):
681         """
682         Return a copy of the text string with new lines added so that the text
683         is wrapped relative to the parent figure (if `get_wrap` is True).
684         """
685         if not self.get_wrap():
686             return self.get_text()
687 
688         # Not fit to handle breaking up latex syntax correctly, so
689         # ignore latex for now.
690         if self.get_usetex():
691             return self.get_text()
692 
693         # Build the line incrementally, for a more accurate measure of length
694         line_width = self._get_wrap_line_width()
695         wrapped_lines = []
696 
697         # New lines in the user's text force a split
698         unwrapped_lines = self.get_text().split('\n')
699 
700         # Now wrap each individual unwrapped line
701         for unwrapped_line in unwrapped_lines:
702 
703             sub_words = unwrapped_line.split(' ')
704             # Remove items from sub_words as we go, so stop when empty
705             while len(sub_words) > 0:
706                 if len(sub_words) == 1:
707                     # Only one word, so just add it to the end
708                     wrapped_lines.append(sub_words.pop(0))
709                     continue
710 
711                 for i in range(2, len(sub_words) + 1):
712                     # Get width of all words up to and including here
713                     line = ' '.join(sub_words[:i])
714                     current_width = self._get_rendered_text_width(line)
715 
716                     # If all these words are too wide, append all not including
717                     # last word
718                     if current_width > line_width:
719                         wrapped_lines.append(' '.join(sub_words[:i - 1]))
720                         sub_words = sub_words[i - 1:]
721                         break
722 
723                     # Otherwise if all words fit in the width, append them all
724                     elif i == len(sub_words):
725                         wrapped_lines.append(' '.join(sub_words[:i]))
726                         sub_words = []
727                         break
728 
729         return '\n'.join(wrapped_lines)
730 
731     @artist.allow_rasterization
732     def draw(self, renderer):
733         # docstring inherited
734 
735         if renderer is not None:
736             self._renderer = renderer
737         if not self.get_visible():
738             return
739         if self.get_text() == '':
740             return
741 
742         renderer.open_group('text', self.get_gid())
743 
744         with self._cm_set(text=self._get_wrapped_text()):
745             bbox, info, descent = self._get_layout(renderer)
746             trans = self.get_transform()
747 
748             # don't use self.get_position here, which refers to text
749             # position in Text:
750             posx = float(self.convert_xunits(self._x))
751             posy = float(self.convert_yunits(self._y))
752             posx, posy = trans.transform((posx, posy))
753             if not np.isfinite(posx) or not np.isfinite(posy):
754                 _log.warning("posx and posy should be finite values")
755                 return
756             canvasw, canvash = renderer.get_canvas_width_height()
757 
758             # Update the location and size of the bbox
759             # (`.patches.FancyBboxPatch`), and draw it.
760             if self._bbox_patch:
761                 self.update_bbox_position_size(renderer)
762                 self._bbox_patch.draw(renderer)
763 
764             gc = renderer.new_gc()
765             gc.set_foreground(self.get_color())
766             gc.set_alpha(self.get_alpha())
767             gc.set_url(self._url)
768             gc.set_antialiased(self._antialiased)
769             self._set_gc_clip(gc)
770 
771             angle = self.get_rotation()
772 
773             for line, wh, x, y in info:
774 
775                 mtext = self if len(info) == 1 else None
776                 x = x + posx
777                 y = y + posy
778                 if renderer.flipy():
779                     y = canvash - y
780                 clean_line, ismath = self._preprocess_math(line)
781 
782                 if self.get_path_effects():
783                     from matplotlib.patheffects import PathEffectRenderer
784                     textrenderer = PathEffectRenderer(
785                         self.get_path_effects(), renderer)
786                 else:
787                     textrenderer = renderer
788 
789                 if self.get_usetex():
790                     textrenderer.draw_tex(gc, x, y, clean_line,
791                                           self._fontproperties, angle,
792                                           mtext=mtext)
793                 else:
794                     textrenderer.draw_text(gc, x, y, clean_line,
795                                            self._fontproperties, angle,
796                                            ismath=ismath, mtext=mtext)
797 
798         gc.restore()
799         renderer.close_group('text')
800         self.stale = False
801 
802     def get_color(self):
803         """Return the color of the text."""
804         return self._color
805 
806     def get_fontproperties(self):
807         """Return the `.font_manager.FontProperties`."""
808         return self._fontproperties
809 
810     def get_fontfamily(self):
811         """
812         Return the list of font families used for font lookup.
813 
814         See Also
815         --------
816         .font_manager.FontProperties.get_family
817         """
818         return self._fontproperties.get_family()
819 
820     def get_fontname(self):
821         """
822         Return the font name as a string.
823 
824         See Also
825         --------
826         .font_manager.FontProperties.get_name
827         """
828         return self._fontproperties.get_name()
829 
830     def get_fontstyle(self):
831         """
832         Return the font style as a string.
833 
834         See Also
835         --------
836         .font_manager.FontProperties.get_style
837         """
838         return self._fontproperties.get_style()
839 
840     def get_fontsize(self):
841         """
842         Return the font size as an integer.
843 
844         See Also
845         --------
846         .font_manager.FontProperties.get_size_in_points
847         """
848         return self._fontproperties.get_size_in_points()
849 
850     def get_fontvariant(self):
851         """
852         Return the font variant as a string.
853 
854         See Also
855         --------
856         .font_manager.FontProperties.get_variant
857         """
858         return self._fontproperties.get_variant()
859 
860     def get_fontweight(self):
861         """
862         Return the font weight as a string or a number.
863 
864         See Also
865         --------
866         .font_manager.FontProperties.get_weight
867         """
868         return self._fontproperties.get_weight()
869 
870     def get_stretch(self):
871         """
872         Return the font stretch as a string or a number.
873 
874         See Also
875         --------
876         .font_manager.FontProperties.get_stretch
877         """
878         return self._fontproperties.get_stretch()
879 
880     def get_horizontalalignment(self):
881         """
882         Return the horizontal alignment as a string.  Will be one of
883         'left', 'center' or 'right'.
884         """
885         return self._horizontalalignment
886 
887     def get_unitless_position(self):
888         """Return the (x, y) unitless position of the text."""
889         # This will get the position with all unit information stripped away.
890         # This is here for convenience since it is done in several locations.
891         x = float(self.convert_xunits(self._x))
892         y = float(self.convert_yunits(self._y))
893         return x, y
894 
895     def get_position(self):
896         """Return the (x, y) position of the text."""
897         # This should return the same data (possible unitized) as was
898         # specified with 'set_x' and 'set_y'.
899         return self._x, self._y
900 
901     def get_text(self):
902         """Return the text string."""
903         return self._text
904 
905     def get_verticalalignment(self):
906         """
907         Return the vertical alignment as a string.  Will be one of
908         'top', 'center', 'bottom', 'baseline' or 'center_baseline'.
909         """
910         return self._verticalalignment
911 
912     def get_window_extent(self, renderer=None, dpi=None):
913         """
914         Return the `.Bbox` bounding the text, in display units.
915 
916         In addition to being used internally, this is useful for specifying
917         clickable regions in a png file on a web page.
918 
919         Parameters
920         ----------
921         renderer : Renderer, optional
922             A renderer is needed to compute the bounding box.  If the artist
923             has already been drawn, the renderer is cached; thus, it is only
924             necessary to pass this argument when calling `get_window_extent`
925             before the first draw.  In practice, it is usually easier to
926             trigger a draw first, e.g. by calling
927             `~.Figure.draw_without_rendering` or ``plt.show()``.
928 
929         dpi : float, optional
930             The dpi value for computing the bbox, defaults to
931             ``self.figure.dpi`` (*not* the renderer dpi); should be set e.g. if
932             to match regions with a figure saved with a custom dpi value.
933         """
934         if not self.get_visible():
935             return Bbox.unit()
936         if dpi is None:
937             dpi = self.figure.dpi
938         if self.get_text() == '':
939             with cbook._setattr_cm(self.figure, dpi=dpi):
940                 tx, ty = self._get_xy_display()
941                 return Bbox.from_bounds(tx, ty, 0, 0)
942 
943         if renderer is not None:
944             self._renderer = renderer
945         if self._renderer is None:
946             self._renderer = self.figure._get_renderer()
947         if self._renderer is None:
948             raise RuntimeError(
949                 "Cannot get window extent of text w/o renderer. You likely "
950                 "want to call 'figure.draw_without_rendering()' first.")
951 
952         with cbook._setattr_cm(self.figure, dpi=dpi):
953             bbox, info, descent = self._get_layout(self._renderer)
954             x, y = self.get_unitless_position()
955             x, y = self.get_transform().transform((x, y))
956             bbox = bbox.translated(x, y)
957             return bbox
958 
959     def set_backgroundcolor(self, color):
960         """
961         Set the background color of the text by updating the bbox.
962 
963         Parameters
964         ----------
965         color : color
966 
967         See Also
968         --------
969         .set_bbox : To change the position of the bounding box
970         """
971         if self._bbox_patch is None:
972             self.set_bbox(dict(facecolor=color, edgecolor=color))
973         else:
974             self._bbox_patch.update(dict(facecolor=color))
975 
976         self._update_clip_properties()
977         self.stale = True
978 
979     def set_color(self, color):
980         """
981         Set the foreground color of the text
982 
983         Parameters
984         ----------
985         color : color
986         """
987         # "auto" is only supported by axisartist, but we can just let it error
988         # out at draw time for simplicity.
989         if not cbook._str_equal(color, "auto"):
990             mpl.colors._check_color_like(color=color)
991         self._color = color
992         self.stale = True
993 
994     def set_horizontalalignment(self, align):
995         """
996         Set the horizontal alignment relative to the anchor point.
997 
998         See also :doc:`/gallery/text_labels_and_annotations/text_alignment`.
999 
1000         Parameters
1001         ----------
1002         align : {'left', 'center', 'right'}
1003         """
1004         _api.check_in_list(['center', 'right', 'left'], align=align)
1005         self._horizontalalignment = align
1006         self.stale = True
1007 
1008     def set_multialignment(self, align):
1009         """
1010         Set the text alignment for multiline texts.
1011 
1012         The layout of the bounding box of all the lines is determined by the
1013         horizontalalignment and verticalalignment properties. This property
1014         controls the alignment of the text lines within that box.
1015 
1016         Parameters
1017         ----------
1018         align : {'left', 'right', 'center'}
1019         """
1020         _api.check_in_list(['center', 'right', 'left'], align=align)
1021         self._multialignment = align
1022         self.stale = True
1023 
1024     def set_linespacing(self, spacing):
1025         """
1026         Set the line spacing as a multiple of the font size.
1027 
1028         The default line spacing is 1.2.
1029 
1030         Parameters
1031         ----------
1032         spacing : float (multiple of font size)
1033         """
1034         _api.check_isinstance(Real, spacing=spacing)
1035         self._linespacing = spacing
1036         self.stale = True
1037 
1038     def set_fontfamily(self, fontname):
1039         """
1040         Set the font family.  Can be either a single string, or a list of
1041         strings in decreasing priority.  Each string may be either a real font
1042         name or a generic font class name.  If the latter, the specific font
1043         names will be looked up in the corresponding rcParams.
1044 
1045         If a `Text` instance is constructed with ``fontfamily=None``, then the
1046         font is set to :rc:`font.family`, and the
1047         same is done when `set_fontfamily()` is called on an existing
1048         `Text` instance.
1049 
1050         Parameters
1051         ----------
1052         fontname : {FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', \
1053 'monospace'}
1054 
1055         See Also
1056         --------
1057         .font_manager.FontProperties.set_family
1058         """
1059         self._fontproperties.set_family(fontname)
1060         self.stale = True
1061 
1062     def set_fontvariant(self, variant):
1063         """
1064         Set the font variant.
1065 
1066         Parameters
1067         ----------
1068         variant : {'normal', 'small-caps'}
1069 
1070         See Also
1071         --------
1072         .font_manager.FontProperties.set_variant
1073         """
1074         self._fontproperties.set_variant(variant)
1075         self.stale = True
1076 
1077     def set_fontstyle(self, fontstyle):
1078         """
1079         Set the font style.
1080 
1081         Parameters
1082         ----------
1083         fontstyle : {'normal', 'italic', 'oblique'}
1084 
1085         See Also
1086         --------
1087         .font_manager.FontProperties.set_style
1088         """
1089         self._fontproperties.set_style(fontstyle)
1090         self.stale = True
1091 
1092     def set_fontsize(self, fontsize):
1093         """
1094         Set the font size.
1095 
1096         Parameters
1097         ----------
1098         fontsize : float or {'xx-small', 'x-small', 'small', 'medium', \
1099 'large', 'x-large', 'xx-large'}
1100             If a float, the fontsize in points. The string values denote sizes
1101             relative to the default font size.
1102 
1103         See Also
1104         --------
1105         .font_manager.FontProperties.set_size
1106         """
1107         self._fontproperties.set_size(fontsize)
1108         self.stale = True
1109 
1110     def get_math_fontfamily(self):
1111         """
1112         Return the font family name for math text rendered by Matplotlib.
1113 
1114         The default value is :rc:`mathtext.fontset`.
1115 
1116         See Also
1117         --------
1118         set_math_fontfamily
1119         """
1120         return self._fontproperties.get_math_fontfamily()
1121 
1122     def set_math_fontfamily(self, fontfamily):
1123         """
1124         Set the font family for math text rendered by Matplotlib.
1125 
1126         This does only affect Matplotlib's own math renderer. It has no effect
1127         when rendering with TeX (``usetex=True``).
1128 
1129         Parameters
1130         ----------
1131         fontfamily : str
1132             The name of the font family.
1133 
1134             Available font families are defined in the
1135             :ref:`default matplotlibrc file
1136             <customizing-with-matplotlibrc-files>`.
1137 
1138         See Also
1139         --------
1140         get_math_fontfamily
1141         """
1142         self._fontproperties.set_math_fontfamily(fontfamily)
1143 
1144     def set_fontweight(self, weight):
1145         """
1146         Set the font weight.
1147 
1148         Parameters
1149         ----------
1150         weight : {a numeric value in range 0-1000, 'ultralight', 'light', \
1151 'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', \
1152 'demi', 'bold', 'heavy', 'extra bold', 'black'}
1153 
1154         See Also
1155         --------
1156         .font_manager.FontProperties.set_weight
1157         """
1158         self._fontproperties.set_weight(weight)
1159         self.stale = True
1160 
1161     def set_fontstretch(self, stretch):
1162         """
1163         Set the font stretch (horizontal condensation or expansion).
1164 
1165         Parameters
1166         ----------
1167         stretch : {a numeric value in range 0-1000, 'ultra-condensed', \
1168 'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', \
1169 'expanded', 'extra-expanded', 'ultra-expanded'}
1170 
1171         See Also
1172         --------
1173         .font_manager.FontProperties.set_stretch
1174         """
1175         self._fontproperties.set_stretch(stretch)
1176         self.stale = True
1177 
1178     def set_position(self, xy):
1179         """
1180         Set the (*x*, *y*) position of the text.
1181 
1182         Parameters
1183         ----------
1184         xy : (float, float)
1185         """
1186         self.set_x(xy[0])
1187         self.set_y(xy[1])
1188 
1189     def set_x(self, x):
1190         """
1191         Set the *x* position of the text.
1192 
1193         Parameters
1194         ----------
1195         x : float
1196         """
1197         self._x = x
1198         self.stale = True
1199 
1200     def set_y(self, y):
1201         """
1202         Set the *y* position of the text.
1203 
1204         Parameters
1205         ----------
1206         y : float
1207         """
1208         self._y = y
1209         self.stale = True
1210 
1211     def set_rotation(self, s):
1212         """
1213         Set the rotation of the text.
1214 
1215         Parameters
1216         ----------
1217         s : float or {'vertical', 'horizontal'}
1218             The rotation angle in degrees in mathematically positive direction
1219             (counterclockwise). 'horizontal' equals 0, 'vertical' equals 90.
1220         """
1221         if isinstance(s, Real):
1222             self._rotation = float(s) % 360
1223         elif cbook._str_equal(s, 'horizontal') or s is None:
1224             self._rotation = 0.
1225         elif cbook._str_equal(s, 'vertical'):
1226             self._rotation = 90.
1227         else:
1228             raise ValueError("rotation must be 'vertical', 'horizontal' or "
1229                              f"a number, not {s}")
1230         self.stale = True
1231 
1232     def set_transform_rotates_text(self, t):
1233         """
1234         Whether rotations of the transform affect the text direction.
1235 
1236         Parameters
1237         ----------
1238         t : bool
1239         """
1240         self._transform_rotates_text = t
1241         self.stale = True
1242 
1243     def set_verticalalignment(self, align):
1244         """
1245         Set the vertical alignment relative to the anchor point.
1246 
1247         See also :doc:`/gallery/text_labels_and_annotations/text_alignment`.
1248 
1249         Parameters
1250         ----------
1251         align : {'bottom', 'baseline', 'center', 'center_baseline', 'top'}
1252         """
1253         _api.check_in_list(
1254             ['top', 'bottom', 'center', 'baseline', 'center_baseline'],
1255             align=align)
1256         self._verticalalignment = align
1257         self.stale = True
1258 
1259     def set_text(self, s):
1260         r"""
1261         Set the text string *s*.
1262 
1263         It may contain newlines (``\n``) or math in LaTeX syntax.
1264 
1265         Parameters
1266         ----------
1267         s : object
1268             Any object gets converted to its `str` representation, except for
1269             ``None`` which is converted to an empty string.
1270         """
1271         if s is None:
1272             s = ''
1273         if s != self._text:
1274             self._text = str(s)
1275             self.stale = True
1276 
1277     def _preprocess_math(self, s):
1278         """
1279         Return the string *s* after mathtext preprocessing, and the kind of
1280         mathtext support needed.
1281 
1282         - If *self* is configured to use TeX, return *s* unchanged except that
1283           a single space gets escaped, and the flag "TeX".
1284         - Otherwise, if *s* is mathtext (has an even number of unescaped dollar
1285           signs) and ``parse_math`` is not set to False, return *s* and the
1286           flag True.
1287         - Otherwise, return *s* with dollar signs unescaped, and the flag
1288           False.
1289         """
1290         if self.get_usetex():
1291             if s == " ":
1292                 s = r"\ "
1293             return s, "TeX"
1294         elif not self.get_parse_math():
1295             return s, False
1296         elif cbook.is_math_text(s):
1297             return s, True
1298         else:
1299             return s.replace(r"\$", "$"), False
1300 
1301     def set_fontproperties(self, fp):
1302         """
1303         Set the font properties that control the text.
1304 
1305         Parameters
1306         ----------
1307         fp : `.font_manager.FontProperties` or `str` or `pathlib.Path`
1308             If a `str`, it is interpreted as a fontconfig pattern parsed by
1309             `.FontProperties`.  If a `pathlib.Path`, it is interpreted as the
1310             absolute path to a font file.
1311         """
1312         self._fontproperties = FontProperties._from_any(fp).copy()
1313         self.stale = True
1314 
1315     def set_usetex(self, usetex):
1316         """
1317         Parameters
1318         ----------
1319         usetex : bool or None
1320             Whether to render using TeX, ``None`` means to use
1321             :rc:`text.usetex`.
1322         """
1323         if usetex is None:
1324             self._usetex = mpl.rcParams['text.usetex']
1325         else:
1326             self._usetex = bool(usetex)
1327         self.stale = True
1328 
1329     def get_usetex(self):
1330         """Return whether this `Text` object uses TeX for rendering."""
1331         return self._usetex
1332 
1333     def set_parse_math(self, parse_math):
1334         """
1335         Override switch to disable any mathtext parsing for this `Text`.
1336 
1337         Parameters
1338         ----------
1339         parse_math : bool
1340             If False, this `Text` will never use mathtext.  If True, mathtext
1341             will be used if there is an even number of unescaped dollar signs.
1342         """
1343         self._parse_math = bool(parse_math)
1344 
1345     def get_parse_math(self):
1346         """Return whether mathtext parsing is considered for this `Text`."""
1347         return self._parse_math
1348 
1349     def set_fontname(self, fontname):
1350         """
1351         Alias for `set_family`.
1352 
1353         One-way alias only: the getter differs.
1354 
1355         Parameters
1356         ----------
1357         fontname : {FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', \
1358 'monospace'}
1359 
1360         See Also
1361         --------
1362         .font_manager.FontProperties.set_family
1363 
1364         """
1365         return self.set_family(fontname)

</code><intended_behavior>In the context of aligning mathtext markers, if adjustments within the `Text` class could impact the rendering of mathtext (such as alignment and positioning), the class should ensure that any mathtext rendered as part of a marker is centered based on the text's bounding box dimensions. The class should provide a mechanism to calculate and apply the correct alignment for mathtext specifically when it is used as a marker. This ensures that mathtext markers are rendered with the same center alignment as other markers, preserving the visual consistency across different marker types. Any modification should cater specifically to scenarios where text is used as a marker, ensuring that general text rendering functionality remains unaltered for regular plot annotations or labels.</intended_behavior>]
2025-10-18 14:33:27.806 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/markers.py</file>
<class>MarkerStyle</class>
<method>_set_mathtext_path</method>
<code>
497     def _set_mathtext_path(self):
498         """
499         Draw mathtext markers '$...$' using `.TextPath` object.
500 
501         Submitted by tcb
502         """
503         from matplotlib.text import TextPath
504 
505         # again, the properties could be initialised just once outside
506         # this function
507         text = TextPath(xy=(0, 0), s=self.get_marker(),
508                         usetex=mpl.rcParams['text.usetex'])
509         if len(text.vertices) == 0:
510             return
511 
512         xmin, ymin = text.vertices.min(axis=0)
513         xmax, ymax = text.vertices.max(axis=0)
514         width = xmax - xmin
515         height = ymax - ymin
516         max_dim = max(width, height)
517         self._transform = Affine2D() \
518             .translate(-xmin + 0.5 * -width, -ymin + 0.5 * -height) \
519             .scale(1.0 / max_dim)
520         self._path = text
521         self._snap = False

</code><intended_behavior>This method should ensure that when mathtext is used to define a marker, it is correctly centered on the plot point it represents. To fix the issue, the method should be adjusted or extended to calculate the center of the mathtext marker accurately and render it so that it aligns perfectly with the intended plot coordinates. This might involve recalculating the anchor point for the mathtext marker or adjusting how the marker's bounding box is computed to ensure central alignment. The change should ensure that mathtext markers behave consistently with other marker types in terms of alignment, without affecting how non-mathtext markers are rendered.</intended_behavior>, <file>lib/matplotlib/markers.py</file>
<class>MarkerStyle</class>
<method>None</method>
<code>
155 class MarkerStyle:
156     """
157     A class representing marker types.
158 
159     Instances are immutable. If you need to change anything, create a new
160     instance.
161 
162     Attributes
163     ----------
164     markers : dict
165         All known markers.
166     filled_markers : tuple
167         All known filled markers. This is a subset of *markers*.
168     fillstyles : tuple
169         The supported fillstyles.
170     """
171 
172     markers = {
173         '.': 'point',
174         ',': 'pixel',
175         'o': 'circle',
176         'v': 'triangle_down',
177         '^': 'triangle_up',
178         '<': 'triangle_left',
179         '>': 'triangle_right',
180         '1': 'tri_down',
181         '2': 'tri_up',
182         '3': 'tri_left',
183         '4': 'tri_right',
184         '8': 'octagon',
185         's': 'square',
186         'p': 'pentagon',
187         '*': 'star',
188         'h': 'hexagon1',
189         'H': 'hexagon2',
190         '+': 'plus',
191         'x': 'x',
192         'D': 'diamond',
193         'd': 'thin_diamond',
194         '|': 'vline',
195         '_': 'hline',
196         'P': 'plus_filled',
197         'X': 'x_filled',
198         TICKLEFT: 'tickleft',
199         TICKRIGHT: 'tickright',
200         TICKUP: 'tickup',
201         TICKDOWN: 'tickdown',
202         CARETLEFT: 'caretleft',
203         CARETRIGHT: 'caretright',
204         CARETUP: 'caretup',
205         CARETDOWN: 'caretdown',
206         CARETLEFTBASE: 'caretleftbase',
207         CARETRIGHTBASE: 'caretrightbase',
208         CARETUPBASE: 'caretupbase',
209         CARETDOWNBASE: 'caretdownbase',
210         "None": 'nothing',
211         "none": 'nothing',
212         ' ': 'nothing',
213         '': 'nothing'
214     }
215 
216     # Just used for informational purposes.  is_filled()
217     # is calculated in the _set_* functions.
218     filled_markers = (
219         '.', 'o', 'v', '^', '<', '>', '8', 's', 'p', '*', 'h', 'H', 'D', 'd',
220         'P', 'X')
221 
222     fillstyles = ('full', 'left', 'right', 'bottom', 'top', 'none')
223     _half_fillstyles = ('left', 'right', 'bottom', 'top')
224 
225     def __init__(self, marker,
226                  fillstyle=None, transform=None, capstyle=None, joinstyle=None):
227         """
228         Parameters
229         ----------
230         marker : str, array-like, Path, MarkerStyle, or None
231             - Another instance of *MarkerStyle* copies the details of that
232               ``marker``.
233             - *None* means no marker.  This is the deprecated default.
234             - For other possible marker values, see the module docstring
235               `matplotlib.markers`.
236 
237         fillstyle : str, default: :rc:`markers.fillstyle`
238             One of 'full', 'left', 'right', 'bottom', 'top', 'none'.
239 
240         transform : transforms.Transform, default: None
241             Transform that will be combined with the native transform of the
242             marker.
243 
244         capstyle : `.CapStyle` or %(CapStyle)s, default: None
245             Cap style that will override the default cap style of the marker.
246 
247         joinstyle : `.JoinStyle` or %(JoinStyle)s, default: None
248             Join style that will override the default join style of the marker.
249         """
250         self._marker_function = None
251         self._user_transform = transform
252         self._user_capstyle = CapStyle(capstyle) if capstyle is not None else None
253         self._user_joinstyle = JoinStyle(joinstyle) if joinstyle is not None else None
254         self._set_fillstyle(fillstyle)
255         self._set_marker(marker)
256 
257     def _recache(self):
258         if self._marker_function is None:
259             return
260         self._path = _empty_path
261         self._transform = IdentityTransform()
262         self._alt_path = None
263         self._alt_transform = None
264         self._snap_threshold = None
265         self._joinstyle = JoinStyle.round
266         self._capstyle = self._user_capstyle or CapStyle.butt
267         # Initial guess: Assume the marker is filled unless the fillstyle is
268         # set to 'none'. The marker function will override this for unfilled
269         # markers.
270         self._filled = self._fillstyle != 'none'
271         self._marker_function()
272 
273     def __bool__(self):
274         return bool(len(self._path.vertices))
275 
276     def is_filled(self):
277         return self._filled
278 
279     def get_fillstyle(self):
280         return self._fillstyle
281 
282     def _set_fillstyle(self, fillstyle):
283         """
284         Set the fillstyle.
285 
286         Parameters
287         ----------
288         fillstyle : {'full', 'left', 'right', 'bottom', 'top', 'none'}
289             The part of the marker surface that is colored with
290             markerfacecolor.
291         """
292         if fillstyle is None:
293             fillstyle = mpl.rcParams['markers.fillstyle']
294         _api.check_in_list(self.fillstyles, fillstyle=fillstyle)
295         self._fillstyle = fillstyle
296         self._recache()
297 
298     def get_joinstyle(self):
299         return self._joinstyle.name
300 
301     def get_capstyle(self):
302         return self._capstyle.name
303 
304     def get_marker(self):
305         return self._marker
306 
307     def _set_marker(self, marker):
308         """
309         Set the marker.
310 
311         Parameters
312         ----------
313         marker : str, array-like, Path, MarkerStyle, or None, default: None
314             - Another instance of *MarkerStyle* copies the details of that
315               ``marker``.
316             - *None* means no marker.
317             - For other possible marker values see the module docstring
318               `matplotlib.markers`.
319         """
320         if (isinstance(marker, np.ndarray) and marker.ndim == 2 and
321                 marker.shape[1] == 2):
322             self._marker_function = self._set_vertices
323         elif isinstance(marker, str) and cbook.is_math_text(marker):
324             self._marker_function = self._set_mathtext_path
325         elif isinstance(marker, Path):
326             self._marker_function = self._set_path_marker
327         elif (isinstance(marker, Sized) and len(marker) in (2, 3) and
328                 marker[1] in (0, 1, 2)):
329             self._marker_function = self._set_tuple_marker
330         elif (not isinstance(marker, (np.ndarray, list)) and
331               marker in self.markers):
332             self._marker_function = getattr(
333                 self, '_set_' + self.markers[marker])
334         elif isinstance(marker, MarkerStyle):
335             self.__dict__ = copy.deepcopy(marker.__dict__)
336 
337         else:
338             try:
339                 Path(marker)
340                 self._marker_function = self._set_vertices
341             except ValueError as err:
342                 raise ValueError(
343                     f'Unrecognized marker style {marker!r}') from err
344 
345         if not isinstance(marker, MarkerStyle):
346             self._marker = marker
347             self._recache()
348 
349     def get_path(self):
350         """
351         Return a `.Path` for the primary part of the marker.
352 
353         For unfilled markers this is the whole marker, for filled markers,
354         this is the area to be drawn with *markerfacecolor*.
355         """
356         return self._path
357 
358     def get_transform(self):
359         """
360         Return the transform to be applied to the `.Path` from
361         `MarkerStyle.get_path()`.
362         """
363         if self._user_transform is None:
364             return self._transform.frozen()
365         else:
366             return (self._transform + self._user_transform).frozen()
367 
368     def get_alt_path(self):
369         """
370         Return a `.Path` for the alternate part of the marker.
371 
372         For unfilled markers, this is *None*; for filled markers, this is the
373         area to be drawn with *markerfacecoloralt*.
374         """
375         return self._alt_path
376 
377     def get_alt_transform(self):
378         """
379         Return the transform to be applied to the `.Path` from
380         `MarkerStyle.get_alt_path()`.
381         """
382         if self._user_transform is None:
383             return self._alt_transform.frozen()
384         else:
385             return (self._alt_transform + self._user_transform).frozen()
386 
387     def get_snap_threshold(self):
388         return self._snap_threshold
389 
390     def get_user_transform(self):
391         """Return user supplied part of marker transform."""
392         if self._user_transform is not None:
393             return self._user_transform.frozen()
394 
395     def transformed(self, transform: Affine2D):
396         """
397         Return a new version of this marker with the transform applied.
398 
399         Parameters
400         ----------
401         transform : `~matplotlib.transforms.Affine2D`, default: None
402             Transform will be combined with current user supplied transform.
403         """
404         new_marker = MarkerStyle(self)
405         if new_marker._user_transform is not None:
406             new_marker._user_transform += transform
407         else:
408             new_marker._user_transform = transform
409         return new_marker
410 
411     def rotated(self, *, deg=None, rad=None):
412         """
413         Return a new version of this marker rotated by specified angle.
414 
415         Parameters
416         ----------
417         deg : float, default: None
418             Rotation angle in degrees.
419 
420         rad : float, default: None
421             Rotation angle in radians.
422 
423         .. note:: You must specify exactly one of deg or rad.
424         """
425         if deg is None and rad is None:
426             raise ValueError('One of deg or rad is required')
427         if deg is not None and rad is not None:
428             raise ValueError('Only one of deg and rad can be supplied')
429         new_marker = MarkerStyle(self)
430         if new_marker._user_transform is None:
431             new_marker._user_transform = Affine2D()
432 
433         if deg is not None:
434             new_marker._user_transform.rotate_deg(deg)
435         if rad is not None:
436             new_marker._user_transform.rotate(rad)
437 
438         return new_marker
439 
440     def scaled(self, sx, sy=None):
441         """
442         Return new marker scaled by specified scale factors.
443 
444         If *sy* is None, the same scale is applied in both the *x*- and
445         *y*-directions.
446 
447         Parameters
448         ----------
449         sx : float
450             *X*-direction scaling factor.
451         sy : float, default: None
452             *Y*-direction scaling factor.
453         """
454         if sy is None:
455             sy = sx
456 
457         new_marker = MarkerStyle(self)
458         _transform = new_marker._user_transform or Affine2D()
459         new_marker._user_transform = _transform.scale(sx, sy)
460         return new_marker
461 
462     def _set_nothing(self):
463         self._filled = False
464 
465     def _set_custom_marker(self, path):
466         rescale = np.max(np.abs(path.vertices))  # max of x's and y's.
467         self._transform = Affine2D().scale(0.5 / rescale)
468         self._path = path
469 
470     def _set_path_marker(self):
471         self._set_custom_marker(self._marker)
472 
473     def _set_vertices(self):
474         self._set_custom_marker(Path(self._marker))
475 
476     def _set_tuple_marker(self):
477         marker = self._marker
478         if len(marker) == 2:
479             numsides, rotation = marker[0], 0.0
480         elif len(marker) == 3:
481             numsides, rotation = marker[0], marker[2]
482         symstyle = marker[1]
483         if symstyle == 0:
484             self._path = Path.unit_regular_polygon(numsides)
485             self._joinstyle = self._user_joinstyle or JoinStyle.miter
486         elif symstyle == 1:
487             self._path = Path.unit_regular_star(numsides)
488             self._joinstyle = self._user_joinstyle or JoinStyle.bevel
489         elif symstyle == 2:
490             self._path = Path.unit_regular_asterisk(numsides)
491             self._filled = False
492             self._joinstyle = self._user_joinstyle or JoinStyle.bevel
493         else:
494             raise ValueError(f"Unexpected tuple marker: {marker}")
495         self._transform = Affine2D().scale(0.5).rotate_deg(rotation)
496 
497     def _set_mathtext_path(self):
498         """
499         Draw mathtext markers '$...$' using `.TextPath` object.
500 
501         Submitted by tcb
502         """
503         from matplotlib.text import TextPath
504 
505         # again, the properties could be initialised just once outside
506         # this function
507         text = TextPath(xy=(0, 0), s=self.get_marker(),
508                         usetex=mpl.rcParams['text.usetex'])
509         if len(text.vertices) == 0:
510             return
511 
512         xmin, ymin = text.vertices.min(axis=0)
513         xmax, ymax = text.vertices.max(axis=0)
514         width = xmax - xmin
515         height = ymax - ymin
516         max_dim = max(width, height)
517         self._transform = Affine2D() \
518             .translate(-xmin + 0.5 * -width, -ymin + 0.5 * -height) \
519             .scale(1.0 / max_dim)
520         self._path = text
521         self._snap = False
522 
523     def _half_fill(self):
524         return self.get_fillstyle() in self._half_fillstyles
525 
526     def _set_circle(self, size=1.0):
527         self._transform = Affine2D().scale(0.5 * size)
528         self._snap_threshold = np.inf
529         if not self._half_fill():
530             self._path = Path.unit_circle()
531         else:
532             self._path = self._alt_path = Path.unit_circle_righthalf()
533             fs = self.get_fillstyle()
534             self._transform.rotate_deg(
535                 {'right': 0, 'top': 90, 'left': 180, 'bottom': 270}[fs])
536             self._alt_transform = self._transform.frozen().rotate_deg(180.)
537 
538     def _set_point(self):
539         self._set_circle(size=0.5)
540 
541     def _set_pixel(self):
542         self._path = Path.unit_rectangle()
543         # Ideally, you'd want -0.5, -0.5 here, but then the snapping
544         # algorithm in the Agg backend will round this to a 2x2
545         # rectangle from (-1, -1) to (1, 1).  By offsetting it
546         # slightly, we can force it to be (0, 0) to (1, 1), which both
547         # makes it only be a single pixel and places it correctly
548         # aligned to 1-width stroking (i.e. the ticks).  This hack is
549         # the best of a number of bad alternatives, mainly because the
550         # backends are not aware of what marker is actually being used
551         # beyond just its path data.
552         self._transform = Affine2D().translate(-0.49999, -0.49999)
553         self._snap_threshold = None
554 
555     _triangle_path = Path._create_closed([[0, 1], [-1, -1], [1, -1]])
556     # Going down halfway looks to small.  Golden ratio is too far.
557     _triangle_path_u = Path._create_closed([[0, 1], [-3/5, -1/5], [3/5, -1/5]])
558     _triangle_path_d = Path._create_closed(
559         [[-3/5, -1/5], [3/5, -1/5], [1, -1], [-1, -1]])
560     _triangle_path_l = Path._create_closed([[0, 1], [0, -1], [-1, -1]])
561     _triangle_path_r = Path._create_closed([[0, 1], [0, -1], [1, -1]])
562 
563     def _set_triangle(self, rot, skip):
564         self._transform = Affine2D().scale(0.5).rotate_deg(rot)
565         self._snap_threshold = 5.0
566 
567         if not self._half_fill():
568             self._path = self._triangle_path
569         else:
570             mpaths = [self._triangle_path_u,
571                       self._triangle_path_l,
572                       self._triangle_path_d,
573                       self._triangle_path_r]
574 
575             fs = self.get_fillstyle()
576             if fs == 'top':
577                 self._path = mpaths[(0 + skip) % 4]
578                 self._alt_path = mpaths[(2 + skip) % 4]
579             elif fs == 'bottom':
580                 self._path = mpaths[(2 + skip) % 4]
581                 self._alt_path = mpaths[(0 + skip) % 4]
582             elif fs == 'left':
583                 self._path = mpaths[(1 + skip) % 4]
584                 self._alt_path = mpaths[(3 + skip) % 4]
585             else:
586                 self._path = mpaths[(3 + skip) % 4]
587                 self._alt_path = mpaths[(1 + skip) % 4]
588 
589             self._alt_transform = self._transform
590 
591         self._joinstyle = self._user_joinstyle or JoinStyle.miter
592 
593     def _set_triangle_up(self):
594         return self._set_triangle(0.0, 0)
595 
596     def _set_triangle_down(self):
597         return self._set_triangle(180.0, 2)
598 
599     def _set_triangle_left(self):
600         return self._set_triangle(90.0, 3)
601 
602     def _set_triangle_right(self):
603         return self._set_triangle(270.0, 1)
604 
605     def _set_square(self):
606         self._transform = Affine2D().translate(-0.5, -0.5)
607         self._snap_threshold = 2.0
608         if not self._half_fill():
609             self._path = Path.unit_rectangle()
610         else:
611             # Build a bottom filled square out of two rectangles, one filled.
612             self._path = Path([[0.0, 0.0], [1.0, 0.0], [1.0, 0.5],
613                                [0.0, 0.5], [0.0, 0.0]])
614             self._alt_path = Path([[0.0, 0.5], [1.0, 0.5], [1.0, 1.0],
615                                    [0.0, 1.0], [0.0, 0.5]])
616             fs = self.get_fillstyle()
617             rotate = {'bottom': 0, 'right': 90, 'top': 180, 'left': 270}[fs]
618             self._transform.rotate_deg(rotate)
619             self._alt_transform = self._transform
620 
621         self._joinstyle = self._user_joinstyle or JoinStyle.miter
622 
623     def _set_diamond(self):
624         self._transform = Affine2D().translate(-0.5, -0.5).rotate_deg(45)
625         self._snap_threshold = 5.0
626         if not self._half_fill():
627             self._path = Path.unit_rectangle()
628         else:
629             self._path = Path([[0, 0], [1, 0], [1, 1], [0, 0]])
630             self._alt_path = Path([[0, 0], [0, 1], [1, 1], [0, 0]])
631             fs = self.get_fillstyle()
632             rotate = {'right': 0, 'top': 90, 'left': 180, 'bottom': 270}[fs]
633             self._transform.rotate_deg(rotate)
634             self._alt_transform = self._transform
635         self._joinstyle = self._user_joinstyle or JoinStyle.miter
636 
637     def _set_thin_diamond(self):
638         self._set_diamond()
639         self._transform.scale(0.6, 1.0)
640 
641     def _set_pentagon(self):
642         self._transform = Affine2D().scale(0.5)
643         self._snap_threshold = 5.0
644 
645         polypath = Path.unit_regular_polygon(5)
646 
647         if not self._half_fill():
648             self._path = polypath
649         else:
650             verts = polypath.vertices
651             y = (1 + np.sqrt(5)) / 4.
652             top = Path(verts[[0, 1, 4, 0]])
653             bottom = Path(verts[[1, 2, 3, 4, 1]])
654             left = Path([verts[0], verts[1], verts[2], [0, -y], verts[0]])
655             right = Path([verts[0], verts[4], verts[3], [0, -y], verts[0]])
656             self._path, self._alt_path = {
657                 'top': (top, bottom), 'bottom': (bottom, top),
658                 'left': (left, right), 'right': (right, left),
659             }[self.get_fillstyle()]
660             self._alt_transform = self._transform
661 
662         self._joinstyle = self._user_joinstyle or JoinStyle.miter
663 
664     def _set_star(self):
665         self._transform = Affine2D().scale(0.5)
666         self._snap_threshold = 5.0
667 
668         polypath = Path.unit_regular_star(5, innerCircle=0.381966)
669 
670         if not self._half_fill():
671             self._path = polypath
672         else:
673             verts = polypath.vertices
674             top = Path(np.concatenate([verts[0:4], verts[7:10], verts[0:1]]))
675             bottom = Path(np.concatenate([verts[3:8], verts[3:4]]))
676             left = Path(np.concatenate([verts[0:6], verts[0:1]]))
677             right = Path(np.concatenate([verts[0:1], verts[5:10], verts[0:1]]))
678             self._path, self._alt_path = {
679                 'top': (top, bottom), 'bottom': (bottom, top),
680                 'left': (left, right), 'right': (right, left),
681             }[self.get_fillstyle()]
682             self._alt_transform = self._transform
683 
684         self._joinstyle = self._user_joinstyle or JoinStyle.bevel
685 
686     def _set_hexagon1(self):
687         self._transform = Affine2D().scale(0.5)
688         self._snap_threshold = None
689 
690         polypath = Path.unit_regular_polygon(6)
691 
692         if not self._half_fill():
693             self._path = polypath
694         else:
695             verts = polypath.vertices
696             # not drawing inside lines
697             x = np.abs(np.cos(5 * np.pi / 6.))
698             top = Path(np.concatenate([[(-x, 0)], verts[[1, 0, 5]], [(x, 0)]]))
699             bottom = Path(np.concatenate([[(-x, 0)], verts[2:5], [(x, 0)]]))
700             left = Path(verts[0:4])
701             right = Path(verts[[0, 5, 4, 3]])
702             self._path, self._alt_path = {
703                 'top': (top, bottom), 'bottom': (bottom, top),
704                 'left': (left, right), 'right': (right, left),
705             }[self.get_fillstyle()]
706             self._alt_transform = self._transform
707 
708         self._joinstyle = self._user_joinstyle or JoinStyle.miter
709 
710     def _set_hexagon2(self):
711         self._transform = Affine2D().scale(0.5).rotate_deg(30)
712         self._snap_threshold = None
713 
714         polypath = Path.unit_regular_polygon(6)
715 
716         if not self._half_fill():
717             self._path = polypath
718         else:
719             verts = polypath.vertices
720             # not drawing inside lines
721             x, y = np.sqrt(3) / 4, 3 / 4.
722             top = Path(verts[[1, 0, 5, 4, 1]])
723             bottom = Path(verts[1:5])
724             left = Path(np.concatenate([
725                 [(x, y)], verts[:3], [(-x, -y), (x, y)]]))
726             right = Path(np.concatenate([
727                 [(x, y)], verts[5:2:-1], [(-x, -y)]]))
728             self._path, self._alt_path = {
729                 'top': (top, bottom), 'bottom': (bottom, top),
730                 'left': (left, right), 'right': (right, left),
731             }[self.get_fillstyle()]
732             self._alt_transform = self._transform
733 
734         self._joinstyle = self._user_joinstyle or JoinStyle.miter
735 
736     def _set_octagon(self):
737         self._transform = Affine2D().scale(0.5)
738         self._snap_threshold = 5.0
739 
740         polypath = Path.unit_regular_polygon(8)
741 
742         if not self._half_fill():
743             self._transform.rotate_deg(22.5)
744             self._path = polypath
745         else:
746             x = np.sqrt(2.) / 4.
747             self._path = self._alt_path = Path(
748                 [[0, -1], [0, 1], [-x, 1], [-1, x],
749                  [-1, -x], [-x, -1], [0, -1]])
750             fs = self.get_fillstyle()
751             self._transform.rotate_deg(
752                 {'left': 0, 'bottom': 90, 'right': 180, 'top': 270}[fs])
753             self._alt_transform = self._transform.frozen().rotate_deg(180.0)
754 
755         self._joinstyle = self._user_joinstyle or JoinStyle.miter
756 
757     _line_marker_path = Path([[0.0, -1.0], [0.0, 1.0]])
758 
759     def _set_vline(self):
760         self._transform = Affine2D().scale(0.5)
761         self._snap_threshold = 1.0
762         self._filled = False
763         self._path = self._line_marker_path
764 
765     def _set_hline(self):
766         self._set_vline()
767         self._transform = self._transform.rotate_deg(90)
768 
769     _tickhoriz_path = Path([[0.0, 0.0], [1.0, 0.0]])
770 
771     def _set_tickleft(self):
772         self._transform = Affine2D().scale(-1.0, 1.0)
773         self._snap_threshold = 1.0
774         self._filled = False
775         self._path = self._tickhoriz_path
776 
777     def _set_tickright(self):
778         self._transform = Affine2D().scale(1.0, 1.0)
779         self._snap_threshold = 1.0
780         self._filled = False
781         self._path = self._tickhoriz_path
782 
783     _tickvert_path = Path([[-0.0, 0.0], [-0.0, 1.0]])
784 
785     def _set_tickup(self):
786         self._transform = Affine2D().scale(1.0, 1.0)
787         self._snap_threshold = 1.0
788         self._filled = False
789         self._path = self._tickvert_path
790 
791     def _set_tickdown(self):
792         self._transform = Affine2D().scale(1.0, -1.0)
793         self._snap_threshold = 1.0
794         self._filled = False
795         self._path = self._tickvert_path
796 
797     _tri_path = Path([[0.0, 0.0], [0.0, -1.0],
798                       [0.0, 0.0], [0.8, 0.5],
799                       [0.0, 0.0], [-0.8, 0.5]],
800                      [Path.MOVETO, Path.LINETO,
801                       Path.MOVETO, Path.LINETO,
802                       Path.MOVETO, Path.LINETO])
803 
804     def _set_tri_down(self):
805         self._transform = Affine2D().scale(0.5)
806         self._snap_threshold = 5.0
807         self._filled = False
808         self._path = self._tri_path
809 
810     def _set_tri_up(self):
811         self._set_tri_down()
812         self._transform = self._transform.rotate_deg(180)
813 
814     def _set_tri_left(self):
815         self._set_tri_down()
816         self._transform = self._transform.rotate_deg(270)
817 
818     def _set_tri_right(self):
819         self._set_tri_down()
820         self._transform = self._transform.rotate_deg(90)
821 
822     _caret_path = Path([[-1.0, 1.5], [0.0, 0.0], [1.0, 1.5]])
823 
824     def _set_caretdown(self):
825         self._transform = Affine2D().scale(0.5)
826         self._snap_threshold = 3.0
827         self._filled = False
828         self._path = self._caret_path
829         self._joinstyle = self._user_joinstyle or JoinStyle.miter
830 
831     def _set_caretup(self):
832         self._set_caretdown()
833         self._transform = self._transform.rotate_deg(180)
834 
835     def _set_caretleft(self):
836         self._set_caretdown()
837         self._transform = self._transform.rotate_deg(270)
838 
839     def _set_caretright(self):
840         self._set_caretdown()
841         self._transform = self._transform.rotate_deg(90)
842 
843     _caret_path_base = Path([[-1.0, 0.0], [0.0, -1.5], [1.0, 0]])
844 
845     def _set_caretdownbase(self):
846         self._set_caretdown()
847         self._path = self._caret_path_base
848 
849     def _set_caretupbase(self):
850         self._set_caretdownbase()
851         self._transform = self._transform.rotate_deg(180)
852 
853     def _set_caretleftbase(self):
854         self._set_caretdownbase()
855         self._transform = self._transform.rotate_deg(270)
856 
857     def _set_caretrightbase(self):
858         self._set_caretdownbase()
859         self._transform = self._transform.rotate_deg(90)
860 
861     _plus_path = Path([[-1.0, 0.0], [1.0, 0.0],
862                        [0.0, -1.0], [0.0, 1.0]],
863                       [Path.MOVETO, Path.LINETO,
864                        Path.MOVETO, Path.LINETO])
865 
866     def _set_plus(self):
867         self._transform = Affine2D().scale(0.5)
868         self._snap_threshold = 1.0
869         self._filled = False
870         self._path = self._plus_path
871 
872     _x_path = Path([[-1.0, -1.0], [1.0, 1.0],
873                     [-1.0, 1.0], [1.0, -1.0]],
874                    [Path.MOVETO, Path.LINETO,
875                     Path.MOVETO, Path.LINETO])
876 
877     def _set_x(self):
878         self._transform = Affine2D().scale(0.5)
879         self._snap_threshold = 3.0
880         self._filled = False
881         self._path = self._x_path
882 
883     _plus_filled_path = Path._create_closed(np.array([
884         (-1, -3), (+1, -3), (+1, -1), (+3, -1), (+3, +1), (+1, +1),
885         (+1, +3), (-1, +3), (-1, +1), (-3, +1), (-3, -1), (-1, -1)]) / 6)
886     _plus_filled_path_t = Path._create_closed(np.array([
887         (+3, 0), (+3, +1), (+1, +1), (+1, +3),
888         (-1, +3), (-1, +1), (-3, +1), (-3, 0)]) / 6)
889 
890     def _set_plus_filled(self):
891         self._transform = Affine2D()
892         self._snap_threshold = 5.0
893         self._joinstyle = self._user_joinstyle or JoinStyle.miter
894         if not self._half_fill():
895             self._path = self._plus_filled_path
896         else:
897             # Rotate top half path to support all partitions
898             self._path = self._alt_path = self._plus_filled_path_t
899             fs = self.get_fillstyle()
900             self._transform.rotate_deg(
901                 {'top': 0, 'left': 90, 'bottom': 180, 'right': 270}[fs])
902             self._alt_transform = self._transform.frozen().rotate_deg(180)
903 
904     _x_filled_path = Path._create_closed(np.array([
905         (-1, -2), (0, -1), (+1, -2), (+2, -1), (+1, 0), (+2, +1),
906         (+1, +2), (0, +1), (-1, +2), (-2, +1), (-1, 0), (-2, -1)]) / 4)
907     _x_filled_path_t = Path._create_closed(np.array([
908         (+1, 0), (+2, +1), (+1, +2), (0, +1),
909         (-1, +2), (-2, +1), (-1, 0)]) / 4)
910 
911     def _set_x_filled(self):
912         self._transform = Affine2D()
913         self._snap_threshold = 5.0
914         self._joinstyle = self._user_joinstyle or JoinStyle.miter
915         if not self._half_fill():
916             self._path = self._x_filled_path
917         else:
918             # Rotate top half path to support all partitions
919             self._path = self._alt_path = self._x_filled_path_t
920             fs = self.get_fillstyle()
921             self._transform.rotate_deg(
922                 {'top': 0, 'left': 90, 'bottom': 180, 'right': 270}[fs])
923             self._alt_transform = self._transform.frozen().rotate_deg(180)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/text.py</file>
<class>Text</class>
<method>None</method>
<code>
95 class Text(Artist):
96     """Handle storing and drawing of text in window or data coordinates."""
97 
98     zorder = 3
99     _charsize_cache = dict()
100 
101     def __repr__(self):
102         return f"Text({self._x}, {self._y}, {self._text!r})"
103 
104     def __init__(self,
105                  x=0, y=0, text='', *,
106                  color=None,           # defaults to rc params
107                  verticalalignment='baseline',
108                  horizontalalignment='left',
109                  multialignment=None,
110                  fontproperties=None,  # defaults to FontProperties()
111                  rotation=None,
112                  linespacing=None,
113                  rotation_mode=None,
114                  usetex=None,          # defaults to rcParams['text.usetex']
115                  wrap=False,
116                  transform_rotates_text=False,
117                  parse_math=None,    # defaults to rcParams['text.parse_math']
118                  antialiased=None,  # defaults to rcParams['text.antialiased']
119                  **kwargs
120                  ):
121         """
122         Create a `.Text` instance at *x*, *y* with string *text*.
123 
124         The text is aligned relative to the anchor point (*x*, *y*) according
125         to ``horizontalalignment`` (default: 'left') and ``verticalalignment``
126         (default: 'bottom'). See also
127         :doc:`/gallery/text_labels_and_annotations/text_alignment`.
128 
129         While Text accepts the 'label' keyword argument, by default it is not
130         added to the handles of a legend.
131 
132         Valid keyword arguments are:
133 
134         %(Text:kwdoc)s
135         """
136         super().__init__()
137         self._x, self._y = x, y
138         self._text = ''
139         self._antialiased = mpl.rcParams['text.antialiased']
140         self._reset_visual_defaults(
141             text=text,
142             color=color,
143             fontproperties=fontproperties,
144             usetex=usetex,
145             parse_math=parse_math,
146             wrap=wrap,
147             verticalalignment=verticalalignment,
148             horizontalalignment=horizontalalignment,
149             multialignment=multialignment,
150             rotation=rotation,
151             transform_rotates_text=transform_rotates_text,
152             linespacing=linespacing,
153             rotation_mode=rotation_mode,
154             antialiased=antialiased
155         )
156         self.update(kwargs)
157 
158     def _reset_visual_defaults(
159         self,
160         text='',
161         color=None,
162         fontproperties=None,
163         usetex=None,
164         parse_math=None,
165         wrap=False,
166         verticalalignment='baseline',
167         horizontalalignment='left',
168         multialignment=None,
169         rotation=None,
170         transform_rotates_text=False,
171         linespacing=None,
172         rotation_mode=None,
173         antialiased=None
174     ):
175         self.set_text(text)
176         self.set_color(
177             color if color is not None else mpl.rcParams["text.color"])
178         self.set_fontproperties(fontproperties)
179         self.set_usetex(usetex)
180         self.set_parse_math(parse_math if parse_math is not None else
181                             mpl.rcParams['text.parse_math'])
182         self.set_wrap(wrap)
183         self.set_verticalalignment(verticalalignment)
184         self.set_horizontalalignment(horizontalalignment)
185         self._multialignment = multialignment
186         self.set_rotation(rotation)
187         self._transform_rotates_text = transform_rotates_text
188         self._bbox_patch = None  # a FancyBboxPatch instance
189         self._renderer = None
190         if linespacing is None:
191             linespacing = 1.2  # Maybe use rcParam later.
192         self.set_linespacing(linespacing)
193         self.set_rotation_mode(rotation_mode)
194         if antialiased is not None:
195             self.set_antialiased(antialiased)
196 
197     def update(self, kwargs):
198         # docstring inherited
199         kwargs = cbook.normalize_kwargs(kwargs, Text)
200         sentinel = object()  # bbox can be None, so use another sentinel.
201         # Update fontproperties first, as it has lowest priority.
202         fontproperties = kwargs.pop("fontproperties", sentinel)
203         if fontproperties is not sentinel:
204             self.set_fontproperties(fontproperties)
205         # Update bbox last, as it depends on font properties.
206         bbox = kwargs.pop("bbox", sentinel)
207         super().update(kwargs)
208         if bbox is not sentinel:
209             self.set_bbox(bbox)
210 
211     def __getstate__(self):
212         d = super().__getstate__()
213         # remove the cached _renderer (if it exists)
214         d['_renderer'] = None
215         return d
216 
217     def contains(self, mouseevent):
218         """
219         Return whether the mouse event occurred inside the axis-aligned
220         bounding-box of the text.
221         """
222         if (self._different_canvas(mouseevent) or not self.get_visible()
223                 or self._renderer is None):
224             return False, {}
225         # Explicitly use Text.get_window_extent(self) and not
226         # self.get_window_extent() so that Annotation.contains does not
227         # accidentally cover the entire annotation bounding box.
228         bbox = Text.get_window_extent(self)
229         inside = (bbox.x0 <= mouseevent.x <= bbox.x1
230                   and bbox.y0 <= mouseevent.y <= bbox.y1)
231         cattr = {}
232         # if the text has a surrounding patch, also check containment for it,
233         # and merge the results with the results for the text.
234         if self._bbox_patch:
235             patch_inside, patch_cattr = self._bbox_patch.contains(mouseevent)
236             inside = inside or patch_inside
237             cattr["bbox_patch"] = patch_cattr
238         return inside, cattr
239 
240     def _get_xy_display(self):
241         """
242         Get the (possibly unit converted) transformed x, y in display coords.
243         """
244         x, y = self.get_unitless_position()
245         return self.get_transform().transform((x, y))
246 
247     def _get_multialignment(self):
248         if self._multialignment is not None:
249             return self._multialignment
250         else:
251             return self._horizontalalignment
252 
253     def _char_index_at(self, x):
254         """
255         Calculate the index closest to the coordinate x in display space.
256 
257         The position of text[index] is assumed to be the sum of the widths
258         of all preceding characters text[:index].
259 
260         This works only on single line texts.
261         """
262         if not self._text:
263             return 0
264 
265         text = self._text
266 
267         fontproperties = str(self._fontproperties)
268         if fontproperties not in Text._charsize_cache:
269             Text._charsize_cache[fontproperties] = dict()
270 
271         charsize_cache = Text._charsize_cache[fontproperties]
272         for char in set(text):
273             if char not in charsize_cache:
274                 self.set_text(char)
275                 bb = self.get_window_extent()
276                 charsize_cache[char] = bb.x1 - bb.x0
277 
278         self.set_text(text)
279         bb = self.get_window_extent()
280 
281         size_accum = np.cumsum([0] + [charsize_cache[x] for x in text])
282         std_x = x - bb.x0
283         return (np.abs(size_accum - std_x)).argmin()
284 
285     def get_rotation(self):
286         """Return the text angle in degrees between 0 and 360."""
287         if self.get_transform_rotates_text():
288             return self.get_transform().transform_angles(
289                 [self._rotation], [self.get_unitless_position()]).item(0)
290         else:
291             return self._rotation
292 
293     def get_transform_rotates_text(self):
294         """
295         Return whether rotations of the transform affect the text direction.
296         """
297         return self._transform_rotates_text
298 
299     def set_rotation_mode(self, m):
300         """
301         Set text rotation mode.
302 
303         Parameters
304         ----------
305         m : {None, 'default', 'anchor'}
306             If ``None`` or ``"default"``, the text will be first rotated, then
307             aligned according to their horizontal and vertical alignments.  If
308             ``"anchor"``, then alignment occurs before rotation.
309         """
310         _api.check_in_list(["anchor", "default", None], rotation_mode=m)
311         self._rotation_mode = m
312         self.stale = True
313 
314     def get_rotation_mode(self):
315         """Return the text rotation mode."""
316         return self._rotation_mode
317 
318     def set_antialiased(self, antialiased):
319         """
320         Set whether to use antialiased rendering.
321 
322         Parameters
323         ----------
324         antialiased : bool
325 
326         Notes
327         -----
328         Antialiasing will be determined by :rc:`text.antialiased`
329         and the parameter *antialiased* will have no effect if the text contains
330         math expressions.
331         """
332         self._antialiased = antialiased
333         self.stale = True
334 
335     def get_antialiased(self):
336         """Return whether antialiased rendering is used."""
337         return self._antialiased
338 
339     def update_from(self, other):
340         # docstring inherited
341         super().update_from(other)
342         self._color = other._color
343         self._multialignment = other._multialignment
344         self._verticalalignment = other._verticalalignment
345         self._horizontalalignment = other._horizontalalignment
346         self._fontproperties = other._fontproperties.copy()
347         self._usetex = other._usetex
348         self._rotation = other._rotation
349         self._transform_rotates_text = other._transform_rotates_text
350         self._picker = other._picker
351         self._linespacing = other._linespacing
352         self._antialiased = other._antialiased
353         self.stale = True
354 
355     def _get_layout(self, renderer):
356         """
357         Return the extent (bbox) of the text together with
358         multiple-alignment information. Note that it returns an extent
359         of a rotated text when necessary.
360         """
361         thisx, thisy = 0.0, 0.0
362         lines = self._get_wrapped_text().split("\n")  # Ensures lines is not empty.
363 
364         ws = []
365         hs = []
366         xs = []
367         ys = []
368 
369         # Full vertical extent of font, including ascenders and descenders:
370         _, lp_h, lp_d = _get_text_metrics_with_cache(
371             renderer, "lp", self._fontproperties,
372             ismath="TeX" if self.get_usetex() else False, dpi=self.figure.dpi)
373         min_dy = (lp_h - lp_d) * self._linespacing
374 
375         for i, line in enumerate(lines):
376             clean_line, ismath = self._preprocess_math(line)
377             if clean_line:
378                 w, h, d = _get_text_metrics_with_cache(
379                     renderer, clean_line, self._fontproperties,
380                     ismath=ismath, dpi=self.figure.dpi)
381             else:
382                 w = h = d = 0
383 
384             # For multiline text, increase the line spacing when the text
385             # net-height (excluding baseline) is larger than that of a "l"
386             # (e.g., use of superscripts), which seems what TeX does.
387             h = max(h, lp_h)
388             d = max(d, lp_d)
389 
390             ws.append(w)
391             hs.append(h)
392 
393             # Metrics of the last line that are needed later:
394             baseline = (h - d) - thisy
395 
396             if i == 0:
397                 # position at baseline
398                 thisy = -(h - d)
399             else:
400                 # put baseline a good distance from bottom of previous line
401                 thisy -= max(min_dy, (h - d) * self._linespacing)
402 
403             xs.append(thisx)  # == 0.
404             ys.append(thisy)
405 
406             thisy -= d
407 
408         # Metrics of the last line that are needed later:
409         descent = d
410 
411         # Bounding box definition:
412         width = max(ws)
413         xmin = 0
414         xmax = width
415         ymax = 0
416         ymin = ys[-1] - descent  # baseline of last line minus its descent
417 
418         # get the rotation matrix
419         M = Affine2D().rotate_deg(self.get_rotation())
420 
421         # now offset the individual text lines within the box
422         malign = self._get_multialignment()
423         if malign == 'left':
424             offset_layout = [(x, y) for x, y in zip(xs, ys)]
425         elif malign == 'center':
426             offset_layout = [(x + width / 2 - w / 2, y)
427                              for x, y, w in zip(xs, ys, ws)]
428         elif malign == 'right':
429             offset_layout = [(x + width - w, y)
430                              for x, y, w in zip(xs, ys, ws)]
431 
432         # the corners of the unrotated bounding box
433         corners_horiz = np.array(
434             [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)])
435 
436         # now rotate the bbox
437         corners_rotated = M.transform(corners_horiz)
438         # compute the bounds of the rotated box
439         xmin = corners_rotated[:, 0].min()
440         xmax = corners_rotated[:, 0].max()
441         ymin = corners_rotated[:, 1].min()
442         ymax = corners_rotated[:, 1].max()
443         width = xmax - xmin
444         height = ymax - ymin
445 
446         # Now move the box to the target position offset the display
447         # bbox by alignment
448         halign = self._horizontalalignment
449         valign = self._verticalalignment
450 
451         rotation_mode = self.get_rotation_mode()
452         if rotation_mode != "anchor":
453             # compute the text location in display coords and the offsets
454             # necessary to align the bbox with that location
455             if halign == 'center':
456                 offsetx = (xmin + xmax) / 2
457             elif halign == 'right':
458                 offsetx = xmax
459             else:
460                 offsetx = xmin
461 
462             if valign == 'center':
463                 offsety = (ymin + ymax) / 2
464             elif valign == 'top':
465                 offsety = ymax
466             elif valign == 'baseline':
467                 offsety = ymin + descent
468             elif valign == 'center_baseline':
469                 offsety = ymin + height - baseline / 2.0
470             else:
471                 offsety = ymin
472         else:
473             xmin1, ymin1 = corners_horiz[0]
474             xmax1, ymax1 = corners_horiz[2]
475 
476             if halign == 'center':
477                 offsetx = (xmin1 + xmax1) / 2.0
478             elif halign == 'right':
479                 offsetx = xmax1
480             else:
481                 offsetx = xmin1
482 
483             if valign == 'center':
484                 offsety = (ymin1 + ymax1) / 2.0
485             elif valign == 'top':
486                 offsety = ymax1
487             elif valign == 'baseline':
488                 offsety = ymax1 - baseline
489             elif valign == 'center_baseline':
490                 offsety = ymax1 - baseline / 2.0
491             else:
492                 offsety = ymin1
493 
494             offsetx, offsety = M.transform((offsetx, offsety))
495 
496         xmin -= offsetx
497         ymin -= offsety
498 
499         bbox = Bbox.from_bounds(xmin, ymin, width, height)
500 
501         # now rotate the positions around the first (x, y) position
502         xys = M.transform(offset_layout) - (offsetx, offsety)
503 
504         return bbox, list(zip(lines, zip(ws, hs), *xys.T)), descent
505 
506     def set_bbox(self, rectprops):
507         """
508         Draw a bounding box around self.
509 
510         Parameters
511         ----------
512         rectprops : dict with properties for `.patches.FancyBboxPatch`
513              The default boxstyle is 'square'. The mutation
514              scale of the `.patches.FancyBboxPatch` is set to the fontsize.
515 
516         Examples
517         --------
518         ::
519 
520             t.set_bbox(dict(facecolor='red', alpha=0.5))
521         """
522 
523         if rectprops is not None:
524             props = rectprops.copy()
525             boxstyle = props.pop("boxstyle", None)
526             pad = props.pop("pad", None)
527             if boxstyle is None:
528                 boxstyle = "square"
529                 if pad is None:
530                     pad = 4  # points
531                 pad /= self.get_size()  # to fraction of font size
532             else:
533                 if pad is None:
534                     pad = 0.3
535             # boxstyle could be a callable or a string
536             if isinstance(boxstyle, str) and "pad" not in boxstyle:
537                 boxstyle += ",pad=%0.2f" % pad
538             self._bbox_patch = FancyBboxPatch(
539                 (0, 0), 1, 1,
540                 boxstyle=boxstyle, transform=IdentityTransform(), **props)
541         else:
542             self._bbox_patch = None
543 
544         self._update_clip_properties()
545 
546     def get_bbox_patch(self):
547         """
548         Return the bbox Patch, or None if the `.patches.FancyBboxPatch`
549         is not made.
550         """
551         return self._bbox_patch
552 
553     def update_bbox_position_size(self, renderer):
554         """
555         Update the location and the size of the bbox.
556 
557         This method should be used when the position and size of the bbox needs
558         to be updated before actually drawing the bbox.
559         """
560         if self._bbox_patch:
561             # don't use self.get_unitless_position here, which refers to text
562             # position in Text:
563             posx = float(self.convert_xunits(self._x))
564             posy = float(self.convert_yunits(self._y))
565             posx, posy = self.get_transform().transform((posx, posy))
566 
567             x_box, y_box, w_box, h_box = _get_textbox(self, renderer)
568             self._bbox_patch.set_bounds(0., 0., w_box, h_box)
569             self._bbox_patch.set_transform(
570                 Affine2D()
571                 .rotate_deg(self.get_rotation())
572                 .translate(posx + x_box, posy + y_box))
573             fontsize_in_pixel = renderer.points_to_pixels(self.get_size())
574             self._bbox_patch.set_mutation_scale(fontsize_in_pixel)
575 
576     def _update_clip_properties(self):
577         clipprops = dict(clip_box=self.clipbox,
578                          clip_path=self._clippath,
579                          clip_on=self._clipon)
580         if self._bbox_patch:
581             self._bbox_patch.update(clipprops)
582 
583     def set_clip_box(self, clipbox):
584         # docstring inherited.
585         super().set_clip_box(clipbox)
586         self._update_clip_properties()
587 
588     def set_clip_path(self, path, transform=None):
589         # docstring inherited.
590         super().set_clip_path(path, transform)
591         self._update_clip_properties()
592 
593     def set_clip_on(self, b):
594         # docstring inherited.
595         super().set_clip_on(b)
596         self._update_clip_properties()
597 
598     def get_wrap(self):
599         """Return whether the text can be wrapped."""
600         return self._wrap
601 
602     def set_wrap(self, wrap):
603         """
604         Set whether the text can be wrapped.
605 
606         Parameters
607         ----------
608         wrap : bool
609 
610         Notes
611         -----
612         Wrapping does not work together with
613         ``savefig(..., bbox_inches='tight')`` (which is also used internally
614         by ``%matplotlib inline`` in IPython/Jupyter). The 'tight' setting
615         rescales the canvas to accommodate all content and happens before
616         wrapping.
617         """
618         self._wrap = wrap
619 
620     def _get_wrap_line_width(self):
621         """
622         Return the maximum line width for wrapping text based on the current
623         orientation.
624         """
625         x0, y0 = self.get_transform().transform(self.get_position())
626         figure_box = self.get_figure().get_window_extent()
627 
628         # Calculate available width based on text alignment
629         alignment = self.get_horizontalalignment()
630         self.set_rotation_mode('anchor')
631         rotation = self.get_rotation()
632 
633         left = self._get_dist_to_box(rotation, x0, y0, figure_box)
634         right = self._get_dist_to_box(
635             (180 + rotation) % 360, x0, y0, figure_box)
636 
637         if alignment == 'left':
638             line_width = left
639         elif alignment == 'right':
640             line_width = right
641         else:
642             line_width = 2 * min(left, right)
643 
644         return line_width
645 
646     def _get_dist_to_box(self, rotation, x0, y0, figure_box):
647         """
648         Return the distance from the given points to the boundaries of a
649         rotated box, in pixels.
650         """
651         if rotation > 270:
652             quad = rotation - 270
653             h1 = y0 / math.cos(math.radians(quad))
654             h2 = (figure_box.x1 - x0) / math.cos(math.radians(90 - quad))
655         elif rotation > 180:
656             quad = rotation - 180
657             h1 = x0 / math.cos(math.radians(quad))
658             h2 = y0 / math.cos(math.radians(90 - quad))
659         elif rotation > 90:
660             quad = rotation - 90
661             h1 = (figure_box.y1 - y0) / math.cos(math.radians(quad))
662             h2 = x0 / math.cos(math.radians(90 - quad))
663         else:
664             h1 = (figure_box.x1 - x0) / math.cos(math.radians(rotation))
665             h2 = (figure_box.y1 - y0) / math.cos(math.radians(90 - rotation))
666 
667         return min(h1, h2)
668 
669     def _get_rendered_text_width(self, text):
670         """
671         Return the width of a given text string, in pixels.
672         """
673 
674         w, h, d = self._renderer.get_text_width_height_descent(
675             text,
676             self.get_fontproperties(),
677             cbook.is_math_text(text))
678         return math.ceil(w)
679 
680     def _get_wrapped_text(self):
681         """
682         Return a copy of the text string with new lines added so that the text
683         is wrapped relative to the parent figure (if `get_wrap` is True).
684         """
685         if not self.get_wrap():
686             return self.get_text()
687 
688         # Not fit to handle breaking up latex syntax correctly, so
689         # ignore latex for now.
690         if self.get_usetex():
691             return self.get_text()
692 
693         # Build the line incrementally, for a more accurate measure of length
694         line_width = self._get_wrap_line_width()
695         wrapped_lines = []
696 
697         # New lines in the user's text force a split
698         unwrapped_lines = self.get_text().split('\n')
699 
700         # Now wrap each individual unwrapped line
701         for unwrapped_line in unwrapped_lines:
702 
703             sub_words = unwrapped_line.split(' ')
704             # Remove items from sub_words as we go, so stop when empty
705             while len(sub_words) > 0:
706                 if len(sub_words) == 1:
707                     # Only one word, so just add it to the end
708                     wrapped_lines.append(sub_words.pop(0))
709                     continue
710 
711                 for i in range(2, len(sub_words) + 1):
712                     # Get width of all words up to and including here
713                     line = ' '.join(sub_words[:i])
714                     current_width = self._get_rendered_text_width(line)
715 
716                     # If all these words are too wide, append all not including
717                     # last word
718                     if current_width > line_width:
719                         wrapped_lines.append(' '.join(sub_words[:i - 1]))
720                         sub_words = sub_words[i - 1:]
721                         break
722 
723                     # Otherwise if all words fit in the width, append them all
724                     elif i == len(sub_words):
725                         wrapped_lines.append(' '.join(sub_words[:i]))
726                         sub_words = []
727                         break
728 
729         return '\n'.join(wrapped_lines)
730 
731     @artist.allow_rasterization
732     def draw(self, renderer):
733         # docstring inherited
734 
735         if renderer is not None:
736             self._renderer = renderer
737         if not self.get_visible():
738             return
739         if self.get_text() == '':
740             return
741 
742         renderer.open_group('text', self.get_gid())
743 
744         with self._cm_set(text=self._get_wrapped_text()):
745             bbox, info, descent = self._get_layout(renderer)
746             trans = self.get_transform()
747 
748             # don't use self.get_position here, which refers to text
749             # position in Text:
750             posx = float(self.convert_xunits(self._x))
751             posy = float(self.convert_yunits(self._y))
752             posx, posy = trans.transform((posx, posy))
753             if not np.isfinite(posx) or not np.isfinite(posy):
754                 _log.warning("posx and posy should be finite values")
755                 return
756             canvasw, canvash = renderer.get_canvas_width_height()
757 
758             # Update the location and size of the bbox
759             # (`.patches.FancyBboxPatch`), and draw it.
760             if self._bbox_patch:
761                 self.update_bbox_position_size(renderer)
762                 self._bbox_patch.draw(renderer)
763 
764             gc = renderer.new_gc()
765             gc.set_foreground(self.get_color())
766             gc.set_alpha(self.get_alpha())
767             gc.set_url(self._url)
768             gc.set_antialiased(self._antialiased)
769             self._set_gc_clip(gc)
770 
771             angle = self.get_rotation()
772 
773             for line, wh, x, y in info:
774 
775                 mtext = self if len(info) == 1 else None
776                 x = x + posx
777                 y = y + posy
778                 if renderer.flipy():
779                     y = canvash - y
780                 clean_line, ismath = self._preprocess_math(line)
781 
782                 if self.get_path_effects():
783                     from matplotlib.patheffects import PathEffectRenderer
784                     textrenderer = PathEffectRenderer(
785                         self.get_path_effects(), renderer)
786                 else:
787                     textrenderer = renderer
788 
789                 if self.get_usetex():
790                     textrenderer.draw_tex(gc, x, y, clean_line,
791                                           self._fontproperties, angle,
792                                           mtext=mtext)
793                 else:
794                     textrenderer.draw_text(gc, x, y, clean_line,
795                                            self._fontproperties, angle,
796                                            ismath=ismath, mtext=mtext)
797 
798         gc.restore()
799         renderer.close_group('text')
800         self.stale = False
801 
802     def get_color(self):
803         """Return the color of the text."""
804         return self._color
805 
806     def get_fontproperties(self):
807         """Return the `.font_manager.FontProperties`."""
808         return self._fontproperties
809 
810     def get_fontfamily(self):
811         """
812         Return the list of font families used for font lookup.
813 
814         See Also
815         --------
816         .font_manager.FontProperties.get_family
817         """
818         return self._fontproperties.get_family()
819 
820     def get_fontname(self):
821         """
822         Return the font name as a string.
823 
824         See Also
825         --------
826         .font_manager.FontProperties.get_name
827         """
828         return self._fontproperties.get_name()
829 
830     def get_fontstyle(self):
831         """
832         Return the font style as a string.
833 
834         See Also
835         --------
836         .font_manager.FontProperties.get_style
837         """
838         return self._fontproperties.get_style()
839 
840     def get_fontsize(self):
841         """
842         Return the font size as an integer.
843 
844         See Also
845         --------
846         .font_manager.FontProperties.get_size_in_points
847         """
848         return self._fontproperties.get_size_in_points()
849 
850     def get_fontvariant(self):
851         """
852         Return the font variant as a string.
853 
854         See Also
855         --------
856         .font_manager.FontProperties.get_variant
857         """
858         return self._fontproperties.get_variant()
859 
860     def get_fontweight(self):
861         """
862         Return the font weight as a string or a number.
863 
864         See Also
865         --------
866         .font_manager.FontProperties.get_weight
867         """
868         return self._fontproperties.get_weight()
869 
870     def get_stretch(self):
871         """
872         Return the font stretch as a string or a number.
873 
874         See Also
875         --------
876         .font_manager.FontProperties.get_stretch
877         """
878         return self._fontproperties.get_stretch()
879 
880     def get_horizontalalignment(self):
881         """
882         Return the horizontal alignment as a string.  Will be one of
883         'left', 'center' or 'right'.
884         """
885         return self._horizontalalignment
886 
887     def get_unitless_position(self):
888         """Return the (x, y) unitless position of the text."""
889         # This will get the position with all unit information stripped away.
890         # This is here for convenience since it is done in several locations.
891         x = float(self.convert_xunits(self._x))
892         y = float(self.convert_yunits(self._y))
893         return x, y
894 
895     def get_position(self):
896         """Return the (x, y) position of the text."""
897         # This should return the same data (possible unitized) as was
898         # specified with 'set_x' and 'set_y'.
899         return self._x, self._y
900 
901     def get_text(self):
902         """Return the text string."""
903         return self._text
904 
905     def get_verticalalignment(self):
906         """
907         Return the vertical alignment as a string.  Will be one of
908         'top', 'center', 'bottom', 'baseline' or 'center_baseline'.
909         """
910         return self._verticalalignment
911 
912     def get_window_extent(self, renderer=None, dpi=None):
913         """
914         Return the `.Bbox` bounding the text, in display units.
915 
916         In addition to being used internally, this is useful for specifying
917         clickable regions in a png file on a web page.
918 
919         Parameters
920         ----------
921         renderer : Renderer, optional
922             A renderer is needed to compute the bounding box.  If the artist
923             has already been drawn, the renderer is cached; thus, it is only
924             necessary to pass this argument when calling `get_window_extent`
925             before the first draw.  In practice, it is usually easier to
926             trigger a draw first, e.g. by calling
927             `~.Figure.draw_without_rendering` or ``plt.show()``.
928 
929         dpi : float, optional
930             The dpi value for computing the bbox, defaults to
931             ``self.figure.dpi`` (*not* the renderer dpi); should be set e.g. if
932             to match regions with a figure saved with a custom dpi value.
933         """
934         if not self.get_visible():
935             return Bbox.unit()
936         if dpi is None:
937             dpi = self.figure.dpi
938         if self.get_text() == '':
939             with cbook._setattr_cm(self.figure, dpi=dpi):
940                 tx, ty = self._get_xy_display()
941                 return Bbox.from_bounds(tx, ty, 0, 0)
942 
943         if renderer is not None:
944             self._renderer = renderer
945         if self._renderer is None:
946             self._renderer = self.figure._get_renderer()
947         if self._renderer is None:
948             raise RuntimeError(
949                 "Cannot get window extent of text w/o renderer. You likely "
950                 "want to call 'figure.draw_without_rendering()' first.")
951 
952         with cbook._setattr_cm(self.figure, dpi=dpi):
953             bbox, info, descent = self._get_layout(self._renderer)
954             x, y = self.get_unitless_position()
955             x, y = self.get_transform().transform((x, y))
956             bbox = bbox.translated(x, y)
957             return bbox
958 
959     def set_backgroundcolor(self, color):
960         """
961         Set the background color of the text by updating the bbox.
962 
963         Parameters
964         ----------
965         color : color
966 
967         See Also
968         --------
969         .set_bbox : To change the position of the bounding box
970         """
971         if self._bbox_patch is None:
972             self.set_bbox(dict(facecolor=color, edgecolor=color))
973         else:
974             self._bbox_patch.update(dict(facecolor=color))
975 
976         self._update_clip_properties()
977         self.stale = True
978 
979     def set_color(self, color):
980         """
981         Set the foreground color of the text
982 
983         Parameters
984         ----------
985         color : color
986         """
987         # "auto" is only supported by axisartist, but we can just let it error
988         # out at draw time for simplicity.
989         if not cbook._str_equal(color, "auto"):
990             mpl.colors._check_color_like(color=color)
991         self._color = color
992         self.stale = True
993 
994     def set_horizontalalignment(self, align):
995         """
996         Set the horizontal alignment relative to the anchor point.
997 
998         See also :doc:`/gallery/text_labels_and_annotations/text_alignment`.
999 
1000         Parameters
1001         ----------
1002         align : {'left', 'center', 'right'}
1003         """
1004         _api.check_in_list(['center', 'right', 'left'], align=align)
1005         self._horizontalalignment = align
1006         self.stale = True
1007 
1008     def set_multialignment(self, align):
1009         """
1010         Set the text alignment for multiline texts.
1011 
1012         The layout of the bounding box of all the lines is determined by the
1013         horizontalalignment and verticalalignment properties. This property
1014         controls the alignment of the text lines within that box.
1015 
1016         Parameters
1017         ----------
1018         align : {'left', 'right', 'center'}
1019         """
1020         _api.check_in_list(['center', 'right', 'left'], align=align)
1021         self._multialignment = align
1022         self.stale = True
1023 
1024     def set_linespacing(self, spacing):
1025         """
1026         Set the line spacing as a multiple of the font size.
1027 
1028         The default line spacing is 1.2.
1029 
1030         Parameters
1031         ----------
1032         spacing : float (multiple of font size)
1033         """
1034         _api.check_isinstance(Real, spacing=spacing)
1035         self._linespacing = spacing
1036         self.stale = True
1037 
1038     def set_fontfamily(self, fontname):
1039         """
1040         Set the font family.  Can be either a single string, or a list of
1041         strings in decreasing priority.  Each string may be either a real font
1042         name or a generic font class name.  If the latter, the specific font
1043         names will be looked up in the corresponding rcParams.
1044 
1045         If a `Text` instance is constructed with ``fontfamily=None``, then the
1046         font is set to :rc:`font.family`, and the
1047         same is done when `set_fontfamily()` is called on an existing
1048         `Text` instance.
1049 
1050         Parameters
1051         ----------
1052         fontname : {FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', \
1053 'monospace'}
1054 
1055         See Also
1056         --------
1057         .font_manager.FontProperties.set_family
1058         """
1059         self._fontproperties.set_family(fontname)
1060         self.stale = True
1061 
1062     def set_fontvariant(self, variant):
1063         """
1064         Set the font variant.
1065 
1066         Parameters
1067         ----------
1068         variant : {'normal', 'small-caps'}
1069 
1070         See Also
1071         --------
1072         .font_manager.FontProperties.set_variant
1073         """
1074         self._fontproperties.set_variant(variant)
1075         self.stale = True
1076 
1077     def set_fontstyle(self, fontstyle):
1078         """
1079         Set the font style.
1080 
1081         Parameters
1082         ----------
1083         fontstyle : {'normal', 'italic', 'oblique'}
1084 
1085         See Also
1086         --------
1087         .font_manager.FontProperties.set_style
1088         """
1089         self._fontproperties.set_style(fontstyle)
1090         self.stale = True
1091 
1092     def set_fontsize(self, fontsize):
1093         """
1094         Set the font size.
1095 
1096         Parameters
1097         ----------
1098         fontsize : float or {'xx-small', 'x-small', 'small', 'medium', \
1099 'large', 'x-large', 'xx-large'}
1100             If a float, the fontsize in points. The string values denote sizes
1101             relative to the default font size.
1102 
1103         See Also
1104         --------
1105         .font_manager.FontProperties.set_size
1106         """
1107         self._fontproperties.set_size(fontsize)
1108         self.stale = True
1109 
1110     def get_math_fontfamily(self):
1111         """
1112         Return the font family name for math text rendered by Matplotlib.
1113 
1114         The default value is :rc:`mathtext.fontset`.
1115 
1116         See Also
1117         --------
1118         set_math_fontfamily
1119         """
1120         return self._fontproperties.get_math_fontfamily()
1121 
1122     def set_math_fontfamily(self, fontfamily):
1123         """
1124         Set the font family for math text rendered by Matplotlib.
1125 
1126         This does only affect Matplotlib's own math renderer. It has no effect
1127         when rendering with TeX (``usetex=True``).
1128 
1129         Parameters
1130         ----------
1131         fontfamily : str
1132             The name of the font family.
1133 
1134             Available font families are defined in the
1135             :ref:`default matplotlibrc file
1136             <customizing-with-matplotlibrc-files>`.
1137 
1138         See Also
1139         --------
1140         get_math_fontfamily
1141         """
1142         self._fontproperties.set_math_fontfamily(fontfamily)
1143 
1144     def set_fontweight(self, weight):
1145         """
1146         Set the font weight.
1147 
1148         Parameters
1149         ----------
1150         weight : {a numeric value in range 0-1000, 'ultralight', 'light', \
1151 'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', \
1152 'demi', 'bold', 'heavy', 'extra bold', 'black'}
1153 
1154         See Also
1155         --------
1156         .font_manager.FontProperties.set_weight
1157         """
1158         self._fontproperties.set_weight(weight)
1159         self.stale = True
1160 
1161     def set_fontstretch(self, stretch):
1162         """
1163         Set the font stretch (horizontal condensation or expansion).
1164 
1165         Parameters
1166         ----------
1167         stretch : {a numeric value in range 0-1000, 'ultra-condensed', \
1168 'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', \
1169 'expanded', 'extra-expanded', 'ultra-expanded'}
1170 
1171         See Also
1172         --------
1173         .font_manager.FontProperties.set_stretch
1174         """
1175         self._fontproperties.set_stretch(stretch)
1176         self.stale = True
1177 
1178     def set_position(self, xy):
1179         """
1180         Set the (*x*, *y*) position of the text.
1181 
1182         Parameters
1183         ----------
1184         xy : (float, float)
1185         """
1186         self.set_x(xy[0])
1187         self.set_y(xy[1])
1188 
1189     def set_x(self, x):
1190         """
1191         Set the *x* position of the text.
1192 
1193         Parameters
1194         ----------
1195         x : float
1196         """
1197         self._x = x
1198         self.stale = True
1199 
1200     def set_y(self, y):
1201         """
1202         Set the *y* position of the text.
1203 
1204         Parameters
1205         ----------
1206         y : float
1207         """
1208         self._y = y
1209         self.stale = True
1210 
1211     def set_rotation(self, s):
1212         """
1213         Set the rotation of the text.
1214 
1215         Parameters
1216         ----------
1217         s : float or {'vertical', 'horizontal'}
1218             The rotation angle in degrees in mathematically positive direction
1219             (counterclockwise). 'horizontal' equals 0, 'vertical' equals 90.
1220         """
1221         if isinstance(s, Real):
1222             self._rotation = float(s) % 360
1223         elif cbook._str_equal(s, 'horizontal') or s is None:
1224             self._rotation = 0.
1225         elif cbook._str_equal(s, 'vertical'):
1226             self._rotation = 90.
1227         else:
1228             raise ValueError("rotation must be 'vertical', 'horizontal' or "
1229                              f"a number, not {s}")
1230         self.stale = True
1231 
1232     def set_transform_rotates_text(self, t):
1233         """
1234         Whether rotations of the transform affect the text direction.
1235 
1236         Parameters
1237         ----------
1238         t : bool
1239         """
1240         self._transform_rotates_text = t
1241         self.stale = True
1242 
1243     def set_verticalalignment(self, align):
1244         """
1245         Set the vertical alignment relative to the anchor point.
1246 
1247         See also :doc:`/gallery/text_labels_and_annotations/text_alignment`.
1248 
1249         Parameters
1250         ----------
1251         align : {'bottom', 'baseline', 'center', 'center_baseline', 'top'}
1252         """
1253         _api.check_in_list(
1254             ['top', 'bottom', 'center', 'baseline', 'center_baseline'],
1255             align=align)
1256         self._verticalalignment = align
1257         self.stale = True
1258 
1259     def set_text(self, s):
1260         r"""
1261         Set the text string *s*.
1262 
1263         It may contain newlines (``\n``) or math in LaTeX syntax.
1264 
1265         Parameters
1266         ----------
1267         s : object
1268             Any object gets converted to its `str` representation, except for
1269             ``None`` which is converted to an empty string.
1270         """
1271         if s is None:
1272             s = ''
1273         if s != self._text:
1274             self._text = str(s)
1275             self.stale = True
1276 
1277     def _preprocess_math(self, s):
1278         """
1279         Return the string *s* after mathtext preprocessing, and the kind of
1280         mathtext support needed.
1281 
1282         - If *self* is configured to use TeX, return *s* unchanged except that
1283           a single space gets escaped, and the flag "TeX".
1284         - Otherwise, if *s* is mathtext (has an even number of unescaped dollar
1285           signs) and ``parse_math`` is not set to False, return *s* and the
1286           flag True.
1287         - Otherwise, return *s* with dollar signs unescaped, and the flag
1288           False.
1289         """
1290         if self.get_usetex():
1291             if s == " ":
1292                 s = r"\ "
1293             return s, "TeX"
1294         elif not self.get_parse_math():
1295             return s, False
1296         elif cbook.is_math_text(s):
1297             return s, True
1298         else:
1299             return s.replace(r"\$", "$"), False
1300 
1301     def set_fontproperties(self, fp):
1302         """
1303         Set the font properties that control the text.
1304 
1305         Parameters
1306         ----------
1307         fp : `.font_manager.FontProperties` or `str` or `pathlib.Path`
1308             If a `str`, it is interpreted as a fontconfig pattern parsed by
1309             `.FontProperties`.  If a `pathlib.Path`, it is interpreted as the
1310             absolute path to a font file.
1311         """
1312         self._fontproperties = FontProperties._from_any(fp).copy()
1313         self.stale = True
1314 
1315     def set_usetex(self, usetex):
1316         """
1317         Parameters
1318         ----------
1319         usetex : bool or None
1320             Whether to render using TeX, ``None`` means to use
1321             :rc:`text.usetex`.
1322         """
1323         if usetex is None:
1324             self._usetex = mpl.rcParams['text.usetex']
1325         else:
1326             self._usetex = bool(usetex)
1327         self.stale = True
1328 
1329     def get_usetex(self):
1330         """Return whether this `Text` object uses TeX for rendering."""
1331         return self._usetex
1332 
1333     def set_parse_math(self, parse_math):
1334         """
1335         Override switch to disable any mathtext parsing for this `Text`.
1336 
1337         Parameters
1338         ----------
1339         parse_math : bool
1340             If False, this `Text` will never use mathtext.  If True, mathtext
1341             will be used if there is an even number of unescaped dollar signs.
1342         """
1343         self._parse_math = bool(parse_math)
1344 
1345     def get_parse_math(self):
1346         """Return whether mathtext parsing is considered for this `Text`."""
1347         return self._parse_math
1348 
1349     def set_fontname(self, fontname):
1350         """
1351         Alias for `set_family`.
1352 
1353         One-way alias only: the getter differs.
1354 
1355         Parameters
1356         ----------
1357         fontname : {FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', \
1358 'monospace'}
1359 
1360         See Also
1361         --------
1362         .font_manager.FontProperties.set_family
1363 
1364         """
1365         return self.set_family(fontname)

</code><intended_behavior>In the context of aligning mathtext markers, if adjustments within the `Text` class could impact the rendering of mathtext (such as alignment and positioning), the class should ensure that any mathtext rendered as part of a marker is centered based on the text's bounding box dimensions. The class should provide a mechanism to calculate and apply the correct alignment for mathtext specifically when it is used as a marker. This ensures that mathtext markers are rendered with the same center alignment as other markers, preserving the visual consistency across different marker types. Any modification should cater specifically to scenarios where text is used as a marker, ensuring that general text rendering functionality remains unaltered for regular plot annotations or labels.</intended_behavior>]
2025-10-18 14:33:27.806 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 14:33:27.806 | INFO     | Search-only: skipping patch selection
2025-10-18 14:33:27.918 | INFO     | Task matplotlib__matplotlib-26101 completed successfully.
2025-10-18 14:33:27.918 | INFO     | No patch generated. You can try running ACR again.
