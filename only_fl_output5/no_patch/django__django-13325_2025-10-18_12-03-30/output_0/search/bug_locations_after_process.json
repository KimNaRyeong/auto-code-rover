[
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 147,
        "end": 148,
        "class_name": "BaseMemcachedCache",
        "method_name": "delete_many",
        "code": "147     def delete_many(self, keys, version=None):\n148         self._cache.delete_multi(self.make_key(key, version=version) for key in keys)\n",
        "intended_behavior": "Before proceeding with the delete_multi operation, each key within the keys iterable should be validated using self.validate_key(key). This validation should happen in a loop iterating over keys, ensuring that each key is safe and adheres to the standards defined by the validate_key method before any deletion operation is attempted."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 13,
        "end": 155,
        "class_name": "BaseMemcachedCache",
        "method_name": null,
        "code": "13 class BaseMemcachedCache(BaseCache):\n14     def __init__(self, server, params, library, value_not_found_exception):\n15         super().__init__(params)\n16         if isinstance(server, str):\n17             self._servers = re.split('[;,]', server)\n18         else:\n19             self._servers = server\n20 \n21         # Exception type raised by the underlying client library for a\n22         # nonexistent key.\n23         self.LibraryValueNotFoundException = value_not_found_exception\n24 \n25         self._lib = library\n26         self._options = params.get('OPTIONS') or {}\n27 \n28     @property\n29     def _cache(self):\n30         \"\"\"\n31         Implement transparent thread-safe access to a memcached client.\n32         \"\"\"\n33         if getattr(self, '_client', None) is None:\n34             self._client = self._lib.Client(self._servers, **self._options)\n35 \n36         return self._client\n37 \n38     def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT):\n39         \"\"\"\n40         Memcached deals with long (> 30 days) timeouts in a special\n41         way. Call this function to obtain a safe value for your timeout.\n42         \"\"\"\n43         if timeout == DEFAULT_TIMEOUT:\n44             timeout = self.default_timeout\n45 \n46         if timeout is None:\n47             # Using 0 in memcache sets a non-expiring timeout.\n48             return 0\n49         elif int(timeout) == 0:\n50             # Other cache backends treat 0 as set-and-expire. To achieve this\n51             # in memcache backends, a negative timeout must be passed.\n52             timeout = -1\n53 \n54         if timeout > 2592000:  # 60*60*24*30, 30 days\n55             # See https://github.com/memcached/memcached/wiki/Programming#expiration\n56             # \"Expiration times can be set from 0, meaning \"never expire\", to\n57             # 30 days. Any time higher than 30 days is interpreted as a Unix\n58             # timestamp date. If you want to expire an object on January 1st of\n59             # next year, this is how you do that.\"\n60             #\n61             # This means that we have to switch to absolute timestamps.\n62             timeout += int(time.time())\n63         return int(timeout)\n64 \n65     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n66         key = self.make_key(key, version=version)\n67         self.validate_key(key)\n68         return self._cache.add(key, value, self.get_backend_timeout(timeout))\n69 \n70     def get(self, key, default=None, version=None):\n71         key = self.make_key(key, version=version)\n72         self.validate_key(key)\n73         return self._cache.get(key, default)\n74 \n75     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n76         key = self.make_key(key, version=version)\n77         self.validate_key(key)\n78         if not self._cache.set(key, value, self.get_backend_timeout(timeout)):\n79             # make sure the key doesn't keep its old value in case of failure to set (memcached's 1MB limit)\n80             self._cache.delete(key)\n81 \n82     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n83         key = self.make_key(key, version=version)\n84         return bool(self._cache.touch(key, self.get_backend_timeout(timeout)))\n85 \n86     def delete(self, key, version=None):\n87         key = self.make_key(key, version=version)\n88         self.validate_key(key)\n89         return bool(self._cache.delete(key))\n90 \n91     def get_many(self, keys, version=None):\n92         key_map = {self.make_key(key, version=version): key for key in keys}\n93         for key in key_map:\n94             self.validate_key(key)\n95         ret = self._cache.get_multi(key_map.keys())\n96         return {key_map[k]: v for k, v in ret.items()}\n97 \n98     def close(self, **kwargs):\n99         # Many clients don't clean up connections properly.\n100         self._cache.disconnect_all()\n101 \n102     def incr(self, key, delta=1, version=None):\n103         key = self.make_key(key, version=version)\n104         self.validate_key(key)\n105         # memcached doesn't support a negative delta\n106         if delta < 0:\n107             return self._cache.decr(key, -delta)\n108         try:\n109             val = self._cache.incr(key, delta)\n110 \n111         # Normalize an exception raised by the underlying client library to\n112         # ValueError in the event of a nonexistent key when calling incr().\n113         except self.LibraryValueNotFoundException:\n114             val = None\n115         if val is None:\n116             raise ValueError(\"Key '%s' not found\" % key)\n117         return val\n118 \n119     def decr(self, key, delta=1, version=None):\n120         key = self.make_key(key, version=version)\n121         self.validate_key(key)\n122         # memcached doesn't support a negative delta\n123         if delta < 0:\n124             return self._cache.incr(key, -delta)\n125         try:\n126             val = self._cache.decr(key, delta)\n127 \n128         # Normalize an exception raised by the underlying client library to\n129         # ValueError in the event of a nonexistent key when calling decr().\n130         except self.LibraryValueNotFoundException:\n131             val = None\n132         if val is None:\n133             raise ValueError(\"Key '%s' not found\" % key)\n134         return val\n135 \n136     def set_many(self, data, timeout=DEFAULT_TIMEOUT, version=None):\n137         safe_data = {}\n138         original_keys = {}\n139         for key, value in data.items():\n140             safe_key = self.make_key(key, version=version)\n141             self.validate_key(safe_key)\n142             safe_data[safe_key] = value\n143             original_keys[safe_key] = key\n144         failed_keys = self._cache.set_multi(safe_data, self.get_backend_timeout(timeout))\n145         return [original_keys[k] for k in failed_keys]\n146 \n147     def delete_many(self, keys, version=None):\n148         self._cache.delete_multi(self.make_key(key, version=version) for key in keys)\n149 \n150     def clear(self):\n151         self._cache.flush_all()\n152 \n153     def validate_key(self, key):\n154         for warning in memcache_key_warnings(key):\n155             raise InvalidCacheKey(warning)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 184,
        "end": 189,
        "class_name": "MemcachedCache",
        "method_name": "delete",
        "code": "184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n",
        "intended_behavior": "The delete method must call self.validate_key(key) prior to executing the deletion logic. This ensures that the key being deleted has been validated against any security or format constraints specified by the caching system, adhering to the application's safety standards."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 158,
        "end": 189,
        "class_name": "MemcachedCache",
        "method_name": null,
        "code": "158 class MemcachedCache(BaseMemcachedCache):\n159     \"An implementation of a cache binding using python-memcached\"\n160     def __init__(self, server, params):\n161         # python-memcached \u2265 1.45 returns None for a nonexistent key in\n162         # incr/decr(), python-memcached < 1.45 raises ValueError.\n163         import memcache\n164         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)\n165 \n166     @property\n167     def _cache(self):\n168         if getattr(self, '_client', None) is None:\n169             client_kwargs = {'pickleProtocol': pickle.HIGHEST_PROTOCOL}\n170             client_kwargs.update(self._options)\n171             self._client = self._lib.Client(self._servers, **client_kwargs)\n172         return self._client\n173 \n174     def get(self, key, default=None, version=None):\n175         key = self.make_key(key, version=version)\n176         val = self._cache.get(key)\n177         # python-memcached doesn't support default values in get().\n178         # https://github.com/linsomniac/python-memcached/issues/159\n179         # Remove this method if that issue is fixed.\n180         if val is None:\n181             return default\n182         return val\n183 \n184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]