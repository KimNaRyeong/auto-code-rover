2025-10-18 20:31:24.119 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 20:31:33.109 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=169, output_tokens=12, cost=0.002050
2025-10-18 20:31:33.109 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 20:31:33.113 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:31:42.075 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=476, output_tokens=324, cost=0.014480
2025-10-18 20:31:42.084 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:31:44.091 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=678, output_tokens=54, cost=0.008400
2025-10-18 20:31:44.092 | DEBUG    | Extracted a valid json.
2025-10-18 20:31:44.093 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MpmathPrinter\")",
        "search_class(\"Float\")",
        "search_class(\"LatexPrinter\")",
        "search_code(\"strip_zeros\")"
    ],
    "bug_locations": []
}
2025-10-18 20:31:44.237 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:31:44.238 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:32:03.959 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5734, output_tokens=783, cost=0.080830
2025-10-18 20:32:03.975 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:32:15.244 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6733, output_tokens=500, cost=0.082330
2025-10-18 20:32:15.255 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:32:24.517 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=854, output_tokens=366, cost=0.019520
2025-10-18 20:32:24.518 | DEBUG    | Extracted a valid json.
2025-10-18 20:32:24.519 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/pycode.py",
            "class": "MpmathPrinter",
            "method": "_print_Float",
            "intended_behavior": "This method should be modified or extended to accept and utilize min_fixed and max_fixed settings for formatting floats. While the existing functionality of converting floats for mpmath compatibility should be preserved, the method should conditionally format the float representation based on these new settings when provided."
        },
        {
            "file": "sympy/core/numbers.py",
            "class": "Float",
            "method": "",
            "intended_behavior": "Although the class implementation does not necessarily embody a 'bug' per se, to accommodate the issue, it might require extension to store and manage min_fixed and max_fixed attributes. This entails modifying the __new__ or _new method to optionally accept these parameters and adjusting relevant formatting methods (potentially including a custom __format__ or enhancing existing methods) to leverage these values when transforming Float instances to strings."
        },
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Float",
            "intended_behavior": "This method currently applies strip_zeros=True unconditionally. To resolve the issue, the behavior should be changed to factor in min_fixed and max_fixed preferences. This could involve: 1) adjusting the method to check for and apply these settings if they are present in the Float instance or globally within the printer settings, and 2) ensuring that when these settings are active, the zeros stripping and number formatting are aligned with them, preserving existing functionality when they are not specified."
        }
    ]
}
2025-10-18 20:32:24.524 | DEBUG    | Found override of _print_Float in StrPrinter
2025-10-18 20:32:24.524 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x761e6b526c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x761d7b11a3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x761d78dc3800>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x761d7b11a480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x761d78d424b0>
    └ <function run_task_in_subprocess at 0x761d7b11a660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x761d78d424b0>
    │        │      └ <function run_raw_task at 0x761d7b11a700>
    │        └ <function ProcessPoolExecutor.submit at 0x761e6ae72020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x761e6ae71da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x761e6ae71ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x761e6ae71f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x761e6b02cea0>
    └ <ForkProcess name='ForkProcess-472' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-472' parent=497161 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x761e6b09e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-472' parent=497161 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-472' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-472' parent=497161 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-472' parent=497161 started>
    │    └ <function Popen._launch at 0x761d7911b7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x761d7a57dfd0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x761e6b02d8a0>
           └ <ForkProcess name='ForkProcess-472' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x761e6b02ce00>
    └ <ForkProcess name='ForkProcess-472' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-472' parent=497161 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x761d79006bd0>, <multiprocessing.queues.SimpleQueue object at 0x761d795c4c...
    │    │        └ <ForkProcess name='ForkProcess-472' parent=497161 started>
    │    └ <function _process_worker at 0x761e6ae711c0>
    └ <ForkProcess name='ForkProcess-472' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x761d7b4c7aa0>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         └ <function run_raw_task at 0x761d7b11a700>
        └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output5/sympy__sympy-18477_2025-10-18_20-31-23'
             │            │    └ <function RawSweTask.to_task at 0x761d7b1196c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x761d7b4c7aa0>
             └ <function do_inference at 0x761d7b11a8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x761d7b228400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x761d7b9b84a0>
       │                 │         │            └ SweTask(task_id='sympy__sympy-18477', problem_statement="Allow to set min_fixed and max_fixed for Float in the printers\nThe ...
       │                 │         └ <app.manage.ProjectApiManager object at 0x761d7b4ef0b0>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output5/sympy__sympy-18477_2025-10-18_20-31-23/output_0')
       └ <function _run_one_task at 0x761d7b2298a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x761d7b431bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x761d790073e0>
                                  └ <app.manage.ProjectApiManager object at 0x761d7b4ef0b0>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'sympy/printing/pycode.py', 'class': 'MpmathPrinter', 'method': '_print_Float', 'intended_behavior': 'This method sh...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x761d7b4318a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x761d795c5160>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x761d790073e0>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ '_print_Float'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/printing/p...
    │    │                      │   └ 'MpmathPrinter'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/printing/p...
    │    └ <function SearchBackend._get_inherited_methods at 0x761d7b431800>
    └ <app.search.search_backend.SearchBackend object at 0x761d795c5160>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'StrPrinter', 'method_name': '_print_Float'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x761d7b430f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x761d795c5160>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x761d795c5160>, {'class_name': 'StrPrinter', 'method_name': '_print_Floa...
           └ <function SearchBackend.search_method_in_class at 0x761d7b430ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-18 20:32:24.539 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/pycode.py</file>
<class>MpmathPrinter</class>
<method>_print_Float</method>
<code>
527     def _print_Float(self, e):
528         # XXX: This does not handle setting mpmath.mp.dps. It is assumed that
529         # the caller of the lambdified function will have set it to sufficient
530         # precision to match the Floats in the expression.
531 
532         # Remove 'mpz' if gmpy is installed.
533         args = str(tuple(map(int, e._mpf_)))
534         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)

</code><intended_behavior>This method should be modified or extended to accept and utilize min_fixed and max_fixed settings for formatting floats. While the existing functionality of converting floats for mpmath compatibility should be preserved, the method should conditionally format the float representation based on these new settings when provided.</intended_behavior>, <file>sympy/printing/pycode.py</file>
<class>MpmathPrinter</class>
<method>None</method>
<code>
513 class MpmathPrinter(PythonCodePrinter):
514     """
515     Lambda printer for mpmath which maintains precision for floats
516     """
517     printmethod = "_mpmathcode"
518 
519     language = "Python with mpmath"
520 
521     _kf = dict(chain(
522         _known_functions.items(),
523         [(k, 'mpmath.' + v) for k, v in _known_functions_mpmath.items()]
524     ))
525     _kc = {k: 'mpmath.'+v for k, v in _known_constants_mpmath.items()}
526 
527     def _print_Float(self, e):
528         # XXX: This does not handle setting mpmath.mp.dps. It is assumed that
529         # the caller of the lambdified function will have set it to sufficient
530         # precision to match the Floats in the expression.
531 
532         # Remove 'mpz' if gmpy is installed.
533         args = str(tuple(map(int, e._mpf_)))
534         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)
535 
536 
537     def _print_Rational(self, e):
538         return "{func}({p})/{func}({q})".format(
539             func=self._module_format('mpmath.mpf'),
540             q=self._print(e.q),
541             p=self._print(e.p)
542         )
543 
544     def _print_Half(self, e):
545         return self._print_Rational(e)
546 
547     def _print_uppergamma(self, e):
548         return "{0}({1}, {2}, {3})".format(
549             self._module_format('mpmath.gammainc'),
550             self._print(e.args[0]),
551             self._print(e.args[1]),
552             self._module_format('mpmath.inf'))
553 
554     def _print_lowergamma(self, e):
555         return "{0}({1}, 0, {2})".format(
556             self._module_format('mpmath.gammainc'),
557             self._print(e.args[0]),
558             self._print(e.args[1]))
559 
560     def _print_log2(self, e):
561         return '{0}({1})/{0}(2)'.format(
562             self._module_format('mpmath.log'), self._print(e.args[0]))
563 
564     def _print_log1p(self, e):
565         return '{0}({1}+1)'.format(
566             self._module_format('mpmath.log'), self._print(e.args[0]))
567 
568     def _print_Pow(self, expr, rational=False):
569         return self._hprint_Pow(expr, rational=rational, sqrt='mpmath.sqrt')

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/numbers.py</file>
<class>Float</class>
<method>None</method>
<code>
858 class Float(Number):
859     """Represent a floating-point number of arbitrary precision.
860 
861     Examples
862     ========
863 
864     >>> from sympy import Float
865     >>> Float(3.5)
866     3.50000000000000
867     >>> Float(3)
868     3.00000000000000
869 
870     Creating Floats from strings (and Python ``int`` and ``long``
871     types) will give a minimum precision of 15 digits, but the
872     precision will automatically increase to capture all digits
873     entered.
874 
875     >>> Float(1)
876     1.00000000000000
877     >>> Float(10**20)
878     100000000000000000000.
879     >>> Float('1e20')
880     100000000000000000000.
881 
882     However, *floating-point* numbers (Python ``float`` types) retain
883     only 15 digits of precision:
884 
885     >>> Float(1e20)
886     1.00000000000000e+20
887     >>> Float(1.23456789123456789)
888     1.23456789123457
889 
890     It may be preferable to enter high-precision decimal numbers
891     as strings:
892 
893     Float('1.23456789123456789')
894     1.23456789123456789
895 
896     The desired number of digits can also be specified:
897 
898     >>> Float('1e-3', 3)
899     0.00100
900     >>> Float(100, 4)
901     100.0
902 
903     Float can automatically count significant figures if a null string
904     is sent for the precision; spaces or underscores are also allowed. (Auto-
905     counting is only allowed for strings, ints and longs).
906 
907     >>> Float('123 456 789.123_456', '')
908     123456789.123456
909     >>> Float('12e-3', '')
910     0.012
911     >>> Float(3, '')
912     3.
913 
914     If a number is written in scientific notation, only the digits before the
915     exponent are considered significant if a decimal appears, otherwise the
916     "e" signifies only how to move the decimal:
917 
918     >>> Float('60.e2', '')  # 2 digits significant
919     6.0e+3
920     >>> Float('60e2', '')  # 4 digits significant
921     6000.
922     >>> Float('600e-2', '')  # 3 digits significant
923     6.00
924 
925     Notes
926     =====
927 
928     Floats are inexact by their nature unless their value is a binary-exact
929     value.
930 
931     >>> approx, exact = Float(.1, 1), Float(.125, 1)
932 
933     For calculation purposes, evalf needs to be able to change the precision
934     but this will not increase the accuracy of the inexact value. The
935     following is the most accurate 5-digit approximation of a value of 0.1
936     that had only 1 digit of precision:
937 
938     >>> approx.evalf(5)
939     0.099609
940 
941     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
942     can be passed to Float or evalf to obtain an arbitrary precision with
943     matching accuracy:
944 
945     >>> Float(exact, 5)
946     0.12500
947     >>> exact.evalf(20)
948     0.12500000000000000000
949 
950     Trying to make a high-precision Float from a float is not disallowed,
951     but one must keep in mind that the *underlying float* (not the apparent
952     decimal value) is being obtained with high precision. For example, 0.3
953     does not have a finite binary representation. The closest rational is
954     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
955     0.3 to 20 digits of precision you will not see the same thing as 0.3
956     followed by 19 zeros:
957 
958     >>> Float(0.3, 20)
959     0.29999999999999998890
960 
961     If you want a 20-digit value of the decimal 0.3 (not the floating point
962     approximation of 0.3) you should send the 0.3 as a string. The underlying
963     representation is still binary but a higher precision than Python's float
964     is used:
965 
966     >>> Float('0.3', 20)
967     0.30000000000000000000
968 
969     Although you can increase the precision of an existing Float using Float
970     it will not increase the accuracy -- the underlying value is not changed:
971 
972     >>> def show(f): # binary rep of Float
973     ...     from sympy import Mul, Pow
974     ...     s, m, e, b = f._mpf_
975     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
976     ...     print('%s at prec=%s' % (v, f._prec))
977     ...
978     >>> t = Float('0.3', 3)
979     >>> show(t)
980     4915/2**14 at prec=13
981     >>> show(Float(t, 20)) # higher prec, not higher accuracy
982     4915/2**14 at prec=70
983     >>> show(Float(t, 2)) # lower prec
984     307/2**10 at prec=10
985 
986     The same thing happens when evalf is used on a Float:
987 
988     >>> show(t.evalf(20))
989     4915/2**14 at prec=70
990     >>> show(t.evalf(2))
991     307/2**10 at prec=10
992 
993     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
994     produce the number (-1)**n*c*2**p:
995 
996     >>> n, c, p = 1, 5, 0
997     >>> (-1)**n*c*2**p
998     -5
999     >>> Float((1, 5, 0))
1000     -5.00000000000000
1001 
1002     An actual mpf tuple also contains the number of bits in c as the last
1003     element of the tuple:
1004 
1005     >>> _._mpf_
1006     (1, 5, 0, 3)
1007 
1008     This is not needed for instantiation and is not the same thing as the
1009     precision. The mpf tuple and the precision are two separate quantities
1010     that Float tracks.
1011 
1012     In SymPy, a Float is a number that can be computed with arbitrary
1013     precision. Although floating point 'inf' and 'nan' are not such
1014     numbers, Float can create these numbers:
1015 
1016     >>> Float('-inf')
1017     -oo
1018     >>> _.is_Float
1019     False
1020     """
1021     __slots__ = ('_mpf_', '_prec')
1022 
1023     # A Float represents many real numbers,
1024     # both rational and irrational.
1025     is_rational = None
1026     is_irrational = None
1027     is_number = True
1028 
1029     is_real = True
1030     is_extended_real = True
1031 
1032     is_Float = True
1033 
1034     def __new__(cls, num, dps=None, prec=None, precision=None):
1035         if prec is not None:
1036             SymPyDeprecationWarning(
1037                             feature="Using 'prec=XX' to denote decimal precision",
1038                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
1039                                               "for binary precision",
1040                             issue=12820,
1041                             deprecated_since_version="1.1").warn()
1042             dps = prec
1043         del prec  # avoid using this deprecated kwarg
1044 
1045         if dps is not None and precision is not None:
1046             raise ValueError('Both decimal and binary precision supplied. '
1047                              'Supply only one. ')
1048 
1049         if isinstance(num, str):
1050             # Float accepts spaces as digit separators
1051             num = num.replace(' ', '').lower()
1052             # in Py 3.6
1053             # underscores are allowed. In anticipation of that, we ignore
1054             # legally placed underscores
1055             if '_' in num:
1056                 parts = num.split('_')
1057                 if not (all(parts) and
1058                         all(parts[i][-1].isdigit()
1059                             for i in range(0, len(parts), 2)) and
1060                         all(parts[i][0].isdigit()
1061                             for i in range(1, len(parts), 2))):
1062                     # copy Py 3.6 error
1063                     raise ValueError("could not convert string to float: '%s'" % num)
1064                 num = ''.join(parts)
1065             if num.startswith('.') and len(num) > 1:
1066                 num = '0' + num
1067             elif num.startswith('-.') and len(num) > 2:
1068                 num = '-0.' + num[2:]
1069             elif num in ('inf', '+inf'):
1070                 return S.Infinity
1071             elif num == '-inf':
1072                 return S.NegativeInfinity
1073         elif isinstance(num, float) and num == 0:
1074             num = '0'
1075         elif isinstance(num, float) and num == float('inf'):
1076             return S.Infinity
1077         elif isinstance(num, float) and num == float('-inf'):
1078             return S.NegativeInfinity
1079         elif isinstance(num, float) and num == float('nan'):
1080             return S.NaN
1081         elif isinstance(num, (SYMPY_INTS, Integer)):
1082             num = str(num)
1083         elif num is S.Infinity:
1084             return num
1085         elif num is S.NegativeInfinity:
1086             return num
1087         elif num is S.NaN:
1088             return num
1089         elif type(num).__module__ == 'numpy': # support for numpy datatypes
1090             num = _convert_numpy_types(num)
1091         elif isinstance(num, mpmath.mpf):
1092             if precision is None:
1093                 if dps is None:
1094                     precision = num.context.prec
1095             num = num._mpf_
1096 
1097         if dps is None and precision is None:
1098             dps = 15
1099             if isinstance(num, Float):
1100                 return num
1101             if isinstance(num, str) and _literal_float(num):
1102                 try:
1103                     Num = decimal.Decimal(num)
1104                 except decimal.InvalidOperation:
1105                     pass
1106                 else:
1107                     isint = '.' not in num
1108                     num, dps = _decimal_to_Rational_prec(Num)
1109                     if num.is_Integer and isint:
1110                         dps = max(dps, len(str(num).lstrip('-')))
1111                     dps = max(15, dps)
1112                     precision = mlib.libmpf.dps_to_prec(dps)
1113         elif precision == '' and dps is None or precision is None and dps == '':
1114             if not isinstance(num, str):
1115                 raise ValueError('The null string can only be used when '
1116                 'the number to Float is passed as a string or an integer.')
1117             ok = None
1118             if _literal_float(num):
1119                 try:
1120                     Num = decimal.Decimal(num)
1121                 except decimal.InvalidOperation:
1122                     pass
1123                 else:
1124                     isint = '.' not in num
1125                     num, dps = _decimal_to_Rational_prec(Num)
1126                     if num.is_Integer and isint:
1127                         dps = max(dps, len(str(num).lstrip('-')))
1128                         precision = mlib.libmpf.dps_to_prec(dps)
1129                     ok = True
1130             if ok is None:
1131                 raise ValueError('string-float not recognized: %s' % num)
1132 
1133         # decimal precision(dps) is set and maybe binary precision(precision)
1134         # as well.From here on binary precision is used to compute the Float.
1135         # Hence, if supplied use binary precision else translate from decimal
1136         # precision.
1137 
1138         if precision is None or precision == '':
1139             precision = mlib.libmpf.dps_to_prec(dps)
1140 
1141         precision = int(precision)
1142 
1143         if isinstance(num, float):
1144             _mpf_ = mlib.from_float(num, precision, rnd)
1145         elif isinstance(num, str):
1146             _mpf_ = mlib.from_str(num, precision, rnd)
1147         elif isinstance(num, decimal.Decimal):
1148             if num.is_finite():
1149                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1150             elif num.is_nan():
1151                 return S.NaN
1152             elif num.is_infinite():
1153                 if num > 0:
1154                     return S.Infinity
1155                 return S.NegativeInfinity
1156             else:
1157                 raise ValueError("unexpected decimal value %s" % str(num))
1158         elif isinstance(num, tuple) and len(num) in (3, 4):
1159             if type(num[1]) is str:
1160                 # it's a hexadecimal (coming from a pickled object)
1161                 # assume that it is in standard form
1162                 num = list(num)
1163                 # If we're loading an object pickled in Python 2 into
1164                 # Python 3, we may need to strip a tailing 'L' because
1165                 # of a shim for int on Python 3, see issue #13470.
1166                 if num[1].endswith('L'):
1167                     num[1] = num[1][:-1]
1168                 num[1] = MPZ(num[1], 16)
1169                 _mpf_ = tuple(num)
1170             else:
1171                 if len(num) == 4:
1172                     # handle normalization hack
1173                     return Float._new(num, precision)
1174                 else:
1175                     if not all((
1176                             num[0] in (0, 1),
1177                             num[1] >= 0,
1178                             all(type(i) in (long, int) for i in num)
1179                             )):
1180                         raise ValueError('malformed mpf: %s' % (num,))
1181                     # don't compute number or else it may
1182                     # over/underflow
1183                     return Float._new(
1184                         (num[0], num[1], num[2], bitcount(num[1])),
1185                         precision)
1186         else:
1187             try:
1188                 _mpf_ = num._as_mpf_val(precision)
1189             except (NotImplementedError, AttributeError):
1190                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1191 
1192         return cls._new(_mpf_, precision, zero=False)
1193 
1194     @classmethod
1195     def _new(cls, _mpf_, _prec, zero=True):
1196         # special cases
1197         if zero and _mpf_ == fzero:
1198             return S.Zero  # Float(0) -> 0.0; Float._new((0,0,0,0)) -> 0
1199         elif _mpf_ == _mpf_nan:
1200             return S.NaN
1201         elif _mpf_ == _mpf_inf:
1202             return S.Infinity
1203         elif _mpf_ == _mpf_ninf:
1204             return S.NegativeInfinity
1205 
1206         obj = Expr.__new__(cls)
1207         obj._mpf_ = mpf_norm(_mpf_, _prec)
1208         obj._prec = _prec
1209         return obj
1210 
1211     # mpz can't be pickled
1212     def __getnewargs__(self):
1213         return (mlib.to_pickable(self._mpf_),)
1214 
1215     def __getstate__(self):
1216         return {'_prec': self._prec}
1217 
1218     def _hashable_content(self):
1219         return (self._mpf_, self._prec)
1220 
1221     def floor(self):
1222         return Integer(int(mlib.to_int(
1223             mlib.mpf_floor(self._mpf_, self._prec))))
1224 
1225     def ceiling(self):
1226         return Integer(int(mlib.to_int(
1227             mlib.mpf_ceil(self._mpf_, self._prec))))
1228 
1229     def __floor__(self):
1230         return self.floor()
1231 
1232     def __ceil__(self):
1233         return self.ceiling()
1234 
1235     @property
1236     def num(self):
1237         return mpmath.mpf(self._mpf_)
1238 
1239     def _as_mpf_val(self, prec):
1240         rv = mpf_norm(self._mpf_, prec)
1241         if rv != self._mpf_ and self._prec == prec:
1242             debug(self._mpf_, rv)
1243         return rv
1244 
1245     def _as_mpf_op(self, prec):
1246         return self._mpf_, max(prec, self._prec)
1247 
1248     def _eval_is_finite(self):
1249         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1250             return False
1251         return True
1252 
1253     def _eval_is_infinite(self):
1254         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1255             return True
1256         return False
1257 
1258     def _eval_is_integer(self):
1259         return self._mpf_ == fzero
1260 
1261     def _eval_is_negative(self):
1262         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1263             return False
1264         return self.num < 0
1265 
1266     def _eval_is_positive(self):
1267         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1268             return False
1269         return self.num > 0
1270 
1271     def _eval_is_extended_negative(self):
1272         if self._mpf_ == _mpf_ninf:
1273             return True
1274         if self._mpf_ == _mpf_inf:
1275             return False
1276         return self.num < 0
1277 
1278     def _eval_is_extended_positive(self):
1279         if self._mpf_ == _mpf_inf:
1280             return True
1281         if self._mpf_ == _mpf_ninf:
1282             return False
1283         return self.num > 0
1284 
1285     def _eval_is_zero(self):
1286         return self._mpf_ == fzero
1287 
1288     def __nonzero__(self):
1289         return self._mpf_ != fzero
1290 
1291     __bool__ = __nonzero__
1292 
1293     def __neg__(self):
1294         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1295 
1296     @_sympifyit('other', NotImplemented)
1297     def __add__(self, other):
1298         if isinstance(other, Number) and global_parameters.evaluate:
1299             rhs, prec = other._as_mpf_op(self._prec)
1300             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1301         return Number.__add__(self, other)
1302 
1303     @_sympifyit('other', NotImplemented)
1304     def __sub__(self, other):
1305         if isinstance(other, Number) and global_parameters.evaluate:
1306             rhs, prec = other._as_mpf_op(self._prec)
1307             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1308         return Number.__sub__(self, other)
1309 
1310     @_sympifyit('other', NotImplemented)
1311     def __mul__(self, other):
1312         if isinstance(other, Number) and global_parameters.evaluate:
1313             rhs, prec = other._as_mpf_op(self._prec)
1314             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1315         return Number.__mul__(self, other)
1316 
1317     @_sympifyit('other', NotImplemented)
1318     def __div__(self, other):
1319         if isinstance(other, Number) and other != 0 and global_parameters.evaluate:
1320             rhs, prec = other._as_mpf_op(self._prec)
1321             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1322         return Number.__div__(self, other)
1323 
1324     __truediv__ = __div__
1325 
1326     @_sympifyit('other', NotImplemented)
1327     def __mod__(self, other):
1328         if isinstance(other, Rational) and other.q != 1 and global_parameters.evaluate:
1329             # calculate mod with Rationals, *then* round the result
1330             return Float(Rational.__mod__(Rational(self), other),
1331                          precision=self._prec)
1332         if isinstance(other, Float) and global_parameters.evaluate:
1333             r = self/other
1334             if r == int(r):
1335                 return Float(0, precision=max(self._prec, other._prec))
1336         if isinstance(other, Number) and global_parameters.evaluate:
1337             rhs, prec = other._as_mpf_op(self._prec)
1338             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1339         return Number.__mod__(self, other)
1340 
1341     @_sympifyit('other', NotImplemented)
1342     def __rmod__(self, other):
1343         if isinstance(other, Float) and global_parameters.evaluate:
1344             return other.__mod__(self)
1345         if isinstance(other, Number) and global_parameters.evaluate:
1346             rhs, prec = other._as_mpf_op(self._prec)
1347             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1348         return Number.__rmod__(self, other)
1349 
1350     def _eval_power(self, expt):
1351         """
1352         expt is symbolic object but not equal to 0, 1
1353 
1354         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1355                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1356         """
1357         if self == 0:
1358             if expt.is_positive:
1359                 return S.Zero
1360             if expt.is_negative:
1361                 return S.Infinity
1362         if isinstance(expt, Number):
1363             if isinstance(expt, Integer):
1364                 prec = self._prec
1365                 return Float._new(
1366                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1367             elif isinstance(expt, Rational) and \
1368                     expt.p == 1 and expt.q % 2 and self.is_negative:
1369                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1370                     -self)._eval_power(expt)
1371             expt, prec = expt._as_mpf_op(self._prec)
1372             mpfself = self._mpf_
1373             try:
1374                 y = mpf_pow(mpfself, expt, prec, rnd)
1375                 return Float._new(y, prec)
1376             except mlib.ComplexResult:
1377                 re, im = mlib.mpc_pow(
1378                     (mpfself, fzero), (expt, fzero), prec, rnd)
1379                 return Float._new(re, prec) + \
1380                     Float._new(im, prec)*S.ImaginaryUnit
1381 
1382     def __abs__(self):
1383         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1384 
1385     def __int__(self):
1386         if self._mpf_ == fzero:
1387             return 0
1388         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1389 
1390     __long__ = __int__
1391 
1392     def __eq__(self, other):
1393         try:
1394             other = _sympify(other)
1395         except SympifyError:
1396             return NotImplemented
1397         if not self:
1398             return not other
1399         if other.is_NumberSymbol:
1400             if other.is_irrational:
1401                 return False
1402             return other.__eq__(self)
1403         if other.is_Float:
1404             # comparison is exact
1405             # so Float(.1, 3) != Float(.1, 33)
1406             return self._mpf_ == other._mpf_
1407         if other.is_Rational:
1408             return other.__eq__(self)
1409         if other.is_Number:
1410             # numbers should compare at the same precision;
1411             # all _as_mpf_val routines should be sure to abide
1412             # by the request to change the prec if necessary; if
1413             # they don't, the equality test will fail since it compares
1414             # the mpf tuples
1415             ompf = other._as_mpf_val(self._prec)
1416             return bool(mlib.mpf_eq(self._mpf_, ompf))
1417         return False    # Float != non-Number
1418 
1419     def __ne__(self, other):
1420         return not self == other
1421 
1422     def _Frel(self, other, op):
1423         from sympy.core.numbers import prec_to_dps
1424         try:
1425             other = _sympify(other)
1426         except SympifyError:
1427             return NotImplemented
1428         if other.is_Rational:
1429             # test self*other.q <?> other.p without losing precision
1430             '''
1431             >>> f = Float(.1,2)
1432             >>> i = 1234567890
1433             >>> (f*i)._mpf_
1434             (0, 471, 18, 9)
1435             >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))
1436             (0, 505555550955, -12, 39)
1437             '''
1438             smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
1439             ompf = mlib.from_int(other.p)
1440             return _sympify(bool(op(smpf, ompf)))
1441         elif other.is_Float:
1442             return _sympify(bool(
1443                         op(self._mpf_, other._mpf_)))
1444         elif other.is_comparable and other not in (
1445                 S.Infinity, S.NegativeInfinity):
1446             other = other.evalf(prec_to_dps(self._prec))
1447             if other._prec > 1:
1448                 if other.is_Number:
1449                     return _sympify(bool(
1450                         op(self._mpf_, other._as_mpf_val(self._prec))))
1451 
1452     def __gt__(self, other):
1453         if isinstance(other, NumberSymbol):
1454             return other.__lt__(self)
1455         rv = self._Frel(other, mlib.mpf_gt)
1456         if rv is None:
1457             return Expr.__gt__(self, other)
1458         return rv
1459 
1460     def __ge__(self, other):
1461         if isinstance(other, NumberSymbol):
1462             return other.__le__(self)
1463         rv = self._Frel(other, mlib.mpf_ge)
1464         if rv is None:
1465             return Expr.__ge__(self, other)
1466         return rv
1467 
1468     def __lt__(self, other):
1469         if isinstance(other, NumberSymbol):
1470             return other.__gt__(self)
1471         rv = self._Frel(other, mlib.mpf_lt)
1472         if rv is None:
1473             return Expr.__lt__(self, other)
1474         return rv
1475 
1476     def __le__(self, other):
1477         if isinstance(other, NumberSymbol):
1478             return other.__ge__(self)
1479         rv = self._Frel(other, mlib.mpf_le)
1480         if rv is None:
1481             return Expr.__le__(self, other)
1482         return rv
1483 
1484     def __hash__(self):
1485         return super(Float, self).__hash__()
1486 
1487     def epsilon_eq(self, other, epsilon="1e-15"):
1488         return abs(self - other) < Float(epsilon)
1489 
1490     def _sage_(self):
1491         import sage.all as sage
1492         return sage.RealNumber(str(self))
1493 
1494     def __format__(self, format_spec):
1495         return format(decimal.Decimal(str(self)), format_spec)

</code><intended_behavior>Although the class implementation does not necessarily embody a 'bug' per se, to accommodate the issue, it might require extension to store and manage min_fixed and max_fixed attributes. This entails modifying the __new__ or _new method to optionally accept these parameters and adjusting relevant formatting methods (potentially including a custom __format__ or enhancing existing methods) to leverage these values when transforming Float instances to strings.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Float</method>
<code>
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real

</code><intended_behavior>This method currently applies strip_zeros=True unconditionally. To resolve the issue, the behavior should be changed to factor in min_fixed and max_fixed preferences. This could involve: 1) adjusting the method to check for and apply these settings if they are present in the Float instance or globally within the printer settings, and 2) ensuring that when these settings are active, the zeros stripping and number formatting are aligned with them, preserving existing functionality when they are not specified.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
124 class LatexPrinter(Printer):
125     printmethod = "_latex"
126 
127     _default_settings = {
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "inv_trig_style": "abbreviated",
132         "itex": False,
133         "ln_notation": False,
134         "long_frac_ratio": None,
135         "mat_delim": "[",
136         "mat_str": None,
137         "mode": "plain",
138         "mul_symbol": None,
139         "order": None,
140         "symbol_names": {},
141         "root_notation": True,
142         "mat_symbol_style": "plain",
143         "imaginary_unit": "i",
144         "gothic_re_im": False,
145         "decimal_separator": "period",
146         "perm_cyclic": True,
147     }  # type: Dict[str, Any]
148 
149     def __init__(self, settings=None):
150         Printer.__init__(self, settings)
151 
152         if 'mode' in self._settings:
153             valid_modes = ['inline', 'plain', 'equation',
154                            'equation*']
155             if self._settings['mode'] not in valid_modes:
156                 raise ValueError("'mode' must be one of 'inline', 'plain', "
157                                  "'equation' or 'equation*'")
158 
159         if self._settings['fold_short_frac'] is None and \
160                 self._settings['mode'] == 'inline':
161             self._settings['fold_short_frac'] = True
162 
163         mul_symbol_table = {
164             None: r" ",
165             "ldot": r" \,.\, ",
166             "dot": r" \cdot ",
167             "times": r" \times "
168         }
169         try:
170             self._settings['mul_symbol_latex'] = \
171                 mul_symbol_table[self._settings['mul_symbol']]
172         except KeyError:
173             self._settings['mul_symbol_latex'] = \
174                 self._settings['mul_symbol']
175         try:
176             self._settings['mul_symbol_latex_numbers'] = \
177                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
178         except KeyError:
179             if (self._settings['mul_symbol'].strip() in
180                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
181                 self._settings['mul_symbol_latex_numbers'] = \
182                     mul_symbol_table['dot']
183             else:
184                 self._settings['mul_symbol_latex_numbers'] = \
185                     self._settings['mul_symbol']
186 
187         self._delim_dict = {'(': ')', '[': ']'}
188 
189         imaginary_unit_table = {
190             None: r"i",
191             "i": r"i",
192             "ri": r"\mathrm{i}",
193             "ti": r"\text{i}",
194             "j": r"j",
195             "rj": r"\mathrm{j}",
196             "tj": r"\text{j}",
197         }
198         try:
199             self._settings['imaginary_unit_latex'] = \
200                 imaginary_unit_table[self._settings['imaginary_unit']]
201         except KeyError:
202             self._settings['imaginary_unit_latex'] = \
203                 self._settings['imaginary_unit']
204 
205     def parenthesize(self, item, level, strict=False):
206         prec_val = precedence_traditional(item)
207         if (prec_val < level) or ((not strict) and prec_val <= level):
208             return r"\left({}\right)".format(self._print(item))
209         else:
210             return self._print(item)
211 
212     def parenthesize_super(self, s):
213         """ Parenthesize s if there is a superscript in s"""
214         if "^" in s:
215             return r"\left({}\right)".format(s)
216         return s
217 
218     def embed_super(self, s):
219         """ Embed s in {} if there is a superscript in s"""
220         if "^" in s:
221             return "{{{}}}".format(s)
222         return s
223 
224     def doprint(self, expr):
225         tex = Printer.doprint(self, expr)
226 
227         if self._settings['mode'] == 'plain':
228             return tex
229         elif self._settings['mode'] == 'inline':
230             return r"$%s$" % tex
231         elif self._settings['itex']:
232             return r"$$%s$$" % tex
233         else:
234             env_str = self._settings['mode']
235             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
236 
237     def _needs_brackets(self, expr):
238         """
239         Returns True if the expression needs to be wrapped in brackets when
240         printed, False otherwise. For example: a + b => True; a => False;
241         10 => False; -10 => True.
242         """
243         return not ((expr.is_Integer and expr.is_nonnegative)
244                     or (expr.is_Atom and (expr is not S.NegativeOne
245                                           and expr.is_Rational is False)))
246 
247     def _needs_function_brackets(self, expr):
248         """
249         Returns True if the expression needs to be wrapped in brackets when
250         passed as an argument to a function, False otherwise. This is a more
251         liberal version of _needs_brackets, in that many expressions which need
252         to be wrapped in brackets when added/subtracted/raised to a power do
253         not need them when passed to a function. Such an example is a*b.
254         """
255         if not self._needs_brackets(expr):
256             return False
257         else:
258             # Muls of the form a*b*c... can be folded
259             if expr.is_Mul and not self._mul_is_clean(expr):
260                 return True
261             # Pows which don't need brackets can be folded
262             elif expr.is_Pow and not self._pow_is_clean(expr):
263                 return True
264             # Add and Function always need brackets
265             elif expr.is_Add or expr.is_Function:
266                 return True
267             else:
268                 return False
269 
270     def _needs_mul_brackets(self, expr, first=False, last=False):
271         """
272         Returns True if the expression needs to be wrapped in brackets when
273         printed as part of a Mul, False otherwise. This is True for Add,
274         but also for some container objects that would not need brackets
275         when appearing last in a Mul, e.g. an Integral. ``last=True``
276         specifies that this expr is the last to appear in a Mul.
277         ``first=True`` specifies that this expr is the first to appear in
278         a Mul.
279         """
280         from sympy import Integral, Product, Sum
281 
282         if expr.is_Mul:
283             if not first and _coeff_isneg(expr):
284                 return True
285         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
286             return True
287         elif expr.is_Relational:
288             return True
289         if expr.is_Piecewise:
290             return True
291         if any([expr.has(x) for x in (Mod,)]):
292             return True
293         if (not last and
294                 any([expr.has(x) for x in (Integral, Product, Sum)])):
295             return True
296 
297         return False
298 
299     def _needs_add_brackets(self, expr):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of an Add, False otherwise.  This is False for most
303         things.
304         """
305         if expr.is_Relational:
306             return True
307         if any([expr.has(x) for x in (Mod,)]):
308             return True
309         if expr.is_Add:
310             return True
311         return False
312 
313     def _mul_is_clean(self, expr):
314         for arg in expr.args:
315             if arg.is_Function:
316                 return False
317         return True
318 
319     def _pow_is_clean(self, expr):
320         return not self._needs_brackets(expr.base)
321 
322     def _do_exponent(self, expr, exp):
323         if exp is not None:
324             return r"\left(%s\right)^{%s}" % (expr, exp)
325         else:
326             return expr
327 
328     def _print_Basic(self, expr):
329         ls = [self._print(o) for o in expr.args]
330         return self._deal_with_super_sub(expr.__class__.__name__) + \
331             r"\left(%s\right)" % ", ".join(ls)
332 
333     def _print_bool(self, e):
334         return r"\text{%s}" % e
335 
336     _print_BooleanTrue = _print_bool
337     _print_BooleanFalse = _print_bool
338 
339     def _print_NoneType(self, e):
340         return r"\text{%s}" % e
341 
342     def _print_Add(self, expr, order=None):
343         if self.order == 'none':
344             terms = list(expr.args)
345         else:
346             terms = self._as_ordered_terms(expr, order=order)
347 
348         tex = ""
349         for i, term in enumerate(terms):
350             if i == 0:
351                 pass
352             elif _coeff_isneg(term):
353                 tex += " - "
354                 term = -term
355             else:
356                 tex += " + "
357             term_tex = self._print(term)
358             if self._needs_add_brackets(term):
359                 term_tex = r"\left(%s\right)" % term_tex
360             tex += term_tex
361 
362         return tex
363 
364     def _print_Cycle(self, expr):
365         from sympy.combinatorics.permutations import Permutation
366         if expr.size == 0:
367             return r"\left( \right)"
368         expr = Permutation(expr)
369         expr_perm = expr.cyclic_form
370         siz = expr.size
371         if expr.array_form[-1] == siz - 1:
372             expr_perm = expr_perm + [[siz - 1]]
373         term_tex = ''
374         for i in expr_perm:
375             term_tex += str(i).replace(',', r"\;")
376         term_tex = term_tex.replace('[', r"\left( ")
377         term_tex = term_tex.replace(']', r"\right)")
378         return term_tex
379 
380     def _print_Permutation(self, expr):
381         from sympy.combinatorics.permutations import Permutation
382         from sympy.utilities.exceptions import SymPyDeprecationWarning
383 
384         perm_cyclic = Permutation.print_cyclic
385         if perm_cyclic is not None:
386             SymPyDeprecationWarning(
387                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
388                 useinstead="init_printing(perm_cyclic={})"
389                 .format(perm_cyclic),
390                 issue=15201,
391                 deprecated_since_version="1.6").warn()
392         else:
393             perm_cyclic = self._settings.get("perm_cyclic", True)
394 
395         if perm_cyclic:
396             return self._print_Cycle(expr)
397 
398         if expr.size == 0:
399             return r"\left( \right)"
400 
401         lower = [self._print(arg) for arg in expr.array_form]
402         upper = [self._print(arg) for arg in range(len(lower))]
403 
404         row1 = " & ".join(upper)
405         row2 = " & ".join(lower)
406         mat = r" \\ ".join((row1, row2))
407         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
408 
409 
410     def _print_AppliedPermutation(self, expr):
411         perm, var = expr.args
412         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
413 
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real
440 
441     def _print_Cross(self, expr):
442         vec1 = expr._expr1
443         vec2 = expr._expr2
444         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
445                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
446 
447     def _print_Curl(self, expr):
448         vec = expr._expr
449         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
450 
451     def _print_Divergence(self, expr):
452         vec = expr._expr
453         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
454 
455     def _print_Dot(self, expr):
456         vec1 = expr._expr1
457         vec2 = expr._expr2
458         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
459                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
460 
461     def _print_Gradient(self, expr):
462         func = expr._expr
463         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
464 
465     def _print_Laplacian(self, expr):
466         func = expr._expr
467         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
468 
469     def _print_Mul(self, expr):
470         from sympy.core.power import Pow
471         from sympy.physics.units import Quantity
472         include_parens = False
473         if _coeff_isneg(expr):
474             expr = -expr
475             tex = "- "
476             if expr.is_Add:
477                 tex += "("
478                 include_parens = True
479         else:
480             tex = ""
481 
482         from sympy.simplify import fraction
483         numer, denom = fraction(expr, exact=True)
484         separator = self._settings['mul_symbol_latex']
485         numbersep = self._settings['mul_symbol_latex_numbers']
486 
487         def convert(expr):
488             if not expr.is_Mul:
489                 return str(self._print(expr))
490             else:
491                 _tex = last_term_tex = ""
492 
493                 if self.order not in ('old', 'none'):
494                     args = expr.as_ordered_factors()
495                 else:
496                     args = list(expr.args)
497 
498                 # If quantities are present append them at the back
499                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
500                               (isinstance(x, Pow) and
501                                isinstance(x.base, Quantity)))
502 
503                 for i, term in enumerate(args):
504                     term_tex = self._print(term)
505 
506                     if self._needs_mul_brackets(term, first=(i == 0),
507                                                 last=(i == len(args) - 1)):
508                         term_tex = r"\left(%s\right)" % term_tex
509 
510                     if _between_two_numbers_p[0].search(last_term_tex) and \
511                             _between_two_numbers_p[1].match(term_tex):
512                         # between two numbers
513                         _tex += numbersep
514                     elif _tex:
515                         _tex += separator
516 
517                     _tex += term_tex
518                     last_term_tex = term_tex
519                 return _tex
520 
521         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
522             # use the original expression here, since fraction() may have
523             # altered it when producing numer and denom
524             tex += convert(expr)
525 
526         else:
527             snumer = convert(numer)
528             sdenom = convert(denom)
529             ldenom = len(sdenom.split())
530             ratio = self._settings['long_frac_ratio']
531             if self._settings['fold_short_frac'] and ldenom <= 2 and \
532                     "^" not in sdenom:
533                 # handle short fractions
534                 if self._needs_mul_brackets(numer, last=False):
535                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
536                 else:
537                     tex += r"%s / %s" % (snumer, sdenom)
538             elif ratio is not None and \
539                     len(snumer.split()) > ratio*ldenom:
540                 # handle long fractions
541                 if self._needs_mul_brackets(numer, last=True):
542                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
543                         % (sdenom, separator, snumer)
544                 elif numer.is_Mul:
545                     # split a long numerator
546                     a = S.One
547                     b = S.One
548                     for x in numer.args:
549                         if self._needs_mul_brackets(x, last=False) or \
550                                 len(convert(a*x).split()) > ratio*ldenom or \
551                                 (b.is_commutative is x.is_commutative is False):
552                             b *= x
553                         else:
554                             a *= x
555                     if self._needs_mul_brackets(b, last=True):
556                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
557                             % (convert(a), sdenom, separator, convert(b))
558                     else:
559                         tex += r"\frac{%s}{%s}%s%s" \
560                             % (convert(a), sdenom, separator, convert(b))
561                 else:
562                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
563             else:
564                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
565 
566         if include_parens:
567             tex += ")"
568         return tex
569 
570     def _print_Pow(self, expr):
571         # Treat x**Rational(1,n) as special case
572         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
573                 and self._settings['root_notation']:
574             base = self._print(expr.base)
575             expq = expr.exp.q
576 
577             if expq == 2:
578                 tex = r"\sqrt{%s}" % base
579             elif self._settings['itex']:
580                 tex = r"\root{%d}{%s}" % (expq, base)
581             else:
582                 tex = r"\sqrt[%d]{%s}" % (expq, base)
583 
584             if expr.exp.is_negative:
585                 return r"\frac{1}{%s}" % tex
586             else:
587                 return tex
588         elif self._settings['fold_frac_powers'] \
589             and expr.exp.is_Rational \
590                 and expr.exp.q != 1:
591             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
592             p, q = expr.exp.p, expr.exp.q
593             # issue #12886: add parentheses for superscripts raised to powers
594             if '^' in base and expr.base.is_Symbol:
595                 base = r"\left(%s\right)" % base
596             if expr.base.is_Function:
597                 return self._print(expr.base, exp="%s/%s" % (p, q))
598             return r"%s^{%s/%s}" % (base, p, q)
599         elif expr.exp.is_Rational and expr.exp.is_negative and \
600                 expr.base.is_commutative:
601             # special case for 1^(-x), issue 9216
602             if expr.base == 1:
603                 return r"%s^{%s}" % (expr.base, expr.exp)
604             # things like 1/x
605             return self._print_Mul(expr)
606         else:
607             if expr.base.is_Function:
608                 return self._print(expr.base, exp=self._print(expr.exp))
609             else:
610                 tex = r"%s^{%s}"
611                 return self._helper_print_standard_power(expr, tex)
612 
613     def _helper_print_standard_power(self, expr, template):
614         exp = self._print(expr.exp)
615         # issue #12886: add parentheses around superscripts raised
616         # to powers
617         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
618         if '^' in base and expr.base.is_Symbol:
619             base = r"\left(%s\right)" % base
620         elif (isinstance(expr.base, Derivative)
621             and base.startswith(r'\left(')
622             and re.match(r'\\left\(\\d?d?dot', base)
623             and base.endswith(r'\right)')):
624             # don't use parentheses around dotted derivative
625             base = base[6: -7]  # remove outermost added parens
626         return template % (base, exp)
627 
628     def _print_UnevaluatedExpr(self, expr):
629         return self._print(expr.args[0])
630 
631     def _print_Sum(self, expr):
632         if len(expr.limits) == 1:
633             tex = r"\sum_{%s=%s}^{%s} " % \
634                 tuple([self._print(i) for i in expr.limits[0]])
635         else:
636             def _format_ineq(l):
637                 return r"%s \leq %s \leq %s" % \
638                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
639 
640             tex = r"\sum_{\substack{%s}} " % \
641                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
642 
643         if isinstance(expr.function, Add):
644             tex += r"\left(%s\right)" % self._print(expr.function)
645         else:
646             tex += self._print(expr.function)
647 
648         return tex
649 
650     def _print_Product(self, expr):
651         if len(expr.limits) == 1:
652             tex = r"\prod_{%s=%s}^{%s} " % \
653                 tuple([self._print(i) for i in expr.limits[0]])
654         else:
655             def _format_ineq(l):
656                 return r"%s \leq %s \leq %s" % \
657                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
658 
659             tex = r"\prod_{\substack{%s}} " % \
660                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
661 
662         if isinstance(expr.function, Add):
663             tex += r"\left(%s\right)" % self._print(expr.function)
664         else:
665             tex += self._print(expr.function)
666 
667         return tex
668 
669     def _print_BasisDependent(self, expr):
670         from sympy.vector import Vector
671 
672         o1 = []
673         if expr == expr.zero:
674             return expr.zero._latex_form
675         if isinstance(expr, Vector):
676             items = expr.separate().items()
677         else:
678             items = [(0, expr)]
679 
680         for system, vect in items:
681             inneritems = list(vect.components.items())
682             inneritems.sort(key=lambda x: x[0].__str__())
683             for k, v in inneritems:
684                 if v == 1:
685                     o1.append(' + ' + k._latex_form)
686                 elif v == -1:
687                     o1.append(' - ' + k._latex_form)
688                 else:
689                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
690                     o1.append(' + ' + arg_str + k._latex_form)
691 
692         outstr = (''.join(o1))
693         if outstr[1] != '-':
694             outstr = outstr[3:]
695         else:
696             outstr = outstr[1:]
697         return outstr
698 
699     def _print_Indexed(self, expr):
700         tex_base = self._print(expr.base)
701         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
702             map(self._print, expr.indices))
703         return tex
704 
705     def _print_IndexedBase(self, expr):
706         return self._print(expr.label)
707 
708     def _print_Derivative(self, expr):
709         if requires_partial(expr.expr):
710             diff_symbol = r'\partial'
711         else:
712             diff_symbol = r'd'
713 
714         tex = ""
715         dim = 0
716         for x, num in reversed(expr.variable_count):
717             dim += num
718             if num == 1:
719                 tex += r"%s %s" % (diff_symbol, self._print(x))
720             else:
721                 tex += r"%s %s^{%s}" % (diff_symbol,
722                                         self.parenthesize_super(self._print(x)),
723                                         self._print(num))
724 
725         if dim == 1:
726             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
727         else:
728             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
729 
730         return r"%s %s" % (tex, self.parenthesize(expr.expr,
731                                                   PRECEDENCE["Mul"],
732                                                   strict=True))
733 
734     def _print_Subs(self, subs):
735         expr, old, new = subs.args
736         latex_expr = self._print(expr)
737         latex_old = (self._print(e) for e in old)
738         latex_new = (self._print(e) for e in new)
739         latex_subs = r'\\ '.join(
740             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
741         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
742                                                          latex_subs)
743 
744     def _print_Integral(self, expr):
745         tex, symbols = "", []
746 
747         # Only up to \iiiint exists
748         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
749             # Use len(expr.limits)-1 so that syntax highlighters don't think
750             # \" is an escaped quote
751             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
752             symbols = [r"\, d%s" % self._print(symbol[0])
753                        for symbol in expr.limits]
754 
755         else:
756             for lim in reversed(expr.limits):
757                 symbol = lim[0]
758                 tex += r"\int"
759 
760                 if len(lim) > 1:
761                     if self._settings['mode'] != 'inline' \
762                             and not self._settings['itex']:
763                         tex += r"\limits"
764 
765                     if len(lim) == 3:
766                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
767                                                self._print(lim[2]))
768                     if len(lim) == 2:
769                         tex += "^{%s}" % (self._print(lim[1]))
770 
771                 symbols.insert(0, r"\, d%s" % self._print(symbol))
772 
773         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
774                                                     PRECEDENCE["Mul"],
775                                                     strict=True),
776                              "".join(symbols))
777 
778     def _print_Limit(self, expr):
779         e, z, z0, dir = expr.args
780 
781         tex = r"\lim_{%s \to " % self._print(z)
782         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
783             tex += r"%s}" % self._print(z0)
784         else:
785             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
786 
787         if isinstance(e, AssocOp):
788             return r"%s\left(%s\right)" % (tex, self._print(e))
789         else:
790             return r"%s %s" % (tex, self._print(e))
791 
792     def _hprint_Function(self, func):
793         r'''
794         Logic to decide how to render a function to latex
795           - if it is a recognized latex name, use the appropriate latex command
796           - if it is a single letter, just use that letter
797           - if it is a longer name, then put \operatorname{} around it and be
798             mindful of undercores in the name
799         '''
800         func = self._deal_with_super_sub(func)
801         if func in accepted_latex_functions:
802             name = r"\%s" % func
803         elif len(func) == 1 or func.startswith('\\'):
804             name = func
805         else:
806             name = r"\operatorname{%s}" % func
807         return name
808 
809     def _print_Function(self, expr, exp=None):
810         r'''
811         Render functions to LaTeX, handling functions that LaTeX knows about
812         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
813         For single-letter function names, render them as regular LaTeX math
814         symbols. For multi-letter function names that LaTeX does not know
815         about, (e.g., Li, sech) use \operatorname{} so that the function name
816         is rendered in Roman font and LaTeX handles spacing properly.
817 
818         expr is the expression involving the function
819         exp is an exponent
820         '''
821         func = expr.func.__name__
822         if hasattr(self, '_print_' + func) and \
823                 not isinstance(expr, AppliedUndef):
824             return getattr(self, '_print_' + func)(expr, exp)
825         else:
826             args = [str(self._print(arg)) for arg in expr.args]
827             # How inverse trig functions should be displayed, formats are:
828             # abbreviated: asin, full: arcsin, power: sin^-1
829             inv_trig_style = self._settings['inv_trig_style']
830             # If we are dealing with a power-style inverse trig function
831             inv_trig_power_case = False
832             # If it is applicable to fold the argument brackets
833             can_fold_brackets = self._settings['fold_func_brackets'] and \
834                 len(args) == 1 and \
835                 not self._needs_function_brackets(expr.args[0])
836 
837             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
838 
839             # If the function is an inverse trig function, handle the style
840             if func in inv_trig_table:
841                 if inv_trig_style == "abbreviated":
842                     pass
843                 elif inv_trig_style == "full":
844                     func = "arc" + func[1:]
845                 elif inv_trig_style == "power":
846                     func = func[1:]
847                     inv_trig_power_case = True
848 
849                     # Can never fold brackets if we're raised to a power
850                     if exp is not None:
851                         can_fold_brackets = False
852 
853             if inv_trig_power_case:
854                 if func in accepted_latex_functions:
855                     name = r"\%s^{-1}" % func
856                 else:
857                     name = r"\operatorname{%s}^{-1}" % func
858             elif exp is not None:
859                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
860             else:
861                 name = self._hprint_Function(func)
862 
863             if can_fold_brackets:
864                 if func in accepted_latex_functions:
865                     # Wrap argument safely to avoid parse-time conflicts
866                     # with the function name itself
867                     name += r" {%s}"
868                 else:
869                     name += r"%s"
870             else:
871                 name += r"{\left(%s \right)}"
872 
873             if inv_trig_power_case and exp is not None:
874                 name += r"^{%s}" % exp
875 
876             return name % ",".join(args)
877 
878     def _print_UndefinedFunction(self, expr):
879         return self._hprint_Function(str(expr))
880 
881     def _print_ElementwiseApplyFunction(self, expr):
882         return r"{%s}_{\circ}\left({%s}\right)" % (
883             self._print(expr.function),
884             self._print(expr.expr),
885         )
886 
887     @property
888     def _special_function_classes(self):
889         from sympy.functions.special.tensor_functions import KroneckerDelta
890         from sympy.functions.special.gamma_functions import gamma, lowergamma
891         from sympy.functions.special.beta_functions import beta
892         from sympy.functions.special.delta_functions import DiracDelta
893         from sympy.functions.special.error_functions import Chi
894         return {KroneckerDelta: r'\delta',
895                 gamma:  r'\Gamma',
896                 lowergamma: r'\gamma',
897                 beta: r'\operatorname{B}',
898                 DiracDelta: r'\delta',
899                 Chi: r'\operatorname{Chi}'}
900 
901     def _print_FunctionClass(self, expr):
902         for cls in self._special_function_classes:
903             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
904                 return self._special_function_classes[cls]
905         return self._hprint_Function(str(expr))
906 
907     def _print_Lambda(self, expr):
908         symbols, expr = expr.args
909 
910         if len(symbols) == 1:
911             symbols = self._print(symbols[0])
912         else:
913             symbols = self._print(tuple(symbols))
914 
915         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
916 
917         return tex
918 
919     def _hprint_variadic_function(self, expr, exp=None):
920         args = sorted(expr.args, key=default_sort_key)
921         texargs = [r"%s" % self._print(symbol) for symbol in args]
922         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()),
923                                        ", ".join(texargs))
924         if exp is not None:
925             return r"%s^{%s}" % (tex, exp)
926         else:
927             return tex
928 
929     _print_Min = _print_Max = _hprint_variadic_function
930 
931     def _print_floor(self, expr, exp=None):
932         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
933 
934         if exp is not None:
935             return r"%s^{%s}" % (tex, exp)
936         else:
937             return tex
938 
939     def _print_ceiling(self, expr, exp=None):
940         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
941 
942         if exp is not None:
943             return r"%s^{%s}" % (tex, exp)
944         else:
945             return tex
946 
947     def _print_log(self, expr, exp=None):
948         if not self._settings["ln_notation"]:
949             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
950         else:
951             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
952 
953         if exp is not None:
954             return r"%s^{%s}" % (tex, exp)
955         else:
956             return tex
957 
958     def _print_Abs(self, expr, exp=None):
959         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
960 
961         if exp is not None:
962             return r"%s^{%s}" % (tex, exp)
963         else:
964             return tex
965     _print_Determinant = _print_Abs
966 
967     def _print_re(self, expr, exp=None):
968         if self._settings['gothic_re_im']:
969             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
970         else:
971             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
972 
973         return self._do_exponent(tex, exp)
974 
975     def _print_im(self, expr, exp=None):
976         if self._settings['gothic_re_im']:
977             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
978         else:
979             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
980 
981         return self._do_exponent(tex, exp)
982 
983     def _print_Not(self, e):
984         from sympy import Equivalent, Implies
985         if isinstance(e.args[0], Equivalent):
986             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
987         if isinstance(e.args[0], Implies):
988             return self._print_Implies(e.args[0], r"\not\Rightarrow")
989         if (e.args[0].is_Boolean):
990             return r"\neg \left(%s\right)" % self._print(e.args[0])
991         else:
992             return r"\neg %s" % self._print(e.args[0])
993 
994     def _print_LogOp(self, args, char):
995         arg = args[0]
996         if arg.is_Boolean and not arg.is_Not:
997             tex = r"\left(%s\right)" % self._print(arg)
998         else:
999             tex = r"%s" % self._print(arg)
1000 
1001         for arg in args[1:]:
1002             if arg.is_Boolean and not arg.is_Not:
1003                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1004             else:
1005                 tex += r" %s %s" % (char, self._print(arg))
1006 
1007         return tex
1008 
1009     def _print_And(self, e):
1010         args = sorted(e.args, key=default_sort_key)
1011         return self._print_LogOp(args, r"\wedge")
1012 
1013     def _print_Or(self, e):
1014         args = sorted(e.args, key=default_sort_key)
1015         return self._print_LogOp(args, r"\vee")
1016 
1017     def _print_Xor(self, e):
1018         args = sorted(e.args, key=default_sort_key)
1019         return self._print_LogOp(args, r"\veebar")
1020 
1021     def _print_Implies(self, e, altchar=None):
1022         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1023 
1024     def _print_Equivalent(self, e, altchar=None):
1025         args = sorted(e.args, key=default_sort_key)
1026         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1027 
1028     def _print_conjugate(self, expr, exp=None):
1029         tex = r"\overline{%s}" % self._print(expr.args[0])
1030 
1031         if exp is not None:
1032             return r"%s^{%s}" % (tex, exp)
1033         else:
1034             return tex
1035 
1036     def _print_polar_lift(self, expr, exp=None):
1037         func = r"\operatorname{polar\_lift}"
1038         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1039 
1040         if exp is not None:
1041             return r"%s^{%s}%s" % (func, exp, arg)
1042         else:
1043             return r"%s%s" % (func, arg)
1044 
1045     def _print_ExpBase(self, expr, exp=None):
1046         # TODO should exp_polar be printed differently?
1047         #      what about exp_polar(0), exp_polar(1)?
1048         tex = r"e^{%s}" % self._print(expr.args[0])
1049         return self._do_exponent(tex, exp)
1050 
1051     def _print_elliptic_k(self, expr, exp=None):
1052         tex = r"\left(%s\right)" % self._print(expr.args[0])
1053         if exp is not None:
1054             return r"K^{%s}%s" % (exp, tex)
1055         else:
1056             return r"K%s" % tex
1057 
1058     def _print_elliptic_f(self, expr, exp=None):
1059         tex = r"\left(%s\middle| %s\right)" % \
1060             (self._print(expr.args[0]), self._print(expr.args[1]))
1061         if exp is not None:
1062             return r"F^{%s}%s" % (exp, tex)
1063         else:
1064             return r"F%s" % tex
1065 
1066     def _print_elliptic_e(self, expr, exp=None):
1067         if len(expr.args) == 2:
1068             tex = r"\left(%s\middle| %s\right)" % \
1069                 (self._print(expr.args[0]), self._print(expr.args[1]))
1070         else:
1071             tex = r"\left(%s\right)" % self._print(expr.args[0])
1072         if exp is not None:
1073             return r"E^{%s}%s" % (exp, tex)
1074         else:
1075             return r"E%s" % tex
1076 
1077     def _print_elliptic_pi(self, expr, exp=None):
1078         if len(expr.args) == 3:
1079             tex = r"\left(%s; %s\middle| %s\right)" % \
1080                 (self._print(expr.args[0]), self._print(expr.args[1]),
1081                  self._print(expr.args[2]))
1082         else:
1083             tex = r"\left(%s\middle| %s\right)" % \
1084                 (self._print(expr.args[0]), self._print(expr.args[1]))
1085         if exp is not None:
1086             return r"\Pi^{%s}%s" % (exp, tex)
1087         else:
1088             return r"\Pi%s" % tex
1089 
1090     def _print_beta(self, expr, exp=None):
1091         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1092                                         self._print(expr.args[1]))
1093 
1094         if exp is not None:
1095             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1096         else:
1097             return r"\operatorname{B}%s" % tex
1098 
1099     def _print_uppergamma(self, expr, exp=None):
1100         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1101                                         self._print(expr.args[1]))
1102 
1103         if exp is not None:
1104             return r"\Gamma^{%s}%s" % (exp, tex)
1105         else:
1106             return r"\Gamma%s" % tex
1107 
1108     def _print_lowergamma(self, expr, exp=None):
1109         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1110                                         self._print(expr.args[1]))
1111 
1112         if exp is not None:
1113             return r"\gamma^{%s}%s" % (exp, tex)
1114         else:
1115             return r"\gamma%s" % tex
1116 
1117     def _hprint_one_arg_func(self, expr, exp=None):
1118         tex = r"\left(%s\right)" % self._print(expr.args[0])
1119 
1120         if exp is not None:
1121             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1122         else:
1123             return r"%s%s" % (self._print(expr.func), tex)
1124 
1125     _print_gamma = _hprint_one_arg_func
1126 
1127     def _print_Chi(self, expr, exp=None):
1128         tex = r"\left(%s\right)" % self._print(expr.args[0])
1129 
1130         if exp is not None:
1131             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1132         else:
1133             return r"\operatorname{Chi}%s" % tex
1134 
1135     def _print_expint(self, expr, exp=None):
1136         tex = r"\left(%s\right)" % self._print(expr.args[1])
1137         nu = self._print(expr.args[0])
1138 
1139         if exp is not None:
1140             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1141         else:
1142             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1143 
1144     def _print_fresnels(self, expr, exp=None):
1145         tex = r"\left(%s\right)" % self._print(expr.args[0])
1146 
1147         if exp is not None:
1148             return r"S^{%s}%s" % (exp, tex)
1149         else:
1150             return r"S%s" % tex
1151 
1152     def _print_fresnelc(self, expr, exp=None):
1153         tex = r"\left(%s\right)" % self._print(expr.args[0])
1154 
1155         if exp is not None:
1156             return r"C^{%s}%s" % (exp, tex)
1157         else:
1158             return r"C%s" % tex
1159 
1160     def _print_subfactorial(self, expr, exp=None):
1161         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1162 
1163         if exp is not None:
1164             return r"\left(%s\right)^{%s}" % (tex, exp)
1165         else:
1166             return tex
1167 
1168     def _print_factorial(self, expr, exp=None):
1169         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1170 
1171         if exp is not None:
1172             return r"%s^{%s}" % (tex, exp)
1173         else:
1174             return tex
1175 
1176     def _print_factorial2(self, expr, exp=None):
1177         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1178 
1179         if exp is not None:
1180             return r"%s^{%s}" % (tex, exp)
1181         else:
1182             return tex
1183 
1184     def _print_binomial(self, expr, exp=None):
1185         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1186                                      self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"%s^{%s}" % (tex, exp)
1190         else:
1191             return tex
1192 
1193     def _print_RisingFactorial(self, expr, exp=None):
1194         n, k = expr.args
1195         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1196 
1197         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1198 
1199         return self._do_exponent(tex, exp)
1200 
1201     def _print_FallingFactorial(self, expr, exp=None):
1202         n, k = expr.args
1203         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1204 
1205         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1206 
1207         return self._do_exponent(tex, exp)
1208 
1209     def _hprint_BesselBase(self, expr, exp, sym):
1210         tex = r"%s" % (sym)
1211 
1212         need_exp = False
1213         if exp is not None:
1214             if tex.find('^') == -1:
1215                 tex = r"%s^{%s}" % (tex, self._print(exp))
1216             else:
1217                 need_exp = True
1218 
1219         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1220                                            self._print(expr.argument))
1221 
1222         if need_exp:
1223             tex = self._do_exponent(tex, exp)
1224         return tex
1225 
1226     def _hprint_vec(self, vec):
1227         if not vec:
1228             return ""
1229         s = ""
1230         for i in vec[:-1]:
1231             s += "%s, " % self._print(i)
1232         s += self._print(vec[-1])
1233         return s
1234 
1235     def _print_besselj(self, expr, exp=None):
1236         return self._hprint_BesselBase(expr, exp, 'J')
1237 
1238     def _print_besseli(self, expr, exp=None):
1239         return self._hprint_BesselBase(expr, exp, 'I')
1240 
1241     def _print_besselk(self, expr, exp=None):
1242         return self._hprint_BesselBase(expr, exp, 'K')
1243 
1244     def _print_bessely(self, expr, exp=None):
1245         return self._hprint_BesselBase(expr, exp, 'Y')
1246 
1247     def _print_yn(self, expr, exp=None):
1248         return self._hprint_BesselBase(expr, exp, 'y')
1249 
1250     def _print_jn(self, expr, exp=None):
1251         return self._hprint_BesselBase(expr, exp, 'j')
1252 
1253     def _print_hankel1(self, expr, exp=None):
1254         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1255 
1256     def _print_hankel2(self, expr, exp=None):
1257         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1258 
1259     def _print_hn1(self, expr, exp=None):
1260         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1261 
1262     def _print_hn2(self, expr, exp=None):
1263         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1264 
1265     def _hprint_airy(self, expr, exp=None, notation=""):
1266         tex = r"\left(%s\right)" % self._print(expr.args[0])
1267 
1268         if exp is not None:
1269             return r"%s^{%s}%s" % (notation, exp, tex)
1270         else:
1271             return r"%s%s" % (notation, tex)
1272 
1273     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1274         tex = r"\left(%s\right)" % self._print(expr.args[0])
1275 
1276         if exp is not None:
1277             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1278         else:
1279             return r"%s^\prime%s" % (notation, tex)
1280 
1281     def _print_airyai(self, expr, exp=None):
1282         return self._hprint_airy(expr, exp, 'Ai')
1283 
1284     def _print_airybi(self, expr, exp=None):
1285         return self._hprint_airy(expr, exp, 'Bi')
1286 
1287     def _print_airyaiprime(self, expr, exp=None):
1288         return self._hprint_airy_prime(expr, exp, 'Ai')
1289 
1290     def _print_airybiprime(self, expr, exp=None):
1291         return self._hprint_airy_prime(expr, exp, 'Bi')
1292 
1293     def _print_hyper(self, expr, exp=None):
1294         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1295               r"\middle| {%s} \right)}" % \
1296             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1297               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1298               self._print(expr.argument))
1299 
1300         if exp is not None:
1301             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1302         return tex
1303 
1304     def _print_meijerg(self, expr, exp=None):
1305         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1306               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1307             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1308               self._print(len(expr.bm)), self._print(len(expr.an)),
1309               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1310               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1311               self._print(expr.argument))
1312 
1313         if exp is not None:
1314             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1315         return tex
1316 
1317     def _print_dirichlet_eta(self, expr, exp=None):
1318         tex = r"\left(%s\right)" % self._print(expr.args[0])
1319         if exp is not None:
1320             return r"\eta^{%s}%s" % (self._print(exp), tex)
1321         return r"\eta%s" % tex
1322 
1323     def _print_zeta(self, expr, exp=None):
1324         if len(expr.args) == 2:
1325             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1326         else:
1327             tex = r"\left(%s\right)" % self._print(expr.args[0])
1328         if exp is not None:
1329             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1330         return r"\zeta%s" % tex
1331 
1332     def _print_stieltjes(self, expr, exp=None):
1333         if len(expr.args) == 2:
1334             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1335         else:
1336             tex = r"_{%s}" % self._print(expr.args[0])
1337         if exp is not None:
1338             return r"\gamma%s^{%s}" % (tex, self._print(exp))
1339         return r"\gamma%s" % tex
1340 
1341     def _print_lerchphi(self, expr, exp=None):
1342         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1343         if exp is None:
1344             return r"\Phi%s" % tex
1345         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1346 
1347     def _print_polylog(self, expr, exp=None):
1348         s, z = map(self._print, expr.args)
1349         tex = r"\left(%s\right)" % z
1350         if exp is None:
1351             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1352         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1353 
1354     def _print_jacobi(self, expr, exp=None):
1355         n, a, b, x = map(self._print, expr.args)
1356         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1357         if exp is not None:
1358             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1359         return tex
1360 
1361     def _print_gegenbauer(self, expr, exp=None):
1362         n, a, x = map(self._print, expr.args)
1363         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1364         if exp is not None:
1365             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1366         return tex
1367 
1368     def _print_chebyshevt(self, expr, exp=None):
1369         n, x = map(self._print, expr.args)
1370         tex = r"T_{%s}\left(%s\right)" % (n, x)
1371         if exp is not None:
1372             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1373         return tex
1374 
1375     def _print_chebyshevu(self, expr, exp=None):
1376         n, x = map(self._print, expr.args)
1377         tex = r"U_{%s}\left(%s\right)" % (n, x)
1378         if exp is not None:
1379             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1380         return tex
1381 
1382     def _print_legendre(self, expr, exp=None):
1383         n, x = map(self._print, expr.args)
1384         tex = r"P_{%s}\left(%s\right)" % (n, x)
1385         if exp is not None:
1386             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1387         return tex
1388 
1389     def _print_assoc_legendre(self, expr, exp=None):
1390         n, a, x = map(self._print, expr.args)
1391         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1392         if exp is not None:
1393             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1394         return tex
1395 
1396     def _print_hermite(self, expr, exp=None):
1397         n, x = map(self._print, expr.args)
1398         tex = r"H_{%s}\left(%s\right)" % (n, x)
1399         if exp is not None:
1400             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1401         return tex
1402 
1403     def _print_laguerre(self, expr, exp=None):
1404         n, x = map(self._print, expr.args)
1405         tex = r"L_{%s}\left(%s\right)" % (n, x)
1406         if exp is not None:
1407             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1408         return tex
1409 
1410     def _print_assoc_laguerre(self, expr, exp=None):
1411         n, a, x = map(self._print, expr.args)
1412         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1413         if exp is not None:
1414             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1415         return tex
1416 
1417     def _print_Ynm(self, expr, exp=None):
1418         n, m, theta, phi = map(self._print, expr.args)
1419         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1420         if exp is not None:
1421             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1422         return tex
1423 
1424     def _print_Znm(self, expr, exp=None):
1425         n, m, theta, phi = map(self._print, expr.args)
1426         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1427         if exp is not None:
1428             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1429         return tex
1430 
1431     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1432         a, q, z = map(self._print, args)
1433         sup = r"^{\prime}" if prime else ""
1434         exp = "" if not exp else "^{%s}" % self._print(exp)
1435         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1436 
1437     def _print_mathieuc(self, expr, exp=None):
1438         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1439 
1440     def _print_mathieus(self, expr, exp=None):
1441         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1442 
1443     def _print_mathieucprime(self, expr, exp=None):
1444         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1445 
1446     def _print_mathieusprime(self, expr, exp=None):
1447         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1448 
1449     def _print_Rational(self, expr):
1450         if expr.q != 1:
1451             sign = ""
1452             p = expr.p
1453             if expr.p < 0:
1454                 sign = "- "
1455                 p = -p
1456             if self._settings['fold_short_frac']:
1457                 return r"%s%d / %d" % (sign, p, expr.q)
1458             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1459         else:
1460             return self._print(expr.p)
1461 
1462     def _print_Order(self, expr):
1463         s = self._print(expr.expr)
1464         if expr.point and any(p != S.Zero for p in expr.point) or \
1465            len(expr.variables) > 1:
1466             s += '; '
1467             if len(expr.variables) > 1:
1468                 s += self._print(expr.variables)
1469             elif expr.variables:
1470                 s += self._print(expr.variables[0])
1471             s += r'\rightarrow '
1472             if len(expr.point) > 1:
1473                 s += self._print(expr.point)
1474             else:
1475                 s += self._print(expr.point[0])
1476         return r"O\left(%s\right)" % s
1477 
1478     def _print_Symbol(self, expr, style='plain'):
1479         if expr in self._settings['symbol_names']:
1480             return self._settings['symbol_names'][expr]
1481 
1482         result = self._deal_with_super_sub(expr.name) if \
1483             '\\' not in expr.name else expr.name
1484 
1485         if style == 'bold':
1486             result = r"\mathbf{{{}}}".format(result)
1487 
1488         return result
1489 
1490     _print_RandomSymbol = _print_Symbol
1491 
1492     def _deal_with_super_sub(self, string):
1493         if '{' in string:
1494             return string
1495 
1496         name, supers, subs = split_super_sub(string)
1497 
1498         name = translate(name)
1499         supers = [translate(sup) for sup in supers]
1500         subs = [translate(sub) for sub in subs]
1501 
1502         # glue all items together:
1503         if supers:
1504             name += "^{%s}" % " ".join(supers)
1505         if subs:
1506             name += "_{%s}" % " ".join(subs)
1507 
1508         return name
1509 
1510     def _print_Relational(self, expr):
1511         if self._settings['itex']:
1512             gt = r"\gt"
1513             lt = r"\lt"
1514         else:
1515             gt = ">"
1516             lt = "<"
1517 
1518         charmap = {
1519             "==": "=",
1520             ">": gt,
1521             "<": lt,
1522             ">=": r"\geq",
1523             "<=": r"\leq",
1524             "!=": r"\neq",
1525         }
1526 
1527         return "%s %s %s" % (self._print(expr.lhs),
1528                              charmap[expr.rel_op], self._print(expr.rhs))
1529 
1530     def _print_Piecewise(self, expr):
1531         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1532                    for e, c in expr.args[:-1]]
1533         if expr.args[-1].cond == true:
1534             ecpairs.append(r"%s & \text{otherwise}" %
1535                            self._print(expr.args[-1].expr))
1536         else:
1537             ecpairs.append(r"%s & \text{for}\: %s" %
1538                            (self._print(expr.args[-1].expr),
1539                             self._print(expr.args[-1].cond)))
1540         tex = r"\begin{cases} %s \end{cases}"
1541         return tex % r" \\".join(ecpairs)
1542 
1543     def _print_MatrixBase(self, expr):
1544         lines = []
1545 
1546         for line in range(expr.rows):  # horrible, should be 'rows'
1547             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1548 
1549         mat_str = self._settings['mat_str']
1550         if mat_str is None:
1551             if self._settings['mode'] == 'inline':
1552                 mat_str = 'smallmatrix'
1553             else:
1554                 if (expr.cols <= 10) is True:
1555                     mat_str = 'matrix'
1556                 else:
1557                     mat_str = 'array'
1558 
1559         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1560         out_str = out_str.replace('%MATSTR%', mat_str)
1561         if mat_str == 'array':
1562             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1563         if self._settings['mat_delim']:
1564             left_delim = self._settings['mat_delim']
1565             right_delim = self._delim_dict[left_delim]
1566             out_str = r'\left' + left_delim + out_str + \
1567                       r'\right' + right_delim
1568         return out_str % r"\\".join(lines)
1569     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1570                            = _print_Matrix \
1571                            = _print_MatrixBase
1572 
1573     def _print_MatrixElement(self, expr):
1574         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1575             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1576 
1577     def _print_MatrixSlice(self, expr):
1578         def latexslice(x):
1579             x = list(x)
1580             if x[2] == 1:
1581                 del x[2]
1582             if x[1] == x[0] + 1:
1583                 del x[1]
1584             if x[0] == 0:
1585                 x[0] = ''
1586             return ':'.join(map(self._print, x))
1587         return (self._print(expr.parent) + r'\left[' +
1588                 latexslice(expr.rowslice) + ', ' +
1589                 latexslice(expr.colslice) + r'\right]')
1590 
1591     def _print_BlockMatrix(self, expr):
1592         return self._print(expr.blocks)
1593 
1594     def _print_Transpose(self, expr):
1595         mat = expr.arg
1596         from sympy.matrices import MatrixSymbol
1597         if not isinstance(mat, MatrixSymbol):
1598             return r"\left(%s\right)^{T}" % self._print(mat)
1599         else:
1600             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1601 
1602     def _print_Trace(self, expr):
1603         mat = expr.arg
1604         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1605 
1606     def _print_Adjoint(self, expr):
1607         mat = expr.arg
1608         from sympy.matrices import MatrixSymbol
1609         if not isinstance(mat, MatrixSymbol):
1610             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1611         else:
1612             return r"%s^{\dagger}" % self._print(mat)
1613 
1614     def _print_MatMul(self, expr):
1615         from sympy import MatMul, Mul
1616 
1617         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1618                                              False)
1619 
1620         args = expr.args
1621         if isinstance(args[0], Mul):
1622             args = args[0].as_ordered_factors() + list(args[1:])
1623         else:
1624             args = list(args)
1625 
1626         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1627             if args[0] == -1:
1628                 args = args[1:]
1629             else:
1630                 args[0] = -args[0]
1631             return '- ' + ' '.join(map(parens, args))
1632         else:
1633             return ' '.join(map(parens, args))
1634 
1635     def _print_Mod(self, expr, exp=None):
1636         if exp is not None:
1637             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1638                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1639                                    strict=True), self._print(expr.args[1]),
1640                  self._print(exp))
1641         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1642                                  PRECEDENCE['Mul'], strict=True),
1643                                  self._print(expr.args[1]))
1644 
1645     def _print_HadamardProduct(self, expr):
1646         args = expr.args
1647         prec = PRECEDENCE['Pow']
1648         parens = self.parenthesize
1649 
1650         return r' \circ '.join(
1651             map(lambda arg: parens(arg, prec, strict=True), args))
1652 
1653     def _print_HadamardPower(self, expr):
1654         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1655             template = r"%s^{\circ \left({%s}\right)}"
1656         else:
1657             template = r"%s^{\circ {%s}}"
1658         return self._helper_print_standard_power(expr, template)
1659 
1660     def _print_KroneckerProduct(self, expr):
1661         args = expr.args
1662         prec = PRECEDENCE['Pow']
1663         parens = self.parenthesize
1664 
1665         return r' \otimes '.join(
1666             map(lambda arg: parens(arg, prec, strict=True), args))
1667 
1668     def _print_MatPow(self, expr):
1669         base, exp = expr.base, expr.exp
1670         from sympy.matrices import MatrixSymbol
1671         if not isinstance(base, MatrixSymbol):
1672             return "\\left(%s\\right)^{%s}" % (self._print(base),
1673                                               self._print(exp))
1674         else:
1675             return "%s^{%s}" % (self._print(base), self._print(exp))
1676 
1677     def _print_MatrixSymbol(self, expr):
1678         return self._print_Symbol(expr, style=self._settings[
1679             'mat_symbol_style'])
1680 
1681     def _print_ZeroMatrix(self, Z):
1682         return r"\mathbb{0}" if self._settings[
1683             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1684 
1685     def _print_OneMatrix(self, O):
1686         return r"\mathbb{1}" if self._settings[
1687             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1688 
1689     def _print_Identity(self, I):
1690         return r"\mathbb{I}" if self._settings[
1691             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1692 
1693     def _print_PermutationMatrix(self, P):
1694         perm_str = self._print(P.args[0])
1695         return "P_{%s}" % perm_str
1696 
1697     def _print_NDimArray(self, expr):
1698 
1699         if expr.rank() == 0:
1700             return self._print(expr[()])
1701 
1702         mat_str = self._settings['mat_str']
1703         if mat_str is None:
1704             if self._settings['mode'] == 'inline':
1705                 mat_str = 'smallmatrix'
1706             else:
1707                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1708                     mat_str = 'matrix'
1709                 else:
1710                     mat_str = 'array'
1711         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1712         block_str = block_str.replace('%MATSTR%', mat_str)
1713         if self._settings['mat_delim']:
1714             left_delim = self._settings['mat_delim']
1715             right_delim = self._delim_dict[left_delim]
1716             block_str = r'\left' + left_delim + block_str + \
1717                         r'\right' + right_delim
1718 
1719         if expr.rank() == 0:
1720             return block_str % ""
1721 
1722         level_str = [[]] + [[] for i in range(expr.rank())]
1723         shape_ranges = [list(range(i)) for i in expr.shape]
1724         for outer_i in itertools.product(*shape_ranges):
1725             level_str[-1].append(self._print(expr[outer_i]))
1726             even = True
1727             for back_outer_i in range(expr.rank()-1, -1, -1):
1728                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1729                     break
1730                 if even:
1731                     level_str[back_outer_i].append(
1732                         r" & ".join(level_str[back_outer_i+1]))
1733                 else:
1734                     level_str[back_outer_i].append(
1735                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1736                     if len(level_str[back_outer_i+1]) == 1:
1737                         level_str[back_outer_i][-1] = r"\left[" + \
1738                             level_str[back_outer_i][-1] + r"\right]"
1739                 even = not even
1740                 level_str[back_outer_i+1] = []
1741 
1742         out_str = level_str[0][0]
1743 
1744         if expr.rank() % 2 == 1:
1745             out_str = block_str % out_str
1746 
1747         return out_str
1748 
1749     _print_ImmutableDenseNDimArray = _print_NDimArray
1750     _print_ImmutableSparseNDimArray = _print_NDimArray
1751     _print_MutableDenseNDimArray = _print_NDimArray
1752     _print_MutableSparseNDimArray = _print_NDimArray
1753 
1754     def _printer_tensor_indices(self, name, indices, index_map={}):
1755         out_str = self._print(name)
1756         last_valence = None
1757         prev_map = None
1758         for index in indices:
1759             new_valence = index.is_up
1760             if ((index in index_map) or prev_map) and \
1761                     last_valence == new_valence:
1762                 out_str += ","
1763             if last_valence != new_valence:
1764                 if last_valence is not None:
1765                     out_str += "}"
1766                 if index.is_up:
1767                     out_str += "{}^{"
1768                 else:
1769                     out_str += "{}_{"
1770             out_str += self._print(index.args[0])
1771             if index in index_map:
1772                 out_str += "="
1773                 out_str += self._print(index_map[index])
1774                 prev_map = True
1775             else:
1776                 prev_map = False
1777             last_valence = new_valence
1778         if last_valence is not None:
1779             out_str += "}"
1780         return out_str
1781 
1782     def _print_Tensor(self, expr):
1783         name = expr.args[0].args[0]
1784         indices = expr.get_indices()
1785         return self._printer_tensor_indices(name, indices)
1786 
1787     def _print_TensorElement(self, expr):
1788         name = expr.expr.args[0].args[0]
1789         indices = expr.expr.get_indices()
1790         index_map = expr.index_map
1791         return self._printer_tensor_indices(name, indices, index_map)
1792 
1793     def _print_TensMul(self, expr):
1794         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1795         sign, args = expr._get_args_for_traditional_printer()
1796         return sign + "".join(
1797             [self.parenthesize(arg, precedence(expr)) for arg in args]
1798         )
1799 
1800     def _print_TensAdd(self, expr):
1801         a = []
1802         args = expr.args
1803         for x in args:
1804             a.append(self.parenthesize(x, precedence(expr)))
1805         a.sort()
1806         s = ' + '.join(a)
1807         s = s.replace('+ -', '- ')
1808         return s
1809 
1810     def _print_TensorIndex(self, expr):
1811         return "{}%s{%s}" % (
1812             "^" if expr.is_up else "_",
1813             self._print(expr.args[0])
1814         )
1815 
1816     def _print_PartialDerivative(self, expr):
1817         if len(expr.variables) == 1:
1818             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1819                 self._print(expr.variables[0]),
1820                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1821             )
1822         else:
1823             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1824                 len(expr.variables),
1825                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1826                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1827             )
1828 
1829     def _print_UniversalSet(self, expr):
1830         return r"\mathbb{U}"
1831 
1832     def _print_frac(self, expr, exp=None):
1833         if exp is None:
1834             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1835         else:
1836             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1837                     self._print(expr.args[0]), self._print(exp))
1838 
1839     def _print_tuple(self, expr):
1840         if self._settings['decimal_separator'] =='comma':
1841             return r"\left( %s\right)" % \
1842                 r"; \  ".join([self._print(i) for i in expr])
1843         elif self._settings['decimal_separator'] =='period':
1844             return r"\left( %s\right)" % \
1845                 r", \  ".join([self._print(i) for i in expr])
1846         else:
1847             raise ValueError('Unknown Decimal Separator')
1848 
1849     def _print_TensorProduct(self, expr):
1850         elements = [self._print(a) for a in expr.args]
1851         return r' \otimes '.join(elements)
1852 
1853     def _print_WedgeProduct(self, expr):
1854         elements = [self._print(a) for a in expr.args]
1855         return r' \wedge '.join(elements)
1856 
1857     def _print_Tuple(self, expr):
1858         return self._print_tuple(expr)
1859 
1860     def _print_list(self, expr):
1861         if self._settings['decimal_separator'] == 'comma':
1862             return r"\left[ %s\right]" % \
1863                 r"; \  ".join([self._print(i) for i in expr])
1864         elif self._settings['decimal_separator'] == 'period':
1865             return r"\left[ %s\right]" % \
1866                 r", \  ".join([self._print(i) for i in expr])
1867         else:
1868             raise ValueError('Unknown Decimal Separator')
1869 
1870 
1871     def _print_dict(self, d):
1872         keys = sorted(d.keys(), key=default_sort_key)
1873         items = []
1874 
1875         for key in keys:
1876             val = d[key]
1877             items.append("%s : %s" % (self._print(key), self._print(val)))
1878 
1879         return r"\left\{ %s\right\}" % r", \  ".join(items)
1880 
1881     def _print_Dict(self, expr):
1882         return self._print_dict(expr)
1883 
1884     def _print_DiracDelta(self, expr, exp=None):
1885         if len(expr.args) == 1 or expr.args[1] == 0:
1886             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1887         else:
1888             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1889                 self._print(expr.args[1]), self._print(expr.args[0]))
1890         if exp:
1891             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1892         return tex
1893 
1894     def _print_SingularityFunction(self, expr):
1895         shift = self._print(expr.args[0] - expr.args[1])
1896         power = self._print(expr.args[2])
1897         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1898         return tex
1899 
1900     def _print_Heaviside(self, expr, exp=None):
1901         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1902         if exp:
1903             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1904         return tex
1905 
1906     def _print_KroneckerDelta(self, expr, exp=None):
1907         i = self._print(expr.args[0])
1908         j = self._print(expr.args[1])
1909         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1910             tex = r'\delta_{%s %s}' % (i, j)
1911         else:
1912             tex = r'\delta_{%s, %s}' % (i, j)
1913         if exp is not None:
1914             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1915         return tex
1916 
1917     def _print_LeviCivita(self, expr, exp=None):
1918         indices = map(self._print, expr.args)
1919         if all(x.is_Atom for x in expr.args):
1920             tex = r'\varepsilon_{%s}' % " ".join(indices)
1921         else:
1922             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1923         if exp:
1924             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1925         return tex
1926 
1927     def _print_RandomDomain(self, d):
1928         if hasattr(d, 'as_boolean'):
1929             return '\\text{Domain: }' + self._print(d.as_boolean())
1930         elif hasattr(d, 'set'):
1931             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1932                     self._print(d.set))
1933         elif hasattr(d, 'symbols'):
1934             return '\\text{Domain on }' + self._print(d.symbols)
1935         else:
1936             return self._print(None)
1937 
1938     def _print_FiniteSet(self, s):
1939         items = sorted(s.args, key=default_sort_key)
1940         return self._print_set(items)
1941 
1942     def _print_set(self, s):
1943         items = sorted(s, key=default_sort_key)
1944         if self._settings['decimal_separator'] == 'comma':
1945             items = "; ".join(map(self._print, items))
1946         elif self._settings['decimal_separator'] == 'period':
1947             items = ", ".join(map(self._print, items))
1948         else:
1949             raise ValueError('Unknown Decimal Separator')
1950         return r"\left\{%s\right\}" % items
1951 
1952 
1953     _print_frozenset = _print_set
1954 
1955     def _print_Range(self, s):
1956         dots = r'\ldots'
1957 
1958         if s.has(Symbol):
1959             return self._print_Basic(s)
1960 
1961         if s.start.is_infinite and s.stop.is_infinite:
1962             if s.step.is_positive:
1963                 printset = dots, -1, 0, 1, dots
1964             else:
1965                 printset = dots, 1, 0, -1, dots
1966         elif s.start.is_infinite:
1967             printset = dots, s[-1] - s.step, s[-1]
1968         elif s.stop.is_infinite:
1969             it = iter(s)
1970             printset = next(it), next(it), dots
1971         elif len(s) > 4:
1972             it = iter(s)
1973             printset = next(it), next(it), dots, s[-1]
1974         else:
1975             printset = tuple(s)
1976 
1977         return (r"\left\{" +
1978                 r", ".join(self._print(el) for el in printset) +
1979                 r"\right\}")
1980 
1981     def __print_number_polynomial(self, expr, letter, exp=None):
1982         if len(expr.args) == 2:
1983             if exp is not None:
1984                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
1985                             self._print(expr.args[0]), self._print(exp),
1986                             self._print(expr.args[1]))
1987             return r"%s_{%s}\left(%s\right)" % (letter,
1988                         self._print(expr.args[0]), self._print(expr.args[1]))
1989 
1990         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
1991         if exp is not None:
1992             tex = r"%s^{%s}" % (tex, self._print(exp))
1993         return tex
1994 
1995     def _print_bernoulli(self, expr, exp=None):
1996         return self.__print_number_polynomial(expr, "B", exp)
1997 
1998     def _print_bell(self, expr, exp=None):
1999         if len(expr.args) == 3:
2000             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2001                                 self._print(expr.args[1]))
2002             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2003                                                el in expr.args[2])
2004             if exp is not None:
2005                 tex = r"%s^{%s}%s" % (tex1, self._print(exp), tex2)
2006             else:
2007                 tex = tex1 + tex2
2008             return tex
2009         return self.__print_number_polynomial(expr, "B", exp)
2010 
2011 
2012     def _print_fibonacci(self, expr, exp=None):
2013         return self.__print_number_polynomial(expr, "F", exp)
2014 
2015     def _print_lucas(self, expr, exp=None):
2016         tex = r"L_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_tribonacci(self, expr, exp=None):
2022         return self.__print_number_polynomial(expr, "T", exp)
2023 
2024     def _print_SeqFormula(self, s):
2025         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2026             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2027                 self._print(s.formula),
2028                 self._print(s.variables[0]),
2029                 self._print(s.start),
2030                 self._print(s.stop)
2031             )
2032         if s.start is S.NegativeInfinity:
2033             stop = s.stop
2034             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
2035                         s.coeff(stop - 1), s.coeff(stop))
2036         elif s.stop is S.Infinity or s.length > 4:
2037             printset = s[:4]
2038             printset.append(r'\ldots')
2039         else:
2040             printset = tuple(s)
2041 
2042         return (r"\left[" +
2043                 r", ".join(self._print(el) for el in printset) +
2044                 r"\right]")
2045 
2046     _print_SeqPer = _print_SeqFormula
2047     _print_SeqAdd = _print_SeqFormula
2048     _print_SeqMul = _print_SeqFormula
2049 
2050     def _print_Interval(self, i):
2051         if i.start == i.end:
2052             return r"\left\{%s\right\}" % self._print(i.start)
2053 
2054         else:
2055             if i.left_open:
2056                 left = '('
2057             else:
2058                 left = '['
2059 
2060             if i.right_open:
2061                 right = ')'
2062             else:
2063                 right = ']'
2064 
2065             return r"\left%s%s, %s\right%s" % \
2066                    (left, self._print(i.start), self._print(i.end), right)
2067 
2068     def _print_AccumulationBounds(self, i):
2069         return r"\left\langle %s, %s\right\rangle" % \
2070                 (self._print(i.min), self._print(i.max))
2071 
2072     def _print_Union(self, u):
2073         prec = precedence_traditional(u)
2074         args_str = [self.parenthesize(i, prec) for i in u.args]
2075         return r" \cup ".join(args_str)
2076 
2077     def _print_Complement(self, u):
2078         prec = precedence_traditional(u)
2079         args_str = [self.parenthesize(i, prec) for i in u.args]
2080         return r" \setminus ".join(args_str)
2081 
2082     def _print_Intersection(self, u):
2083         prec = precedence_traditional(u)
2084         args_str = [self.parenthesize(i, prec) for i in u.args]
2085         return r" \cap ".join(args_str)
2086 
2087     def _print_SymmetricDifference(self, u):
2088         prec = precedence_traditional(u)
2089         args_str = [self.parenthesize(i, prec) for i in u.args]
2090         return r" \triangle ".join(args_str)
2091 
2092     def _print_ProductSet(self, p):
2093         prec = precedence_traditional(p)
2094         if len(p.sets) >= 1 and not has_variety(p.sets):
2095             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2096         return r" \times ".join(
2097             self.parenthesize(set, prec) for set in p.sets)
2098 
2099     def _print_EmptySet(self, e):
2100         return r"\emptyset"
2101 
2102     def _print_Naturals(self, n):
2103         return r"\mathbb{N}"
2104 
2105     def _print_Naturals0(self, n):
2106         return r"\mathbb{N}_0"
2107 
2108     def _print_Integers(self, i):
2109         return r"\mathbb{Z}"
2110 
2111     def _print_Rationals(self, i):
2112         return r"\mathbb{Q}"
2113 
2114     def _print_Reals(self, i):
2115         return r"\mathbb{R}"
2116 
2117     def _print_Complexes(self, i):
2118         return r"\mathbb{C}"
2119 
2120     def _print_ImageSet(self, s):
2121         expr = s.lamda.expr
2122         sig = s.lamda.signature
2123         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2124         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2125         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2126 
2127     def _print_ConditionSet(self, s):
2128         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2129         if s.base_set is S.UniversalSet:
2130             return r"\left\{%s \mid %s \right\}" % \
2131                 (vars_print, self._print(s.condition))
2132 
2133         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2134             vars_print,
2135             vars_print,
2136             self._print(s.base_set),
2137             self._print(s.condition))
2138 
2139     def _print_ComplexRegion(self, s):
2140         vars_print = ', '.join([self._print(var) for var in s.variables])
2141         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2142             self._print(s.expr),
2143             vars_print,
2144             self._print(s.sets))
2145 
2146     def _print_Contains(self, e):
2147         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2148 
2149     def _print_FourierSeries(self, s):
2150         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
2151 
2152     def _print_FormalPowerSeries(self, s):
2153         return self._print_Add(s.infinite)
2154 
2155     def _print_FiniteField(self, expr):
2156         return r"\mathbb{F}_{%s}" % expr.mod
2157 
2158     def _print_IntegerRing(self, expr):
2159         return r"\mathbb{Z}"
2160 
2161     def _print_RationalField(self, expr):
2162         return r"\mathbb{Q}"
2163 
2164     def _print_RealField(self, expr):
2165         return r"\mathbb{R}"
2166 
2167     def _print_ComplexField(self, expr):
2168         return r"\mathbb{C}"
2169 
2170     def _print_PolynomialRing(self, expr):
2171         domain = self._print(expr.domain)
2172         symbols = ", ".join(map(self._print, expr.symbols))
2173         return r"%s\left[%s\right]" % (domain, symbols)
2174 
2175     def _print_FractionField(self, expr):
2176         domain = self._print(expr.domain)
2177         symbols = ", ".join(map(self._print, expr.symbols))
2178         return r"%s\left(%s\right)" % (domain, symbols)
2179 
2180     def _print_PolynomialRingBase(self, expr):
2181         domain = self._print(expr.domain)
2182         symbols = ", ".join(map(self._print, expr.symbols))
2183         inv = ""
2184         if not expr.is_Poly:
2185             inv = r"S_<^{-1}"
2186         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2187 
2188     def _print_Poly(self, poly):
2189         cls = poly.__class__.__name__
2190         terms = []
2191         for monom, coeff in poly.terms():
2192             s_monom = ''
2193             for i, exp in enumerate(monom):
2194                 if exp > 0:
2195                     if exp == 1:
2196                         s_monom += self._print(poly.gens[i])
2197                     else:
2198                         s_monom += self._print(pow(poly.gens[i], exp))
2199 
2200             if coeff.is_Add:
2201                 if s_monom:
2202                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2203                 else:
2204                     s_coeff = self._print(coeff)
2205             else:
2206                 if s_monom:
2207                     if coeff is S.One:
2208                         terms.extend(['+', s_monom])
2209                         continue
2210 
2211                     if coeff is S.NegativeOne:
2212                         terms.extend(['-', s_monom])
2213                         continue
2214 
2215                 s_coeff = self._print(coeff)
2216 
2217             if not s_monom:
2218                 s_term = s_coeff
2219             else:
2220                 s_term = s_coeff + " " + s_monom
2221 
2222             if s_term.startswith('-'):
2223                 terms.extend(['-', s_term[1:]])
2224             else:
2225                 terms.extend(['+', s_term])
2226 
2227         if terms[0] in ['-', '+']:
2228             modifier = terms.pop(0)
2229 
2230             if modifier == '-':
2231                 terms[0] = '-' + terms[0]
2232 
2233         expr = ' '.join(terms)
2234         gens = list(map(self._print, poly.gens))
2235         domain = "domain=%s" % self._print(poly.get_domain())
2236 
2237         args = ", ".join([expr] + gens + [domain])
2238         if cls in accepted_latex_functions:
2239             tex = r"\%s {\left(%s \right)}" % (cls, args)
2240         else:
2241             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2242 
2243         return tex
2244 
2245     def _print_ComplexRootOf(self, root):
2246         cls = root.__class__.__name__
2247         if cls == "ComplexRootOf":
2248             cls = "CRootOf"
2249         expr = self._print(root.expr)
2250         index = root.index
2251         if cls in accepted_latex_functions:
2252             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2253         else:
2254             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2255                                                                  index)
2256 
2257     def _print_RootSum(self, expr):
2258         cls = expr.__class__.__name__
2259         args = [self._print(expr.expr)]
2260 
2261         if expr.fun is not S.IdentityFunction:
2262             args.append(self._print(expr.fun))
2263 
2264         if cls in accepted_latex_functions:
2265             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2266         else:
2267             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2268                                                              ", ".join(args))
2269 
2270     def _print_PolyElement(self, poly):
2271         mul_symbol = self._settings['mul_symbol_latex']
2272         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2273 
2274     def _print_FracElement(self, frac):
2275         if frac.denom == 1:
2276             return self._print(frac.numer)
2277         else:
2278             numer = self._print(frac.numer)
2279             denom = self._print(frac.denom)
2280             return r"\frac{%s}{%s}" % (numer, denom)
2281 
2282     def _print_euler(self, expr, exp=None):
2283         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2284         tex = r"E_{%s}" % self._print(m)
2285         if exp is not None:
2286             tex = r"%s^{%s}" % (tex, self._print(exp))
2287         if x is not None:
2288             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2289         return tex
2290 
2291     def _print_catalan(self, expr, exp=None):
2292         tex = r"C_{%s}" % self._print(expr.args[0])
2293         if exp is not None:
2294             tex = r"%s^{%s}" % (tex, self._print(exp))
2295         return tex
2296 
2297     def _print_UnifiedTransform(self, expr, s, inverse=False):
2298         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2299 
2300     def _print_MellinTransform(self, expr):
2301         return self._print_UnifiedTransform(expr, 'M')
2302 
2303     def _print_InverseMellinTransform(self, expr):
2304         return self._print_UnifiedTransform(expr, 'M', True)
2305 
2306     def _print_LaplaceTransform(self, expr):
2307         return self._print_UnifiedTransform(expr, 'L')
2308 
2309     def _print_InverseLaplaceTransform(self, expr):
2310         return self._print_UnifiedTransform(expr, 'L', True)
2311 
2312     def _print_FourierTransform(self, expr):
2313         return self._print_UnifiedTransform(expr, 'F')
2314 
2315     def _print_InverseFourierTransform(self, expr):
2316         return self._print_UnifiedTransform(expr, 'F', True)
2317 
2318     def _print_SineTransform(self, expr):
2319         return self._print_UnifiedTransform(expr, 'SIN')
2320 
2321     def _print_InverseSineTransform(self, expr):
2322         return self._print_UnifiedTransform(expr, 'SIN', True)
2323 
2324     def _print_CosineTransform(self, expr):
2325         return self._print_UnifiedTransform(expr, 'COS')
2326 
2327     def _print_InverseCosineTransform(self, expr):
2328         return self._print_UnifiedTransform(expr, 'COS', True)
2329 
2330     def _print_DMP(self, p):
2331         try:
2332             if p.ring is not None:
2333                 # TODO incorporate order
2334                 return self._print(p.ring.to_sympy(p))
2335         except SympifyError:
2336             pass
2337         return self._print(repr(p))
2338 
2339     def _print_DMF(self, p):
2340         return self._print_DMP(p)
2341 
2342     def _print_Object(self, object):
2343         return self._print(Symbol(object.name))
2344 
2345     def _print_LambertW(self, expr):
2346         if len(expr.args) == 1:
2347             return r"W\left(%s\right)" % self._print(expr.args[0])
2348         return r"W_{%s}\left(%s\right)" % \
2349             (self._print(expr.args[1]), self._print(expr.args[0]))
2350 
2351     def _print_Morphism(self, morphism):
2352         domain = self._print(morphism.domain)
2353         codomain = self._print(morphism.codomain)
2354         return "%s\\rightarrow %s" % (domain, codomain)
2355 
2356     def _print_NamedMorphism(self, morphism):
2357         pretty_name = self._print(Symbol(morphism.name))
2358         pretty_morphism = self._print_Morphism(morphism)
2359         return "%s:%s" % (pretty_name, pretty_morphism)
2360 
2361     def _print_IdentityMorphism(self, morphism):
2362         from sympy.categories import NamedMorphism
2363         return self._print_NamedMorphism(NamedMorphism(
2364             morphism.domain, morphism.codomain, "id"))
2365 
2366     def _print_CompositeMorphism(self, morphism):
2367         # All components of the morphism have names and it is thus
2368         # possible to build the name of the composite.
2369         component_names_list = [self._print(Symbol(component.name)) for
2370                                 component in morphism.components]
2371         component_names_list.reverse()
2372         component_names = "\\circ ".join(component_names_list) + ":"
2373 
2374         pretty_morphism = self._print_Morphism(morphism)
2375         return component_names + pretty_morphism
2376 
2377     def _print_Category(self, morphism):
2378         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2379 
2380     def _print_Diagram(self, diagram):
2381         if not diagram.premises:
2382             # This is an empty diagram.
2383             return self._print(S.EmptySet)
2384 
2385         latex_result = self._print(diagram.premises)
2386         if diagram.conclusions:
2387             latex_result += "\\Longrightarrow %s" % \
2388                             self._print(diagram.conclusions)
2389 
2390         return latex_result
2391 
2392     def _print_DiagramGrid(self, grid):
2393         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2394 
2395         for i in range(grid.height):
2396             for j in range(grid.width):
2397                 if grid[i, j]:
2398                     latex_result += latex(grid[i, j])
2399                 latex_result += " "
2400                 if j != grid.width - 1:
2401                     latex_result += "& "
2402 
2403             if i != grid.height - 1:
2404                 latex_result += "\\\\"
2405             latex_result += "\n"
2406 
2407         latex_result += "\\end{array}\n"
2408         return latex_result
2409 
2410     def _print_FreeModule(self, M):
2411         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2412 
2413     def _print_FreeModuleElement(self, m):
2414         # Print as row vector for convenience, for now.
2415         return r"\left[ {} \right]".format(",".join(
2416             '{' + self._print(x) + '}' for x in m))
2417 
2418     def _print_SubModule(self, m):
2419         return r"\left\langle {} \right\rangle".format(",".join(
2420             '{' + self._print(x) + '}' for x in m.gens))
2421 
2422     def _print_ModuleImplementedIdeal(self, m):
2423         return r"\left\langle {} \right\rangle".format(",".join(
2424             '{' + self._print(x) + '}' for [x] in m._module.gens))
2425 
2426     def _print_Quaternion(self, expr):
2427         # TODO: This expression is potentially confusing,
2428         # shall we print it as `Quaternion( ... )`?
2429         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2430              for i in expr.args]
2431         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2432         return " + ".join(a)
2433 
2434     def _print_QuotientRing(self, R):
2435         # TODO nicer fractions for few generators...
2436         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2437                  self._print(R.base_ideal))
2438 
2439     def _print_QuotientRingElement(self, x):
2440         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2441                  self._print(x.ring.base_ideal))
2442 
2443     def _print_QuotientModuleElement(self, m):
2444         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2445                  self._print(m.module.killed_module))
2446 
2447     def _print_QuotientModule(self, M):
2448         # TODO nicer fractions for few generators...
2449         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2450                  self._print(M.killed_module))
2451 
2452     def _print_MatrixHomomorphism(self, h):
2453         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2454             self._print(h.domain), self._print(h.codomain))
2455 
2456     def _print_BaseScalarField(self, field):
2457         string = field._coord_sys._names[field._index]
2458         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2459 
2460     def _print_BaseVectorField(self, field):
2461         string = field._coord_sys._names[field._index]
2462         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2463 
2464     def _print_Differential(self, diff):
2465         field = diff._form_field
2466         if hasattr(field, '_coord_sys'):
2467             string = field._coord_sys._names[field._index]
2468             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2469         else:
2470             string = self._print(field)
2471             return r'\operatorname{{d}}\left({}\right)'.format(string)
2472 
2473     def _print_Tr(self, p):
2474         # TODO: Handle indices
2475         contents = self._print(p.args[0])
2476         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2477 
2478     def _print_totient(self, expr, exp=None):
2479         if exp is not None:
2480             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2481                 (self._print(expr.args[0]), self._print(exp))
2482         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2483 
2484     def _print_reduced_totient(self, expr, exp=None):
2485         if exp is not None:
2486             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2487                 (self._print(expr.args[0]), self._print(exp))
2488         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2489 
2490     def _print_divisor_sigma(self, expr, exp=None):
2491         if len(expr.args) == 2:
2492             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2493                                                 (expr.args[1], expr.args[0])))
2494         else:
2495             tex = r"\left(%s\right)" % self._print(expr.args[0])
2496         if exp is not None:
2497             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2498         return r"\sigma%s" % tex
2499 
2500     def _print_udivisor_sigma(self, expr, exp=None):
2501         if len(expr.args) == 2:
2502             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2503                                                 (expr.args[1], expr.args[0])))
2504         else:
2505             tex = r"\left(%s\right)" % self._print(expr.args[0])
2506         if exp is not None:
2507             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2508         return r"\sigma^*%s" % tex
2509 
2510     def _print_primenu(self, expr, exp=None):
2511         if exp is not None:
2512             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2513                 (self._print(expr.args[0]), self._print(exp))
2514         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2515 
2516     def _print_primeomega(self, expr, exp=None):
2517         if exp is not None:
2518             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2519                 (self._print(expr.args[0]), self._print(exp))
2520         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 20:32:24.540 | INFO     | Search completed. Bug locations: [<file>sympy/printing/pycode.py</file>
<class>MpmathPrinter</class>
<method>_print_Float</method>
<code>
527     def _print_Float(self, e):
528         # XXX: This does not handle setting mpmath.mp.dps. It is assumed that
529         # the caller of the lambdified function will have set it to sufficient
530         # precision to match the Floats in the expression.
531 
532         # Remove 'mpz' if gmpy is installed.
533         args = str(tuple(map(int, e._mpf_)))
534         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)

</code><intended_behavior>This method should be modified or extended to accept and utilize min_fixed and max_fixed settings for formatting floats. While the existing functionality of converting floats for mpmath compatibility should be preserved, the method should conditionally format the float representation based on these new settings when provided.</intended_behavior>, <file>sympy/printing/pycode.py</file>
<class>MpmathPrinter</class>
<method>None</method>
<code>
513 class MpmathPrinter(PythonCodePrinter):
514     """
515     Lambda printer for mpmath which maintains precision for floats
516     """
517     printmethod = "_mpmathcode"
518 
519     language = "Python with mpmath"
520 
521     _kf = dict(chain(
522         _known_functions.items(),
523         [(k, 'mpmath.' + v) for k, v in _known_functions_mpmath.items()]
524     ))
525     _kc = {k: 'mpmath.'+v for k, v in _known_constants_mpmath.items()}
526 
527     def _print_Float(self, e):
528         # XXX: This does not handle setting mpmath.mp.dps. It is assumed that
529         # the caller of the lambdified function will have set it to sufficient
530         # precision to match the Floats in the expression.
531 
532         # Remove 'mpz' if gmpy is installed.
533         args = str(tuple(map(int, e._mpf_)))
534         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)
535 
536 
537     def _print_Rational(self, e):
538         return "{func}({p})/{func}({q})".format(
539             func=self._module_format('mpmath.mpf'),
540             q=self._print(e.q),
541             p=self._print(e.p)
542         )
543 
544     def _print_Half(self, e):
545         return self._print_Rational(e)
546 
547     def _print_uppergamma(self, e):
548         return "{0}({1}, {2}, {3})".format(
549             self._module_format('mpmath.gammainc'),
550             self._print(e.args[0]),
551             self._print(e.args[1]),
552             self._module_format('mpmath.inf'))
553 
554     def _print_lowergamma(self, e):
555         return "{0}({1}, 0, {2})".format(
556             self._module_format('mpmath.gammainc'),
557             self._print(e.args[0]),
558             self._print(e.args[1]))
559 
560     def _print_log2(self, e):
561         return '{0}({1})/{0}(2)'.format(
562             self._module_format('mpmath.log'), self._print(e.args[0]))
563 
564     def _print_log1p(self, e):
565         return '{0}({1}+1)'.format(
566             self._module_format('mpmath.log'), self._print(e.args[0]))
567 
568     def _print_Pow(self, expr, rational=False):
569         return self._hprint_Pow(expr, rational=rational, sqrt='mpmath.sqrt')

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/numbers.py</file>
<class>Float</class>
<method>None</method>
<code>
858 class Float(Number):
859     """Represent a floating-point number of arbitrary precision.
860 
861     Examples
862     ========
863 
864     >>> from sympy import Float
865     >>> Float(3.5)
866     3.50000000000000
867     >>> Float(3)
868     3.00000000000000
869 
870     Creating Floats from strings (and Python ``int`` and ``long``
871     types) will give a minimum precision of 15 digits, but the
872     precision will automatically increase to capture all digits
873     entered.
874 
875     >>> Float(1)
876     1.00000000000000
877     >>> Float(10**20)
878     100000000000000000000.
879     >>> Float('1e20')
880     100000000000000000000.
881 
882     However, *floating-point* numbers (Python ``float`` types) retain
883     only 15 digits of precision:
884 
885     >>> Float(1e20)
886     1.00000000000000e+20
887     >>> Float(1.23456789123456789)
888     1.23456789123457
889 
890     It may be preferable to enter high-precision decimal numbers
891     as strings:
892 
893     Float('1.23456789123456789')
894     1.23456789123456789
895 
896     The desired number of digits can also be specified:
897 
898     >>> Float('1e-3', 3)
899     0.00100
900     >>> Float(100, 4)
901     100.0
902 
903     Float can automatically count significant figures if a null string
904     is sent for the precision; spaces or underscores are also allowed. (Auto-
905     counting is only allowed for strings, ints and longs).
906 
907     >>> Float('123 456 789.123_456', '')
908     123456789.123456
909     >>> Float('12e-3', '')
910     0.012
911     >>> Float(3, '')
912     3.
913 
914     If a number is written in scientific notation, only the digits before the
915     exponent are considered significant if a decimal appears, otherwise the
916     "e" signifies only how to move the decimal:
917 
918     >>> Float('60.e2', '')  # 2 digits significant
919     6.0e+3
920     >>> Float('60e2', '')  # 4 digits significant
921     6000.
922     >>> Float('600e-2', '')  # 3 digits significant
923     6.00
924 
925     Notes
926     =====
927 
928     Floats are inexact by their nature unless their value is a binary-exact
929     value.
930 
931     >>> approx, exact = Float(.1, 1), Float(.125, 1)
932 
933     For calculation purposes, evalf needs to be able to change the precision
934     but this will not increase the accuracy of the inexact value. The
935     following is the most accurate 5-digit approximation of a value of 0.1
936     that had only 1 digit of precision:
937 
938     >>> approx.evalf(5)
939     0.099609
940 
941     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
942     can be passed to Float or evalf to obtain an arbitrary precision with
943     matching accuracy:
944 
945     >>> Float(exact, 5)
946     0.12500
947     >>> exact.evalf(20)
948     0.12500000000000000000
949 
950     Trying to make a high-precision Float from a float is not disallowed,
951     but one must keep in mind that the *underlying float* (not the apparent
952     decimal value) is being obtained with high precision. For example, 0.3
953     does not have a finite binary representation. The closest rational is
954     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
955     0.3 to 20 digits of precision you will not see the same thing as 0.3
956     followed by 19 zeros:
957 
958     >>> Float(0.3, 20)
959     0.29999999999999998890
960 
961     If you want a 20-digit value of the decimal 0.3 (not the floating point
962     approximation of 0.3) you should send the 0.3 as a string. The underlying
963     representation is still binary but a higher precision than Python's float
964     is used:
965 
966     >>> Float('0.3', 20)
967     0.30000000000000000000
968 
969     Although you can increase the precision of an existing Float using Float
970     it will not increase the accuracy -- the underlying value is not changed:
971 
972     >>> def show(f): # binary rep of Float
973     ...     from sympy import Mul, Pow
974     ...     s, m, e, b = f._mpf_
975     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
976     ...     print('%s at prec=%s' % (v, f._prec))
977     ...
978     >>> t = Float('0.3', 3)
979     >>> show(t)
980     4915/2**14 at prec=13
981     >>> show(Float(t, 20)) # higher prec, not higher accuracy
982     4915/2**14 at prec=70
983     >>> show(Float(t, 2)) # lower prec
984     307/2**10 at prec=10
985 
986     The same thing happens when evalf is used on a Float:
987 
988     >>> show(t.evalf(20))
989     4915/2**14 at prec=70
990     >>> show(t.evalf(2))
991     307/2**10 at prec=10
992 
993     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
994     produce the number (-1)**n*c*2**p:
995 
996     >>> n, c, p = 1, 5, 0
997     >>> (-1)**n*c*2**p
998     -5
999     >>> Float((1, 5, 0))
1000     -5.00000000000000
1001 
1002     An actual mpf tuple also contains the number of bits in c as the last
1003     element of the tuple:
1004 
1005     >>> _._mpf_
1006     (1, 5, 0, 3)
1007 
1008     This is not needed for instantiation and is not the same thing as the
1009     precision. The mpf tuple and the precision are two separate quantities
1010     that Float tracks.
1011 
1012     In SymPy, a Float is a number that can be computed with arbitrary
1013     precision. Although floating point 'inf' and 'nan' are not such
1014     numbers, Float can create these numbers:
1015 
1016     >>> Float('-inf')
1017     -oo
1018     >>> _.is_Float
1019     False
1020     """
1021     __slots__ = ('_mpf_', '_prec')
1022 
1023     # A Float represents many real numbers,
1024     # both rational and irrational.
1025     is_rational = None
1026     is_irrational = None
1027     is_number = True
1028 
1029     is_real = True
1030     is_extended_real = True
1031 
1032     is_Float = True
1033 
1034     def __new__(cls, num, dps=None, prec=None, precision=None):
1035         if prec is not None:
1036             SymPyDeprecationWarning(
1037                             feature="Using 'prec=XX' to denote decimal precision",
1038                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
1039                                               "for binary precision",
1040                             issue=12820,
1041                             deprecated_since_version="1.1").warn()
1042             dps = prec
1043         del prec  # avoid using this deprecated kwarg
1044 
1045         if dps is not None and precision is not None:
1046             raise ValueError('Both decimal and binary precision supplied. '
1047                              'Supply only one. ')
1048 
1049         if isinstance(num, str):
1050             # Float accepts spaces as digit separators
1051             num = num.replace(' ', '').lower()
1052             # in Py 3.6
1053             # underscores are allowed. In anticipation of that, we ignore
1054             # legally placed underscores
1055             if '_' in num:
1056                 parts = num.split('_')
1057                 if not (all(parts) and
1058                         all(parts[i][-1].isdigit()
1059                             for i in range(0, len(parts), 2)) and
1060                         all(parts[i][0].isdigit()
1061                             for i in range(1, len(parts), 2))):
1062                     # copy Py 3.6 error
1063                     raise ValueError("could not convert string to float: '%s'" % num)
1064                 num = ''.join(parts)
1065             if num.startswith('.') and len(num) > 1:
1066                 num = '0' + num
1067             elif num.startswith('-.') and len(num) > 2:
1068                 num = '-0.' + num[2:]
1069             elif num in ('inf', '+inf'):
1070                 return S.Infinity
1071             elif num == '-inf':
1072                 return S.NegativeInfinity
1073         elif isinstance(num, float) and num == 0:
1074             num = '0'
1075         elif isinstance(num, float) and num == float('inf'):
1076             return S.Infinity
1077         elif isinstance(num, float) and num == float('-inf'):
1078             return S.NegativeInfinity
1079         elif isinstance(num, float) and num == float('nan'):
1080             return S.NaN
1081         elif isinstance(num, (SYMPY_INTS, Integer)):
1082             num = str(num)
1083         elif num is S.Infinity:
1084             return num
1085         elif num is S.NegativeInfinity:
1086             return num
1087         elif num is S.NaN:
1088             return num
1089         elif type(num).__module__ == 'numpy': # support for numpy datatypes
1090             num = _convert_numpy_types(num)
1091         elif isinstance(num, mpmath.mpf):
1092             if precision is None:
1093                 if dps is None:
1094                     precision = num.context.prec
1095             num = num._mpf_
1096 
1097         if dps is None and precision is None:
1098             dps = 15
1099             if isinstance(num, Float):
1100                 return num
1101             if isinstance(num, str) and _literal_float(num):
1102                 try:
1103                     Num = decimal.Decimal(num)
1104                 except decimal.InvalidOperation:
1105                     pass
1106                 else:
1107                     isint = '.' not in num
1108                     num, dps = _decimal_to_Rational_prec(Num)
1109                     if num.is_Integer and isint:
1110                         dps = max(dps, len(str(num).lstrip('-')))
1111                     dps = max(15, dps)
1112                     precision = mlib.libmpf.dps_to_prec(dps)
1113         elif precision == '' and dps is None or precision is None and dps == '':
1114             if not isinstance(num, str):
1115                 raise ValueError('The null string can only be used when '
1116                 'the number to Float is passed as a string or an integer.')
1117             ok = None
1118             if _literal_float(num):
1119                 try:
1120                     Num = decimal.Decimal(num)
1121                 except decimal.InvalidOperation:
1122                     pass
1123                 else:
1124                     isint = '.' not in num
1125                     num, dps = _decimal_to_Rational_prec(Num)
1126                     if num.is_Integer and isint:
1127                         dps = max(dps, len(str(num).lstrip('-')))
1128                         precision = mlib.libmpf.dps_to_prec(dps)
1129                     ok = True
1130             if ok is None:
1131                 raise ValueError('string-float not recognized: %s' % num)
1132 
1133         # decimal precision(dps) is set and maybe binary precision(precision)
1134         # as well.From here on binary precision is used to compute the Float.
1135         # Hence, if supplied use binary precision else translate from decimal
1136         # precision.
1137 
1138         if precision is None or precision == '':
1139             precision = mlib.libmpf.dps_to_prec(dps)
1140 
1141         precision = int(precision)
1142 
1143         if isinstance(num, float):
1144             _mpf_ = mlib.from_float(num, precision, rnd)
1145         elif isinstance(num, str):
1146             _mpf_ = mlib.from_str(num, precision, rnd)
1147         elif isinstance(num, decimal.Decimal):
1148             if num.is_finite():
1149                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1150             elif num.is_nan():
1151                 return S.NaN
1152             elif num.is_infinite():
1153                 if num > 0:
1154                     return S.Infinity
1155                 return S.NegativeInfinity
1156             else:
1157                 raise ValueError("unexpected decimal value %s" % str(num))
1158         elif isinstance(num, tuple) and len(num) in (3, 4):
1159             if type(num[1]) is str:
1160                 # it's a hexadecimal (coming from a pickled object)
1161                 # assume that it is in standard form
1162                 num = list(num)
1163                 # If we're loading an object pickled in Python 2 into
1164                 # Python 3, we may need to strip a tailing 'L' because
1165                 # of a shim for int on Python 3, see issue #13470.
1166                 if num[1].endswith('L'):
1167                     num[1] = num[1][:-1]
1168                 num[1] = MPZ(num[1], 16)
1169                 _mpf_ = tuple(num)
1170             else:
1171                 if len(num) == 4:
1172                     # handle normalization hack
1173                     return Float._new(num, precision)
1174                 else:
1175                     if not all((
1176                             num[0] in (0, 1),
1177                             num[1] >= 0,
1178                             all(type(i) in (long, int) for i in num)
1179                             )):
1180                         raise ValueError('malformed mpf: %s' % (num,))
1181                     # don't compute number or else it may
1182                     # over/underflow
1183                     return Float._new(
1184                         (num[0], num[1], num[2], bitcount(num[1])),
1185                         precision)
1186         else:
1187             try:
1188                 _mpf_ = num._as_mpf_val(precision)
1189             except (NotImplementedError, AttributeError):
1190                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1191 
1192         return cls._new(_mpf_, precision, zero=False)
1193 
1194     @classmethod
1195     def _new(cls, _mpf_, _prec, zero=True):
1196         # special cases
1197         if zero and _mpf_ == fzero:
1198             return S.Zero  # Float(0) -> 0.0; Float._new((0,0,0,0)) -> 0
1199         elif _mpf_ == _mpf_nan:
1200             return S.NaN
1201         elif _mpf_ == _mpf_inf:
1202             return S.Infinity
1203         elif _mpf_ == _mpf_ninf:
1204             return S.NegativeInfinity
1205 
1206         obj = Expr.__new__(cls)
1207         obj._mpf_ = mpf_norm(_mpf_, _prec)
1208         obj._prec = _prec
1209         return obj
1210 
1211     # mpz can't be pickled
1212     def __getnewargs__(self):
1213         return (mlib.to_pickable(self._mpf_),)
1214 
1215     def __getstate__(self):
1216         return {'_prec': self._prec}
1217 
1218     def _hashable_content(self):
1219         return (self._mpf_, self._prec)
1220 
1221     def floor(self):
1222         return Integer(int(mlib.to_int(
1223             mlib.mpf_floor(self._mpf_, self._prec))))
1224 
1225     def ceiling(self):
1226         return Integer(int(mlib.to_int(
1227             mlib.mpf_ceil(self._mpf_, self._prec))))
1228 
1229     def __floor__(self):
1230         return self.floor()
1231 
1232     def __ceil__(self):
1233         return self.ceiling()
1234 
1235     @property
1236     def num(self):
1237         return mpmath.mpf(self._mpf_)
1238 
1239     def _as_mpf_val(self, prec):
1240         rv = mpf_norm(self._mpf_, prec)
1241         if rv != self._mpf_ and self._prec == prec:
1242             debug(self._mpf_, rv)
1243         return rv
1244 
1245     def _as_mpf_op(self, prec):
1246         return self._mpf_, max(prec, self._prec)
1247 
1248     def _eval_is_finite(self):
1249         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1250             return False
1251         return True
1252 
1253     def _eval_is_infinite(self):
1254         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1255             return True
1256         return False
1257 
1258     def _eval_is_integer(self):
1259         return self._mpf_ == fzero
1260 
1261     def _eval_is_negative(self):
1262         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1263             return False
1264         return self.num < 0
1265 
1266     def _eval_is_positive(self):
1267         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1268             return False
1269         return self.num > 0
1270 
1271     def _eval_is_extended_negative(self):
1272         if self._mpf_ == _mpf_ninf:
1273             return True
1274         if self._mpf_ == _mpf_inf:
1275             return False
1276         return self.num < 0
1277 
1278     def _eval_is_extended_positive(self):
1279         if self._mpf_ == _mpf_inf:
1280             return True
1281         if self._mpf_ == _mpf_ninf:
1282             return False
1283         return self.num > 0
1284 
1285     def _eval_is_zero(self):
1286         return self._mpf_ == fzero
1287 
1288     def __nonzero__(self):
1289         return self._mpf_ != fzero
1290 
1291     __bool__ = __nonzero__
1292 
1293     def __neg__(self):
1294         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1295 
1296     @_sympifyit('other', NotImplemented)
1297     def __add__(self, other):
1298         if isinstance(other, Number) and global_parameters.evaluate:
1299             rhs, prec = other._as_mpf_op(self._prec)
1300             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1301         return Number.__add__(self, other)
1302 
1303     @_sympifyit('other', NotImplemented)
1304     def __sub__(self, other):
1305         if isinstance(other, Number) and global_parameters.evaluate:
1306             rhs, prec = other._as_mpf_op(self._prec)
1307             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1308         return Number.__sub__(self, other)
1309 
1310     @_sympifyit('other', NotImplemented)
1311     def __mul__(self, other):
1312         if isinstance(other, Number) and global_parameters.evaluate:
1313             rhs, prec = other._as_mpf_op(self._prec)
1314             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1315         return Number.__mul__(self, other)
1316 
1317     @_sympifyit('other', NotImplemented)
1318     def __div__(self, other):
1319         if isinstance(other, Number) and other != 0 and global_parameters.evaluate:
1320             rhs, prec = other._as_mpf_op(self._prec)
1321             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1322         return Number.__div__(self, other)
1323 
1324     __truediv__ = __div__
1325 
1326     @_sympifyit('other', NotImplemented)
1327     def __mod__(self, other):
1328         if isinstance(other, Rational) and other.q != 1 and global_parameters.evaluate:
1329             # calculate mod with Rationals, *then* round the result
1330             return Float(Rational.__mod__(Rational(self), other),
1331                          precision=self._prec)
1332         if isinstance(other, Float) and global_parameters.evaluate:
1333             r = self/other
1334             if r == int(r):
1335                 return Float(0, precision=max(self._prec, other._prec))
1336         if isinstance(other, Number) and global_parameters.evaluate:
1337             rhs, prec = other._as_mpf_op(self._prec)
1338             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1339         return Number.__mod__(self, other)
1340 
1341     @_sympifyit('other', NotImplemented)
1342     def __rmod__(self, other):
1343         if isinstance(other, Float) and global_parameters.evaluate:
1344             return other.__mod__(self)
1345         if isinstance(other, Number) and global_parameters.evaluate:
1346             rhs, prec = other._as_mpf_op(self._prec)
1347             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1348         return Number.__rmod__(self, other)
1349 
1350     def _eval_power(self, expt):
1351         """
1352         expt is symbolic object but not equal to 0, 1
1353 
1354         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1355                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1356         """
1357         if self == 0:
1358             if expt.is_positive:
1359                 return S.Zero
1360             if expt.is_negative:
1361                 return S.Infinity
1362         if isinstance(expt, Number):
1363             if isinstance(expt, Integer):
1364                 prec = self._prec
1365                 return Float._new(
1366                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1367             elif isinstance(expt, Rational) and \
1368                     expt.p == 1 and expt.q % 2 and self.is_negative:
1369                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1370                     -self)._eval_power(expt)
1371             expt, prec = expt._as_mpf_op(self._prec)
1372             mpfself = self._mpf_
1373             try:
1374                 y = mpf_pow(mpfself, expt, prec, rnd)
1375                 return Float._new(y, prec)
1376             except mlib.ComplexResult:
1377                 re, im = mlib.mpc_pow(
1378                     (mpfself, fzero), (expt, fzero), prec, rnd)
1379                 return Float._new(re, prec) + \
1380                     Float._new(im, prec)*S.ImaginaryUnit
1381 
1382     def __abs__(self):
1383         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1384 
1385     def __int__(self):
1386         if self._mpf_ == fzero:
1387             return 0
1388         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1389 
1390     __long__ = __int__
1391 
1392     def __eq__(self, other):
1393         try:
1394             other = _sympify(other)
1395         except SympifyError:
1396             return NotImplemented
1397         if not self:
1398             return not other
1399         if other.is_NumberSymbol:
1400             if other.is_irrational:
1401                 return False
1402             return other.__eq__(self)
1403         if other.is_Float:
1404             # comparison is exact
1405             # so Float(.1, 3) != Float(.1, 33)
1406             return self._mpf_ == other._mpf_
1407         if other.is_Rational:
1408             return other.__eq__(self)
1409         if other.is_Number:
1410             # numbers should compare at the same precision;
1411             # all _as_mpf_val routines should be sure to abide
1412             # by the request to change the prec if necessary; if
1413             # they don't, the equality test will fail since it compares
1414             # the mpf tuples
1415             ompf = other._as_mpf_val(self._prec)
1416             return bool(mlib.mpf_eq(self._mpf_, ompf))
1417         return False    # Float != non-Number
1418 
1419     def __ne__(self, other):
1420         return not self == other
1421 
1422     def _Frel(self, other, op):
1423         from sympy.core.numbers import prec_to_dps
1424         try:
1425             other = _sympify(other)
1426         except SympifyError:
1427             return NotImplemented
1428         if other.is_Rational:
1429             # test self*other.q <?> other.p without losing precision
1430             '''
1431             >>> f = Float(.1,2)
1432             >>> i = 1234567890
1433             >>> (f*i)._mpf_
1434             (0, 471, 18, 9)
1435             >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))
1436             (0, 505555550955, -12, 39)
1437             '''
1438             smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
1439             ompf = mlib.from_int(other.p)
1440             return _sympify(bool(op(smpf, ompf)))
1441         elif other.is_Float:
1442             return _sympify(bool(
1443                         op(self._mpf_, other._mpf_)))
1444         elif other.is_comparable and other not in (
1445                 S.Infinity, S.NegativeInfinity):
1446             other = other.evalf(prec_to_dps(self._prec))
1447             if other._prec > 1:
1448                 if other.is_Number:
1449                     return _sympify(bool(
1450                         op(self._mpf_, other._as_mpf_val(self._prec))))
1451 
1452     def __gt__(self, other):
1453         if isinstance(other, NumberSymbol):
1454             return other.__lt__(self)
1455         rv = self._Frel(other, mlib.mpf_gt)
1456         if rv is None:
1457             return Expr.__gt__(self, other)
1458         return rv
1459 
1460     def __ge__(self, other):
1461         if isinstance(other, NumberSymbol):
1462             return other.__le__(self)
1463         rv = self._Frel(other, mlib.mpf_ge)
1464         if rv is None:
1465             return Expr.__ge__(self, other)
1466         return rv
1467 
1468     def __lt__(self, other):
1469         if isinstance(other, NumberSymbol):
1470             return other.__gt__(self)
1471         rv = self._Frel(other, mlib.mpf_lt)
1472         if rv is None:
1473             return Expr.__lt__(self, other)
1474         return rv
1475 
1476     def __le__(self, other):
1477         if isinstance(other, NumberSymbol):
1478             return other.__ge__(self)
1479         rv = self._Frel(other, mlib.mpf_le)
1480         if rv is None:
1481             return Expr.__le__(self, other)
1482         return rv
1483 
1484     def __hash__(self):
1485         return super(Float, self).__hash__()
1486 
1487     def epsilon_eq(self, other, epsilon="1e-15"):
1488         return abs(self - other) < Float(epsilon)
1489 
1490     def _sage_(self):
1491         import sage.all as sage
1492         return sage.RealNumber(str(self))
1493 
1494     def __format__(self, format_spec):
1495         return format(decimal.Decimal(str(self)), format_spec)

</code><intended_behavior>Although the class implementation does not necessarily embody a 'bug' per se, to accommodate the issue, it might require extension to store and manage min_fixed and max_fixed attributes. This entails modifying the __new__ or _new method to optionally accept these parameters and adjusting relevant formatting methods (potentially including a custom __format__ or enhancing existing methods) to leverage these values when transforming Float instances to strings.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Float</method>
<code>
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real

</code><intended_behavior>This method currently applies strip_zeros=True unconditionally. To resolve the issue, the behavior should be changed to factor in min_fixed and max_fixed preferences. This could involve: 1) adjusting the method to check for and apply these settings if they are present in the Float instance or globally within the printer settings, and 2) ensuring that when these settings are active, the zeros stripping and number formatting are aligned with them, preserving existing functionality when they are not specified.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
124 class LatexPrinter(Printer):
125     printmethod = "_latex"
126 
127     _default_settings = {
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "inv_trig_style": "abbreviated",
132         "itex": False,
133         "ln_notation": False,
134         "long_frac_ratio": None,
135         "mat_delim": "[",
136         "mat_str": None,
137         "mode": "plain",
138         "mul_symbol": None,
139         "order": None,
140         "symbol_names": {},
141         "root_notation": True,
142         "mat_symbol_style": "plain",
143         "imaginary_unit": "i",
144         "gothic_re_im": False,
145         "decimal_separator": "period",
146         "perm_cyclic": True,
147     }  # type: Dict[str, Any]
148 
149     def __init__(self, settings=None):
150         Printer.__init__(self, settings)
151 
152         if 'mode' in self._settings:
153             valid_modes = ['inline', 'plain', 'equation',
154                            'equation*']
155             if self._settings['mode'] not in valid_modes:
156                 raise ValueError("'mode' must be one of 'inline', 'plain', "
157                                  "'equation' or 'equation*'")
158 
159         if self._settings['fold_short_frac'] is None and \
160                 self._settings['mode'] == 'inline':
161             self._settings['fold_short_frac'] = True
162 
163         mul_symbol_table = {
164             None: r" ",
165             "ldot": r" \,.\, ",
166             "dot": r" \cdot ",
167             "times": r" \times "
168         }
169         try:
170             self._settings['mul_symbol_latex'] = \
171                 mul_symbol_table[self._settings['mul_symbol']]
172         except KeyError:
173             self._settings['mul_symbol_latex'] = \
174                 self._settings['mul_symbol']
175         try:
176             self._settings['mul_symbol_latex_numbers'] = \
177                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
178         except KeyError:
179             if (self._settings['mul_symbol'].strip() in
180                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
181                 self._settings['mul_symbol_latex_numbers'] = \
182                     mul_symbol_table['dot']
183             else:
184                 self._settings['mul_symbol_latex_numbers'] = \
185                     self._settings['mul_symbol']
186 
187         self._delim_dict = {'(': ')', '[': ']'}
188 
189         imaginary_unit_table = {
190             None: r"i",
191             "i": r"i",
192             "ri": r"\mathrm{i}",
193             "ti": r"\text{i}",
194             "j": r"j",
195             "rj": r"\mathrm{j}",
196             "tj": r"\text{j}",
197         }
198         try:
199             self._settings['imaginary_unit_latex'] = \
200                 imaginary_unit_table[self._settings['imaginary_unit']]
201         except KeyError:
202             self._settings['imaginary_unit_latex'] = \
203                 self._settings['imaginary_unit']
204 
205     def parenthesize(self, item, level, strict=False):
206         prec_val = precedence_traditional(item)
207         if (prec_val < level) or ((not strict) and prec_val <= level):
208             return r"\left({}\right)".format(self._print(item))
209         else:
210             return self._print(item)
211 
212     def parenthesize_super(self, s):
213         """ Parenthesize s if there is a superscript in s"""
214         if "^" in s:
215             return r"\left({}\right)".format(s)
216         return s
217 
218     def embed_super(self, s):
219         """ Embed s in {} if there is a superscript in s"""
220         if "^" in s:
221             return "{{{}}}".format(s)
222         return s
223 
224     def doprint(self, expr):
225         tex = Printer.doprint(self, expr)
226 
227         if self._settings['mode'] == 'plain':
228             return tex
229         elif self._settings['mode'] == 'inline':
230             return r"$%s$" % tex
231         elif self._settings['itex']:
232             return r"$$%s$$" % tex
233         else:
234             env_str = self._settings['mode']
235             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
236 
237     def _needs_brackets(self, expr):
238         """
239         Returns True if the expression needs to be wrapped in brackets when
240         printed, False otherwise. For example: a + b => True; a => False;
241         10 => False; -10 => True.
242         """
243         return not ((expr.is_Integer and expr.is_nonnegative)
244                     or (expr.is_Atom and (expr is not S.NegativeOne
245                                           and expr.is_Rational is False)))
246 
247     def _needs_function_brackets(self, expr):
248         """
249         Returns True if the expression needs to be wrapped in brackets when
250         passed as an argument to a function, False otherwise. This is a more
251         liberal version of _needs_brackets, in that many expressions which need
252         to be wrapped in brackets when added/subtracted/raised to a power do
253         not need them when passed to a function. Such an example is a*b.
254         """
255         if not self._needs_brackets(expr):
256             return False
257         else:
258             # Muls of the form a*b*c... can be folded
259             if expr.is_Mul and not self._mul_is_clean(expr):
260                 return True
261             # Pows which don't need brackets can be folded
262             elif expr.is_Pow and not self._pow_is_clean(expr):
263                 return True
264             # Add and Function always need brackets
265             elif expr.is_Add or expr.is_Function:
266                 return True
267             else:
268                 return False
269 
270     def _needs_mul_brackets(self, expr, first=False, last=False):
271         """
272         Returns True if the expression needs to be wrapped in brackets when
273         printed as part of a Mul, False otherwise. This is True for Add,
274         but also for some container objects that would not need brackets
275         when appearing last in a Mul, e.g. an Integral. ``last=True``
276         specifies that this expr is the last to appear in a Mul.
277         ``first=True`` specifies that this expr is the first to appear in
278         a Mul.
279         """
280         from sympy import Integral, Product, Sum
281 
282         if expr.is_Mul:
283             if not first and _coeff_isneg(expr):
284                 return True
285         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
286             return True
287         elif expr.is_Relational:
288             return True
289         if expr.is_Piecewise:
290             return True
291         if any([expr.has(x) for x in (Mod,)]):
292             return True
293         if (not last and
294                 any([expr.has(x) for x in (Integral, Product, Sum)])):
295             return True
296 
297         return False
298 
299     def _needs_add_brackets(self, expr):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of an Add, False otherwise.  This is False for most
303         things.
304         """
305         if expr.is_Relational:
306             return True
307         if any([expr.has(x) for x in (Mod,)]):
308             return True
309         if expr.is_Add:
310             return True
311         return False
312 
313     def _mul_is_clean(self, expr):
314         for arg in expr.args:
315             if arg.is_Function:
316                 return False
317         return True
318 
319     def _pow_is_clean(self, expr):
320         return not self._needs_brackets(expr.base)
321 
322     def _do_exponent(self, expr, exp):
323         if exp is not None:
324             return r"\left(%s\right)^{%s}" % (expr, exp)
325         else:
326             return expr
327 
328     def _print_Basic(self, expr):
329         ls = [self._print(o) for o in expr.args]
330         return self._deal_with_super_sub(expr.__class__.__name__) + \
331             r"\left(%s\right)" % ", ".join(ls)
332 
333     def _print_bool(self, e):
334         return r"\text{%s}" % e
335 
336     _print_BooleanTrue = _print_bool
337     _print_BooleanFalse = _print_bool
338 
339     def _print_NoneType(self, e):
340         return r"\text{%s}" % e
341 
342     def _print_Add(self, expr, order=None):
343         if self.order == 'none':
344             terms = list(expr.args)
345         else:
346             terms = self._as_ordered_terms(expr, order=order)
347 
348         tex = ""
349         for i, term in enumerate(terms):
350             if i == 0:
351                 pass
352             elif _coeff_isneg(term):
353                 tex += " - "
354                 term = -term
355             else:
356                 tex += " + "
357             term_tex = self._print(term)
358             if self._needs_add_brackets(term):
359                 term_tex = r"\left(%s\right)" % term_tex
360             tex += term_tex
361 
362         return tex
363 
364     def _print_Cycle(self, expr):
365         from sympy.combinatorics.permutations import Permutation
366         if expr.size == 0:
367             return r"\left( \right)"
368         expr = Permutation(expr)
369         expr_perm = expr.cyclic_form
370         siz = expr.size
371         if expr.array_form[-1] == siz - 1:
372             expr_perm = expr_perm + [[siz - 1]]
373         term_tex = ''
374         for i in expr_perm:
375             term_tex += str(i).replace(',', r"\;")
376         term_tex = term_tex.replace('[', r"\left( ")
377         term_tex = term_tex.replace(']', r"\right)")
378         return term_tex
379 
380     def _print_Permutation(self, expr):
381         from sympy.combinatorics.permutations import Permutation
382         from sympy.utilities.exceptions import SymPyDeprecationWarning
383 
384         perm_cyclic = Permutation.print_cyclic
385         if perm_cyclic is not None:
386             SymPyDeprecationWarning(
387                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
388                 useinstead="init_printing(perm_cyclic={})"
389                 .format(perm_cyclic),
390                 issue=15201,
391                 deprecated_since_version="1.6").warn()
392         else:
393             perm_cyclic = self._settings.get("perm_cyclic", True)
394 
395         if perm_cyclic:
396             return self._print_Cycle(expr)
397 
398         if expr.size == 0:
399             return r"\left( \right)"
400 
401         lower = [self._print(arg) for arg in expr.array_form]
402         upper = [self._print(arg) for arg in range(len(lower))]
403 
404         row1 = " & ".join(upper)
405         row2 = " & ".join(lower)
406         mat = r" \\ ".join((row1, row2))
407         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
408 
409 
410     def _print_AppliedPermutation(self, expr):
411         perm, var = expr.args
412         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
413 
414     def _print_Float(self, expr):
415         # Based off of that in StrPrinter
416         dps = prec_to_dps(expr._prec)
417         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
418 
419         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
420         # thus we use the number separator
421         separator = self._settings['mul_symbol_latex_numbers']
422 
423         if 'e' in str_real:
424             (mant, exp) = str_real.split('e')
425 
426             if exp[0] == '+':
427                 exp = exp[1:]
428             if self._settings['decimal_separator'] == 'comma':
429                 mant = mant.replace('.','{,}')
430 
431             return r"%s%s10^{%s}" % (mant, separator, exp)
432         elif str_real == "+inf":
433             return r"\infty"
434         elif str_real == "-inf":
435             return r"- \infty"
436         else:
437             if self._settings['decimal_separator'] == 'comma':
438                 str_real = str_real.replace('.','{,}')
439             return str_real
440 
441     def _print_Cross(self, expr):
442         vec1 = expr._expr1
443         vec2 = expr._expr2
444         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
445                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
446 
447     def _print_Curl(self, expr):
448         vec = expr._expr
449         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
450 
451     def _print_Divergence(self, expr):
452         vec = expr._expr
453         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
454 
455     def _print_Dot(self, expr):
456         vec1 = expr._expr1
457         vec2 = expr._expr2
458         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
459                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
460 
461     def _print_Gradient(self, expr):
462         func = expr._expr
463         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
464 
465     def _print_Laplacian(self, expr):
466         func = expr._expr
467         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
468 
469     def _print_Mul(self, expr):
470         from sympy.core.power import Pow
471         from sympy.physics.units import Quantity
472         include_parens = False
473         if _coeff_isneg(expr):
474             expr = -expr
475             tex = "- "
476             if expr.is_Add:
477                 tex += "("
478                 include_parens = True
479         else:
480             tex = ""
481 
482         from sympy.simplify import fraction
483         numer, denom = fraction(expr, exact=True)
484         separator = self._settings['mul_symbol_latex']
485         numbersep = self._settings['mul_symbol_latex_numbers']
486 
487         def convert(expr):
488             if not expr.is_Mul:
489                 return str(self._print(expr))
490             else:
491                 _tex = last_term_tex = ""
492 
493                 if self.order not in ('old', 'none'):
494                     args = expr.as_ordered_factors()
495                 else:
496                     args = list(expr.args)
497 
498                 # If quantities are present append them at the back
499                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
500                               (isinstance(x, Pow) and
501                                isinstance(x.base, Quantity)))
502 
503                 for i, term in enumerate(args):
504                     term_tex = self._print(term)
505 
506                     if self._needs_mul_brackets(term, first=(i == 0),
507                                                 last=(i == len(args) - 1)):
508                         term_tex = r"\left(%s\right)" % term_tex
509 
510                     if _between_two_numbers_p[0].search(last_term_tex) and \
511                             _between_two_numbers_p[1].match(term_tex):
512                         # between two numbers
513                         _tex += numbersep
514                     elif _tex:
515                         _tex += separator
516 
517                     _tex += term_tex
518                     last_term_tex = term_tex
519                 return _tex
520 
521         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
522             # use the original expression here, since fraction() may have
523             # altered it when producing numer and denom
524             tex += convert(expr)
525 
526         else:
527             snumer = convert(numer)
528             sdenom = convert(denom)
529             ldenom = len(sdenom.split())
530             ratio = self._settings['long_frac_ratio']
531             if self._settings['fold_short_frac'] and ldenom <= 2 and \
532                     "^" not in sdenom:
533                 # handle short fractions
534                 if self._needs_mul_brackets(numer, last=False):
535                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
536                 else:
537                     tex += r"%s / %s" % (snumer, sdenom)
538             elif ratio is not None and \
539                     len(snumer.split()) > ratio*ldenom:
540                 # handle long fractions
541                 if self._needs_mul_brackets(numer, last=True):
542                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
543                         % (sdenom, separator, snumer)
544                 elif numer.is_Mul:
545                     # split a long numerator
546                     a = S.One
547                     b = S.One
548                     for x in numer.args:
549                         if self._needs_mul_brackets(x, last=False) or \
550                                 len(convert(a*x).split()) > ratio*ldenom or \
551                                 (b.is_commutative is x.is_commutative is False):
552                             b *= x
553                         else:
554                             a *= x
555                     if self._needs_mul_brackets(b, last=True):
556                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
557                             % (convert(a), sdenom, separator, convert(b))
558                     else:
559                         tex += r"\frac{%s}{%s}%s%s" \
560                             % (convert(a), sdenom, separator, convert(b))
561                 else:
562                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
563             else:
564                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
565 
566         if include_parens:
567             tex += ")"
568         return tex
569 
570     def _print_Pow(self, expr):
571         # Treat x**Rational(1,n) as special case
572         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
573                 and self._settings['root_notation']:
574             base = self._print(expr.base)
575             expq = expr.exp.q
576 
577             if expq == 2:
578                 tex = r"\sqrt{%s}" % base
579             elif self._settings['itex']:
580                 tex = r"\root{%d}{%s}" % (expq, base)
581             else:
582                 tex = r"\sqrt[%d]{%s}" % (expq, base)
583 
584             if expr.exp.is_negative:
585                 return r"\frac{1}{%s}" % tex
586             else:
587                 return tex
588         elif self._settings['fold_frac_powers'] \
589             and expr.exp.is_Rational \
590                 and expr.exp.q != 1:
591             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
592             p, q = expr.exp.p, expr.exp.q
593             # issue #12886: add parentheses for superscripts raised to powers
594             if '^' in base and expr.base.is_Symbol:
595                 base = r"\left(%s\right)" % base
596             if expr.base.is_Function:
597                 return self._print(expr.base, exp="%s/%s" % (p, q))
598             return r"%s^{%s/%s}" % (base, p, q)
599         elif expr.exp.is_Rational and expr.exp.is_negative and \
600                 expr.base.is_commutative:
601             # special case for 1^(-x), issue 9216
602             if expr.base == 1:
603                 return r"%s^{%s}" % (expr.base, expr.exp)
604             # things like 1/x
605             return self._print_Mul(expr)
606         else:
607             if expr.base.is_Function:
608                 return self._print(expr.base, exp=self._print(expr.exp))
609             else:
610                 tex = r"%s^{%s}"
611                 return self._helper_print_standard_power(expr, tex)
612 
613     def _helper_print_standard_power(self, expr, template):
614         exp = self._print(expr.exp)
615         # issue #12886: add parentheses around superscripts raised
616         # to powers
617         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
618         if '^' in base and expr.base.is_Symbol:
619             base = r"\left(%s\right)" % base
620         elif (isinstance(expr.base, Derivative)
621             and base.startswith(r'\left(')
622             and re.match(r'\\left\(\\d?d?dot', base)
623             and base.endswith(r'\right)')):
624             # don't use parentheses around dotted derivative
625             base = base[6: -7]  # remove outermost added parens
626         return template % (base, exp)
627 
628     def _print_UnevaluatedExpr(self, expr):
629         return self._print(expr.args[0])
630 
631     def _print_Sum(self, expr):
632         if len(expr.limits) == 1:
633             tex = r"\sum_{%s=%s}^{%s} " % \
634                 tuple([self._print(i) for i in expr.limits[0]])
635         else:
636             def _format_ineq(l):
637                 return r"%s \leq %s \leq %s" % \
638                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
639 
640             tex = r"\sum_{\substack{%s}} " % \
641                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
642 
643         if isinstance(expr.function, Add):
644             tex += r"\left(%s\right)" % self._print(expr.function)
645         else:
646             tex += self._print(expr.function)
647 
648         return tex
649 
650     def _print_Product(self, expr):
651         if len(expr.limits) == 1:
652             tex = r"\prod_{%s=%s}^{%s} " % \
653                 tuple([self._print(i) for i in expr.limits[0]])
654         else:
655             def _format_ineq(l):
656                 return r"%s \leq %s \leq %s" % \
657                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
658 
659             tex = r"\prod_{\substack{%s}} " % \
660                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
661 
662         if isinstance(expr.function, Add):
663             tex += r"\left(%s\right)" % self._print(expr.function)
664         else:
665             tex += self._print(expr.function)
666 
667         return tex
668 
669     def _print_BasisDependent(self, expr):
670         from sympy.vector import Vector
671 
672         o1 = []
673         if expr == expr.zero:
674             return expr.zero._latex_form
675         if isinstance(expr, Vector):
676             items = expr.separate().items()
677         else:
678             items = [(0, expr)]
679 
680         for system, vect in items:
681             inneritems = list(vect.components.items())
682             inneritems.sort(key=lambda x: x[0].__str__())
683             for k, v in inneritems:
684                 if v == 1:
685                     o1.append(' + ' + k._latex_form)
686                 elif v == -1:
687                     o1.append(' - ' + k._latex_form)
688                 else:
689                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
690                     o1.append(' + ' + arg_str + k._latex_form)
691 
692         outstr = (''.join(o1))
693         if outstr[1] != '-':
694             outstr = outstr[3:]
695         else:
696             outstr = outstr[1:]
697         return outstr
698 
699     def _print_Indexed(self, expr):
700         tex_base = self._print(expr.base)
701         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
702             map(self._print, expr.indices))
703         return tex
704 
705     def _print_IndexedBase(self, expr):
706         return self._print(expr.label)
707 
708     def _print_Derivative(self, expr):
709         if requires_partial(expr.expr):
710             diff_symbol = r'\partial'
711         else:
712             diff_symbol = r'd'
713 
714         tex = ""
715         dim = 0
716         for x, num in reversed(expr.variable_count):
717             dim += num
718             if num == 1:
719                 tex += r"%s %s" % (diff_symbol, self._print(x))
720             else:
721                 tex += r"%s %s^{%s}" % (diff_symbol,
722                                         self.parenthesize_super(self._print(x)),
723                                         self._print(num))
724 
725         if dim == 1:
726             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
727         else:
728             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
729 
730         return r"%s %s" % (tex, self.parenthesize(expr.expr,
731                                                   PRECEDENCE["Mul"],
732                                                   strict=True))
733 
734     def _print_Subs(self, subs):
735         expr, old, new = subs.args
736         latex_expr = self._print(expr)
737         latex_old = (self._print(e) for e in old)
738         latex_new = (self._print(e) for e in new)
739         latex_subs = r'\\ '.join(
740             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
741         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
742                                                          latex_subs)
743 
744     def _print_Integral(self, expr):
745         tex, symbols = "", []
746 
747         # Only up to \iiiint exists
748         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
749             # Use len(expr.limits)-1 so that syntax highlighters don't think
750             # \" is an escaped quote
751             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
752             symbols = [r"\, d%s" % self._print(symbol[0])
753                        for symbol in expr.limits]
754 
755         else:
756             for lim in reversed(expr.limits):
757                 symbol = lim[0]
758                 tex += r"\int"
759 
760                 if len(lim) > 1:
761                     if self._settings['mode'] != 'inline' \
762                             and not self._settings['itex']:
763                         tex += r"\limits"
764 
765                     if len(lim) == 3:
766                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
767                                                self._print(lim[2]))
768                     if len(lim) == 2:
769                         tex += "^{%s}" % (self._print(lim[1]))
770 
771                 symbols.insert(0, r"\, d%s" % self._print(symbol))
772 
773         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
774                                                     PRECEDENCE["Mul"],
775                                                     strict=True),
776                              "".join(symbols))
777 
778     def _print_Limit(self, expr):
779         e, z, z0, dir = expr.args
780 
781         tex = r"\lim_{%s \to " % self._print(z)
782         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
783             tex += r"%s}" % self._print(z0)
784         else:
785             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
786 
787         if isinstance(e, AssocOp):
788             return r"%s\left(%s\right)" % (tex, self._print(e))
789         else:
790             return r"%s %s" % (tex, self._print(e))
791 
792     def _hprint_Function(self, func):
793         r'''
794         Logic to decide how to render a function to latex
795           - if it is a recognized latex name, use the appropriate latex command
796           - if it is a single letter, just use that letter
797           - if it is a longer name, then put \operatorname{} around it and be
798             mindful of undercores in the name
799         '''
800         func = self._deal_with_super_sub(func)
801         if func in accepted_latex_functions:
802             name = r"\%s" % func
803         elif len(func) == 1 or func.startswith('\\'):
804             name = func
805         else:
806             name = r"\operatorname{%s}" % func
807         return name
808 
809     def _print_Function(self, expr, exp=None):
810         r'''
811         Render functions to LaTeX, handling functions that LaTeX knows about
812         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
813         For single-letter function names, render them as regular LaTeX math
814         symbols. For multi-letter function names that LaTeX does not know
815         about, (e.g., Li, sech) use \operatorname{} so that the function name
816         is rendered in Roman font and LaTeX handles spacing properly.
817 
818         expr is the expression involving the function
819         exp is an exponent
820         '''
821         func = expr.func.__name__
822         if hasattr(self, '_print_' + func) and \
823                 not isinstance(expr, AppliedUndef):
824             return getattr(self, '_print_' + func)(expr, exp)
825         else:
826             args = [str(self._print(arg)) for arg in expr.args]
827             # How inverse trig functions should be displayed, formats are:
828             # abbreviated: asin, full: arcsin, power: sin^-1
829             inv_trig_style = self._settings['inv_trig_style']
830             # If we are dealing with a power-style inverse trig function
831             inv_trig_power_case = False
832             # If it is applicable to fold the argument brackets
833             can_fold_brackets = self._settings['fold_func_brackets'] and \
834                 len(args) == 1 and \
835                 not self._needs_function_brackets(expr.args[0])
836 
837             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
838 
839             # If the function is an inverse trig function, handle the style
840             if func in inv_trig_table:
841                 if inv_trig_style == "abbreviated":
842                     pass
843                 elif inv_trig_style == "full":
844                     func = "arc" + func[1:]
845                 elif inv_trig_style == "power":
846                     func = func[1:]
847                     inv_trig_power_case = True
848 
849                     # Can never fold brackets if we're raised to a power
850                     if exp is not None:
851                         can_fold_brackets = False
852 
853             if inv_trig_power_case:
854                 if func in accepted_latex_functions:
855                     name = r"\%s^{-1}" % func
856                 else:
857                     name = r"\operatorname{%s}^{-1}" % func
858             elif exp is not None:
859                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
860             else:
861                 name = self._hprint_Function(func)
862 
863             if can_fold_brackets:
864                 if func in accepted_latex_functions:
865                     # Wrap argument safely to avoid parse-time conflicts
866                     # with the function name itself
867                     name += r" {%s}"
868                 else:
869                     name += r"%s"
870             else:
871                 name += r"{\left(%s \right)}"
872 
873             if inv_trig_power_case and exp is not None:
874                 name += r"^{%s}" % exp
875 
876             return name % ",".join(args)
877 
878     def _print_UndefinedFunction(self, expr):
879         return self._hprint_Function(str(expr))
880 
881     def _print_ElementwiseApplyFunction(self, expr):
882         return r"{%s}_{\circ}\left({%s}\right)" % (
883             self._print(expr.function),
884             self._print(expr.expr),
885         )
886 
887     @property
888     def _special_function_classes(self):
889         from sympy.functions.special.tensor_functions import KroneckerDelta
890         from sympy.functions.special.gamma_functions import gamma, lowergamma
891         from sympy.functions.special.beta_functions import beta
892         from sympy.functions.special.delta_functions import DiracDelta
893         from sympy.functions.special.error_functions import Chi
894         return {KroneckerDelta: r'\delta',
895                 gamma:  r'\Gamma',
896                 lowergamma: r'\gamma',
897                 beta: r'\operatorname{B}',
898                 DiracDelta: r'\delta',
899                 Chi: r'\operatorname{Chi}'}
900 
901     def _print_FunctionClass(self, expr):
902         for cls in self._special_function_classes:
903             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
904                 return self._special_function_classes[cls]
905         return self._hprint_Function(str(expr))
906 
907     def _print_Lambda(self, expr):
908         symbols, expr = expr.args
909 
910         if len(symbols) == 1:
911             symbols = self._print(symbols[0])
912         else:
913             symbols = self._print(tuple(symbols))
914 
915         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
916 
917         return tex
918 
919     def _hprint_variadic_function(self, expr, exp=None):
920         args = sorted(expr.args, key=default_sort_key)
921         texargs = [r"%s" % self._print(symbol) for symbol in args]
922         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()),
923                                        ", ".join(texargs))
924         if exp is not None:
925             return r"%s^{%s}" % (tex, exp)
926         else:
927             return tex
928 
929     _print_Min = _print_Max = _hprint_variadic_function
930 
931     def _print_floor(self, expr, exp=None):
932         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
933 
934         if exp is not None:
935             return r"%s^{%s}" % (tex, exp)
936         else:
937             return tex
938 
939     def _print_ceiling(self, expr, exp=None):
940         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
941 
942         if exp is not None:
943             return r"%s^{%s}" % (tex, exp)
944         else:
945             return tex
946 
947     def _print_log(self, expr, exp=None):
948         if not self._settings["ln_notation"]:
949             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
950         else:
951             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
952 
953         if exp is not None:
954             return r"%s^{%s}" % (tex, exp)
955         else:
956             return tex
957 
958     def _print_Abs(self, expr, exp=None):
959         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
960 
961         if exp is not None:
962             return r"%s^{%s}" % (tex, exp)
963         else:
964             return tex
965     _print_Determinant = _print_Abs
966 
967     def _print_re(self, expr, exp=None):
968         if self._settings['gothic_re_im']:
969             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
970         else:
971             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
972 
973         return self._do_exponent(tex, exp)
974 
975     def _print_im(self, expr, exp=None):
976         if self._settings['gothic_re_im']:
977             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
978         else:
979             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
980 
981         return self._do_exponent(tex, exp)
982 
983     def _print_Not(self, e):
984         from sympy import Equivalent, Implies
985         if isinstance(e.args[0], Equivalent):
986             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
987         if isinstance(e.args[0], Implies):
988             return self._print_Implies(e.args[0], r"\not\Rightarrow")
989         if (e.args[0].is_Boolean):
990             return r"\neg \left(%s\right)" % self._print(e.args[0])
991         else:
992             return r"\neg %s" % self._print(e.args[0])
993 
994     def _print_LogOp(self, args, char):
995         arg = args[0]
996         if arg.is_Boolean and not arg.is_Not:
997             tex = r"\left(%s\right)" % self._print(arg)
998         else:
999             tex = r"%s" % self._print(arg)
1000 
1001         for arg in args[1:]:
1002             if arg.is_Boolean and not arg.is_Not:
1003                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1004             else:
1005                 tex += r" %s %s" % (char, self._print(arg))
1006 
1007         return tex
1008 
1009     def _print_And(self, e):
1010         args = sorted(e.args, key=default_sort_key)
1011         return self._print_LogOp(args, r"\wedge")
1012 
1013     def _print_Or(self, e):
1014         args = sorted(e.args, key=default_sort_key)
1015         return self._print_LogOp(args, r"\vee")
1016 
1017     def _print_Xor(self, e):
1018         args = sorted(e.args, key=default_sort_key)
1019         return self._print_LogOp(args, r"\veebar")
1020 
1021     def _print_Implies(self, e, altchar=None):
1022         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1023 
1024     def _print_Equivalent(self, e, altchar=None):
1025         args = sorted(e.args, key=default_sort_key)
1026         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1027 
1028     def _print_conjugate(self, expr, exp=None):
1029         tex = r"\overline{%s}" % self._print(expr.args[0])
1030 
1031         if exp is not None:
1032             return r"%s^{%s}" % (tex, exp)
1033         else:
1034             return tex
1035 
1036     def _print_polar_lift(self, expr, exp=None):
1037         func = r"\operatorname{polar\_lift}"
1038         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1039 
1040         if exp is not None:
1041             return r"%s^{%s}%s" % (func, exp, arg)
1042         else:
1043             return r"%s%s" % (func, arg)
1044 
1045     def _print_ExpBase(self, expr, exp=None):
1046         # TODO should exp_polar be printed differently?
1047         #      what about exp_polar(0), exp_polar(1)?
1048         tex = r"e^{%s}" % self._print(expr.args[0])
1049         return self._do_exponent(tex, exp)
1050 
1051     def _print_elliptic_k(self, expr, exp=None):
1052         tex = r"\left(%s\right)" % self._print(expr.args[0])
1053         if exp is not None:
1054             return r"K^{%s}%s" % (exp, tex)
1055         else:
1056             return r"K%s" % tex
1057 
1058     def _print_elliptic_f(self, expr, exp=None):
1059         tex = r"\left(%s\middle| %s\right)" % \
1060             (self._print(expr.args[0]), self._print(expr.args[1]))
1061         if exp is not None:
1062             return r"F^{%s}%s" % (exp, tex)
1063         else:
1064             return r"F%s" % tex
1065 
1066     def _print_elliptic_e(self, expr, exp=None):
1067         if len(expr.args) == 2:
1068             tex = r"\left(%s\middle| %s\right)" % \
1069                 (self._print(expr.args[0]), self._print(expr.args[1]))
1070         else:
1071             tex = r"\left(%s\right)" % self._print(expr.args[0])
1072         if exp is not None:
1073             return r"E^{%s}%s" % (exp, tex)
1074         else:
1075             return r"E%s" % tex
1076 
1077     def _print_elliptic_pi(self, expr, exp=None):
1078         if len(expr.args) == 3:
1079             tex = r"\left(%s; %s\middle| %s\right)" % \
1080                 (self._print(expr.args[0]), self._print(expr.args[1]),
1081                  self._print(expr.args[2]))
1082         else:
1083             tex = r"\left(%s\middle| %s\right)" % \
1084                 (self._print(expr.args[0]), self._print(expr.args[1]))
1085         if exp is not None:
1086             return r"\Pi^{%s}%s" % (exp, tex)
1087         else:
1088             return r"\Pi%s" % tex
1089 
1090     def _print_beta(self, expr, exp=None):
1091         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1092                                         self._print(expr.args[1]))
1093 
1094         if exp is not None:
1095             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1096         else:
1097             return r"\operatorname{B}%s" % tex
1098 
1099     def _print_uppergamma(self, expr, exp=None):
1100         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1101                                         self._print(expr.args[1]))
1102 
1103         if exp is not None:
1104             return r"\Gamma^{%s}%s" % (exp, tex)
1105         else:
1106             return r"\Gamma%s" % tex
1107 
1108     def _print_lowergamma(self, expr, exp=None):
1109         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1110                                         self._print(expr.args[1]))
1111 
1112         if exp is not None:
1113             return r"\gamma^{%s}%s" % (exp, tex)
1114         else:
1115             return r"\gamma%s" % tex
1116 
1117     def _hprint_one_arg_func(self, expr, exp=None):
1118         tex = r"\left(%s\right)" % self._print(expr.args[0])
1119 
1120         if exp is not None:
1121             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1122         else:
1123             return r"%s%s" % (self._print(expr.func), tex)
1124 
1125     _print_gamma = _hprint_one_arg_func
1126 
1127     def _print_Chi(self, expr, exp=None):
1128         tex = r"\left(%s\right)" % self._print(expr.args[0])
1129 
1130         if exp is not None:
1131             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1132         else:
1133             return r"\operatorname{Chi}%s" % tex
1134 
1135     def _print_expint(self, expr, exp=None):
1136         tex = r"\left(%s\right)" % self._print(expr.args[1])
1137         nu = self._print(expr.args[0])
1138 
1139         if exp is not None:
1140             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1141         else:
1142             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1143 
1144     def _print_fresnels(self, expr, exp=None):
1145         tex = r"\left(%s\right)" % self._print(expr.args[0])
1146 
1147         if exp is not None:
1148             return r"S^{%s}%s" % (exp, tex)
1149         else:
1150             return r"S%s" % tex
1151 
1152     def _print_fresnelc(self, expr, exp=None):
1153         tex = r"\left(%s\right)" % self._print(expr.args[0])
1154 
1155         if exp is not None:
1156             return r"C^{%s}%s" % (exp, tex)
1157         else:
1158             return r"C%s" % tex
1159 
1160     def _print_subfactorial(self, expr, exp=None):
1161         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1162 
1163         if exp is not None:
1164             return r"\left(%s\right)^{%s}" % (tex, exp)
1165         else:
1166             return tex
1167 
1168     def _print_factorial(self, expr, exp=None):
1169         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1170 
1171         if exp is not None:
1172             return r"%s^{%s}" % (tex, exp)
1173         else:
1174             return tex
1175 
1176     def _print_factorial2(self, expr, exp=None):
1177         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1178 
1179         if exp is not None:
1180             return r"%s^{%s}" % (tex, exp)
1181         else:
1182             return tex
1183 
1184     def _print_binomial(self, expr, exp=None):
1185         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1186                                      self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"%s^{%s}" % (tex, exp)
1190         else:
1191             return tex
1192 
1193     def _print_RisingFactorial(self, expr, exp=None):
1194         n, k = expr.args
1195         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1196 
1197         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1198 
1199         return self._do_exponent(tex, exp)
1200 
1201     def _print_FallingFactorial(self, expr, exp=None):
1202         n, k = expr.args
1203         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1204 
1205         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1206 
1207         return self._do_exponent(tex, exp)
1208 
1209     def _hprint_BesselBase(self, expr, exp, sym):
1210         tex = r"%s" % (sym)
1211 
1212         need_exp = False
1213         if exp is not None:
1214             if tex.find('^') == -1:
1215                 tex = r"%s^{%s}" % (tex, self._print(exp))
1216             else:
1217                 need_exp = True
1218 
1219         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1220                                            self._print(expr.argument))
1221 
1222         if need_exp:
1223             tex = self._do_exponent(tex, exp)
1224         return tex
1225 
1226     def _hprint_vec(self, vec):
1227         if not vec:
1228             return ""
1229         s = ""
1230         for i in vec[:-1]:
1231             s += "%s, " % self._print(i)
1232         s += self._print(vec[-1])
1233         return s
1234 
1235     def _print_besselj(self, expr, exp=None):
1236         return self._hprint_BesselBase(expr, exp, 'J')
1237 
1238     def _print_besseli(self, expr, exp=None):
1239         return self._hprint_BesselBase(expr, exp, 'I')
1240 
1241     def _print_besselk(self, expr, exp=None):
1242         return self._hprint_BesselBase(expr, exp, 'K')
1243 
1244     def _print_bessely(self, expr, exp=None):
1245         return self._hprint_BesselBase(expr, exp, 'Y')
1246 
1247     def _print_yn(self, expr, exp=None):
1248         return self._hprint_BesselBase(expr, exp, 'y')
1249 
1250     def _print_jn(self, expr, exp=None):
1251         return self._hprint_BesselBase(expr, exp, 'j')
1252 
1253     def _print_hankel1(self, expr, exp=None):
1254         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1255 
1256     def _print_hankel2(self, expr, exp=None):
1257         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1258 
1259     def _print_hn1(self, expr, exp=None):
1260         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1261 
1262     def _print_hn2(self, expr, exp=None):
1263         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1264 
1265     def _hprint_airy(self, expr, exp=None, notation=""):
1266         tex = r"\left(%s\right)" % self._print(expr.args[0])
1267 
1268         if exp is not None:
1269             return r"%s^{%s}%s" % (notation, exp, tex)
1270         else:
1271             return r"%s%s" % (notation, tex)
1272 
1273     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1274         tex = r"\left(%s\right)" % self._print(expr.args[0])
1275 
1276         if exp is not None:
1277             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1278         else:
1279             return r"%s^\prime%s" % (notation, tex)
1280 
1281     def _print_airyai(self, expr, exp=None):
1282         return self._hprint_airy(expr, exp, 'Ai')
1283 
1284     def _print_airybi(self, expr, exp=None):
1285         return self._hprint_airy(expr, exp, 'Bi')
1286 
1287     def _print_airyaiprime(self, expr, exp=None):
1288         return self._hprint_airy_prime(expr, exp, 'Ai')
1289 
1290     def _print_airybiprime(self, expr, exp=None):
1291         return self._hprint_airy_prime(expr, exp, 'Bi')
1292 
1293     def _print_hyper(self, expr, exp=None):
1294         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1295               r"\middle| {%s} \right)}" % \
1296             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1297               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1298               self._print(expr.argument))
1299 
1300         if exp is not None:
1301             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1302         return tex
1303 
1304     def _print_meijerg(self, expr, exp=None):
1305         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1306               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1307             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1308               self._print(len(expr.bm)), self._print(len(expr.an)),
1309               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1310               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1311               self._print(expr.argument))
1312 
1313         if exp is not None:
1314             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1315         return tex
1316 
1317     def _print_dirichlet_eta(self, expr, exp=None):
1318         tex = r"\left(%s\right)" % self._print(expr.args[0])
1319         if exp is not None:
1320             return r"\eta^{%s}%s" % (self._print(exp), tex)
1321         return r"\eta%s" % tex
1322 
1323     def _print_zeta(self, expr, exp=None):
1324         if len(expr.args) == 2:
1325             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1326         else:
1327             tex = r"\left(%s\right)" % self._print(expr.args[0])
1328         if exp is not None:
1329             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1330         return r"\zeta%s" % tex
1331 
1332     def _print_stieltjes(self, expr, exp=None):
1333         if len(expr.args) == 2:
1334             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1335         else:
1336             tex = r"_{%s}" % self._print(expr.args[0])
1337         if exp is not None:
1338             return r"\gamma%s^{%s}" % (tex, self._print(exp))
1339         return r"\gamma%s" % tex
1340 
1341     def _print_lerchphi(self, expr, exp=None):
1342         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1343         if exp is None:
1344             return r"\Phi%s" % tex
1345         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1346 
1347     def _print_polylog(self, expr, exp=None):
1348         s, z = map(self._print, expr.args)
1349         tex = r"\left(%s\right)" % z
1350         if exp is None:
1351             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1352         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1353 
1354     def _print_jacobi(self, expr, exp=None):
1355         n, a, b, x = map(self._print, expr.args)
1356         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1357         if exp is not None:
1358             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1359         return tex
1360 
1361     def _print_gegenbauer(self, expr, exp=None):
1362         n, a, x = map(self._print, expr.args)
1363         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1364         if exp is not None:
1365             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1366         return tex
1367 
1368     def _print_chebyshevt(self, expr, exp=None):
1369         n, x = map(self._print, expr.args)
1370         tex = r"T_{%s}\left(%s\right)" % (n, x)
1371         if exp is not None:
1372             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1373         return tex
1374 
1375     def _print_chebyshevu(self, expr, exp=None):
1376         n, x = map(self._print, expr.args)
1377         tex = r"U_{%s}\left(%s\right)" % (n, x)
1378         if exp is not None:
1379             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1380         return tex
1381 
1382     def _print_legendre(self, expr, exp=None):
1383         n, x = map(self._print, expr.args)
1384         tex = r"P_{%s}\left(%s\right)" % (n, x)
1385         if exp is not None:
1386             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1387         return tex
1388 
1389     def _print_assoc_legendre(self, expr, exp=None):
1390         n, a, x = map(self._print, expr.args)
1391         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1392         if exp is not None:
1393             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1394         return tex
1395 
1396     def _print_hermite(self, expr, exp=None):
1397         n, x = map(self._print, expr.args)
1398         tex = r"H_{%s}\left(%s\right)" % (n, x)
1399         if exp is not None:
1400             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1401         return tex
1402 
1403     def _print_laguerre(self, expr, exp=None):
1404         n, x = map(self._print, expr.args)
1405         tex = r"L_{%s}\left(%s\right)" % (n, x)
1406         if exp is not None:
1407             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1408         return tex
1409 
1410     def _print_assoc_laguerre(self, expr, exp=None):
1411         n, a, x = map(self._print, expr.args)
1412         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1413         if exp is not None:
1414             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1415         return tex
1416 
1417     def _print_Ynm(self, expr, exp=None):
1418         n, m, theta, phi = map(self._print, expr.args)
1419         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1420         if exp is not None:
1421             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1422         return tex
1423 
1424     def _print_Znm(self, expr, exp=None):
1425         n, m, theta, phi = map(self._print, expr.args)
1426         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1427         if exp is not None:
1428             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1429         return tex
1430 
1431     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1432         a, q, z = map(self._print, args)
1433         sup = r"^{\prime}" if prime else ""
1434         exp = "" if not exp else "^{%s}" % self._print(exp)
1435         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1436 
1437     def _print_mathieuc(self, expr, exp=None):
1438         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1439 
1440     def _print_mathieus(self, expr, exp=None):
1441         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1442 
1443     def _print_mathieucprime(self, expr, exp=None):
1444         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1445 
1446     def _print_mathieusprime(self, expr, exp=None):
1447         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1448 
1449     def _print_Rational(self, expr):
1450         if expr.q != 1:
1451             sign = ""
1452             p = expr.p
1453             if expr.p < 0:
1454                 sign = "- "
1455                 p = -p
1456             if self._settings['fold_short_frac']:
1457                 return r"%s%d / %d" % (sign, p, expr.q)
1458             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1459         else:
1460             return self._print(expr.p)
1461 
1462     def _print_Order(self, expr):
1463         s = self._print(expr.expr)
1464         if expr.point and any(p != S.Zero for p in expr.point) or \
1465            len(expr.variables) > 1:
1466             s += '; '
1467             if len(expr.variables) > 1:
1468                 s += self._print(expr.variables)
1469             elif expr.variables:
1470                 s += self._print(expr.variables[0])
1471             s += r'\rightarrow '
1472             if len(expr.point) > 1:
1473                 s += self._print(expr.point)
1474             else:
1475                 s += self._print(expr.point[0])
1476         return r"O\left(%s\right)" % s
1477 
1478     def _print_Symbol(self, expr, style='plain'):
1479         if expr in self._settings['symbol_names']:
1480             return self._settings['symbol_names'][expr]
1481 
1482         result = self._deal_with_super_sub(expr.name) if \
1483             '\\' not in expr.name else expr.name
1484 
1485         if style == 'bold':
1486             result = r"\mathbf{{{}}}".format(result)
1487 
1488         return result
1489 
1490     _print_RandomSymbol = _print_Symbol
1491 
1492     def _deal_with_super_sub(self, string):
1493         if '{' in string:
1494             return string
1495 
1496         name, supers, subs = split_super_sub(string)
1497 
1498         name = translate(name)
1499         supers = [translate(sup) for sup in supers]
1500         subs = [translate(sub) for sub in subs]
1501 
1502         # glue all items together:
1503         if supers:
1504             name += "^{%s}" % " ".join(supers)
1505         if subs:
1506             name += "_{%s}" % " ".join(subs)
1507 
1508         return name
1509 
1510     def _print_Relational(self, expr):
1511         if self._settings['itex']:
1512             gt = r"\gt"
1513             lt = r"\lt"
1514         else:
1515             gt = ">"
1516             lt = "<"
1517 
1518         charmap = {
1519             "==": "=",
1520             ">": gt,
1521             "<": lt,
1522             ">=": r"\geq",
1523             "<=": r"\leq",
1524             "!=": r"\neq",
1525         }
1526 
1527         return "%s %s %s" % (self._print(expr.lhs),
1528                              charmap[expr.rel_op], self._print(expr.rhs))
1529 
1530     def _print_Piecewise(self, expr):
1531         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1532                    for e, c in expr.args[:-1]]
1533         if expr.args[-1].cond == true:
1534             ecpairs.append(r"%s & \text{otherwise}" %
1535                            self._print(expr.args[-1].expr))
1536         else:
1537             ecpairs.append(r"%s & \text{for}\: %s" %
1538                            (self._print(expr.args[-1].expr),
1539                             self._print(expr.args[-1].cond)))
1540         tex = r"\begin{cases} %s \end{cases}"
1541         return tex % r" \\".join(ecpairs)
1542 
1543     def _print_MatrixBase(self, expr):
1544         lines = []
1545 
1546         for line in range(expr.rows):  # horrible, should be 'rows'
1547             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1548 
1549         mat_str = self._settings['mat_str']
1550         if mat_str is None:
1551             if self._settings['mode'] == 'inline':
1552                 mat_str = 'smallmatrix'
1553             else:
1554                 if (expr.cols <= 10) is True:
1555                     mat_str = 'matrix'
1556                 else:
1557                     mat_str = 'array'
1558 
1559         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1560         out_str = out_str.replace('%MATSTR%', mat_str)
1561         if mat_str == 'array':
1562             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1563         if self._settings['mat_delim']:
1564             left_delim = self._settings['mat_delim']
1565             right_delim = self._delim_dict[left_delim]
1566             out_str = r'\left' + left_delim + out_str + \
1567                       r'\right' + right_delim
1568         return out_str % r"\\".join(lines)
1569     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1570                            = _print_Matrix \
1571                            = _print_MatrixBase
1572 
1573     def _print_MatrixElement(self, expr):
1574         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1575             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1576 
1577     def _print_MatrixSlice(self, expr):
1578         def latexslice(x):
1579             x = list(x)
1580             if x[2] == 1:
1581                 del x[2]
1582             if x[1] == x[0] + 1:
1583                 del x[1]
1584             if x[0] == 0:
1585                 x[0] = ''
1586             return ':'.join(map(self._print, x))
1587         return (self._print(expr.parent) + r'\left[' +
1588                 latexslice(expr.rowslice) + ', ' +
1589                 latexslice(expr.colslice) + r'\right]')
1590 
1591     def _print_BlockMatrix(self, expr):
1592         return self._print(expr.blocks)
1593 
1594     def _print_Transpose(self, expr):
1595         mat = expr.arg
1596         from sympy.matrices import MatrixSymbol
1597         if not isinstance(mat, MatrixSymbol):
1598             return r"\left(%s\right)^{T}" % self._print(mat)
1599         else:
1600             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1601 
1602     def _print_Trace(self, expr):
1603         mat = expr.arg
1604         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1605 
1606     def _print_Adjoint(self, expr):
1607         mat = expr.arg
1608         from sympy.matrices import MatrixSymbol
1609         if not isinstance(mat, MatrixSymbol):
1610             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1611         else:
1612             return r"%s^{\dagger}" % self._print(mat)
1613 
1614     def _print_MatMul(self, expr):
1615         from sympy import MatMul, Mul
1616 
1617         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1618                                              False)
1619 
1620         args = expr.args
1621         if isinstance(args[0], Mul):
1622             args = args[0].as_ordered_factors() + list(args[1:])
1623         else:
1624             args = list(args)
1625 
1626         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1627             if args[0] == -1:
1628                 args = args[1:]
1629             else:
1630                 args[0] = -args[0]
1631             return '- ' + ' '.join(map(parens, args))
1632         else:
1633             return ' '.join(map(parens, args))
1634 
1635     def _print_Mod(self, expr, exp=None):
1636         if exp is not None:
1637             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1638                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1639                                    strict=True), self._print(expr.args[1]),
1640                  self._print(exp))
1641         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1642                                  PRECEDENCE['Mul'], strict=True),
1643                                  self._print(expr.args[1]))
1644 
1645     def _print_HadamardProduct(self, expr):
1646         args = expr.args
1647         prec = PRECEDENCE['Pow']
1648         parens = self.parenthesize
1649 
1650         return r' \circ '.join(
1651             map(lambda arg: parens(arg, prec, strict=True), args))
1652 
1653     def _print_HadamardPower(self, expr):
1654         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1655             template = r"%s^{\circ \left({%s}\right)}"
1656         else:
1657             template = r"%s^{\circ {%s}}"
1658         return self._helper_print_standard_power(expr, template)
1659 
1660     def _print_KroneckerProduct(self, expr):
1661         args = expr.args
1662         prec = PRECEDENCE['Pow']
1663         parens = self.parenthesize
1664 
1665         return r' \otimes '.join(
1666             map(lambda arg: parens(arg, prec, strict=True), args))
1667 
1668     def _print_MatPow(self, expr):
1669         base, exp = expr.base, expr.exp
1670         from sympy.matrices import MatrixSymbol
1671         if not isinstance(base, MatrixSymbol):
1672             return "\\left(%s\\right)^{%s}" % (self._print(base),
1673                                               self._print(exp))
1674         else:
1675             return "%s^{%s}" % (self._print(base), self._print(exp))
1676 
1677     def _print_MatrixSymbol(self, expr):
1678         return self._print_Symbol(expr, style=self._settings[
1679             'mat_symbol_style'])
1680 
1681     def _print_ZeroMatrix(self, Z):
1682         return r"\mathbb{0}" if self._settings[
1683             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1684 
1685     def _print_OneMatrix(self, O):
1686         return r"\mathbb{1}" if self._settings[
1687             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1688 
1689     def _print_Identity(self, I):
1690         return r"\mathbb{I}" if self._settings[
1691             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1692 
1693     def _print_PermutationMatrix(self, P):
1694         perm_str = self._print(P.args[0])
1695         return "P_{%s}" % perm_str
1696 
1697     def _print_NDimArray(self, expr):
1698 
1699         if expr.rank() == 0:
1700             return self._print(expr[()])
1701 
1702         mat_str = self._settings['mat_str']
1703         if mat_str is None:
1704             if self._settings['mode'] == 'inline':
1705                 mat_str = 'smallmatrix'
1706             else:
1707                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1708                     mat_str = 'matrix'
1709                 else:
1710                     mat_str = 'array'
1711         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1712         block_str = block_str.replace('%MATSTR%', mat_str)
1713         if self._settings['mat_delim']:
1714             left_delim = self._settings['mat_delim']
1715             right_delim = self._delim_dict[left_delim]
1716             block_str = r'\left' + left_delim + block_str + \
1717                         r'\right' + right_delim
1718 
1719         if expr.rank() == 0:
1720             return block_str % ""
1721 
1722         level_str = [[]] + [[] for i in range(expr.rank())]
1723         shape_ranges = [list(range(i)) for i in expr.shape]
1724         for outer_i in itertools.product(*shape_ranges):
1725             level_str[-1].append(self._print(expr[outer_i]))
1726             even = True
1727             for back_outer_i in range(expr.rank()-1, -1, -1):
1728                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1729                     break
1730                 if even:
1731                     level_str[back_outer_i].append(
1732                         r" & ".join(level_str[back_outer_i+1]))
1733                 else:
1734                     level_str[back_outer_i].append(
1735                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1736                     if len(level_str[back_outer_i+1]) == 1:
1737                         level_str[back_outer_i][-1] = r"\left[" + \
1738                             level_str[back_outer_i][-1] + r"\right]"
1739                 even = not even
1740                 level_str[back_outer_i+1] = []
1741 
1742         out_str = level_str[0][0]
1743 
1744         if expr.rank() % 2 == 1:
1745             out_str = block_str % out_str
1746 
1747         return out_str
1748 
1749     _print_ImmutableDenseNDimArray = _print_NDimArray
1750     _print_ImmutableSparseNDimArray = _print_NDimArray
1751     _print_MutableDenseNDimArray = _print_NDimArray
1752     _print_MutableSparseNDimArray = _print_NDimArray
1753 
1754     def _printer_tensor_indices(self, name, indices, index_map={}):
1755         out_str = self._print(name)
1756         last_valence = None
1757         prev_map = None
1758         for index in indices:
1759             new_valence = index.is_up
1760             if ((index in index_map) or prev_map) and \
1761                     last_valence == new_valence:
1762                 out_str += ","
1763             if last_valence != new_valence:
1764                 if last_valence is not None:
1765                     out_str += "}"
1766                 if index.is_up:
1767                     out_str += "{}^{"
1768                 else:
1769                     out_str += "{}_{"
1770             out_str += self._print(index.args[0])
1771             if index in index_map:
1772                 out_str += "="
1773                 out_str += self._print(index_map[index])
1774                 prev_map = True
1775             else:
1776                 prev_map = False
1777             last_valence = new_valence
1778         if last_valence is not None:
1779             out_str += "}"
1780         return out_str
1781 
1782     def _print_Tensor(self, expr):
1783         name = expr.args[0].args[0]
1784         indices = expr.get_indices()
1785         return self._printer_tensor_indices(name, indices)
1786 
1787     def _print_TensorElement(self, expr):
1788         name = expr.expr.args[0].args[0]
1789         indices = expr.expr.get_indices()
1790         index_map = expr.index_map
1791         return self._printer_tensor_indices(name, indices, index_map)
1792 
1793     def _print_TensMul(self, expr):
1794         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1795         sign, args = expr._get_args_for_traditional_printer()
1796         return sign + "".join(
1797             [self.parenthesize(arg, precedence(expr)) for arg in args]
1798         )
1799 
1800     def _print_TensAdd(self, expr):
1801         a = []
1802         args = expr.args
1803         for x in args:
1804             a.append(self.parenthesize(x, precedence(expr)))
1805         a.sort()
1806         s = ' + '.join(a)
1807         s = s.replace('+ -', '- ')
1808         return s
1809 
1810     def _print_TensorIndex(self, expr):
1811         return "{}%s{%s}" % (
1812             "^" if expr.is_up else "_",
1813             self._print(expr.args[0])
1814         )
1815 
1816     def _print_PartialDerivative(self, expr):
1817         if len(expr.variables) == 1:
1818             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1819                 self._print(expr.variables[0]),
1820                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1821             )
1822         else:
1823             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1824                 len(expr.variables),
1825                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1826                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1827             )
1828 
1829     def _print_UniversalSet(self, expr):
1830         return r"\mathbb{U}"
1831 
1832     def _print_frac(self, expr, exp=None):
1833         if exp is None:
1834             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1835         else:
1836             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1837                     self._print(expr.args[0]), self._print(exp))
1838 
1839     def _print_tuple(self, expr):
1840         if self._settings['decimal_separator'] =='comma':
1841             return r"\left( %s\right)" % \
1842                 r"; \  ".join([self._print(i) for i in expr])
1843         elif self._settings['decimal_separator'] =='period':
1844             return r"\left( %s\right)" % \
1845                 r", \  ".join([self._print(i) for i in expr])
1846         else:
1847             raise ValueError('Unknown Decimal Separator')
1848 
1849     def _print_TensorProduct(self, expr):
1850         elements = [self._print(a) for a in expr.args]
1851         return r' \otimes '.join(elements)
1852 
1853     def _print_WedgeProduct(self, expr):
1854         elements = [self._print(a) for a in expr.args]
1855         return r' \wedge '.join(elements)
1856 
1857     def _print_Tuple(self, expr):
1858         return self._print_tuple(expr)
1859 
1860     def _print_list(self, expr):
1861         if self._settings['decimal_separator'] == 'comma':
1862             return r"\left[ %s\right]" % \
1863                 r"; \  ".join([self._print(i) for i in expr])
1864         elif self._settings['decimal_separator'] == 'period':
1865             return r"\left[ %s\right]" % \
1866                 r", \  ".join([self._print(i) for i in expr])
1867         else:
1868             raise ValueError('Unknown Decimal Separator')
1869 
1870 
1871     def _print_dict(self, d):
1872         keys = sorted(d.keys(), key=default_sort_key)
1873         items = []
1874 
1875         for key in keys:
1876             val = d[key]
1877             items.append("%s : %s" % (self._print(key), self._print(val)))
1878 
1879         return r"\left\{ %s\right\}" % r", \  ".join(items)
1880 
1881     def _print_Dict(self, expr):
1882         return self._print_dict(expr)
1883 
1884     def _print_DiracDelta(self, expr, exp=None):
1885         if len(expr.args) == 1 or expr.args[1] == 0:
1886             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1887         else:
1888             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1889                 self._print(expr.args[1]), self._print(expr.args[0]))
1890         if exp:
1891             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1892         return tex
1893 
1894     def _print_SingularityFunction(self, expr):
1895         shift = self._print(expr.args[0] - expr.args[1])
1896         power = self._print(expr.args[2])
1897         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1898         return tex
1899 
1900     def _print_Heaviside(self, expr, exp=None):
1901         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1902         if exp:
1903             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1904         return tex
1905 
1906     def _print_KroneckerDelta(self, expr, exp=None):
1907         i = self._print(expr.args[0])
1908         j = self._print(expr.args[1])
1909         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1910             tex = r'\delta_{%s %s}' % (i, j)
1911         else:
1912             tex = r'\delta_{%s, %s}' % (i, j)
1913         if exp is not None:
1914             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1915         return tex
1916 
1917     def _print_LeviCivita(self, expr, exp=None):
1918         indices = map(self._print, expr.args)
1919         if all(x.is_Atom for x in expr.args):
1920             tex = r'\varepsilon_{%s}' % " ".join(indices)
1921         else:
1922             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1923         if exp:
1924             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1925         return tex
1926 
1927     def _print_RandomDomain(self, d):
1928         if hasattr(d, 'as_boolean'):
1929             return '\\text{Domain: }' + self._print(d.as_boolean())
1930         elif hasattr(d, 'set'):
1931             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1932                     self._print(d.set))
1933         elif hasattr(d, 'symbols'):
1934             return '\\text{Domain on }' + self._print(d.symbols)
1935         else:
1936             return self._print(None)
1937 
1938     def _print_FiniteSet(self, s):
1939         items = sorted(s.args, key=default_sort_key)
1940         return self._print_set(items)
1941 
1942     def _print_set(self, s):
1943         items = sorted(s, key=default_sort_key)
1944         if self._settings['decimal_separator'] == 'comma':
1945             items = "; ".join(map(self._print, items))
1946         elif self._settings['decimal_separator'] == 'period':
1947             items = ", ".join(map(self._print, items))
1948         else:
1949             raise ValueError('Unknown Decimal Separator')
1950         return r"\left\{%s\right\}" % items
1951 
1952 
1953     _print_frozenset = _print_set
1954 
1955     def _print_Range(self, s):
1956         dots = r'\ldots'
1957 
1958         if s.has(Symbol):
1959             return self._print_Basic(s)
1960 
1961         if s.start.is_infinite and s.stop.is_infinite:
1962             if s.step.is_positive:
1963                 printset = dots, -1, 0, 1, dots
1964             else:
1965                 printset = dots, 1, 0, -1, dots
1966         elif s.start.is_infinite:
1967             printset = dots, s[-1] - s.step, s[-1]
1968         elif s.stop.is_infinite:
1969             it = iter(s)
1970             printset = next(it), next(it), dots
1971         elif len(s) > 4:
1972             it = iter(s)
1973             printset = next(it), next(it), dots, s[-1]
1974         else:
1975             printset = tuple(s)
1976 
1977         return (r"\left\{" +
1978                 r", ".join(self._print(el) for el in printset) +
1979                 r"\right\}")
1980 
1981     def __print_number_polynomial(self, expr, letter, exp=None):
1982         if len(expr.args) == 2:
1983             if exp is not None:
1984                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
1985                             self._print(expr.args[0]), self._print(exp),
1986                             self._print(expr.args[1]))
1987             return r"%s_{%s}\left(%s\right)" % (letter,
1988                         self._print(expr.args[0]), self._print(expr.args[1]))
1989 
1990         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
1991         if exp is not None:
1992             tex = r"%s^{%s}" % (tex, self._print(exp))
1993         return tex
1994 
1995     def _print_bernoulli(self, expr, exp=None):
1996         return self.__print_number_polynomial(expr, "B", exp)
1997 
1998     def _print_bell(self, expr, exp=None):
1999         if len(expr.args) == 3:
2000             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2001                                 self._print(expr.args[1]))
2002             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2003                                                el in expr.args[2])
2004             if exp is not None:
2005                 tex = r"%s^{%s}%s" % (tex1, self._print(exp), tex2)
2006             else:
2007                 tex = tex1 + tex2
2008             return tex
2009         return self.__print_number_polynomial(expr, "B", exp)
2010 
2011 
2012     def _print_fibonacci(self, expr, exp=None):
2013         return self.__print_number_polynomial(expr, "F", exp)
2014 
2015     def _print_lucas(self, expr, exp=None):
2016         tex = r"L_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_tribonacci(self, expr, exp=None):
2022         return self.__print_number_polynomial(expr, "T", exp)
2023 
2024     def _print_SeqFormula(self, s):
2025         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2026             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2027                 self._print(s.formula),
2028                 self._print(s.variables[0]),
2029                 self._print(s.start),
2030                 self._print(s.stop)
2031             )
2032         if s.start is S.NegativeInfinity:
2033             stop = s.stop
2034             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
2035                         s.coeff(stop - 1), s.coeff(stop))
2036         elif s.stop is S.Infinity or s.length > 4:
2037             printset = s[:4]
2038             printset.append(r'\ldots')
2039         else:
2040             printset = tuple(s)
2041 
2042         return (r"\left[" +
2043                 r", ".join(self._print(el) for el in printset) +
2044                 r"\right]")
2045 
2046     _print_SeqPer = _print_SeqFormula
2047     _print_SeqAdd = _print_SeqFormula
2048     _print_SeqMul = _print_SeqFormula
2049 
2050     def _print_Interval(self, i):
2051         if i.start == i.end:
2052             return r"\left\{%s\right\}" % self._print(i.start)
2053 
2054         else:
2055             if i.left_open:
2056                 left = '('
2057             else:
2058                 left = '['
2059 
2060             if i.right_open:
2061                 right = ')'
2062             else:
2063                 right = ']'
2064 
2065             return r"\left%s%s, %s\right%s" % \
2066                    (left, self._print(i.start), self._print(i.end), right)
2067 
2068     def _print_AccumulationBounds(self, i):
2069         return r"\left\langle %s, %s\right\rangle" % \
2070                 (self._print(i.min), self._print(i.max))
2071 
2072     def _print_Union(self, u):
2073         prec = precedence_traditional(u)
2074         args_str = [self.parenthesize(i, prec) for i in u.args]
2075         return r" \cup ".join(args_str)
2076 
2077     def _print_Complement(self, u):
2078         prec = precedence_traditional(u)
2079         args_str = [self.parenthesize(i, prec) for i in u.args]
2080         return r" \setminus ".join(args_str)
2081 
2082     def _print_Intersection(self, u):
2083         prec = precedence_traditional(u)
2084         args_str = [self.parenthesize(i, prec) for i in u.args]
2085         return r" \cap ".join(args_str)
2086 
2087     def _print_SymmetricDifference(self, u):
2088         prec = precedence_traditional(u)
2089         args_str = [self.parenthesize(i, prec) for i in u.args]
2090         return r" \triangle ".join(args_str)
2091 
2092     def _print_ProductSet(self, p):
2093         prec = precedence_traditional(p)
2094         if len(p.sets) >= 1 and not has_variety(p.sets):
2095             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2096         return r" \times ".join(
2097             self.parenthesize(set, prec) for set in p.sets)
2098 
2099     def _print_EmptySet(self, e):
2100         return r"\emptyset"
2101 
2102     def _print_Naturals(self, n):
2103         return r"\mathbb{N}"
2104 
2105     def _print_Naturals0(self, n):
2106         return r"\mathbb{N}_0"
2107 
2108     def _print_Integers(self, i):
2109         return r"\mathbb{Z}"
2110 
2111     def _print_Rationals(self, i):
2112         return r"\mathbb{Q}"
2113 
2114     def _print_Reals(self, i):
2115         return r"\mathbb{R}"
2116 
2117     def _print_Complexes(self, i):
2118         return r"\mathbb{C}"
2119 
2120     def _print_ImageSet(self, s):
2121         expr = s.lamda.expr
2122         sig = s.lamda.signature
2123         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2124         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2125         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2126 
2127     def _print_ConditionSet(self, s):
2128         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2129         if s.base_set is S.UniversalSet:
2130             return r"\left\{%s \mid %s \right\}" % \
2131                 (vars_print, self._print(s.condition))
2132 
2133         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2134             vars_print,
2135             vars_print,
2136             self._print(s.base_set),
2137             self._print(s.condition))
2138 
2139     def _print_ComplexRegion(self, s):
2140         vars_print = ', '.join([self._print(var) for var in s.variables])
2141         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2142             self._print(s.expr),
2143             vars_print,
2144             self._print(s.sets))
2145 
2146     def _print_Contains(self, e):
2147         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2148 
2149     def _print_FourierSeries(self, s):
2150         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
2151 
2152     def _print_FormalPowerSeries(self, s):
2153         return self._print_Add(s.infinite)
2154 
2155     def _print_FiniteField(self, expr):
2156         return r"\mathbb{F}_{%s}" % expr.mod
2157 
2158     def _print_IntegerRing(self, expr):
2159         return r"\mathbb{Z}"
2160 
2161     def _print_RationalField(self, expr):
2162         return r"\mathbb{Q}"
2163 
2164     def _print_RealField(self, expr):
2165         return r"\mathbb{R}"
2166 
2167     def _print_ComplexField(self, expr):
2168         return r"\mathbb{C}"
2169 
2170     def _print_PolynomialRing(self, expr):
2171         domain = self._print(expr.domain)
2172         symbols = ", ".join(map(self._print, expr.symbols))
2173         return r"%s\left[%s\right]" % (domain, symbols)
2174 
2175     def _print_FractionField(self, expr):
2176         domain = self._print(expr.domain)
2177         symbols = ", ".join(map(self._print, expr.symbols))
2178         return r"%s\left(%s\right)" % (domain, symbols)
2179 
2180     def _print_PolynomialRingBase(self, expr):
2181         domain = self._print(expr.domain)
2182         symbols = ", ".join(map(self._print, expr.symbols))
2183         inv = ""
2184         if not expr.is_Poly:
2185             inv = r"S_<^{-1}"
2186         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2187 
2188     def _print_Poly(self, poly):
2189         cls = poly.__class__.__name__
2190         terms = []
2191         for monom, coeff in poly.terms():
2192             s_monom = ''
2193             for i, exp in enumerate(monom):
2194                 if exp > 0:
2195                     if exp == 1:
2196                         s_monom += self._print(poly.gens[i])
2197                     else:
2198                         s_monom += self._print(pow(poly.gens[i], exp))
2199 
2200             if coeff.is_Add:
2201                 if s_monom:
2202                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2203                 else:
2204                     s_coeff = self._print(coeff)
2205             else:
2206                 if s_monom:
2207                     if coeff is S.One:
2208                         terms.extend(['+', s_monom])
2209                         continue
2210 
2211                     if coeff is S.NegativeOne:
2212                         terms.extend(['-', s_monom])
2213                         continue
2214 
2215                 s_coeff = self._print(coeff)
2216 
2217             if not s_monom:
2218                 s_term = s_coeff
2219             else:
2220                 s_term = s_coeff + " " + s_monom
2221 
2222             if s_term.startswith('-'):
2223                 terms.extend(['-', s_term[1:]])
2224             else:
2225                 terms.extend(['+', s_term])
2226 
2227         if terms[0] in ['-', '+']:
2228             modifier = terms.pop(0)
2229 
2230             if modifier == '-':
2231                 terms[0] = '-' + terms[0]
2232 
2233         expr = ' '.join(terms)
2234         gens = list(map(self._print, poly.gens))
2235         domain = "domain=%s" % self._print(poly.get_domain())
2236 
2237         args = ", ".join([expr] + gens + [domain])
2238         if cls in accepted_latex_functions:
2239             tex = r"\%s {\left(%s \right)}" % (cls, args)
2240         else:
2241             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2242 
2243         return tex
2244 
2245     def _print_ComplexRootOf(self, root):
2246         cls = root.__class__.__name__
2247         if cls == "ComplexRootOf":
2248             cls = "CRootOf"
2249         expr = self._print(root.expr)
2250         index = root.index
2251         if cls in accepted_latex_functions:
2252             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2253         else:
2254             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2255                                                                  index)
2256 
2257     def _print_RootSum(self, expr):
2258         cls = expr.__class__.__name__
2259         args = [self._print(expr.expr)]
2260 
2261         if expr.fun is not S.IdentityFunction:
2262             args.append(self._print(expr.fun))
2263 
2264         if cls in accepted_latex_functions:
2265             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2266         else:
2267             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2268                                                              ", ".join(args))
2269 
2270     def _print_PolyElement(self, poly):
2271         mul_symbol = self._settings['mul_symbol_latex']
2272         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2273 
2274     def _print_FracElement(self, frac):
2275         if frac.denom == 1:
2276             return self._print(frac.numer)
2277         else:
2278             numer = self._print(frac.numer)
2279             denom = self._print(frac.denom)
2280             return r"\frac{%s}{%s}" % (numer, denom)
2281 
2282     def _print_euler(self, expr, exp=None):
2283         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2284         tex = r"E_{%s}" % self._print(m)
2285         if exp is not None:
2286             tex = r"%s^{%s}" % (tex, self._print(exp))
2287         if x is not None:
2288             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2289         return tex
2290 
2291     def _print_catalan(self, expr, exp=None):
2292         tex = r"C_{%s}" % self._print(expr.args[0])
2293         if exp is not None:
2294             tex = r"%s^{%s}" % (tex, self._print(exp))
2295         return tex
2296 
2297     def _print_UnifiedTransform(self, expr, s, inverse=False):
2298         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2299 
2300     def _print_MellinTransform(self, expr):
2301         return self._print_UnifiedTransform(expr, 'M')
2302 
2303     def _print_InverseMellinTransform(self, expr):
2304         return self._print_UnifiedTransform(expr, 'M', True)
2305 
2306     def _print_LaplaceTransform(self, expr):
2307         return self._print_UnifiedTransform(expr, 'L')
2308 
2309     def _print_InverseLaplaceTransform(self, expr):
2310         return self._print_UnifiedTransform(expr, 'L', True)
2311 
2312     def _print_FourierTransform(self, expr):
2313         return self._print_UnifiedTransform(expr, 'F')
2314 
2315     def _print_InverseFourierTransform(self, expr):
2316         return self._print_UnifiedTransform(expr, 'F', True)
2317 
2318     def _print_SineTransform(self, expr):
2319         return self._print_UnifiedTransform(expr, 'SIN')
2320 
2321     def _print_InverseSineTransform(self, expr):
2322         return self._print_UnifiedTransform(expr, 'SIN', True)
2323 
2324     def _print_CosineTransform(self, expr):
2325         return self._print_UnifiedTransform(expr, 'COS')
2326 
2327     def _print_InverseCosineTransform(self, expr):
2328         return self._print_UnifiedTransform(expr, 'COS', True)
2329 
2330     def _print_DMP(self, p):
2331         try:
2332             if p.ring is not None:
2333                 # TODO incorporate order
2334                 return self._print(p.ring.to_sympy(p))
2335         except SympifyError:
2336             pass
2337         return self._print(repr(p))
2338 
2339     def _print_DMF(self, p):
2340         return self._print_DMP(p)
2341 
2342     def _print_Object(self, object):
2343         return self._print(Symbol(object.name))
2344 
2345     def _print_LambertW(self, expr):
2346         if len(expr.args) == 1:
2347             return r"W\left(%s\right)" % self._print(expr.args[0])
2348         return r"W_{%s}\left(%s\right)" % \
2349             (self._print(expr.args[1]), self._print(expr.args[0]))
2350 
2351     def _print_Morphism(self, morphism):
2352         domain = self._print(morphism.domain)
2353         codomain = self._print(morphism.codomain)
2354         return "%s\\rightarrow %s" % (domain, codomain)
2355 
2356     def _print_NamedMorphism(self, morphism):
2357         pretty_name = self._print(Symbol(morphism.name))
2358         pretty_morphism = self._print_Morphism(morphism)
2359         return "%s:%s" % (pretty_name, pretty_morphism)
2360 
2361     def _print_IdentityMorphism(self, morphism):
2362         from sympy.categories import NamedMorphism
2363         return self._print_NamedMorphism(NamedMorphism(
2364             morphism.domain, morphism.codomain, "id"))
2365 
2366     def _print_CompositeMorphism(self, morphism):
2367         # All components of the morphism have names and it is thus
2368         # possible to build the name of the composite.
2369         component_names_list = [self._print(Symbol(component.name)) for
2370                                 component in morphism.components]
2371         component_names_list.reverse()
2372         component_names = "\\circ ".join(component_names_list) + ":"
2373 
2374         pretty_morphism = self._print_Morphism(morphism)
2375         return component_names + pretty_morphism
2376 
2377     def _print_Category(self, morphism):
2378         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2379 
2380     def _print_Diagram(self, diagram):
2381         if not diagram.premises:
2382             # This is an empty diagram.
2383             return self._print(S.EmptySet)
2384 
2385         latex_result = self._print(diagram.premises)
2386         if diagram.conclusions:
2387             latex_result += "\\Longrightarrow %s" % \
2388                             self._print(diagram.conclusions)
2389 
2390         return latex_result
2391 
2392     def _print_DiagramGrid(self, grid):
2393         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2394 
2395         for i in range(grid.height):
2396             for j in range(grid.width):
2397                 if grid[i, j]:
2398                     latex_result += latex(grid[i, j])
2399                 latex_result += " "
2400                 if j != grid.width - 1:
2401                     latex_result += "& "
2402 
2403             if i != grid.height - 1:
2404                 latex_result += "\\\\"
2405             latex_result += "\n"
2406 
2407         latex_result += "\\end{array}\n"
2408         return latex_result
2409 
2410     def _print_FreeModule(self, M):
2411         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2412 
2413     def _print_FreeModuleElement(self, m):
2414         # Print as row vector for convenience, for now.
2415         return r"\left[ {} \right]".format(",".join(
2416             '{' + self._print(x) + '}' for x in m))
2417 
2418     def _print_SubModule(self, m):
2419         return r"\left\langle {} \right\rangle".format(",".join(
2420             '{' + self._print(x) + '}' for x in m.gens))
2421 
2422     def _print_ModuleImplementedIdeal(self, m):
2423         return r"\left\langle {} \right\rangle".format(",".join(
2424             '{' + self._print(x) + '}' for [x] in m._module.gens))
2425 
2426     def _print_Quaternion(self, expr):
2427         # TODO: This expression is potentially confusing,
2428         # shall we print it as `Quaternion( ... )`?
2429         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2430              for i in expr.args]
2431         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2432         return " + ".join(a)
2433 
2434     def _print_QuotientRing(self, R):
2435         # TODO nicer fractions for few generators...
2436         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2437                  self._print(R.base_ideal))
2438 
2439     def _print_QuotientRingElement(self, x):
2440         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2441                  self._print(x.ring.base_ideal))
2442 
2443     def _print_QuotientModuleElement(self, m):
2444         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2445                  self._print(m.module.killed_module))
2446 
2447     def _print_QuotientModule(self, M):
2448         # TODO nicer fractions for few generators...
2449         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2450                  self._print(M.killed_module))
2451 
2452     def _print_MatrixHomomorphism(self, h):
2453         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2454             self._print(h.domain), self._print(h.codomain))
2455 
2456     def _print_BaseScalarField(self, field):
2457         string = field._coord_sys._names[field._index]
2458         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2459 
2460     def _print_BaseVectorField(self, field):
2461         string = field._coord_sys._names[field._index]
2462         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2463 
2464     def _print_Differential(self, diff):
2465         field = diff._form_field
2466         if hasattr(field, '_coord_sys'):
2467             string = field._coord_sys._names[field._index]
2468             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2469         else:
2470             string = self._print(field)
2471             return r'\operatorname{{d}}\left({}\right)'.format(string)
2472 
2473     def _print_Tr(self, p):
2474         # TODO: Handle indices
2475         contents = self._print(p.args[0])
2476         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2477 
2478     def _print_totient(self, expr, exp=None):
2479         if exp is not None:
2480             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2481                 (self._print(expr.args[0]), self._print(exp))
2482         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2483 
2484     def _print_reduced_totient(self, expr, exp=None):
2485         if exp is not None:
2486             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2487                 (self._print(expr.args[0]), self._print(exp))
2488         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2489 
2490     def _print_divisor_sigma(self, expr, exp=None):
2491         if len(expr.args) == 2:
2492             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2493                                                 (expr.args[1], expr.args[0])))
2494         else:
2495             tex = r"\left(%s\right)" % self._print(expr.args[0])
2496         if exp is not None:
2497             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2498         return r"\sigma%s" % tex
2499 
2500     def _print_udivisor_sigma(self, expr, exp=None):
2501         if len(expr.args) == 2:
2502             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2503                                                 (expr.args[1], expr.args[0])))
2504         else:
2505             tex = r"\left(%s\right)" % self._print(expr.args[0])
2506         if exp is not None:
2507             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2508         return r"\sigma^*%s" % tex
2509 
2510     def _print_primenu(self, expr, exp=None):
2511         if exp is not None:
2512             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2513                 (self._print(expr.args[0]), self._print(exp))
2514         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2515 
2516     def _print_primeomega(self, expr, exp=None):
2517         if exp is not None:
2518             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2519                 (self._print(expr.args[0]), self._print(exp))
2520         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 20:32:24.540 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 20:32:24.540 | INFO     | Search-only: skipping patch selection
2025-10-18 20:32:24.613 | INFO     | Task sympy__sympy-18477 completed successfully.
2025-10-18 20:32:24.614 | INFO     | No patch generated. You can try running ACR again.
