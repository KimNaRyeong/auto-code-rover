2025-10-18 17:10:05.642 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 17:10:08.048 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1452, output_tokens=13, cost=0.014910
2025-10-18 17:10:20.893 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1632, output_tokens=512, cost=0.031680
2025-10-18 17:10:22.140 | INFO     | registered non reproducing test 0
2025-10-18 17:10:33.237 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2972, output_tokens=535, cost=0.045770
2025-10-18 17:10:34.294 | INFO     | registered non reproducing test 1
2025-10-18 17:10:50.749 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3041, output_tokens=759, cost=0.053180
2025-10-18 17:10:51.798 | INFO     | registered non reproducing test 2
2025-10-18 17:10:51.798 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 17:10:51.803 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 17:11:02.663 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1465, output_tokens=442, cost=0.027910
2025-10-18 17:11:02.672 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 17:11:04.887 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=796, output_tokens=57, cost=0.009670
2025-10-18 17:11:04.888 | DEBUG    | Extracted a valid json.
2025-10-18 17:11:04.889 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"pairwise_distances\")",
        "search_code(\"euclidean_distances\")",
        "search_code(\"X_norm_squared\")",
        "search_code(\"swap X and Y\")"
    ],
    "bug_locations": []
}
2025-10-18 17:11:04.993 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 17:11:04.993 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 17:11:26.183 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3979, output_tokens=977, cost=0.069100
2025-10-18 17:11:26.200 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 17:11:38.312 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5172, output_tokens=466, cost=0.065700
2025-10-18 17:11:38.316 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 17:11:48.374 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=820, output_tokens=463, cost=0.022090
2025-10-18 17:11:48.375 | DEBUG    | Extracted a valid json.
2025-10-18 17:11:48.381 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sklearn/metrics/pairwise.py",
            "class": "",
            "method": "pairwise_distances",
            "intended_behavior": "The intended behavior for resolving the issue with `pairwise_distances` involves ensuring numerical precision is preserved for `float32` arrays throughout the computation, especially when using the \"euclidean\" metric. Precisely, when computing distances between arrays of type `float32`, the function should carefully manage the conversion (if necessary) to `float64` to avoid precision loss, or better yet, optimize the calculation to preserve `float32` precision without unnecessary type conversions. This could involve conditionally enabling such optimizations based on the dtype of the input arrays and the available memory for computations, thus preserving existing functionality while improving numerical precision for `float32`. The patch should also ensure that any block-wise operations or use of `X_norm_squared` for optimizations are correctly applied to maintain precision across types."
        },
        {
            "file": "sklearn/metrics/pairwise.py",
            "class": "",
            "method": "",
            "intended_behavior": "Although a specific method wasn't identified due to lack of precise match in the search results, the changes should conceptually address optimizations around memory usage and block-wise operations as mentioned in the issue. This includes ensuring that any blocks cast to `float64` for the purpose of improving precision do not inadvertently cause mismatches or precision loss when the original data was in `float32`. Implementing or refining a mechanism to dynamically calculate the optimal block size based on the input data type and available memory, ensuring symmetry in distance computations (i.e., between `X` and `Y`), and accurately copying results between blocks could achieve this. This might involve reviewing and potentially revising the logic that handles these aspects, ensuring that enhancements for handling `float32` do not compromise performance or accuracy for other types. Adjustments or additional logic may need to be integrated to ensure that the handling of `X_norm_squared` and potential `Y_norm_squared` during these operations aligns with the goal of precise and efficient distance computations for all supported data types, including `float32`."
        }
    ]
}
2025-10-18 17:11:48.393 | DEBUG    | Bug location extracted successfully: [<file>sklearn/metrics/pairwise.py</file>
<class>None</class>
<method>pairwise_distances</method>
<code>
1363 def pairwise_distances(X, Y=None, metric="euclidean", n_jobs=None, **kwds):
1364     """ Compute the distance matrix from a vector array X and optional Y.
1365 
1366     This method takes either a vector array or a distance matrix, and returns
1367     a distance matrix. If the input is a vector array, the distances are
1368     computed. If the input is a distances matrix, it is returned instead.
1369 
1370     This method provides a safe way to take a distance matrix as input, while
1371     preserving compatibility with many other algorithms that take a vector
1372     array.
1373 
1374     If Y is given (default is None), then the returned matrix is the pairwise
1375     distance between the arrays from both X and Y.
1376 
1377     Valid values for metric are:
1378 
1379     - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
1380       'manhattan']. These metrics support sparse matrix inputs.
1381 
1382     - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
1383       'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',
1384       'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
1385       'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']
1386       See the documentation for scipy.spatial.distance for details on these
1387       metrics. These metrics do not support sparse matrix inputs.
1388 
1389     Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are
1390     valid scipy.spatial.distance metrics), the scikit-learn implementation
1391     will be used, which is faster and has support for sparse matrices (except
1392     for 'cityblock'). For a verbose description of the metrics from
1393     scikit-learn, see the __doc__ of the sklearn.pairwise.distance_metrics
1394     function.
1395 
1396     Read more in the :ref:`User Guide <metrics>`.
1397 
1398     Parameters
1399     ----------
1400     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or, \
1401              [n_samples_a, n_features] otherwise
1402         Array of pairwise distances between samples, or a feature array.
1403 
1404     Y : array [n_samples_b, n_features], optional
1405         An optional second feature array. Only allowed if
1406         metric != "precomputed".
1407 
1408     metric : string, or callable
1409         The metric to use when calculating distance between instances in a
1410         feature array. If metric is a string, it must be one of the options
1411         allowed by scipy.spatial.distance.pdist for its metric parameter, or
1412         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
1413         If metric is "precomputed", X is assumed to be a distance matrix.
1414         Alternatively, if metric is a callable function, it is called on each
1415         pair of instances (rows) and the resulting value recorded. The callable
1416         should take two arrays from X as input and return a value indicating
1417         the distance between them.
1418 
1419     n_jobs : int or None, optional (default=None)
1420         The number of jobs to use for the computation. This works by breaking
1421         down the pairwise matrix into n_jobs even slices and computing them in
1422         parallel.
1423 
1424         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1425         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1426         for more details.
1427 
1428     **kwds : optional keyword parameters
1429         Any further parameters are passed directly to the distance function.
1430         If using a scipy.spatial.distance metric, the parameters are still
1431         metric dependent. See the scipy docs for usage examples.
1432 
1433     Returns
1434     -------
1435     D : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
1436         A distance matrix D such that D_{i, j} is the distance between the
1437         ith and jth vectors of the given matrix X, if Y is None.
1438         If Y is not None, then D_{i, j} is the distance between the ith array
1439         from X and the jth array from Y.
1440 
1441     See also
1442     --------
1443     pairwise_distances_chunked : performs the same calculation as this
1444         function, but returns a generator of chunks of the distance matrix, in
1445         order to limit memory usage.
1446     paired_distances : Computes the distances between corresponding
1447                        elements of two arrays
1448     """
1449     if (metric not in _VALID_METRICS and
1450             not callable(metric) and metric != "precomputed"):
1451         raise ValueError("Unknown metric %s. "
1452                          "Valid metrics are %s, or 'precomputed', or a "
1453                          "callable" % (metric, _VALID_METRICS))
1454 
1455     if metric == "precomputed":
1456         X, _ = check_pairwise_arrays(X, Y, precomputed=True)
1457 
1458         whom = ("`pairwise_distances`. Precomputed distance "
1459                 " need to have non-negative values.")
1460         check_non_negative(X, whom=whom)
1461         return X
1462     elif metric in PAIRWISE_DISTANCE_FUNCTIONS:
1463         func = PAIRWISE_DISTANCE_FUNCTIONS[metric]
1464     elif callable(metric):
1465         func = partial(_pairwise_callable, metric=metric, **kwds)
1466     else:
1467         if issparse(X) or issparse(Y):
1468             raise TypeError("scipy distance metrics do not"
1469                             " support sparse matrices.")
1470 
1471         dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None
1472 
1473         if dtype == bool and (X.dtype != bool or Y.dtype != bool):
1474             msg = "Data was converted to boolean for metric %s" % metric
1475             warnings.warn(msg, DataConversionWarning)
1476 
1477         X, Y = check_pairwise_arrays(X, Y, dtype=dtype)
1478 
1479         # precompute data-derived metric params
1480         params = _precompute_metric_params(X, Y, metric=metric, **kwds)
1481         kwds.update(**params)
1482 
1483         if effective_n_jobs(n_jobs) == 1 and X is Y:
1484             return distance.squareform(distance.pdist(X, metric=metric,
1485                                                       **kwds))
1486         func = partial(distance.cdist, metric=metric, **kwds)
1487 
1488     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)

</code><intended_behavior>The intended behavior for resolving the issue with `pairwise_distances` involves ensuring numerical precision is preserved for `float32` arrays throughout the computation, especially when using the "euclidean" metric. Precisely, when computing distances between arrays of type `float32`, the function should carefully manage the conversion (if necessary) to `float64` to avoid precision loss, or better yet, optimize the calculation to preserve `float32` precision without unnecessary type conversions. This could involve conditionally enabling such optimizations based on the dtype of the input arrays and the available memory for computations, thus preserving existing functionality while improving numerical precision for `float32`. The patch should also ensure that any block-wise operations or use of `X_norm_squared` for optimizations are correctly applied to maintain precision across types.</intended_behavior>, <file>sklearn/metrics/pairwise.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 
3 # Authors: Alexandre Gramfort <alexandre.gramfort@inria.fr>
4 #          Mathieu Blondel <mathieu@mblondel.org>
5 #          Robert Layton <robertlayton@gmail.com>
6 #          Andreas Mueller <amueller@ais.uni-bonn.de>
7 #          Philippe Gervais <philippe.gervais@inria.fr>
8 #          Lars Buitinck
9 #          Joel Nothman <joel.nothman@gmail.com>
10 # License: BSD 3 clause
11 
12 import itertools
13 from functools import partial
14 import warnings
15 
16 import numpy as np
17 from scipy.spatial import distance
18 from scipy.sparse import csr_matrix
19 from scipy.sparse import issparse
20 
21 from ..utils.validation import _num_samples
22 from ..utils.validation import check_non_negative
23 from ..utils import check_array
24 from ..utils import gen_even_slices
25 from ..utils import gen_batches, get_chunk_n_rows
26 from ..utils.extmath import row_norms, safe_sparse_dot
27 from ..preprocessing import normalize
28 from ..utils._joblib import Parallel
29 from ..utils._joblib import delayed
30 from ..utils._joblib import effective_n_jobs
31 
32 from .pairwise_fast import _chi2_kernel_fast, _sparse_manhattan
33 from ..exceptions import DataConversionWarning
34 
35 
36 # Utility Functions
37 def _return_float_dtype(X, Y):
38     """
39     1. If dtype of X and Y is float32, then dtype float32 is returned.
40     2. Else dtype float is returned.
41     """
42     if not issparse(X) and not isinstance(X, np.ndarray):
43         X = np.asarray(X)
44 
45     if Y is None:
46         Y_dtype = X.dtype
47     elif not issparse(Y) and not isinstance(Y, np.ndarray):
48         Y = np.asarray(Y)
49         Y_dtype = Y.dtype
50     else:
51         Y_dtype = Y.dtype
52 
53     if X.dtype == Y_dtype == np.float32:
54         dtype = np.float32
55     else:
56         dtype = np.float
57 
58     return X, Y, dtype
59 
60 
61 def check_pairwise_arrays(X, Y, precomputed=False, dtype=None):
62     """ Set X and Y appropriately and checks inputs
63 
64     If Y is None, it is set as a pointer to X (i.e. not a copy).
65     If Y is given, this does not happen.
66     All distance metrics should use this function first to assert that the
67     given parameters are correct and safe to use.
68 
69     Specifically, this function first ensures that both X and Y are arrays,
70     then checks that they are at least two dimensional while ensuring that
71     their elements are floats (or dtype if provided). Finally, the function
72     checks that the size of the second dimension of the two arrays is equal, or
73     the equivalent check for a precomputed distance matrix.
74 
75     Parameters
76     ----------
77     X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
78 
79     Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
80 
81     precomputed : bool
82         True if X is to be treated as precomputed distances to the samples in
83         Y.
84 
85     dtype : string, type, list of types or None (default=None)
86         Data type required for X and Y. If None, the dtype will be an
87         appropriate float type selected by _return_float_dtype.
88 
89         .. versionadded:: 0.18
90 
91     Returns
92     -------
93     safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
94         An array equal to X, guaranteed to be a numpy array.
95 
96     safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
97         An array equal to Y if Y was not None, guaranteed to be a numpy array.
98         If Y was None, safe_Y will be a pointer to X.
99 
100     """
101     X, Y, dtype_float = _return_float_dtype(X, Y)
102 
103     estimator = 'check_pairwise_arrays'
104     if dtype is None:
105         dtype = dtype_float
106 
107     if Y is X or Y is None:
108         X = Y = check_array(X, accept_sparse='csr', dtype=dtype,
109                             estimator=estimator)
110     else:
111         X = check_array(X, accept_sparse='csr', dtype=dtype,
112                         estimator=estimator)
113         Y = check_array(Y, accept_sparse='csr', dtype=dtype,
114                         estimator=estimator)
115 
116     if precomputed:
117         if X.shape[1] != Y.shape[0]:
118             raise ValueError("Precomputed metric requires shape "
119                              "(n_queries, n_indexed). Got (%d, %d) "
120                              "for %d indexed." %
121                              (X.shape[0], X.shape[1], Y.shape[0]))
122     elif X.shape[1] != Y.shape[1]:
123         raise ValueError("Incompatible dimension for X and Y matrices: "
124                          "X.shape[1] == %d while Y.shape[1] == %d" % (
125                              X.shape[1], Y.shape[1]))
126 
127     return X, Y
128 
129 
130 def check_paired_arrays(X, Y):
131     """ Set X and Y appropriately and checks inputs for paired distances
132 
133     All paired distance metrics should use this function first to assert that
134     the given parameters are correct and safe to use.
135 
136     Specifically, this function first ensures that both X and Y are arrays,
137     then checks that they are at least two dimensional while ensuring that
138     their elements are floats. Finally, the function checks that the size
139     of the dimensions of the two arrays are equal.
140 
141     Parameters
142     ----------
143     X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
144 
145     Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
146 
147     Returns
148     -------
149     safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
150         An array equal to X, guaranteed to be a numpy array.
151 
152     safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
153         An array equal to Y if Y was not None, guaranteed to be a numpy array.
154         If Y was None, safe_Y will be a pointer to X.
155 
156     """
157     X, Y = check_pairwise_arrays(X, Y)
158     if X.shape != Y.shape:
159         raise ValueError("X and Y should be of same shape. They were "
160                          "respectively %r and %r long." % (X.shape, Y.shape))
161     return X, Y
162 
163 
164 # Pairwise distances
165 def euclidean_distances(X, Y=None, Y_norm_squared=None, squared=False,
166                         X_norm_squared=None):
167     """
168     Considering the rows of X (and Y=X) as vectors, compute the
169     distance matrix between each pair of vectors.
170 
171     For efficiency reasons, the euclidean distance between a pair of row
172     vector x and y is computed as::
173 
174         dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y))
175 
176     This formulation has two advantages over other ways of computing distances.
177     First, it is computationally efficient when dealing with sparse data.
178     Second, if one argument varies but the other remains unchanged, then
179     `dot(x, x)` and/or `dot(y, y)` can be pre-computed.
180 
181     However, this is not the most precise way of doing this computation, and
182     the distance matrix returned by this function may not be exactly
183     symmetric as required by, e.g., ``scipy.spatial.distance`` functions.
184 
185     Read more in the :ref:`User Guide <metrics>`.
186 
187     Parameters
188     ----------
189     X : {array-like, sparse matrix}, shape (n_samples_1, n_features)
190 
191     Y : {array-like, sparse matrix}, shape (n_samples_2, n_features)
192 
193     Y_norm_squared : array-like, shape (n_samples_2, ), optional
194         Pre-computed dot-products of vectors in Y (e.g.,
195         ``(Y**2).sum(axis=1)``)
196 
197     squared : boolean, optional
198         Return squared Euclidean distances.
199 
200     X_norm_squared : array-like, shape = [n_samples_1], optional
201         Pre-computed dot-products of vectors in X (e.g.,
202         ``(X**2).sum(axis=1)``)
203 
204     Returns
205     -------
206     distances : {array, sparse matrix}, shape (n_samples_1, n_samples_2)
207 
208     Examples
209     --------
210     >>> from sklearn.metrics.pairwise import euclidean_distances
211     >>> X = [[0, 1], [1, 1]]
212     >>> # distance between rows of X
213     >>> euclidean_distances(X, X)
214     array([[0., 1.],
215            [1., 0.]])
216     >>> # get distance to origin
217     >>> euclidean_distances(X, [[0, 0]])
218     array([[1.        ],
219            [1.41421356]])
220 
221     See also
222     --------
223     paired_distances : distances betweens pairs of elements of X and Y.
224     """
225     X, Y = check_pairwise_arrays(X, Y)
226 
227     if X_norm_squared is not None:
228         XX = check_array(X_norm_squared)
229         if XX.shape == (1, X.shape[0]):
230             XX = XX.T
231         elif XX.shape != (X.shape[0], 1):
232             raise ValueError(
233                 "Incompatible dimensions for X and X_norm_squared")
234     else:
235         XX = row_norms(X, squared=True)[:, np.newaxis]
236 
237     if X is Y:  # shortcut in the common case euclidean_distances(X, X)
238         YY = XX.T
239     elif Y_norm_squared is not None:
240         YY = np.atleast_2d(Y_norm_squared)
241 
242         if YY.shape != (1, Y.shape[0]):
243             raise ValueError(
244                 "Incompatible dimensions for Y and Y_norm_squared")
245     else:
246         YY = row_norms(Y, squared=True)[np.newaxis, :]
247 
248     distances = safe_sparse_dot(X, Y.T, dense_output=True)
249     distances *= -2
250     distances += XX
251     distances += YY
252     np.maximum(distances, 0, out=distances)
253 
254     if X is Y:
255         # Ensure that distances between vectors and themselves are set to 0.0.
256         # This may not be the case due to floating point rounding errors.
257         distances.flat[::distances.shape[0] + 1] = 0.0
258 
259     return distances if squared else np.sqrt(distances, out=distances)
260 
261 
262 def _argmin_min_reduce(dist, start):
263     indices = dist.argmin(axis=1)
264     values = dist[np.arange(dist.shape[0]), indices]
265     return indices, values
266 
267 
268 def pairwise_distances_argmin_min(X, Y, axis=1, metric="euclidean",
269                                   batch_size=None, metric_kwargs=None):
270     """Compute minimum distances between one point and a set of points.
271 
272     This function computes for each row in X, the index of the row of Y which
273     is closest (according to the specified distance). The minimal distances are
274     also returned.
275 
276     This is mostly equivalent to calling:
277 
278         (pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis),
279          pairwise_distances(X, Y=Y, metric=metric).min(axis=axis))
280 
281     but uses much less memory, and is faster for large arrays.
282 
283     Parameters
284     ----------
285     X : {array-like, sparse matrix}, shape (n_samples1, n_features)
286         Array containing points.
287 
288     Y : {array-like, sparse matrix}, shape (n_samples2, n_features)
289         Arrays containing points.
290 
291     axis : int, optional, default 1
292         Axis along which the argmin and distances are to be computed.
293 
294     metric : string or callable, default 'euclidean'
295         metric to use for distance computation. Any metric from scikit-learn
296         or scipy.spatial.distance can be used.
297 
298         If metric is a callable function, it is called on each
299         pair of instances (rows) and the resulting value recorded. The callable
300         should take two arrays as input and return one value indicating the
301         distance between them. This works for Scipy's metrics, but is less
302         efficient than passing the metric name as a string.
303 
304         Distance matrices are not supported.
305 
306         Valid values for metric are:
307 
308         - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
309           'manhattan']
310 
311         - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
312           'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
313           'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
314           'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
315           'yule']
316 
317         See the documentation for scipy.spatial.distance for details on these
318         metrics.
319 
320     batch_size : integer
321         .. deprecated:: 0.20
322             Deprecated for removal in 0.22.
323             Use sklearn.set_config(working_memory=...) instead.
324 
325     metric_kwargs : dict, optional
326         Keyword arguments to pass to specified metric function.
327 
328     Returns
329     -------
330     argmin : numpy.ndarray
331         Y[argmin[i], :] is the row in Y that is closest to X[i, :].
332 
333     distances : numpy.ndarray
334         distances[i] is the distance between the i-th row in X and the
335         argmin[i]-th row in Y.
336 
337     See also
338     --------
339     sklearn.metrics.pairwise_distances
340     sklearn.metrics.pairwise_distances_argmin
341     """
342     if batch_size is not None:
343         warnings.warn("'batch_size' is ignored. It was deprecated in version "
344                       "0.20 and will be removed in version 0.22. "
345                       "Use sklearn.set_config(working_memory=...) instead.",
346                       DeprecationWarning)
347     X, Y = check_pairwise_arrays(X, Y)
348 
349     if metric_kwargs is None:
350         metric_kwargs = {}
351 
352     if axis == 0:
353         X, Y = Y, X
354 
355     indices, values = zip(*pairwise_distances_chunked(
356         X, Y, reduce_func=_argmin_min_reduce, metric=metric,
357         **metric_kwargs))
358     indices = np.concatenate(indices)
359     values = np.concatenate(values)
360 
361     return indices, values
362 
363 
364 def pairwise_distances_argmin(X, Y, axis=1, metric="euclidean",
365                               batch_size=None, metric_kwargs=None):
366     """Compute minimum distances between one point and a set of points.
367 
368     This function computes for each row in X, the index of the row of Y which
369     is closest (according to the specified distance).
370 
371     This is mostly equivalent to calling:
372 
373         pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis)
374 
375     but uses much less memory, and is faster for large arrays.
376 
377     This function works with dense 2D arrays only.
378 
379     Parameters
380     ----------
381     X : array-like
382         Arrays containing points. Respective shapes (n_samples1, n_features)
383         and (n_samples2, n_features)
384 
385     Y : array-like
386         Arrays containing points. Respective shapes (n_samples1, n_features)
387         and (n_samples2, n_features)
388 
389     axis : int, optional, default 1
390         Axis along which the argmin and distances are to be computed.
391 
392     metric : string or callable
393         metric to use for distance computation. Any metric from scikit-learn
394         or scipy.spatial.distance can be used.
395 
396         If metric is a callable function, it is called on each
397         pair of instances (rows) and the resulting value recorded. The callable
398         should take two arrays as input and return one value indicating the
399         distance between them. This works for Scipy's metrics, but is less
400         efficient than passing the metric name as a string.
401 
402         Distance matrices are not supported.
403 
404         Valid values for metric are:
405 
406         - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
407           'manhattan']
408 
409         - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
410           'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
411           'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
412           'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
413           'yule']
414 
415         See the documentation for scipy.spatial.distance for details on these
416         metrics.
417 
418     batch_size : integer
419         .. deprecated:: 0.20
420             Deprecated for removal in 0.22.
421             Use sklearn.set_config(working_memory=...) instead.
422 
423     metric_kwargs : dict
424         keyword arguments to pass to specified metric function.
425 
426     Returns
427     -------
428     argmin : numpy.ndarray
429         Y[argmin[i], :] is the row in Y that is closest to X[i, :].
430 
431     See also
432     --------
433     sklearn.metrics.pairwise_distances
434     sklearn.metrics.pairwise_distances_argmin_min
435     """
436     if metric_kwargs is None:
437         metric_kwargs = {}
438 
439     return pairwise_distances_argmin_min(X, Y, axis, metric,
440                                          metric_kwargs=metric_kwargs,
441                                          batch_size=batch_size)[0]
442 
443 
444 def haversine_distances(X, Y=None):
445     """Compute the Haversine distance between samples in X and Y
446 
447     The Haversine (or great circle) distance is the angular distance between
448     two points on the surface of a sphere. The first distance of each point is
449     assumed to be the latitude, the second is the longitude, given in radians.
450     The dimension of the data must be 2.
451 
452     .. math::
453        D(x, y) = 2\arcsin[\\sqrt{\\sin^2((x1 - y1) / 2)
454                                 + cos(x1)cos(y1)sin^2((x2 - y2) / 2)}]
455 
456     Parameters
457     ----------
458     X : array_like, shape (n_samples_1, 2)
459 
460     Y : array_like, shape (n_samples_2, 2), optional
461 
462     Returns
463     -------
464     distance : {array}, shape (n_samples_1, n_samples_2)
465 
466     Notes
467     -----
468     As the Earth is nearly spherical, the haversine formula provides a good
469     approximation of the distance between two points of the Earth surface, with
470     a less than 1% error on average.
471 
472     Examples
473     --------
474     We want to calculate the distance between the Ezeiza Airport
475     (Buenos Aires, Argentina) and the Charles de Gaulle Airport (Paris, France)
476 
477     >>> from sklearn.metrics.pairwise import haversine_distances
478     >>> bsas = [-34.83333, -58.5166646]
479     >>> paris = [49.0083899664, 2.53844117956]
480     >>> result = haversine_distances([bsas, paris])
481     >>> result * 6371000/1000  # multiply by Earth radius to get kilometers
482     array([[    0.        , 11279.45379464],
483            [11279.45379464,     0.        ]])
484     """
485     from sklearn.neighbors import DistanceMetric
486     return DistanceMetric.get_metric('haversine').pairwise(X, Y)
487 
488 
489 def manhattan_distances(X, Y=None, sum_over_features=True):
490     """ Compute the L1 distances between the vectors in X and Y.
491 
492     With sum_over_features equal to False it returns the componentwise
493     distances.
494 
495     Read more in the :ref:`User Guide <metrics>`.
496 
497     Parameters
498     ----------
499     X : array_like
500         An array with shape (n_samples_X, n_features).
501 
502     Y : array_like, optional
503         An array with shape (n_samples_Y, n_features).
504 
505     sum_over_features : bool, default=True
506         If True the function returns the pairwise distance matrix
507         else it returns the componentwise L1 pairwise-distances.
508         Not supported for sparse matrix inputs.
509 
510     Returns
511     -------
512     D : array
513         If sum_over_features is False shape is
514         (n_samples_X * n_samples_Y, n_features) and D contains the
515         componentwise L1 pairwise-distances (ie. absolute difference),
516         else shape is (n_samples_X, n_samples_Y) and D contains
517         the pairwise L1 distances.
518 
519     Examples
520     --------
521     >>> from sklearn.metrics.pairwise import manhattan_distances
522     >>> manhattan_distances([[3]], [[3]])#doctest:+ELLIPSIS
523     array([[0.]])
524     >>> manhattan_distances([[3]], [[2]])#doctest:+ELLIPSIS
525     array([[1.]])
526     >>> manhattan_distances([[2]], [[3]])#doctest:+ELLIPSIS
527     array([[1.]])
528     >>> manhattan_distances([[1, 2], [3, 4]],\
529          [[1, 2], [0, 3]])#doctest:+ELLIPSIS
530     array([[0., 2.],
531            [4., 4.]])
532     >>> import numpy as np
533     >>> X = np.ones((1, 2))
534     >>> y = np.full((2, 2), 2.)
535     >>> manhattan_distances(X, y, sum_over_features=False)#doctest:+ELLIPSIS
536     array([[1., 1.],
537            [1., 1.]])
538     """
539     X, Y = check_pairwise_arrays(X, Y)
540 
541     if issparse(X) or issparse(Y):
542         if not sum_over_features:
543             raise TypeError("sum_over_features=%r not supported"
544                             " for sparse matrices" % sum_over_features)
545 
546         X = csr_matrix(X, copy=False)
547         Y = csr_matrix(Y, copy=False)
548         D = np.zeros((X.shape[0], Y.shape[0]))
549         _sparse_manhattan(X.data, X.indices, X.indptr,
550                           Y.data, Y.indices, Y.indptr,
551                           X.shape[1], D)
552         return D
553 
554     if sum_over_features:
555         return distance.cdist(X, Y, 'cityblock')
556 
557     D = X[:, np.newaxis, :] - Y[np.newaxis, :, :]
558     D = np.abs(D, D)
559     return D.reshape((-1, X.shape[1]))
560 
561 
562 def cosine_distances(X, Y=None):
563     """Compute cosine distance between samples in X and Y.
564 
565     Cosine distance is defined as 1.0 minus the cosine similarity.
566 
567     Read more in the :ref:`User Guide <metrics>`.
568 
569     Parameters
570     ----------
571     X : array_like, sparse matrix
572         with shape (n_samples_X, n_features).
573 
574     Y : array_like, sparse matrix (optional)
575         with shape (n_samples_Y, n_features).
576 
577     Returns
578     -------
579     distance matrix : array
580         An array with shape (n_samples_X, n_samples_Y).
581 
582     See also
583     --------
584     sklearn.metrics.pairwise.cosine_similarity
585     scipy.spatial.distance.cosine : dense matrices only
586     """
587     # 1.0 - cosine_similarity(X, Y) without copy
588     S = cosine_similarity(X, Y)
589     S *= -1
590     S += 1
591     np.clip(S, 0, 2, out=S)
592     if X is Y or Y is None:
593         # Ensure that distances between vectors and themselves are set to 0.0.
594         # This may not be the case due to floating point rounding errors.
595         S[np.diag_indices_from(S)] = 0.0
596     return S
597 
598 
599 # Paired distances
600 def paired_euclidean_distances(X, Y):
601     """
602     Computes the paired euclidean distances between X and Y
603 
604     Read more in the :ref:`User Guide <metrics>`.
605 
606     Parameters
607     ----------
608     X : array-like, shape (n_samples, n_features)
609 
610     Y : array-like, shape (n_samples, n_features)
611 
612     Returns
613     -------
614     distances : ndarray (n_samples, )
615     """
616     X, Y = check_paired_arrays(X, Y)
617     return row_norms(X - Y)
618 
619 
620 def paired_manhattan_distances(X, Y):
621     """Compute the L1 distances between the vectors in X and Y.
622 
623     Read more in the :ref:`User Guide <metrics>`.
624 
625     Parameters
626     ----------
627     X : array-like, shape (n_samples, n_features)
628 
629     Y : array-like, shape (n_samples, n_features)
630 
631     Returns
632     -------
633     distances : ndarray (n_samples, )
634     """
635     X, Y = check_paired_arrays(X, Y)
636     diff = X - Y
637     if issparse(diff):
638         diff.data = np.abs(diff.data)
639         return np.squeeze(np.array(diff.sum(axis=1)))
640     else:
641         return np.abs(diff).sum(axis=-1)
642 
643 
644 def paired_cosine_distances(X, Y):
645     """
646     Computes the paired cosine distances between X and Y
647 
648     Read more in the :ref:`User Guide <metrics>`.
649 
650     Parameters
651     ----------
652     X : array-like, shape (n_samples, n_features)
653 
654     Y : array-like, shape (n_samples, n_features)
655 
656     Returns
657     -------
658     distances : ndarray, shape (n_samples, )
659 
660     Notes
661     ------
662     The cosine distance is equivalent to the half the squared
663     euclidean distance if each sample is normalized to unit norm
664     """
665     X, Y = check_paired_arrays(X, Y)
666     return .5 * row_norms(normalize(X) - normalize(Y), squared=True)
667 
668 
669 PAIRED_DISTANCES = {
670     'cosine': paired_cosine_distances,
671     'euclidean': paired_euclidean_distances,
672     'l2': paired_euclidean_distances,
673     'l1': paired_manhattan_distances,
674     'manhattan': paired_manhattan_distances,
675     'cityblock': paired_manhattan_distances}
676 
677 
678 def paired_distances(X, Y, metric="euclidean", **kwds):
679     """
680     Computes the paired distances between X and Y.
681 
682     Computes the distances between (X[0], Y[0]), (X[1], Y[1]), etc...
683 
684     Read more in the :ref:`User Guide <metrics>`.
685 
686     Parameters
687     ----------
688     X : ndarray (n_samples, n_features)
689         Array 1 for distance computation.
690 
691     Y : ndarray (n_samples, n_features)
692         Array 2 for distance computation.
693 
694     metric : string or callable
695         The metric to use when calculating distance between instances in a
696         feature array. If metric is a string, it must be one of the options
697         specified in PAIRED_DISTANCES, including "euclidean",
698         "manhattan", or "cosine".
699         Alternatively, if metric is a callable function, it is called on each
700         pair of instances (rows) and the resulting value recorded. The callable
701         should take two arrays from X as input and return a value indicating
702         the distance between them.
703 
704     Returns
705     -------
706     distances : ndarray (n_samples, )
707 
708     Examples
709     --------
710     >>> from sklearn.metrics.pairwise import paired_distances
711     >>> X = [[0, 1], [1, 1]]
712     >>> Y = [[0, 1], [2, 1]]
713     >>> paired_distances(X, Y)
714     array([0., 1.])
715 
716     See also
717     --------
718     pairwise_distances : Computes the distance between every pair of samples
719     """
720 
721     if metric in PAIRED_DISTANCES:
722         func = PAIRED_DISTANCES[metric]
723         return func(X, Y)
724     elif callable(metric):
725         # Check the matrix first (it is usually done by the metric)
726         X, Y = check_paired_arrays(X, Y)
727         distances = np.zeros(len(X))
728         for i in range(len(X)):
729             distances[i] = metric(X[i], Y[i])
730         return distances
731     else:
732         raise ValueError('Unknown distance %s' % metric)
733 
734 
735 # Kernels
736 def linear_kernel(X, Y=None, dense_output=True):
737     """
738     Compute the linear kernel between X and Y.
739 
740     Read more in the :ref:`User Guide <linear_kernel>`.
741 
742     Parameters
743     ----------
744     X : array of shape (n_samples_1, n_features)
745 
746     Y : array of shape (n_samples_2, n_features)
747 
748     dense_output : boolean (optional), default True
749         Whether to return dense output even when the input is sparse. If
750         ``False``, the output is sparse if both input arrays are sparse.
751 
752         .. versionadded:: 0.20
753 
754     Returns
755     -------
756     Gram matrix : array of shape (n_samples_1, n_samples_2)
757     """
758     X, Y = check_pairwise_arrays(X, Y)
759     return safe_sparse_dot(X, Y.T, dense_output=dense_output)
760 
761 
762 def polynomial_kernel(X, Y=None, degree=3, gamma=None, coef0=1):
763     """
764     Compute the polynomial kernel between X and Y::
765 
766         K(X, Y) = (gamma <X, Y> + coef0)^degree
767 
768     Read more in the :ref:`User Guide <polynomial_kernel>`.
769 
770     Parameters
771     ----------
772     X : ndarray of shape (n_samples_1, n_features)
773 
774     Y : ndarray of shape (n_samples_2, n_features)
775 
776     degree : int, default 3
777 
778     gamma : float, default None
779         if None, defaults to 1.0 / n_features
780 
781     coef0 : float, default 1
782 
783     Returns
784     -------
785     Gram matrix : array of shape (n_samples_1, n_samples_2)
786     """
787     X, Y = check_pairwise_arrays(X, Y)
788     if gamma is None:
789         gamma = 1.0 / X.shape[1]
790 
791     K = safe_sparse_dot(X, Y.T, dense_output=True)
792     K *= gamma
793     K += coef0
794     K **= degree
795     return K
796 
797 
798 def sigmoid_kernel(X, Y=None, gamma=None, coef0=1):
799     """
800     Compute the sigmoid kernel between X and Y::
801 
802         K(X, Y) = tanh(gamma <X, Y> + coef0)
803 
804     Read more in the :ref:`User Guide <sigmoid_kernel>`.
805 
806     Parameters
807     ----------
808     X : ndarray of shape (n_samples_1, n_features)
809 
810     Y : ndarray of shape (n_samples_2, n_features)
811 
812     gamma : float, default None
813         If None, defaults to 1.0 / n_features
814 
815     coef0 : float, default 1
816 
817     Returns
818     -------
819     Gram matrix : array of shape (n_samples_1, n_samples_2)
820     """
821     X, Y = check_pairwise_arrays(X, Y)
822     if gamma is None:
823         gamma = 1.0 / X.shape[1]
824 
825     K = safe_sparse_dot(X, Y.T, dense_output=True)
826     K *= gamma
827     K += coef0
828     np.tanh(K, K)   # compute tanh in-place
829     return K
830 
831 
832 def rbf_kernel(X, Y=None, gamma=None):
833     """
834     Compute the rbf (gaussian) kernel between X and Y::
835 
836         K(x, y) = exp(-gamma ||x-y||^2)
837 
838     for each pair of rows x in X and y in Y.
839 
840     Read more in the :ref:`User Guide <rbf_kernel>`.
841 
842     Parameters
843     ----------
844     X : array of shape (n_samples_X, n_features)
845 
846     Y : array of shape (n_samples_Y, n_features)
847 
848     gamma : float, default None
849         If None, defaults to 1.0 / n_features
850 
851     Returns
852     -------
853     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
854     """
855     X, Y = check_pairwise_arrays(X, Y)
856     if gamma is None:
857         gamma = 1.0 / X.shape[1]
858 
859     K = euclidean_distances(X, Y, squared=True)
860     K *= -gamma
861     np.exp(K, K)    # exponentiate K in-place
862     return K
863 
864 
865 def laplacian_kernel(X, Y=None, gamma=None):
866     """Compute the laplacian kernel between X and Y.
867 
868     The laplacian kernel is defined as::
869 
870         K(x, y) = exp(-gamma ||x-y||_1)
871 
872     for each pair of rows x in X and y in Y.
873     Read more in the :ref:`User Guide <laplacian_kernel>`.
874 
875     .. versionadded:: 0.17
876 
877     Parameters
878     ----------
879     X : array of shape (n_samples_X, n_features)
880 
881     Y : array of shape (n_samples_Y, n_features)
882 
883     gamma : float, default None
884         If None, defaults to 1.0 / n_features
885 
886     Returns
887     -------
888     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
889     """
890     X, Y = check_pairwise_arrays(X, Y)
891     if gamma is None:
892         gamma = 1.0 / X.shape[1]
893 
894     K = -gamma * manhattan_distances(X, Y)
895     np.exp(K, K)    # exponentiate K in-place
896     return K
897 
898 
899 def cosine_similarity(X, Y=None, dense_output=True):
900     """Compute cosine similarity between samples in X and Y.
901 
902     Cosine similarity, or the cosine kernel, computes similarity as the
903     normalized dot product of X and Y:
904 
905         K(X, Y) = <X, Y> / (||X||*||Y||)
906 
907     On L2-normalized data, this function is equivalent to linear_kernel.
908 
909     Read more in the :ref:`User Guide <cosine_similarity>`.
910 
911     Parameters
912     ----------
913     X : ndarray or sparse array, shape: (n_samples_X, n_features)
914         Input data.
915 
916     Y : ndarray or sparse array, shape: (n_samples_Y, n_features)
917         Input data. If ``None``, the output will be the pairwise
918         similarities between all samples in ``X``.
919 
920     dense_output : boolean (optional), default True
921         Whether to return dense output even when the input is sparse. If
922         ``False``, the output is sparse if both input arrays are sparse.
923 
924         .. versionadded:: 0.17
925            parameter ``dense_output`` for dense output.
926 
927     Returns
928     -------
929     kernel matrix : array
930         An array with shape (n_samples_X, n_samples_Y).
931     """
932     # to avoid recursive import
933 
934     X, Y = check_pairwise_arrays(X, Y)
935 
936     X_normalized = normalize(X, copy=True)
937     if X is Y:
938         Y_normalized = X_normalized
939     else:
940         Y_normalized = normalize(Y, copy=True)
941 
942     K = safe_sparse_dot(X_normalized, Y_normalized.T,
943                         dense_output=dense_output)
944 
945     return K
946 
947 
948 def additive_chi2_kernel(X, Y=None):
949     """Computes the additive chi-squared kernel between observations in X and Y
950 
951     The chi-squared kernel is computed between each pair of rows in X and Y.  X
952     and Y have to be non-negative. This kernel is most commonly applied to
953     histograms.
954 
955     The chi-squared kernel is given by::
956 
957         k(x, y) = -Sum [(x - y)^2 / (x + y)]
958 
959     It can be interpreted as a weighted difference per entry.
960 
961     Read more in the :ref:`User Guide <chi2_kernel>`.
962 
963     Notes
964     -----
965     As the negative of a distance, this kernel is only conditionally positive
966     definite.
967 
968 
969     Parameters
970     ----------
971     X : array-like of shape (n_samples_X, n_features)
972 
973     Y : array of shape (n_samples_Y, n_features)
974 
975     Returns
976     -------
977     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
978 
979     References
980     ----------
981     * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
982       Local features and kernels for classification of texture and object
983       categories: A comprehensive study
984       International Journal of Computer Vision 2007
985       https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf
986 
987 
988     See also
989     --------
990     chi2_kernel : The exponentiated version of the kernel, which is usually
991         preferable.
992 
993     sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
994         to this kernel.
995     """
996     if issparse(X) or issparse(Y):
997         raise ValueError("additive_chi2 does not support sparse matrices.")
998     X, Y = check_pairwise_arrays(X, Y)
999     if (X < 0).any():
1000         raise ValueError("X contains negative values.")
1001     if Y is not X and (Y < 0).any():
1002         raise ValueError("Y contains negative values.")
1003 
1004     result = np.zeros((X.shape[0], Y.shape[0]), dtype=X.dtype)
1005     _chi2_kernel_fast(X, Y, result)
1006     return result
1007 
1008 
1009 def chi2_kernel(X, Y=None, gamma=1.):
1010     """Computes the exponential chi-squared kernel X and Y.
1011 
1012     The chi-squared kernel is computed between each pair of rows in X and Y.  X
1013     and Y have to be non-negative. This kernel is most commonly applied to
1014     histograms.
1015 
1016     The chi-squared kernel is given by::
1017 
1018         k(x, y) = exp(-gamma Sum [(x - y)^2 / (x + y)])
1019 
1020     It can be interpreted as a weighted difference per entry.
1021 
1022     Read more in the :ref:`User Guide <chi2_kernel>`.
1023 
1024     Parameters
1025     ----------
1026     X : array-like of shape (n_samples_X, n_features)
1027 
1028     Y : array of shape (n_samples_Y, n_features)
1029 
1030     gamma : float, default=1.
1031         Scaling parameter of the chi2 kernel.
1032 
1033     Returns
1034     -------
1035     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
1036 
1037     References
1038     ----------
1039     * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
1040       Local features and kernels for classification of texture and object
1041       categories: A comprehensive study
1042       International Journal of Computer Vision 2007
1043       https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf
1044 
1045     See also
1046     --------
1047     additive_chi2_kernel : The additive version of this kernel
1048 
1049     sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
1050         to the additive version of this kernel.
1051     """
1052     K = additive_chi2_kernel(X, Y)
1053     K *= gamma
1054     return np.exp(K, K)
1055 
1056 
1057 # Helper functions - distance
1058 PAIRWISE_DISTANCE_FUNCTIONS = {
1059     # If updating this dictionary, update the doc in both distance_metrics()
1060     # and also in pairwise_distances()!
1061     'cityblock': manhattan_distances,
1062     'cosine': cosine_distances,
1063     'euclidean': euclidean_distances,
1064     'haversine': haversine_distances,
1065     'l2': euclidean_distances,
1066     'l1': manhattan_distances,
1067     'manhattan': manhattan_distances,
1068     'precomputed': None,  # HACK: precomputed is always allowed, never called
1069 }
1070 
1071 
1072 def distance_metrics():
1073     """Valid metrics for pairwise_distances.
1074 
1075     This function simply returns the valid pairwise distance metrics.
1076     It exists to allow for a description of the mapping for
1077     each of the valid strings.
1078 
1079     The valid distance metrics, and the function they map to, are:
1080 
1081     ============     ====================================
1082     metric           Function
1083     ============     ====================================
1084     'cityblock'      metrics.pairwise.manhattan_distances
1085     'cosine'         metrics.pairwise.cosine_distances
1086     'euclidean'      metrics.pairwise.euclidean_distances
1087     'haversine'      metrics.pairwise.haversine_distances
1088     'l1'             metrics.pairwise.manhattan_distances
1089     'l2'             metrics.pairwise.euclidean_distances
1090     'manhattan'      metrics.pairwise.manhattan_distances
1091     ============     ====================================
1092 
1093     Read more in the :ref:`User Guide <metrics>`.
1094 
1095     """
1096     return PAIRWISE_DISTANCE_FUNCTIONS
1097 
1098 
1099 def _dist_wrapper(dist_func, dist_matrix, slice_, *args, **kwargs):
1100     """Write in-place to a slice of a distance matrix"""
1101     dist_matrix[:, slice_] = dist_func(*args, **kwargs)
1102 
1103 
1104 def _parallel_pairwise(X, Y, func, n_jobs, **kwds):
1105     """Break the pairwise matrix in n_jobs even slices
1106     and compute them in parallel"""
1107 
1108     if Y is None:
1109         Y = X
1110 
1111     if effective_n_jobs(n_jobs) == 1:
1112         return func(X, Y, **kwds)
1113 
1114     # enforce a threading backend to prevent data communication overhead
1115     fd = delayed(_dist_wrapper)
1116     ret = np.empty((X.shape[0], Y.shape[0]), dtype=X.dtype, order='F')
1117     Parallel(backend="threading", n_jobs=n_jobs)(
1118         fd(func, ret, s, X, Y[s], **kwds)
1119         for s in gen_even_slices(_num_samples(Y), effective_n_jobs(n_jobs)))
1120 
1121     return ret
1122 
1123 
1124 def _pairwise_callable(X, Y, metric, **kwds):
1125     """Handle the callable case for pairwise_{distances,kernels}
1126     """
1127     X, Y = check_pairwise_arrays(X, Y)
1128 
1129     if X is Y:
1130         # Only calculate metric for upper triangle
1131         out = np.zeros((X.shape[0], Y.shape[0]), dtype='float')
1132         iterator = itertools.combinations(range(X.shape[0]), 2)
1133         for i, j in iterator:
1134             out[i, j] = metric(X[i], Y[j], **kwds)
1135 
1136         # Make symmetric
1137         # NB: out += out.T will produce incorrect results
1138         out = out + out.T
1139 
1140         # Calculate diagonal
1141         # NB: nonzero diagonals are allowed for both metrics and kernels
1142         for i in range(X.shape[0]):
1143             x = X[i]
1144             out[i, i] = metric(x, x, **kwds)
1145 
1146     else:
1147         # Calculate all cells
1148         out = np.empty((X.shape[0], Y.shape[0]), dtype='float')
1149         iterator = itertools.product(range(X.shape[0]), range(Y.shape[0]))
1150         for i, j in iterator:
1151             out[i, j] = metric(X[i], Y[j], **kwds)
1152 
1153     return out
1154 
1155 
1156 _VALID_METRICS = ['euclidean', 'l2', 'l1', 'manhattan', 'cityblock',
1157                   'braycurtis', 'canberra', 'chebyshev', 'correlation',
1158                   'cosine', 'dice', 'hamming', 'jaccard', 'kulsinski',
1159                   'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
1160                   'russellrao', 'seuclidean', 'sokalmichener',
1161                   'sokalsneath', 'sqeuclidean', 'yule', 'wminkowski',
1162                   'haversine']
1163 
1164 
1165 def _check_chunk_size(reduced, chunk_size):
1166     """Checks chunk is a sequence of expected size or a tuple of same
1167     """
1168     is_tuple = isinstance(reduced, tuple)
1169     if not is_tuple:
1170         reduced = (reduced,)
1171     if any(isinstance(r, tuple) or not hasattr(r, '__iter__')
1172            for r in reduced):
1173         raise TypeError('reduce_func returned %r. '
1174                         'Expected sequence(s) of length %d.' %
1175                         (reduced if is_tuple else reduced[0], chunk_size))
1176     if any(_num_samples(r) != chunk_size for r in reduced):
1177         actual_size = tuple(_num_samples(r) for r in reduced)
1178         raise ValueError('reduce_func returned object of length %s. '
1179                          'Expected same length as input: %d.' %
1180                          (actual_size if is_tuple else actual_size[0],
1181                           chunk_size))
1182 
1183 
1184 def _precompute_metric_params(X, Y, metric=None, **kwds):
1185     """Precompute data-derived metric parameters if not provided
1186     """
1187     if metric == "seuclidean" and 'V' not in kwds:
1188         if X is Y:
1189             V = np.var(X, axis=0, ddof=1)
1190         else:
1191             V = np.var(np.vstack([X, Y]), axis=0, ddof=1)
1192         return {'V': V}
1193     if metric == "mahalanobis" and 'VI' not in kwds:
1194         if X is Y:
1195             VI = np.linalg.inv(np.cov(X.T)).T
1196         else:
1197             VI = np.linalg.inv(np.cov(np.vstack([X, Y]).T)).T
1198         return {'VI': VI}
1199     return {}
1200 
1201 
1202 def pairwise_distances_chunked(X, Y=None, reduce_func=None,
1203                                metric='euclidean', n_jobs=None,
1204                                working_memory=None, **kwds):
1205     """Generate a distance matrix chunk by chunk with optional reduction
1206 
1207     In cases where not all of a pairwise distance matrix needs to be stored at
1208     once, this is used to calculate pairwise distances in
1209     ``working_memory``-sized chunks.  If ``reduce_func`` is given, it is run
1210     on each chunk and its return values are concatenated into lists, arrays
1211     or sparse matrices.
1212 
1213     Parameters
1214     ----------
1215     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or,
1216         [n_samples_a, n_features] otherwise
1217         Array of pairwise distances between samples, or a feature array.
1218 
1219     Y : array [n_samples_b, n_features], optional
1220         An optional second feature array. Only allowed if
1221         metric != "precomputed".
1222 
1223     reduce_func : callable, optional
1224         The function which is applied on each chunk of the distance matrix,
1225         reducing it to needed values.  ``reduce_func(D_chunk, start)``
1226         is called repeatedly, where ``D_chunk`` is a contiguous vertical
1227         slice of the pairwise distance matrix, starting at row ``start``.
1228         It should return an array, a list, or a sparse matrix of length
1229         ``D_chunk.shape[0]``, or a tuple of such objects.
1230 
1231         If None, pairwise_distances_chunked returns a generator of vertical
1232         chunks of the distance matrix.
1233 
1234     metric : string, or callable
1235         The metric to use when calculating distance between instances in a
1236         feature array. If metric is a string, it must be one of the options
1237         allowed by scipy.spatial.distance.pdist for its metric parameter, or
1238         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
1239         If metric is "precomputed", X is assumed to be a distance matrix.
1240         Alternatively, if metric is a callable function, it is called on each
1241         pair of instances (rows) and the resulting value recorded. The callable
1242         should take two arrays from X as input and return a value indicating
1243         the distance between them.
1244 
1245     n_jobs : int or None, optional (default=None)
1246         The number of jobs to use for the computation. This works by breaking
1247         down the pairwise matrix into n_jobs even slices and computing them in
1248         parallel.
1249 
1250         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1251         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1252         for more details.
1253 
1254     working_memory : int, optional
1255         The sought maximum memory for temporary distance matrix chunks.
1256         When None (default), the value of
1257         ``sklearn.get_config()['working_memory']`` is used.
1258 
1259     `**kwds` : optional keyword parameters
1260         Any further parameters are passed directly to the distance function.
1261         If using a scipy.spatial.distance metric, the parameters are still
1262         metric dependent. See the scipy docs for usage examples.
1263 
1264     Yields
1265     ------
1266     D_chunk : array or sparse matrix
1267         A contiguous slice of distance matrix, optionally processed by
1268         ``reduce_func``.
1269 
1270     Examples
1271     --------
1272     Without reduce_func:
1273 
1274     >>> import numpy as np
1275     >>> from sklearn.metrics import pairwise_distances_chunked
1276     >>> X = np.random.RandomState(0).rand(5, 3)
1277     >>> D_chunk = next(pairwise_distances_chunked(X))
1278     >>> D_chunk  # doctest: +ELLIPSIS
1279     array([[0.  ..., 0.29..., 0.41..., 0.19..., 0.57...],
1280            [0.29..., 0.  ..., 0.57..., 0.41..., 0.76...],
1281            [0.41..., 0.57..., 0.  ..., 0.44..., 0.90...],
1282            [0.19..., 0.41..., 0.44..., 0.  ..., 0.51...],
1283            [0.57..., 0.76..., 0.90..., 0.51..., 0.  ...]])
1284 
1285     Retrieve all neighbors and average distance within radius r:
1286 
1287     >>> r = .2
1288     >>> def reduce_func(D_chunk, start):
1289     ...     neigh = [np.flatnonzero(d < r) for d in D_chunk]
1290     ...     avg_dist = (D_chunk * (D_chunk < r)).mean(axis=1)
1291     ...     return neigh, avg_dist
1292     >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func)
1293     >>> neigh, avg_dist = next(gen)
1294     >>> neigh
1295     [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])]
1296     >>> avg_dist  # doctest: +ELLIPSIS
1297     array([0.039..., 0.        , 0.        , 0.039..., 0.        ])
1298 
1299     Where r is defined per sample, we need to make use of ``start``:
1300 
1301     >>> r = [.2, .4, .4, .3, .1]
1302     >>> def reduce_func(D_chunk, start):
1303     ...     neigh = [np.flatnonzero(d < r[i])
1304     ...              for i, d in enumerate(D_chunk, start)]
1305     ...     return neigh
1306     >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func))
1307     >>> neigh
1308     [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])]
1309 
1310     Force row-by-row generation by reducing ``working_memory``:
1311 
1312     >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func,
1313     ...                                  working_memory=0)
1314     >>> next(gen)
1315     [array([0, 3])]
1316     >>> next(gen)
1317     [array([0, 1])]
1318     """
1319     n_samples_X = _num_samples(X)
1320     if metric == 'precomputed':
1321         slices = (slice(0, n_samples_X),)
1322     else:
1323         if Y is None:
1324             Y = X
1325         # We get as many rows as possible within our working_memory budget to
1326         # store len(Y) distances in each row of output.
1327         #
1328         # Note:
1329         #  - this will get at least 1 row, even if 1 row of distances will
1330         #    exceed working_memory.
1331         #  - this does not account for any temporary memory usage while
1332         #    calculating distances (e.g. difference of vectors in manhattan
1333         #    distance.
1334         chunk_n_rows = get_chunk_n_rows(row_bytes=8 * _num_samples(Y),
1335                                         max_n_rows=n_samples_X,
1336                                         working_memory=working_memory)
1337         slices = gen_batches(n_samples_X, chunk_n_rows)
1338 
1339     # precompute data-derived metric params
1340     params = _precompute_metric_params(X, Y, metric=metric, **kwds)
1341     kwds.update(**params)
1342 
1343     for sl in slices:
1344         if sl.start == 0 and sl.stop == n_samples_X:
1345             X_chunk = X  # enable optimised paths for X is Y
1346         else:
1347             X_chunk = X[sl]
1348         D_chunk = pairwise_distances(X_chunk, Y, metric=metric,
1349                                      n_jobs=n_jobs, **kwds)
1350         if ((X is Y or Y is None)
1351                 and PAIRWISE_DISTANCE_FUNCTIONS.get(metric, None)
1352                 is euclidean_distances):
1353             # zeroing diagonal, taking care of aliases of "euclidean",
1354             # i.e. "l2"
1355             D_chunk.flat[sl.start::_num_samples(X) + 1] = 0
1356         if reduce_func is not None:
1357             chunk_size = D_chunk.shape[0]
1358             D_chunk = reduce_func(D_chunk, sl.start)
1359             _check_chunk_size(D_chunk, chunk_size)
1360         yield D_chunk
1361 
1362 
1363 def pairwise_distances(X, Y=None, metric="euclidean", n_jobs=None, **kwds):
1364     """ Compute the distance matrix from a vector array X and optional Y.
1365 
1366     This method takes either a vector array or a distance matrix, and returns
1367     a distance matrix. If the input is a vector array, the distances are
1368     computed. If the input is a distances matrix, it is returned instead.
1369 
1370     This method provides a safe way to take a distance matrix as input, while
1371     preserving compatibility with many other algorithms that take a vector
1372     array.
1373 
1374     If Y is given (default is None), then the returned matrix is the pairwise
1375     distance between the arrays from both X and Y.
1376 
1377     Valid values for metric are:
1378 
1379     - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
1380       'manhattan']. These metrics support sparse matrix inputs.
1381 
1382     - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
1383       'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',
1384       'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
1385       'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']
1386       See the documentation for scipy.spatial.distance for details on these
1387       metrics. These metrics do not support sparse matrix inputs.
1388 
1389     Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are
1390     valid scipy.spatial.distance metrics), the scikit-learn implementation
1391     will be used, which is faster and has support for sparse matrices (except
1392     for 'cityblock'). For a verbose description of the metrics from
1393     scikit-learn, see the __doc__ of the sklearn.pairwise.distance_metrics
1394     function.
1395 
1396     Read more in the :ref:`User Guide <metrics>`.
1397 
1398     Parameters
1399     ----------
1400     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or, \
1401              [n_samples_a, n_features] otherwise
1402         Array of pairwise distances between samples, or a feature array.
1403 
1404     Y : array [n_samples_b, n_features], optional
1405         An optional second feature array. Only allowed if
1406         metric != "precomputed".
1407 
1408     metric : string, or callable
1409         The metric to use when calculating distance between instances in a
1410         feature array. If metric is a string, it must be one of the options
1411         allowed by scipy.spatial.distance.pdist for its metric parameter, or
1412         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
1413         If metric is "precomputed", X is assumed to be a distance matrix.
1414         Alternatively, if metric is a callable function, it is called on each
1415         pair of instances (rows) and the resulting value recorded. The callable
1416         should take two arrays from X as input and return a value indicating
1417         the distance between them.
1418 
1419     n_jobs : int or None, optional (default=None)
1420         The number of jobs to use for the computation. This works by breaking
1421         down the pairwise matrix into n_jobs even slices and computing them in
1422         parallel.
1423 
1424         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1425         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1426         for more details.
1427 
1428     **kwds : optional keyword parameters
1429         Any further parameters are passed directly to the distance function.
1430         If using a scipy.spatial.distance metric, the parameters are still
1431         metric dependent. See the scipy docs for usage examples.
1432 
1433     Returns
1434     -------
1435     D : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
1436         A distance matrix D such that D_{i, j} is the distance between the
1437         ith and jth vectors of the given matrix X, if Y is None.
1438         If Y is not None, then D_{i, j} is the distance between the ith array
1439         from X and the jth array from Y.
1440 
1441     See also
1442     --------
1443     pairwise_distances_chunked : performs the same calculation as this
1444         function, but returns a generator of chunks of the distance matrix, in
1445         order to limit memory usage.
1446     paired_distances : Computes the distances between corresponding
1447                        elements of two arrays
1448     """
1449     if (metric not in _VALID_METRICS and
1450             not callable(metric) and metric != "precomputed"):
1451         raise ValueError("Unknown metric %s. "
1452                          "Valid metrics are %s, or 'precomputed', or a "
1453                          "callable" % (metric, _VALID_METRICS))
1454 
1455     if metric == "precomputed":
1456         X, _ = check_pairwise_arrays(X, Y, precomputed=True)
1457 
1458         whom = ("`pairwise_distances`. Precomputed distance "
1459                 " need to have non-negative values.")
1460         check_non_negative(X, whom=whom)
1461         return X
1462     elif metric in PAIRWISE_DISTANCE_FUNCTIONS:
1463         func = PAIRWISE_DISTANCE_FUNCTIONS[metric]
1464     elif callable(metric):
1465         func = partial(_pairwise_callable, metric=metric, **kwds)
1466     else:
1467         if issparse(X) or issparse(Y):
1468             raise TypeError("scipy distance metrics do not"
1469                             " support sparse matrices.")
1470 
1471         dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None
1472 
1473         if dtype == bool and (X.dtype != bool or Y.dtype != bool):
1474             msg = "Data was converted to boolean for metric %s" % metric
1475             warnings.warn(msg, DataConversionWarning)
1476 
1477         X, Y = check_pairwise_arrays(X, Y, dtype=dtype)
1478 
1479         # precompute data-derived metric params
1480         params = _precompute_metric_params(X, Y, metric=metric, **kwds)
1481         kwds.update(**params)
1482 
1483         if effective_n_jobs(n_jobs) == 1 and X is Y:
1484             return distance.squareform(distance.pdist(X, metric=metric,
1485                                                       **kwds))
1486         func = partial(distance.cdist, metric=metric, **kwds)
1487 
1488     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
1489 
1490 
1491 # These distances recquire boolean arrays, when using scipy.spatial.distance
1492 PAIRWISE_BOOLEAN_FUNCTIONS = [
1493     'dice',
1494     'jaccard',
1495     'kulsinski',
1496     'matching',
1497     'rogerstanimoto',
1498     'russellrao',
1499     'sokalmichener',
1500     'sokalsneath',
1501     'yule',
1502 ]
1503 
1504 
1505 # Helper functions - distance
1506 PAIRWISE_KERNEL_FUNCTIONS = {
1507     # If updating this dictionary, update the doc in both distance_metrics()
1508     # and also in pairwise_distances()!
1509     'additive_chi2': additive_chi2_kernel,
1510     'chi2': chi2_kernel,
1511     'linear': linear_kernel,
1512     'polynomial': polynomial_kernel,
1513     'poly': polynomial_kernel,
1514     'rbf': rbf_kernel,
1515     'laplacian': laplacian_kernel,
1516     'sigmoid': sigmoid_kernel,
1517     'cosine': cosine_similarity, }
1518 
1519 
1520 def kernel_metrics():
1521     """ Valid metrics for pairwise_kernels
1522 
1523     This function simply returns the valid pairwise distance metrics.
1524     It exists, however, to allow for a verbose description of the mapping for
1525     each of the valid strings.
1526 
1527     The valid distance metrics, and the function they map to, are:
1528       ===============   ========================================
1529       metric            Function
1530       ===============   ========================================
1531       'additive_chi2'   sklearn.pairwise.additive_chi2_kernel
1532       'chi2'            sklearn.pairwise.chi2_kernel
1533       'linear'          sklearn.pairwise.linear_kernel
1534       'poly'            sklearn.pairwise.polynomial_kernel
1535       'polynomial'      sklearn.pairwise.polynomial_kernel
1536       'rbf'             sklearn.pairwise.rbf_kernel
1537       'laplacian'       sklearn.pairwise.laplacian_kernel
1538       'sigmoid'         sklearn.pairwise.sigmoid_kernel
1539       'cosine'          sklearn.pairwise.cosine_similarity
1540       ===============   ========================================
1541 
1542     Read more in the :ref:`User Guide <metrics>`.
1543     """
1544     return PAIRWISE_KERNEL_FUNCTIONS
1545 
1546 
1547 KERNEL_PARAMS = {
1548     "additive_chi2": (),
1549     "chi2": frozenset(["gamma"]),
1550     "cosine": (),
1551     "linear": (),
1552     "poly": frozenset(["gamma", "degree", "coef0"]),
1553     "polynomial": frozenset(["gamma", "degree", "coef0"]),
1554     "rbf": frozenset(["gamma"]),
1555     "laplacian": frozenset(["gamma"]),
1556     "sigmoid": frozenset(["gamma", "coef0"]),
1557 }
1558 
1559 
1560 def pairwise_kernels(X, Y=None, metric="linear", filter_params=False,
1561                      n_jobs=None, **kwds):
1562     """Compute the kernel between arrays X and optional array Y.
1563 
1564     This method takes either a vector array or a kernel matrix, and returns
1565     a kernel matrix. If the input is a vector array, the kernels are
1566     computed. If the input is a kernel matrix, it is returned instead.
1567 
1568     This method provides a safe way to take a kernel matrix as input, while
1569     preserving compatibility with many other algorithms that take a vector
1570     array.
1571 
1572     If Y is given (default is None), then the returned matrix is the pairwise
1573     kernel between the arrays from both X and Y.
1574 
1575     Valid values for metric are::
1576         ['rbf', 'sigmoid', 'polynomial', 'poly', 'linear', 'cosine']
1577 
1578     Read more in the :ref:`User Guide <metrics>`.
1579 
1580     Parameters
1581     ----------
1582     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or, \
1583              [n_samples_a, n_features] otherwise
1584         Array of pairwise kernels between samples, or a feature array.
1585 
1586     Y : array [n_samples_b, n_features]
1587         A second feature array only if X has shape [n_samples_a, n_features].
1588 
1589     metric : string, or callable
1590         The metric to use when calculating kernel between instances in a
1591         feature array. If metric is a string, it must be one of the metrics
1592         in pairwise.PAIRWISE_KERNEL_FUNCTIONS.
1593         If metric is "precomputed", X is assumed to be a kernel matrix.
1594         Alternatively, if metric is a callable function, it is called on each
1595         pair of instances (rows) and the resulting value recorded. The callable
1596         should take two arrays from X as input and return a value indicating
1597         the distance between them.
1598 
1599     filter_params : boolean
1600         Whether to filter invalid parameters or not.
1601 
1602     n_jobs : int or None, optional (default=None)
1603         The number of jobs to use for the computation. This works by breaking
1604         down the pairwise matrix into n_jobs even slices and computing them in
1605         parallel.
1606 
1607         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1608         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1609         for more details.
1610 
1611     **kwds : optional keyword parameters
1612         Any further parameters are passed directly to the kernel function.
1613 
1614     Returns
1615     -------
1616     K : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
1617         A kernel matrix K such that K_{i, j} is the kernel between the
1618         ith and jth vectors of the given matrix X, if Y is None.
1619         If Y is not None, then K_{i, j} is the kernel between the ith array
1620         from X and the jth array from Y.
1621 
1622     Notes
1623     -----
1624     If metric is 'precomputed', Y is ignored and X is returned.
1625 
1626     """
1627     # import GPKernel locally to prevent circular imports
1628     from ..gaussian_process.kernels import Kernel as GPKernel
1629 
1630     if metric == "precomputed":
1631         X, _ = check_pairwise_arrays(X, Y, precomputed=True)
1632         return X
1633     elif isinstance(metric, GPKernel):
1634         func = metric.__call__
1635     elif metric in PAIRWISE_KERNEL_FUNCTIONS:
1636         if filter_params:
1637             kwds = {k: kwds[k] for k in kwds
1638                     if k in KERNEL_PARAMS[metric]}
1639         func = PAIRWISE_KERNEL_FUNCTIONS[metric]
1640     elif callable(metric):
1641         func = partial(_pairwise_callable, metric=metric, **kwds)
1642     else:
1643         raise ValueError("Unknown kernel %r" % metric)
1644 
1645     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)

</code><intended_behavior>Although a specific method wasn't identified due to lack of precise match in the search results, the changes should conceptually address optimizations around memory usage and block-wise operations as mentioned in the issue. This includes ensuring that any blocks cast to `float64` for the purpose of improving precision do not inadvertently cause mismatches or precision loss when the original data was in `float32`. Implementing or refining a mechanism to dynamically calculate the optimal block size based on the input data type and available memory, ensuring symmetry in distance computations (i.e., between `X` and `Y`), and accurately copying results between blocks could achieve this. This might involve reviewing and potentially revising the logic that handles these aspects, ensuring that enhancements for handling `float32` do not compromise performance or accuracy for other types. Adjustments or additional logic may need to be integrated to ensure that the handling of `X_norm_squared` and potential `Y_norm_squared` during these operations aligns with the goal of precise and efficient distance computations for all supported data types, including `float32`.</intended_behavior>]
2025-10-18 17:11:48.394 | INFO     | Search completed. Bug locations: [<file>sklearn/metrics/pairwise.py</file>
<class>None</class>
<method>pairwise_distances</method>
<code>
1363 def pairwise_distances(X, Y=None, metric="euclidean", n_jobs=None, **kwds):
1364     """ Compute the distance matrix from a vector array X and optional Y.
1365 
1366     This method takes either a vector array or a distance matrix, and returns
1367     a distance matrix. If the input is a vector array, the distances are
1368     computed. If the input is a distances matrix, it is returned instead.
1369 
1370     This method provides a safe way to take a distance matrix as input, while
1371     preserving compatibility with many other algorithms that take a vector
1372     array.
1373 
1374     If Y is given (default is None), then the returned matrix is the pairwise
1375     distance between the arrays from both X and Y.
1376 
1377     Valid values for metric are:
1378 
1379     - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
1380       'manhattan']. These metrics support sparse matrix inputs.
1381 
1382     - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
1383       'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',
1384       'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
1385       'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']
1386       See the documentation for scipy.spatial.distance for details on these
1387       metrics. These metrics do not support sparse matrix inputs.
1388 
1389     Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are
1390     valid scipy.spatial.distance metrics), the scikit-learn implementation
1391     will be used, which is faster and has support for sparse matrices (except
1392     for 'cityblock'). For a verbose description of the metrics from
1393     scikit-learn, see the __doc__ of the sklearn.pairwise.distance_metrics
1394     function.
1395 
1396     Read more in the :ref:`User Guide <metrics>`.
1397 
1398     Parameters
1399     ----------
1400     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or, \
1401              [n_samples_a, n_features] otherwise
1402         Array of pairwise distances between samples, or a feature array.
1403 
1404     Y : array [n_samples_b, n_features], optional
1405         An optional second feature array. Only allowed if
1406         metric != "precomputed".
1407 
1408     metric : string, or callable
1409         The metric to use when calculating distance between instances in a
1410         feature array. If metric is a string, it must be one of the options
1411         allowed by scipy.spatial.distance.pdist for its metric parameter, or
1412         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
1413         If metric is "precomputed", X is assumed to be a distance matrix.
1414         Alternatively, if metric is a callable function, it is called on each
1415         pair of instances (rows) and the resulting value recorded. The callable
1416         should take two arrays from X as input and return a value indicating
1417         the distance between them.
1418 
1419     n_jobs : int or None, optional (default=None)
1420         The number of jobs to use for the computation. This works by breaking
1421         down the pairwise matrix into n_jobs even slices and computing them in
1422         parallel.
1423 
1424         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1425         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1426         for more details.
1427 
1428     **kwds : optional keyword parameters
1429         Any further parameters are passed directly to the distance function.
1430         If using a scipy.spatial.distance metric, the parameters are still
1431         metric dependent. See the scipy docs for usage examples.
1432 
1433     Returns
1434     -------
1435     D : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
1436         A distance matrix D such that D_{i, j} is the distance between the
1437         ith and jth vectors of the given matrix X, if Y is None.
1438         If Y is not None, then D_{i, j} is the distance between the ith array
1439         from X and the jth array from Y.
1440 
1441     See also
1442     --------
1443     pairwise_distances_chunked : performs the same calculation as this
1444         function, but returns a generator of chunks of the distance matrix, in
1445         order to limit memory usage.
1446     paired_distances : Computes the distances between corresponding
1447                        elements of two arrays
1448     """
1449     if (metric not in _VALID_METRICS and
1450             not callable(metric) and metric != "precomputed"):
1451         raise ValueError("Unknown metric %s. "
1452                          "Valid metrics are %s, or 'precomputed', or a "
1453                          "callable" % (metric, _VALID_METRICS))
1454 
1455     if metric == "precomputed":
1456         X, _ = check_pairwise_arrays(X, Y, precomputed=True)
1457 
1458         whom = ("`pairwise_distances`. Precomputed distance "
1459                 " need to have non-negative values.")
1460         check_non_negative(X, whom=whom)
1461         return X
1462     elif metric in PAIRWISE_DISTANCE_FUNCTIONS:
1463         func = PAIRWISE_DISTANCE_FUNCTIONS[metric]
1464     elif callable(metric):
1465         func = partial(_pairwise_callable, metric=metric, **kwds)
1466     else:
1467         if issparse(X) or issparse(Y):
1468             raise TypeError("scipy distance metrics do not"
1469                             " support sparse matrices.")
1470 
1471         dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None
1472 
1473         if dtype == bool and (X.dtype != bool or Y.dtype != bool):
1474             msg = "Data was converted to boolean for metric %s" % metric
1475             warnings.warn(msg, DataConversionWarning)
1476 
1477         X, Y = check_pairwise_arrays(X, Y, dtype=dtype)
1478 
1479         # precompute data-derived metric params
1480         params = _precompute_metric_params(X, Y, metric=metric, **kwds)
1481         kwds.update(**params)
1482 
1483         if effective_n_jobs(n_jobs) == 1 and X is Y:
1484             return distance.squareform(distance.pdist(X, metric=metric,
1485                                                       **kwds))
1486         func = partial(distance.cdist, metric=metric, **kwds)
1487 
1488     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)

</code><intended_behavior>The intended behavior for resolving the issue with `pairwise_distances` involves ensuring numerical precision is preserved for `float32` arrays throughout the computation, especially when using the "euclidean" metric. Precisely, when computing distances between arrays of type `float32`, the function should carefully manage the conversion (if necessary) to `float64` to avoid precision loss, or better yet, optimize the calculation to preserve `float32` precision without unnecessary type conversions. This could involve conditionally enabling such optimizations based on the dtype of the input arrays and the available memory for computations, thus preserving existing functionality while improving numerical precision for `float32`. The patch should also ensure that any block-wise operations or use of `X_norm_squared` for optimizations are correctly applied to maintain precision across types.</intended_behavior>, <file>sklearn/metrics/pairwise.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 
3 # Authors: Alexandre Gramfort <alexandre.gramfort@inria.fr>
4 #          Mathieu Blondel <mathieu@mblondel.org>
5 #          Robert Layton <robertlayton@gmail.com>
6 #          Andreas Mueller <amueller@ais.uni-bonn.de>
7 #          Philippe Gervais <philippe.gervais@inria.fr>
8 #          Lars Buitinck
9 #          Joel Nothman <joel.nothman@gmail.com>
10 # License: BSD 3 clause
11 
12 import itertools
13 from functools import partial
14 import warnings
15 
16 import numpy as np
17 from scipy.spatial import distance
18 from scipy.sparse import csr_matrix
19 from scipy.sparse import issparse
20 
21 from ..utils.validation import _num_samples
22 from ..utils.validation import check_non_negative
23 from ..utils import check_array
24 from ..utils import gen_even_slices
25 from ..utils import gen_batches, get_chunk_n_rows
26 from ..utils.extmath import row_norms, safe_sparse_dot
27 from ..preprocessing import normalize
28 from ..utils._joblib import Parallel
29 from ..utils._joblib import delayed
30 from ..utils._joblib import effective_n_jobs
31 
32 from .pairwise_fast import _chi2_kernel_fast, _sparse_manhattan
33 from ..exceptions import DataConversionWarning
34 
35 
36 # Utility Functions
37 def _return_float_dtype(X, Y):
38     """
39     1. If dtype of X and Y is float32, then dtype float32 is returned.
40     2. Else dtype float is returned.
41     """
42     if not issparse(X) and not isinstance(X, np.ndarray):
43         X = np.asarray(X)
44 
45     if Y is None:
46         Y_dtype = X.dtype
47     elif not issparse(Y) and not isinstance(Y, np.ndarray):
48         Y = np.asarray(Y)
49         Y_dtype = Y.dtype
50     else:
51         Y_dtype = Y.dtype
52 
53     if X.dtype == Y_dtype == np.float32:
54         dtype = np.float32
55     else:
56         dtype = np.float
57 
58     return X, Y, dtype
59 
60 
61 def check_pairwise_arrays(X, Y, precomputed=False, dtype=None):
62     """ Set X and Y appropriately and checks inputs
63 
64     If Y is None, it is set as a pointer to X (i.e. not a copy).
65     If Y is given, this does not happen.
66     All distance metrics should use this function first to assert that the
67     given parameters are correct and safe to use.
68 
69     Specifically, this function first ensures that both X and Y are arrays,
70     then checks that they are at least two dimensional while ensuring that
71     their elements are floats (or dtype if provided). Finally, the function
72     checks that the size of the second dimension of the two arrays is equal, or
73     the equivalent check for a precomputed distance matrix.
74 
75     Parameters
76     ----------
77     X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
78 
79     Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
80 
81     precomputed : bool
82         True if X is to be treated as precomputed distances to the samples in
83         Y.
84 
85     dtype : string, type, list of types or None (default=None)
86         Data type required for X and Y. If None, the dtype will be an
87         appropriate float type selected by _return_float_dtype.
88 
89         .. versionadded:: 0.18
90 
91     Returns
92     -------
93     safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
94         An array equal to X, guaranteed to be a numpy array.
95 
96     safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
97         An array equal to Y if Y was not None, guaranteed to be a numpy array.
98         If Y was None, safe_Y will be a pointer to X.
99 
100     """
101     X, Y, dtype_float = _return_float_dtype(X, Y)
102 
103     estimator = 'check_pairwise_arrays'
104     if dtype is None:
105         dtype = dtype_float
106 
107     if Y is X or Y is None:
108         X = Y = check_array(X, accept_sparse='csr', dtype=dtype,
109                             estimator=estimator)
110     else:
111         X = check_array(X, accept_sparse='csr', dtype=dtype,
112                         estimator=estimator)
113         Y = check_array(Y, accept_sparse='csr', dtype=dtype,
114                         estimator=estimator)
115 
116     if precomputed:
117         if X.shape[1] != Y.shape[0]:
118             raise ValueError("Precomputed metric requires shape "
119                              "(n_queries, n_indexed). Got (%d, %d) "
120                              "for %d indexed." %
121                              (X.shape[0], X.shape[1], Y.shape[0]))
122     elif X.shape[1] != Y.shape[1]:
123         raise ValueError("Incompatible dimension for X and Y matrices: "
124                          "X.shape[1] == %d while Y.shape[1] == %d" % (
125                              X.shape[1], Y.shape[1]))
126 
127     return X, Y
128 
129 
130 def check_paired_arrays(X, Y):
131     """ Set X and Y appropriately and checks inputs for paired distances
132 
133     All paired distance metrics should use this function first to assert that
134     the given parameters are correct and safe to use.
135 
136     Specifically, this function first ensures that both X and Y are arrays,
137     then checks that they are at least two dimensional while ensuring that
138     their elements are floats. Finally, the function checks that the size
139     of the dimensions of the two arrays are equal.
140 
141     Parameters
142     ----------
143     X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
144 
145     Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
146 
147     Returns
148     -------
149     safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)
150         An array equal to X, guaranteed to be a numpy array.
151 
152     safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)
153         An array equal to Y if Y was not None, guaranteed to be a numpy array.
154         If Y was None, safe_Y will be a pointer to X.
155 
156     """
157     X, Y = check_pairwise_arrays(X, Y)
158     if X.shape != Y.shape:
159         raise ValueError("X and Y should be of same shape. They were "
160                          "respectively %r and %r long." % (X.shape, Y.shape))
161     return X, Y
162 
163 
164 # Pairwise distances
165 def euclidean_distances(X, Y=None, Y_norm_squared=None, squared=False,
166                         X_norm_squared=None):
167     """
168     Considering the rows of X (and Y=X) as vectors, compute the
169     distance matrix between each pair of vectors.
170 
171     For efficiency reasons, the euclidean distance between a pair of row
172     vector x and y is computed as::
173 
174         dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y))
175 
176     This formulation has two advantages over other ways of computing distances.
177     First, it is computationally efficient when dealing with sparse data.
178     Second, if one argument varies but the other remains unchanged, then
179     `dot(x, x)` and/or `dot(y, y)` can be pre-computed.
180 
181     However, this is not the most precise way of doing this computation, and
182     the distance matrix returned by this function may not be exactly
183     symmetric as required by, e.g., ``scipy.spatial.distance`` functions.
184 
185     Read more in the :ref:`User Guide <metrics>`.
186 
187     Parameters
188     ----------
189     X : {array-like, sparse matrix}, shape (n_samples_1, n_features)
190 
191     Y : {array-like, sparse matrix}, shape (n_samples_2, n_features)
192 
193     Y_norm_squared : array-like, shape (n_samples_2, ), optional
194         Pre-computed dot-products of vectors in Y (e.g.,
195         ``(Y**2).sum(axis=1)``)
196 
197     squared : boolean, optional
198         Return squared Euclidean distances.
199 
200     X_norm_squared : array-like, shape = [n_samples_1], optional
201         Pre-computed dot-products of vectors in X (e.g.,
202         ``(X**2).sum(axis=1)``)
203 
204     Returns
205     -------
206     distances : {array, sparse matrix}, shape (n_samples_1, n_samples_2)
207 
208     Examples
209     --------
210     >>> from sklearn.metrics.pairwise import euclidean_distances
211     >>> X = [[0, 1], [1, 1]]
212     >>> # distance between rows of X
213     >>> euclidean_distances(X, X)
214     array([[0., 1.],
215            [1., 0.]])
216     >>> # get distance to origin
217     >>> euclidean_distances(X, [[0, 0]])
218     array([[1.        ],
219            [1.41421356]])
220 
221     See also
222     --------
223     paired_distances : distances betweens pairs of elements of X and Y.
224     """
225     X, Y = check_pairwise_arrays(X, Y)
226 
227     if X_norm_squared is not None:
228         XX = check_array(X_norm_squared)
229         if XX.shape == (1, X.shape[0]):
230             XX = XX.T
231         elif XX.shape != (X.shape[0], 1):
232             raise ValueError(
233                 "Incompatible dimensions for X and X_norm_squared")
234     else:
235         XX = row_norms(X, squared=True)[:, np.newaxis]
236 
237     if X is Y:  # shortcut in the common case euclidean_distances(X, X)
238         YY = XX.T
239     elif Y_norm_squared is not None:
240         YY = np.atleast_2d(Y_norm_squared)
241 
242         if YY.shape != (1, Y.shape[0]):
243             raise ValueError(
244                 "Incompatible dimensions for Y and Y_norm_squared")
245     else:
246         YY = row_norms(Y, squared=True)[np.newaxis, :]
247 
248     distances = safe_sparse_dot(X, Y.T, dense_output=True)
249     distances *= -2
250     distances += XX
251     distances += YY
252     np.maximum(distances, 0, out=distances)
253 
254     if X is Y:
255         # Ensure that distances between vectors and themselves are set to 0.0.
256         # This may not be the case due to floating point rounding errors.
257         distances.flat[::distances.shape[0] + 1] = 0.0
258 
259     return distances if squared else np.sqrt(distances, out=distances)
260 
261 
262 def _argmin_min_reduce(dist, start):
263     indices = dist.argmin(axis=1)
264     values = dist[np.arange(dist.shape[0]), indices]
265     return indices, values
266 
267 
268 def pairwise_distances_argmin_min(X, Y, axis=1, metric="euclidean",
269                                   batch_size=None, metric_kwargs=None):
270     """Compute minimum distances between one point and a set of points.
271 
272     This function computes for each row in X, the index of the row of Y which
273     is closest (according to the specified distance). The minimal distances are
274     also returned.
275 
276     This is mostly equivalent to calling:
277 
278         (pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis),
279          pairwise_distances(X, Y=Y, metric=metric).min(axis=axis))
280 
281     but uses much less memory, and is faster for large arrays.
282 
283     Parameters
284     ----------
285     X : {array-like, sparse matrix}, shape (n_samples1, n_features)
286         Array containing points.
287 
288     Y : {array-like, sparse matrix}, shape (n_samples2, n_features)
289         Arrays containing points.
290 
291     axis : int, optional, default 1
292         Axis along which the argmin and distances are to be computed.
293 
294     metric : string or callable, default 'euclidean'
295         metric to use for distance computation. Any metric from scikit-learn
296         or scipy.spatial.distance can be used.
297 
298         If metric is a callable function, it is called on each
299         pair of instances (rows) and the resulting value recorded. The callable
300         should take two arrays as input and return one value indicating the
301         distance between them. This works for Scipy's metrics, but is less
302         efficient than passing the metric name as a string.
303 
304         Distance matrices are not supported.
305 
306         Valid values for metric are:
307 
308         - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
309           'manhattan']
310 
311         - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
312           'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
313           'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
314           'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
315           'yule']
316 
317         See the documentation for scipy.spatial.distance for details on these
318         metrics.
319 
320     batch_size : integer
321         .. deprecated:: 0.20
322             Deprecated for removal in 0.22.
323             Use sklearn.set_config(working_memory=...) instead.
324 
325     metric_kwargs : dict, optional
326         Keyword arguments to pass to specified metric function.
327 
328     Returns
329     -------
330     argmin : numpy.ndarray
331         Y[argmin[i], :] is the row in Y that is closest to X[i, :].
332 
333     distances : numpy.ndarray
334         distances[i] is the distance between the i-th row in X and the
335         argmin[i]-th row in Y.
336 
337     See also
338     --------
339     sklearn.metrics.pairwise_distances
340     sklearn.metrics.pairwise_distances_argmin
341     """
342     if batch_size is not None:
343         warnings.warn("'batch_size' is ignored. It was deprecated in version "
344                       "0.20 and will be removed in version 0.22. "
345                       "Use sklearn.set_config(working_memory=...) instead.",
346                       DeprecationWarning)
347     X, Y = check_pairwise_arrays(X, Y)
348 
349     if metric_kwargs is None:
350         metric_kwargs = {}
351 
352     if axis == 0:
353         X, Y = Y, X
354 
355     indices, values = zip(*pairwise_distances_chunked(
356         X, Y, reduce_func=_argmin_min_reduce, metric=metric,
357         **metric_kwargs))
358     indices = np.concatenate(indices)
359     values = np.concatenate(values)
360 
361     return indices, values
362 
363 
364 def pairwise_distances_argmin(X, Y, axis=1, metric="euclidean",
365                               batch_size=None, metric_kwargs=None):
366     """Compute minimum distances between one point and a set of points.
367 
368     This function computes for each row in X, the index of the row of Y which
369     is closest (according to the specified distance).
370 
371     This is mostly equivalent to calling:
372 
373         pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis)
374 
375     but uses much less memory, and is faster for large arrays.
376 
377     This function works with dense 2D arrays only.
378 
379     Parameters
380     ----------
381     X : array-like
382         Arrays containing points. Respective shapes (n_samples1, n_features)
383         and (n_samples2, n_features)
384 
385     Y : array-like
386         Arrays containing points. Respective shapes (n_samples1, n_features)
387         and (n_samples2, n_features)
388 
389     axis : int, optional, default 1
390         Axis along which the argmin and distances are to be computed.
391 
392     metric : string or callable
393         metric to use for distance computation. Any metric from scikit-learn
394         or scipy.spatial.distance can be used.
395 
396         If metric is a callable function, it is called on each
397         pair of instances (rows) and the resulting value recorded. The callable
398         should take two arrays as input and return one value indicating the
399         distance between them. This works for Scipy's metrics, but is less
400         efficient than passing the metric name as a string.
401 
402         Distance matrices are not supported.
403 
404         Valid values for metric are:
405 
406         - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
407           'manhattan']
408 
409         - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
410           'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',
411           'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',
412           'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',
413           'yule']
414 
415         See the documentation for scipy.spatial.distance for details on these
416         metrics.
417 
418     batch_size : integer
419         .. deprecated:: 0.20
420             Deprecated for removal in 0.22.
421             Use sklearn.set_config(working_memory=...) instead.
422 
423     metric_kwargs : dict
424         keyword arguments to pass to specified metric function.
425 
426     Returns
427     -------
428     argmin : numpy.ndarray
429         Y[argmin[i], :] is the row in Y that is closest to X[i, :].
430 
431     See also
432     --------
433     sklearn.metrics.pairwise_distances
434     sklearn.metrics.pairwise_distances_argmin_min
435     """
436     if metric_kwargs is None:
437         metric_kwargs = {}
438 
439     return pairwise_distances_argmin_min(X, Y, axis, metric,
440                                          metric_kwargs=metric_kwargs,
441                                          batch_size=batch_size)[0]
442 
443 
444 def haversine_distances(X, Y=None):
445     """Compute the Haversine distance between samples in X and Y
446 
447     The Haversine (or great circle) distance is the angular distance between
448     two points on the surface of a sphere. The first distance of each point is
449     assumed to be the latitude, the second is the longitude, given in radians.
450     The dimension of the data must be 2.
451 
452     .. math::
453        D(x, y) = 2\arcsin[\\sqrt{\\sin^2((x1 - y1) / 2)
454                                 + cos(x1)cos(y1)sin^2((x2 - y2) / 2)}]
455 
456     Parameters
457     ----------
458     X : array_like, shape (n_samples_1, 2)
459 
460     Y : array_like, shape (n_samples_2, 2), optional
461 
462     Returns
463     -------
464     distance : {array}, shape (n_samples_1, n_samples_2)
465 
466     Notes
467     -----
468     As the Earth is nearly spherical, the haversine formula provides a good
469     approximation of the distance between two points of the Earth surface, with
470     a less than 1% error on average.
471 
472     Examples
473     --------
474     We want to calculate the distance between the Ezeiza Airport
475     (Buenos Aires, Argentina) and the Charles de Gaulle Airport (Paris, France)
476 
477     >>> from sklearn.metrics.pairwise import haversine_distances
478     >>> bsas = [-34.83333, -58.5166646]
479     >>> paris = [49.0083899664, 2.53844117956]
480     >>> result = haversine_distances([bsas, paris])
481     >>> result * 6371000/1000  # multiply by Earth radius to get kilometers
482     array([[    0.        , 11279.45379464],
483            [11279.45379464,     0.        ]])
484     """
485     from sklearn.neighbors import DistanceMetric
486     return DistanceMetric.get_metric('haversine').pairwise(X, Y)
487 
488 
489 def manhattan_distances(X, Y=None, sum_over_features=True):
490     """ Compute the L1 distances between the vectors in X and Y.
491 
492     With sum_over_features equal to False it returns the componentwise
493     distances.
494 
495     Read more in the :ref:`User Guide <metrics>`.
496 
497     Parameters
498     ----------
499     X : array_like
500         An array with shape (n_samples_X, n_features).
501 
502     Y : array_like, optional
503         An array with shape (n_samples_Y, n_features).
504 
505     sum_over_features : bool, default=True
506         If True the function returns the pairwise distance matrix
507         else it returns the componentwise L1 pairwise-distances.
508         Not supported for sparse matrix inputs.
509 
510     Returns
511     -------
512     D : array
513         If sum_over_features is False shape is
514         (n_samples_X * n_samples_Y, n_features) and D contains the
515         componentwise L1 pairwise-distances (ie. absolute difference),
516         else shape is (n_samples_X, n_samples_Y) and D contains
517         the pairwise L1 distances.
518 
519     Examples
520     --------
521     >>> from sklearn.metrics.pairwise import manhattan_distances
522     >>> manhattan_distances([[3]], [[3]])#doctest:+ELLIPSIS
523     array([[0.]])
524     >>> manhattan_distances([[3]], [[2]])#doctest:+ELLIPSIS
525     array([[1.]])
526     >>> manhattan_distances([[2]], [[3]])#doctest:+ELLIPSIS
527     array([[1.]])
528     >>> manhattan_distances([[1, 2], [3, 4]],\
529          [[1, 2], [0, 3]])#doctest:+ELLIPSIS
530     array([[0., 2.],
531            [4., 4.]])
532     >>> import numpy as np
533     >>> X = np.ones((1, 2))
534     >>> y = np.full((2, 2), 2.)
535     >>> manhattan_distances(X, y, sum_over_features=False)#doctest:+ELLIPSIS
536     array([[1., 1.],
537            [1., 1.]])
538     """
539     X, Y = check_pairwise_arrays(X, Y)
540 
541     if issparse(X) or issparse(Y):
542         if not sum_over_features:
543             raise TypeError("sum_over_features=%r not supported"
544                             " for sparse matrices" % sum_over_features)
545 
546         X = csr_matrix(X, copy=False)
547         Y = csr_matrix(Y, copy=False)
548         D = np.zeros((X.shape[0], Y.shape[0]))
549         _sparse_manhattan(X.data, X.indices, X.indptr,
550                           Y.data, Y.indices, Y.indptr,
551                           X.shape[1], D)
552         return D
553 
554     if sum_over_features:
555         return distance.cdist(X, Y, 'cityblock')
556 
557     D = X[:, np.newaxis, :] - Y[np.newaxis, :, :]
558     D = np.abs(D, D)
559     return D.reshape((-1, X.shape[1]))
560 
561 
562 def cosine_distances(X, Y=None):
563     """Compute cosine distance between samples in X and Y.
564 
565     Cosine distance is defined as 1.0 minus the cosine similarity.
566 
567     Read more in the :ref:`User Guide <metrics>`.
568 
569     Parameters
570     ----------
571     X : array_like, sparse matrix
572         with shape (n_samples_X, n_features).
573 
574     Y : array_like, sparse matrix (optional)
575         with shape (n_samples_Y, n_features).
576 
577     Returns
578     -------
579     distance matrix : array
580         An array with shape (n_samples_X, n_samples_Y).
581 
582     See also
583     --------
584     sklearn.metrics.pairwise.cosine_similarity
585     scipy.spatial.distance.cosine : dense matrices only
586     """
587     # 1.0 - cosine_similarity(X, Y) without copy
588     S = cosine_similarity(X, Y)
589     S *= -1
590     S += 1
591     np.clip(S, 0, 2, out=S)
592     if X is Y or Y is None:
593         # Ensure that distances between vectors and themselves are set to 0.0.
594         # This may not be the case due to floating point rounding errors.
595         S[np.diag_indices_from(S)] = 0.0
596     return S
597 
598 
599 # Paired distances
600 def paired_euclidean_distances(X, Y):
601     """
602     Computes the paired euclidean distances between X and Y
603 
604     Read more in the :ref:`User Guide <metrics>`.
605 
606     Parameters
607     ----------
608     X : array-like, shape (n_samples, n_features)
609 
610     Y : array-like, shape (n_samples, n_features)
611 
612     Returns
613     -------
614     distances : ndarray (n_samples, )
615     """
616     X, Y = check_paired_arrays(X, Y)
617     return row_norms(X - Y)
618 
619 
620 def paired_manhattan_distances(X, Y):
621     """Compute the L1 distances between the vectors in X and Y.
622 
623     Read more in the :ref:`User Guide <metrics>`.
624 
625     Parameters
626     ----------
627     X : array-like, shape (n_samples, n_features)
628 
629     Y : array-like, shape (n_samples, n_features)
630 
631     Returns
632     -------
633     distances : ndarray (n_samples, )
634     """
635     X, Y = check_paired_arrays(X, Y)
636     diff = X - Y
637     if issparse(diff):
638         diff.data = np.abs(diff.data)
639         return np.squeeze(np.array(diff.sum(axis=1)))
640     else:
641         return np.abs(diff).sum(axis=-1)
642 
643 
644 def paired_cosine_distances(X, Y):
645     """
646     Computes the paired cosine distances between X and Y
647 
648     Read more in the :ref:`User Guide <metrics>`.
649 
650     Parameters
651     ----------
652     X : array-like, shape (n_samples, n_features)
653 
654     Y : array-like, shape (n_samples, n_features)
655 
656     Returns
657     -------
658     distances : ndarray, shape (n_samples, )
659 
660     Notes
661     ------
662     The cosine distance is equivalent to the half the squared
663     euclidean distance if each sample is normalized to unit norm
664     """
665     X, Y = check_paired_arrays(X, Y)
666     return .5 * row_norms(normalize(X) - normalize(Y), squared=True)
667 
668 
669 PAIRED_DISTANCES = {
670     'cosine': paired_cosine_distances,
671     'euclidean': paired_euclidean_distances,
672     'l2': paired_euclidean_distances,
673     'l1': paired_manhattan_distances,
674     'manhattan': paired_manhattan_distances,
675     'cityblock': paired_manhattan_distances}
676 
677 
678 def paired_distances(X, Y, metric="euclidean", **kwds):
679     """
680     Computes the paired distances between X and Y.
681 
682     Computes the distances between (X[0], Y[0]), (X[1], Y[1]), etc...
683 
684     Read more in the :ref:`User Guide <metrics>`.
685 
686     Parameters
687     ----------
688     X : ndarray (n_samples, n_features)
689         Array 1 for distance computation.
690 
691     Y : ndarray (n_samples, n_features)
692         Array 2 for distance computation.
693 
694     metric : string or callable
695         The metric to use when calculating distance between instances in a
696         feature array. If metric is a string, it must be one of the options
697         specified in PAIRED_DISTANCES, including "euclidean",
698         "manhattan", or "cosine".
699         Alternatively, if metric is a callable function, it is called on each
700         pair of instances (rows) and the resulting value recorded. The callable
701         should take two arrays from X as input and return a value indicating
702         the distance between them.
703 
704     Returns
705     -------
706     distances : ndarray (n_samples, )
707 
708     Examples
709     --------
710     >>> from sklearn.metrics.pairwise import paired_distances
711     >>> X = [[0, 1], [1, 1]]
712     >>> Y = [[0, 1], [2, 1]]
713     >>> paired_distances(X, Y)
714     array([0., 1.])
715 
716     See also
717     --------
718     pairwise_distances : Computes the distance between every pair of samples
719     """
720 
721     if metric in PAIRED_DISTANCES:
722         func = PAIRED_DISTANCES[metric]
723         return func(X, Y)
724     elif callable(metric):
725         # Check the matrix first (it is usually done by the metric)
726         X, Y = check_paired_arrays(X, Y)
727         distances = np.zeros(len(X))
728         for i in range(len(X)):
729             distances[i] = metric(X[i], Y[i])
730         return distances
731     else:
732         raise ValueError('Unknown distance %s' % metric)
733 
734 
735 # Kernels
736 def linear_kernel(X, Y=None, dense_output=True):
737     """
738     Compute the linear kernel between X and Y.
739 
740     Read more in the :ref:`User Guide <linear_kernel>`.
741 
742     Parameters
743     ----------
744     X : array of shape (n_samples_1, n_features)
745 
746     Y : array of shape (n_samples_2, n_features)
747 
748     dense_output : boolean (optional), default True
749         Whether to return dense output even when the input is sparse. If
750         ``False``, the output is sparse if both input arrays are sparse.
751 
752         .. versionadded:: 0.20
753 
754     Returns
755     -------
756     Gram matrix : array of shape (n_samples_1, n_samples_2)
757     """
758     X, Y = check_pairwise_arrays(X, Y)
759     return safe_sparse_dot(X, Y.T, dense_output=dense_output)
760 
761 
762 def polynomial_kernel(X, Y=None, degree=3, gamma=None, coef0=1):
763     """
764     Compute the polynomial kernel between X and Y::
765 
766         K(X, Y) = (gamma <X, Y> + coef0)^degree
767 
768     Read more in the :ref:`User Guide <polynomial_kernel>`.
769 
770     Parameters
771     ----------
772     X : ndarray of shape (n_samples_1, n_features)
773 
774     Y : ndarray of shape (n_samples_2, n_features)
775 
776     degree : int, default 3
777 
778     gamma : float, default None
779         if None, defaults to 1.0 / n_features
780 
781     coef0 : float, default 1
782 
783     Returns
784     -------
785     Gram matrix : array of shape (n_samples_1, n_samples_2)
786     """
787     X, Y = check_pairwise_arrays(X, Y)
788     if gamma is None:
789         gamma = 1.0 / X.shape[1]
790 
791     K = safe_sparse_dot(X, Y.T, dense_output=True)
792     K *= gamma
793     K += coef0
794     K **= degree
795     return K
796 
797 
798 def sigmoid_kernel(X, Y=None, gamma=None, coef0=1):
799     """
800     Compute the sigmoid kernel between X and Y::
801 
802         K(X, Y) = tanh(gamma <X, Y> + coef0)
803 
804     Read more in the :ref:`User Guide <sigmoid_kernel>`.
805 
806     Parameters
807     ----------
808     X : ndarray of shape (n_samples_1, n_features)
809 
810     Y : ndarray of shape (n_samples_2, n_features)
811 
812     gamma : float, default None
813         If None, defaults to 1.0 / n_features
814 
815     coef0 : float, default 1
816 
817     Returns
818     -------
819     Gram matrix : array of shape (n_samples_1, n_samples_2)
820     """
821     X, Y = check_pairwise_arrays(X, Y)
822     if gamma is None:
823         gamma = 1.0 / X.shape[1]
824 
825     K = safe_sparse_dot(X, Y.T, dense_output=True)
826     K *= gamma
827     K += coef0
828     np.tanh(K, K)   # compute tanh in-place
829     return K
830 
831 
832 def rbf_kernel(X, Y=None, gamma=None):
833     """
834     Compute the rbf (gaussian) kernel between X and Y::
835 
836         K(x, y) = exp(-gamma ||x-y||^2)
837 
838     for each pair of rows x in X and y in Y.
839 
840     Read more in the :ref:`User Guide <rbf_kernel>`.
841 
842     Parameters
843     ----------
844     X : array of shape (n_samples_X, n_features)
845 
846     Y : array of shape (n_samples_Y, n_features)
847 
848     gamma : float, default None
849         If None, defaults to 1.0 / n_features
850 
851     Returns
852     -------
853     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
854     """
855     X, Y = check_pairwise_arrays(X, Y)
856     if gamma is None:
857         gamma = 1.0 / X.shape[1]
858 
859     K = euclidean_distances(X, Y, squared=True)
860     K *= -gamma
861     np.exp(K, K)    # exponentiate K in-place
862     return K
863 
864 
865 def laplacian_kernel(X, Y=None, gamma=None):
866     """Compute the laplacian kernel between X and Y.
867 
868     The laplacian kernel is defined as::
869 
870         K(x, y) = exp(-gamma ||x-y||_1)
871 
872     for each pair of rows x in X and y in Y.
873     Read more in the :ref:`User Guide <laplacian_kernel>`.
874 
875     .. versionadded:: 0.17
876 
877     Parameters
878     ----------
879     X : array of shape (n_samples_X, n_features)
880 
881     Y : array of shape (n_samples_Y, n_features)
882 
883     gamma : float, default None
884         If None, defaults to 1.0 / n_features
885 
886     Returns
887     -------
888     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
889     """
890     X, Y = check_pairwise_arrays(X, Y)
891     if gamma is None:
892         gamma = 1.0 / X.shape[1]
893 
894     K = -gamma * manhattan_distances(X, Y)
895     np.exp(K, K)    # exponentiate K in-place
896     return K
897 
898 
899 def cosine_similarity(X, Y=None, dense_output=True):
900     """Compute cosine similarity between samples in X and Y.
901 
902     Cosine similarity, or the cosine kernel, computes similarity as the
903     normalized dot product of X and Y:
904 
905         K(X, Y) = <X, Y> / (||X||*||Y||)
906 
907     On L2-normalized data, this function is equivalent to linear_kernel.
908 
909     Read more in the :ref:`User Guide <cosine_similarity>`.
910 
911     Parameters
912     ----------
913     X : ndarray or sparse array, shape: (n_samples_X, n_features)
914         Input data.
915 
916     Y : ndarray or sparse array, shape: (n_samples_Y, n_features)
917         Input data. If ``None``, the output will be the pairwise
918         similarities between all samples in ``X``.
919 
920     dense_output : boolean (optional), default True
921         Whether to return dense output even when the input is sparse. If
922         ``False``, the output is sparse if both input arrays are sparse.
923 
924         .. versionadded:: 0.17
925            parameter ``dense_output`` for dense output.
926 
927     Returns
928     -------
929     kernel matrix : array
930         An array with shape (n_samples_X, n_samples_Y).
931     """
932     # to avoid recursive import
933 
934     X, Y = check_pairwise_arrays(X, Y)
935 
936     X_normalized = normalize(X, copy=True)
937     if X is Y:
938         Y_normalized = X_normalized
939     else:
940         Y_normalized = normalize(Y, copy=True)
941 
942     K = safe_sparse_dot(X_normalized, Y_normalized.T,
943                         dense_output=dense_output)
944 
945     return K
946 
947 
948 def additive_chi2_kernel(X, Y=None):
949     """Computes the additive chi-squared kernel between observations in X and Y
950 
951     The chi-squared kernel is computed between each pair of rows in X and Y.  X
952     and Y have to be non-negative. This kernel is most commonly applied to
953     histograms.
954 
955     The chi-squared kernel is given by::
956 
957         k(x, y) = -Sum [(x - y)^2 / (x + y)]
958 
959     It can be interpreted as a weighted difference per entry.
960 
961     Read more in the :ref:`User Guide <chi2_kernel>`.
962 
963     Notes
964     -----
965     As the negative of a distance, this kernel is only conditionally positive
966     definite.
967 
968 
969     Parameters
970     ----------
971     X : array-like of shape (n_samples_X, n_features)
972 
973     Y : array of shape (n_samples_Y, n_features)
974 
975     Returns
976     -------
977     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
978 
979     References
980     ----------
981     * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
982       Local features and kernels for classification of texture and object
983       categories: A comprehensive study
984       International Journal of Computer Vision 2007
985       https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf
986 
987 
988     See also
989     --------
990     chi2_kernel : The exponentiated version of the kernel, which is usually
991         preferable.
992 
993     sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
994         to this kernel.
995     """
996     if issparse(X) or issparse(Y):
997         raise ValueError("additive_chi2 does not support sparse matrices.")
998     X, Y = check_pairwise_arrays(X, Y)
999     if (X < 0).any():
1000         raise ValueError("X contains negative values.")
1001     if Y is not X and (Y < 0).any():
1002         raise ValueError("Y contains negative values.")
1003 
1004     result = np.zeros((X.shape[0], Y.shape[0]), dtype=X.dtype)
1005     _chi2_kernel_fast(X, Y, result)
1006     return result
1007 
1008 
1009 def chi2_kernel(X, Y=None, gamma=1.):
1010     """Computes the exponential chi-squared kernel X and Y.
1011 
1012     The chi-squared kernel is computed between each pair of rows in X and Y.  X
1013     and Y have to be non-negative. This kernel is most commonly applied to
1014     histograms.
1015 
1016     The chi-squared kernel is given by::
1017 
1018         k(x, y) = exp(-gamma Sum [(x - y)^2 / (x + y)])
1019 
1020     It can be interpreted as a weighted difference per entry.
1021 
1022     Read more in the :ref:`User Guide <chi2_kernel>`.
1023 
1024     Parameters
1025     ----------
1026     X : array-like of shape (n_samples_X, n_features)
1027 
1028     Y : array of shape (n_samples_Y, n_features)
1029 
1030     gamma : float, default=1.
1031         Scaling parameter of the chi2 kernel.
1032 
1033     Returns
1034     -------
1035     kernel_matrix : array of shape (n_samples_X, n_samples_Y)
1036 
1037     References
1038     ----------
1039     * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.
1040       Local features and kernels for classification of texture and object
1041       categories: A comprehensive study
1042       International Journal of Computer Vision 2007
1043       https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf
1044 
1045     See also
1046     --------
1047     additive_chi2_kernel : The additive version of this kernel
1048 
1049     sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation
1050         to the additive version of this kernel.
1051     """
1052     K = additive_chi2_kernel(X, Y)
1053     K *= gamma
1054     return np.exp(K, K)
1055 
1056 
1057 # Helper functions - distance
1058 PAIRWISE_DISTANCE_FUNCTIONS = {
1059     # If updating this dictionary, update the doc in both distance_metrics()
1060     # and also in pairwise_distances()!
1061     'cityblock': manhattan_distances,
1062     'cosine': cosine_distances,
1063     'euclidean': euclidean_distances,
1064     'haversine': haversine_distances,
1065     'l2': euclidean_distances,
1066     'l1': manhattan_distances,
1067     'manhattan': manhattan_distances,
1068     'precomputed': None,  # HACK: precomputed is always allowed, never called
1069 }
1070 
1071 
1072 def distance_metrics():
1073     """Valid metrics for pairwise_distances.
1074 
1075     This function simply returns the valid pairwise distance metrics.
1076     It exists to allow for a description of the mapping for
1077     each of the valid strings.
1078 
1079     The valid distance metrics, and the function they map to, are:
1080 
1081     ============     ====================================
1082     metric           Function
1083     ============     ====================================
1084     'cityblock'      metrics.pairwise.manhattan_distances
1085     'cosine'         metrics.pairwise.cosine_distances
1086     'euclidean'      metrics.pairwise.euclidean_distances
1087     'haversine'      metrics.pairwise.haversine_distances
1088     'l1'             metrics.pairwise.manhattan_distances
1089     'l2'             metrics.pairwise.euclidean_distances
1090     'manhattan'      metrics.pairwise.manhattan_distances
1091     ============     ====================================
1092 
1093     Read more in the :ref:`User Guide <metrics>`.
1094 
1095     """
1096     return PAIRWISE_DISTANCE_FUNCTIONS
1097 
1098 
1099 def _dist_wrapper(dist_func, dist_matrix, slice_, *args, **kwargs):
1100     """Write in-place to a slice of a distance matrix"""
1101     dist_matrix[:, slice_] = dist_func(*args, **kwargs)
1102 
1103 
1104 def _parallel_pairwise(X, Y, func, n_jobs, **kwds):
1105     """Break the pairwise matrix in n_jobs even slices
1106     and compute them in parallel"""
1107 
1108     if Y is None:
1109         Y = X
1110 
1111     if effective_n_jobs(n_jobs) == 1:
1112         return func(X, Y, **kwds)
1113 
1114     # enforce a threading backend to prevent data communication overhead
1115     fd = delayed(_dist_wrapper)
1116     ret = np.empty((X.shape[0], Y.shape[0]), dtype=X.dtype, order='F')
1117     Parallel(backend="threading", n_jobs=n_jobs)(
1118         fd(func, ret, s, X, Y[s], **kwds)
1119         for s in gen_even_slices(_num_samples(Y), effective_n_jobs(n_jobs)))
1120 
1121     return ret
1122 
1123 
1124 def _pairwise_callable(X, Y, metric, **kwds):
1125     """Handle the callable case for pairwise_{distances,kernels}
1126     """
1127     X, Y = check_pairwise_arrays(X, Y)
1128 
1129     if X is Y:
1130         # Only calculate metric for upper triangle
1131         out = np.zeros((X.shape[0], Y.shape[0]), dtype='float')
1132         iterator = itertools.combinations(range(X.shape[0]), 2)
1133         for i, j in iterator:
1134             out[i, j] = metric(X[i], Y[j], **kwds)
1135 
1136         # Make symmetric
1137         # NB: out += out.T will produce incorrect results
1138         out = out + out.T
1139 
1140         # Calculate diagonal
1141         # NB: nonzero diagonals are allowed for both metrics and kernels
1142         for i in range(X.shape[0]):
1143             x = X[i]
1144             out[i, i] = metric(x, x, **kwds)
1145 
1146     else:
1147         # Calculate all cells
1148         out = np.empty((X.shape[0], Y.shape[0]), dtype='float')
1149         iterator = itertools.product(range(X.shape[0]), range(Y.shape[0]))
1150         for i, j in iterator:
1151             out[i, j] = metric(X[i], Y[j], **kwds)
1152 
1153     return out
1154 
1155 
1156 _VALID_METRICS = ['euclidean', 'l2', 'l1', 'manhattan', 'cityblock',
1157                   'braycurtis', 'canberra', 'chebyshev', 'correlation',
1158                   'cosine', 'dice', 'hamming', 'jaccard', 'kulsinski',
1159                   'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
1160                   'russellrao', 'seuclidean', 'sokalmichener',
1161                   'sokalsneath', 'sqeuclidean', 'yule', 'wminkowski',
1162                   'haversine']
1163 
1164 
1165 def _check_chunk_size(reduced, chunk_size):
1166     """Checks chunk is a sequence of expected size or a tuple of same
1167     """
1168     is_tuple = isinstance(reduced, tuple)
1169     if not is_tuple:
1170         reduced = (reduced,)
1171     if any(isinstance(r, tuple) or not hasattr(r, '__iter__')
1172            for r in reduced):
1173         raise TypeError('reduce_func returned %r. '
1174                         'Expected sequence(s) of length %d.' %
1175                         (reduced if is_tuple else reduced[0], chunk_size))
1176     if any(_num_samples(r) != chunk_size for r in reduced):
1177         actual_size = tuple(_num_samples(r) for r in reduced)
1178         raise ValueError('reduce_func returned object of length %s. '
1179                          'Expected same length as input: %d.' %
1180                          (actual_size if is_tuple else actual_size[0],
1181                           chunk_size))
1182 
1183 
1184 def _precompute_metric_params(X, Y, metric=None, **kwds):
1185     """Precompute data-derived metric parameters if not provided
1186     """
1187     if metric == "seuclidean" and 'V' not in kwds:
1188         if X is Y:
1189             V = np.var(X, axis=0, ddof=1)
1190         else:
1191             V = np.var(np.vstack([X, Y]), axis=0, ddof=1)
1192         return {'V': V}
1193     if metric == "mahalanobis" and 'VI' not in kwds:
1194         if X is Y:
1195             VI = np.linalg.inv(np.cov(X.T)).T
1196         else:
1197             VI = np.linalg.inv(np.cov(np.vstack([X, Y]).T)).T
1198         return {'VI': VI}
1199     return {}
1200 
1201 
1202 def pairwise_distances_chunked(X, Y=None, reduce_func=None,
1203                                metric='euclidean', n_jobs=None,
1204                                working_memory=None, **kwds):
1205     """Generate a distance matrix chunk by chunk with optional reduction
1206 
1207     In cases where not all of a pairwise distance matrix needs to be stored at
1208     once, this is used to calculate pairwise distances in
1209     ``working_memory``-sized chunks.  If ``reduce_func`` is given, it is run
1210     on each chunk and its return values are concatenated into lists, arrays
1211     or sparse matrices.
1212 
1213     Parameters
1214     ----------
1215     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or,
1216         [n_samples_a, n_features] otherwise
1217         Array of pairwise distances between samples, or a feature array.
1218 
1219     Y : array [n_samples_b, n_features], optional
1220         An optional second feature array. Only allowed if
1221         metric != "precomputed".
1222 
1223     reduce_func : callable, optional
1224         The function which is applied on each chunk of the distance matrix,
1225         reducing it to needed values.  ``reduce_func(D_chunk, start)``
1226         is called repeatedly, where ``D_chunk`` is a contiguous vertical
1227         slice of the pairwise distance matrix, starting at row ``start``.
1228         It should return an array, a list, or a sparse matrix of length
1229         ``D_chunk.shape[0]``, or a tuple of such objects.
1230 
1231         If None, pairwise_distances_chunked returns a generator of vertical
1232         chunks of the distance matrix.
1233 
1234     metric : string, or callable
1235         The metric to use when calculating distance between instances in a
1236         feature array. If metric is a string, it must be one of the options
1237         allowed by scipy.spatial.distance.pdist for its metric parameter, or
1238         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
1239         If metric is "precomputed", X is assumed to be a distance matrix.
1240         Alternatively, if metric is a callable function, it is called on each
1241         pair of instances (rows) and the resulting value recorded. The callable
1242         should take two arrays from X as input and return a value indicating
1243         the distance between them.
1244 
1245     n_jobs : int or None, optional (default=None)
1246         The number of jobs to use for the computation. This works by breaking
1247         down the pairwise matrix into n_jobs even slices and computing them in
1248         parallel.
1249 
1250         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1251         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1252         for more details.
1253 
1254     working_memory : int, optional
1255         The sought maximum memory for temporary distance matrix chunks.
1256         When None (default), the value of
1257         ``sklearn.get_config()['working_memory']`` is used.
1258 
1259     `**kwds` : optional keyword parameters
1260         Any further parameters are passed directly to the distance function.
1261         If using a scipy.spatial.distance metric, the parameters are still
1262         metric dependent. See the scipy docs for usage examples.
1263 
1264     Yields
1265     ------
1266     D_chunk : array or sparse matrix
1267         A contiguous slice of distance matrix, optionally processed by
1268         ``reduce_func``.
1269 
1270     Examples
1271     --------
1272     Without reduce_func:
1273 
1274     >>> import numpy as np
1275     >>> from sklearn.metrics import pairwise_distances_chunked
1276     >>> X = np.random.RandomState(0).rand(5, 3)
1277     >>> D_chunk = next(pairwise_distances_chunked(X))
1278     >>> D_chunk  # doctest: +ELLIPSIS
1279     array([[0.  ..., 0.29..., 0.41..., 0.19..., 0.57...],
1280            [0.29..., 0.  ..., 0.57..., 0.41..., 0.76...],
1281            [0.41..., 0.57..., 0.  ..., 0.44..., 0.90...],
1282            [0.19..., 0.41..., 0.44..., 0.  ..., 0.51...],
1283            [0.57..., 0.76..., 0.90..., 0.51..., 0.  ...]])
1284 
1285     Retrieve all neighbors and average distance within radius r:
1286 
1287     >>> r = .2
1288     >>> def reduce_func(D_chunk, start):
1289     ...     neigh = [np.flatnonzero(d < r) for d in D_chunk]
1290     ...     avg_dist = (D_chunk * (D_chunk < r)).mean(axis=1)
1291     ...     return neigh, avg_dist
1292     >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func)
1293     >>> neigh, avg_dist = next(gen)
1294     >>> neigh
1295     [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])]
1296     >>> avg_dist  # doctest: +ELLIPSIS
1297     array([0.039..., 0.        , 0.        , 0.039..., 0.        ])
1298 
1299     Where r is defined per sample, we need to make use of ``start``:
1300 
1301     >>> r = [.2, .4, .4, .3, .1]
1302     >>> def reduce_func(D_chunk, start):
1303     ...     neigh = [np.flatnonzero(d < r[i])
1304     ...              for i, d in enumerate(D_chunk, start)]
1305     ...     return neigh
1306     >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func))
1307     >>> neigh
1308     [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])]
1309 
1310     Force row-by-row generation by reducing ``working_memory``:
1311 
1312     >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func,
1313     ...                                  working_memory=0)
1314     >>> next(gen)
1315     [array([0, 3])]
1316     >>> next(gen)
1317     [array([0, 1])]
1318     """
1319     n_samples_X = _num_samples(X)
1320     if metric == 'precomputed':
1321         slices = (slice(0, n_samples_X),)
1322     else:
1323         if Y is None:
1324             Y = X
1325         # We get as many rows as possible within our working_memory budget to
1326         # store len(Y) distances in each row of output.
1327         #
1328         # Note:
1329         #  - this will get at least 1 row, even if 1 row of distances will
1330         #    exceed working_memory.
1331         #  - this does not account for any temporary memory usage while
1332         #    calculating distances (e.g. difference of vectors in manhattan
1333         #    distance.
1334         chunk_n_rows = get_chunk_n_rows(row_bytes=8 * _num_samples(Y),
1335                                         max_n_rows=n_samples_X,
1336                                         working_memory=working_memory)
1337         slices = gen_batches(n_samples_X, chunk_n_rows)
1338 
1339     # precompute data-derived metric params
1340     params = _precompute_metric_params(X, Y, metric=metric, **kwds)
1341     kwds.update(**params)
1342 
1343     for sl in slices:
1344         if sl.start == 0 and sl.stop == n_samples_X:
1345             X_chunk = X  # enable optimised paths for X is Y
1346         else:
1347             X_chunk = X[sl]
1348         D_chunk = pairwise_distances(X_chunk, Y, metric=metric,
1349                                      n_jobs=n_jobs, **kwds)
1350         if ((X is Y or Y is None)
1351                 and PAIRWISE_DISTANCE_FUNCTIONS.get(metric, None)
1352                 is euclidean_distances):
1353             # zeroing diagonal, taking care of aliases of "euclidean",
1354             # i.e. "l2"
1355             D_chunk.flat[sl.start::_num_samples(X) + 1] = 0
1356         if reduce_func is not None:
1357             chunk_size = D_chunk.shape[0]
1358             D_chunk = reduce_func(D_chunk, sl.start)
1359             _check_chunk_size(D_chunk, chunk_size)
1360         yield D_chunk
1361 
1362 
1363 def pairwise_distances(X, Y=None, metric="euclidean", n_jobs=None, **kwds):
1364     """ Compute the distance matrix from a vector array X and optional Y.
1365 
1366     This method takes either a vector array or a distance matrix, and returns
1367     a distance matrix. If the input is a vector array, the distances are
1368     computed. If the input is a distances matrix, it is returned instead.
1369 
1370     This method provides a safe way to take a distance matrix as input, while
1371     preserving compatibility with many other algorithms that take a vector
1372     array.
1373 
1374     If Y is given (default is None), then the returned matrix is the pairwise
1375     distance between the arrays from both X and Y.
1376 
1377     Valid values for metric are:
1378 
1379     - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',
1380       'manhattan']. These metrics support sparse matrix inputs.
1381 
1382     - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',
1383       'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',
1384       'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',
1385       'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']
1386       See the documentation for scipy.spatial.distance for details on these
1387       metrics. These metrics do not support sparse matrix inputs.
1388 
1389     Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are
1390     valid scipy.spatial.distance metrics), the scikit-learn implementation
1391     will be used, which is faster and has support for sparse matrices (except
1392     for 'cityblock'). For a verbose description of the metrics from
1393     scikit-learn, see the __doc__ of the sklearn.pairwise.distance_metrics
1394     function.
1395 
1396     Read more in the :ref:`User Guide <metrics>`.
1397 
1398     Parameters
1399     ----------
1400     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or, \
1401              [n_samples_a, n_features] otherwise
1402         Array of pairwise distances between samples, or a feature array.
1403 
1404     Y : array [n_samples_b, n_features], optional
1405         An optional second feature array. Only allowed if
1406         metric != "precomputed".
1407 
1408     metric : string, or callable
1409         The metric to use when calculating distance between instances in a
1410         feature array. If metric is a string, it must be one of the options
1411         allowed by scipy.spatial.distance.pdist for its metric parameter, or
1412         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.
1413         If metric is "precomputed", X is assumed to be a distance matrix.
1414         Alternatively, if metric is a callable function, it is called on each
1415         pair of instances (rows) and the resulting value recorded. The callable
1416         should take two arrays from X as input and return a value indicating
1417         the distance between them.
1418 
1419     n_jobs : int or None, optional (default=None)
1420         The number of jobs to use for the computation. This works by breaking
1421         down the pairwise matrix into n_jobs even slices and computing them in
1422         parallel.
1423 
1424         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1425         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1426         for more details.
1427 
1428     **kwds : optional keyword parameters
1429         Any further parameters are passed directly to the distance function.
1430         If using a scipy.spatial.distance metric, the parameters are still
1431         metric dependent. See the scipy docs for usage examples.
1432 
1433     Returns
1434     -------
1435     D : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
1436         A distance matrix D such that D_{i, j} is the distance between the
1437         ith and jth vectors of the given matrix X, if Y is None.
1438         If Y is not None, then D_{i, j} is the distance between the ith array
1439         from X and the jth array from Y.
1440 
1441     See also
1442     --------
1443     pairwise_distances_chunked : performs the same calculation as this
1444         function, but returns a generator of chunks of the distance matrix, in
1445         order to limit memory usage.
1446     paired_distances : Computes the distances between corresponding
1447                        elements of two arrays
1448     """
1449     if (metric not in _VALID_METRICS and
1450             not callable(metric) and metric != "precomputed"):
1451         raise ValueError("Unknown metric %s. "
1452                          "Valid metrics are %s, or 'precomputed', or a "
1453                          "callable" % (metric, _VALID_METRICS))
1454 
1455     if metric == "precomputed":
1456         X, _ = check_pairwise_arrays(X, Y, precomputed=True)
1457 
1458         whom = ("`pairwise_distances`. Precomputed distance "
1459                 " need to have non-negative values.")
1460         check_non_negative(X, whom=whom)
1461         return X
1462     elif metric in PAIRWISE_DISTANCE_FUNCTIONS:
1463         func = PAIRWISE_DISTANCE_FUNCTIONS[metric]
1464     elif callable(metric):
1465         func = partial(_pairwise_callable, metric=metric, **kwds)
1466     else:
1467         if issparse(X) or issparse(Y):
1468             raise TypeError("scipy distance metrics do not"
1469                             " support sparse matrices.")
1470 
1471         dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None
1472 
1473         if dtype == bool and (X.dtype != bool or Y.dtype != bool):
1474             msg = "Data was converted to boolean for metric %s" % metric
1475             warnings.warn(msg, DataConversionWarning)
1476 
1477         X, Y = check_pairwise_arrays(X, Y, dtype=dtype)
1478 
1479         # precompute data-derived metric params
1480         params = _precompute_metric_params(X, Y, metric=metric, **kwds)
1481         kwds.update(**params)
1482 
1483         if effective_n_jobs(n_jobs) == 1 and X is Y:
1484             return distance.squareform(distance.pdist(X, metric=metric,
1485                                                       **kwds))
1486         func = partial(distance.cdist, metric=metric, **kwds)
1487 
1488     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)
1489 
1490 
1491 # These distances recquire boolean arrays, when using scipy.spatial.distance
1492 PAIRWISE_BOOLEAN_FUNCTIONS = [
1493     'dice',
1494     'jaccard',
1495     'kulsinski',
1496     'matching',
1497     'rogerstanimoto',
1498     'russellrao',
1499     'sokalmichener',
1500     'sokalsneath',
1501     'yule',
1502 ]
1503 
1504 
1505 # Helper functions - distance
1506 PAIRWISE_KERNEL_FUNCTIONS = {
1507     # If updating this dictionary, update the doc in both distance_metrics()
1508     # and also in pairwise_distances()!
1509     'additive_chi2': additive_chi2_kernel,
1510     'chi2': chi2_kernel,
1511     'linear': linear_kernel,
1512     'polynomial': polynomial_kernel,
1513     'poly': polynomial_kernel,
1514     'rbf': rbf_kernel,
1515     'laplacian': laplacian_kernel,
1516     'sigmoid': sigmoid_kernel,
1517     'cosine': cosine_similarity, }
1518 
1519 
1520 def kernel_metrics():
1521     """ Valid metrics for pairwise_kernels
1522 
1523     This function simply returns the valid pairwise distance metrics.
1524     It exists, however, to allow for a verbose description of the mapping for
1525     each of the valid strings.
1526 
1527     The valid distance metrics, and the function they map to, are:
1528       ===============   ========================================
1529       metric            Function
1530       ===============   ========================================
1531       'additive_chi2'   sklearn.pairwise.additive_chi2_kernel
1532       'chi2'            sklearn.pairwise.chi2_kernel
1533       'linear'          sklearn.pairwise.linear_kernel
1534       'poly'            sklearn.pairwise.polynomial_kernel
1535       'polynomial'      sklearn.pairwise.polynomial_kernel
1536       'rbf'             sklearn.pairwise.rbf_kernel
1537       'laplacian'       sklearn.pairwise.laplacian_kernel
1538       'sigmoid'         sklearn.pairwise.sigmoid_kernel
1539       'cosine'          sklearn.pairwise.cosine_similarity
1540       ===============   ========================================
1541 
1542     Read more in the :ref:`User Guide <metrics>`.
1543     """
1544     return PAIRWISE_KERNEL_FUNCTIONS
1545 
1546 
1547 KERNEL_PARAMS = {
1548     "additive_chi2": (),
1549     "chi2": frozenset(["gamma"]),
1550     "cosine": (),
1551     "linear": (),
1552     "poly": frozenset(["gamma", "degree", "coef0"]),
1553     "polynomial": frozenset(["gamma", "degree", "coef0"]),
1554     "rbf": frozenset(["gamma"]),
1555     "laplacian": frozenset(["gamma"]),
1556     "sigmoid": frozenset(["gamma", "coef0"]),
1557 }
1558 
1559 
1560 def pairwise_kernels(X, Y=None, metric="linear", filter_params=False,
1561                      n_jobs=None, **kwds):
1562     """Compute the kernel between arrays X and optional array Y.
1563 
1564     This method takes either a vector array or a kernel matrix, and returns
1565     a kernel matrix. If the input is a vector array, the kernels are
1566     computed. If the input is a kernel matrix, it is returned instead.
1567 
1568     This method provides a safe way to take a kernel matrix as input, while
1569     preserving compatibility with many other algorithms that take a vector
1570     array.
1571 
1572     If Y is given (default is None), then the returned matrix is the pairwise
1573     kernel between the arrays from both X and Y.
1574 
1575     Valid values for metric are::
1576         ['rbf', 'sigmoid', 'polynomial', 'poly', 'linear', 'cosine']
1577 
1578     Read more in the :ref:`User Guide <metrics>`.
1579 
1580     Parameters
1581     ----------
1582     X : array [n_samples_a, n_samples_a] if metric == "precomputed", or, \
1583              [n_samples_a, n_features] otherwise
1584         Array of pairwise kernels between samples, or a feature array.
1585 
1586     Y : array [n_samples_b, n_features]
1587         A second feature array only if X has shape [n_samples_a, n_features].
1588 
1589     metric : string, or callable
1590         The metric to use when calculating kernel between instances in a
1591         feature array. If metric is a string, it must be one of the metrics
1592         in pairwise.PAIRWISE_KERNEL_FUNCTIONS.
1593         If metric is "precomputed", X is assumed to be a kernel matrix.
1594         Alternatively, if metric is a callable function, it is called on each
1595         pair of instances (rows) and the resulting value recorded. The callable
1596         should take two arrays from X as input and return a value indicating
1597         the distance between them.
1598 
1599     filter_params : boolean
1600         Whether to filter invalid parameters or not.
1601 
1602     n_jobs : int or None, optional (default=None)
1603         The number of jobs to use for the computation. This works by breaking
1604         down the pairwise matrix into n_jobs even slices and computing them in
1605         parallel.
1606 
1607         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
1608         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`
1609         for more details.
1610 
1611     **kwds : optional keyword parameters
1612         Any further parameters are passed directly to the kernel function.
1613 
1614     Returns
1615     -------
1616     K : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]
1617         A kernel matrix K such that K_{i, j} is the kernel between the
1618         ith and jth vectors of the given matrix X, if Y is None.
1619         If Y is not None, then K_{i, j} is the kernel between the ith array
1620         from X and the jth array from Y.
1621 
1622     Notes
1623     -----
1624     If metric is 'precomputed', Y is ignored and X is returned.
1625 
1626     """
1627     # import GPKernel locally to prevent circular imports
1628     from ..gaussian_process.kernels import Kernel as GPKernel
1629 
1630     if metric == "precomputed":
1631         X, _ = check_pairwise_arrays(X, Y, precomputed=True)
1632         return X
1633     elif isinstance(metric, GPKernel):
1634         func = metric.__call__
1635     elif metric in PAIRWISE_KERNEL_FUNCTIONS:
1636         if filter_params:
1637             kwds = {k: kwds[k] for k in kwds
1638                     if k in KERNEL_PARAMS[metric]}
1639         func = PAIRWISE_KERNEL_FUNCTIONS[metric]
1640     elif callable(metric):
1641         func = partial(_pairwise_callable, metric=metric, **kwds)
1642     else:
1643         raise ValueError("Unknown kernel %r" % metric)
1644 
1645     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)

</code><intended_behavior>Although a specific method wasn't identified due to lack of precise match in the search results, the changes should conceptually address optimizations around memory usage and block-wise operations as mentioned in the issue. This includes ensuring that any blocks cast to `float64` for the purpose of improving precision do not inadvertently cause mismatches or precision loss when the original data was in `float32`. Implementing or refining a mechanism to dynamically calculate the optimal block size based on the input data type and available memory, ensuring symmetry in distance computations (i.e., between `X` and `Y`), and accurately copying results between blocks could achieve this. This might involve reviewing and potentially revising the logic that handles these aspects, ensuring that enhancements for handling `float32` do not compromise performance or accuracy for other types. Adjustments or additional logic may need to be integrated to ensure that the handling of `X_norm_squared` and potential `Y_norm_squared` during these operations aligns with the goal of precise and efficient distance computations for all supported data types, including `float32`.</intended_behavior>]
2025-10-18 17:11:48.394 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 17:11:48.394 | INFO     | Search-only: skipping patch selection
2025-10-18 17:11:48.487 | INFO     | Task scikit-learn__scikit-learn-13554 completed successfully.
2025-10-18 17:11:48.488 | INFO     | No patch generated. You can try running ACR again.
