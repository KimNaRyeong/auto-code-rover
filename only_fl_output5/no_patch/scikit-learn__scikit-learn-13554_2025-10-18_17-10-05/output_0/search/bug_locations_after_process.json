[
    {
        "rel_file_path": "sklearn/metrics/pairwise.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.21/sklearn/metrics/pairwise.py",
        "start": 1363,
        "end": 1488,
        "class_name": null,
        "method_name": "pairwise_distances",
        "code": "1363 def pairwise_distances(X, Y=None, metric=\"euclidean\", n_jobs=None, **kwds):\n1364     \"\"\" Compute the distance matrix from a vector array X and optional Y.\n1365 \n1366     This method takes either a vector array or a distance matrix, and returns\n1367     a distance matrix. If the input is a vector array, the distances are\n1368     computed. If the input is a distances matrix, it is returned instead.\n1369 \n1370     This method provides a safe way to take a distance matrix as input, while\n1371     preserving compatibility with many other algorithms that take a vector\n1372     array.\n1373 \n1374     If Y is given (default is None), then the returned matrix is the pairwise\n1375     distance between the arrays from both X and Y.\n1376 \n1377     Valid values for metric are:\n1378 \n1379     - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n1380       'manhattan']. These metrics support sparse matrix inputs.\n1381 \n1382     - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n1383       'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',\n1384       'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',\n1385       'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']\n1386       See the documentation for scipy.spatial.distance for details on these\n1387       metrics. These metrics do not support sparse matrix inputs.\n1388 \n1389     Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are\n1390     valid scipy.spatial.distance metrics), the scikit-learn implementation\n1391     will be used, which is faster and has support for sparse matrices (except\n1392     for 'cityblock'). For a verbose description of the metrics from\n1393     scikit-learn, see the __doc__ of the sklearn.pairwise.distance_metrics\n1394     function.\n1395 \n1396     Read more in the :ref:`User Guide <metrics>`.\n1397 \n1398     Parameters\n1399     ----------\n1400     X : array [n_samples_a, n_samples_a] if metric == \"precomputed\", or, \\\n1401              [n_samples_a, n_features] otherwise\n1402         Array of pairwise distances between samples, or a feature array.\n1403 \n1404     Y : array [n_samples_b, n_features], optional\n1405         An optional second feature array. Only allowed if\n1406         metric != \"precomputed\".\n1407 \n1408     metric : string, or callable\n1409         The metric to use when calculating distance between instances in a\n1410         feature array. If metric is a string, it must be one of the options\n1411         allowed by scipy.spatial.distance.pdist for its metric parameter, or\n1412         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\n1413         If metric is \"precomputed\", X is assumed to be a distance matrix.\n1414         Alternatively, if metric is a callable function, it is called on each\n1415         pair of instances (rows) and the resulting value recorded. The callable\n1416         should take two arrays from X as input and return a value indicating\n1417         the distance between them.\n1418 \n1419     n_jobs : int or None, optional (default=None)\n1420         The number of jobs to use for the computation. This works by breaking\n1421         down the pairwise matrix into n_jobs even slices and computing them in\n1422         parallel.\n1423 \n1424         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n1425         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n1426         for more details.\n1427 \n1428     **kwds : optional keyword parameters\n1429         Any further parameters are passed directly to the distance function.\n1430         If using a scipy.spatial.distance metric, the parameters are still\n1431         metric dependent. See the scipy docs for usage examples.\n1432 \n1433     Returns\n1434     -------\n1435     D : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]\n1436         A distance matrix D such that D_{i, j} is the distance between the\n1437         ith and jth vectors of the given matrix X, if Y is None.\n1438         If Y is not None, then D_{i, j} is the distance between the ith array\n1439         from X and the jth array from Y.\n1440 \n1441     See also\n1442     --------\n1443     pairwise_distances_chunked : performs the same calculation as this\n1444         function, but returns a generator of chunks of the distance matrix, in\n1445         order to limit memory usage.\n1446     paired_distances : Computes the distances between corresponding\n1447                        elements of two arrays\n1448     \"\"\"\n1449     if (metric not in _VALID_METRICS and\n1450             not callable(metric) and metric != \"precomputed\"):\n1451         raise ValueError(\"Unknown metric %s. \"\n1452                          \"Valid metrics are %s, or 'precomputed', or a \"\n1453                          \"callable\" % (metric, _VALID_METRICS))\n1454 \n1455     if metric == \"precomputed\":\n1456         X, _ = check_pairwise_arrays(X, Y, precomputed=True)\n1457 \n1458         whom = (\"`pairwise_distances`. Precomputed distance \"\n1459                 \" need to have non-negative values.\")\n1460         check_non_negative(X, whom=whom)\n1461         return X\n1462     elif metric in PAIRWISE_DISTANCE_FUNCTIONS:\n1463         func = PAIRWISE_DISTANCE_FUNCTIONS[metric]\n1464     elif callable(metric):\n1465         func = partial(_pairwise_callable, metric=metric, **kwds)\n1466     else:\n1467         if issparse(X) or issparse(Y):\n1468             raise TypeError(\"scipy distance metrics do not\"\n1469                             \" support sparse matrices.\")\n1470 \n1471         dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None\n1472 \n1473         if dtype == bool and (X.dtype != bool or Y.dtype != bool):\n1474             msg = \"Data was converted to boolean for metric %s\" % metric\n1475             warnings.warn(msg, DataConversionWarning)\n1476 \n1477         X, Y = check_pairwise_arrays(X, Y, dtype=dtype)\n1478 \n1479         # precompute data-derived metric params\n1480         params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n1481         kwds.update(**params)\n1482 \n1483         if effective_n_jobs(n_jobs) == 1 and X is Y:\n1484             return distance.squareform(distance.pdist(X, metric=metric,\n1485                                                       **kwds))\n1486         func = partial(distance.cdist, metric=metric, **kwds)\n1487 \n1488     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)\n",
        "intended_behavior": "The intended behavior for resolving the issue with `pairwise_distances` involves ensuring numerical precision is preserved for `float32` arrays throughout the computation, especially when using the \"euclidean\" metric. Precisely, when computing distances between arrays of type `float32`, the function should carefully manage the conversion (if necessary) to `float64` to avoid precision loss, or better yet, optimize the calculation to preserve `float32` precision without unnecessary type conversions. This could involve conditionally enabling such optimizations based on the dtype of the input arrays and the available memory for computations, thus preserving existing functionality while improving numerical precision for `float32`. The patch should also ensure that any block-wise operations or use of `X_norm_squared` for optimizations are correctly applied to maintain precision across types."
    },
    {
        "rel_file_path": "sklearn/metrics/pairwise.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.21/sklearn/metrics/pairwise.py",
        "start": 1,
        "end": 1645,
        "class_name": null,
        "method_name": null,
        "code": "1 # -*- coding: utf-8 -*-\n2 \n3 # Authors: Alexandre Gramfort <alexandre.gramfort@inria.fr>\n4 #          Mathieu Blondel <mathieu@mblondel.org>\n5 #          Robert Layton <robertlayton@gmail.com>\n6 #          Andreas Mueller <amueller@ais.uni-bonn.de>\n7 #          Philippe Gervais <philippe.gervais@inria.fr>\n8 #          Lars Buitinck\n9 #          Joel Nothman <joel.nothman@gmail.com>\n10 # License: BSD 3 clause\n11 \n12 import itertools\n13 from functools import partial\n14 import warnings\n15 \n16 import numpy as np\n17 from scipy.spatial import distance\n18 from scipy.sparse import csr_matrix\n19 from scipy.sparse import issparse\n20 \n21 from ..utils.validation import _num_samples\n22 from ..utils.validation import check_non_negative\n23 from ..utils import check_array\n24 from ..utils import gen_even_slices\n25 from ..utils import gen_batches, get_chunk_n_rows\n26 from ..utils.extmath import row_norms, safe_sparse_dot\n27 from ..preprocessing import normalize\n28 from ..utils._joblib import Parallel\n29 from ..utils._joblib import delayed\n30 from ..utils._joblib import effective_n_jobs\n31 \n32 from .pairwise_fast import _chi2_kernel_fast, _sparse_manhattan\n33 from ..exceptions import DataConversionWarning\n34 \n35 \n36 # Utility Functions\n37 def _return_float_dtype(X, Y):\n38     \"\"\"\n39     1. If dtype of X and Y is float32, then dtype float32 is returned.\n40     2. Else dtype float is returned.\n41     \"\"\"\n42     if not issparse(X) and not isinstance(X, np.ndarray):\n43         X = np.asarray(X)\n44 \n45     if Y is None:\n46         Y_dtype = X.dtype\n47     elif not issparse(Y) and not isinstance(Y, np.ndarray):\n48         Y = np.asarray(Y)\n49         Y_dtype = Y.dtype\n50     else:\n51         Y_dtype = Y.dtype\n52 \n53     if X.dtype == Y_dtype == np.float32:\n54         dtype = np.float32\n55     else:\n56         dtype = np.float\n57 \n58     return X, Y, dtype\n59 \n60 \n61 def check_pairwise_arrays(X, Y, precomputed=False, dtype=None):\n62     \"\"\" Set X and Y appropriately and checks inputs\n63 \n64     If Y is None, it is set as a pointer to X (i.e. not a copy).\n65     If Y is given, this does not happen.\n66     All distance metrics should use this function first to assert that the\n67     given parameters are correct and safe to use.\n68 \n69     Specifically, this function first ensures that both X and Y are arrays,\n70     then checks that they are at least two dimensional while ensuring that\n71     their elements are floats (or dtype if provided). Finally, the function\n72     checks that the size of the second dimension of the two arrays is equal, or\n73     the equivalent check for a precomputed distance matrix.\n74 \n75     Parameters\n76     ----------\n77     X : {array-like, sparse matrix}, shape (n_samples_a, n_features)\n78 \n79     Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)\n80 \n81     precomputed : bool\n82         True if X is to be treated as precomputed distances to the samples in\n83         Y.\n84 \n85     dtype : string, type, list of types or None (default=None)\n86         Data type required for X and Y. If None, the dtype will be an\n87         appropriate float type selected by _return_float_dtype.\n88 \n89         .. versionadded:: 0.18\n90 \n91     Returns\n92     -------\n93     safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)\n94         An array equal to X, guaranteed to be a numpy array.\n95 \n96     safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)\n97         An array equal to Y if Y was not None, guaranteed to be a numpy array.\n98         If Y was None, safe_Y will be a pointer to X.\n99 \n100     \"\"\"\n101     X, Y, dtype_float = _return_float_dtype(X, Y)\n102 \n103     estimator = 'check_pairwise_arrays'\n104     if dtype is None:\n105         dtype = dtype_float\n106 \n107     if Y is X or Y is None:\n108         X = Y = check_array(X, accept_sparse='csr', dtype=dtype,\n109                             estimator=estimator)\n110     else:\n111         X = check_array(X, accept_sparse='csr', dtype=dtype,\n112                         estimator=estimator)\n113         Y = check_array(Y, accept_sparse='csr', dtype=dtype,\n114                         estimator=estimator)\n115 \n116     if precomputed:\n117         if X.shape[1] != Y.shape[0]:\n118             raise ValueError(\"Precomputed metric requires shape \"\n119                              \"(n_queries, n_indexed). Got (%d, %d) \"\n120                              \"for %d indexed.\" %\n121                              (X.shape[0], X.shape[1], Y.shape[0]))\n122     elif X.shape[1] != Y.shape[1]:\n123         raise ValueError(\"Incompatible dimension for X and Y matrices: \"\n124                          \"X.shape[1] == %d while Y.shape[1] == %d\" % (\n125                              X.shape[1], Y.shape[1]))\n126 \n127     return X, Y\n128 \n129 \n130 def check_paired_arrays(X, Y):\n131     \"\"\" Set X and Y appropriately and checks inputs for paired distances\n132 \n133     All paired distance metrics should use this function first to assert that\n134     the given parameters are correct and safe to use.\n135 \n136     Specifically, this function first ensures that both X and Y are arrays,\n137     then checks that they are at least two dimensional while ensuring that\n138     their elements are floats. Finally, the function checks that the size\n139     of the dimensions of the two arrays are equal.\n140 \n141     Parameters\n142     ----------\n143     X : {array-like, sparse matrix}, shape (n_samples_a, n_features)\n144 \n145     Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)\n146 \n147     Returns\n148     -------\n149     safe_X : {array-like, sparse matrix}, shape (n_samples_a, n_features)\n150         An array equal to X, guaranteed to be a numpy array.\n151 \n152     safe_Y : {array-like, sparse matrix}, shape (n_samples_b, n_features)\n153         An array equal to Y if Y was not None, guaranteed to be a numpy array.\n154         If Y was None, safe_Y will be a pointer to X.\n155 \n156     \"\"\"\n157     X, Y = check_pairwise_arrays(X, Y)\n158     if X.shape != Y.shape:\n159         raise ValueError(\"X and Y should be of same shape. They were \"\n160                          \"respectively %r and %r long.\" % (X.shape, Y.shape))\n161     return X, Y\n162 \n163 \n164 # Pairwise distances\n165 def euclidean_distances(X, Y=None, Y_norm_squared=None, squared=False,\n166                         X_norm_squared=None):\n167     \"\"\"\n168     Considering the rows of X (and Y=X) as vectors, compute the\n169     distance matrix between each pair of vectors.\n170 \n171     For efficiency reasons, the euclidean distance between a pair of row\n172     vector x and y is computed as::\n173 \n174         dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y))\n175 \n176     This formulation has two advantages over other ways of computing distances.\n177     First, it is computationally efficient when dealing with sparse data.\n178     Second, if one argument varies but the other remains unchanged, then\n179     `dot(x, x)` and/or `dot(y, y)` can be pre-computed.\n180 \n181     However, this is not the most precise way of doing this computation, and\n182     the distance matrix returned by this function may not be exactly\n183     symmetric as required by, e.g., ``scipy.spatial.distance`` functions.\n184 \n185     Read more in the :ref:`User Guide <metrics>`.\n186 \n187     Parameters\n188     ----------\n189     X : {array-like, sparse matrix}, shape (n_samples_1, n_features)\n190 \n191     Y : {array-like, sparse matrix}, shape (n_samples_2, n_features)\n192 \n193     Y_norm_squared : array-like, shape (n_samples_2, ), optional\n194         Pre-computed dot-products of vectors in Y (e.g.,\n195         ``(Y**2).sum(axis=1)``)\n196 \n197     squared : boolean, optional\n198         Return squared Euclidean distances.\n199 \n200     X_norm_squared : array-like, shape = [n_samples_1], optional\n201         Pre-computed dot-products of vectors in X (e.g.,\n202         ``(X**2).sum(axis=1)``)\n203 \n204     Returns\n205     -------\n206     distances : {array, sparse matrix}, shape (n_samples_1, n_samples_2)\n207 \n208     Examples\n209     --------\n210     >>> from sklearn.metrics.pairwise import euclidean_distances\n211     >>> X = [[0, 1], [1, 1]]\n212     >>> # distance between rows of X\n213     >>> euclidean_distances(X, X)\n214     array([[0., 1.],\n215            [1., 0.]])\n216     >>> # get distance to origin\n217     >>> euclidean_distances(X, [[0, 0]])\n218     array([[1.        ],\n219            [1.41421356]])\n220 \n221     See also\n222     --------\n223     paired_distances : distances betweens pairs of elements of X and Y.\n224     \"\"\"\n225     X, Y = check_pairwise_arrays(X, Y)\n226 \n227     if X_norm_squared is not None:\n228         XX = check_array(X_norm_squared)\n229         if XX.shape == (1, X.shape[0]):\n230             XX = XX.T\n231         elif XX.shape != (X.shape[0], 1):\n232             raise ValueError(\n233                 \"Incompatible dimensions for X and X_norm_squared\")\n234     else:\n235         XX = row_norms(X, squared=True)[:, np.newaxis]\n236 \n237     if X is Y:  # shortcut in the common case euclidean_distances(X, X)\n238         YY = XX.T\n239     elif Y_norm_squared is not None:\n240         YY = np.atleast_2d(Y_norm_squared)\n241 \n242         if YY.shape != (1, Y.shape[0]):\n243             raise ValueError(\n244                 \"Incompatible dimensions for Y and Y_norm_squared\")\n245     else:\n246         YY = row_norms(Y, squared=True)[np.newaxis, :]\n247 \n248     distances = safe_sparse_dot(X, Y.T, dense_output=True)\n249     distances *= -2\n250     distances += XX\n251     distances += YY\n252     np.maximum(distances, 0, out=distances)\n253 \n254     if X is Y:\n255         # Ensure that distances between vectors and themselves are set to 0.0.\n256         # This may not be the case due to floating point rounding errors.\n257         distances.flat[::distances.shape[0] + 1] = 0.0\n258 \n259     return distances if squared else np.sqrt(distances, out=distances)\n260 \n261 \n262 def _argmin_min_reduce(dist, start):\n263     indices = dist.argmin(axis=1)\n264     values = dist[np.arange(dist.shape[0]), indices]\n265     return indices, values\n266 \n267 \n268 def pairwise_distances_argmin_min(X, Y, axis=1, metric=\"euclidean\",\n269                                   batch_size=None, metric_kwargs=None):\n270     \"\"\"Compute minimum distances between one point and a set of points.\n271 \n272     This function computes for each row in X, the index of the row of Y which\n273     is closest (according to the specified distance). The minimal distances are\n274     also returned.\n275 \n276     This is mostly equivalent to calling:\n277 \n278         (pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis),\n279          pairwise_distances(X, Y=Y, metric=metric).min(axis=axis))\n280 \n281     but uses much less memory, and is faster for large arrays.\n282 \n283     Parameters\n284     ----------\n285     X : {array-like, sparse matrix}, shape (n_samples1, n_features)\n286         Array containing points.\n287 \n288     Y : {array-like, sparse matrix}, shape (n_samples2, n_features)\n289         Arrays containing points.\n290 \n291     axis : int, optional, default 1\n292         Axis along which the argmin and distances are to be computed.\n293 \n294     metric : string or callable, default 'euclidean'\n295         metric to use for distance computation. Any metric from scikit-learn\n296         or scipy.spatial.distance can be used.\n297 \n298         If metric is a callable function, it is called on each\n299         pair of instances (rows) and the resulting value recorded. The callable\n300         should take two arrays as input and return one value indicating the\n301         distance between them. This works for Scipy's metrics, but is less\n302         efficient than passing the metric name as a string.\n303 \n304         Distance matrices are not supported.\n305 \n306         Valid values for metric are:\n307 \n308         - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n309           'manhattan']\n310 \n311         - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n312           'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n313           'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n314           'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n315           'yule']\n316 \n317         See the documentation for scipy.spatial.distance for details on these\n318         metrics.\n319 \n320     batch_size : integer\n321         .. deprecated:: 0.20\n322             Deprecated for removal in 0.22.\n323             Use sklearn.set_config(working_memory=...) instead.\n324 \n325     metric_kwargs : dict, optional\n326         Keyword arguments to pass to specified metric function.\n327 \n328     Returns\n329     -------\n330     argmin : numpy.ndarray\n331         Y[argmin[i], :] is the row in Y that is closest to X[i, :].\n332 \n333     distances : numpy.ndarray\n334         distances[i] is the distance between the i-th row in X and the\n335         argmin[i]-th row in Y.\n336 \n337     See also\n338     --------\n339     sklearn.metrics.pairwise_distances\n340     sklearn.metrics.pairwise_distances_argmin\n341     \"\"\"\n342     if batch_size is not None:\n343         warnings.warn(\"'batch_size' is ignored. It was deprecated in version \"\n344                       \"0.20 and will be removed in version 0.22. \"\n345                       \"Use sklearn.set_config(working_memory=...) instead.\",\n346                       DeprecationWarning)\n347     X, Y = check_pairwise_arrays(X, Y)\n348 \n349     if metric_kwargs is None:\n350         metric_kwargs = {}\n351 \n352     if axis == 0:\n353         X, Y = Y, X\n354 \n355     indices, values = zip(*pairwise_distances_chunked(\n356         X, Y, reduce_func=_argmin_min_reduce, metric=metric,\n357         **metric_kwargs))\n358     indices = np.concatenate(indices)\n359     values = np.concatenate(values)\n360 \n361     return indices, values\n362 \n363 \n364 def pairwise_distances_argmin(X, Y, axis=1, metric=\"euclidean\",\n365                               batch_size=None, metric_kwargs=None):\n366     \"\"\"Compute minimum distances between one point and a set of points.\n367 \n368     This function computes for each row in X, the index of the row of Y which\n369     is closest (according to the specified distance).\n370 \n371     This is mostly equivalent to calling:\n372 \n373         pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis)\n374 \n375     but uses much less memory, and is faster for large arrays.\n376 \n377     This function works with dense 2D arrays only.\n378 \n379     Parameters\n380     ----------\n381     X : array-like\n382         Arrays containing points. Respective shapes (n_samples1, n_features)\n383         and (n_samples2, n_features)\n384 \n385     Y : array-like\n386         Arrays containing points. Respective shapes (n_samples1, n_features)\n387         and (n_samples2, n_features)\n388 \n389     axis : int, optional, default 1\n390         Axis along which the argmin and distances are to be computed.\n391 \n392     metric : string or callable\n393         metric to use for distance computation. Any metric from scikit-learn\n394         or scipy.spatial.distance can be used.\n395 \n396         If metric is a callable function, it is called on each\n397         pair of instances (rows) and the resulting value recorded. The callable\n398         should take two arrays as input and return one value indicating the\n399         distance between them. This works for Scipy's metrics, but is less\n400         efficient than passing the metric name as a string.\n401 \n402         Distance matrices are not supported.\n403 \n404         Valid values for metric are:\n405 \n406         - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n407           'manhattan']\n408 \n409         - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n410           'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski',\n411           'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao',\n412           'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean',\n413           'yule']\n414 \n415         See the documentation for scipy.spatial.distance for details on these\n416         metrics.\n417 \n418     batch_size : integer\n419         .. deprecated:: 0.20\n420             Deprecated for removal in 0.22.\n421             Use sklearn.set_config(working_memory=...) instead.\n422 \n423     metric_kwargs : dict\n424         keyword arguments to pass to specified metric function.\n425 \n426     Returns\n427     -------\n428     argmin : numpy.ndarray\n429         Y[argmin[i], :] is the row in Y that is closest to X[i, :].\n430 \n431     See also\n432     --------\n433     sklearn.metrics.pairwise_distances\n434     sklearn.metrics.pairwise_distances_argmin_min\n435     \"\"\"\n436     if metric_kwargs is None:\n437         metric_kwargs = {}\n438 \n439     return pairwise_distances_argmin_min(X, Y, axis, metric,\n440                                          metric_kwargs=metric_kwargs,\n441                                          batch_size=batch_size)[0]\n442 \n443 \n444 def haversine_distances(X, Y=None):\n445     \"\"\"Compute the Haversine distance between samples in X and Y\n446 \n447     The Haversine (or great circle) distance is the angular distance between\n448     two points on the surface of a sphere. The first distance of each point is\n449     assumed to be the latitude, the second is the longitude, given in radians.\n450     The dimension of the data must be 2.\n451 \n452     .. math::\n453        D(x, y) = 2\\arcsin[\\\\sqrt{\\\\sin^2((x1 - y1) / 2)\n454                                 + cos(x1)cos(y1)sin^2((x2 - y2) / 2)}]\n455 \n456     Parameters\n457     ----------\n458     X : array_like, shape (n_samples_1, 2)\n459 \n460     Y : array_like, shape (n_samples_2, 2), optional\n461 \n462     Returns\n463     -------\n464     distance : {array}, shape (n_samples_1, n_samples_2)\n465 \n466     Notes\n467     -----\n468     As the Earth is nearly spherical, the haversine formula provides a good\n469     approximation of the distance between two points of the Earth surface, with\n470     a less than 1% error on average.\n471 \n472     Examples\n473     --------\n474     We want to calculate the distance between the Ezeiza Airport\n475     (Buenos Aires, Argentina) and the Charles de Gaulle Airport (Paris, France)\n476 \n477     >>> from sklearn.metrics.pairwise import haversine_distances\n478     >>> bsas = [-34.83333, -58.5166646]\n479     >>> paris = [49.0083899664, 2.53844117956]\n480     >>> result = haversine_distances([bsas, paris])\n481     >>> result * 6371000/1000  # multiply by Earth radius to get kilometers\n482     array([[    0.        , 11279.45379464],\n483            [11279.45379464,     0.        ]])\n484     \"\"\"\n485     from sklearn.neighbors import DistanceMetric\n486     return DistanceMetric.get_metric('haversine').pairwise(X, Y)\n487 \n488 \n489 def manhattan_distances(X, Y=None, sum_over_features=True):\n490     \"\"\" Compute the L1 distances between the vectors in X and Y.\n491 \n492     With sum_over_features equal to False it returns the componentwise\n493     distances.\n494 \n495     Read more in the :ref:`User Guide <metrics>`.\n496 \n497     Parameters\n498     ----------\n499     X : array_like\n500         An array with shape (n_samples_X, n_features).\n501 \n502     Y : array_like, optional\n503         An array with shape (n_samples_Y, n_features).\n504 \n505     sum_over_features : bool, default=True\n506         If True the function returns the pairwise distance matrix\n507         else it returns the componentwise L1 pairwise-distances.\n508         Not supported for sparse matrix inputs.\n509 \n510     Returns\n511     -------\n512     D : array\n513         If sum_over_features is False shape is\n514         (n_samples_X * n_samples_Y, n_features) and D contains the\n515         componentwise L1 pairwise-distances (ie. absolute difference),\n516         else shape is (n_samples_X, n_samples_Y) and D contains\n517         the pairwise L1 distances.\n518 \n519     Examples\n520     --------\n521     >>> from sklearn.metrics.pairwise import manhattan_distances\n522     >>> manhattan_distances([[3]], [[3]])#doctest:+ELLIPSIS\n523     array([[0.]])\n524     >>> manhattan_distances([[3]], [[2]])#doctest:+ELLIPSIS\n525     array([[1.]])\n526     >>> manhattan_distances([[2]], [[3]])#doctest:+ELLIPSIS\n527     array([[1.]])\n528     >>> manhattan_distances([[1, 2], [3, 4]],\\\n529          [[1, 2], [0, 3]])#doctest:+ELLIPSIS\n530     array([[0., 2.],\n531            [4., 4.]])\n532     >>> import numpy as np\n533     >>> X = np.ones((1, 2))\n534     >>> y = np.full((2, 2), 2.)\n535     >>> manhattan_distances(X, y, sum_over_features=False)#doctest:+ELLIPSIS\n536     array([[1., 1.],\n537            [1., 1.]])\n538     \"\"\"\n539     X, Y = check_pairwise_arrays(X, Y)\n540 \n541     if issparse(X) or issparse(Y):\n542         if not sum_over_features:\n543             raise TypeError(\"sum_over_features=%r not supported\"\n544                             \" for sparse matrices\" % sum_over_features)\n545 \n546         X = csr_matrix(X, copy=False)\n547         Y = csr_matrix(Y, copy=False)\n548         D = np.zeros((X.shape[0], Y.shape[0]))\n549         _sparse_manhattan(X.data, X.indices, X.indptr,\n550                           Y.data, Y.indices, Y.indptr,\n551                           X.shape[1], D)\n552         return D\n553 \n554     if sum_over_features:\n555         return distance.cdist(X, Y, 'cityblock')\n556 \n557     D = X[:, np.newaxis, :] - Y[np.newaxis, :, :]\n558     D = np.abs(D, D)\n559     return D.reshape((-1, X.shape[1]))\n560 \n561 \n562 def cosine_distances(X, Y=None):\n563     \"\"\"Compute cosine distance between samples in X and Y.\n564 \n565     Cosine distance is defined as 1.0 minus the cosine similarity.\n566 \n567     Read more in the :ref:`User Guide <metrics>`.\n568 \n569     Parameters\n570     ----------\n571     X : array_like, sparse matrix\n572         with shape (n_samples_X, n_features).\n573 \n574     Y : array_like, sparse matrix (optional)\n575         with shape (n_samples_Y, n_features).\n576 \n577     Returns\n578     -------\n579     distance matrix : array\n580         An array with shape (n_samples_X, n_samples_Y).\n581 \n582     See also\n583     --------\n584     sklearn.metrics.pairwise.cosine_similarity\n585     scipy.spatial.distance.cosine : dense matrices only\n586     \"\"\"\n587     # 1.0 - cosine_similarity(X, Y) without copy\n588     S = cosine_similarity(X, Y)\n589     S *= -1\n590     S += 1\n591     np.clip(S, 0, 2, out=S)\n592     if X is Y or Y is None:\n593         # Ensure that distances between vectors and themselves are set to 0.0.\n594         # This may not be the case due to floating point rounding errors.\n595         S[np.diag_indices_from(S)] = 0.0\n596     return S\n597 \n598 \n599 # Paired distances\n600 def paired_euclidean_distances(X, Y):\n601     \"\"\"\n602     Computes the paired euclidean distances between X and Y\n603 \n604     Read more in the :ref:`User Guide <metrics>`.\n605 \n606     Parameters\n607     ----------\n608     X : array-like, shape (n_samples, n_features)\n609 \n610     Y : array-like, shape (n_samples, n_features)\n611 \n612     Returns\n613     -------\n614     distances : ndarray (n_samples, )\n615     \"\"\"\n616     X, Y = check_paired_arrays(X, Y)\n617     return row_norms(X - Y)\n618 \n619 \n620 def paired_manhattan_distances(X, Y):\n621     \"\"\"Compute the L1 distances between the vectors in X and Y.\n622 \n623     Read more in the :ref:`User Guide <metrics>`.\n624 \n625     Parameters\n626     ----------\n627     X : array-like, shape (n_samples, n_features)\n628 \n629     Y : array-like, shape (n_samples, n_features)\n630 \n631     Returns\n632     -------\n633     distances : ndarray (n_samples, )\n634     \"\"\"\n635     X, Y = check_paired_arrays(X, Y)\n636     diff = X - Y\n637     if issparse(diff):\n638         diff.data = np.abs(diff.data)\n639         return np.squeeze(np.array(diff.sum(axis=1)))\n640     else:\n641         return np.abs(diff).sum(axis=-1)\n642 \n643 \n644 def paired_cosine_distances(X, Y):\n645     \"\"\"\n646     Computes the paired cosine distances between X and Y\n647 \n648     Read more in the :ref:`User Guide <metrics>`.\n649 \n650     Parameters\n651     ----------\n652     X : array-like, shape (n_samples, n_features)\n653 \n654     Y : array-like, shape (n_samples, n_features)\n655 \n656     Returns\n657     -------\n658     distances : ndarray, shape (n_samples, )\n659 \n660     Notes\n661     ------\n662     The cosine distance is equivalent to the half the squared\n663     euclidean distance if each sample is normalized to unit norm\n664     \"\"\"\n665     X, Y = check_paired_arrays(X, Y)\n666     return .5 * row_norms(normalize(X) - normalize(Y), squared=True)\n667 \n668 \n669 PAIRED_DISTANCES = {\n670     'cosine': paired_cosine_distances,\n671     'euclidean': paired_euclidean_distances,\n672     'l2': paired_euclidean_distances,\n673     'l1': paired_manhattan_distances,\n674     'manhattan': paired_manhattan_distances,\n675     'cityblock': paired_manhattan_distances}\n676 \n677 \n678 def paired_distances(X, Y, metric=\"euclidean\", **kwds):\n679     \"\"\"\n680     Computes the paired distances between X and Y.\n681 \n682     Computes the distances between (X[0], Y[0]), (X[1], Y[1]), etc...\n683 \n684     Read more in the :ref:`User Guide <metrics>`.\n685 \n686     Parameters\n687     ----------\n688     X : ndarray (n_samples, n_features)\n689         Array 1 for distance computation.\n690 \n691     Y : ndarray (n_samples, n_features)\n692         Array 2 for distance computation.\n693 \n694     metric : string or callable\n695         The metric to use when calculating distance between instances in a\n696         feature array. If metric is a string, it must be one of the options\n697         specified in PAIRED_DISTANCES, including \"euclidean\",\n698         \"manhattan\", or \"cosine\".\n699         Alternatively, if metric is a callable function, it is called on each\n700         pair of instances (rows) and the resulting value recorded. The callable\n701         should take two arrays from X as input and return a value indicating\n702         the distance between them.\n703 \n704     Returns\n705     -------\n706     distances : ndarray (n_samples, )\n707 \n708     Examples\n709     --------\n710     >>> from sklearn.metrics.pairwise import paired_distances\n711     >>> X = [[0, 1], [1, 1]]\n712     >>> Y = [[0, 1], [2, 1]]\n713     >>> paired_distances(X, Y)\n714     array([0., 1.])\n715 \n716     See also\n717     --------\n718     pairwise_distances : Computes the distance between every pair of samples\n719     \"\"\"\n720 \n721     if metric in PAIRED_DISTANCES:\n722         func = PAIRED_DISTANCES[metric]\n723         return func(X, Y)\n724     elif callable(metric):\n725         # Check the matrix first (it is usually done by the metric)\n726         X, Y = check_paired_arrays(X, Y)\n727         distances = np.zeros(len(X))\n728         for i in range(len(X)):\n729             distances[i] = metric(X[i], Y[i])\n730         return distances\n731     else:\n732         raise ValueError('Unknown distance %s' % metric)\n733 \n734 \n735 # Kernels\n736 def linear_kernel(X, Y=None, dense_output=True):\n737     \"\"\"\n738     Compute the linear kernel between X and Y.\n739 \n740     Read more in the :ref:`User Guide <linear_kernel>`.\n741 \n742     Parameters\n743     ----------\n744     X : array of shape (n_samples_1, n_features)\n745 \n746     Y : array of shape (n_samples_2, n_features)\n747 \n748     dense_output : boolean (optional), default True\n749         Whether to return dense output even when the input is sparse. If\n750         ``False``, the output is sparse if both input arrays are sparse.\n751 \n752         .. versionadded:: 0.20\n753 \n754     Returns\n755     -------\n756     Gram matrix : array of shape (n_samples_1, n_samples_2)\n757     \"\"\"\n758     X, Y = check_pairwise_arrays(X, Y)\n759     return safe_sparse_dot(X, Y.T, dense_output=dense_output)\n760 \n761 \n762 def polynomial_kernel(X, Y=None, degree=3, gamma=None, coef0=1):\n763     \"\"\"\n764     Compute the polynomial kernel between X and Y::\n765 \n766         K(X, Y) = (gamma <X, Y> + coef0)^degree\n767 \n768     Read more in the :ref:`User Guide <polynomial_kernel>`.\n769 \n770     Parameters\n771     ----------\n772     X : ndarray of shape (n_samples_1, n_features)\n773 \n774     Y : ndarray of shape (n_samples_2, n_features)\n775 \n776     degree : int, default 3\n777 \n778     gamma : float, default None\n779         if None, defaults to 1.0 / n_features\n780 \n781     coef0 : float, default 1\n782 \n783     Returns\n784     -------\n785     Gram matrix : array of shape (n_samples_1, n_samples_2)\n786     \"\"\"\n787     X, Y = check_pairwise_arrays(X, Y)\n788     if gamma is None:\n789         gamma = 1.0 / X.shape[1]\n790 \n791     K = safe_sparse_dot(X, Y.T, dense_output=True)\n792     K *= gamma\n793     K += coef0\n794     K **= degree\n795     return K\n796 \n797 \n798 def sigmoid_kernel(X, Y=None, gamma=None, coef0=1):\n799     \"\"\"\n800     Compute the sigmoid kernel between X and Y::\n801 \n802         K(X, Y) = tanh(gamma <X, Y> + coef0)\n803 \n804     Read more in the :ref:`User Guide <sigmoid_kernel>`.\n805 \n806     Parameters\n807     ----------\n808     X : ndarray of shape (n_samples_1, n_features)\n809 \n810     Y : ndarray of shape (n_samples_2, n_features)\n811 \n812     gamma : float, default None\n813         If None, defaults to 1.0 / n_features\n814 \n815     coef0 : float, default 1\n816 \n817     Returns\n818     -------\n819     Gram matrix : array of shape (n_samples_1, n_samples_2)\n820     \"\"\"\n821     X, Y = check_pairwise_arrays(X, Y)\n822     if gamma is None:\n823         gamma = 1.0 / X.shape[1]\n824 \n825     K = safe_sparse_dot(X, Y.T, dense_output=True)\n826     K *= gamma\n827     K += coef0\n828     np.tanh(K, K)   # compute tanh in-place\n829     return K\n830 \n831 \n832 def rbf_kernel(X, Y=None, gamma=None):\n833     \"\"\"\n834     Compute the rbf (gaussian) kernel between X and Y::\n835 \n836         K(x, y) = exp(-gamma ||x-y||^2)\n837 \n838     for each pair of rows x in X and y in Y.\n839 \n840     Read more in the :ref:`User Guide <rbf_kernel>`.\n841 \n842     Parameters\n843     ----------\n844     X : array of shape (n_samples_X, n_features)\n845 \n846     Y : array of shape (n_samples_Y, n_features)\n847 \n848     gamma : float, default None\n849         If None, defaults to 1.0 / n_features\n850 \n851     Returns\n852     -------\n853     kernel_matrix : array of shape (n_samples_X, n_samples_Y)\n854     \"\"\"\n855     X, Y = check_pairwise_arrays(X, Y)\n856     if gamma is None:\n857         gamma = 1.0 / X.shape[1]\n858 \n859     K = euclidean_distances(X, Y, squared=True)\n860     K *= -gamma\n861     np.exp(K, K)    # exponentiate K in-place\n862     return K\n863 \n864 \n865 def laplacian_kernel(X, Y=None, gamma=None):\n866     \"\"\"Compute the laplacian kernel between X and Y.\n867 \n868     The laplacian kernel is defined as::\n869 \n870         K(x, y) = exp(-gamma ||x-y||_1)\n871 \n872     for each pair of rows x in X and y in Y.\n873     Read more in the :ref:`User Guide <laplacian_kernel>`.\n874 \n875     .. versionadded:: 0.17\n876 \n877     Parameters\n878     ----------\n879     X : array of shape (n_samples_X, n_features)\n880 \n881     Y : array of shape (n_samples_Y, n_features)\n882 \n883     gamma : float, default None\n884         If None, defaults to 1.0 / n_features\n885 \n886     Returns\n887     -------\n888     kernel_matrix : array of shape (n_samples_X, n_samples_Y)\n889     \"\"\"\n890     X, Y = check_pairwise_arrays(X, Y)\n891     if gamma is None:\n892         gamma = 1.0 / X.shape[1]\n893 \n894     K = -gamma * manhattan_distances(X, Y)\n895     np.exp(K, K)    # exponentiate K in-place\n896     return K\n897 \n898 \n899 def cosine_similarity(X, Y=None, dense_output=True):\n900     \"\"\"Compute cosine similarity between samples in X and Y.\n901 \n902     Cosine similarity, or the cosine kernel, computes similarity as the\n903     normalized dot product of X and Y:\n904 \n905         K(X, Y) = <X, Y> / (||X||*||Y||)\n906 \n907     On L2-normalized data, this function is equivalent to linear_kernel.\n908 \n909     Read more in the :ref:`User Guide <cosine_similarity>`.\n910 \n911     Parameters\n912     ----------\n913     X : ndarray or sparse array, shape: (n_samples_X, n_features)\n914         Input data.\n915 \n916     Y : ndarray or sparse array, shape: (n_samples_Y, n_features)\n917         Input data. If ``None``, the output will be the pairwise\n918         similarities between all samples in ``X``.\n919 \n920     dense_output : boolean (optional), default True\n921         Whether to return dense output even when the input is sparse. If\n922         ``False``, the output is sparse if both input arrays are sparse.\n923 \n924         .. versionadded:: 0.17\n925            parameter ``dense_output`` for dense output.\n926 \n927     Returns\n928     -------\n929     kernel matrix : array\n930         An array with shape (n_samples_X, n_samples_Y).\n931     \"\"\"\n932     # to avoid recursive import\n933 \n934     X, Y = check_pairwise_arrays(X, Y)\n935 \n936     X_normalized = normalize(X, copy=True)\n937     if X is Y:\n938         Y_normalized = X_normalized\n939     else:\n940         Y_normalized = normalize(Y, copy=True)\n941 \n942     K = safe_sparse_dot(X_normalized, Y_normalized.T,\n943                         dense_output=dense_output)\n944 \n945     return K\n946 \n947 \n948 def additive_chi2_kernel(X, Y=None):\n949     \"\"\"Computes the additive chi-squared kernel between observations in X and Y\n950 \n951     The chi-squared kernel is computed between each pair of rows in X and Y.  X\n952     and Y have to be non-negative. This kernel is most commonly applied to\n953     histograms.\n954 \n955     The chi-squared kernel is given by::\n956 \n957         k(x, y) = -Sum [(x - y)^2 / (x + y)]\n958 \n959     It can be interpreted as a weighted difference per entry.\n960 \n961     Read more in the :ref:`User Guide <chi2_kernel>`.\n962 \n963     Notes\n964     -----\n965     As the negative of a distance, this kernel is only conditionally positive\n966     definite.\n967 \n968 \n969     Parameters\n970     ----------\n971     X : array-like of shape (n_samples_X, n_features)\n972 \n973     Y : array of shape (n_samples_Y, n_features)\n974 \n975     Returns\n976     -------\n977     kernel_matrix : array of shape (n_samples_X, n_samples_Y)\n978 \n979     References\n980     ----------\n981     * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.\n982       Local features and kernels for classification of texture and object\n983       categories: A comprehensive study\n984       International Journal of Computer Vision 2007\n985       https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf\n986 \n987 \n988     See also\n989     --------\n990     chi2_kernel : The exponentiated version of the kernel, which is usually\n991         preferable.\n992 \n993     sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation\n994         to this kernel.\n995     \"\"\"\n996     if issparse(X) or issparse(Y):\n997         raise ValueError(\"additive_chi2 does not support sparse matrices.\")\n998     X, Y = check_pairwise_arrays(X, Y)\n999     if (X < 0).any():\n1000         raise ValueError(\"X contains negative values.\")\n1001     if Y is not X and (Y < 0).any():\n1002         raise ValueError(\"Y contains negative values.\")\n1003 \n1004     result = np.zeros((X.shape[0], Y.shape[0]), dtype=X.dtype)\n1005     _chi2_kernel_fast(X, Y, result)\n1006     return result\n1007 \n1008 \n1009 def chi2_kernel(X, Y=None, gamma=1.):\n1010     \"\"\"Computes the exponential chi-squared kernel X and Y.\n1011 \n1012     The chi-squared kernel is computed between each pair of rows in X and Y.  X\n1013     and Y have to be non-negative. This kernel is most commonly applied to\n1014     histograms.\n1015 \n1016     The chi-squared kernel is given by::\n1017 \n1018         k(x, y) = exp(-gamma Sum [(x - y)^2 / (x + y)])\n1019 \n1020     It can be interpreted as a weighted difference per entry.\n1021 \n1022     Read more in the :ref:`User Guide <chi2_kernel>`.\n1023 \n1024     Parameters\n1025     ----------\n1026     X : array-like of shape (n_samples_X, n_features)\n1027 \n1028     Y : array of shape (n_samples_Y, n_features)\n1029 \n1030     gamma : float, default=1.\n1031         Scaling parameter of the chi2 kernel.\n1032 \n1033     Returns\n1034     -------\n1035     kernel_matrix : array of shape (n_samples_X, n_samples_Y)\n1036 \n1037     References\n1038     ----------\n1039     * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C.\n1040       Local features and kernels for classification of texture and object\n1041       categories: A comprehensive study\n1042       International Journal of Computer Vision 2007\n1043       https://research.microsoft.com/en-us/um/people/manik/projects/trade-off/papers/ZhangIJCV06.pdf\n1044 \n1045     See also\n1046     --------\n1047     additive_chi2_kernel : The additive version of this kernel\n1048 \n1049     sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation\n1050         to the additive version of this kernel.\n1051     \"\"\"\n1052     K = additive_chi2_kernel(X, Y)\n1053     K *= gamma\n1054     return np.exp(K, K)\n1055 \n1056 \n1057 # Helper functions - distance\n1058 PAIRWISE_DISTANCE_FUNCTIONS = {\n1059     # If updating this dictionary, update the doc in both distance_metrics()\n1060     # and also in pairwise_distances()!\n1061     'cityblock': manhattan_distances,\n1062     'cosine': cosine_distances,\n1063     'euclidean': euclidean_distances,\n1064     'haversine': haversine_distances,\n1065     'l2': euclidean_distances,\n1066     'l1': manhattan_distances,\n1067     'manhattan': manhattan_distances,\n1068     'precomputed': None,  # HACK: precomputed is always allowed, never called\n1069 }\n1070 \n1071 \n1072 def distance_metrics():\n1073     \"\"\"Valid metrics for pairwise_distances.\n1074 \n1075     This function simply returns the valid pairwise distance metrics.\n1076     It exists to allow for a description of the mapping for\n1077     each of the valid strings.\n1078 \n1079     The valid distance metrics, and the function they map to, are:\n1080 \n1081     ============     ====================================\n1082     metric           Function\n1083     ============     ====================================\n1084     'cityblock'      metrics.pairwise.manhattan_distances\n1085     'cosine'         metrics.pairwise.cosine_distances\n1086     'euclidean'      metrics.pairwise.euclidean_distances\n1087     'haversine'      metrics.pairwise.haversine_distances\n1088     'l1'             metrics.pairwise.manhattan_distances\n1089     'l2'             metrics.pairwise.euclidean_distances\n1090     'manhattan'      metrics.pairwise.manhattan_distances\n1091     ============     ====================================\n1092 \n1093     Read more in the :ref:`User Guide <metrics>`.\n1094 \n1095     \"\"\"\n1096     return PAIRWISE_DISTANCE_FUNCTIONS\n1097 \n1098 \n1099 def _dist_wrapper(dist_func, dist_matrix, slice_, *args, **kwargs):\n1100     \"\"\"Write in-place to a slice of a distance matrix\"\"\"\n1101     dist_matrix[:, slice_] = dist_func(*args, **kwargs)\n1102 \n1103 \n1104 def _parallel_pairwise(X, Y, func, n_jobs, **kwds):\n1105     \"\"\"Break the pairwise matrix in n_jobs even slices\n1106     and compute them in parallel\"\"\"\n1107 \n1108     if Y is None:\n1109         Y = X\n1110 \n1111     if effective_n_jobs(n_jobs) == 1:\n1112         return func(X, Y, **kwds)\n1113 \n1114     # enforce a threading backend to prevent data communication overhead\n1115     fd = delayed(_dist_wrapper)\n1116     ret = np.empty((X.shape[0], Y.shape[0]), dtype=X.dtype, order='F')\n1117     Parallel(backend=\"threading\", n_jobs=n_jobs)(\n1118         fd(func, ret, s, X, Y[s], **kwds)\n1119         for s in gen_even_slices(_num_samples(Y), effective_n_jobs(n_jobs)))\n1120 \n1121     return ret\n1122 \n1123 \n1124 def _pairwise_callable(X, Y, metric, **kwds):\n1125     \"\"\"Handle the callable case for pairwise_{distances,kernels}\n1126     \"\"\"\n1127     X, Y = check_pairwise_arrays(X, Y)\n1128 \n1129     if X is Y:\n1130         # Only calculate metric for upper triangle\n1131         out = np.zeros((X.shape[0], Y.shape[0]), dtype='float')\n1132         iterator = itertools.combinations(range(X.shape[0]), 2)\n1133         for i, j in iterator:\n1134             out[i, j] = metric(X[i], Y[j], **kwds)\n1135 \n1136         # Make symmetric\n1137         # NB: out += out.T will produce incorrect results\n1138         out = out + out.T\n1139 \n1140         # Calculate diagonal\n1141         # NB: nonzero diagonals are allowed for both metrics and kernels\n1142         for i in range(X.shape[0]):\n1143             x = X[i]\n1144             out[i, i] = metric(x, x, **kwds)\n1145 \n1146     else:\n1147         # Calculate all cells\n1148         out = np.empty((X.shape[0], Y.shape[0]), dtype='float')\n1149         iterator = itertools.product(range(X.shape[0]), range(Y.shape[0]))\n1150         for i, j in iterator:\n1151             out[i, j] = metric(X[i], Y[j], **kwds)\n1152 \n1153     return out\n1154 \n1155 \n1156 _VALID_METRICS = ['euclidean', 'l2', 'l1', 'manhattan', 'cityblock',\n1157                   'braycurtis', 'canberra', 'chebyshev', 'correlation',\n1158                   'cosine', 'dice', 'hamming', 'jaccard', 'kulsinski',\n1159                   'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',\n1160                   'russellrao', 'seuclidean', 'sokalmichener',\n1161                   'sokalsneath', 'sqeuclidean', 'yule', 'wminkowski',\n1162                   'haversine']\n1163 \n1164 \n1165 def _check_chunk_size(reduced, chunk_size):\n1166     \"\"\"Checks chunk is a sequence of expected size or a tuple of same\n1167     \"\"\"\n1168     is_tuple = isinstance(reduced, tuple)\n1169     if not is_tuple:\n1170         reduced = (reduced,)\n1171     if any(isinstance(r, tuple) or not hasattr(r, '__iter__')\n1172            for r in reduced):\n1173         raise TypeError('reduce_func returned %r. '\n1174                         'Expected sequence(s) of length %d.' %\n1175                         (reduced if is_tuple else reduced[0], chunk_size))\n1176     if any(_num_samples(r) != chunk_size for r in reduced):\n1177         actual_size = tuple(_num_samples(r) for r in reduced)\n1178         raise ValueError('reduce_func returned object of length %s. '\n1179                          'Expected same length as input: %d.' %\n1180                          (actual_size if is_tuple else actual_size[0],\n1181                           chunk_size))\n1182 \n1183 \n1184 def _precompute_metric_params(X, Y, metric=None, **kwds):\n1185     \"\"\"Precompute data-derived metric parameters if not provided\n1186     \"\"\"\n1187     if metric == \"seuclidean\" and 'V' not in kwds:\n1188         if X is Y:\n1189             V = np.var(X, axis=0, ddof=1)\n1190         else:\n1191             V = np.var(np.vstack([X, Y]), axis=0, ddof=1)\n1192         return {'V': V}\n1193     if metric == \"mahalanobis\" and 'VI' not in kwds:\n1194         if X is Y:\n1195             VI = np.linalg.inv(np.cov(X.T)).T\n1196         else:\n1197             VI = np.linalg.inv(np.cov(np.vstack([X, Y]).T)).T\n1198         return {'VI': VI}\n1199     return {}\n1200 \n1201 \n1202 def pairwise_distances_chunked(X, Y=None, reduce_func=None,\n1203                                metric='euclidean', n_jobs=None,\n1204                                working_memory=None, **kwds):\n1205     \"\"\"Generate a distance matrix chunk by chunk with optional reduction\n1206 \n1207     In cases where not all of a pairwise distance matrix needs to be stored at\n1208     once, this is used to calculate pairwise distances in\n1209     ``working_memory``-sized chunks.  If ``reduce_func`` is given, it is run\n1210     on each chunk and its return values are concatenated into lists, arrays\n1211     or sparse matrices.\n1212 \n1213     Parameters\n1214     ----------\n1215     X : array [n_samples_a, n_samples_a] if metric == \"precomputed\", or,\n1216         [n_samples_a, n_features] otherwise\n1217         Array of pairwise distances between samples, or a feature array.\n1218 \n1219     Y : array [n_samples_b, n_features], optional\n1220         An optional second feature array. Only allowed if\n1221         metric != \"precomputed\".\n1222 \n1223     reduce_func : callable, optional\n1224         The function which is applied on each chunk of the distance matrix,\n1225         reducing it to needed values.  ``reduce_func(D_chunk, start)``\n1226         is called repeatedly, where ``D_chunk`` is a contiguous vertical\n1227         slice of the pairwise distance matrix, starting at row ``start``.\n1228         It should return an array, a list, or a sparse matrix of length\n1229         ``D_chunk.shape[0]``, or a tuple of such objects.\n1230 \n1231         If None, pairwise_distances_chunked returns a generator of vertical\n1232         chunks of the distance matrix.\n1233 \n1234     metric : string, or callable\n1235         The metric to use when calculating distance between instances in a\n1236         feature array. If metric is a string, it must be one of the options\n1237         allowed by scipy.spatial.distance.pdist for its metric parameter, or\n1238         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\n1239         If metric is \"precomputed\", X is assumed to be a distance matrix.\n1240         Alternatively, if metric is a callable function, it is called on each\n1241         pair of instances (rows) and the resulting value recorded. The callable\n1242         should take two arrays from X as input and return a value indicating\n1243         the distance between them.\n1244 \n1245     n_jobs : int or None, optional (default=None)\n1246         The number of jobs to use for the computation. This works by breaking\n1247         down the pairwise matrix into n_jobs even slices and computing them in\n1248         parallel.\n1249 \n1250         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n1251         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n1252         for more details.\n1253 \n1254     working_memory : int, optional\n1255         The sought maximum memory for temporary distance matrix chunks.\n1256         When None (default), the value of\n1257         ``sklearn.get_config()['working_memory']`` is used.\n1258 \n1259     `**kwds` : optional keyword parameters\n1260         Any further parameters are passed directly to the distance function.\n1261         If using a scipy.spatial.distance metric, the parameters are still\n1262         metric dependent. See the scipy docs for usage examples.\n1263 \n1264     Yields\n1265     ------\n1266     D_chunk : array or sparse matrix\n1267         A contiguous slice of distance matrix, optionally processed by\n1268         ``reduce_func``.\n1269 \n1270     Examples\n1271     --------\n1272     Without reduce_func:\n1273 \n1274     >>> import numpy as np\n1275     >>> from sklearn.metrics import pairwise_distances_chunked\n1276     >>> X = np.random.RandomState(0).rand(5, 3)\n1277     >>> D_chunk = next(pairwise_distances_chunked(X))\n1278     >>> D_chunk  # doctest: +ELLIPSIS\n1279     array([[0.  ..., 0.29..., 0.41..., 0.19..., 0.57...],\n1280            [0.29..., 0.  ..., 0.57..., 0.41..., 0.76...],\n1281            [0.41..., 0.57..., 0.  ..., 0.44..., 0.90...],\n1282            [0.19..., 0.41..., 0.44..., 0.  ..., 0.51...],\n1283            [0.57..., 0.76..., 0.90..., 0.51..., 0.  ...]])\n1284 \n1285     Retrieve all neighbors and average distance within radius r:\n1286 \n1287     >>> r = .2\n1288     >>> def reduce_func(D_chunk, start):\n1289     ...     neigh = [np.flatnonzero(d < r) for d in D_chunk]\n1290     ...     avg_dist = (D_chunk * (D_chunk < r)).mean(axis=1)\n1291     ...     return neigh, avg_dist\n1292     >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func)\n1293     >>> neigh, avg_dist = next(gen)\n1294     >>> neigh\n1295     [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])]\n1296     >>> avg_dist  # doctest: +ELLIPSIS\n1297     array([0.039..., 0.        , 0.        , 0.039..., 0.        ])\n1298 \n1299     Where r is defined per sample, we need to make use of ``start``:\n1300 \n1301     >>> r = [.2, .4, .4, .3, .1]\n1302     >>> def reduce_func(D_chunk, start):\n1303     ...     neigh = [np.flatnonzero(d < r[i])\n1304     ...              for i, d in enumerate(D_chunk, start)]\n1305     ...     return neigh\n1306     >>> neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func))\n1307     >>> neigh\n1308     [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])]\n1309 \n1310     Force row-by-row generation by reducing ``working_memory``:\n1311 \n1312     >>> gen = pairwise_distances_chunked(X, reduce_func=reduce_func,\n1313     ...                                  working_memory=0)\n1314     >>> next(gen)\n1315     [array([0, 3])]\n1316     >>> next(gen)\n1317     [array([0, 1])]\n1318     \"\"\"\n1319     n_samples_X = _num_samples(X)\n1320     if metric == 'precomputed':\n1321         slices = (slice(0, n_samples_X),)\n1322     else:\n1323         if Y is None:\n1324             Y = X\n1325         # We get as many rows as possible within our working_memory budget to\n1326         # store len(Y) distances in each row of output.\n1327         #\n1328         # Note:\n1329         #  - this will get at least 1 row, even if 1 row of distances will\n1330         #    exceed working_memory.\n1331         #  - this does not account for any temporary memory usage while\n1332         #    calculating distances (e.g. difference of vectors in manhattan\n1333         #    distance.\n1334         chunk_n_rows = get_chunk_n_rows(row_bytes=8 * _num_samples(Y),\n1335                                         max_n_rows=n_samples_X,\n1336                                         working_memory=working_memory)\n1337         slices = gen_batches(n_samples_X, chunk_n_rows)\n1338 \n1339     # precompute data-derived metric params\n1340     params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n1341     kwds.update(**params)\n1342 \n1343     for sl in slices:\n1344         if sl.start == 0 and sl.stop == n_samples_X:\n1345             X_chunk = X  # enable optimised paths for X is Y\n1346         else:\n1347             X_chunk = X[sl]\n1348         D_chunk = pairwise_distances(X_chunk, Y, metric=metric,\n1349                                      n_jobs=n_jobs, **kwds)\n1350         if ((X is Y or Y is None)\n1351                 and PAIRWISE_DISTANCE_FUNCTIONS.get(metric, None)\n1352                 is euclidean_distances):\n1353             # zeroing diagonal, taking care of aliases of \"euclidean\",\n1354             # i.e. \"l2\"\n1355             D_chunk.flat[sl.start::_num_samples(X) + 1] = 0\n1356         if reduce_func is not None:\n1357             chunk_size = D_chunk.shape[0]\n1358             D_chunk = reduce_func(D_chunk, sl.start)\n1359             _check_chunk_size(D_chunk, chunk_size)\n1360         yield D_chunk\n1361 \n1362 \n1363 def pairwise_distances(X, Y=None, metric=\"euclidean\", n_jobs=None, **kwds):\n1364     \"\"\" Compute the distance matrix from a vector array X and optional Y.\n1365 \n1366     This method takes either a vector array or a distance matrix, and returns\n1367     a distance matrix. If the input is a vector array, the distances are\n1368     computed. If the input is a distances matrix, it is returned instead.\n1369 \n1370     This method provides a safe way to take a distance matrix as input, while\n1371     preserving compatibility with many other algorithms that take a vector\n1372     array.\n1373 \n1374     If Y is given (default is None), then the returned matrix is the pairwise\n1375     distance between the arrays from both X and Y.\n1376 \n1377     Valid values for metric are:\n1378 \n1379     - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2',\n1380       'manhattan']. These metrics support sparse matrix inputs.\n1381 \n1382     - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev',\n1383       'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis',\n1384       'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean',\n1385       'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule']\n1386       See the documentation for scipy.spatial.distance for details on these\n1387       metrics. These metrics do not support sparse matrix inputs.\n1388 \n1389     Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are\n1390     valid scipy.spatial.distance metrics), the scikit-learn implementation\n1391     will be used, which is faster and has support for sparse matrices (except\n1392     for 'cityblock'). For a verbose description of the metrics from\n1393     scikit-learn, see the __doc__ of the sklearn.pairwise.distance_metrics\n1394     function.\n1395 \n1396     Read more in the :ref:`User Guide <metrics>`.\n1397 \n1398     Parameters\n1399     ----------\n1400     X : array [n_samples_a, n_samples_a] if metric == \"precomputed\", or, \\\n1401              [n_samples_a, n_features] otherwise\n1402         Array of pairwise distances between samples, or a feature array.\n1403 \n1404     Y : array [n_samples_b, n_features], optional\n1405         An optional second feature array. Only allowed if\n1406         metric != \"precomputed\".\n1407 \n1408     metric : string, or callable\n1409         The metric to use when calculating distance between instances in a\n1410         feature array. If metric is a string, it must be one of the options\n1411         allowed by scipy.spatial.distance.pdist for its metric parameter, or\n1412         a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS.\n1413         If metric is \"precomputed\", X is assumed to be a distance matrix.\n1414         Alternatively, if metric is a callable function, it is called on each\n1415         pair of instances (rows) and the resulting value recorded. The callable\n1416         should take two arrays from X as input and return a value indicating\n1417         the distance between them.\n1418 \n1419     n_jobs : int or None, optional (default=None)\n1420         The number of jobs to use for the computation. This works by breaking\n1421         down the pairwise matrix into n_jobs even slices and computing them in\n1422         parallel.\n1423 \n1424         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n1425         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n1426         for more details.\n1427 \n1428     **kwds : optional keyword parameters\n1429         Any further parameters are passed directly to the distance function.\n1430         If using a scipy.spatial.distance metric, the parameters are still\n1431         metric dependent. See the scipy docs for usage examples.\n1432 \n1433     Returns\n1434     -------\n1435     D : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]\n1436         A distance matrix D such that D_{i, j} is the distance between the\n1437         ith and jth vectors of the given matrix X, if Y is None.\n1438         If Y is not None, then D_{i, j} is the distance between the ith array\n1439         from X and the jth array from Y.\n1440 \n1441     See also\n1442     --------\n1443     pairwise_distances_chunked : performs the same calculation as this\n1444         function, but returns a generator of chunks of the distance matrix, in\n1445         order to limit memory usage.\n1446     paired_distances : Computes the distances between corresponding\n1447                        elements of two arrays\n1448     \"\"\"\n1449     if (metric not in _VALID_METRICS and\n1450             not callable(metric) and metric != \"precomputed\"):\n1451         raise ValueError(\"Unknown metric %s. \"\n1452                          \"Valid metrics are %s, or 'precomputed', or a \"\n1453                          \"callable\" % (metric, _VALID_METRICS))\n1454 \n1455     if metric == \"precomputed\":\n1456         X, _ = check_pairwise_arrays(X, Y, precomputed=True)\n1457 \n1458         whom = (\"`pairwise_distances`. Precomputed distance \"\n1459                 \" need to have non-negative values.\")\n1460         check_non_negative(X, whom=whom)\n1461         return X\n1462     elif metric in PAIRWISE_DISTANCE_FUNCTIONS:\n1463         func = PAIRWISE_DISTANCE_FUNCTIONS[metric]\n1464     elif callable(metric):\n1465         func = partial(_pairwise_callable, metric=metric, **kwds)\n1466     else:\n1467         if issparse(X) or issparse(Y):\n1468             raise TypeError(\"scipy distance metrics do not\"\n1469                             \" support sparse matrices.\")\n1470 \n1471         dtype = bool if metric in PAIRWISE_BOOLEAN_FUNCTIONS else None\n1472 \n1473         if dtype == bool and (X.dtype != bool or Y.dtype != bool):\n1474             msg = \"Data was converted to boolean for metric %s\" % metric\n1475             warnings.warn(msg, DataConversionWarning)\n1476 \n1477         X, Y = check_pairwise_arrays(X, Y, dtype=dtype)\n1478 \n1479         # precompute data-derived metric params\n1480         params = _precompute_metric_params(X, Y, metric=metric, **kwds)\n1481         kwds.update(**params)\n1482 \n1483         if effective_n_jobs(n_jobs) == 1 and X is Y:\n1484             return distance.squareform(distance.pdist(X, metric=metric,\n1485                                                       **kwds))\n1486         func = partial(distance.cdist, metric=metric, **kwds)\n1487 \n1488     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)\n1489 \n1490 \n1491 # These distances recquire boolean arrays, when using scipy.spatial.distance\n1492 PAIRWISE_BOOLEAN_FUNCTIONS = [\n1493     'dice',\n1494     'jaccard',\n1495     'kulsinski',\n1496     'matching',\n1497     'rogerstanimoto',\n1498     'russellrao',\n1499     'sokalmichener',\n1500     'sokalsneath',\n1501     'yule',\n1502 ]\n1503 \n1504 \n1505 # Helper functions - distance\n1506 PAIRWISE_KERNEL_FUNCTIONS = {\n1507     # If updating this dictionary, update the doc in both distance_metrics()\n1508     # and also in pairwise_distances()!\n1509     'additive_chi2': additive_chi2_kernel,\n1510     'chi2': chi2_kernel,\n1511     'linear': linear_kernel,\n1512     'polynomial': polynomial_kernel,\n1513     'poly': polynomial_kernel,\n1514     'rbf': rbf_kernel,\n1515     'laplacian': laplacian_kernel,\n1516     'sigmoid': sigmoid_kernel,\n1517     'cosine': cosine_similarity, }\n1518 \n1519 \n1520 def kernel_metrics():\n1521     \"\"\" Valid metrics for pairwise_kernels\n1522 \n1523     This function simply returns the valid pairwise distance metrics.\n1524     It exists, however, to allow for a verbose description of the mapping for\n1525     each of the valid strings.\n1526 \n1527     The valid distance metrics, and the function they map to, are:\n1528       ===============   ========================================\n1529       metric            Function\n1530       ===============   ========================================\n1531       'additive_chi2'   sklearn.pairwise.additive_chi2_kernel\n1532       'chi2'            sklearn.pairwise.chi2_kernel\n1533       'linear'          sklearn.pairwise.linear_kernel\n1534       'poly'            sklearn.pairwise.polynomial_kernel\n1535       'polynomial'      sklearn.pairwise.polynomial_kernel\n1536       'rbf'             sklearn.pairwise.rbf_kernel\n1537       'laplacian'       sklearn.pairwise.laplacian_kernel\n1538       'sigmoid'         sklearn.pairwise.sigmoid_kernel\n1539       'cosine'          sklearn.pairwise.cosine_similarity\n1540       ===============   ========================================\n1541 \n1542     Read more in the :ref:`User Guide <metrics>`.\n1543     \"\"\"\n1544     return PAIRWISE_KERNEL_FUNCTIONS\n1545 \n1546 \n1547 KERNEL_PARAMS = {\n1548     \"additive_chi2\": (),\n1549     \"chi2\": frozenset([\"gamma\"]),\n1550     \"cosine\": (),\n1551     \"linear\": (),\n1552     \"poly\": frozenset([\"gamma\", \"degree\", \"coef0\"]),\n1553     \"polynomial\": frozenset([\"gamma\", \"degree\", \"coef0\"]),\n1554     \"rbf\": frozenset([\"gamma\"]),\n1555     \"laplacian\": frozenset([\"gamma\"]),\n1556     \"sigmoid\": frozenset([\"gamma\", \"coef0\"]),\n1557 }\n1558 \n1559 \n1560 def pairwise_kernels(X, Y=None, metric=\"linear\", filter_params=False,\n1561                      n_jobs=None, **kwds):\n1562     \"\"\"Compute the kernel between arrays X and optional array Y.\n1563 \n1564     This method takes either a vector array or a kernel matrix, and returns\n1565     a kernel matrix. If the input is a vector array, the kernels are\n1566     computed. If the input is a kernel matrix, it is returned instead.\n1567 \n1568     This method provides a safe way to take a kernel matrix as input, while\n1569     preserving compatibility with many other algorithms that take a vector\n1570     array.\n1571 \n1572     If Y is given (default is None), then the returned matrix is the pairwise\n1573     kernel between the arrays from both X and Y.\n1574 \n1575     Valid values for metric are::\n1576         ['rbf', 'sigmoid', 'polynomial', 'poly', 'linear', 'cosine']\n1577 \n1578     Read more in the :ref:`User Guide <metrics>`.\n1579 \n1580     Parameters\n1581     ----------\n1582     X : array [n_samples_a, n_samples_a] if metric == \"precomputed\", or, \\\n1583              [n_samples_a, n_features] otherwise\n1584         Array of pairwise kernels between samples, or a feature array.\n1585 \n1586     Y : array [n_samples_b, n_features]\n1587         A second feature array only if X has shape [n_samples_a, n_features].\n1588 \n1589     metric : string, or callable\n1590         The metric to use when calculating kernel between instances in a\n1591         feature array. If metric is a string, it must be one of the metrics\n1592         in pairwise.PAIRWISE_KERNEL_FUNCTIONS.\n1593         If metric is \"precomputed\", X is assumed to be a kernel matrix.\n1594         Alternatively, if metric is a callable function, it is called on each\n1595         pair of instances (rows) and the resulting value recorded. The callable\n1596         should take two arrays from X as input and return a value indicating\n1597         the distance between them.\n1598 \n1599     filter_params : boolean\n1600         Whether to filter invalid parameters or not.\n1601 \n1602     n_jobs : int or None, optional (default=None)\n1603         The number of jobs to use for the computation. This works by breaking\n1604         down the pairwise matrix into n_jobs even slices and computing them in\n1605         parallel.\n1606 \n1607         ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n1608         ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n1609         for more details.\n1610 \n1611     **kwds : optional keyword parameters\n1612         Any further parameters are passed directly to the kernel function.\n1613 \n1614     Returns\n1615     -------\n1616     K : array [n_samples_a, n_samples_a] or [n_samples_a, n_samples_b]\n1617         A kernel matrix K such that K_{i, j} is the kernel between the\n1618         ith and jth vectors of the given matrix X, if Y is None.\n1619         If Y is not None, then K_{i, j} is the kernel between the ith array\n1620         from X and the jth array from Y.\n1621 \n1622     Notes\n1623     -----\n1624     If metric is 'precomputed', Y is ignored and X is returned.\n1625 \n1626     \"\"\"\n1627     # import GPKernel locally to prevent circular imports\n1628     from ..gaussian_process.kernels import Kernel as GPKernel\n1629 \n1630     if metric == \"precomputed\":\n1631         X, _ = check_pairwise_arrays(X, Y, precomputed=True)\n1632         return X\n1633     elif isinstance(metric, GPKernel):\n1634         func = metric.__call__\n1635     elif metric in PAIRWISE_KERNEL_FUNCTIONS:\n1636         if filter_params:\n1637             kwds = {k: kwds[k] for k in kwds\n1638                     if k in KERNEL_PARAMS[metric]}\n1639         func = PAIRWISE_KERNEL_FUNCTIONS[metric]\n1640     elif callable(metric):\n1641         func = partial(_pairwise_callable, metric=metric, **kwds)\n1642     else:\n1643         raise ValueError(\"Unknown kernel %r\" % metric)\n1644 \n1645     return _parallel_pairwise(X, Y, func, n_jobs, **kwds)\n",
        "intended_behavior": "Although a specific method wasn't identified due to lack of precise match in the search results, the changes should conceptually address optimizations around memory usage and block-wise operations as mentioned in the issue. This includes ensuring that any blocks cast to `float64` for the purpose of improving precision do not inadvertently cause mismatches or precision loss when the original data was in `float32`. Implementing or refining a mechanism to dynamically calculate the optimal block size based on the input data type and available memory, ensuring symmetry in distance computations (i.e., between `X` and `Y`), and accurately copying results between blocks could achieve this. This might involve reviewing and potentially revising the logic that handles these aspects, ensuring that enhancements for handling `float32` do not compromise performance or accuracy for other types. Adjustments or additional logic may need to be integrated to ensure that the handling of `X_norm_squared` and potential `Y_norm_squared` during these operations aligns with the goal of precise and efficient distance computations for all supported data types, including `float32`."
    }
]