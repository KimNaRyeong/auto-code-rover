[
    {
        "rel_file_path": "sphinx/roles.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/roles.py",
        "start": 1,
        "end": 630,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.roles\n3     ~~~~~~~~~~~~\n4 \n5     Handlers for additional ReST roles.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import warnings\n13 from typing import Any, Dict, List, Tuple\n14 \n15 from docutils import nodes, utils\n16 from docutils.nodes import Element, Node, TextElement, system_message\n17 from docutils.parsers.rst.states import Inliner\n18 \n19 from sphinx import addnodes\n20 from sphinx.deprecation import RemovedInSphinx40Warning\n21 from sphinx.locale import _\n22 from sphinx.util import ws_re\n23 from sphinx.util.docutils import ReferenceRole, SphinxRole\n24 from sphinx.util.nodes import (\n25     split_explicit_title, process_index_entry, set_role_source_info\n26 )\n27 from sphinx.util.typing import RoleFunction\n28 \n29 if False:\n30     # For type annotation\n31     from typing import Type  # for python3.5.1\n32     from sphinx.application import Sphinx\n33     from sphinx.environment import BuildEnvironment\n34 \n35 \n36 generic_docroles = {\n37     'command': addnodes.literal_strong,\n38     'dfn': nodes.emphasis,\n39     'kbd': nodes.literal,\n40     'mailheader': addnodes.literal_emphasis,\n41     'makevar': addnodes.literal_strong,\n42     'manpage': addnodes.manpage,\n43     'mimetype': addnodes.literal_emphasis,\n44     'newsgroup': addnodes.literal_emphasis,\n45     'program': addnodes.literal_strong,  # XXX should be an x-ref\n46     'regexp': nodes.literal,\n47 }\n48 \n49 \n50 # -- generic cross-reference role ----------------------------------------------\n51 \n52 class XRefRole(ReferenceRole):\n53     \"\"\"\n54     A generic cross-referencing role.  To create a callable that can be used as\n55     a role function, create an instance of this class.\n56 \n57     The general features of this role are:\n58 \n59     * Automatic creation of a reference and a content node.\n60     * Optional separation of title and target with `title <target>`.\n61     * The implementation is a class rather than a function to make\n62       customization easier.\n63 \n64     Customization can be done in two ways:\n65 \n66     * Supplying constructor parameters:\n67       * `fix_parens` to normalize parentheses (strip from target, and add to\n68         title if configured)\n69       * `lowercase` to lowercase the target\n70       * `nodeclass` and `innernodeclass` select the node classes for\n71         the reference and the content node\n72 \n73     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.\n74     \"\"\"\n75 \n76     nodeclass = addnodes.pending_xref   # type: Type[Element]\n77     innernodeclass = nodes.literal      # type: Type[TextElement]\n78 \n79     def __init__(self, fix_parens: bool = False, lowercase: bool = False,\n80                  nodeclass: \"Type[Element]\" = None, innernodeclass: \"Type[TextElement]\" = None,\n81                  warn_dangling: bool = False) -> None:\n82         self.fix_parens = fix_parens\n83         self.lowercase = lowercase\n84         self.warn_dangling = warn_dangling\n85         if nodeclass is not None:\n86             self.nodeclass = nodeclass\n87         if innernodeclass is not None:\n88             self.innernodeclass = innernodeclass\n89 \n90         super().__init__()\n91 \n92     def _fix_parens(self, env: \"BuildEnvironment\", has_explicit_title: bool, title: str,\n93                     target: str) -> Tuple[str, str]:\n94         warnings.warn('XRefRole._fix_parens() is deprecated.',\n95                       RemovedInSphinx40Warning, stacklevel=2)\n96         if not has_explicit_title:\n97             if title.endswith('()'):\n98                 # remove parentheses\n99                 title = title[:-2]\n100             if env.config.add_function_parentheses:\n101                 # add them back to all occurrences if configured\n102                 title += '()'\n103         # remove parentheses from the target too\n104         if target.endswith('()'):\n105             target = target[:-2]\n106         return title, target\n107 \n108     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:\n109         if not self.has_explicit_title:\n110             if title.endswith('()'):\n111                 # remove parentheses\n112                 title = title[:-2]\n113             if self.config.add_function_parentheses:\n114                 # add them back to all occurrences if configured\n115                 title += '()'\n116         # remove parentheses from the target too\n117         if target.endswith('()'):\n118             target = target[:-2]\n119         return title, target\n120 \n121     def run(self) -> Tuple[List[Node], List[system_message]]:\n122         if ':' not in self.name:\n123             self.refdomain, self.reftype = '', self.name\n124             self.classes = ['xref', self.reftype]\n125         else:\n126             self.refdomain, self.reftype = self.name.split(':', 1)\n127             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]\n128 \n129         if self.disabled:\n130             return self.create_non_xref_node()\n131         else:\n132             return self.create_xref_node()\n133 \n134     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n135         text = utils.unescape(self.text[1:])\n136         if self.fix_parens:\n137             self.has_explicit_title = False  # treat as implicit\n138             text, target = self.update_title_and_target(text, \"\")\n139 \n140         node = self.innernodeclass(self.rawtext, text, classes=self.classes)\n141         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)\n142 \n143     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n144         target = self.target\n145         title = self.title\n146         if self.lowercase:\n147             target = target.lower()\n148         if self.fix_parens:\n149             title, target = self.update_title_and_target(title, target)\n150 \n151         # create the reference node\n152         options = {'refdoc': self.env.docname,\n153                    'refdomain': self.refdomain,\n154                    'reftype': self.reftype,\n155                    'refexplicit': self.has_explicit_title,\n156                    'refwarn': self.warn_dangling}\n157         refnode = self.nodeclass(self.rawtext, **options)\n158         self.set_source_info(refnode)\n159 \n160         # determine the target and title for the class\n161         title, target = self.process_link(self.env, refnode, self.has_explicit_title,\n162                                           title, target)\n163         refnode['reftarget'] = target\n164         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)\n165 \n166         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)\n167 \n168     # methods that can be overwritten\n169 \n170     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n171                      title: str, target: str) -> Tuple[str, str]:\n172         \"\"\"Called after parsing title and target text, and creating the\n173         reference node (given in *refnode*).  This method can alter the\n174         reference node and must return a new (or the same) ``(title, target)``\n175         tuple.\n176         \"\"\"\n177         return title, ws_re.sub(' ', target)\n178 \n179     def result_nodes(self, document: nodes.document, env: \"BuildEnvironment\", node: Element,\n180                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n181         \"\"\"Called before returning the finished nodes.  *node* is the reference\n182         node if one was created (*is_ref* is then true), else the content node.\n183         This method can add other nodes and must return a ``(nodes, messages)``\n184         tuple (the usual return value of a role function).\n185         \"\"\"\n186         return [node], []\n187 \n188 \n189 class AnyXRefRole(XRefRole):\n190     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n191                      title: str, target: str) -> Tuple[str, str]:\n192         result = super().process_link(env, refnode, has_explicit_title, title, target)\n193         # add all possible context info (i.e. std:program, py:module etc.)\n194         refnode.attributes.update(env.ref_context)\n195         return result\n196 \n197 \n198 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n199                      options: Dict = {}, content: List[str] = []\n200                      ) -> Tuple[List[Node], List[system_message]]:\n201     \"\"\"Role for PEP/RFC references that generate an index entry.\"\"\"\n202     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',\n203                   RemovedInSphinx40Warning, stacklevel=2)\n204     env = inliner.document.settings.env\n205     if not typ:\n206         assert env.temp_data['default_role']\n207         typ = env.temp_data['default_role'].lower()\n208     else:\n209         typ = typ.lower()\n210 \n211     has_explicit_title, title, target = split_explicit_title(text)\n212     title = utils.unescape(title)\n213     target = utils.unescape(target)\n214     targetid = 'index-%s' % env.new_serialno('index')\n215     indexnode = addnodes.index()\n216     targetnode = nodes.target('', '', ids=[targetid])\n217     inliner.document.note_explicit_target(targetnode)\n218     if typ == 'pep':\n219         indexnode['entries'] = [\n220             ('single', _('Python Enhancement Proposals; PEP %s') % target,\n221              targetid, '', None)]\n222         anchor = ''\n223         anchorindex = target.find('#')\n224         if anchorindex > 0:\n225             target, anchor = target[:anchorindex], target[anchorindex:]\n226         if not has_explicit_title:\n227             title = \"PEP \" + utils.unescape(title)\n228         try:\n229             pepnum = int(target)\n230         except ValueError:\n231             msg = inliner.reporter.error('invalid PEP number %s' % target,\n232                                          line=lineno)\n233             prb = inliner.problematic(rawtext, rawtext, msg)\n234             return [prb], [msg]\n235         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum\n236         sn = nodes.strong(title, title)\n237         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,\n238                              classes=[typ])\n239         rn += sn\n240         return [indexnode, targetnode, rn], []\n241     elif typ == 'rfc':\n242         indexnode['entries'] = [\n243             ('single', 'RFC; RFC %s' % target, targetid, '', None)]\n244         anchor = ''\n245         anchorindex = target.find('#')\n246         if anchorindex > 0:\n247             target, anchor = target[:anchorindex], target[anchorindex:]\n248         if not has_explicit_title:\n249             title = \"RFC \" + utils.unescape(title)\n250         try:\n251             rfcnum = int(target)\n252         except ValueError:\n253             msg = inliner.reporter.error('invalid RFC number %s' % target,\n254                                          line=lineno)\n255             prb = inliner.problematic(rawtext, rawtext, msg)\n256             return [prb], [msg]\n257         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum\n258         sn = nodes.strong(title, title)\n259         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,\n260                              classes=[typ])\n261         rn += sn\n262         return [indexnode, targetnode, rn], []\n263     else:\n264         raise ValueError('unknown role type: %s' % typ)\n265 \n266 \n267 class PEP(ReferenceRole):\n268     def run(self) -> Tuple[List[Node], List[system_message]]:\n269         target_id = 'index-%s' % self.env.new_serialno('index')\n270         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,\n271                     target_id, '', None)]\n272 \n273         index = addnodes.index(entries=entries)\n274         target = nodes.target('', '', ids=[target_id])\n275         self.inliner.document.note_explicit_target(target)\n276 \n277         try:\n278             refuri = self.build_uri()\n279             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])\n280             if self.has_explicit_title:\n281                 reference += nodes.strong(self.title, self.title)\n282             else:\n283                 title = \"PEP \" + self.title\n284                 reference += nodes.strong(title, title)\n285         except ValueError:\n286             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,\n287                                               line=self.lineno)\n288             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n289             return [prb], [msg]\n290 \n291         return [index, target, reference], []\n292 \n293     def build_uri(self) -> str:\n294         base_url = self.inliner.document.settings.pep_base_url\n295         ret = self.target.split('#', 1)\n296         if len(ret) == 2:\n297             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])\n298         else:\n299             return base_url + 'pep-%04d' % int(ret[0])\n300 \n301 \n302 class RFC(ReferenceRole):\n303     def run(self) -> Tuple[List[Node], List[system_message]]:\n304         target_id = 'index-%s' % self.env.new_serialno('index')\n305         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]\n306 \n307         index = addnodes.index(entries=entries)\n308         target = nodes.target('', '', ids=[target_id])\n309         self.inliner.document.note_explicit_target(target)\n310 \n311         try:\n312             refuri = self.build_uri()\n313             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])\n314             if self.has_explicit_title:\n315                 reference += nodes.strong(self.title, self.title)\n316             else:\n317                 title = \"RFC \" + self.title\n318                 reference += nodes.strong(title, title)\n319         except ValueError:\n320             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,\n321                                               line=self.lineno)\n322             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n323             return [prb], [msg]\n324 \n325         return [index, target, reference], []\n326 \n327     def build_uri(self) -> str:\n328         base_url = self.inliner.document.settings.rfc_base_url\n329         ret = self.target.split('#', 1)\n330         if len(ret) == 2:\n331             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]\n332         else:\n333             return base_url + self.inliner.rfc_url % int(ret[0])\n334 \n335 \n336 _amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n337 \n338 \n339 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n340                  options: Dict = {}, content: List[str] = []\n341                  ) -> Tuple[List[Node], List[system_message]]:\n342     warnings.warn('menusel_role() is deprecated. '\n343                   'Please use MenuSelection or GUILabel class instead.',\n344                   RemovedInSphinx40Warning, stacklevel=2)\n345     env = inliner.document.settings.env\n346     if not typ:\n347         assert env.temp_data['default_role']\n348         typ = env.temp_data['default_role'].lower()\n349     else:\n350         typ = typ.lower()\n351 \n352     text = utils.unescape(text)\n353     if typ == 'menuselection':\n354         text = text.replace('-->', '\\N{TRIANGULAR BULLET}')\n355     spans = _amp_re.split(text)\n356 \n357     node = nodes.inline(rawtext=rawtext)\n358     for i, span in enumerate(spans):\n359         span = span.replace('&&', '&')\n360         if i == 0:\n361             if len(span) > 0:\n362                 textnode = nodes.Text(span)\n363                 node += textnode\n364             continue\n365         accel_node = nodes.inline()\n366         letter_node = nodes.Text(span[0])\n367         accel_node += letter_node\n368         accel_node['classes'].append('accelerator')\n369         node += accel_node\n370         textnode = nodes.Text(span[1:])\n371         node += textnode\n372 \n373     node['classes'].append(typ)\n374     return [node], []\n375 \n376 \n377 class GUILabel(SphinxRole):\n378     amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n379 \n380     def run(self) -> Tuple[List[Node], List[system_message]]:\n381         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])\n382         spans = self.amp_re.split(self.text)\n383         node += nodes.Text(spans.pop(0))\n384         for span in spans:\n385             span = span.replace('&&', '&')\n386 \n387             letter = nodes.Text(span[0])\n388             accelerator = nodes.inline('', '', letter, classes=['accelerator'])\n389             node += accelerator\n390             node += nodes.Text(span[1:])\n391 \n392         return [node], []\n393 \n394 \n395 class MenuSelection(GUILabel):\n396     BULLET_CHARACTER = '\\N{TRIANGULAR BULLET}'\n397 \n398     def run(self) -> Tuple[List[Node], List[system_message]]:\n399         self.text = self.text.replace('-->', self.BULLET_CHARACTER)\n400         return super().run()\n401 \n402 \n403 _litvar_re = re.compile('{([^}]+)}')\n404 parens_re = re.compile(r'(\\\\*{|\\\\*})')\n405 \n406 \n407 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n408                       options: Dict = {}, content: List[str] = []\n409                       ) -> Tuple[List[Node], List[system_message]]:\n410     warnings.warn('emph_literal_role() is deprecated. '\n411                   'Please use EmphasizedLiteral class instead.',\n412                   RemovedInSphinx40Warning, stacklevel=2)\n413     env = inliner.document.settings.env\n414     if not typ:\n415         assert env.temp_data['default_role']\n416         typ = env.temp_data['default_role'].lower()\n417     else:\n418         typ = typ.lower()\n419 \n420     retnode = nodes.literal(role=typ.lower(), classes=[typ])\n421     parts = list(parens_re.split(utils.unescape(text)))\n422     stack = ['']\n423     for part in parts:\n424         matched = parens_re.match(part)\n425         if matched:\n426             backslashes = len(part) - 1\n427             if backslashes % 2 == 1:    # escaped\n428                 stack[-1] += \"\\\\\" * int((backslashes - 1) / 2) + part[-1]\n429             elif part[-1] == '{':       # rparen\n430                 stack[-1] += \"\\\\\" * int(backslashes / 2)\n431                 if len(stack) >= 2 and stack[-2] == \"{\":\n432                     # nested\n433                     stack[-1] += \"{\"\n434                 else:\n435                     # start emphasis\n436                     stack.append('{')\n437                     stack.append('')\n438             else:                       # lparen\n439                 stack[-1] += \"\\\\\" * int(backslashes / 2)\n440                 if len(stack) == 3 and stack[1] == \"{\" and len(stack[2]) > 0:\n441                     # emphasized word found\n442                     if stack[0]:\n443                         retnode += nodes.Text(stack[0], stack[0])\n444                     retnode += nodes.emphasis(stack[2], stack[2])\n445                     stack = ['']\n446                 else:\n447                     # emphasized word not found; the rparen is not a special symbol\n448                     stack.append('}')\n449                     stack = [''.join(stack)]\n450         else:\n451             stack[-1] += part\n452     if ''.join(stack):\n453         # remaining is treated as Text\n454         text = ''.join(stack)\n455         retnode += nodes.Text(text, text)\n456 \n457     return [retnode], []\n458 \n459 \n460 class EmphasizedLiteral(SphinxRole):\n461     parens_re = re.compile(r'(\\\\\\\\|\\\\{|\\\\}|{|})')\n462 \n463     def run(self) -> Tuple[List[Node], List[system_message]]:\n464         children = self.parse(self.text)\n465         node = nodes.literal(self.rawtext, '', *children,\n466                              role=self.name.lower(), classes=[self.name])\n467 \n468         return [node], []\n469 \n470     def parse(self, text: str) -> List[Node]:\n471         result = []  # type: List[Node]\n472 \n473         stack = ['']\n474         for part in self.parens_re.split(text):\n475             if part == '\\\\\\\\':  # escaped backslash\n476                 stack[-1] += '\\\\'\n477             elif part == '{':\n478                 if len(stack) >= 2 and stack[-2] == \"{\":  # nested\n479                     stack[-1] += \"{\"\n480                 else:\n481                     # start emphasis\n482                     stack.append('{')\n483                     stack.append('')\n484             elif part == '}':\n485                 if len(stack) == 3 and stack[1] == \"{\" and len(stack[2]) > 0:\n486                     # emphasized word found\n487                     if stack[0]:\n488                         result.append(nodes.Text(stack[0], stack[0]))\n489                     result.append(nodes.emphasis(stack[2], stack[2]))\n490                     stack = ['']\n491                 else:\n492                     # emphasized word not found; the rparen is not a special symbol\n493                     stack.append('}')\n494                     stack = [''.join(stack)]\n495             elif part == '\\\\{':  # escaped left-brace\n496                 stack[-1] += '{'\n497             elif part == '\\\\}':  # escaped right-brace\n498                 stack[-1] += '}'\n499             else:  # others (containing escaped braces)\n500                 stack[-1] += part\n501 \n502         if ''.join(stack):\n503             # remaining is treated as Text\n504             text = ''.join(stack)\n505             result.append(nodes.Text(text, text))\n506 \n507         return result\n508 \n509 \n510 _abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n511 \n512 \n513 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n514               options: Dict = {}, content: List[str] = []\n515               ) -> Tuple[List[Node], List[system_message]]:\n516     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',\n517                   RemovedInSphinx40Warning, stacklevel=2)\n518     text = utils.unescape(text)\n519     m = _abbr_re.search(text)\n520     if m is None:\n521         return [nodes.abbreviation(text, text, **options)], []\n522     abbr = text[:m.start()].strip()\n523     expl = m.group(1)\n524     options = options.copy()\n525     options['explanation'] = expl\n526     return [nodes.abbreviation(abbr, abbr, **options)], []\n527 \n528 \n529 class Abbreviation(SphinxRole):\n530     abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n531 \n532     def run(self) -> Tuple[List[Node], List[system_message]]:\n533         matched = self.abbr_re.search(self.text)\n534         if matched:\n535             text = self.text[:matched.start()].strip()\n536             self.options['explanation'] = matched.group(1)\n537         else:\n538             text = self.text\n539 \n540         return [nodes.abbreviation(self.rawtext, text, **self.options)], []\n541 \n542 \n543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n544                options: Dict = {}, content: List[str] = []\n545                ) -> Tuple[List[Node], List[system_message]]:\n546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',\n547                   RemovedInSphinx40Warning, stacklevel=2)\n548     # create new reference target\n549     env = inliner.document.settings.env\n550     targetid = 'index-%s' % env.new_serialno('index')\n551     targetnode = nodes.target('', '', ids=[targetid])\n552     # split text and target in role content\n553     has_explicit_title, title, target = split_explicit_title(text)\n554     title = utils.unescape(title)\n555     target = utils.unescape(target)\n556     # if an explicit target is given, we can process it as a full entry\n557     if has_explicit_title:\n558         entries = process_index_entry(target, targetid)\n559     # otherwise we just create a \"single\" entry\n560     else:\n561         # but allow giving main entry\n562         main = ''\n563         if target.startswith('!'):\n564             target = target[1:]\n565             title = title[1:]\n566             main = 'main'\n567         entries = [('single', target, targetid, main, None)]\n568     indexnode = addnodes.index()\n569     indexnode['entries'] = entries\n570     set_role_source_info(inliner, lineno, indexnode)\n571     textnode = nodes.Text(title, title)\n572     return [indexnode, targetnode, textnode], []\n573 \n574 \n575 class Index(ReferenceRole):\n576     def run(self) -> Tuple[List[Node], List[system_message]]:\n577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning)\n578         target_id = 'index-%s' % self.env.new_serialno('index')\n579         if self.has_explicit_title:\n580             # if an explicit target is given, process it as a full entry\n581             title = self.title\n582             entries = process_index_entry(self.target, target_id)\n583         else:\n584             # otherwise we just create a single entry\n585             if self.target.startswith('!'):\n586                 title = self.title[1:]\n587                 entries = [('single', self.target[1:], target_id, 'main', None)]\n588             else:\n589                 title = self.title\n590                 entries = [('single', self.target, target_id, '', None)]\n591 \n592         index = addnodes.index(entries=entries)\n593         target = nodes.target('', '', ids=[target_id])\n594         text = nodes.Text(title, title)\n595         self.set_source_info(index)\n596         return [index, target, text], []\n597 \n598 \n599 specific_docroles = {\n600     # links to download references\n601     'download': XRefRole(nodeclass=addnodes.download_reference),\n602     # links to anything\n603     'any': AnyXRefRole(warn_dangling=True),\n604 \n605     'pep': PEP(),\n606     'rfc': RFC(),\n607     'guilabel': GUILabel(),\n608     'menuselection': MenuSelection(),\n609     'file': EmphasizedLiteral(),\n610     'samp': EmphasizedLiteral(),\n611     'abbr': Abbreviation(),\n612 }  # type: Dict[str, RoleFunction]\n613 \n614 \n615 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n616     from docutils.parsers.rst import roles\n617 \n618     for rolename, nodeclass in generic_docroles.items():\n619         generic = roles.GenericRole(rolename, nodeclass)\n620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})\n621         roles.register_local_role(rolename, role)\n622 \n623     for rolename, func in specific_docroles.items():\n624         roles.register_local_role(rolename, func)\n625 \n626     return {\n627         'version': 'builtin',\n628         'parallel_read_safe': True,\n629         'parallel_write_safe': True,\n630     }\n",
        "intended_behavior": "The code in this file should include either the addition of a new custom role for `:kbd:` that contains logic for parsing the text content of the role to identify individual keystrokes or key sequences and construct nested or individual `<kbd>` HTML elements accordingly. This would involve parsing the input text to separate keys or key combinations and wrapping them in `<kbd>` tags, supporting both the individual and nested output formats as described in the issue."
    }
]