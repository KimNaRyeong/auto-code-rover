2025-10-18 18:10:32.344 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 18:10:35.439 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=438, output_tokens=12, cost=0.004740
2025-10-18 18:10:35.440 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 18:10:35.444 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:10:46.234 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=742, output_tokens=405, cost=0.019570
2025-10-18 18:10:46.238 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:10:49.532 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=759, output_tokens=75, cost=0.009840
2025-10-18 18:10:49.534 | DEBUG    | Extracted a valid json.
2025-10-18 18:10:49.534 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Role\")",
        "search_class(\"Roles\")",
        "search_method(\"process_roles\")",
        "search_method(\"role\")",
        "search_method_in_class(\"visit_kbd\", \"RoleVisitor\")",
        "search_code(\"visit_kbd\")"
    ],
    "bug_locations": []
}
2025-10-18 18:10:49.569 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:10:49.570 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:11:05.049 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2117, output_tokens=708, cost=0.042410
2025-10-18 18:11:05.063 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:11:15.257 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3041, output_tokens=480, cost=0.044810
2025-10-18 18:11:15.266 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:11:20.662 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=834, output_tokens=196, cost=0.014220
2025-10-18 18:11:20.663 | DEBUG    | Extracted a valid json.
2025-10-18 18:11:20.663 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\":kbd:\")",
        "search_code(\"roles.register_local_role\")"
    ],
    "bug_locations": [
        {
            "file": "sphinx/domains/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "A new or modified method should interpret the `:kbd:` directive's content, breaking it down into individual keys or key combinations and wrapping them in separate `<kbd>` HTML elements for semantic correctness and enhanced browser rendering. This method must be capable of handling complex inputs where keys are combined with modifiers (e.g., Control, Alt) or sequential inputs and producing nested or sequential `<kbd>` tags as illustrated in the issue description. The functionality should allow configuration or by default produce nested `<kbd>` elements to follow the MDN recommendation for key combinations, ensuring backward compatibility for documents expecting a single `<kbd>` tag."
        }
    ]
}
2025-10-18 18:11:20.702 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:11:20.703 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:11:36.573 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3981, output_tokens=699, cost=0.060780
2025-10-18 18:11:36.587 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:11:47.557 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4896, output_tokens=468, cost=0.063000
2025-10-18 18:11:47.566 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:11:51.489 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=822, output_tokens=135, cost=0.012270
2025-10-18 18:11:51.490 | DEBUG    | Extracted a valid json.
2025-10-18 18:11:51.491 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/roles.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code in this file should include either the addition of a new custom role for `:kbd:` that contains logic for parsing the text content of the role to identify individual keystrokes or key sequences and construct nested or individual `<kbd>` HTML elements accordingly. This would involve parsing the input text to separate keys or key combinations and wrapping them in `<kbd>` tags, supporting both the individual and nested output formats as described in the issue."
        }
    ]
}
2025-10-18 18:11:51.495 | DEBUG    | Bug location extracted successfully: [<file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.roles
3     ~~~~~~~~~~~~
4 
5     Handlers for additional ReST roles.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import Any, Dict, List, Tuple
14 
15 from docutils import nodes, utils
16 from docutils.nodes import Element, Node, TextElement, system_message
17 from docutils.parsers.rst.states import Inliner
18 
19 from sphinx import addnodes
20 from sphinx.deprecation import RemovedInSphinx40Warning
21 from sphinx.locale import _
22 from sphinx.util import ws_re
23 from sphinx.util.docutils import ReferenceRole, SphinxRole
24 from sphinx.util.nodes import (
25     split_explicit_title, process_index_entry, set_role_source_info
26 )
27 from sphinx.util.typing import RoleFunction
28 
29 if False:
30     # For type annotation
31     from typing import Type  # for python3.5.1
32     from sphinx.application import Sphinx
33     from sphinx.environment import BuildEnvironment
34 
35 
36 generic_docroles = {
37     'command': addnodes.literal_strong,
38     'dfn': nodes.emphasis,
39     'kbd': nodes.literal,
40     'mailheader': addnodes.literal_emphasis,
41     'makevar': addnodes.literal_strong,
42     'manpage': addnodes.manpage,
43     'mimetype': addnodes.literal_emphasis,
44     'newsgroup': addnodes.literal_emphasis,
45     'program': addnodes.literal_strong,  # XXX should be an x-ref
46     'regexp': nodes.literal,
47 }
48 
49 
50 # -- generic cross-reference role ----------------------------------------------
51 
52 class XRefRole(ReferenceRole):
53     """
54     A generic cross-referencing role.  To create a callable that can be used as
55     a role function, create an instance of this class.
56 
57     The general features of this role are:
58 
59     * Automatic creation of a reference and a content node.
60     * Optional separation of title and target with `title <target>`.
61     * The implementation is a class rather than a function to make
62       customization easier.
63 
64     Customization can be done in two ways:
65 
66     * Supplying constructor parameters:
67       * `fix_parens` to normalize parentheses (strip from target, and add to
68         title if configured)
69       * `lowercase` to lowercase the target
70       * `nodeclass` and `innernodeclass` select the node classes for
71         the reference and the content node
72 
73     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
74     """
75 
76     nodeclass = addnodes.pending_xref   # type: Type[Element]
77     innernodeclass = nodes.literal      # type: Type[TextElement]
78 
79     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
80                  nodeclass: "Type[Element]" = None, innernodeclass: "Type[TextElement]" = None,
81                  warn_dangling: bool = False) -> None:
82         self.fix_parens = fix_parens
83         self.lowercase = lowercase
84         self.warn_dangling = warn_dangling
85         if nodeclass is not None:
86             self.nodeclass = nodeclass
87         if innernodeclass is not None:
88             self.innernodeclass = innernodeclass
89 
90         super().__init__()
91 
92     def _fix_parens(self, env: "BuildEnvironment", has_explicit_title: bool, title: str,
93                     target: str) -> Tuple[str, str]:
94         warnings.warn('XRefRole._fix_parens() is deprecated.',
95                       RemovedInSphinx40Warning, stacklevel=2)
96         if not has_explicit_title:
97             if title.endswith('()'):
98                 # remove parentheses
99                 title = title[:-2]
100             if env.config.add_function_parentheses:
101                 # add them back to all occurrences if configured
102                 title += '()'
103         # remove parentheses from the target too
104         if target.endswith('()'):
105             target = target[:-2]
106         return title, target
107 
108     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
109         if not self.has_explicit_title:
110             if title.endswith('()'):
111                 # remove parentheses
112                 title = title[:-2]
113             if self.config.add_function_parentheses:
114                 # add them back to all occurrences if configured
115                 title += '()'
116         # remove parentheses from the target too
117         if target.endswith('()'):
118             target = target[:-2]
119         return title, target
120 
121     def run(self) -> Tuple[List[Node], List[system_message]]:
122         if ':' not in self.name:
123             self.refdomain, self.reftype = '', self.name
124             self.classes = ['xref', self.reftype]
125         else:
126             self.refdomain, self.reftype = self.name.split(':', 1)
127             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
128 
129         if self.disabled:
130             return self.create_non_xref_node()
131         else:
132             return self.create_xref_node()
133 
134     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
135         text = utils.unescape(self.text[1:])
136         if self.fix_parens:
137             self.has_explicit_title = False  # treat as implicit
138             text, target = self.update_title_and_target(text, "")
139 
140         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
141         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
142 
143     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
144         target = self.target
145         title = self.title
146         if self.lowercase:
147             target = target.lower()
148         if self.fix_parens:
149             title, target = self.update_title_and_target(title, target)
150 
151         # create the reference node
152         options = {'refdoc': self.env.docname,
153                    'refdomain': self.refdomain,
154                    'reftype': self.reftype,
155                    'refexplicit': self.has_explicit_title,
156                    'refwarn': self.warn_dangling}
157         refnode = self.nodeclass(self.rawtext, **options)
158         self.set_source_info(refnode)
159 
160         # determine the target and title for the class
161         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
162                                           title, target)
163         refnode['reftarget'] = target
164         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
165 
166         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
167 
168     # methods that can be overwritten
169 
170     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
171                      title: str, target: str) -> Tuple[str, str]:
172         """Called after parsing title and target text, and creating the
173         reference node (given in *refnode*).  This method can alter the
174         reference node and must return a new (or the same) ``(title, target)``
175         tuple.
176         """
177         return title, ws_re.sub(' ', target)
178 
179     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
180                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
181         """Called before returning the finished nodes.  *node* is the reference
182         node if one was created (*is_ref* is then true), else the content node.
183         This method can add other nodes and must return a ``(nodes, messages)``
184         tuple (the usual return value of a role function).
185         """
186         return [node], []
187 
188 
189 class AnyXRefRole(XRefRole):
190     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
191                      title: str, target: str) -> Tuple[str, str]:
192         result = super().process_link(env, refnode, has_explicit_title, title, target)
193         # add all possible context info (i.e. std:program, py:module etc.)
194         refnode.attributes.update(env.ref_context)
195         return result
196 
197 
198 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
199                      options: Dict = {}, content: List[str] = []
200                      ) -> Tuple[List[Node], List[system_message]]:
201     """Role for PEP/RFC references that generate an index entry."""
202     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',
203                   RemovedInSphinx40Warning, stacklevel=2)
204     env = inliner.document.settings.env
205     if not typ:
206         assert env.temp_data['default_role']
207         typ = env.temp_data['default_role'].lower()
208     else:
209         typ = typ.lower()
210 
211     has_explicit_title, title, target = split_explicit_title(text)
212     title = utils.unescape(title)
213     target = utils.unescape(target)
214     targetid = 'index-%s' % env.new_serialno('index')
215     indexnode = addnodes.index()
216     targetnode = nodes.target('', '', ids=[targetid])
217     inliner.document.note_explicit_target(targetnode)
218     if typ == 'pep':
219         indexnode['entries'] = [
220             ('single', _('Python Enhancement Proposals; PEP %s') % target,
221              targetid, '', None)]
222         anchor = ''
223         anchorindex = target.find('#')
224         if anchorindex > 0:
225             target, anchor = target[:anchorindex], target[anchorindex:]
226         if not has_explicit_title:
227             title = "PEP " + utils.unescape(title)
228         try:
229             pepnum = int(target)
230         except ValueError:
231             msg = inliner.reporter.error('invalid PEP number %s' % target,
232                                          line=lineno)
233             prb = inliner.problematic(rawtext, rawtext, msg)
234             return [prb], [msg]
235         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum
236         sn = nodes.strong(title, title)
237         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
238                              classes=[typ])
239         rn += sn
240         return [indexnode, targetnode, rn], []
241     elif typ == 'rfc':
242         indexnode['entries'] = [
243             ('single', 'RFC; RFC %s' % target, targetid, '', None)]
244         anchor = ''
245         anchorindex = target.find('#')
246         if anchorindex > 0:
247             target, anchor = target[:anchorindex], target[anchorindex:]
248         if not has_explicit_title:
249             title = "RFC " + utils.unescape(title)
250         try:
251             rfcnum = int(target)
252         except ValueError:
253             msg = inliner.reporter.error('invalid RFC number %s' % target,
254                                          line=lineno)
255             prb = inliner.problematic(rawtext, rawtext, msg)
256             return [prb], [msg]
257         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum
258         sn = nodes.strong(title, title)
259         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
260                              classes=[typ])
261         rn += sn
262         return [indexnode, targetnode, rn], []
263     else:
264         raise ValueError('unknown role type: %s' % typ)
265 
266 
267 class PEP(ReferenceRole):
268     def run(self) -> Tuple[List[Node], List[system_message]]:
269         target_id = 'index-%s' % self.env.new_serialno('index')
270         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
271                     target_id, '', None)]
272 
273         index = addnodes.index(entries=entries)
274         target = nodes.target('', '', ids=[target_id])
275         self.inliner.document.note_explicit_target(target)
276 
277         try:
278             refuri = self.build_uri()
279             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
280             if self.has_explicit_title:
281                 reference += nodes.strong(self.title, self.title)
282             else:
283                 title = "PEP " + self.title
284                 reference += nodes.strong(title, title)
285         except ValueError:
286             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,
287                                               line=self.lineno)
288             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
289             return [prb], [msg]
290 
291         return [index, target, reference], []
292 
293     def build_uri(self) -> str:
294         base_url = self.inliner.document.settings.pep_base_url
295         ret = self.target.split('#', 1)
296         if len(ret) == 2:
297             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])
298         else:
299             return base_url + 'pep-%04d' % int(ret[0])
300 
301 
302 class RFC(ReferenceRole):
303     def run(self) -> Tuple[List[Node], List[system_message]]:
304         target_id = 'index-%s' % self.env.new_serialno('index')
305         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
306 
307         index = addnodes.index(entries=entries)
308         target = nodes.target('', '', ids=[target_id])
309         self.inliner.document.note_explicit_target(target)
310 
311         try:
312             refuri = self.build_uri()
313             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
314             if self.has_explicit_title:
315                 reference += nodes.strong(self.title, self.title)
316             else:
317                 title = "RFC " + self.title
318                 reference += nodes.strong(title, title)
319         except ValueError:
320             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,
321                                               line=self.lineno)
322             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
323             return [prb], [msg]
324 
325         return [index, target, reference], []
326 
327     def build_uri(self) -> str:
328         base_url = self.inliner.document.settings.rfc_base_url
329         ret = self.target.split('#', 1)
330         if len(ret) == 2:
331             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
332         else:
333             return base_url + self.inliner.rfc_url % int(ret[0])
334 
335 
336 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
337 
338 
339 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
340                  options: Dict = {}, content: List[str] = []
341                  ) -> Tuple[List[Node], List[system_message]]:
342     warnings.warn('menusel_role() is deprecated. '
343                   'Please use MenuSelection or GUILabel class instead.',
344                   RemovedInSphinx40Warning, stacklevel=2)
345     env = inliner.document.settings.env
346     if not typ:
347         assert env.temp_data['default_role']
348         typ = env.temp_data['default_role'].lower()
349     else:
350         typ = typ.lower()
351 
352     text = utils.unescape(text)
353     if typ == 'menuselection':
354         text = text.replace('-->', '\N{TRIANGULAR BULLET}')
355     spans = _amp_re.split(text)
356 
357     node = nodes.inline(rawtext=rawtext)
358     for i, span in enumerate(spans):
359         span = span.replace('&&', '&')
360         if i == 0:
361             if len(span) > 0:
362                 textnode = nodes.Text(span)
363                 node += textnode
364             continue
365         accel_node = nodes.inline()
366         letter_node = nodes.Text(span[0])
367         accel_node += letter_node
368         accel_node['classes'].append('accelerator')
369         node += accel_node
370         textnode = nodes.Text(span[1:])
371         node += textnode
372 
373     node['classes'].append(typ)
374     return [node], []
375 
376 
377 class GUILabel(SphinxRole):
378     amp_re = re.compile(r'(?<!&)&(?![&\s])')
379 
380     def run(self) -> Tuple[List[Node], List[system_message]]:
381         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
382         spans = self.amp_re.split(self.text)
383         node += nodes.Text(spans.pop(0))
384         for span in spans:
385             span = span.replace('&&', '&')
386 
387             letter = nodes.Text(span[0])
388             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
389             node += accelerator
390             node += nodes.Text(span[1:])
391 
392         return [node], []
393 
394 
395 class MenuSelection(GUILabel):
396     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
397 
398     def run(self) -> Tuple[List[Node], List[system_message]]:
399         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
400         return super().run()
401 
402 
403 _litvar_re = re.compile('{([^}]+)}')
404 parens_re = re.compile(r'(\\*{|\\*})')
405 
406 
407 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
408                       options: Dict = {}, content: List[str] = []
409                       ) -> Tuple[List[Node], List[system_message]]:
410     warnings.warn('emph_literal_role() is deprecated. '
411                   'Please use EmphasizedLiteral class instead.',
412                   RemovedInSphinx40Warning, stacklevel=2)
413     env = inliner.document.settings.env
414     if not typ:
415         assert env.temp_data['default_role']
416         typ = env.temp_data['default_role'].lower()
417     else:
418         typ = typ.lower()
419 
420     retnode = nodes.literal(role=typ.lower(), classes=[typ])
421     parts = list(parens_re.split(utils.unescape(text)))
422     stack = ['']
423     for part in parts:
424         matched = parens_re.match(part)
425         if matched:
426             backslashes = len(part) - 1
427             if backslashes % 2 == 1:    # escaped
428                 stack[-1] += "\\" * int((backslashes - 1) / 2) + part[-1]
429             elif part[-1] == '{':       # rparen
430                 stack[-1] += "\\" * int(backslashes / 2)
431                 if len(stack) >= 2 and stack[-2] == "{":
432                     # nested
433                     stack[-1] += "{"
434                 else:
435                     # start emphasis
436                     stack.append('{')
437                     stack.append('')
438             else:                       # lparen
439                 stack[-1] += "\\" * int(backslashes / 2)
440                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
441                     # emphasized word found
442                     if stack[0]:
443                         retnode += nodes.Text(stack[0], stack[0])
444                     retnode += nodes.emphasis(stack[2], stack[2])
445                     stack = ['']
446                 else:
447                     # emphasized word not found; the rparen is not a special symbol
448                     stack.append('}')
449                     stack = [''.join(stack)]
450         else:
451             stack[-1] += part
452     if ''.join(stack):
453         # remaining is treated as Text
454         text = ''.join(stack)
455         retnode += nodes.Text(text, text)
456 
457     return [retnode], []
458 
459 
460 class EmphasizedLiteral(SphinxRole):
461     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
462 
463     def run(self) -> Tuple[List[Node], List[system_message]]:
464         children = self.parse(self.text)
465         node = nodes.literal(self.rawtext, '', *children,
466                              role=self.name.lower(), classes=[self.name])
467 
468         return [node], []
469 
470     def parse(self, text: str) -> List[Node]:
471         result = []  # type: List[Node]
472 
473         stack = ['']
474         for part in self.parens_re.split(text):
475             if part == '\\\\':  # escaped backslash
476                 stack[-1] += '\\'
477             elif part == '{':
478                 if len(stack) >= 2 and stack[-2] == "{":  # nested
479                     stack[-1] += "{"
480                 else:
481                     # start emphasis
482                     stack.append('{')
483                     stack.append('')
484             elif part == '}':
485                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
486                     # emphasized word found
487                     if stack[0]:
488                         result.append(nodes.Text(stack[0], stack[0]))
489                     result.append(nodes.emphasis(stack[2], stack[2]))
490                     stack = ['']
491                 else:
492                     # emphasized word not found; the rparen is not a special symbol
493                     stack.append('}')
494                     stack = [''.join(stack)]
495             elif part == '\\{':  # escaped left-brace
496                 stack[-1] += '{'
497             elif part == '\\}':  # escaped right-brace
498                 stack[-1] += '}'
499             else:  # others (containing escaped braces)
500                 stack[-1] += part
501 
502         if ''.join(stack):
503             # remaining is treated as Text
504             text = ''.join(stack)
505             result.append(nodes.Text(text, text))
506 
507         return result
508 
509 
510 _abbr_re = re.compile(r'\((.*)\)$', re.S)
511 
512 
513 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
514               options: Dict = {}, content: List[str] = []
515               ) -> Tuple[List[Node], List[system_message]]:
516     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',
517                   RemovedInSphinx40Warning, stacklevel=2)
518     text = utils.unescape(text)
519     m = _abbr_re.search(text)
520     if m is None:
521         return [nodes.abbreviation(text, text, **options)], []
522     abbr = text[:m.start()].strip()
523     expl = m.group(1)
524     options = options.copy()
525     options['explanation'] = expl
526     return [nodes.abbreviation(abbr, abbr, **options)], []
527 
528 
529 class Abbreviation(SphinxRole):
530     abbr_re = re.compile(r'\((.*)\)$', re.S)
531 
532     def run(self) -> Tuple[List[Node], List[system_message]]:
533         matched = self.abbr_re.search(self.text)
534         if matched:
535             text = self.text[:matched.start()].strip()
536             self.options['explanation'] = matched.group(1)
537         else:
538             text = self.text
539 
540         return [nodes.abbreviation(self.rawtext, text, **self.options)], []
541 
542 
543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
544                options: Dict = {}, content: List[str] = []
545                ) -> Tuple[List[Node], List[system_message]]:
546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',
547                   RemovedInSphinx40Warning, stacklevel=2)
548     # create new reference target
549     env = inliner.document.settings.env
550     targetid = 'index-%s' % env.new_serialno('index')
551     targetnode = nodes.target('', '', ids=[targetid])
552     # split text and target in role content
553     has_explicit_title, title, target = split_explicit_title(text)
554     title = utils.unescape(title)
555     target = utils.unescape(target)
556     # if an explicit target is given, we can process it as a full entry
557     if has_explicit_title:
558         entries = process_index_entry(target, targetid)
559     # otherwise we just create a "single" entry
560     else:
561         # but allow giving main entry
562         main = ''
563         if target.startswith('!'):
564             target = target[1:]
565             title = title[1:]
566             main = 'main'
567         entries = [('single', target, targetid, main, None)]
568     indexnode = addnodes.index()
569     indexnode['entries'] = entries
570     set_role_source_info(inliner, lineno, indexnode)
571     textnode = nodes.Text(title, title)
572     return [indexnode, targetnode, textnode], []
573 
574 
575 class Index(ReferenceRole):
576     def run(self) -> Tuple[List[Node], List[system_message]]:
577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning)
578         target_id = 'index-%s' % self.env.new_serialno('index')
579         if self.has_explicit_title:
580             # if an explicit target is given, process it as a full entry
581             title = self.title
582             entries = process_index_entry(self.target, target_id)
583         else:
584             # otherwise we just create a single entry
585             if self.target.startswith('!'):
586                 title = self.title[1:]
587                 entries = [('single', self.target[1:], target_id, 'main', None)]
588             else:
589                 title = self.title
590                 entries = [('single', self.target, target_id, '', None)]
591 
592         index = addnodes.index(entries=entries)
593         target = nodes.target('', '', ids=[target_id])
594         text = nodes.Text(title, title)
595         self.set_source_info(index)
596         return [index, target, text], []
597 
598 
599 specific_docroles = {
600     # links to download references
601     'download': XRefRole(nodeclass=addnodes.download_reference),
602     # links to anything
603     'any': AnyXRefRole(warn_dangling=True),
604 
605     'pep': PEP(),
606     'rfc': RFC(),
607     'guilabel': GUILabel(),
608     'menuselection': MenuSelection(),
609     'file': EmphasizedLiteral(),
610     'samp': EmphasizedLiteral(),
611     'abbr': Abbreviation(),
612 }  # type: Dict[str, RoleFunction]
613 
614 
615 def setup(app: "Sphinx") -> Dict[str, Any]:
616     from docutils.parsers.rst import roles
617 
618     for rolename, nodeclass in generic_docroles.items():
619         generic = roles.GenericRole(rolename, nodeclass)
620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
621         roles.register_local_role(rolename, role)
622 
623     for rolename, func in specific_docroles.items():
624         roles.register_local_role(rolename, func)
625 
626     return {
627         'version': 'builtin',
628         'parallel_read_safe': True,
629         'parallel_write_safe': True,
630     }

</code><intended_behavior>The code in this file should include either the addition of a new custom role for `:kbd:` that contains logic for parsing the text content of the role to identify individual keystrokes or key sequences and construct nested or individual `<kbd>` HTML elements accordingly. This would involve parsing the input text to separate keys or key combinations and wrapping them in `<kbd>` tags, supporting both the individual and nested output formats as described in the issue.</intended_behavior>]
2025-10-18 18:11:51.495 | INFO     | Search completed. Bug locations: [<file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.roles
3     ~~~~~~~~~~~~
4 
5     Handlers for additional ReST roles.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import Any, Dict, List, Tuple
14 
15 from docutils import nodes, utils
16 from docutils.nodes import Element, Node, TextElement, system_message
17 from docutils.parsers.rst.states import Inliner
18 
19 from sphinx import addnodes
20 from sphinx.deprecation import RemovedInSphinx40Warning
21 from sphinx.locale import _
22 from sphinx.util import ws_re
23 from sphinx.util.docutils import ReferenceRole, SphinxRole
24 from sphinx.util.nodes import (
25     split_explicit_title, process_index_entry, set_role_source_info
26 )
27 from sphinx.util.typing import RoleFunction
28 
29 if False:
30     # For type annotation
31     from typing import Type  # for python3.5.1
32     from sphinx.application import Sphinx
33     from sphinx.environment import BuildEnvironment
34 
35 
36 generic_docroles = {
37     'command': addnodes.literal_strong,
38     'dfn': nodes.emphasis,
39     'kbd': nodes.literal,
40     'mailheader': addnodes.literal_emphasis,
41     'makevar': addnodes.literal_strong,
42     'manpage': addnodes.manpage,
43     'mimetype': addnodes.literal_emphasis,
44     'newsgroup': addnodes.literal_emphasis,
45     'program': addnodes.literal_strong,  # XXX should be an x-ref
46     'regexp': nodes.literal,
47 }
48 
49 
50 # -- generic cross-reference role ----------------------------------------------
51 
52 class XRefRole(ReferenceRole):
53     """
54     A generic cross-referencing role.  To create a callable that can be used as
55     a role function, create an instance of this class.
56 
57     The general features of this role are:
58 
59     * Automatic creation of a reference and a content node.
60     * Optional separation of title and target with `title <target>`.
61     * The implementation is a class rather than a function to make
62       customization easier.
63 
64     Customization can be done in two ways:
65 
66     * Supplying constructor parameters:
67       * `fix_parens` to normalize parentheses (strip from target, and add to
68         title if configured)
69       * `lowercase` to lowercase the target
70       * `nodeclass` and `innernodeclass` select the node classes for
71         the reference and the content node
72 
73     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
74     """
75 
76     nodeclass = addnodes.pending_xref   # type: Type[Element]
77     innernodeclass = nodes.literal      # type: Type[TextElement]
78 
79     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
80                  nodeclass: "Type[Element]" = None, innernodeclass: "Type[TextElement]" = None,
81                  warn_dangling: bool = False) -> None:
82         self.fix_parens = fix_parens
83         self.lowercase = lowercase
84         self.warn_dangling = warn_dangling
85         if nodeclass is not None:
86             self.nodeclass = nodeclass
87         if innernodeclass is not None:
88             self.innernodeclass = innernodeclass
89 
90         super().__init__()
91 
92     def _fix_parens(self, env: "BuildEnvironment", has_explicit_title: bool, title: str,
93                     target: str) -> Tuple[str, str]:
94         warnings.warn('XRefRole._fix_parens() is deprecated.',
95                       RemovedInSphinx40Warning, stacklevel=2)
96         if not has_explicit_title:
97             if title.endswith('()'):
98                 # remove parentheses
99                 title = title[:-2]
100             if env.config.add_function_parentheses:
101                 # add them back to all occurrences if configured
102                 title += '()'
103         # remove parentheses from the target too
104         if target.endswith('()'):
105             target = target[:-2]
106         return title, target
107 
108     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
109         if not self.has_explicit_title:
110             if title.endswith('()'):
111                 # remove parentheses
112                 title = title[:-2]
113             if self.config.add_function_parentheses:
114                 # add them back to all occurrences if configured
115                 title += '()'
116         # remove parentheses from the target too
117         if target.endswith('()'):
118             target = target[:-2]
119         return title, target
120 
121     def run(self) -> Tuple[List[Node], List[system_message]]:
122         if ':' not in self.name:
123             self.refdomain, self.reftype = '', self.name
124             self.classes = ['xref', self.reftype]
125         else:
126             self.refdomain, self.reftype = self.name.split(':', 1)
127             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
128 
129         if self.disabled:
130             return self.create_non_xref_node()
131         else:
132             return self.create_xref_node()
133 
134     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
135         text = utils.unescape(self.text[1:])
136         if self.fix_parens:
137             self.has_explicit_title = False  # treat as implicit
138             text, target = self.update_title_and_target(text, "")
139 
140         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
141         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
142 
143     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
144         target = self.target
145         title = self.title
146         if self.lowercase:
147             target = target.lower()
148         if self.fix_parens:
149             title, target = self.update_title_and_target(title, target)
150 
151         # create the reference node
152         options = {'refdoc': self.env.docname,
153                    'refdomain': self.refdomain,
154                    'reftype': self.reftype,
155                    'refexplicit': self.has_explicit_title,
156                    'refwarn': self.warn_dangling}
157         refnode = self.nodeclass(self.rawtext, **options)
158         self.set_source_info(refnode)
159 
160         # determine the target and title for the class
161         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
162                                           title, target)
163         refnode['reftarget'] = target
164         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
165 
166         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
167 
168     # methods that can be overwritten
169 
170     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
171                      title: str, target: str) -> Tuple[str, str]:
172         """Called after parsing title and target text, and creating the
173         reference node (given in *refnode*).  This method can alter the
174         reference node and must return a new (or the same) ``(title, target)``
175         tuple.
176         """
177         return title, ws_re.sub(' ', target)
178 
179     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
180                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
181         """Called before returning the finished nodes.  *node* is the reference
182         node if one was created (*is_ref* is then true), else the content node.
183         This method can add other nodes and must return a ``(nodes, messages)``
184         tuple (the usual return value of a role function).
185         """
186         return [node], []
187 
188 
189 class AnyXRefRole(XRefRole):
190     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
191                      title: str, target: str) -> Tuple[str, str]:
192         result = super().process_link(env, refnode, has_explicit_title, title, target)
193         # add all possible context info (i.e. std:program, py:module etc.)
194         refnode.attributes.update(env.ref_context)
195         return result
196 
197 
198 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
199                      options: Dict = {}, content: List[str] = []
200                      ) -> Tuple[List[Node], List[system_message]]:
201     """Role for PEP/RFC references that generate an index entry."""
202     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',
203                   RemovedInSphinx40Warning, stacklevel=2)
204     env = inliner.document.settings.env
205     if not typ:
206         assert env.temp_data['default_role']
207         typ = env.temp_data['default_role'].lower()
208     else:
209         typ = typ.lower()
210 
211     has_explicit_title, title, target = split_explicit_title(text)
212     title = utils.unescape(title)
213     target = utils.unescape(target)
214     targetid = 'index-%s' % env.new_serialno('index')
215     indexnode = addnodes.index()
216     targetnode = nodes.target('', '', ids=[targetid])
217     inliner.document.note_explicit_target(targetnode)
218     if typ == 'pep':
219         indexnode['entries'] = [
220             ('single', _('Python Enhancement Proposals; PEP %s') % target,
221              targetid, '', None)]
222         anchor = ''
223         anchorindex = target.find('#')
224         if anchorindex > 0:
225             target, anchor = target[:anchorindex], target[anchorindex:]
226         if not has_explicit_title:
227             title = "PEP " + utils.unescape(title)
228         try:
229             pepnum = int(target)
230         except ValueError:
231             msg = inliner.reporter.error('invalid PEP number %s' % target,
232                                          line=lineno)
233             prb = inliner.problematic(rawtext, rawtext, msg)
234             return [prb], [msg]
235         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum
236         sn = nodes.strong(title, title)
237         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
238                              classes=[typ])
239         rn += sn
240         return [indexnode, targetnode, rn], []
241     elif typ == 'rfc':
242         indexnode['entries'] = [
243             ('single', 'RFC; RFC %s' % target, targetid, '', None)]
244         anchor = ''
245         anchorindex = target.find('#')
246         if anchorindex > 0:
247             target, anchor = target[:anchorindex], target[anchorindex:]
248         if not has_explicit_title:
249             title = "RFC " + utils.unescape(title)
250         try:
251             rfcnum = int(target)
252         except ValueError:
253             msg = inliner.reporter.error('invalid RFC number %s' % target,
254                                          line=lineno)
255             prb = inliner.problematic(rawtext, rawtext, msg)
256             return [prb], [msg]
257         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum
258         sn = nodes.strong(title, title)
259         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
260                              classes=[typ])
261         rn += sn
262         return [indexnode, targetnode, rn], []
263     else:
264         raise ValueError('unknown role type: %s' % typ)
265 
266 
267 class PEP(ReferenceRole):
268     def run(self) -> Tuple[List[Node], List[system_message]]:
269         target_id = 'index-%s' % self.env.new_serialno('index')
270         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
271                     target_id, '', None)]
272 
273         index = addnodes.index(entries=entries)
274         target = nodes.target('', '', ids=[target_id])
275         self.inliner.document.note_explicit_target(target)
276 
277         try:
278             refuri = self.build_uri()
279             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
280             if self.has_explicit_title:
281                 reference += nodes.strong(self.title, self.title)
282             else:
283                 title = "PEP " + self.title
284                 reference += nodes.strong(title, title)
285         except ValueError:
286             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,
287                                               line=self.lineno)
288             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
289             return [prb], [msg]
290 
291         return [index, target, reference], []
292 
293     def build_uri(self) -> str:
294         base_url = self.inliner.document.settings.pep_base_url
295         ret = self.target.split('#', 1)
296         if len(ret) == 2:
297             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])
298         else:
299             return base_url + 'pep-%04d' % int(ret[0])
300 
301 
302 class RFC(ReferenceRole):
303     def run(self) -> Tuple[List[Node], List[system_message]]:
304         target_id = 'index-%s' % self.env.new_serialno('index')
305         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
306 
307         index = addnodes.index(entries=entries)
308         target = nodes.target('', '', ids=[target_id])
309         self.inliner.document.note_explicit_target(target)
310 
311         try:
312             refuri = self.build_uri()
313             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
314             if self.has_explicit_title:
315                 reference += nodes.strong(self.title, self.title)
316             else:
317                 title = "RFC " + self.title
318                 reference += nodes.strong(title, title)
319         except ValueError:
320             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,
321                                               line=self.lineno)
322             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
323             return [prb], [msg]
324 
325         return [index, target, reference], []
326 
327     def build_uri(self) -> str:
328         base_url = self.inliner.document.settings.rfc_base_url
329         ret = self.target.split('#', 1)
330         if len(ret) == 2:
331             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
332         else:
333             return base_url + self.inliner.rfc_url % int(ret[0])
334 
335 
336 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
337 
338 
339 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
340                  options: Dict = {}, content: List[str] = []
341                  ) -> Tuple[List[Node], List[system_message]]:
342     warnings.warn('menusel_role() is deprecated. '
343                   'Please use MenuSelection or GUILabel class instead.',
344                   RemovedInSphinx40Warning, stacklevel=2)
345     env = inliner.document.settings.env
346     if not typ:
347         assert env.temp_data['default_role']
348         typ = env.temp_data['default_role'].lower()
349     else:
350         typ = typ.lower()
351 
352     text = utils.unescape(text)
353     if typ == 'menuselection':
354         text = text.replace('-->', '\N{TRIANGULAR BULLET}')
355     spans = _amp_re.split(text)
356 
357     node = nodes.inline(rawtext=rawtext)
358     for i, span in enumerate(spans):
359         span = span.replace('&&', '&')
360         if i == 0:
361             if len(span) > 0:
362                 textnode = nodes.Text(span)
363                 node += textnode
364             continue
365         accel_node = nodes.inline()
366         letter_node = nodes.Text(span[0])
367         accel_node += letter_node
368         accel_node['classes'].append('accelerator')
369         node += accel_node
370         textnode = nodes.Text(span[1:])
371         node += textnode
372 
373     node['classes'].append(typ)
374     return [node], []
375 
376 
377 class GUILabel(SphinxRole):
378     amp_re = re.compile(r'(?<!&)&(?![&\s])')
379 
380     def run(self) -> Tuple[List[Node], List[system_message]]:
381         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
382         spans = self.amp_re.split(self.text)
383         node += nodes.Text(spans.pop(0))
384         for span in spans:
385             span = span.replace('&&', '&')
386 
387             letter = nodes.Text(span[0])
388             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
389             node += accelerator
390             node += nodes.Text(span[1:])
391 
392         return [node], []
393 
394 
395 class MenuSelection(GUILabel):
396     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
397 
398     def run(self) -> Tuple[List[Node], List[system_message]]:
399         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
400         return super().run()
401 
402 
403 _litvar_re = re.compile('{([^}]+)}')
404 parens_re = re.compile(r'(\\*{|\\*})')
405 
406 
407 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
408                       options: Dict = {}, content: List[str] = []
409                       ) -> Tuple[List[Node], List[system_message]]:
410     warnings.warn('emph_literal_role() is deprecated. '
411                   'Please use EmphasizedLiteral class instead.',
412                   RemovedInSphinx40Warning, stacklevel=2)
413     env = inliner.document.settings.env
414     if not typ:
415         assert env.temp_data['default_role']
416         typ = env.temp_data['default_role'].lower()
417     else:
418         typ = typ.lower()
419 
420     retnode = nodes.literal(role=typ.lower(), classes=[typ])
421     parts = list(parens_re.split(utils.unescape(text)))
422     stack = ['']
423     for part in parts:
424         matched = parens_re.match(part)
425         if matched:
426             backslashes = len(part) - 1
427             if backslashes % 2 == 1:    # escaped
428                 stack[-1] += "\\" * int((backslashes - 1) / 2) + part[-1]
429             elif part[-1] == '{':       # rparen
430                 stack[-1] += "\\" * int(backslashes / 2)
431                 if len(stack) >= 2 and stack[-2] == "{":
432                     # nested
433                     stack[-1] += "{"
434                 else:
435                     # start emphasis
436                     stack.append('{')
437                     stack.append('')
438             else:                       # lparen
439                 stack[-1] += "\\" * int(backslashes / 2)
440                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
441                     # emphasized word found
442                     if stack[0]:
443                         retnode += nodes.Text(stack[0], stack[0])
444                     retnode += nodes.emphasis(stack[2], stack[2])
445                     stack = ['']
446                 else:
447                     # emphasized word not found; the rparen is not a special symbol
448                     stack.append('}')
449                     stack = [''.join(stack)]
450         else:
451             stack[-1] += part
452     if ''.join(stack):
453         # remaining is treated as Text
454         text = ''.join(stack)
455         retnode += nodes.Text(text, text)
456 
457     return [retnode], []
458 
459 
460 class EmphasizedLiteral(SphinxRole):
461     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
462 
463     def run(self) -> Tuple[List[Node], List[system_message]]:
464         children = self.parse(self.text)
465         node = nodes.literal(self.rawtext, '', *children,
466                              role=self.name.lower(), classes=[self.name])
467 
468         return [node], []
469 
470     def parse(self, text: str) -> List[Node]:
471         result = []  # type: List[Node]
472 
473         stack = ['']
474         for part in self.parens_re.split(text):
475             if part == '\\\\':  # escaped backslash
476                 stack[-1] += '\\'
477             elif part == '{':
478                 if len(stack) >= 2 and stack[-2] == "{":  # nested
479                     stack[-1] += "{"
480                 else:
481                     # start emphasis
482                     stack.append('{')
483                     stack.append('')
484             elif part == '}':
485                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
486                     # emphasized word found
487                     if stack[0]:
488                         result.append(nodes.Text(stack[0], stack[0]))
489                     result.append(nodes.emphasis(stack[2], stack[2]))
490                     stack = ['']
491                 else:
492                     # emphasized word not found; the rparen is not a special symbol
493                     stack.append('}')
494                     stack = [''.join(stack)]
495             elif part == '\\{':  # escaped left-brace
496                 stack[-1] += '{'
497             elif part == '\\}':  # escaped right-brace
498                 stack[-1] += '}'
499             else:  # others (containing escaped braces)
500                 stack[-1] += part
501 
502         if ''.join(stack):
503             # remaining is treated as Text
504             text = ''.join(stack)
505             result.append(nodes.Text(text, text))
506 
507         return result
508 
509 
510 _abbr_re = re.compile(r'\((.*)\)$', re.S)
511 
512 
513 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
514               options: Dict = {}, content: List[str] = []
515               ) -> Tuple[List[Node], List[system_message]]:
516     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',
517                   RemovedInSphinx40Warning, stacklevel=2)
518     text = utils.unescape(text)
519     m = _abbr_re.search(text)
520     if m is None:
521         return [nodes.abbreviation(text, text, **options)], []
522     abbr = text[:m.start()].strip()
523     expl = m.group(1)
524     options = options.copy()
525     options['explanation'] = expl
526     return [nodes.abbreviation(abbr, abbr, **options)], []
527 
528 
529 class Abbreviation(SphinxRole):
530     abbr_re = re.compile(r'\((.*)\)$', re.S)
531 
532     def run(self) -> Tuple[List[Node], List[system_message]]:
533         matched = self.abbr_re.search(self.text)
534         if matched:
535             text = self.text[:matched.start()].strip()
536             self.options['explanation'] = matched.group(1)
537         else:
538             text = self.text
539 
540         return [nodes.abbreviation(self.rawtext, text, **self.options)], []
541 
542 
543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
544                options: Dict = {}, content: List[str] = []
545                ) -> Tuple[List[Node], List[system_message]]:
546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',
547                   RemovedInSphinx40Warning, stacklevel=2)
548     # create new reference target
549     env = inliner.document.settings.env
550     targetid = 'index-%s' % env.new_serialno('index')
551     targetnode = nodes.target('', '', ids=[targetid])
552     # split text and target in role content
553     has_explicit_title, title, target = split_explicit_title(text)
554     title = utils.unescape(title)
555     target = utils.unescape(target)
556     # if an explicit target is given, we can process it as a full entry
557     if has_explicit_title:
558         entries = process_index_entry(target, targetid)
559     # otherwise we just create a "single" entry
560     else:
561         # but allow giving main entry
562         main = ''
563         if target.startswith('!'):
564             target = target[1:]
565             title = title[1:]
566             main = 'main'
567         entries = [('single', target, targetid, main, None)]
568     indexnode = addnodes.index()
569     indexnode['entries'] = entries
570     set_role_source_info(inliner, lineno, indexnode)
571     textnode = nodes.Text(title, title)
572     return [indexnode, targetnode, textnode], []
573 
574 
575 class Index(ReferenceRole):
576     def run(self) -> Tuple[List[Node], List[system_message]]:
577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning)
578         target_id = 'index-%s' % self.env.new_serialno('index')
579         if self.has_explicit_title:
580             # if an explicit target is given, process it as a full entry
581             title = self.title
582             entries = process_index_entry(self.target, target_id)
583         else:
584             # otherwise we just create a single entry
585             if self.target.startswith('!'):
586                 title = self.title[1:]
587                 entries = [('single', self.target[1:], target_id, 'main', None)]
588             else:
589                 title = self.title
590                 entries = [('single', self.target, target_id, '', None)]
591 
592         index = addnodes.index(entries=entries)
593         target = nodes.target('', '', ids=[target_id])
594         text = nodes.Text(title, title)
595         self.set_source_info(index)
596         return [index, target, text], []
597 
598 
599 specific_docroles = {
600     # links to download references
601     'download': XRefRole(nodeclass=addnodes.download_reference),
602     # links to anything
603     'any': AnyXRefRole(warn_dangling=True),
604 
605     'pep': PEP(),
606     'rfc': RFC(),
607     'guilabel': GUILabel(),
608     'menuselection': MenuSelection(),
609     'file': EmphasizedLiteral(),
610     'samp': EmphasizedLiteral(),
611     'abbr': Abbreviation(),
612 }  # type: Dict[str, RoleFunction]
613 
614 
615 def setup(app: "Sphinx") -> Dict[str, Any]:
616     from docutils.parsers.rst import roles
617 
618     for rolename, nodeclass in generic_docroles.items():
619         generic = roles.GenericRole(rolename, nodeclass)
620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
621         roles.register_local_role(rolename, role)
622 
623     for rolename, func in specific_docroles.items():
624         roles.register_local_role(rolename, func)
625 
626     return {
627         'version': 'builtin',
628         'parallel_read_safe': True,
629         'parallel_write_safe': True,
630     }

</code><intended_behavior>The code in this file should include either the addition of a new custom role for `:kbd:` that contains logic for parsing the text content of the role to identify individual keystrokes or key sequences and construct nested or individual `<kbd>` HTML elements accordingly. This would involve parsing the input text to separate keys or key combinations and wrapping them in `<kbd>` tags, supporting both the individual and nested output formats as described in the issue.</intended_behavior>]
2025-10-18 18:11:51.496 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 18:11:51.496 | INFO     | Search-only: skipping patch selection
2025-10-18 18:11:51.580 | INFO     | Task sphinx-doc__sphinx-7593 completed successfully.
2025-10-18 18:11:51.581 | INFO     | No patch generated. You can try running ACR again.
