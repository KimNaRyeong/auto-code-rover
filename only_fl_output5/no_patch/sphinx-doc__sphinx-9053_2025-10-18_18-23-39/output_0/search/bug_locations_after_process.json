[
    {
        "rel_file_path": "sphinx/io.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/io.py",
        "start": 1,
        "end": 189,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.io\n3     ~~~~~~~~~\n4 \n5     Input/Output files\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 import codecs\n11 from typing import TYPE_CHECKING, Any, List, Type\n12 \n13 from docutils import nodes\n14 from docutils.core import Publisher\n15 from docutils.frontend import Values\n16 from docutils.io import FileInput, Input, NullOutput\n17 from docutils.parsers import Parser\n18 from docutils.parsers.rst import Parser as RSTParser\n19 from docutils.readers import standalone\n20 from docutils.transforms import Transform\n21 from docutils.transforms.references import DanglingReferences\n22 from docutils.writers import UnfilteredWriter\n23 \n24 from sphinx import addnodes\n25 from sphinx.environment import BuildEnvironment\n26 from sphinx.transforms import (AutoIndexUpgrader, DoctreeReadEvent, FigureAligner,\n27                                SphinxTransformer)\n28 from sphinx.transforms.i18n import (Locale, PreserveTranslatableMessages,\n29                                     RemoveTranslatableInline)\n30 from sphinx.transforms.references import SphinxDomains\n31 from sphinx.util import UnicodeDecodeErrorHandler, get_filetype, logging\n32 from sphinx.util.docutils import LoggingReporter\n33 from sphinx.versioning import UIDTransform\n34 \n35 if TYPE_CHECKING:\n36     from sphinx.application import Sphinx\n37 \n38 \n39 logger = logging.getLogger(__name__)\n40 \n41 \n42 class SphinxBaseReader(standalone.Reader):\n43     \"\"\"\n44     A base class of readers for Sphinx.\n45 \n46     This replaces reporter by Sphinx's on generating document.\n47     \"\"\"\n48 \n49     transforms: List[Type[Transform]] = []\n50 \n51     def __init__(self, *args: Any, **kwargs: Any) -> None:\n52         from sphinx.application import Sphinx\n53         if len(args) > 0 and isinstance(args[0], Sphinx):\n54             self._app = args[0]\n55             self._env = self._app.env\n56             args = args[1:]\n57 \n58         super().__init__(*args, **kwargs)\n59 \n60     def setup(self, app: \"Sphinx\") -> None:\n61         self._app = app      # hold application object only for compatibility\n62         self._env = app.env\n63 \n64     def get_transforms(self) -> List[Type[Transform]]:\n65         transforms = super().get_transforms() + self.transforms\n66 \n67         # remove transforms which is not needed for Sphinx\n68         unused = [DanglingReferences]\n69         for transform in unused:\n70             if transform in transforms:\n71                 transforms.remove(transform)\n72 \n73         return transforms\n74 \n75     def new_document(self) -> nodes.document:\n76         \"\"\"Creates a new document object which having a special reporter object good\n77         for logging.\n78         \"\"\"\n79         document = super().new_document()\n80         document.__class__ = addnodes.document  # replace the class with patched version\n81 \n82         # substitute transformer\n83         document.transformer = SphinxTransformer(document)\n84         document.transformer.set_environment(self.settings.env)\n85 \n86         # substitute reporter\n87         reporter = document.reporter\n88         document.reporter = LoggingReporter.from_reporter(reporter)\n89 \n90         return document\n91 \n92 \n93 class SphinxStandaloneReader(SphinxBaseReader):\n94     \"\"\"\n95     A basic document reader for Sphinx.\n96     \"\"\"\n97 \n98     def setup(self, app: \"Sphinx\") -> None:\n99         self.transforms = self.transforms + app.registry.get_transforms()\n100         super().setup(app)\n101 \n102     def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:\n103         self.source = source\n104         if not self.parser:\n105             self.parser = parser\n106         self.settings = settings\n107         self.input = self.read_source(settings.env)\n108         self.parse()\n109         return self.document\n110 \n111     def read_source(self, env: BuildEnvironment) -> str:\n112         \"\"\"Read content from source and do post-process.\"\"\"\n113         content = self.source.read()\n114 \n115         # emit \"source-read\" event\n116         arg = [content]\n117         env.events.emit('source-read', env.docname, arg)\n118         return arg[0]\n119 \n120 \n121 class SphinxI18nReader(SphinxBaseReader):\n122     \"\"\"\n123     A document reader for i18n.\n124 \n125     This returns the source line number of original text as current source line number\n126     to let users know where the error happened.\n127     Because the translated texts are partial and they don't have correct line numbers.\n128     \"\"\"\n129 \n130     def setup(self, app: \"Sphinx\") -> None:\n131         super().setup(app)\n132 \n133         self.transforms = self.transforms + app.registry.get_transforms()\n134         unused = [PreserveTranslatableMessages, Locale, RemoveTranslatableInline,\n135                   AutoIndexUpgrader, FigureAligner, SphinxDomains, DoctreeReadEvent,\n136                   UIDTransform]\n137         for transform in unused:\n138             if transform in self.transforms:\n139                 self.transforms.remove(transform)\n140 \n141 \n142 class SphinxDummyWriter(UnfilteredWriter):\n143     \"\"\"Dummy writer module used for generating doctree.\"\"\"\n144 \n145     supported = ('html',)  # needed to keep \"meta\" nodes\n146 \n147     def translate(self) -> None:\n148         pass\n149 \n150 \n151 def SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:\n152     \"\"\"Bypass source object as is to cheat Publisher.\"\"\"\n153     return source\n154 \n155 \n156 class SphinxFileInput(FileInput):\n157     \"\"\"A basic FileInput for Sphinx.\"\"\"\n158     def __init__(self, *args: Any, **kwargs: Any) -> None:\n159         kwargs['error_handler'] = 'sphinx'\n160         super().__init__(*args, **kwargs)\n161 \n162 \n163 def read_doc(app: \"Sphinx\", env: BuildEnvironment, filename: str) -> nodes.document:\n164     \"\"\"Parse a document and convert to doctree.\"\"\"\n165     # set up error_handler for the target document\n166     error_handler = UnicodeDecodeErrorHandler(env.docname)\n167     codecs.register_error('sphinx', error_handler)  # type: ignore\n168 \n169     reader = SphinxStandaloneReader()\n170     reader.setup(app)\n171     filetype = get_filetype(app.config.source_suffix, filename)\n172     parser = app.registry.create_source_parser(app, filetype)\n173     if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():\n174         # a workaround for recommonmark\n175         #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser\n176         #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST\n177         #   parser.  As a workaround, this copies settings_spec for RSTParser to the\n178         #   CommonMarkParser.\n179         parser.settings_spec = RSTParser.settings_spec\n180 \n181     pub = Publisher(reader=reader,\n182                     parser=parser,\n183                     writer=SphinxDummyWriter(),\n184                     source_class=SphinxFileInput,\n185                     destination=NullOutput())\n186     pub.process_programmatic_settings(None, env.settings, None)\n187     pub.set_source(source_path=filename)\n188     pub.publish()\n189     return pub.document\n",
        "intended_behavior": "Ensure parsing of reStructuredText documents is compatible with `docutils-0.17b1`, maintaining existing functionality."
    },
    {
        "rel_file_path": "sphinx/util/docutils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/util/docutils.py",
        "start": 1,
        "end": 516,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.docutils\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Utility functions for docutils.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import os\n12 import re\n13 from contextlib import contextmanager\n14 from copy import copy\n15 from distutils.version import LooseVersion\n16 from os import path\n17 from types import ModuleType\n18 from typing import (IO, TYPE_CHECKING, Any, Callable, Dict, Generator, List, Optional, Set,\n19                     Tuple, Type, cast)\n20 \n21 import docutils\n22 from docutils import nodes\n23 from docutils.io import FileOutput\n24 from docutils.nodes import Element, Node, system_message\n25 from docutils.parsers.rst import Directive, directives, roles\n26 from docutils.parsers.rst.states import Inliner\n27 from docutils.statemachine import State, StateMachine, StringList\n28 from docutils.utils import Reporter, unescape\n29 \n30 from sphinx.errors import SphinxError\n31 from sphinx.locale import _\n32 from sphinx.util import logging\n33 from sphinx.util.typing import RoleFunction\n34 \n35 logger = logging.getLogger(__name__)\n36 report_re = re.compile('^(.+?:(?:\\\\d+)?): \\\\((DEBUG|INFO|WARNING|ERROR|SEVERE)/(\\\\d+)?\\\\) ')\n37 \n38 if TYPE_CHECKING:\n39     from sphinx.builders import Builder\n40     from sphinx.config import Config\n41     from sphinx.environment import BuildEnvironment\n42 \n43 \n44 __version_info__ = tuple(LooseVersion(docutils.__version__).version)\n45 additional_nodes: Set[Type[Element]] = set()\n46 \n47 \n48 @contextmanager\n49 def docutils_namespace() -> Generator[None, None, None]:\n50     \"\"\"Create namespace for reST parsers.\"\"\"\n51     try:\n52         _directives = copy(directives._directives)  # type: ignore\n53         _roles = copy(roles._roles)  # type: ignore\n54 \n55         yield\n56     finally:\n57         directives._directives = _directives  # type: ignore\n58         roles._roles = _roles  # type: ignore\n59 \n60         for node in list(additional_nodes):\n61             unregister_node(node)\n62             additional_nodes.discard(node)\n63 \n64 \n65 def is_directive_registered(name: str) -> bool:\n66     \"\"\"Check the *name* directive is already registered.\"\"\"\n67     return name in directives._directives  # type: ignore\n68 \n69 \n70 def register_directive(name: str, directive: Type[Directive]) -> None:\n71     \"\"\"Register a directive to docutils.\n72 \n73     This modifies global state of docutils.  So it is better to use this\n74     inside ``docutils_namespace()`` to prevent side-effects.\n75     \"\"\"\n76     directives.register_directive(name, directive)\n77 \n78 \n79 def is_role_registered(name: str) -> bool:\n80     \"\"\"Check the *name* role is already registered.\"\"\"\n81     return name in roles._roles  # type: ignore\n82 \n83 \n84 def register_role(name: str, role: RoleFunction) -> None:\n85     \"\"\"Register a role to docutils.\n86 \n87     This modifies global state of docutils.  So it is better to use this\n88     inside ``docutils_namespace()`` to prevent side-effects.\n89     \"\"\"\n90     roles.register_local_role(name, role)\n91 \n92 \n93 def unregister_role(name: str) -> None:\n94     \"\"\"Unregister a role from docutils.\"\"\"\n95     roles._roles.pop(name, None)  # type: ignore\n96 \n97 \n98 def is_node_registered(node: Type[Element]) -> bool:\n99     \"\"\"Check the *node* is already registered.\"\"\"\n100     return hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__)\n101 \n102 \n103 def register_node(node: Type[Element]) -> None:\n104     \"\"\"Register a node to docutils.\n105 \n106     This modifies global state of some visitors.  So it is better to use this\n107     inside ``docutils_namespace()`` to prevent side-effects.\n108     \"\"\"\n109     if not hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):\n110         nodes._add_node_class_names([node.__name__])  # type: ignore\n111         additional_nodes.add(node)\n112 \n113 \n114 def unregister_node(node: Type[Element]) -> None:\n115     \"\"\"Unregister a node from docutils.\n116 \n117     This is inverse of ``nodes._add_nodes_class_names()``.\n118     \"\"\"\n119     if hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):\n120         delattr(nodes.GenericNodeVisitor, \"visit_\" + node.__name__)\n121         delattr(nodes.GenericNodeVisitor, \"depart_\" + node.__name__)\n122         delattr(nodes.SparseNodeVisitor, 'visit_' + node.__name__)\n123         delattr(nodes.SparseNodeVisitor, 'depart_' + node.__name__)\n124 \n125 \n126 @contextmanager\n127 def patched_get_language() -> Generator[None, None, None]:\n128     \"\"\"Patch docutils.languages.get_language() temporarily.\n129 \n130     This ignores the second argument ``reporter`` to suppress warnings.\n131     refs: https://github.com/sphinx-doc/sphinx/issues/3788\n132     \"\"\"\n133     from docutils.languages import get_language\n134 \n135     def patched_get_language(language_code: str, reporter: Reporter = None) -> Any:\n136         return get_language(language_code)\n137 \n138     try:\n139         docutils.languages.get_language = patched_get_language\n140         yield\n141     finally:\n142         # restore original implementations\n143         docutils.languages.get_language = get_language\n144 \n145 \n146 @contextmanager\n147 def using_user_docutils_conf(confdir: Optional[str]) -> Generator[None, None, None]:\n148     \"\"\"Let docutils know the location of ``docutils.conf`` for Sphinx.\"\"\"\n149     try:\n150         docutilsconfig = os.environ.get('DOCUTILSCONFIG', None)\n151         if confdir:\n152             os.environ['DOCUTILSCONFIG'] = path.join(path.abspath(confdir), 'docutils.conf')\n153 \n154         yield\n155     finally:\n156         if docutilsconfig is None:\n157             os.environ.pop('DOCUTILSCONFIG', None)\n158         else:\n159             os.environ['DOCUTILSCONFIG'] = docutilsconfig\n160 \n161 \n162 @contextmanager\n163 def patch_docutils(confdir: Optional[str] = None) -> Generator[None, None, None]:\n164     \"\"\"Patch to docutils temporarily.\"\"\"\n165     with patched_get_language(), using_user_docutils_conf(confdir):\n166         yield\n167 \n168 \n169 class ElementLookupError(Exception):\n170     pass\n171 \n172 \n173 class sphinx_domains:\n174     \"\"\"Monkey-patch directive and role dispatch, so that domain-specific\n175     markup takes precedence.\n176     \"\"\"\n177     def __init__(self, env: \"BuildEnvironment\") -> None:\n178         self.env = env\n179         self.directive_func: Callable = None\n180         self.roles_func: Callable = None\n181 \n182     def __enter__(self) -> None:\n183         self.enable()\n184 \n185     def __exit__(self, exc_type: Type[Exception], exc_value: Exception, traceback: Any) -> None:  # NOQA\n186         self.disable()\n187 \n188     def enable(self) -> None:\n189         self.directive_func = directives.directive\n190         self.role_func = roles.role\n191 \n192         directives.directive = self.lookup_directive\n193         roles.role = self.lookup_role\n194 \n195     def disable(self) -> None:\n196         directives.directive = self.directive_func\n197         roles.role = self.role_func\n198 \n199     def lookup_domain_element(self, type: str, name: str) -> Any:\n200         \"\"\"Lookup a markup element (directive or role), given its name which can\n201         be a full name (with domain).\n202         \"\"\"\n203         name = name.lower()\n204         # explicit domain given?\n205         if ':' in name:\n206             domain_name, name = name.split(':', 1)\n207             if domain_name in self.env.domains:\n208                 domain = self.env.get_domain(domain_name)\n209                 element = getattr(domain, type)(name)\n210                 if element is not None:\n211                     return element, []\n212             else:\n213                 logger.warning(_('unknown directive or role name: %s:%s'), domain_name, name)\n214         # else look in the default domain\n215         else:\n216             def_domain = self.env.temp_data.get('default_domain')\n217             if def_domain is not None:\n218                 element = getattr(def_domain, type)(name)\n219                 if element is not None:\n220                     return element, []\n221 \n222         # always look in the std domain\n223         element = getattr(self.env.get_domain('std'), type)(name)\n224         if element is not None:\n225             return element, []\n226 \n227         raise ElementLookupError\n228 \n229     def lookup_directive(self, directive_name: str, language_module: ModuleType, document: nodes.document) -> Tuple[Optional[Type[Directive]], List[system_message]]:  # NOQA\n230         try:\n231             return self.lookup_domain_element('directive', directive_name)\n232         except ElementLookupError:\n233             return self.directive_func(directive_name, language_module, document)\n234 \n235     def lookup_role(self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter) -> Tuple[RoleFunction, List[system_message]]:  # NOQA\n236         try:\n237             return self.lookup_domain_element('role', role_name)\n238         except ElementLookupError:\n239             return self.role_func(role_name, language_module, lineno, reporter)\n240 \n241 \n242 class WarningStream:\n243     def write(self, text: str) -> None:\n244         matched = report_re.search(text)\n245         if not matched:\n246             logger.warning(text.rstrip(\"\\r\\n\"))\n247         else:\n248             location, type, level = matched.groups()\n249             message = report_re.sub('', text).rstrip()\n250             logger.log(type, message, location=location)\n251 \n252 \n253 class LoggingReporter(Reporter):\n254     @classmethod\n255     def from_reporter(cls, reporter: Reporter) -> \"LoggingReporter\":\n256         \"\"\"Create an instance of LoggingReporter from other reporter object.\"\"\"\n257         return cls(reporter.source, reporter.report_level, reporter.halt_level,\n258                    reporter.debug_flag, reporter.error_handler)\n259 \n260     def __init__(self, source: str, report_level: int = Reporter.WARNING_LEVEL,\n261                  halt_level: int = Reporter.SEVERE_LEVEL, debug: bool = False,\n262                  error_handler: str = 'backslashreplace') -> None:\n263         stream = cast(IO, WarningStream())\n264         super().__init__(source, report_level, halt_level,\n265                          stream, debug, error_handler=error_handler)\n266 \n267 \n268 class NullReporter(Reporter):\n269     \"\"\"A dummy reporter; write nothing.\"\"\"\n270 \n271     def __init__(self) -> None:\n272         super().__init__('', 999, 4)\n273 \n274 \n275 def is_html5_writer_available() -> bool:\n276     return __version_info__ > (0, 13, 0)\n277 \n278 \n279 @contextmanager\n280 def switch_source_input(state: State, content: StringList) -> Generator[None, None, None]:\n281     \"\"\"Switch current source input of state temporarily.\"\"\"\n282     try:\n283         # remember the original ``get_source_and_line()`` method\n284         get_source_and_line = state.memo.reporter.get_source_and_line  # type: ignore\n285 \n286         # replace it by new one\n287         state_machine = StateMachine([], None)\n288         state_machine.input_lines = content\n289         state.memo.reporter.get_source_and_line = state_machine.get_source_and_line  # type: ignore  # NOQA\n290 \n291         yield\n292     finally:\n293         # restore the method\n294         state.memo.reporter.get_source_and_line = get_source_and_line  # type: ignore\n295 \n296 \n297 class SphinxFileOutput(FileOutput):\n298     \"\"\"Better FileOutput class for Sphinx.\"\"\"\n299 \n300     def __init__(self, **kwargs: Any) -> None:\n301         self.overwrite_if_changed = kwargs.pop('overwrite_if_changed', False)\n302         super().__init__(**kwargs)\n303 \n304     def write(self, data: str) -> str:\n305         if (self.destination_path and self.autoclose and 'b' not in self.mode and\n306                 self.overwrite_if_changed and os.path.exists(self.destination_path)):\n307             with open(self.destination_path, encoding=self.encoding) as f:\n308                 # skip writing: content not changed\n309                 if f.read() == data:\n310                     return data\n311 \n312         return super().write(data)\n313 \n314 \n315 class SphinxDirective(Directive):\n316     \"\"\"A base class for Sphinx directives.\n317 \n318     This class provides helper methods for Sphinx directives.\n319 \n320     .. note:: The subclasses of this class might not work with docutils.\n321               This class is strongly coupled with Sphinx.\n322     \"\"\"\n323 \n324     @property\n325     def env(self) -> \"BuildEnvironment\":\n326         \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n327         return self.state.document.settings.env\n328 \n329     @property\n330     def config(self) -> \"Config\":\n331         \"\"\"Reference to the :class:`.Config` object.\"\"\"\n332         return self.env.config\n333 \n334     def get_source_info(self) -> Tuple[str, int]:\n335         \"\"\"Get source and line number.\"\"\"\n336         return self.state_machine.get_source_and_line(self.lineno)\n337 \n338     def set_source_info(self, node: Node) -> None:\n339         \"\"\"Set source and line number to the node.\"\"\"\n340         node.source, node.line = self.get_source_info()\n341 \n342 \n343 class SphinxRole:\n344     \"\"\"A base class for Sphinx roles.\n345 \n346     This class provides helper methods for Sphinx roles.\n347 \n348     .. note:: The subclasses of this class might not work with docutils.\n349               This class is strongly coupled with Sphinx.\n350     \"\"\"\n351     name: str           #: The role name actually used in the document.\n352     rawtext: str        #: A string containing the entire interpreted text input.\n353     text: str           #: The interpreted text content.\n354     lineno: int         #: The line number where the interpreted text begins.\n355     inliner: Inliner    #: The ``docutils.parsers.rst.states.Inliner`` object.\n356     options: Dict       #: A dictionary of directive options for customization\n357                         #: (from the \"role\" directive).\n358     content: List[str]  #: A list of strings, the directive content for customization\n359                         #: (from the \"role\" directive).\n360 \n361     def __call__(self, name: str, rawtext: str, text: str, lineno: int,\n362                  inliner: Inliner, options: Dict = {}, content: List[str] = []\n363                  ) -> Tuple[List[Node], List[system_message]]:\n364         self.rawtext = rawtext\n365         self.text = unescape(text)\n366         self.lineno = lineno\n367         self.inliner = inliner\n368         self.options = options\n369         self.content = content\n370 \n371         # guess role type\n372         if name:\n373             self.name = name.lower()\n374         else:\n375             self.name = self.env.temp_data.get('default_role')\n376             if not self.name:\n377                 self.name = self.env.config.default_role\n378             if not self.name:\n379                 raise SphinxError('cannot determine default role!')\n380 \n381         return self.run()\n382 \n383     def run(self) -> Tuple[List[Node], List[system_message]]:\n384         raise NotImplementedError\n385 \n386     @property\n387     def env(self) -> \"BuildEnvironment\":\n388         \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n389         return self.inliner.document.settings.env\n390 \n391     @property\n392     def config(self) -> \"Config\":\n393         \"\"\"Reference to the :class:`.Config` object.\"\"\"\n394         return self.env.config\n395 \n396     def get_source_info(self, lineno: int = None) -> Tuple[str, int]:\n397         if lineno is None:\n398             lineno = self.lineno\n399         return self.inliner.reporter.get_source_and_line(lineno)  # type: ignore\n400 \n401     def set_source_info(self, node: Node, lineno: int = None) -> None:\n402         node.source, node.line = self.get_source_info(lineno)\n403 \n404 \n405 class ReferenceRole(SphinxRole):\n406     \"\"\"A base class for reference roles.\n407 \n408     The reference roles can accpet ``link title <target>`` style as a text for\n409     the role.  The parsed result; link title and target will be stored to\n410     ``self.title`` and ``self.target``.\n411     \"\"\"\n412     has_explicit_title: bool    #: A boolean indicates the role has explicit title or not.\n413     disabled: bool              #: A boolean indicates the reference is disabled.\n414     title: str                  #: The link title for the interpreted text.\n415     target: str                 #: The link target for the interpreted text.\n416 \n417     # \\x00 means the \"<\" was backslash-escaped\n418     explicit_title_re = re.compile(r'^(.+?)\\s*(?<!\\x00)<(.*?)>$', re.DOTALL)\n419 \n420     def __call__(self, name: str, rawtext: str, text: str, lineno: int,\n421                  inliner: Inliner, options: Dict = {}, content: List[str] = []\n422                  ) -> Tuple[List[Node], List[system_message]]:\n423         # if the first character is a bang, don't cross-reference at all\n424         self.disabled = text.startswith('!')\n425 \n426         matched = self.explicit_title_re.match(text)\n427         if matched:\n428             self.has_explicit_title = True\n429             self.title = unescape(matched.group(1))\n430             self.target = unescape(matched.group(2))\n431         else:\n432             self.has_explicit_title = False\n433             self.title = unescape(text)\n434             self.target = unescape(text)\n435 \n436         return super().__call__(name, rawtext, text, lineno, inliner, options, content)\n437 \n438 \n439 class SphinxTranslator(nodes.NodeVisitor):\n440     \"\"\"A base class for Sphinx translators.\n441 \n442     This class adds a support for visitor/departure method for super node class\n443     if visitor/departure method for node class is not found.\n444 \n445     It also provides helper methods for Sphinx translators.\n446 \n447     .. note:: The subclasses of this class might not work with docutils.\n448               This class is strongly coupled with Sphinx.\n449     \"\"\"\n450 \n451     def __init__(self, document: nodes.document, builder: \"Builder\") -> None:\n452         super().__init__(document)\n453         self.builder = builder\n454         self.config = builder.config\n455         self.settings = document.settings\n456 \n457     def dispatch_visit(self, node: Node) -> None:\n458         \"\"\"\n459         Dispatch node to appropriate visitor method.\n460         The priority of visitor method is:\n461 \n462         1. ``self.visit_{node_class}()``\n463         2. ``self.visit_{super_node_class}()``\n464         3. ``self.unknown_visit()``\n465         \"\"\"\n466         for node_class in node.__class__.__mro__:\n467             method = getattr(self, 'visit_%s' % (node_class.__name__), None)\n468             if method:\n469                 method(node)\n470                 break\n471         else:\n472             super().dispatch_visit(node)\n473 \n474     def dispatch_departure(self, node: Node) -> None:\n475         \"\"\"\n476         Dispatch node to appropriate departure method.\n477         The priority of departure method is:\n478 \n479         1. ``self.depart_{node_class}()``\n480         2. ``self.depart_{super_node_class}()``\n481         3. ``self.unknown_departure()``\n482         \"\"\"\n483         for node_class in node.__class__.__mro__:\n484             method = getattr(self, 'depart_%s' % (node_class.__name__), None)\n485             if method:\n486                 method(node)\n487                 break\n488         else:\n489             super().dispatch_departure(node)\n490 \n491 \n492 # cache a vanilla instance of nodes.document\n493 # Used in new_document() function\n494 __document_cache__: nodes.document = None\n495 \n496 \n497 def new_document(source_path: str, settings: Any = None) -> nodes.document:\n498     \"\"\"Return a new empty document object.  This is an alternative of docutils'.\n499 \n500     This is a simple wrapper for ``docutils.utils.new_document()``.  It\n501     caches the result of docutils' and use it on second call for instantiation.\n502     This makes an instantiation of document nodes much faster.\n503     \"\"\"\n504     global __document_cache__\n505     if __document_cache__ is None:\n506         __document_cache__ = docutils.utils.new_document(source_path)\n507 \n508     if settings is None:\n509         # Make a copy of ``settings`` from cache to accelerate instansiation\n510         settings = copy(__document_cache__.settings)\n511 \n512     # Create a new instance of nodes.document using cached reporter\n513     from sphinx import addnodes\n514     document = addnodes.document(settings, __document_cache__.reporter, source=source_path)\n515     document.note_source(source_path, -1)\n516     return document\n",
        "intended_behavior": "Update or adapt utility functions to work seamlessly with `docutils-0.17b1`, leveraging new features or changes without breaking existing integrations."
    },
    {
        "rel_file_path": "sphinx/transforms/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/transforms/__init__.py",
        "start": 1,
        "end": 428,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.transforms\n3     ~~~~~~~~~~~~~~~~~\n4 \n5     Docutils transforms used by Sphinx when reading documents.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import warnings\n13 from typing import TYPE_CHECKING, Any, Dict, Generator, List, Tuple\n14 \n15 from docutils import nodes\n16 from docutils.nodes import Element, Node, Text\n17 from docutils.transforms import Transform, Transformer\n18 from docutils.transforms.parts import ContentsFilter\n19 from docutils.transforms.universal import SmartQuotes\n20 from docutils.utils import normalize_language_tag\n21 from docutils.utils.smartquotes import smartchars\n22 \n23 from sphinx import addnodes\n24 from sphinx.config import Config\n25 from sphinx.deprecation import RemovedInSphinx60Warning\n26 from sphinx.locale import _, __\n27 from sphinx.util import docutils, logging\n28 from sphinx.util.docutils import new_document\n29 from sphinx.util.i18n import format_date\n30 from sphinx.util.nodes import NodeMatcher, apply_source_workaround, is_smartquotable\n31 \n32 if TYPE_CHECKING:\n33     from sphinx.application import Sphinx\n34     from sphinx.domain.std import StandardDomain\n35     from sphinx.environment import BuildEnvironment\n36 \n37 \n38 logger = logging.getLogger(__name__)\n39 \n40 default_substitutions = {\n41     'version',\n42     'release',\n43     'today',\n44 }\n45 \n46 \n47 class SphinxTransform(Transform):\n48     \"\"\"A base class of Transforms.\n49 \n50     Compared with ``docutils.transforms.Transform``, this class improves accessibility to\n51     Sphinx APIs.\n52     \"\"\"\n53 \n54     @property\n55     def app(self) -> \"Sphinx\":\n56         \"\"\"Reference to the :class:`.Sphinx` object.\"\"\"\n57         return self.env.app\n58 \n59     @property\n60     def env(self) -> \"BuildEnvironment\":\n61         \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n62         return self.document.settings.env\n63 \n64     @property\n65     def config(self) -> Config:\n66         \"\"\"Reference to the :class:`.Config` object.\"\"\"\n67         return self.env.config\n68 \n69 \n70 class SphinxTransformer(Transformer):\n71     \"\"\"\n72     A transformer for Sphinx.\n73     \"\"\"\n74 \n75     document: nodes.document = None\n76     env: \"BuildEnvironment\" = None\n77 \n78     def set_environment(self, env: \"BuildEnvironment\") -> None:\n79         self.env = env\n80 \n81     def apply_transforms(self) -> None:\n82         if isinstance(self.document, nodes.document):\n83             if not hasattr(self.document.settings, 'env') and self.env:\n84                 self.document.settings.env = self.env\n85 \n86             super().apply_transforms()\n87         else:\n88             # wrap the target node by document node during transforming\n89             try:\n90                 document = new_document('')\n91                 if self.env:\n92                     document.settings.env = self.env\n93                 document += self.document\n94                 self.document = document\n95                 super().apply_transforms()\n96             finally:\n97                 self.document = self.document[0]\n98 \n99 \n100 class DefaultSubstitutions(SphinxTransform):\n101     \"\"\"\n102     Replace some substitutions if they aren't defined in the document.\n103     \"\"\"\n104     # run before the default Substitutions\n105     default_priority = 210\n106 \n107     def apply(self, **kwargs: Any) -> None:\n108         # only handle those not otherwise defined in the document\n109         to_handle = default_substitutions - set(self.document.substitution_defs)\n110         for ref in self.document.traverse(nodes.substitution_reference):\n111             refname = ref['refname']\n112             if refname in to_handle:\n113                 text = self.config[refname]\n114                 if refname == 'today' and not text:\n115                     # special handling: can also specify a strftime format\n116                     text = format_date(self.config.today_fmt or _('%b %d, %Y'),\n117                                        language=self.config.language)\n118                 ref.replace_self(nodes.Text(text, text))\n119 \n120 \n121 class MoveModuleTargets(SphinxTransform):\n122     \"\"\"\n123     Move module targets that are the first thing in a section to the section\n124     title.\n125 \n126     XXX Python specific\n127     \"\"\"\n128     default_priority = 210\n129 \n130     def apply(self, **kwargs: Any) -> None:\n131         for node in self.document.traverse(nodes.target):\n132             if not node['ids']:\n133                 continue\n134             if ('ismod' in node and\n135                     node.parent.__class__ is nodes.section and\n136                     # index 0 is the section title node\n137                     node.parent.index(node) == 1):\n138                 node.parent['ids'][0:0] = node['ids']\n139                 node.parent.remove(node)\n140 \n141 \n142 class HandleCodeBlocks(SphinxTransform):\n143     \"\"\"\n144     Several code block related transformations.\n145     \"\"\"\n146     default_priority = 210\n147 \n148     def apply(self, **kwargs: Any) -> None:\n149         # move doctest blocks out of blockquotes\n150         for node in self.document.traverse(nodes.block_quote):\n151             if all(isinstance(child, nodes.doctest_block) for child\n152                    in node.children):\n153                 node.replace_self(node.children)\n154         # combine successive doctest blocks\n155         # for node in self.document.traverse(nodes.doctest_block):\n156         #    if node not in node.parent.children:\n157         #        continue\n158         #    parindex = node.parent.index(node)\n159         #    while len(node.parent) > parindex+1 and \\\n160         #            isinstance(node.parent[parindex+1], nodes.doctest_block):\n161         #        node[0] = nodes.Text(node[0] + '\\n\\n' +\n162         #                             node.parent[parindex+1][0])\n163         #        del node.parent[parindex+1]\n164 \n165 \n166 class AutoNumbering(SphinxTransform):\n167     \"\"\"\n168     Register IDs of tables, figures and literal_blocks to assign numbers.\n169     \"\"\"\n170     default_priority = 210\n171 \n172     def apply(self, **kwargs: Any) -> None:\n173         domain: StandardDomain = self.env.get_domain('std')\n174 \n175         for node in self.document.traverse(nodes.Element):\n176             if (domain.is_enumerable_node(node) and\n177                     domain.get_numfig_title(node) is not None and\n178                     node['ids'] == []):\n179                 self.document.note_implicit_target(node)\n180 \n181 \n182 class SortIds(SphinxTransform):\n183     \"\"\"\n184     Sort secion IDs so that the \"id[0-9]+\" one comes last.\n185     \"\"\"\n186     default_priority = 261\n187 \n188     def apply(self, **kwargs: Any) -> None:\n189         for node in self.document.traverse(nodes.section):\n190             if len(node['ids']) > 1 and node['ids'][0].startswith('id'):\n191                 node['ids'] = node['ids'][1:] + [node['ids'][0]]\n192 \n193 \n194 TRANSLATABLE_NODES = {\n195     'literal-block': nodes.literal_block,\n196     'doctest-block': nodes.doctest_block,\n197     'raw': nodes.raw,\n198     'index': addnodes.index,\n199     'image': nodes.image,\n200 }\n201 \n202 \n203 class ApplySourceWorkaround(SphinxTransform):\n204     \"\"\"\n205     update source and rawsource attributes\n206     \"\"\"\n207     default_priority = 10\n208 \n209     def apply(self, **kwargs: Any) -> None:\n210         for node in self.document.traverse():  # type: Node\n211             if isinstance(node, (nodes.TextElement, nodes.image)):\n212                 apply_source_workaround(node)\n213 \n214 \n215 class AutoIndexUpgrader(SphinxTransform):\n216     \"\"\"\n217     Detect old style; 4 column based indices and automatically upgrade to new style.\n218     \"\"\"\n219     default_priority = 210\n220 \n221     def apply(self, **kwargs: Any) -> None:\n222         for node in self.document.traverse(addnodes.index):\n223             if 'entries' in node and any(len(entry) == 4 for entry in node['entries']):\n224                 msg = __('4 column based index found. '\n225                          'It might be a bug of extensions you use: %r') % node['entries']\n226                 logger.warning(msg, location=node)\n227                 for i, entry in enumerate(node['entries']):\n228                     if len(entry) == 4:\n229                         node['entries'][i] = entry + (None,)\n230 \n231 \n232 class ExtraTranslatableNodes(SphinxTransform):\n233     \"\"\"\n234     make nodes translatable\n235     \"\"\"\n236     default_priority = 10\n237 \n238     def apply(self, **kwargs: Any) -> None:\n239         targets = self.config.gettext_additional_targets\n240         target_nodes = [v for k, v in TRANSLATABLE_NODES.items() if k in targets]\n241         if not target_nodes:\n242             return\n243 \n244         def is_translatable_node(node: Node) -> bool:\n245             return isinstance(node, tuple(target_nodes))\n246 \n247         for node in self.document.traverse(is_translatable_node):  # type: Element\n248             node['translatable'] = True\n249 \n250 \n251 class UnreferencedFootnotesDetector(SphinxTransform):\n252     \"\"\"\n253     detect unreferenced footnotes and emit warnings\n254     \"\"\"\n255     default_priority = 200\n256 \n257     def apply(self, **kwargs: Any) -> None:\n258         for node in self.document.footnotes:\n259             if node['names'] == []:\n260                 # footnote having duplicated number.  It is already warned at parser.\n261                 pass\n262             elif node['names'][0] not in self.document.footnote_refs:\n263                 logger.warning(__('Footnote [%s] is not referenced.'), node['names'][0],\n264                                type='ref', subtype='footnote',\n265                                location=node)\n266 \n267         for node in self.document.autofootnotes:\n268             if not any(ref['auto'] == node['auto'] for ref in self.document.autofootnote_refs):\n269                 logger.warning(__('Footnote [#] is not referenced.'),\n270                                type='ref', subtype='footnote',\n271                                location=node)\n272 \n273 \n274 class DoctestTransform(SphinxTransform):\n275     \"\"\"Set \"doctest\" style to each doctest_block node\"\"\"\n276     default_priority = 500\n277 \n278     def apply(self, **kwargs: Any) -> None:\n279         for node in self.document.traverse(nodes.doctest_block):\n280             node['classes'].append('doctest')\n281 \n282 \n283 class FigureAligner(SphinxTransform):\n284     \"\"\"\n285     Align figures to center by default.\n286     \"\"\"\n287     default_priority = 700\n288 \n289     def __init__(self, *args: Any, **kwargs: Any) -> None:\n290         warnings.warn('FigureAilgner is deprecated.',\n291                       RemovedInSphinx60Warning)\n292         super().__init__(*args, **kwargs)\n293 \n294     def apply(self, **kwargs: Any) -> None:\n295         matcher = NodeMatcher(nodes.table, nodes.figure)\n296         for node in self.document.traverse(matcher):  # type: Element\n297             node.setdefault('align', 'default')\n298 \n299 \n300 class FilterSystemMessages(SphinxTransform):\n301     \"\"\"Filter system messages from a doctree.\"\"\"\n302     default_priority = 999\n303 \n304     def apply(self, **kwargs: Any) -> None:\n305         filterlevel = 2 if self.config.keep_warnings else 5\n306         for node in self.document.traverse(nodes.system_message):\n307             if node['level'] < filterlevel:\n308                 logger.debug('%s [filtered system message]', node.astext())\n309                 node.parent.remove(node)\n310 \n311 \n312 class SphinxContentsFilter(ContentsFilter):\n313     \"\"\"\n314     Used with BuildEnvironment.add_toc_from() to discard cross-file links\n315     within table-of-contents link nodes.\n316     \"\"\"\n317     visit_pending_xref = ContentsFilter.ignore_node_but_process_children\n318 \n319     def visit_image(self, node: nodes.image) -> None:\n320         raise nodes.SkipNode\n321 \n322 \n323 class SphinxSmartQuotes(SmartQuotes, SphinxTransform):\n324     \"\"\"\n325     Customized SmartQuotes to avoid transform for some extra node types.\n326 \n327     refs: sphinx.parsers.RSTParser\n328     \"\"\"\n329     default_priority = 750\n330 \n331     def apply(self, **kwargs: Any) -> None:\n332         if not self.is_available():\n333             return\n334 \n335         # override default settings with :confval:`smartquotes_action`\n336         self.smartquotes_action = self.config.smartquotes_action\n337 \n338         super().apply()\n339 \n340     def is_available(self) -> bool:\n341         builders = self.config.smartquotes_excludes.get('builders', [])\n342         languages = self.config.smartquotes_excludes.get('languages', [])\n343 \n344         if self.document.settings.smart_quotes is False:\n345             # disabled by 3rd party extension (workaround)\n346             return False\n347         elif self.config.smartquotes is False:\n348             # disabled by confval smartquotes\n349             return False\n350         elif self.app.builder.name in builders:\n351             # disabled by confval smartquotes_excludes['builders']\n352             return False\n353         elif self.config.language in languages:\n354             # disabled by confval smartquotes_excludes['languages']\n355             return False\n356 \n357         # confirm selected language supports smart_quotes or not\n358         language = self.env.settings['language_code']\n359         for tag in normalize_language_tag(language):\n360             if tag in smartchars.quotes:\n361                 return True\n362         else:\n363             return False\n364 \n365     def get_tokens(self, txtnodes: List[Text]) -> Generator[Tuple[str, str], None, None]:\n366         # A generator that yields ``(texttype, nodetext)`` tuples for a list\n367         # of \"Text\" nodes (interface to ``smartquotes.educate_tokens()``).\n368         for txtnode in txtnodes:\n369             if is_smartquotable(txtnode):\n370                 if docutils.__version_info__ >= (0, 16):\n371                     # SmartQuotes uses backslash escapes instead of null-escapes\n372                     text = re.sub(r'(?<=\\x00)([-\\\\\\'\".`])', r'\\\\\\1', str(txtnode))\n373                 else:\n374                     text = txtnode.astext()\n375 \n376                 yield ('plain', text)\n377             else:\n378                 # skip smart quotes\n379                 yield ('literal', txtnode.astext())\n380 \n381 \n382 class DoctreeReadEvent(SphinxTransform):\n383     \"\"\"Emit :event:`doctree-read` event.\"\"\"\n384     default_priority = 880\n385 \n386     def apply(self, **kwargs: Any) -> None:\n387         self.app.emit('doctree-read', self.document)\n388 \n389 \n390 class ManpageLink(SphinxTransform):\n391     \"\"\"Find manpage section numbers and names\"\"\"\n392     default_priority = 999\n393 \n394     def apply(self, **kwargs: Any) -> None:\n395         for node in self.document.traverse(addnodes.manpage):\n396             manpage = ' '.join([str(x) for x in node.children\n397                                 if isinstance(x, nodes.Text)])\n398             pattern = r'^(?P<path>(?P<page>.+)[\\(\\.](?P<section>[1-9]\\w*)?\\)?)$'  # noqa\n399             info = {'path': manpage,\n400                     'page': manpage,\n401                     'section': ''}\n402             r = re.match(pattern, manpage)\n403             if r:\n404                 info = r.groupdict()\n405             node.attributes.update(info)\n406 \n407 \n408 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n409     app.add_transform(ApplySourceWorkaround)\n410     app.add_transform(ExtraTranslatableNodes)\n411     app.add_transform(DefaultSubstitutions)\n412     app.add_transform(MoveModuleTargets)\n413     app.add_transform(HandleCodeBlocks)\n414     app.add_transform(SortIds)\n415     app.add_transform(DoctestTransform)\n416     app.add_transform(AutoNumbering)\n417     app.add_transform(AutoIndexUpgrader)\n418     app.add_transform(FilterSystemMessages)\n419     app.add_transform(UnreferencedFootnotesDetector)\n420     app.add_transform(SphinxSmartQuotes)\n421     app.add_transform(DoctreeReadEvent)\n422     app.add_transform(ManpageLink)\n423 \n424     return {\n425         'version': 'builtin',\n426         'parallel_read_safe': True,\n427         'parallel_write_safe': True,\n428     }\n",
        "intended_behavior": "Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API."
    },
    {
        "rel_file_path": "sphinx/transforms/post_transforms/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/transforms/post_transforms/__init__.py",
        "start": 1,
        "end": 248,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.transforms.post_transforms\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Docutils transforms used by Sphinx.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from typing import Any, Dict, List, Optional, Tuple, Type, cast\n12 \n13 from docutils import nodes\n14 from docutils.nodes import Element\n15 \n16 from sphinx import addnodes\n17 from sphinx.addnodes import pending_xref\n18 from sphinx.application import Sphinx\n19 from sphinx.domains import Domain\n20 from sphinx.errors import NoUri\n21 from sphinx.locale import __\n22 from sphinx.transforms import SphinxTransform\n23 from sphinx.util import logging\n24 from sphinx.util.docutils import SphinxTranslator\n25 from sphinx.util.nodes import find_pending_xref_condition, process_only_nodes\n26 \n27 logger = logging.getLogger(__name__)\n28 \n29 if False:\n30     # For type annotation\n31     from docutils.nodes import Node\n32 \n33 \n34 class SphinxPostTransform(SphinxTransform):\n35     \"\"\"A base class of post-transforms.\n36 \n37     Post transforms are invoked to modify the document to restructure it for outputting.\n38     They do resolving references, convert images, special transformation for each output\n39     formats and so on.  This class helps to implement these post transforms.\n40     \"\"\"\n41     builders: Tuple[str, ...] = ()\n42     formats: Tuple[str, ...] = ()\n43 \n44     def apply(self, **kwargs: Any) -> None:\n45         if self.is_supported():\n46             self.run(**kwargs)\n47 \n48     def is_supported(self) -> bool:\n49         \"\"\"Check this transform working for current builder.\"\"\"\n50         if self.builders and self.app.builder.name not in self.builders:\n51             return False\n52         if self.formats and self.app.builder.format not in self.formats:\n53             return False\n54 \n55         return True\n56 \n57     def run(self, **kwargs: Any) -> None:\n58         \"\"\"main method of post transforms.\n59 \n60         Subclasses should override this method instead of ``apply()``.\n61         \"\"\"\n62         raise NotImplementedError\n63 \n64 \n65 class ReferencesResolver(SphinxPostTransform):\n66     \"\"\"\n67     Resolves cross-references on doctrees.\n68     \"\"\"\n69 \n70     default_priority = 10\n71 \n72     def run(self, **kwargs: Any) -> None:\n73         for node in self.document.traverse(addnodes.pending_xref):\n74             contnode = cast(nodes.TextElement, node[0].deepcopy())\n75             newnode = None\n76 \n77             typ = node['reftype']\n78             target = node['reftarget']\n79             refdoc = node.get('refdoc', self.env.docname)\n80             domain = None\n81 \n82             try:\n83                 if 'refdomain' in node and node['refdomain']:\n84                     # let the domain try to resolve the reference\n85                     try:\n86                         domain = self.env.domains[node['refdomain']]\n87                     except KeyError as exc:\n88                         raise NoUri(target, typ) from exc\n89                     newnode = domain.resolve_xref(self.env, refdoc, self.app.builder,\n90                                                   typ, target, node, contnode)\n91                 # really hardwired reference types\n92                 elif typ == 'any':\n93                     newnode = self.resolve_anyref(refdoc, node, contnode)\n94                 # no new node found? try the missing-reference event\n95                 if newnode is None:\n96                     newnode = self.app.emit_firstresult('missing-reference', self.env,\n97                                                         node, contnode,\n98                                                         allowed_exceptions=(NoUri,))\n99                     # still not found? warn if node wishes to be warned about or\n100                     # we are in nit-picky mode\n101                     if newnode is None:\n102                         self.warn_missing_reference(refdoc, typ, target, node, domain)\n103             except NoUri:\n104                 newnode = None\n105 \n106             if newnode:\n107                 newnodes: List[Node] = [newnode]\n108             else:\n109                 newnodes = [contnode]\n110                 if newnode is None and isinstance(node[0], addnodes.pending_xref_condition):\n111                     matched = find_pending_xref_condition(node, \"*\")\n112                     if matched:\n113                         newnodes = matched.children\n114                     else:\n115                         logger.warning(__('Could not determine the fallback text for the '\n116                                           'cross-reference. Might be a bug.'), location=node)\n117 \n118             node.replace_self(newnodes)\n119 \n120     def resolve_anyref(self, refdoc: str, node: pending_xref, contnode: Element) -> Element:\n121         \"\"\"Resolve reference generated by the \"any\" role.\"\"\"\n122         stddomain = self.env.get_domain('std')\n123         target = node['reftarget']\n124         results: List[Tuple[str, Element]] = []\n125         # first, try resolving as :doc:\n126         doc_ref = stddomain.resolve_xref(self.env, refdoc, self.app.builder,\n127                                          'doc', target, node, contnode)\n128         if doc_ref:\n129             results.append(('doc', doc_ref))\n130         # next, do the standard domain (makes this a priority)\n131         results.extend(stddomain.resolve_any_xref(self.env, refdoc, self.app.builder,\n132                                                   target, node, contnode))\n133         for domain in self.env.domains.values():\n134             if domain.name == 'std':\n135                 continue  # we did this one already\n136             try:\n137                 results.extend(domain.resolve_any_xref(self.env, refdoc, self.app.builder,\n138                                                        target, node, contnode))\n139             except NotImplementedError:\n140                 # the domain doesn't yet support the new interface\n141                 # we have to manually collect possible references (SLOW)\n142                 for role in domain.roles:\n143                     res = domain.resolve_xref(self.env, refdoc, self.app.builder,\n144                                               role, target, node, contnode)\n145                     if res and len(res) > 0 and isinstance(res[0], nodes.Element):\n146                         results.append(('%s:%s' % (domain.name, role), res))\n147         # now, see how many matches we got...\n148         if not results:\n149             return None\n150         if len(results) > 1:\n151             def stringify(name: str, node: Element) -> str:\n152                 reftitle = node.get('reftitle', node.astext())\n153                 return ':%s:`%s`' % (name, reftitle)\n154             candidates = ' or '.join(stringify(name, role) for name, role in results)\n155             logger.warning(__('more than one target found for \\'any\\' cross-'\n156                               'reference %r: could be %s'), target, candidates,\n157                            location=node)\n158         res_role, newnode = results[0]\n159         # Override \"any\" class with the actual role type to get the styling\n160         # approximately correct.\n161         res_domain = res_role.split(':')[0]\n162         if (len(newnode) > 0 and\n163                 isinstance(newnode[0], nodes.Element) and\n164                 newnode[0].get('classes')):\n165             newnode[0]['classes'].append(res_domain)\n166             newnode[0]['classes'].append(res_role.replace(':', '-'))\n167         return newnode\n168 \n169     def warn_missing_reference(self, refdoc: str, typ: str, target: str,\n170                                node: pending_xref, domain: Optional[Domain]) -> None:\n171         warn = node.get('refwarn')\n172         if self.config.nitpicky:\n173             warn = True\n174             if self.config.nitpick_ignore:\n175                 dtype = '%s:%s' % (domain.name, typ) if domain else typ\n176                 if (dtype, target) in self.config.nitpick_ignore:\n177                     warn = False\n178                 # for \"std\" types also try without domain name\n179                 if (not domain or domain.name == 'std') and \\\n180                    (typ, target) in self.config.nitpick_ignore:\n181                     warn = False\n182         if not warn:\n183             return\n184 \n185         if self.app.emit_firstresult('warn-missing-reference', domain, node):\n186             return\n187         elif domain and typ in domain.dangling_warnings:\n188             msg = domain.dangling_warnings[typ] % {'target': target}\n189         elif node.get('refdomain', 'std') not in ('', 'std'):\n190             msg = (__('%s:%s reference target not found: %s') %\n191                    (node['refdomain'], typ, target))\n192         else:\n193             msg = __('%r reference target not found: %s') % (typ, target)\n194         logger.warning(msg, location=node, type='ref', subtype=typ)\n195 \n196 \n197 class OnlyNodeTransform(SphinxPostTransform):\n198     default_priority = 50\n199 \n200     def run(self, **kwargs: Any) -> None:\n201         # A comment on the comment() nodes being inserted: replacing by [] would\n202         # result in a \"Losing ids\" exception if there is a target node before\n203         # the only node, so we make sure docutils can transfer the id to\n204         # something, even if it's just a comment and will lose the id anyway...\n205         process_only_nodes(self.document, self.app.builder.tags)\n206 \n207 \n208 class SigElementFallbackTransform(SphinxPostTransform):\n209     \"\"\"Fallback desc_sig_element nodes to inline if translator does not supported them.\"\"\"\n210     default_priority = 200\n211 \n212     SIG_ELEMENTS = [addnodes.desc_sig_name,\n213                     addnodes.desc_sig_operator,\n214                     addnodes.desc_sig_punctuation]\n215 \n216     def run(self, **kwargs: Any) -> None:\n217         def has_visitor(translator: Type[nodes.NodeVisitor], node: Type[Element]) -> bool:\n218             return hasattr(translator, \"visit_%s\" % node.__name__)\n219 \n220         translator = self.app.builder.get_translator_class()\n221         if isinstance(translator, SphinxTranslator):\n222             # subclass of SphinxTranslator supports desc_sig_element nodes automatically.\n223             return\n224 \n225         if all(has_visitor(translator, node) for node in self.SIG_ELEMENTS):\n226             # the translator supports all desc_sig_element nodes\n227             return\n228         else:\n229             self.fallback()\n230 \n231     def fallback(self) -> None:\n232         for node in self.document.traverse(addnodes.desc_sig_element):\n233             newnode = nodes.inline()\n234             newnode.update_all_atts(node)\n235             newnode.extend(node)\n236             node.replace_self(newnode)\n237 \n238 \n239 def setup(app: Sphinx) -> Dict[str, Any]:\n240     app.add_post_transform(ReferencesResolver)\n241     app.add_post_transform(OnlyNodeTransform)\n242     app.add_post_transform(SigElementFallbackTransform)\n243 \n244     return {\n245         'version': 'builtin',\n246         'parallel_read_safe': True,\n247         'parallel_write_safe': True,\n248     }\n",
        "intended_behavior": "Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API."
    }
]