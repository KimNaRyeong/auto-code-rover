2025-10-18 18:23:40.082 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 18:23:42.069 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=109, output_tokens=12, cost=0.001450
2025-10-18 18:23:42.070 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 18:23:42.074 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:23:52.037 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=418, output_tokens=424, cost=0.016900
2025-10-18 18:23:52.045 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:23:54.134 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=778, output_tokens=21, cost=0.008410
2025-10-18 18:23:54.135 | DEBUG    | Extracted a valid json.
2025-10-18 18:23:54.136 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"docutils\")"],
    "bug_locations": []
}
2025-10-18 18:23:54.510 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:23:54.511 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:24:10.655 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2825, output_tokens=699, cost=0.049220
2025-10-18 18:24:10.668 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:24:18.524 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3740, output_tokens=317, cost=0.046910
2025-10-18 18:24:18.530 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:24:20.542 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=14, cost=0.007130
2025-10-18 18:24:20.543 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:20.543 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 18:24:22.532 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=14, cost=0.007130
2025-10-18 18:24:22.532 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:22.532 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 18:24:24.167 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=14, cost=0.007130
2025-10-18 18:24:24.168 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:24.168 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 18:24:26.217 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=14, cost=0.007130
2025-10-18 18:24:26.217 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:26.217 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 18:24:29.186 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=14, cost=0.007130
2025-10-18 18:24:29.187 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:29.193 | DEBUG    | Agent proxy return the following json: None
2025-10-18 18:24:29.193 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 18:24:29.194 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 18:24:29.194 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:24:36.090 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4084, output_tokens=186, cost=0.046420
2025-10-18 18:24:36.095 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:24:38.971 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=540, output_tokens=14, cost=0.005820
2025-10-18 18:24:38.972 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:38.972 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 18:24:40.234 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=540, output_tokens=14, cost=0.005820
2025-10-18 18:24:40.235 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:40.235 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 18:24:43.011 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=540, output_tokens=14, cost=0.005820
2025-10-18 18:24:43.012 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:43.012 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 18:24:45.180 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=540, output_tokens=14, cost=0.005820
2025-10-18 18:24:45.181 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:45.181 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 18:24:48.099 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=540, output_tokens=14, cost=0.005820
2025-10-18 18:24:48.100 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:24:48.100 | DEBUG    | Agent proxy return the following json: None
2025-10-18 18:24:48.100 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 18:24:48.101 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 18:24:48.101 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:25:00.064 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4297, output_tokens=450, cost=0.056470
2025-10-18 18:25:00.074 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:25:07.026 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=804, output_tokens=261, cost=0.015870
2025-10-18 18:25:07.027 | DEBUG    | Extracted a valid json.
2025-10-18 18:25:07.027 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/io.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure parsing of reStructuredText documents is compatible with `docutils-0.17b1`, maintaining existing functionality."
        },
        {
            "file": "sphinx/util/docutils.py",
            "class": "",
            "method": "",
            "intended_behavior": "Update or adapt utility functions to work seamlessly with `docutils-0.17b1`, leveraging new features or changes without breaking existing integrations."
        },
        {
            "file": "sphinx/transforms/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API."
        },
        {
            "file": "sphinx/transforms/post_transforms/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API."
        }
    ]
}
2025-10-18 18:25:07.030 | DEBUG    | Bug location extracted successfully: [<file>sphinx/io.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.io
3     ~~~~~~~~~
4 
5     Input/Output files
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 import codecs
11 from typing import TYPE_CHECKING, Any, List, Type
12 
13 from docutils import nodes
14 from docutils.core import Publisher
15 from docutils.frontend import Values
16 from docutils.io import FileInput, Input, NullOutput
17 from docutils.parsers import Parser
18 from docutils.parsers.rst import Parser as RSTParser
19 from docutils.readers import standalone
20 from docutils.transforms import Transform
21 from docutils.transforms.references import DanglingReferences
22 from docutils.writers import UnfilteredWriter
23 
24 from sphinx import addnodes
25 from sphinx.environment import BuildEnvironment
26 from sphinx.transforms import (AutoIndexUpgrader, DoctreeReadEvent, FigureAligner,
27                                SphinxTransformer)
28 from sphinx.transforms.i18n import (Locale, PreserveTranslatableMessages,
29                                     RemoveTranslatableInline)
30 from sphinx.transforms.references import SphinxDomains
31 from sphinx.util import UnicodeDecodeErrorHandler, get_filetype, logging
32 from sphinx.util.docutils import LoggingReporter
33 from sphinx.versioning import UIDTransform
34 
35 if TYPE_CHECKING:
36     from sphinx.application import Sphinx
37 
38 
39 logger = logging.getLogger(__name__)
40 
41 
42 class SphinxBaseReader(standalone.Reader):
43     """
44     A base class of readers for Sphinx.
45 
46     This replaces reporter by Sphinx's on generating document.
47     """
48 
49     transforms: List[Type[Transform]] = []
50 
51     def __init__(self, *args: Any, **kwargs: Any) -> None:
52         from sphinx.application import Sphinx
53         if len(args) > 0 and isinstance(args[0], Sphinx):
54             self._app = args[0]
55             self._env = self._app.env
56             args = args[1:]
57 
58         super().__init__(*args, **kwargs)
59 
60     def setup(self, app: "Sphinx") -> None:
61         self._app = app      # hold application object only for compatibility
62         self._env = app.env
63 
64     def get_transforms(self) -> List[Type[Transform]]:
65         transforms = super().get_transforms() + self.transforms
66 
67         # remove transforms which is not needed for Sphinx
68         unused = [DanglingReferences]
69         for transform in unused:
70             if transform in transforms:
71                 transforms.remove(transform)
72 
73         return transforms
74 
75     def new_document(self) -> nodes.document:
76         """Creates a new document object which having a special reporter object good
77         for logging.
78         """
79         document = super().new_document()
80         document.__class__ = addnodes.document  # replace the class with patched version
81 
82         # substitute transformer
83         document.transformer = SphinxTransformer(document)
84         document.transformer.set_environment(self.settings.env)
85 
86         # substitute reporter
87         reporter = document.reporter
88         document.reporter = LoggingReporter.from_reporter(reporter)
89 
90         return document
91 
92 
93 class SphinxStandaloneReader(SphinxBaseReader):
94     """
95     A basic document reader for Sphinx.
96     """
97 
98     def setup(self, app: "Sphinx") -> None:
99         self.transforms = self.transforms + app.registry.get_transforms()
100         super().setup(app)
101 
102     def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:
103         self.source = source
104         if not self.parser:
105             self.parser = parser
106         self.settings = settings
107         self.input = self.read_source(settings.env)
108         self.parse()
109         return self.document
110 
111     def read_source(self, env: BuildEnvironment) -> str:
112         """Read content from source and do post-process."""
113         content = self.source.read()
114 
115         # emit "source-read" event
116         arg = [content]
117         env.events.emit('source-read', env.docname, arg)
118         return arg[0]
119 
120 
121 class SphinxI18nReader(SphinxBaseReader):
122     """
123     A document reader for i18n.
124 
125     This returns the source line number of original text as current source line number
126     to let users know where the error happened.
127     Because the translated texts are partial and they don't have correct line numbers.
128     """
129 
130     def setup(self, app: "Sphinx") -> None:
131         super().setup(app)
132 
133         self.transforms = self.transforms + app.registry.get_transforms()
134         unused = [PreserveTranslatableMessages, Locale, RemoveTranslatableInline,
135                   AutoIndexUpgrader, FigureAligner, SphinxDomains, DoctreeReadEvent,
136                   UIDTransform]
137         for transform in unused:
138             if transform in self.transforms:
139                 self.transforms.remove(transform)
140 
141 
142 class SphinxDummyWriter(UnfilteredWriter):
143     """Dummy writer module used for generating doctree."""
144 
145     supported = ('html',)  # needed to keep "meta" nodes
146 
147     def translate(self) -> None:
148         pass
149 
150 
151 def SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:
152     """Bypass source object as is to cheat Publisher."""
153     return source
154 
155 
156 class SphinxFileInput(FileInput):
157     """A basic FileInput for Sphinx."""
158     def __init__(self, *args: Any, **kwargs: Any) -> None:
159         kwargs['error_handler'] = 'sphinx'
160         super().__init__(*args, **kwargs)
161 
162 
163 def read_doc(app: "Sphinx", env: BuildEnvironment, filename: str) -> nodes.document:
164     """Parse a document and convert to doctree."""
165     # set up error_handler for the target document
166     error_handler = UnicodeDecodeErrorHandler(env.docname)
167     codecs.register_error('sphinx', error_handler)  # type: ignore
168 
169     reader = SphinxStandaloneReader()
170     reader.setup(app)
171     filetype = get_filetype(app.config.source_suffix, filename)
172     parser = app.registry.create_source_parser(app, filetype)
173     if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():
174         # a workaround for recommonmark
175         #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser
176         #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST
177         #   parser.  As a workaround, this copies settings_spec for RSTParser to the
178         #   CommonMarkParser.
179         parser.settings_spec = RSTParser.settings_spec
180 
181     pub = Publisher(reader=reader,
182                     parser=parser,
183                     writer=SphinxDummyWriter(),
184                     source_class=SphinxFileInput,
185                     destination=NullOutput())
186     pub.process_programmatic_settings(None, env.settings, None)
187     pub.set_source(source_path=filename)
188     pub.publish()
189     return pub.document

</code><intended_behavior>Ensure parsing of reStructuredText documents is compatible with `docutils-0.17b1`, maintaining existing functionality.</intended_behavior>, <file>sphinx/util/docutils.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.docutils
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Utility functions for docutils.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import os
12 import re
13 from contextlib import contextmanager
14 from copy import copy
15 from distutils.version import LooseVersion
16 from os import path
17 from types import ModuleType
18 from typing import (IO, TYPE_CHECKING, Any, Callable, Dict, Generator, List, Optional, Set,
19                     Tuple, Type, cast)
20 
21 import docutils
22 from docutils import nodes
23 from docutils.io import FileOutput
24 from docutils.nodes import Element, Node, system_message
25 from docutils.parsers.rst import Directive, directives, roles
26 from docutils.parsers.rst.states import Inliner
27 from docutils.statemachine import State, StateMachine, StringList
28 from docutils.utils import Reporter, unescape
29 
30 from sphinx.errors import SphinxError
31 from sphinx.locale import _
32 from sphinx.util import logging
33 from sphinx.util.typing import RoleFunction
34 
35 logger = logging.getLogger(__name__)
36 report_re = re.compile('^(.+?:(?:\\d+)?): \\((DEBUG|INFO|WARNING|ERROR|SEVERE)/(\\d+)?\\) ')
37 
38 if TYPE_CHECKING:
39     from sphinx.builders import Builder
40     from sphinx.config import Config
41     from sphinx.environment import BuildEnvironment
42 
43 
44 __version_info__ = tuple(LooseVersion(docutils.__version__).version)
45 additional_nodes: Set[Type[Element]] = set()
46 
47 
48 @contextmanager
49 def docutils_namespace() -> Generator[None, None, None]:
50     """Create namespace for reST parsers."""
51     try:
52         _directives = copy(directives._directives)  # type: ignore
53         _roles = copy(roles._roles)  # type: ignore
54 
55         yield
56     finally:
57         directives._directives = _directives  # type: ignore
58         roles._roles = _roles  # type: ignore
59 
60         for node in list(additional_nodes):
61             unregister_node(node)
62             additional_nodes.discard(node)
63 
64 
65 def is_directive_registered(name: str) -> bool:
66     """Check the *name* directive is already registered."""
67     return name in directives._directives  # type: ignore
68 
69 
70 def register_directive(name: str, directive: Type[Directive]) -> None:
71     """Register a directive to docutils.
72 
73     This modifies global state of docutils.  So it is better to use this
74     inside ``docutils_namespace()`` to prevent side-effects.
75     """
76     directives.register_directive(name, directive)
77 
78 
79 def is_role_registered(name: str) -> bool:
80     """Check the *name* role is already registered."""
81     return name in roles._roles  # type: ignore
82 
83 
84 def register_role(name: str, role: RoleFunction) -> None:
85     """Register a role to docutils.
86 
87     This modifies global state of docutils.  So it is better to use this
88     inside ``docutils_namespace()`` to prevent side-effects.
89     """
90     roles.register_local_role(name, role)
91 
92 
93 def unregister_role(name: str) -> None:
94     """Unregister a role from docutils."""
95     roles._roles.pop(name, None)  # type: ignore
96 
97 
98 def is_node_registered(node: Type[Element]) -> bool:
99     """Check the *node* is already registered."""
100     return hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__)
101 
102 
103 def register_node(node: Type[Element]) -> None:
104     """Register a node to docutils.
105 
106     This modifies global state of some visitors.  So it is better to use this
107     inside ``docutils_namespace()`` to prevent side-effects.
108     """
109     if not hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):
110         nodes._add_node_class_names([node.__name__])  # type: ignore
111         additional_nodes.add(node)
112 
113 
114 def unregister_node(node: Type[Element]) -> None:
115     """Unregister a node from docutils.
116 
117     This is inverse of ``nodes._add_nodes_class_names()``.
118     """
119     if hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):
120         delattr(nodes.GenericNodeVisitor, "visit_" + node.__name__)
121         delattr(nodes.GenericNodeVisitor, "depart_" + node.__name__)
122         delattr(nodes.SparseNodeVisitor, 'visit_' + node.__name__)
123         delattr(nodes.SparseNodeVisitor, 'depart_' + node.__name__)
124 
125 
126 @contextmanager
127 def patched_get_language() -> Generator[None, None, None]:
128     """Patch docutils.languages.get_language() temporarily.
129 
130     This ignores the second argument ``reporter`` to suppress warnings.
131     refs: https://github.com/sphinx-doc/sphinx/issues/3788
132     """
133     from docutils.languages import get_language
134 
135     def patched_get_language(language_code: str, reporter: Reporter = None) -> Any:
136         return get_language(language_code)
137 
138     try:
139         docutils.languages.get_language = patched_get_language
140         yield
141     finally:
142         # restore original implementations
143         docutils.languages.get_language = get_language
144 
145 
146 @contextmanager
147 def using_user_docutils_conf(confdir: Optional[str]) -> Generator[None, None, None]:
148     """Let docutils know the location of ``docutils.conf`` for Sphinx."""
149     try:
150         docutilsconfig = os.environ.get('DOCUTILSCONFIG', None)
151         if confdir:
152             os.environ['DOCUTILSCONFIG'] = path.join(path.abspath(confdir), 'docutils.conf')
153 
154         yield
155     finally:
156         if docutilsconfig is None:
157             os.environ.pop('DOCUTILSCONFIG', None)
158         else:
159             os.environ['DOCUTILSCONFIG'] = docutilsconfig
160 
161 
162 @contextmanager
163 def patch_docutils(confdir: Optional[str] = None) -> Generator[None, None, None]:
164     """Patch to docutils temporarily."""
165     with patched_get_language(), using_user_docutils_conf(confdir):
166         yield
167 
168 
169 class ElementLookupError(Exception):
170     pass
171 
172 
173 class sphinx_domains:
174     """Monkey-patch directive and role dispatch, so that domain-specific
175     markup takes precedence.
176     """
177     def __init__(self, env: "BuildEnvironment") -> None:
178         self.env = env
179         self.directive_func: Callable = None
180         self.roles_func: Callable = None
181 
182     def __enter__(self) -> None:
183         self.enable()
184 
185     def __exit__(self, exc_type: Type[Exception], exc_value: Exception, traceback: Any) -> None:  # NOQA
186         self.disable()
187 
188     def enable(self) -> None:
189         self.directive_func = directives.directive
190         self.role_func = roles.role
191 
192         directives.directive = self.lookup_directive
193         roles.role = self.lookup_role
194 
195     def disable(self) -> None:
196         directives.directive = self.directive_func
197         roles.role = self.role_func
198 
199     def lookup_domain_element(self, type: str, name: str) -> Any:
200         """Lookup a markup element (directive or role), given its name which can
201         be a full name (with domain).
202         """
203         name = name.lower()
204         # explicit domain given?
205         if ':' in name:
206             domain_name, name = name.split(':', 1)
207             if domain_name in self.env.domains:
208                 domain = self.env.get_domain(domain_name)
209                 element = getattr(domain, type)(name)
210                 if element is not None:
211                     return element, []
212             else:
213                 logger.warning(_('unknown directive or role name: %s:%s'), domain_name, name)
214         # else look in the default domain
215         else:
216             def_domain = self.env.temp_data.get('default_domain')
217             if def_domain is not None:
218                 element = getattr(def_domain, type)(name)
219                 if element is not None:
220                     return element, []
221 
222         # always look in the std domain
223         element = getattr(self.env.get_domain('std'), type)(name)
224         if element is not None:
225             return element, []
226 
227         raise ElementLookupError
228 
229     def lookup_directive(self, directive_name: str, language_module: ModuleType, document: nodes.document) -> Tuple[Optional[Type[Directive]], List[system_message]]:  # NOQA
230         try:
231             return self.lookup_domain_element('directive', directive_name)
232         except ElementLookupError:
233             return self.directive_func(directive_name, language_module, document)
234 
235     def lookup_role(self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter) -> Tuple[RoleFunction, List[system_message]]:  # NOQA
236         try:
237             return self.lookup_domain_element('role', role_name)
238         except ElementLookupError:
239             return self.role_func(role_name, language_module, lineno, reporter)
240 
241 
242 class WarningStream:
243     def write(self, text: str) -> None:
244         matched = report_re.search(text)
245         if not matched:
246             logger.warning(text.rstrip("\r\n"))
247         else:
248             location, type, level = matched.groups()
249             message = report_re.sub('', text).rstrip()
250             logger.log(type, message, location=location)
251 
252 
253 class LoggingReporter(Reporter):
254     @classmethod
255     def from_reporter(cls, reporter: Reporter) -> "LoggingReporter":
256         """Create an instance of LoggingReporter from other reporter object."""
257         return cls(reporter.source, reporter.report_level, reporter.halt_level,
258                    reporter.debug_flag, reporter.error_handler)
259 
260     def __init__(self, source: str, report_level: int = Reporter.WARNING_LEVEL,
261                  halt_level: int = Reporter.SEVERE_LEVEL, debug: bool = False,
262                  error_handler: str = 'backslashreplace') -> None:
263         stream = cast(IO, WarningStream())
264         super().__init__(source, report_level, halt_level,
265                          stream, debug, error_handler=error_handler)
266 
267 
268 class NullReporter(Reporter):
269     """A dummy reporter; write nothing."""
270 
271     def __init__(self) -> None:
272         super().__init__('', 999, 4)
273 
274 
275 def is_html5_writer_available() -> bool:
276     return __version_info__ > (0, 13, 0)
277 
278 
279 @contextmanager
280 def switch_source_input(state: State, content: StringList) -> Generator[None, None, None]:
281     """Switch current source input of state temporarily."""
282     try:
283         # remember the original ``get_source_and_line()`` method
284         get_source_and_line = state.memo.reporter.get_source_and_line  # type: ignore
285 
286         # replace it by new one
287         state_machine = StateMachine([], None)
288         state_machine.input_lines = content
289         state.memo.reporter.get_source_and_line = state_machine.get_source_and_line  # type: ignore  # NOQA
290 
291         yield
292     finally:
293         # restore the method
294         state.memo.reporter.get_source_and_line = get_source_and_line  # type: ignore
295 
296 
297 class SphinxFileOutput(FileOutput):
298     """Better FileOutput class for Sphinx."""
299 
300     def __init__(self, **kwargs: Any) -> None:
301         self.overwrite_if_changed = kwargs.pop('overwrite_if_changed', False)
302         super().__init__(**kwargs)
303 
304     def write(self, data: str) -> str:
305         if (self.destination_path and self.autoclose and 'b' not in self.mode and
306                 self.overwrite_if_changed and os.path.exists(self.destination_path)):
307             with open(self.destination_path, encoding=self.encoding) as f:
308                 # skip writing: content not changed
309                 if f.read() == data:
310                     return data
311 
312         return super().write(data)
313 
314 
315 class SphinxDirective(Directive):
316     """A base class for Sphinx directives.
317 
318     This class provides helper methods for Sphinx directives.
319 
320     .. note:: The subclasses of this class might not work with docutils.
321               This class is strongly coupled with Sphinx.
322     """
323 
324     @property
325     def env(self) -> "BuildEnvironment":
326         """Reference to the :class:`.BuildEnvironment` object."""
327         return self.state.document.settings.env
328 
329     @property
330     def config(self) -> "Config":
331         """Reference to the :class:`.Config` object."""
332         return self.env.config
333 
334     def get_source_info(self) -> Tuple[str, int]:
335         """Get source and line number."""
336         return self.state_machine.get_source_and_line(self.lineno)
337 
338     def set_source_info(self, node: Node) -> None:
339         """Set source and line number to the node."""
340         node.source, node.line = self.get_source_info()
341 
342 
343 class SphinxRole:
344     """A base class for Sphinx roles.
345 
346     This class provides helper methods for Sphinx roles.
347 
348     .. note:: The subclasses of this class might not work with docutils.
349               This class is strongly coupled with Sphinx.
350     """
351     name: str           #: The role name actually used in the document.
352     rawtext: str        #: A string containing the entire interpreted text input.
353     text: str           #: The interpreted text content.
354     lineno: int         #: The line number where the interpreted text begins.
355     inliner: Inliner    #: The ``docutils.parsers.rst.states.Inliner`` object.
356     options: Dict       #: A dictionary of directive options for customization
357                         #: (from the "role" directive).
358     content: List[str]  #: A list of strings, the directive content for customization
359                         #: (from the "role" directive).
360 
361     def __call__(self, name: str, rawtext: str, text: str, lineno: int,
362                  inliner: Inliner, options: Dict = {}, content: List[str] = []
363                  ) -> Tuple[List[Node], List[system_message]]:
364         self.rawtext = rawtext
365         self.text = unescape(text)
366         self.lineno = lineno
367         self.inliner = inliner
368         self.options = options
369         self.content = content
370 
371         # guess role type
372         if name:
373             self.name = name.lower()
374         else:
375             self.name = self.env.temp_data.get('default_role')
376             if not self.name:
377                 self.name = self.env.config.default_role
378             if not self.name:
379                 raise SphinxError('cannot determine default role!')
380 
381         return self.run()
382 
383     def run(self) -> Tuple[List[Node], List[system_message]]:
384         raise NotImplementedError
385 
386     @property
387     def env(self) -> "BuildEnvironment":
388         """Reference to the :class:`.BuildEnvironment` object."""
389         return self.inliner.document.settings.env
390 
391     @property
392     def config(self) -> "Config":
393         """Reference to the :class:`.Config` object."""
394         return self.env.config
395 
396     def get_source_info(self, lineno: int = None) -> Tuple[str, int]:
397         if lineno is None:
398             lineno = self.lineno
399         return self.inliner.reporter.get_source_and_line(lineno)  # type: ignore
400 
401     def set_source_info(self, node: Node, lineno: int = None) -> None:
402         node.source, node.line = self.get_source_info(lineno)
403 
404 
405 class ReferenceRole(SphinxRole):
406     """A base class for reference roles.
407 
408     The reference roles can accpet ``link title <target>`` style as a text for
409     the role.  The parsed result; link title and target will be stored to
410     ``self.title`` and ``self.target``.
411     """
412     has_explicit_title: bool    #: A boolean indicates the role has explicit title or not.
413     disabled: bool              #: A boolean indicates the reference is disabled.
414     title: str                  #: The link title for the interpreted text.
415     target: str                 #: The link target for the interpreted text.
416 
417     # \x00 means the "<" was backslash-escaped
418     explicit_title_re = re.compile(r'^(.+?)\s*(?<!\x00)<(.*?)>$', re.DOTALL)
419 
420     def __call__(self, name: str, rawtext: str, text: str, lineno: int,
421                  inliner: Inliner, options: Dict = {}, content: List[str] = []
422                  ) -> Tuple[List[Node], List[system_message]]:
423         # if the first character is a bang, don't cross-reference at all
424         self.disabled = text.startswith('!')
425 
426         matched = self.explicit_title_re.match(text)
427         if matched:
428             self.has_explicit_title = True
429             self.title = unescape(matched.group(1))
430             self.target = unescape(matched.group(2))
431         else:
432             self.has_explicit_title = False
433             self.title = unescape(text)
434             self.target = unescape(text)
435 
436         return super().__call__(name, rawtext, text, lineno, inliner, options, content)
437 
438 
439 class SphinxTranslator(nodes.NodeVisitor):
440     """A base class for Sphinx translators.
441 
442     This class adds a support for visitor/departure method for super node class
443     if visitor/departure method for node class is not found.
444 
445     It also provides helper methods for Sphinx translators.
446 
447     .. note:: The subclasses of this class might not work with docutils.
448               This class is strongly coupled with Sphinx.
449     """
450 
451     def __init__(self, document: nodes.document, builder: "Builder") -> None:
452         super().__init__(document)
453         self.builder = builder
454         self.config = builder.config
455         self.settings = document.settings
456 
457     def dispatch_visit(self, node: Node) -> None:
458         """
459         Dispatch node to appropriate visitor method.
460         The priority of visitor method is:
461 
462         1. ``self.visit_{node_class}()``
463         2. ``self.visit_{super_node_class}()``
464         3. ``self.unknown_visit()``
465         """
466         for node_class in node.__class__.__mro__:
467             method = getattr(self, 'visit_%s' % (node_class.__name__), None)
468             if method:
469                 method(node)
470                 break
471         else:
472             super().dispatch_visit(node)
473 
474     def dispatch_departure(self, node: Node) -> None:
475         """
476         Dispatch node to appropriate departure method.
477         The priority of departure method is:
478 
479         1. ``self.depart_{node_class}()``
480         2. ``self.depart_{super_node_class}()``
481         3. ``self.unknown_departure()``
482         """
483         for node_class in node.__class__.__mro__:
484             method = getattr(self, 'depart_%s' % (node_class.__name__), None)
485             if method:
486                 method(node)
487                 break
488         else:
489             super().dispatch_departure(node)
490 
491 
492 # cache a vanilla instance of nodes.document
493 # Used in new_document() function
494 __document_cache__: nodes.document = None
495 
496 
497 def new_document(source_path: str, settings: Any = None) -> nodes.document:
498     """Return a new empty document object.  This is an alternative of docutils'.
499 
500     This is a simple wrapper for ``docutils.utils.new_document()``.  It
501     caches the result of docutils' and use it on second call for instantiation.
502     This makes an instantiation of document nodes much faster.
503     """
504     global __document_cache__
505     if __document_cache__ is None:
506         __document_cache__ = docutils.utils.new_document(source_path)
507 
508     if settings is None:
509         # Make a copy of ``settings`` from cache to accelerate instansiation
510         settings = copy(__document_cache__.settings)
511 
512     # Create a new instance of nodes.document using cached reporter
513     from sphinx import addnodes
514     document = addnodes.document(settings, __document_cache__.reporter, source=source_path)
515     document.note_source(source_path, -1)
516     return document

</code><intended_behavior>Update or adapt utility functions to work seamlessly with `docutils-0.17b1`, leveraging new features or changes without breaking existing integrations.</intended_behavior>, <file>sphinx/transforms/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.transforms
3     ~~~~~~~~~~~~~~~~~
4 
5     Docutils transforms used by Sphinx when reading documents.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import TYPE_CHECKING, Any, Dict, Generator, List, Tuple
14 
15 from docutils import nodes
16 from docutils.nodes import Element, Node, Text
17 from docutils.transforms import Transform, Transformer
18 from docutils.transforms.parts import ContentsFilter
19 from docutils.transforms.universal import SmartQuotes
20 from docutils.utils import normalize_language_tag
21 from docutils.utils.smartquotes import smartchars
22 
23 from sphinx import addnodes
24 from sphinx.config import Config
25 from sphinx.deprecation import RemovedInSphinx60Warning
26 from sphinx.locale import _, __
27 from sphinx.util import docutils, logging
28 from sphinx.util.docutils import new_document
29 from sphinx.util.i18n import format_date
30 from sphinx.util.nodes import NodeMatcher, apply_source_workaround, is_smartquotable
31 
32 if TYPE_CHECKING:
33     from sphinx.application import Sphinx
34     from sphinx.domain.std import StandardDomain
35     from sphinx.environment import BuildEnvironment
36 
37 
38 logger = logging.getLogger(__name__)
39 
40 default_substitutions = {
41     'version',
42     'release',
43     'today',
44 }
45 
46 
47 class SphinxTransform(Transform):
48     """A base class of Transforms.
49 
50     Compared with ``docutils.transforms.Transform``, this class improves accessibility to
51     Sphinx APIs.
52     """
53 
54     @property
55     def app(self) -> "Sphinx":
56         """Reference to the :class:`.Sphinx` object."""
57         return self.env.app
58 
59     @property
60     def env(self) -> "BuildEnvironment":
61         """Reference to the :class:`.BuildEnvironment` object."""
62         return self.document.settings.env
63 
64     @property
65     def config(self) -> Config:
66         """Reference to the :class:`.Config` object."""
67         return self.env.config
68 
69 
70 class SphinxTransformer(Transformer):
71     """
72     A transformer for Sphinx.
73     """
74 
75     document: nodes.document = None
76     env: "BuildEnvironment" = None
77 
78     def set_environment(self, env: "BuildEnvironment") -> None:
79         self.env = env
80 
81     def apply_transforms(self) -> None:
82         if isinstance(self.document, nodes.document):
83             if not hasattr(self.document.settings, 'env') and self.env:
84                 self.document.settings.env = self.env
85 
86             super().apply_transforms()
87         else:
88             # wrap the target node by document node during transforming
89             try:
90                 document = new_document('')
91                 if self.env:
92                     document.settings.env = self.env
93                 document += self.document
94                 self.document = document
95                 super().apply_transforms()
96             finally:
97                 self.document = self.document[0]
98 
99 
100 class DefaultSubstitutions(SphinxTransform):
101     """
102     Replace some substitutions if they aren't defined in the document.
103     """
104     # run before the default Substitutions
105     default_priority = 210
106 
107     def apply(self, **kwargs: Any) -> None:
108         # only handle those not otherwise defined in the document
109         to_handle = default_substitutions - set(self.document.substitution_defs)
110         for ref in self.document.traverse(nodes.substitution_reference):
111             refname = ref['refname']
112             if refname in to_handle:
113                 text = self.config[refname]
114                 if refname == 'today' and not text:
115                     # special handling: can also specify a strftime format
116                     text = format_date(self.config.today_fmt or _('%b %d, %Y'),
117                                        language=self.config.language)
118                 ref.replace_self(nodes.Text(text, text))
119 
120 
121 class MoveModuleTargets(SphinxTransform):
122     """
123     Move module targets that are the first thing in a section to the section
124     title.
125 
126     XXX Python specific
127     """
128     default_priority = 210
129 
130     def apply(self, **kwargs: Any) -> None:
131         for node in self.document.traverse(nodes.target):
132             if not node['ids']:
133                 continue
134             if ('ismod' in node and
135                     node.parent.__class__ is nodes.section and
136                     # index 0 is the section title node
137                     node.parent.index(node) == 1):
138                 node.parent['ids'][0:0] = node['ids']
139                 node.parent.remove(node)
140 
141 
142 class HandleCodeBlocks(SphinxTransform):
143     """
144     Several code block related transformations.
145     """
146     default_priority = 210
147 
148     def apply(self, **kwargs: Any) -> None:
149         # move doctest blocks out of blockquotes
150         for node in self.document.traverse(nodes.block_quote):
151             if all(isinstance(child, nodes.doctest_block) for child
152                    in node.children):
153                 node.replace_self(node.children)
154         # combine successive doctest blocks
155         # for node in self.document.traverse(nodes.doctest_block):
156         #    if node not in node.parent.children:
157         #        continue
158         #    parindex = node.parent.index(node)
159         #    while len(node.parent) > parindex+1 and \
160         #            isinstance(node.parent[parindex+1], nodes.doctest_block):
161         #        node[0] = nodes.Text(node[0] + '\n\n' +
162         #                             node.parent[parindex+1][0])
163         #        del node.parent[parindex+1]
164 
165 
166 class AutoNumbering(SphinxTransform):
167     """
168     Register IDs of tables, figures and literal_blocks to assign numbers.
169     """
170     default_priority = 210
171 
172     def apply(self, **kwargs: Any) -> None:
173         domain: StandardDomain = self.env.get_domain('std')
174 
175         for node in self.document.traverse(nodes.Element):
176             if (domain.is_enumerable_node(node) and
177                     domain.get_numfig_title(node) is not None and
178                     node['ids'] == []):
179                 self.document.note_implicit_target(node)
180 
181 
182 class SortIds(SphinxTransform):
183     """
184     Sort secion IDs so that the "id[0-9]+" one comes last.
185     """
186     default_priority = 261
187 
188     def apply(self, **kwargs: Any) -> None:
189         for node in self.document.traverse(nodes.section):
190             if len(node['ids']) > 1 and node['ids'][0].startswith('id'):
191                 node['ids'] = node['ids'][1:] + [node['ids'][0]]
192 
193 
194 TRANSLATABLE_NODES = {
195     'literal-block': nodes.literal_block,
196     'doctest-block': nodes.doctest_block,
197     'raw': nodes.raw,
198     'index': addnodes.index,
199     'image': nodes.image,
200 }
201 
202 
203 class ApplySourceWorkaround(SphinxTransform):
204     """
205     update source and rawsource attributes
206     """
207     default_priority = 10
208 
209     def apply(self, **kwargs: Any) -> None:
210         for node in self.document.traverse():  # type: Node
211             if isinstance(node, (nodes.TextElement, nodes.image)):
212                 apply_source_workaround(node)
213 
214 
215 class AutoIndexUpgrader(SphinxTransform):
216     """
217     Detect old style; 4 column based indices and automatically upgrade to new style.
218     """
219     default_priority = 210
220 
221     def apply(self, **kwargs: Any) -> None:
222         for node in self.document.traverse(addnodes.index):
223             if 'entries' in node and any(len(entry) == 4 for entry in node['entries']):
224                 msg = __('4 column based index found. '
225                          'It might be a bug of extensions you use: %r') % node['entries']
226                 logger.warning(msg, location=node)
227                 for i, entry in enumerate(node['entries']):
228                     if len(entry) == 4:
229                         node['entries'][i] = entry + (None,)
230 
231 
232 class ExtraTranslatableNodes(SphinxTransform):
233     """
234     make nodes translatable
235     """
236     default_priority = 10
237 
238     def apply(self, **kwargs: Any) -> None:
239         targets = self.config.gettext_additional_targets
240         target_nodes = [v for k, v in TRANSLATABLE_NODES.items() if k in targets]
241         if not target_nodes:
242             return
243 
244         def is_translatable_node(node: Node) -> bool:
245             return isinstance(node, tuple(target_nodes))
246 
247         for node in self.document.traverse(is_translatable_node):  # type: Element
248             node['translatable'] = True
249 
250 
251 class UnreferencedFootnotesDetector(SphinxTransform):
252     """
253     detect unreferenced footnotes and emit warnings
254     """
255     default_priority = 200
256 
257     def apply(self, **kwargs: Any) -> None:
258         for node in self.document.footnotes:
259             if node['names'] == []:
260                 # footnote having duplicated number.  It is already warned at parser.
261                 pass
262             elif node['names'][0] not in self.document.footnote_refs:
263                 logger.warning(__('Footnote [%s] is not referenced.'), node['names'][0],
264                                type='ref', subtype='footnote',
265                                location=node)
266 
267         for node in self.document.autofootnotes:
268             if not any(ref['auto'] == node['auto'] for ref in self.document.autofootnote_refs):
269                 logger.warning(__('Footnote [#] is not referenced.'),
270                                type='ref', subtype='footnote',
271                                location=node)
272 
273 
274 class DoctestTransform(SphinxTransform):
275     """Set "doctest" style to each doctest_block node"""
276     default_priority = 500
277 
278     def apply(self, **kwargs: Any) -> None:
279         for node in self.document.traverse(nodes.doctest_block):
280             node['classes'].append('doctest')
281 
282 
283 class FigureAligner(SphinxTransform):
284     """
285     Align figures to center by default.
286     """
287     default_priority = 700
288 
289     def __init__(self, *args: Any, **kwargs: Any) -> None:
290         warnings.warn('FigureAilgner is deprecated.',
291                       RemovedInSphinx60Warning)
292         super().__init__(*args, **kwargs)
293 
294     def apply(self, **kwargs: Any) -> None:
295         matcher = NodeMatcher(nodes.table, nodes.figure)
296         for node in self.document.traverse(matcher):  # type: Element
297             node.setdefault('align', 'default')
298 
299 
300 class FilterSystemMessages(SphinxTransform):
301     """Filter system messages from a doctree."""
302     default_priority = 999
303 
304     def apply(self, **kwargs: Any) -> None:
305         filterlevel = 2 if self.config.keep_warnings else 5
306         for node in self.document.traverse(nodes.system_message):
307             if node['level'] < filterlevel:
308                 logger.debug('%s [filtered system message]', node.astext())
309                 node.parent.remove(node)
310 
311 
312 class SphinxContentsFilter(ContentsFilter):
313     """
314     Used with BuildEnvironment.add_toc_from() to discard cross-file links
315     within table-of-contents link nodes.
316     """
317     visit_pending_xref = ContentsFilter.ignore_node_but_process_children
318 
319     def visit_image(self, node: nodes.image) -> None:
320         raise nodes.SkipNode
321 
322 
323 class SphinxSmartQuotes(SmartQuotes, SphinxTransform):
324     """
325     Customized SmartQuotes to avoid transform for some extra node types.
326 
327     refs: sphinx.parsers.RSTParser
328     """
329     default_priority = 750
330 
331     def apply(self, **kwargs: Any) -> None:
332         if not self.is_available():
333             return
334 
335         # override default settings with :confval:`smartquotes_action`
336         self.smartquotes_action = self.config.smartquotes_action
337 
338         super().apply()
339 
340     def is_available(self) -> bool:
341         builders = self.config.smartquotes_excludes.get('builders', [])
342         languages = self.config.smartquotes_excludes.get('languages', [])
343 
344         if self.document.settings.smart_quotes is False:
345             # disabled by 3rd party extension (workaround)
346             return False
347         elif self.config.smartquotes is False:
348             # disabled by confval smartquotes
349             return False
350         elif self.app.builder.name in builders:
351             # disabled by confval smartquotes_excludes['builders']
352             return False
353         elif self.config.language in languages:
354             # disabled by confval smartquotes_excludes['languages']
355             return False
356 
357         # confirm selected language supports smart_quotes or not
358         language = self.env.settings['language_code']
359         for tag in normalize_language_tag(language):
360             if tag in smartchars.quotes:
361                 return True
362         else:
363             return False
364 
365     def get_tokens(self, txtnodes: List[Text]) -> Generator[Tuple[str, str], None, None]:
366         # A generator that yields ``(texttype, nodetext)`` tuples for a list
367         # of "Text" nodes (interface to ``smartquotes.educate_tokens()``).
368         for txtnode in txtnodes:
369             if is_smartquotable(txtnode):
370                 if docutils.__version_info__ >= (0, 16):
371                     # SmartQuotes uses backslash escapes instead of null-escapes
372                     text = re.sub(r'(?<=\x00)([-\\\'".`])', r'\\\1', str(txtnode))
373                 else:
374                     text = txtnode.astext()
375 
376                 yield ('plain', text)
377             else:
378                 # skip smart quotes
379                 yield ('literal', txtnode.astext())
380 
381 
382 class DoctreeReadEvent(SphinxTransform):
383     """Emit :event:`doctree-read` event."""
384     default_priority = 880
385 
386     def apply(self, **kwargs: Any) -> None:
387         self.app.emit('doctree-read', self.document)
388 
389 
390 class ManpageLink(SphinxTransform):
391     """Find manpage section numbers and names"""
392     default_priority = 999
393 
394     def apply(self, **kwargs: Any) -> None:
395         for node in self.document.traverse(addnodes.manpage):
396             manpage = ' '.join([str(x) for x in node.children
397                                 if isinstance(x, nodes.Text)])
398             pattern = r'^(?P<path>(?P<page>.+)[\(\.](?P<section>[1-9]\w*)?\)?)$'  # noqa
399             info = {'path': manpage,
400                     'page': manpage,
401                     'section': ''}
402             r = re.match(pattern, manpage)
403             if r:
404                 info = r.groupdict()
405             node.attributes.update(info)
406 
407 
408 def setup(app: "Sphinx") -> Dict[str, Any]:
409     app.add_transform(ApplySourceWorkaround)
410     app.add_transform(ExtraTranslatableNodes)
411     app.add_transform(DefaultSubstitutions)
412     app.add_transform(MoveModuleTargets)
413     app.add_transform(HandleCodeBlocks)
414     app.add_transform(SortIds)
415     app.add_transform(DoctestTransform)
416     app.add_transform(AutoNumbering)
417     app.add_transform(AutoIndexUpgrader)
418     app.add_transform(FilterSystemMessages)
419     app.add_transform(UnreferencedFootnotesDetector)
420     app.add_transform(SphinxSmartQuotes)
421     app.add_transform(DoctreeReadEvent)
422     app.add_transform(ManpageLink)
423 
424     return {
425         'version': 'builtin',
426         'parallel_read_safe': True,
427         'parallel_write_safe': True,
428     }

</code><intended_behavior>Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API.</intended_behavior>, <file>sphinx/transforms/post_transforms/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.transforms.post_transforms
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Docutils transforms used by Sphinx.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Dict, List, Optional, Tuple, Type, cast
12 
13 from docutils import nodes
14 from docutils.nodes import Element
15 
16 from sphinx import addnodes
17 from sphinx.addnodes import pending_xref
18 from sphinx.application import Sphinx
19 from sphinx.domains import Domain
20 from sphinx.errors import NoUri
21 from sphinx.locale import __
22 from sphinx.transforms import SphinxTransform
23 from sphinx.util import logging
24 from sphinx.util.docutils import SphinxTranslator
25 from sphinx.util.nodes import find_pending_xref_condition, process_only_nodes
26 
27 logger = logging.getLogger(__name__)
28 
29 if False:
30     # For type annotation
31     from docutils.nodes import Node
32 
33 
34 class SphinxPostTransform(SphinxTransform):
35     """A base class of post-transforms.
36 
37     Post transforms are invoked to modify the document to restructure it for outputting.
38     They do resolving references, convert images, special transformation for each output
39     formats and so on.  This class helps to implement these post transforms.
40     """
41     builders: Tuple[str, ...] = ()
42     formats: Tuple[str, ...] = ()
43 
44     def apply(self, **kwargs: Any) -> None:
45         if self.is_supported():
46             self.run(**kwargs)
47 
48     def is_supported(self) -> bool:
49         """Check this transform working for current builder."""
50         if self.builders and self.app.builder.name not in self.builders:
51             return False
52         if self.formats and self.app.builder.format not in self.formats:
53             return False
54 
55         return True
56 
57     def run(self, **kwargs: Any) -> None:
58         """main method of post transforms.
59 
60         Subclasses should override this method instead of ``apply()``.
61         """
62         raise NotImplementedError
63 
64 
65 class ReferencesResolver(SphinxPostTransform):
66     """
67     Resolves cross-references on doctrees.
68     """
69 
70     default_priority = 10
71 
72     def run(self, **kwargs: Any) -> None:
73         for node in self.document.traverse(addnodes.pending_xref):
74             contnode = cast(nodes.TextElement, node[0].deepcopy())
75             newnode = None
76 
77             typ = node['reftype']
78             target = node['reftarget']
79             refdoc = node.get('refdoc', self.env.docname)
80             domain = None
81 
82             try:
83                 if 'refdomain' in node and node['refdomain']:
84                     # let the domain try to resolve the reference
85                     try:
86                         domain = self.env.domains[node['refdomain']]
87                     except KeyError as exc:
88                         raise NoUri(target, typ) from exc
89                     newnode = domain.resolve_xref(self.env, refdoc, self.app.builder,
90                                                   typ, target, node, contnode)
91                 # really hardwired reference types
92                 elif typ == 'any':
93                     newnode = self.resolve_anyref(refdoc, node, contnode)
94                 # no new node found? try the missing-reference event
95                 if newnode is None:
96                     newnode = self.app.emit_firstresult('missing-reference', self.env,
97                                                         node, contnode,
98                                                         allowed_exceptions=(NoUri,))
99                     # still not found? warn if node wishes to be warned about or
100                     # we are in nit-picky mode
101                     if newnode is None:
102                         self.warn_missing_reference(refdoc, typ, target, node, domain)
103             except NoUri:
104                 newnode = None
105 
106             if newnode:
107                 newnodes: List[Node] = [newnode]
108             else:
109                 newnodes = [contnode]
110                 if newnode is None and isinstance(node[0], addnodes.pending_xref_condition):
111                     matched = find_pending_xref_condition(node, "*")
112                     if matched:
113                         newnodes = matched.children
114                     else:
115                         logger.warning(__('Could not determine the fallback text for the '
116                                           'cross-reference. Might be a bug.'), location=node)
117 
118             node.replace_self(newnodes)
119 
120     def resolve_anyref(self, refdoc: str, node: pending_xref, contnode: Element) -> Element:
121         """Resolve reference generated by the "any" role."""
122         stddomain = self.env.get_domain('std')
123         target = node['reftarget']
124         results: List[Tuple[str, Element]] = []
125         # first, try resolving as :doc:
126         doc_ref = stddomain.resolve_xref(self.env, refdoc, self.app.builder,
127                                          'doc', target, node, contnode)
128         if doc_ref:
129             results.append(('doc', doc_ref))
130         # next, do the standard domain (makes this a priority)
131         results.extend(stddomain.resolve_any_xref(self.env, refdoc, self.app.builder,
132                                                   target, node, contnode))
133         for domain in self.env.domains.values():
134             if domain.name == 'std':
135                 continue  # we did this one already
136             try:
137                 results.extend(domain.resolve_any_xref(self.env, refdoc, self.app.builder,
138                                                        target, node, contnode))
139             except NotImplementedError:
140                 # the domain doesn't yet support the new interface
141                 # we have to manually collect possible references (SLOW)
142                 for role in domain.roles:
143                     res = domain.resolve_xref(self.env, refdoc, self.app.builder,
144                                               role, target, node, contnode)
145                     if res and len(res) > 0 and isinstance(res[0], nodes.Element):
146                         results.append(('%s:%s' % (domain.name, role), res))
147         # now, see how many matches we got...
148         if not results:
149             return None
150         if len(results) > 1:
151             def stringify(name: str, node: Element) -> str:
152                 reftitle = node.get('reftitle', node.astext())
153                 return ':%s:`%s`' % (name, reftitle)
154             candidates = ' or '.join(stringify(name, role) for name, role in results)
155             logger.warning(__('more than one target found for \'any\' cross-'
156                               'reference %r: could be %s'), target, candidates,
157                            location=node)
158         res_role, newnode = results[0]
159         # Override "any" class with the actual role type to get the styling
160         # approximately correct.
161         res_domain = res_role.split(':')[0]
162         if (len(newnode) > 0 and
163                 isinstance(newnode[0], nodes.Element) and
164                 newnode[0].get('classes')):
165             newnode[0]['classes'].append(res_domain)
166             newnode[0]['classes'].append(res_role.replace(':', '-'))
167         return newnode
168 
169     def warn_missing_reference(self, refdoc: str, typ: str, target: str,
170                                node: pending_xref, domain: Optional[Domain]) -> None:
171         warn = node.get('refwarn')
172         if self.config.nitpicky:
173             warn = True
174             if self.config.nitpick_ignore:
175                 dtype = '%s:%s' % (domain.name, typ) if domain else typ
176                 if (dtype, target) in self.config.nitpick_ignore:
177                     warn = False
178                 # for "std" types also try without domain name
179                 if (not domain or domain.name == 'std') and \
180                    (typ, target) in self.config.nitpick_ignore:
181                     warn = False
182         if not warn:
183             return
184 
185         if self.app.emit_firstresult('warn-missing-reference', domain, node):
186             return
187         elif domain and typ in domain.dangling_warnings:
188             msg = domain.dangling_warnings[typ] % {'target': target}
189         elif node.get('refdomain', 'std') not in ('', 'std'):
190             msg = (__('%s:%s reference target not found: %s') %
191                    (node['refdomain'], typ, target))
192         else:
193             msg = __('%r reference target not found: %s') % (typ, target)
194         logger.warning(msg, location=node, type='ref', subtype=typ)
195 
196 
197 class OnlyNodeTransform(SphinxPostTransform):
198     default_priority = 50
199 
200     def run(self, **kwargs: Any) -> None:
201         # A comment on the comment() nodes being inserted: replacing by [] would
202         # result in a "Losing ids" exception if there is a target node before
203         # the only node, so we make sure docutils can transfer the id to
204         # something, even if it's just a comment and will lose the id anyway...
205         process_only_nodes(self.document, self.app.builder.tags)
206 
207 
208 class SigElementFallbackTransform(SphinxPostTransform):
209     """Fallback desc_sig_element nodes to inline if translator does not supported them."""
210     default_priority = 200
211 
212     SIG_ELEMENTS = [addnodes.desc_sig_name,
213                     addnodes.desc_sig_operator,
214                     addnodes.desc_sig_punctuation]
215 
216     def run(self, **kwargs: Any) -> None:
217         def has_visitor(translator: Type[nodes.NodeVisitor], node: Type[Element]) -> bool:
218             return hasattr(translator, "visit_%s" % node.__name__)
219 
220         translator = self.app.builder.get_translator_class()
221         if isinstance(translator, SphinxTranslator):
222             # subclass of SphinxTranslator supports desc_sig_element nodes automatically.
223             return
224 
225         if all(has_visitor(translator, node) for node in self.SIG_ELEMENTS):
226             # the translator supports all desc_sig_element nodes
227             return
228         else:
229             self.fallback()
230 
231     def fallback(self) -> None:
232         for node in self.document.traverse(addnodes.desc_sig_element):
233             newnode = nodes.inline()
234             newnode.update_all_atts(node)
235             newnode.extend(node)
236             node.replace_self(newnode)
237 
238 
239 def setup(app: Sphinx) -> Dict[str, Any]:
240     app.add_post_transform(ReferencesResolver)
241     app.add_post_transform(OnlyNodeTransform)
242     app.add_post_transform(SigElementFallbackTransform)
243 
244     return {
245         'version': 'builtin',
246         'parallel_read_safe': True,
247         'parallel_write_safe': True,
248     }

</code><intended_behavior>Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API.</intended_behavior>]
2025-10-18 18:25:07.031 | INFO     | Search completed. Bug locations: [<file>sphinx/io.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.io
3     ~~~~~~~~~
4 
5     Input/Output files
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 import codecs
11 from typing import TYPE_CHECKING, Any, List, Type
12 
13 from docutils import nodes
14 from docutils.core import Publisher
15 from docutils.frontend import Values
16 from docutils.io import FileInput, Input, NullOutput
17 from docutils.parsers import Parser
18 from docutils.parsers.rst import Parser as RSTParser
19 from docutils.readers import standalone
20 from docutils.transforms import Transform
21 from docutils.transforms.references import DanglingReferences
22 from docutils.writers import UnfilteredWriter
23 
24 from sphinx import addnodes
25 from sphinx.environment import BuildEnvironment
26 from sphinx.transforms import (AutoIndexUpgrader, DoctreeReadEvent, FigureAligner,
27                                SphinxTransformer)
28 from sphinx.transforms.i18n import (Locale, PreserveTranslatableMessages,
29                                     RemoveTranslatableInline)
30 from sphinx.transforms.references import SphinxDomains
31 from sphinx.util import UnicodeDecodeErrorHandler, get_filetype, logging
32 from sphinx.util.docutils import LoggingReporter
33 from sphinx.versioning import UIDTransform
34 
35 if TYPE_CHECKING:
36     from sphinx.application import Sphinx
37 
38 
39 logger = logging.getLogger(__name__)
40 
41 
42 class SphinxBaseReader(standalone.Reader):
43     """
44     A base class of readers for Sphinx.
45 
46     This replaces reporter by Sphinx's on generating document.
47     """
48 
49     transforms: List[Type[Transform]] = []
50 
51     def __init__(self, *args: Any, **kwargs: Any) -> None:
52         from sphinx.application import Sphinx
53         if len(args) > 0 and isinstance(args[0], Sphinx):
54             self._app = args[0]
55             self._env = self._app.env
56             args = args[1:]
57 
58         super().__init__(*args, **kwargs)
59 
60     def setup(self, app: "Sphinx") -> None:
61         self._app = app      # hold application object only for compatibility
62         self._env = app.env
63 
64     def get_transforms(self) -> List[Type[Transform]]:
65         transforms = super().get_transforms() + self.transforms
66 
67         # remove transforms which is not needed for Sphinx
68         unused = [DanglingReferences]
69         for transform in unused:
70             if transform in transforms:
71                 transforms.remove(transform)
72 
73         return transforms
74 
75     def new_document(self) -> nodes.document:
76         """Creates a new document object which having a special reporter object good
77         for logging.
78         """
79         document = super().new_document()
80         document.__class__ = addnodes.document  # replace the class with patched version
81 
82         # substitute transformer
83         document.transformer = SphinxTransformer(document)
84         document.transformer.set_environment(self.settings.env)
85 
86         # substitute reporter
87         reporter = document.reporter
88         document.reporter = LoggingReporter.from_reporter(reporter)
89 
90         return document
91 
92 
93 class SphinxStandaloneReader(SphinxBaseReader):
94     """
95     A basic document reader for Sphinx.
96     """
97 
98     def setup(self, app: "Sphinx") -> None:
99         self.transforms = self.transforms + app.registry.get_transforms()
100         super().setup(app)
101 
102     def read(self, source: Input, parser: Parser, settings: Values) -> nodes.document:
103         self.source = source
104         if not self.parser:
105             self.parser = parser
106         self.settings = settings
107         self.input = self.read_source(settings.env)
108         self.parse()
109         return self.document
110 
111     def read_source(self, env: BuildEnvironment) -> str:
112         """Read content from source and do post-process."""
113         content = self.source.read()
114 
115         # emit "source-read" event
116         arg = [content]
117         env.events.emit('source-read', env.docname, arg)
118         return arg[0]
119 
120 
121 class SphinxI18nReader(SphinxBaseReader):
122     """
123     A document reader for i18n.
124 
125     This returns the source line number of original text as current source line number
126     to let users know where the error happened.
127     Because the translated texts are partial and they don't have correct line numbers.
128     """
129 
130     def setup(self, app: "Sphinx") -> None:
131         super().setup(app)
132 
133         self.transforms = self.transforms + app.registry.get_transforms()
134         unused = [PreserveTranslatableMessages, Locale, RemoveTranslatableInline,
135                   AutoIndexUpgrader, FigureAligner, SphinxDomains, DoctreeReadEvent,
136                   UIDTransform]
137         for transform in unused:
138             if transform in self.transforms:
139                 self.transforms.remove(transform)
140 
141 
142 class SphinxDummyWriter(UnfilteredWriter):
143     """Dummy writer module used for generating doctree."""
144 
145     supported = ('html',)  # needed to keep "meta" nodes
146 
147     def translate(self) -> None:
148         pass
149 
150 
151 def SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -> Any:
152     """Bypass source object as is to cheat Publisher."""
153     return source
154 
155 
156 class SphinxFileInput(FileInput):
157     """A basic FileInput for Sphinx."""
158     def __init__(self, *args: Any, **kwargs: Any) -> None:
159         kwargs['error_handler'] = 'sphinx'
160         super().__init__(*args, **kwargs)
161 
162 
163 def read_doc(app: "Sphinx", env: BuildEnvironment, filename: str) -> nodes.document:
164     """Parse a document and convert to doctree."""
165     # set up error_handler for the target document
166     error_handler = UnicodeDecodeErrorHandler(env.docname)
167     codecs.register_error('sphinx', error_handler)  # type: ignore
168 
169     reader = SphinxStandaloneReader()
170     reader.setup(app)
171     filetype = get_filetype(app.config.source_suffix, filename)
172     parser = app.registry.create_source_parser(app, filetype)
173     if parser.__class__.__name__ == 'CommonMarkParser' and parser.settings_spec == ():
174         # a workaround for recommonmark
175         #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser
176         #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST
177         #   parser.  As a workaround, this copies settings_spec for RSTParser to the
178         #   CommonMarkParser.
179         parser.settings_spec = RSTParser.settings_spec
180 
181     pub = Publisher(reader=reader,
182                     parser=parser,
183                     writer=SphinxDummyWriter(),
184                     source_class=SphinxFileInput,
185                     destination=NullOutput())
186     pub.process_programmatic_settings(None, env.settings, None)
187     pub.set_source(source_path=filename)
188     pub.publish()
189     return pub.document

</code><intended_behavior>Ensure parsing of reStructuredText documents is compatible with `docutils-0.17b1`, maintaining existing functionality.</intended_behavior>, <file>sphinx/util/docutils.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.docutils
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Utility functions for docutils.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import os
12 import re
13 from contextlib import contextmanager
14 from copy import copy
15 from distutils.version import LooseVersion
16 from os import path
17 from types import ModuleType
18 from typing import (IO, TYPE_CHECKING, Any, Callable, Dict, Generator, List, Optional, Set,
19                     Tuple, Type, cast)
20 
21 import docutils
22 from docutils import nodes
23 from docutils.io import FileOutput
24 from docutils.nodes import Element, Node, system_message
25 from docutils.parsers.rst import Directive, directives, roles
26 from docutils.parsers.rst.states import Inliner
27 from docutils.statemachine import State, StateMachine, StringList
28 from docutils.utils import Reporter, unescape
29 
30 from sphinx.errors import SphinxError
31 from sphinx.locale import _
32 from sphinx.util import logging
33 from sphinx.util.typing import RoleFunction
34 
35 logger = logging.getLogger(__name__)
36 report_re = re.compile('^(.+?:(?:\\d+)?): \\((DEBUG|INFO|WARNING|ERROR|SEVERE)/(\\d+)?\\) ')
37 
38 if TYPE_CHECKING:
39     from sphinx.builders import Builder
40     from sphinx.config import Config
41     from sphinx.environment import BuildEnvironment
42 
43 
44 __version_info__ = tuple(LooseVersion(docutils.__version__).version)
45 additional_nodes: Set[Type[Element]] = set()
46 
47 
48 @contextmanager
49 def docutils_namespace() -> Generator[None, None, None]:
50     """Create namespace for reST parsers."""
51     try:
52         _directives = copy(directives._directives)  # type: ignore
53         _roles = copy(roles._roles)  # type: ignore
54 
55         yield
56     finally:
57         directives._directives = _directives  # type: ignore
58         roles._roles = _roles  # type: ignore
59 
60         for node in list(additional_nodes):
61             unregister_node(node)
62             additional_nodes.discard(node)
63 
64 
65 def is_directive_registered(name: str) -> bool:
66     """Check the *name* directive is already registered."""
67     return name in directives._directives  # type: ignore
68 
69 
70 def register_directive(name: str, directive: Type[Directive]) -> None:
71     """Register a directive to docutils.
72 
73     This modifies global state of docutils.  So it is better to use this
74     inside ``docutils_namespace()`` to prevent side-effects.
75     """
76     directives.register_directive(name, directive)
77 
78 
79 def is_role_registered(name: str) -> bool:
80     """Check the *name* role is already registered."""
81     return name in roles._roles  # type: ignore
82 
83 
84 def register_role(name: str, role: RoleFunction) -> None:
85     """Register a role to docutils.
86 
87     This modifies global state of docutils.  So it is better to use this
88     inside ``docutils_namespace()`` to prevent side-effects.
89     """
90     roles.register_local_role(name, role)
91 
92 
93 def unregister_role(name: str) -> None:
94     """Unregister a role from docutils."""
95     roles._roles.pop(name, None)  # type: ignore
96 
97 
98 def is_node_registered(node: Type[Element]) -> bool:
99     """Check the *node* is already registered."""
100     return hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__)
101 
102 
103 def register_node(node: Type[Element]) -> None:
104     """Register a node to docutils.
105 
106     This modifies global state of some visitors.  So it is better to use this
107     inside ``docutils_namespace()`` to prevent side-effects.
108     """
109     if not hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):
110         nodes._add_node_class_names([node.__name__])  # type: ignore
111         additional_nodes.add(node)
112 
113 
114 def unregister_node(node: Type[Element]) -> None:
115     """Unregister a node from docutils.
116 
117     This is inverse of ``nodes._add_nodes_class_names()``.
118     """
119     if hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):
120         delattr(nodes.GenericNodeVisitor, "visit_" + node.__name__)
121         delattr(nodes.GenericNodeVisitor, "depart_" + node.__name__)
122         delattr(nodes.SparseNodeVisitor, 'visit_' + node.__name__)
123         delattr(nodes.SparseNodeVisitor, 'depart_' + node.__name__)
124 
125 
126 @contextmanager
127 def patched_get_language() -> Generator[None, None, None]:
128     """Patch docutils.languages.get_language() temporarily.
129 
130     This ignores the second argument ``reporter`` to suppress warnings.
131     refs: https://github.com/sphinx-doc/sphinx/issues/3788
132     """
133     from docutils.languages import get_language
134 
135     def patched_get_language(language_code: str, reporter: Reporter = None) -> Any:
136         return get_language(language_code)
137 
138     try:
139         docutils.languages.get_language = patched_get_language
140         yield
141     finally:
142         # restore original implementations
143         docutils.languages.get_language = get_language
144 
145 
146 @contextmanager
147 def using_user_docutils_conf(confdir: Optional[str]) -> Generator[None, None, None]:
148     """Let docutils know the location of ``docutils.conf`` for Sphinx."""
149     try:
150         docutilsconfig = os.environ.get('DOCUTILSCONFIG', None)
151         if confdir:
152             os.environ['DOCUTILSCONFIG'] = path.join(path.abspath(confdir), 'docutils.conf')
153 
154         yield
155     finally:
156         if docutilsconfig is None:
157             os.environ.pop('DOCUTILSCONFIG', None)
158         else:
159             os.environ['DOCUTILSCONFIG'] = docutilsconfig
160 
161 
162 @contextmanager
163 def patch_docutils(confdir: Optional[str] = None) -> Generator[None, None, None]:
164     """Patch to docutils temporarily."""
165     with patched_get_language(), using_user_docutils_conf(confdir):
166         yield
167 
168 
169 class ElementLookupError(Exception):
170     pass
171 
172 
173 class sphinx_domains:
174     """Monkey-patch directive and role dispatch, so that domain-specific
175     markup takes precedence.
176     """
177     def __init__(self, env: "BuildEnvironment") -> None:
178         self.env = env
179         self.directive_func: Callable = None
180         self.roles_func: Callable = None
181 
182     def __enter__(self) -> None:
183         self.enable()
184 
185     def __exit__(self, exc_type: Type[Exception], exc_value: Exception, traceback: Any) -> None:  # NOQA
186         self.disable()
187 
188     def enable(self) -> None:
189         self.directive_func = directives.directive
190         self.role_func = roles.role
191 
192         directives.directive = self.lookup_directive
193         roles.role = self.lookup_role
194 
195     def disable(self) -> None:
196         directives.directive = self.directive_func
197         roles.role = self.role_func
198 
199     def lookup_domain_element(self, type: str, name: str) -> Any:
200         """Lookup a markup element (directive or role), given its name which can
201         be a full name (with domain).
202         """
203         name = name.lower()
204         # explicit domain given?
205         if ':' in name:
206             domain_name, name = name.split(':', 1)
207             if domain_name in self.env.domains:
208                 domain = self.env.get_domain(domain_name)
209                 element = getattr(domain, type)(name)
210                 if element is not None:
211                     return element, []
212             else:
213                 logger.warning(_('unknown directive or role name: %s:%s'), domain_name, name)
214         # else look in the default domain
215         else:
216             def_domain = self.env.temp_data.get('default_domain')
217             if def_domain is not None:
218                 element = getattr(def_domain, type)(name)
219                 if element is not None:
220                     return element, []
221 
222         # always look in the std domain
223         element = getattr(self.env.get_domain('std'), type)(name)
224         if element is not None:
225             return element, []
226 
227         raise ElementLookupError
228 
229     def lookup_directive(self, directive_name: str, language_module: ModuleType, document: nodes.document) -> Tuple[Optional[Type[Directive]], List[system_message]]:  # NOQA
230         try:
231             return self.lookup_domain_element('directive', directive_name)
232         except ElementLookupError:
233             return self.directive_func(directive_name, language_module, document)
234 
235     def lookup_role(self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter) -> Tuple[RoleFunction, List[system_message]]:  # NOQA
236         try:
237             return self.lookup_domain_element('role', role_name)
238         except ElementLookupError:
239             return self.role_func(role_name, language_module, lineno, reporter)
240 
241 
242 class WarningStream:
243     def write(self, text: str) -> None:
244         matched = report_re.search(text)
245         if not matched:
246             logger.warning(text.rstrip("\r\n"))
247         else:
248             location, type, level = matched.groups()
249             message = report_re.sub('', text).rstrip()
250             logger.log(type, message, location=location)
251 
252 
253 class LoggingReporter(Reporter):
254     @classmethod
255     def from_reporter(cls, reporter: Reporter) -> "LoggingReporter":
256         """Create an instance of LoggingReporter from other reporter object."""
257         return cls(reporter.source, reporter.report_level, reporter.halt_level,
258                    reporter.debug_flag, reporter.error_handler)
259 
260     def __init__(self, source: str, report_level: int = Reporter.WARNING_LEVEL,
261                  halt_level: int = Reporter.SEVERE_LEVEL, debug: bool = False,
262                  error_handler: str = 'backslashreplace') -> None:
263         stream = cast(IO, WarningStream())
264         super().__init__(source, report_level, halt_level,
265                          stream, debug, error_handler=error_handler)
266 
267 
268 class NullReporter(Reporter):
269     """A dummy reporter; write nothing."""
270 
271     def __init__(self) -> None:
272         super().__init__('', 999, 4)
273 
274 
275 def is_html5_writer_available() -> bool:
276     return __version_info__ > (0, 13, 0)
277 
278 
279 @contextmanager
280 def switch_source_input(state: State, content: StringList) -> Generator[None, None, None]:
281     """Switch current source input of state temporarily."""
282     try:
283         # remember the original ``get_source_and_line()`` method
284         get_source_and_line = state.memo.reporter.get_source_and_line  # type: ignore
285 
286         # replace it by new one
287         state_machine = StateMachine([], None)
288         state_machine.input_lines = content
289         state.memo.reporter.get_source_and_line = state_machine.get_source_and_line  # type: ignore  # NOQA
290 
291         yield
292     finally:
293         # restore the method
294         state.memo.reporter.get_source_and_line = get_source_and_line  # type: ignore
295 
296 
297 class SphinxFileOutput(FileOutput):
298     """Better FileOutput class for Sphinx."""
299 
300     def __init__(self, **kwargs: Any) -> None:
301         self.overwrite_if_changed = kwargs.pop('overwrite_if_changed', False)
302         super().__init__(**kwargs)
303 
304     def write(self, data: str) -> str:
305         if (self.destination_path and self.autoclose and 'b' not in self.mode and
306                 self.overwrite_if_changed and os.path.exists(self.destination_path)):
307             with open(self.destination_path, encoding=self.encoding) as f:
308                 # skip writing: content not changed
309                 if f.read() == data:
310                     return data
311 
312         return super().write(data)
313 
314 
315 class SphinxDirective(Directive):
316     """A base class for Sphinx directives.
317 
318     This class provides helper methods for Sphinx directives.
319 
320     .. note:: The subclasses of this class might not work with docutils.
321               This class is strongly coupled with Sphinx.
322     """
323 
324     @property
325     def env(self) -> "BuildEnvironment":
326         """Reference to the :class:`.BuildEnvironment` object."""
327         return self.state.document.settings.env
328 
329     @property
330     def config(self) -> "Config":
331         """Reference to the :class:`.Config` object."""
332         return self.env.config
333 
334     def get_source_info(self) -> Tuple[str, int]:
335         """Get source and line number."""
336         return self.state_machine.get_source_and_line(self.lineno)
337 
338     def set_source_info(self, node: Node) -> None:
339         """Set source and line number to the node."""
340         node.source, node.line = self.get_source_info()
341 
342 
343 class SphinxRole:
344     """A base class for Sphinx roles.
345 
346     This class provides helper methods for Sphinx roles.
347 
348     .. note:: The subclasses of this class might not work with docutils.
349               This class is strongly coupled with Sphinx.
350     """
351     name: str           #: The role name actually used in the document.
352     rawtext: str        #: A string containing the entire interpreted text input.
353     text: str           #: The interpreted text content.
354     lineno: int         #: The line number where the interpreted text begins.
355     inliner: Inliner    #: The ``docutils.parsers.rst.states.Inliner`` object.
356     options: Dict       #: A dictionary of directive options for customization
357                         #: (from the "role" directive).
358     content: List[str]  #: A list of strings, the directive content for customization
359                         #: (from the "role" directive).
360 
361     def __call__(self, name: str, rawtext: str, text: str, lineno: int,
362                  inliner: Inliner, options: Dict = {}, content: List[str] = []
363                  ) -> Tuple[List[Node], List[system_message]]:
364         self.rawtext = rawtext
365         self.text = unescape(text)
366         self.lineno = lineno
367         self.inliner = inliner
368         self.options = options
369         self.content = content
370 
371         # guess role type
372         if name:
373             self.name = name.lower()
374         else:
375             self.name = self.env.temp_data.get('default_role')
376             if not self.name:
377                 self.name = self.env.config.default_role
378             if not self.name:
379                 raise SphinxError('cannot determine default role!')
380 
381         return self.run()
382 
383     def run(self) -> Tuple[List[Node], List[system_message]]:
384         raise NotImplementedError
385 
386     @property
387     def env(self) -> "BuildEnvironment":
388         """Reference to the :class:`.BuildEnvironment` object."""
389         return self.inliner.document.settings.env
390 
391     @property
392     def config(self) -> "Config":
393         """Reference to the :class:`.Config` object."""
394         return self.env.config
395 
396     def get_source_info(self, lineno: int = None) -> Tuple[str, int]:
397         if lineno is None:
398             lineno = self.lineno
399         return self.inliner.reporter.get_source_and_line(lineno)  # type: ignore
400 
401     def set_source_info(self, node: Node, lineno: int = None) -> None:
402         node.source, node.line = self.get_source_info(lineno)
403 
404 
405 class ReferenceRole(SphinxRole):
406     """A base class for reference roles.
407 
408     The reference roles can accpet ``link title <target>`` style as a text for
409     the role.  The parsed result; link title and target will be stored to
410     ``self.title`` and ``self.target``.
411     """
412     has_explicit_title: bool    #: A boolean indicates the role has explicit title or not.
413     disabled: bool              #: A boolean indicates the reference is disabled.
414     title: str                  #: The link title for the interpreted text.
415     target: str                 #: The link target for the interpreted text.
416 
417     # \x00 means the "<" was backslash-escaped
418     explicit_title_re = re.compile(r'^(.+?)\s*(?<!\x00)<(.*?)>$', re.DOTALL)
419 
420     def __call__(self, name: str, rawtext: str, text: str, lineno: int,
421                  inliner: Inliner, options: Dict = {}, content: List[str] = []
422                  ) -> Tuple[List[Node], List[system_message]]:
423         # if the first character is a bang, don't cross-reference at all
424         self.disabled = text.startswith('!')
425 
426         matched = self.explicit_title_re.match(text)
427         if matched:
428             self.has_explicit_title = True
429             self.title = unescape(matched.group(1))
430             self.target = unescape(matched.group(2))
431         else:
432             self.has_explicit_title = False
433             self.title = unescape(text)
434             self.target = unescape(text)
435 
436         return super().__call__(name, rawtext, text, lineno, inliner, options, content)
437 
438 
439 class SphinxTranslator(nodes.NodeVisitor):
440     """A base class for Sphinx translators.
441 
442     This class adds a support for visitor/departure method for super node class
443     if visitor/departure method for node class is not found.
444 
445     It also provides helper methods for Sphinx translators.
446 
447     .. note:: The subclasses of this class might not work with docutils.
448               This class is strongly coupled with Sphinx.
449     """
450 
451     def __init__(self, document: nodes.document, builder: "Builder") -> None:
452         super().__init__(document)
453         self.builder = builder
454         self.config = builder.config
455         self.settings = document.settings
456 
457     def dispatch_visit(self, node: Node) -> None:
458         """
459         Dispatch node to appropriate visitor method.
460         The priority of visitor method is:
461 
462         1. ``self.visit_{node_class}()``
463         2. ``self.visit_{super_node_class}()``
464         3. ``self.unknown_visit()``
465         """
466         for node_class in node.__class__.__mro__:
467             method = getattr(self, 'visit_%s' % (node_class.__name__), None)
468             if method:
469                 method(node)
470                 break
471         else:
472             super().dispatch_visit(node)
473 
474     def dispatch_departure(self, node: Node) -> None:
475         """
476         Dispatch node to appropriate departure method.
477         The priority of departure method is:
478 
479         1. ``self.depart_{node_class}()``
480         2. ``self.depart_{super_node_class}()``
481         3. ``self.unknown_departure()``
482         """
483         for node_class in node.__class__.__mro__:
484             method = getattr(self, 'depart_%s' % (node_class.__name__), None)
485             if method:
486                 method(node)
487                 break
488         else:
489             super().dispatch_departure(node)
490 
491 
492 # cache a vanilla instance of nodes.document
493 # Used in new_document() function
494 __document_cache__: nodes.document = None
495 
496 
497 def new_document(source_path: str, settings: Any = None) -> nodes.document:
498     """Return a new empty document object.  This is an alternative of docutils'.
499 
500     This is a simple wrapper for ``docutils.utils.new_document()``.  It
501     caches the result of docutils' and use it on second call for instantiation.
502     This makes an instantiation of document nodes much faster.
503     """
504     global __document_cache__
505     if __document_cache__ is None:
506         __document_cache__ = docutils.utils.new_document(source_path)
507 
508     if settings is None:
509         # Make a copy of ``settings`` from cache to accelerate instansiation
510         settings = copy(__document_cache__.settings)
511 
512     # Create a new instance of nodes.document using cached reporter
513     from sphinx import addnodes
514     document = addnodes.document(settings, __document_cache__.reporter, source=source_path)
515     document.note_source(source_path, -1)
516     return document

</code><intended_behavior>Update or adapt utility functions to work seamlessly with `docutils-0.17b1`, leveraging new features or changes without breaking existing integrations.</intended_behavior>, <file>sphinx/transforms/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.transforms
3     ~~~~~~~~~~~~~~~~~
4 
5     Docutils transforms used by Sphinx when reading documents.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import TYPE_CHECKING, Any, Dict, Generator, List, Tuple
14 
15 from docutils import nodes
16 from docutils.nodes import Element, Node, Text
17 from docutils.transforms import Transform, Transformer
18 from docutils.transforms.parts import ContentsFilter
19 from docutils.transforms.universal import SmartQuotes
20 from docutils.utils import normalize_language_tag
21 from docutils.utils.smartquotes import smartchars
22 
23 from sphinx import addnodes
24 from sphinx.config import Config
25 from sphinx.deprecation import RemovedInSphinx60Warning
26 from sphinx.locale import _, __
27 from sphinx.util import docutils, logging
28 from sphinx.util.docutils import new_document
29 from sphinx.util.i18n import format_date
30 from sphinx.util.nodes import NodeMatcher, apply_source_workaround, is_smartquotable
31 
32 if TYPE_CHECKING:
33     from sphinx.application import Sphinx
34     from sphinx.domain.std import StandardDomain
35     from sphinx.environment import BuildEnvironment
36 
37 
38 logger = logging.getLogger(__name__)
39 
40 default_substitutions = {
41     'version',
42     'release',
43     'today',
44 }
45 
46 
47 class SphinxTransform(Transform):
48     """A base class of Transforms.
49 
50     Compared with ``docutils.transforms.Transform``, this class improves accessibility to
51     Sphinx APIs.
52     """
53 
54     @property
55     def app(self) -> "Sphinx":
56         """Reference to the :class:`.Sphinx` object."""
57         return self.env.app
58 
59     @property
60     def env(self) -> "BuildEnvironment":
61         """Reference to the :class:`.BuildEnvironment` object."""
62         return self.document.settings.env
63 
64     @property
65     def config(self) -> Config:
66         """Reference to the :class:`.Config` object."""
67         return self.env.config
68 
69 
70 class SphinxTransformer(Transformer):
71     """
72     A transformer for Sphinx.
73     """
74 
75     document: nodes.document = None
76     env: "BuildEnvironment" = None
77 
78     def set_environment(self, env: "BuildEnvironment") -> None:
79         self.env = env
80 
81     def apply_transforms(self) -> None:
82         if isinstance(self.document, nodes.document):
83             if not hasattr(self.document.settings, 'env') and self.env:
84                 self.document.settings.env = self.env
85 
86             super().apply_transforms()
87         else:
88             # wrap the target node by document node during transforming
89             try:
90                 document = new_document('')
91                 if self.env:
92                     document.settings.env = self.env
93                 document += self.document
94                 self.document = document
95                 super().apply_transforms()
96             finally:
97                 self.document = self.document[0]
98 
99 
100 class DefaultSubstitutions(SphinxTransform):
101     """
102     Replace some substitutions if they aren't defined in the document.
103     """
104     # run before the default Substitutions
105     default_priority = 210
106 
107     def apply(self, **kwargs: Any) -> None:
108         # only handle those not otherwise defined in the document
109         to_handle = default_substitutions - set(self.document.substitution_defs)
110         for ref in self.document.traverse(nodes.substitution_reference):
111             refname = ref['refname']
112             if refname in to_handle:
113                 text = self.config[refname]
114                 if refname == 'today' and not text:
115                     # special handling: can also specify a strftime format
116                     text = format_date(self.config.today_fmt or _('%b %d, %Y'),
117                                        language=self.config.language)
118                 ref.replace_self(nodes.Text(text, text))
119 
120 
121 class MoveModuleTargets(SphinxTransform):
122     """
123     Move module targets that are the first thing in a section to the section
124     title.
125 
126     XXX Python specific
127     """
128     default_priority = 210
129 
130     def apply(self, **kwargs: Any) -> None:
131         for node in self.document.traverse(nodes.target):
132             if not node['ids']:
133                 continue
134             if ('ismod' in node and
135                     node.parent.__class__ is nodes.section and
136                     # index 0 is the section title node
137                     node.parent.index(node) == 1):
138                 node.parent['ids'][0:0] = node['ids']
139                 node.parent.remove(node)
140 
141 
142 class HandleCodeBlocks(SphinxTransform):
143     """
144     Several code block related transformations.
145     """
146     default_priority = 210
147 
148     def apply(self, **kwargs: Any) -> None:
149         # move doctest blocks out of blockquotes
150         for node in self.document.traverse(nodes.block_quote):
151             if all(isinstance(child, nodes.doctest_block) for child
152                    in node.children):
153                 node.replace_self(node.children)
154         # combine successive doctest blocks
155         # for node in self.document.traverse(nodes.doctest_block):
156         #    if node not in node.parent.children:
157         #        continue
158         #    parindex = node.parent.index(node)
159         #    while len(node.parent) > parindex+1 and \
160         #            isinstance(node.parent[parindex+1], nodes.doctest_block):
161         #        node[0] = nodes.Text(node[0] + '\n\n' +
162         #                             node.parent[parindex+1][0])
163         #        del node.parent[parindex+1]
164 
165 
166 class AutoNumbering(SphinxTransform):
167     """
168     Register IDs of tables, figures and literal_blocks to assign numbers.
169     """
170     default_priority = 210
171 
172     def apply(self, **kwargs: Any) -> None:
173         domain: StandardDomain = self.env.get_domain('std')
174 
175         for node in self.document.traverse(nodes.Element):
176             if (domain.is_enumerable_node(node) and
177                     domain.get_numfig_title(node) is not None and
178                     node['ids'] == []):
179                 self.document.note_implicit_target(node)
180 
181 
182 class SortIds(SphinxTransform):
183     """
184     Sort secion IDs so that the "id[0-9]+" one comes last.
185     """
186     default_priority = 261
187 
188     def apply(self, **kwargs: Any) -> None:
189         for node in self.document.traverse(nodes.section):
190             if len(node['ids']) > 1 and node['ids'][0].startswith('id'):
191                 node['ids'] = node['ids'][1:] + [node['ids'][0]]
192 
193 
194 TRANSLATABLE_NODES = {
195     'literal-block': nodes.literal_block,
196     'doctest-block': nodes.doctest_block,
197     'raw': nodes.raw,
198     'index': addnodes.index,
199     'image': nodes.image,
200 }
201 
202 
203 class ApplySourceWorkaround(SphinxTransform):
204     """
205     update source and rawsource attributes
206     """
207     default_priority = 10
208 
209     def apply(self, **kwargs: Any) -> None:
210         for node in self.document.traverse():  # type: Node
211             if isinstance(node, (nodes.TextElement, nodes.image)):
212                 apply_source_workaround(node)
213 
214 
215 class AutoIndexUpgrader(SphinxTransform):
216     """
217     Detect old style; 4 column based indices and automatically upgrade to new style.
218     """
219     default_priority = 210
220 
221     def apply(self, **kwargs: Any) -> None:
222         for node in self.document.traverse(addnodes.index):
223             if 'entries' in node and any(len(entry) == 4 for entry in node['entries']):
224                 msg = __('4 column based index found. '
225                          'It might be a bug of extensions you use: %r') % node['entries']
226                 logger.warning(msg, location=node)
227                 for i, entry in enumerate(node['entries']):
228                     if len(entry) == 4:
229                         node['entries'][i] = entry + (None,)
230 
231 
232 class ExtraTranslatableNodes(SphinxTransform):
233     """
234     make nodes translatable
235     """
236     default_priority = 10
237 
238     def apply(self, **kwargs: Any) -> None:
239         targets = self.config.gettext_additional_targets
240         target_nodes = [v for k, v in TRANSLATABLE_NODES.items() if k in targets]
241         if not target_nodes:
242             return
243 
244         def is_translatable_node(node: Node) -> bool:
245             return isinstance(node, tuple(target_nodes))
246 
247         for node in self.document.traverse(is_translatable_node):  # type: Element
248             node['translatable'] = True
249 
250 
251 class UnreferencedFootnotesDetector(SphinxTransform):
252     """
253     detect unreferenced footnotes and emit warnings
254     """
255     default_priority = 200
256 
257     def apply(self, **kwargs: Any) -> None:
258         for node in self.document.footnotes:
259             if node['names'] == []:
260                 # footnote having duplicated number.  It is already warned at parser.
261                 pass
262             elif node['names'][0] not in self.document.footnote_refs:
263                 logger.warning(__('Footnote [%s] is not referenced.'), node['names'][0],
264                                type='ref', subtype='footnote',
265                                location=node)
266 
267         for node in self.document.autofootnotes:
268             if not any(ref['auto'] == node['auto'] for ref in self.document.autofootnote_refs):
269                 logger.warning(__('Footnote [#] is not referenced.'),
270                                type='ref', subtype='footnote',
271                                location=node)
272 
273 
274 class DoctestTransform(SphinxTransform):
275     """Set "doctest" style to each doctest_block node"""
276     default_priority = 500
277 
278     def apply(self, **kwargs: Any) -> None:
279         for node in self.document.traverse(nodes.doctest_block):
280             node['classes'].append('doctest')
281 
282 
283 class FigureAligner(SphinxTransform):
284     """
285     Align figures to center by default.
286     """
287     default_priority = 700
288 
289     def __init__(self, *args: Any, **kwargs: Any) -> None:
290         warnings.warn('FigureAilgner is deprecated.',
291                       RemovedInSphinx60Warning)
292         super().__init__(*args, **kwargs)
293 
294     def apply(self, **kwargs: Any) -> None:
295         matcher = NodeMatcher(nodes.table, nodes.figure)
296         for node in self.document.traverse(matcher):  # type: Element
297             node.setdefault('align', 'default')
298 
299 
300 class FilterSystemMessages(SphinxTransform):
301     """Filter system messages from a doctree."""
302     default_priority = 999
303 
304     def apply(self, **kwargs: Any) -> None:
305         filterlevel = 2 if self.config.keep_warnings else 5
306         for node in self.document.traverse(nodes.system_message):
307             if node['level'] < filterlevel:
308                 logger.debug('%s [filtered system message]', node.astext())
309                 node.parent.remove(node)
310 
311 
312 class SphinxContentsFilter(ContentsFilter):
313     """
314     Used with BuildEnvironment.add_toc_from() to discard cross-file links
315     within table-of-contents link nodes.
316     """
317     visit_pending_xref = ContentsFilter.ignore_node_but_process_children
318 
319     def visit_image(self, node: nodes.image) -> None:
320         raise nodes.SkipNode
321 
322 
323 class SphinxSmartQuotes(SmartQuotes, SphinxTransform):
324     """
325     Customized SmartQuotes to avoid transform for some extra node types.
326 
327     refs: sphinx.parsers.RSTParser
328     """
329     default_priority = 750
330 
331     def apply(self, **kwargs: Any) -> None:
332         if not self.is_available():
333             return
334 
335         # override default settings with :confval:`smartquotes_action`
336         self.smartquotes_action = self.config.smartquotes_action
337 
338         super().apply()
339 
340     def is_available(self) -> bool:
341         builders = self.config.smartquotes_excludes.get('builders', [])
342         languages = self.config.smartquotes_excludes.get('languages', [])
343 
344         if self.document.settings.smart_quotes is False:
345             # disabled by 3rd party extension (workaround)
346             return False
347         elif self.config.smartquotes is False:
348             # disabled by confval smartquotes
349             return False
350         elif self.app.builder.name in builders:
351             # disabled by confval smartquotes_excludes['builders']
352             return False
353         elif self.config.language in languages:
354             # disabled by confval smartquotes_excludes['languages']
355             return False
356 
357         # confirm selected language supports smart_quotes or not
358         language = self.env.settings['language_code']
359         for tag in normalize_language_tag(language):
360             if tag in smartchars.quotes:
361                 return True
362         else:
363             return False
364 
365     def get_tokens(self, txtnodes: List[Text]) -> Generator[Tuple[str, str], None, None]:
366         # A generator that yields ``(texttype, nodetext)`` tuples for a list
367         # of "Text" nodes (interface to ``smartquotes.educate_tokens()``).
368         for txtnode in txtnodes:
369             if is_smartquotable(txtnode):
370                 if docutils.__version_info__ >= (0, 16):
371                     # SmartQuotes uses backslash escapes instead of null-escapes
372                     text = re.sub(r'(?<=\x00)([-\\\'".`])', r'\\\1', str(txtnode))
373                 else:
374                     text = txtnode.astext()
375 
376                 yield ('plain', text)
377             else:
378                 # skip smart quotes
379                 yield ('literal', txtnode.astext())
380 
381 
382 class DoctreeReadEvent(SphinxTransform):
383     """Emit :event:`doctree-read` event."""
384     default_priority = 880
385 
386     def apply(self, **kwargs: Any) -> None:
387         self.app.emit('doctree-read', self.document)
388 
389 
390 class ManpageLink(SphinxTransform):
391     """Find manpage section numbers and names"""
392     default_priority = 999
393 
394     def apply(self, **kwargs: Any) -> None:
395         for node in self.document.traverse(addnodes.manpage):
396             manpage = ' '.join([str(x) for x in node.children
397                                 if isinstance(x, nodes.Text)])
398             pattern = r'^(?P<path>(?P<page>.+)[\(\.](?P<section>[1-9]\w*)?\)?)$'  # noqa
399             info = {'path': manpage,
400                     'page': manpage,
401                     'section': ''}
402             r = re.match(pattern, manpage)
403             if r:
404                 info = r.groupdict()
405             node.attributes.update(info)
406 
407 
408 def setup(app: "Sphinx") -> Dict[str, Any]:
409     app.add_transform(ApplySourceWorkaround)
410     app.add_transform(ExtraTranslatableNodes)
411     app.add_transform(DefaultSubstitutions)
412     app.add_transform(MoveModuleTargets)
413     app.add_transform(HandleCodeBlocks)
414     app.add_transform(SortIds)
415     app.add_transform(DoctestTransform)
416     app.add_transform(AutoNumbering)
417     app.add_transform(AutoIndexUpgrader)
418     app.add_transform(FilterSystemMessages)
419     app.add_transform(UnreferencedFootnotesDetector)
420     app.add_transform(SphinxSmartQuotes)
421     app.add_transform(DoctreeReadEvent)
422     app.add_transform(ManpageLink)
423 
424     return {
425         'version': 'builtin',
426         'parallel_read_safe': True,
427         'parallel_write_safe': True,
428     }

</code><intended_behavior>Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API.</intended_behavior>, <file>sphinx/transforms/post_transforms/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.transforms.post_transforms
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Docutils transforms used by Sphinx.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Dict, List, Optional, Tuple, Type, cast
12 
13 from docutils import nodes
14 from docutils.nodes import Element
15 
16 from sphinx import addnodes
17 from sphinx.addnodes import pending_xref
18 from sphinx.application import Sphinx
19 from sphinx.domains import Domain
20 from sphinx.errors import NoUri
21 from sphinx.locale import __
22 from sphinx.transforms import SphinxTransform
23 from sphinx.util import logging
24 from sphinx.util.docutils import SphinxTranslator
25 from sphinx.util.nodes import find_pending_xref_condition, process_only_nodes
26 
27 logger = logging.getLogger(__name__)
28 
29 if False:
30     # For type annotation
31     from docutils.nodes import Node
32 
33 
34 class SphinxPostTransform(SphinxTransform):
35     """A base class of post-transforms.
36 
37     Post transforms are invoked to modify the document to restructure it for outputting.
38     They do resolving references, convert images, special transformation for each output
39     formats and so on.  This class helps to implement these post transforms.
40     """
41     builders: Tuple[str, ...] = ()
42     formats: Tuple[str, ...] = ()
43 
44     def apply(self, **kwargs: Any) -> None:
45         if self.is_supported():
46             self.run(**kwargs)
47 
48     def is_supported(self) -> bool:
49         """Check this transform working for current builder."""
50         if self.builders and self.app.builder.name not in self.builders:
51             return False
52         if self.formats and self.app.builder.format not in self.formats:
53             return False
54 
55         return True
56 
57     def run(self, **kwargs: Any) -> None:
58         """main method of post transforms.
59 
60         Subclasses should override this method instead of ``apply()``.
61         """
62         raise NotImplementedError
63 
64 
65 class ReferencesResolver(SphinxPostTransform):
66     """
67     Resolves cross-references on doctrees.
68     """
69 
70     default_priority = 10
71 
72     def run(self, **kwargs: Any) -> None:
73         for node in self.document.traverse(addnodes.pending_xref):
74             contnode = cast(nodes.TextElement, node[0].deepcopy())
75             newnode = None
76 
77             typ = node['reftype']
78             target = node['reftarget']
79             refdoc = node.get('refdoc', self.env.docname)
80             domain = None
81 
82             try:
83                 if 'refdomain' in node and node['refdomain']:
84                     # let the domain try to resolve the reference
85                     try:
86                         domain = self.env.domains[node['refdomain']]
87                     except KeyError as exc:
88                         raise NoUri(target, typ) from exc
89                     newnode = domain.resolve_xref(self.env, refdoc, self.app.builder,
90                                                   typ, target, node, contnode)
91                 # really hardwired reference types
92                 elif typ == 'any':
93                     newnode = self.resolve_anyref(refdoc, node, contnode)
94                 # no new node found? try the missing-reference event
95                 if newnode is None:
96                     newnode = self.app.emit_firstresult('missing-reference', self.env,
97                                                         node, contnode,
98                                                         allowed_exceptions=(NoUri,))
99                     # still not found? warn if node wishes to be warned about or
100                     # we are in nit-picky mode
101                     if newnode is None:
102                         self.warn_missing_reference(refdoc, typ, target, node, domain)
103             except NoUri:
104                 newnode = None
105 
106             if newnode:
107                 newnodes: List[Node] = [newnode]
108             else:
109                 newnodes = [contnode]
110                 if newnode is None and isinstance(node[0], addnodes.pending_xref_condition):
111                     matched = find_pending_xref_condition(node, "*")
112                     if matched:
113                         newnodes = matched.children
114                     else:
115                         logger.warning(__('Could not determine the fallback text for the '
116                                           'cross-reference. Might be a bug.'), location=node)
117 
118             node.replace_self(newnodes)
119 
120     def resolve_anyref(self, refdoc: str, node: pending_xref, contnode: Element) -> Element:
121         """Resolve reference generated by the "any" role."""
122         stddomain = self.env.get_domain('std')
123         target = node['reftarget']
124         results: List[Tuple[str, Element]] = []
125         # first, try resolving as :doc:
126         doc_ref = stddomain.resolve_xref(self.env, refdoc, self.app.builder,
127                                          'doc', target, node, contnode)
128         if doc_ref:
129             results.append(('doc', doc_ref))
130         # next, do the standard domain (makes this a priority)
131         results.extend(stddomain.resolve_any_xref(self.env, refdoc, self.app.builder,
132                                                   target, node, contnode))
133         for domain in self.env.domains.values():
134             if domain.name == 'std':
135                 continue  # we did this one already
136             try:
137                 results.extend(domain.resolve_any_xref(self.env, refdoc, self.app.builder,
138                                                        target, node, contnode))
139             except NotImplementedError:
140                 # the domain doesn't yet support the new interface
141                 # we have to manually collect possible references (SLOW)
142                 for role in domain.roles:
143                     res = domain.resolve_xref(self.env, refdoc, self.app.builder,
144                                               role, target, node, contnode)
145                     if res and len(res) > 0 and isinstance(res[0], nodes.Element):
146                         results.append(('%s:%s' % (domain.name, role), res))
147         # now, see how many matches we got...
148         if not results:
149             return None
150         if len(results) > 1:
151             def stringify(name: str, node: Element) -> str:
152                 reftitle = node.get('reftitle', node.astext())
153                 return ':%s:`%s`' % (name, reftitle)
154             candidates = ' or '.join(stringify(name, role) for name, role in results)
155             logger.warning(__('more than one target found for \'any\' cross-'
156                               'reference %r: could be %s'), target, candidates,
157                            location=node)
158         res_role, newnode = results[0]
159         # Override "any" class with the actual role type to get the styling
160         # approximately correct.
161         res_domain = res_role.split(':')[0]
162         if (len(newnode) > 0 and
163                 isinstance(newnode[0], nodes.Element) and
164                 newnode[0].get('classes')):
165             newnode[0]['classes'].append(res_domain)
166             newnode[0]['classes'].append(res_role.replace(':', '-'))
167         return newnode
168 
169     def warn_missing_reference(self, refdoc: str, typ: str, target: str,
170                                node: pending_xref, domain: Optional[Domain]) -> None:
171         warn = node.get('refwarn')
172         if self.config.nitpicky:
173             warn = True
174             if self.config.nitpick_ignore:
175                 dtype = '%s:%s' % (domain.name, typ) if domain else typ
176                 if (dtype, target) in self.config.nitpick_ignore:
177                     warn = False
178                 # for "std" types also try without domain name
179                 if (not domain or domain.name == 'std') and \
180                    (typ, target) in self.config.nitpick_ignore:
181                     warn = False
182         if not warn:
183             return
184 
185         if self.app.emit_firstresult('warn-missing-reference', domain, node):
186             return
187         elif domain and typ in domain.dangling_warnings:
188             msg = domain.dangling_warnings[typ] % {'target': target}
189         elif node.get('refdomain', 'std') not in ('', 'std'):
190             msg = (__('%s:%s reference target not found: %s') %
191                    (node['refdomain'], typ, target))
192         else:
193             msg = __('%r reference target not found: %s') % (typ, target)
194         logger.warning(msg, location=node, type='ref', subtype=typ)
195 
196 
197 class OnlyNodeTransform(SphinxPostTransform):
198     default_priority = 50
199 
200     def run(self, **kwargs: Any) -> None:
201         # A comment on the comment() nodes being inserted: replacing by [] would
202         # result in a "Losing ids" exception if there is a target node before
203         # the only node, so we make sure docutils can transfer the id to
204         # something, even if it's just a comment and will lose the id anyway...
205         process_only_nodes(self.document, self.app.builder.tags)
206 
207 
208 class SigElementFallbackTransform(SphinxPostTransform):
209     """Fallback desc_sig_element nodes to inline if translator does not supported them."""
210     default_priority = 200
211 
212     SIG_ELEMENTS = [addnodes.desc_sig_name,
213                     addnodes.desc_sig_operator,
214                     addnodes.desc_sig_punctuation]
215 
216     def run(self, **kwargs: Any) -> None:
217         def has_visitor(translator: Type[nodes.NodeVisitor], node: Type[Element]) -> bool:
218             return hasattr(translator, "visit_%s" % node.__name__)
219 
220         translator = self.app.builder.get_translator_class()
221         if isinstance(translator, SphinxTranslator):
222             # subclass of SphinxTranslator supports desc_sig_element nodes automatically.
223             return
224 
225         if all(has_visitor(translator, node) for node in self.SIG_ELEMENTS):
226             # the translator supports all desc_sig_element nodes
227             return
228         else:
229             self.fallback()
230 
231     def fallback(self) -> None:
232         for node in self.document.traverse(addnodes.desc_sig_element):
233             newnode = nodes.inline()
234             newnode.update_all_atts(node)
235             newnode.extend(node)
236             node.replace_self(newnode)
237 
238 
239 def setup(app: Sphinx) -> Dict[str, Any]:
240     app.add_post_transform(ReferencesResolver)
241     app.add_post_transform(OnlyNodeTransform)
242     app.add_post_transform(SigElementFallbackTransform)
243 
244     return {
245         'version': 'builtin',
246         'parallel_read_safe': True,
247         'parallel_write_safe': True,
248     }

</code><intended_behavior>Confirm or refresh transformation logic to ensure they correctly process documents with the `docutils-0.17b1` structure and API.</intended_behavior>]
2025-10-18 18:25:07.031 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 18:25:07.031 | INFO     | Search-only: skipping patch selection
2025-10-18 18:25:07.101 | INFO     | Task sphinx-doc__sphinx-9053 completed successfully.
2025-10-18 18:25:07.101 | INFO     | No patch generated. You can try running ACR again.
