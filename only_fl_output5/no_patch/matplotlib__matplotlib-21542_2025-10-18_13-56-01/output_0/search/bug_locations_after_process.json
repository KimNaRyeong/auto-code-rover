[
    {
        "rel_file_path": "lib/matplotlib/colorbar.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.4/lib/matplotlib/colorbar.py",
        "start": 369,
        "end": 511,
        "class_name": "Colorbar",
        "method_name": "__init__",
        "code": "369     def __init__(self, ax, mappable=None, *, cmap=None,\n370                  norm=None,\n371                  alpha=None,\n372                  values=None,\n373                  boundaries=None,\n374                  orientation='vertical',\n375                  ticklocation='auto',\n376                  extend=None,\n377                  spacing='uniform',  # uniform or proportional\n378                  ticks=None,\n379                  format=None,\n380                  drawedges=False,\n381                  filled=True,\n382                  extendfrac=None,\n383                  extendrect=False,\n384                  label='',\n385                  ):\n386 \n387         if mappable is None:\n388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n389 \n390         # Ensure the given mappable's norm has appropriate vmin and vmax\n391         # set even if mappable.draw has not yet been called.\n392         if mappable.get_array() is not None:\n393             mappable.autoscale_None()\n394 \n395         self.mappable = mappable\n396         cmap = mappable.cmap\n397         norm = mappable.norm\n398 \n399         if isinstance(mappable, contour.ContourSet):\n400             cs = mappable\n401             alpha = cs.get_alpha()\n402             boundaries = cs._levels\n403             values = cs.cvalues\n404             extend = cs.extend\n405             filled = cs.filled\n406             if ticks is None:\n407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)\n408         elif isinstance(mappable, martist.Artist):\n409             alpha = mappable.get_alpha()\n410 \n411         mappable.colorbar = self\n412         mappable.colorbar_cid = mappable.callbacks.connect(\n413             'changed', self.update_normal)\n414 \n415         _api.check_in_list(\n416             ['vertical', 'horizontal'], orientation=orientation)\n417         _api.check_in_list(\n418             ['auto', 'left', 'right', 'top', 'bottom'],\n419             ticklocation=ticklocation)\n420         _api.check_in_list(\n421             ['uniform', 'proportional'], spacing=spacing)\n422 \n423         self.ax = ax\n424         self.ax._axes_locator = _ColorbarAxesLocator(self)\n425 \n426         if extend is None:\n427             if (not isinstance(mappable, contour.ContourSet)\n428                     and getattr(cmap, 'colorbar_extend', False) is not False):\n429                 extend = cmap.colorbar_extend\n430             elif hasattr(norm, 'extend'):\n431                 extend = norm.extend\n432             else:\n433                 extend = 'neither'\n434         self.alpha = None\n435         # Call set_alpha to handle array-like alphas properly\n436         self.set_alpha(alpha)\n437         self.cmap = cmap\n438         self.norm = norm\n439         self.values = values\n440         self.boundaries = boundaries\n441         self.extend = extend\n442         self._inside = _api.check_getitem(\n443             {'neither': slice(0, None), 'both': slice(1, -1),\n444              'min': slice(1, None), 'max': slice(0, -1)},\n445             extend=extend)\n446         self.spacing = spacing\n447         self.orientation = orientation\n448         self.drawedges = drawedges\n449         self.filled = filled\n450         self.extendfrac = extendfrac\n451         self.extendrect = extendrect\n452         self.solids = None\n453         self.solids_patches = []\n454         self.lines = []\n455 \n456         for spine in self.ax.spines.values():\n457             spine.set_visible(False)\n458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)\n459         self._short_axis().set_visible(False)\n460         # Only kept for backcompat; remove after deprecation of .patch elapses.\n461         self._patch = mpatches.Polygon(\n462             np.empty((0, 2)),\n463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)\n464         ax.add_artist(self._patch)\n465 \n466         self.dividers = collections.LineCollection(\n467             [],\n468             colors=[mpl.rcParams['axes.edgecolor']],\n469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])\n470         self.ax.add_collection(self.dividers)\n471 \n472         self.locator = None\n473         self.minorlocator = None\n474         self.formatter = None\n475         self.__scale = None  # linear, log10 for now.  Hopefully more?\n476 \n477         if ticklocation == 'auto':\n478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'\n479         self.ticklocation = ticklocation\n480 \n481         self.set_label(label)\n482         self._reset_locator_formatter_scale()\n483 \n484         if np.iterable(ticks):\n485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n486         else:\n487             self.locator = ticks    # Handle default in _ticker()\n488 \n489         if isinstance(format, str):\n490             self.formatter = ticker.FormatStrFormatter(format)\n491         else:\n492             self.formatter = format  # Assume it is a Formatter or None\n493         self.draw_all()\n494 \n495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:\n496             self.add_lines(mappable)\n497 \n498         # Link the Axes and Colorbar for interactive use\n499         self.ax._colorbar = self\n500         # Don't navigate on any of these types of mappables\n501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or\n502                 isinstance(self.mappable, contour.ContourSet)):\n503             self.ax.set_navigate(False)\n504 \n505         # These are the functions that set up interactivity on this colorbar\n506         self._interactive_funcs = [\"_get_view\", \"_set_view\",\n507                                    \"_set_view_from_bbox\", \"drag_pan\"]\n508         for x in self._interactive_funcs:\n509             setattr(self.ax, x, getattr(self, x))\n510         # Set the cla function to the cbar's method to override it\n511         self.ax.cla = self._cbar_cla\n",
        "intended_behavior": "Instead of directly initializing a FormatStrFormatter when format is a string, the Colorbar class should adopt a new strategy that is consistent with the handling of format strings in Axis._set_formatter. The __init__ method should either directly use or mirror the logic seen in Axis._set_formatter to support new-style format strings by default. This change ensures that format strings used in colorbars are handled in the same versatile and flexible manner as those in axes, which already support new-style format strings following enhancement #16715."
    },
    {
        "rel_file_path": "lib/matplotlib/colorbar.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.4/lib/matplotlib/colorbar.py",
        "start": 289,
        "end": 1329,
        "class_name": "Colorbar",
        "method_name": null,
        "code": "289 class Colorbar:\n290     r\"\"\"\n291     Draw a colorbar in an existing axes.\n292 \n293     Typically, colorbars are created using `.Figure.colorbar` or\n294     `.pyplot.colorbar` and associated with `.ScalarMappable`\\s (such as an\n295     `.AxesImage` generated via `~.axes.Axes.imshow`).\n296 \n297     In order to draw a colorbar not associated with other elements in the\n298     figure, e.g. when showing a colormap by itself, one can create an empty\n299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*\n300     to `Colorbar`.\n301 \n302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n303 \n304     Attributes\n305     ----------\n306     ax : `~matplotlib.axes.Axes`\n307         The `~.axes.Axes` instance in which the colorbar is drawn.\n308     lines : list\n309         A list of `.LineCollection` (empty if no lines were drawn).\n310     dividers : `.LineCollection`\n311         A LineCollection (empty if *drawedges* is ``False``).\n312 \n313     Parameters\n314     ----------\n315     ax : `~matplotlib.axes.Axes`\n316         The `~.axes.Axes` instance in which the colorbar is drawn.\n317 \n318     mappable : `.ScalarMappable`\n319         The mappable whose colormap and norm will be used.\n320 \n321         To show the under- and over- value colors, the mappable's norm should\n322         be specified as ::\n323 \n324             norm = colors.Normalize(clip=False)\n325 \n326         To show the colors versus index instead of on a 0-1 scale, use::\n327 \n328             norm=colors.NoNorm()\n329 \n330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n331         The colormap to use.  This parameter is ignored, unless *mappable* is\n332         None.\n333 \n334     norm : `~matplotlib.colors.Normalize`\n335         The normalization to use.  This parameter is ignored, unless *mappable*\n336         is None.\n337 \n338     alpha : float\n339         The colorbar transparency between 0 (transparent) and 1 (opaque).\n340 \n341     values, boundaries\n342         If unset, the colormap will be displayed on a 0-1 scale.\n343 \n344     orientation : {'vertical', 'horizontal'}\n345 \n346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}\n347 \n348     extend : {'neither', 'both', 'min', 'max'}\n349 \n350     spacing : {'uniform', 'proportional'}\n351 \n352     ticks : `~matplotlib.ticker.Locator` or array-like of float\n353 \n354     format : str or `~matplotlib.ticker.Formatter`\n355 \n356     drawedges : bool\n357 \n358     filled : bool\n359 \n360     extendfrac\n361 \n362     extendrec\n363 \n364     label : str\n365     \"\"\"\n366 \n367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n368 \n369     def __init__(self, ax, mappable=None, *, cmap=None,\n370                  norm=None,\n371                  alpha=None,\n372                  values=None,\n373                  boundaries=None,\n374                  orientation='vertical',\n375                  ticklocation='auto',\n376                  extend=None,\n377                  spacing='uniform',  # uniform or proportional\n378                  ticks=None,\n379                  format=None,\n380                  drawedges=False,\n381                  filled=True,\n382                  extendfrac=None,\n383                  extendrect=False,\n384                  label='',\n385                  ):\n386 \n387         if mappable is None:\n388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n389 \n390         # Ensure the given mappable's norm has appropriate vmin and vmax\n391         # set even if mappable.draw has not yet been called.\n392         if mappable.get_array() is not None:\n393             mappable.autoscale_None()\n394 \n395         self.mappable = mappable\n396         cmap = mappable.cmap\n397         norm = mappable.norm\n398 \n399         if isinstance(mappable, contour.ContourSet):\n400             cs = mappable\n401             alpha = cs.get_alpha()\n402             boundaries = cs._levels\n403             values = cs.cvalues\n404             extend = cs.extend\n405             filled = cs.filled\n406             if ticks is None:\n407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)\n408         elif isinstance(mappable, martist.Artist):\n409             alpha = mappable.get_alpha()\n410 \n411         mappable.colorbar = self\n412         mappable.colorbar_cid = mappable.callbacks.connect(\n413             'changed', self.update_normal)\n414 \n415         _api.check_in_list(\n416             ['vertical', 'horizontal'], orientation=orientation)\n417         _api.check_in_list(\n418             ['auto', 'left', 'right', 'top', 'bottom'],\n419             ticklocation=ticklocation)\n420         _api.check_in_list(\n421             ['uniform', 'proportional'], spacing=spacing)\n422 \n423         self.ax = ax\n424         self.ax._axes_locator = _ColorbarAxesLocator(self)\n425 \n426         if extend is None:\n427             if (not isinstance(mappable, contour.ContourSet)\n428                     and getattr(cmap, 'colorbar_extend', False) is not False):\n429                 extend = cmap.colorbar_extend\n430             elif hasattr(norm, 'extend'):\n431                 extend = norm.extend\n432             else:\n433                 extend = 'neither'\n434         self.alpha = None\n435         # Call set_alpha to handle array-like alphas properly\n436         self.set_alpha(alpha)\n437         self.cmap = cmap\n438         self.norm = norm\n439         self.values = values\n440         self.boundaries = boundaries\n441         self.extend = extend\n442         self._inside = _api.check_getitem(\n443             {'neither': slice(0, None), 'both': slice(1, -1),\n444              'min': slice(1, None), 'max': slice(0, -1)},\n445             extend=extend)\n446         self.spacing = spacing\n447         self.orientation = orientation\n448         self.drawedges = drawedges\n449         self.filled = filled\n450         self.extendfrac = extendfrac\n451         self.extendrect = extendrect\n452         self.solids = None\n453         self.solids_patches = []\n454         self.lines = []\n455 \n456         for spine in self.ax.spines.values():\n457             spine.set_visible(False)\n458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)\n459         self._short_axis().set_visible(False)\n460         # Only kept for backcompat; remove after deprecation of .patch elapses.\n461         self._patch = mpatches.Polygon(\n462             np.empty((0, 2)),\n463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)\n464         ax.add_artist(self._patch)\n465 \n466         self.dividers = collections.LineCollection(\n467             [],\n468             colors=[mpl.rcParams['axes.edgecolor']],\n469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])\n470         self.ax.add_collection(self.dividers)\n471 \n472         self.locator = None\n473         self.minorlocator = None\n474         self.formatter = None\n475         self.__scale = None  # linear, log10 for now.  Hopefully more?\n476 \n477         if ticklocation == 'auto':\n478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'\n479         self.ticklocation = ticklocation\n480 \n481         self.set_label(label)\n482         self._reset_locator_formatter_scale()\n483 \n484         if np.iterable(ticks):\n485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n486         else:\n487             self.locator = ticks    # Handle default in _ticker()\n488 \n489         if isinstance(format, str):\n490             self.formatter = ticker.FormatStrFormatter(format)\n491         else:\n492             self.formatter = format  # Assume it is a Formatter or None\n493         self.draw_all()\n494 \n495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:\n496             self.add_lines(mappable)\n497 \n498         # Link the Axes and Colorbar for interactive use\n499         self.ax._colorbar = self\n500         # Don't navigate on any of these types of mappables\n501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or\n502                 isinstance(self.mappable, contour.ContourSet)):\n503             self.ax.set_navigate(False)\n504 \n505         # These are the functions that set up interactivity on this colorbar\n506         self._interactive_funcs = [\"_get_view\", \"_set_view\",\n507                                    \"_set_view_from_bbox\", \"drag_pan\"]\n508         for x in self._interactive_funcs:\n509             setattr(self.ax, x, getattr(self, x))\n510         # Set the cla function to the cbar's method to override it\n511         self.ax.cla = self._cbar_cla\n512 \n513     def _cbar_cla(self):\n514         \"\"\"Function to clear the interactive colorbar state.\"\"\"\n515         for x in self._interactive_funcs:\n516             delattr(self.ax, x)\n517         # We now restore the old cla() back and can call it directly\n518         del self.ax.cla\n519         self.ax.cla()\n520 \n521     # Also remove ._patch after deprecation elapses.\n522     patch = _api.deprecate_privatize_attribute(\"3.5\", alternative=\"ax\")\n523 \n524     def update_normal(self, mappable):\n525         \"\"\"\n526         Update solid patches, lines, etc.\n527 \n528         This is meant to be called when the norm of the image or contour plot\n529         to which this colorbar belongs changes.\n530 \n531         If the norm on the mappable is different than before, this resets the\n532         locator and formatter for the axis, so if these have been customized,\n533         they will need to be customized again.  However, if the norm only\n534         changes values of *vmin*, *vmax* or *cmap* then the old formatter\n535         and locator will be preserved.\n536         \"\"\"\n537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n538         self.mappable = mappable\n539         self.set_alpha(mappable.get_alpha())\n540         self.cmap = mappable.cmap\n541         if mappable.norm != self.norm:\n542             self.norm = mappable.norm\n543             self._reset_locator_formatter_scale()\n544 \n545         self.draw_all()\n546         if isinstance(self.mappable, contour.ContourSet):\n547             CS = self.mappable\n548             if not CS.filled:\n549                 self.add_lines(CS)\n550         self.stale = True\n551 \n552     def draw_all(self):\n553         \"\"\"\n554         Calculate any free parameters based on the current cmap and norm,\n555         and do all the drawing.\n556         \"\"\"\n557         if self.orientation == 'vertical':\n558             if mpl.rcParams['ytick.minor.visible']:\n559                 self.minorticks_on()\n560         else:\n561             if mpl.rcParams['xtick.minor.visible']:\n562                 self.minorticks_on()\n563         self._long_axis().set(label_position=self.ticklocation,\n564                               ticks_position=self.ticklocation)\n565         self._short_axis().set_ticks([])\n566         self._short_axis().set_ticks([], minor=True)\n567 \n568         # Set self._boundaries and self._values, including extensions.\n569         # self._boundaries are the edges of each square of color, and\n570         # self._values are the value to map into the norm to get the\n571         # color:\n572         self._process_values()\n573         # Set self.vmin and self.vmax to first and last boundary, excluding\n574         # extensions:\n575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]\n576         # Compute the X/Y mesh.\n577         X, Y, extendlen = self._mesh()\n578         # draw the extend triangles, and shrink the inner axes to accommodate.\n579         # also adds the outline path to self.outline spine:\n580         self._do_extends(extendlen)\n581 \n582         if self.orientation == 'vertical':\n583             self.ax.set_xlim(0, 1)\n584             self.ax.set_ylim(self.vmin, self.vmax)\n585         else:\n586             self.ax.set_ylim(0, 1)\n587             self.ax.set_xlim(self.vmin, self.vmax)\n588 \n589         # set up the tick locators and formatters.  A bit complicated because\n590         # boundary norms + uniform spacing requires a manual locator.\n591         self.update_ticks()\n592 \n593         if self.filled:\n594             ind = np.arange(len(self._values))\n595             if self._extend_lower():\n596                 ind = ind[1:]\n597             if self._extend_upper():\n598                 ind = ind[:-1]\n599             self._add_solids(X, Y, self._values[ind, np.newaxis])\n600 \n601     def _add_solids(self, X, Y, C):\n602         \"\"\"Draw the colors; optionally add separators.\"\"\"\n603         # Cleanup previously set artists.\n604         if self.solids is not None:\n605             self.solids.remove()\n606         for solid in self.solids_patches:\n607             solid.remove()\n608         # Add new artist(s), based on mappable type.  Use individual patches if\n609         # hatching is needed, pcolormesh otherwise.\n610         mappable = getattr(self, 'mappable', None)\n611         if (isinstance(mappable, contour.ContourSet)\n612                 and any(hatch is not None for hatch in mappable.hatches)):\n613             self._add_solids_patches(X, Y, C, mappable)\n614         else:\n615             self.solids = self.ax.pcolormesh(\n616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,\n617                 edgecolors='none', shading='flat')\n618             if not self.drawedges:\n619                 if len(self._y) >= self.n_rasterize:\n620                     self.solids.set_rasterized(True)\n621         self.dividers.set_segments(\n622             np.dstack([X, Y])[1:-1] if self.drawedges else [])\n623 \n624     def _add_solids_patches(self, X, Y, C, mappable):\n625         hatches = mappable.hatches * len(C)  # Have enough hatches.\n626         patches = []\n627         for i in range(len(X) - 1):\n628             xy = np.array([[X[i, 0], Y[i, 0]],\n629                            [X[i, 1], Y[i, 0]],\n630                            [X[i + 1, 1], Y[i + 1, 0]],\n631                            [X[i + 1, 0], Y[i + 1, 1]]])\n632             patch = mpatches.PathPatch(mpath.Path(xy),\n633                                        facecolor=self.cmap(self.norm(C[i][0])),\n634                                        hatch=hatches[i], linewidth=0,\n635                                        antialiased=False, alpha=self.alpha)\n636             self.ax.add_patch(patch)\n637             patches.append(patch)\n638         self.solids_patches = patches\n639 \n640     def _do_extends(self, extendlen):\n641         \"\"\"\n642         Add the extend tri/rectangles on the outside of the axes.\n643         \"\"\"\n644         # extend lengths are fraction of the *inner* part of colorbar,\n645         # not the total colorbar:\n646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)\n647         top = 1 + (extendlen[1] if self._extend_upper() else 0)\n648 \n649         # xyout is the outline of the colorbar including the extend patches:\n650         if not self.extendrect:\n651             # triangle:\n652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],\n653                               [1, 1], [0.5, top], [0, 1], [0, 0]])\n654         else:\n655             # rectangle:\n656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],\n657                               [1, 1], [1, top], [0, top], [0, 1],\n658                               [0, 0]])\n659 \n660         if self.orientation == 'horizontal':\n661             xyout = xyout[:, ::-1]\n662 \n663         # xyout is the path for the spine:\n664         self.outline.set_xy(xyout)\n665         if not self.filled:\n666             return\n667 \n668         # Make extend triangles or rectangles filled patches.  These are\n669         # defined in the outer parent axes' coordinates:\n670         mappable = getattr(self, 'mappable', None)\n671         if (isinstance(mappable, contour.ContourSet)\n672                 and any(hatch is not None for hatch in mappable.hatches)):\n673             hatches = mappable.hatches\n674         else:\n675             hatches = [None]\n676 \n677         if self._extend_lower():\n678             if not self.extendrect:\n679                 # triangle\n680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])\n681             else:\n682                 # rectangle\n683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])\n684             if self.orientation == 'horizontal':\n685                 xy = xy[:, ::-1]\n686             # add the patch\n687             color = self.cmap(self.norm(self._values[0]))\n688             patch = mpatches.PathPatch(\n689                 mpath.Path(xy), facecolor=color, linewidth=0,\n690                 antialiased=False, transform=self.ax.transAxes,\n691                 hatch=hatches[0], clip_on=False)\n692             self.ax.add_patch(patch)\n693         if self._extend_upper():\n694             if not self.extendrect:\n695                 # triangle\n696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])\n697             else:\n698                 # rectangle\n699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])\n700             if self.orientation == 'horizontal':\n701                 xy = xy[:, ::-1]\n702             # add the patch\n703             color = self.cmap(self.norm(self._values[-1]))\n704             patch = mpatches.PathPatch(\n705                 mpath.Path(xy), facecolor=color,\n706                 linewidth=0, antialiased=False,\n707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)\n708             self.ax.add_patch(patch)\n709         return\n710 \n711     def add_lines(self, *args, **kwargs):\n712         \"\"\"\n713         Draw lines on the colorbar.\n714 \n715         The lines are appended to the list :attr:`lines`.\n716 \n717         Parameters\n718         ----------\n719         levels : array-like\n720             The positions of the lines.\n721         colors : color or list of colors\n722             Either a single color applying to all lines or one color value for\n723             each line.\n724         linewidths : float or array-like\n725             Either a single linewidth applying to all lines or one linewidth\n726             for each line.\n727         erase : bool, default: True\n728             Whether to remove any previously added lines.\n729 \n730         Notes\n731         -----\n732         Alternatively, this method can also be called with the signature\n733         ``colorbar.add_lines(contour_set, erase=True)``, in which case\n734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.\n735         \"\"\"\n736         params = _api.select_matching_signature(\n737             [lambda self, CS, erase=True: locals(),\n738              lambda self, levels, colors, linewidths, erase=True: locals()],\n739             self, *args, **kwargs)\n740         if \"CS\" in params:\n741             self, CS, erase = params.values()\n742             if not isinstance(CS, contour.ContourSet) or CS.filled:\n743                 raise ValueError(\"If a single artist is passed to add_lines, \"\n744                                  \"it must be a ContourSet of lines\")\n745             # TODO: Make colorbar lines auto-follow changes in contour lines.\n746             return self.add_lines(\n747                 CS.levels,\n748                 [c[0] for c in CS.tcolors],\n749                 [t[0] for t in CS.tlinewidths],\n750                 erase=erase)\n751         else:\n752             self, levels, colors, linewidths, erase = params.values()\n753 \n754         y = self._locate(levels)\n755         rtol = (self._y[-1] - self._y[0]) * 1e-10\n756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)\n757         y = y[igood]\n758         if np.iterable(colors):\n759             colors = np.asarray(colors)[igood]\n760         if np.iterable(linewidths):\n761             linewidths = np.asarray(linewidths)[igood]\n762         X, Y = np.meshgrid([0, 1], y)\n763         if self.orientation == 'vertical':\n764             xy = np.stack([X, Y], axis=-1)\n765         else:\n766             xy = np.stack([Y, X], axis=-1)\n767         col = collections.LineCollection(xy, linewidths=linewidths,\n768                                          colors=colors)\n769 \n770         if erase and self.lines:\n771             for lc in self.lines:\n772                 lc.remove()\n773             self.lines = []\n774         self.lines.append(col)\n775 \n776         # make a clip path that is just a linewidth bigger than the axes...\n777         fac = np.max(linewidths) / 72\n778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])\n779         inches = self.ax.get_figure().dpi_scale_trans\n780         # do in inches:\n781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))\n782         xy[[0, 1, 4], 1] -= fac\n783         xy[[2, 3], 1] += fac\n784         # back to axes units...\n785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))\n786         if self.orientation == 'horizontal':\n787             xy = xy.T\n788         col.set_clip_path(mpath.Path(xy, closed=True),\n789                           self.ax.transAxes)\n790         self.ax.add_collection(col)\n791         self.stale = True\n792 \n793     def update_ticks(self):\n794         \"\"\"\n795         Setup the ticks and ticklabels. This should not be needed by users.\n796         \"\"\"\n797         # Get the locator and formatter; defaults to self.locator if not None.\n798         self._get_ticker_locator_formatter()\n799         self._long_axis().set_major_locator(self.locator)\n800         self._long_axis().set_minor_locator(self.minorlocator)\n801         self._long_axis().set_major_formatter(self.formatter)\n802 \n803     def _get_ticker_locator_formatter(self):\n804         \"\"\"\n805         Return the ``locator`` and ``formatter`` of the colorbar.\n806 \n807         If they have not been defined (i.e. are *None*), the formatter and\n808         locator are retrieved from the axis, or from the value of the\n809         boundaries for a boundary norm.\n810 \n811         Called by update_ticks...\n812         \"\"\"\n813         locator = self.locator\n814         formatter = self.formatter\n815         minorlocator = self.minorlocator\n816         if isinstance(self.norm, colors.BoundaryNorm):\n817             b = self.norm.boundaries\n818             if locator is None:\n819                 locator = ticker.FixedLocator(b, nbins=10)\n820         elif self.boundaries is not None:\n821             b = self._boundaries[self._inside]\n822             if locator is None:\n823                 locator = ticker.FixedLocator(b, nbins=10)\n824         else:  # most cases:\n825             if locator is None:\n826                 # we haven't set the locator explicitly, so use the default\n827                 # for this axis:\n828                 locator = self._long_axis().get_major_locator()\n829             if minorlocator is None:\n830                 minorlocator = self._long_axis().get_minor_locator()\n831             if isinstance(self.norm, colors.NoNorm):\n832                 # default locator:\n833                 nv = len(self._values)\n834                 base = 1 + int(nv / 10)\n835                 locator = ticker.IndexLocator(base=base, offset=0)\n836 \n837         if minorlocator is None:\n838             minorlocator = ticker.NullLocator()\n839 \n840         if formatter is None:\n841             formatter = self._long_axis().get_major_formatter()\n842 \n843         self.locator = locator\n844         self.formatter = formatter\n845         self.minorlocator = minorlocator\n846         _log.debug('locator: %r', locator)\n847 \n848     @_api.delete_parameter(\"3.5\", \"update_ticks\")\n849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,\n850                   minor=False, **kwargs):\n851         \"\"\"\n852         Set tick locations.\n853 \n854         Parameters\n855         ----------\n856         ticks : list of floats\n857             List of tick locations.\n858         labels : list of str, optional\n859             List of tick labels. If not set, the labels show the data value.\n860         minor : bool, default: False\n861             If ``False``, set the major ticks; if ``True``, the minor ticks.\n862         **kwargs\n863             `.Text` properties for the labels. These take effect only if you\n864             pass *labels*. In other cases, please use `~.Axes.tick_params`.\n865         \"\"\"\n866         if np.iterable(ticks):\n867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,\n868                                         **kwargs)\n869             self.locator = self._long_axis().get_major_locator()\n870         else:\n871             self.locator = ticks\n872             self._long_axis().set_major_locator(self.locator)\n873         self.stale = True\n874 \n875     def get_ticks(self, minor=False):\n876         \"\"\"\n877         Return the ticks as a list of locations.\n878 \n879         Parameters\n880         ----------\n881         minor : boolean, default: False\n882             if True return the minor ticks.\n883         \"\"\"\n884         if minor:\n885             return self._long_axis().get_minorticklocs()\n886         else:\n887             return self._long_axis().get_majorticklocs()\n888 \n889     @_api.delete_parameter(\"3.5\", \"update_ticks\")\n890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,\n891                        **kwargs):\n892         \"\"\"\n893         Set tick labels.\n894 \n895         .. admonition:: Discouraged\n896 \n897             The use of this method is discouraged, because of the dependency\n898             on tick positions. In most cases, you'll want to use\n899             ``set_ticks(positions, labels=labels)`` instead.\n900 \n901             If you are using this method, you should always fix the tick\n902             positions before, e.g. by using `.Colorbar.set_ticks` or by\n903             explicitly setting a `~.ticker.FixedLocator` on the long axis\n904             of the colorbar. Otherwise, ticks are free to move and the\n905             labels may end up in unexpected positions.\n906 \n907         Parameters\n908         ----------\n909         ticklabels : sequence of str or of `.Text`\n910             Texts for labeling each tick location in the sequence set by\n911             `.Colorbar.set_ticks`; the number of labels must match the number\n912             of locations.\n913 \n914         update_ticks : bool, default: True\n915             This keyword argument is ignored and will be be removed.\n916             Deprecated\n917 \n918          minor : bool\n919             If True, set minor ticks instead of major ticks.\n920 \n921         **kwargs\n922             `.Text` properties for the labels.\n923         \"\"\"\n924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)\n925 \n926     def minorticks_on(self):\n927         \"\"\"\n928         Turn on colorbar minor ticks.\n929         \"\"\"\n930         self.ax.minorticks_on()\n931         self.minorlocator = self._long_axis().get_minor_locator()\n932         self._short_axis().set_minor_locator(ticker.NullLocator())\n933 \n934     def minorticks_off(self):\n935         \"\"\"Turn the minor ticks of the colorbar off.\"\"\"\n936         self.minorlocator = ticker.NullLocator()\n937         self._long_axis().set_minor_locator(self.minorlocator)\n938 \n939     def set_label(self, label, *, loc=None, **kwargs):\n940         \"\"\"\n941         Add a label to the long axis of the colorbar.\n942 \n943         Parameters\n944         ----------\n945         label : str\n946             The label text.\n947         loc : str, optional\n948             The location of the label.\n949 \n950             - For horizontal orientation one of {'left', 'center', 'right'}\n951             - For vertical orientation one of {'bottom', 'center', 'top'}\n952 \n953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`\n954             depending on the orientation.\n955         **kwargs\n956             Keyword arguments are passed to `~.Axes.set_xlabel` /\n957             `~.Axes.set_ylabel`.\n958             Supported keywords are *labelpad* and `.Text` properties.\n959         \"\"\"\n960         if self.orientation == \"vertical\":\n961             self.ax.set_ylabel(label, loc=loc, **kwargs)\n962         else:\n963             self.ax.set_xlabel(label, loc=loc, **kwargs)\n964         self.stale = True\n965 \n966     def set_alpha(self, alpha):\n967         \"\"\"\n968         Set the transparency between 0 (transparent) and 1 (opaque).\n969 \n970         If an array is provided, *alpha* will be set to None to use the\n971         transparency values associated with the colormap.\n972         \"\"\"\n973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha\n974 \n975     def _set_scale(self, scale, **kwargs):\n976         \"\"\"\n977         Set the colorbar long axis scale.\n978 \n979         Parameters\n980         ----------\n981         value : {\"linear\", \"log\", \"symlog\", \"logit\", ...} or `.ScaleBase`\n982             The axis scale type to apply.\n983 \n984         **kwargs\n985             Different keyword arguments are accepted, depending on the scale.\n986             See the respective class keyword arguments:\n987 \n988             - `matplotlib.scale.LinearScale`\n989             - `matplotlib.scale.LogScale`\n990             - `matplotlib.scale.SymmetricalLogScale`\n991             - `matplotlib.scale.LogitScale`\n992             - `matplotlib.scale.FuncScale`\n993 \n994         Notes\n995         -----\n996         By default, Matplotlib supports the above mentioned scales.\n997         Additionally, custom scales may be registered using\n998         `matplotlib.scale.register_scale`. These scales can then also\n999         be used here.\n1000         \"\"\"\n1001         if self.orientation == 'vertical':\n1002             self.ax.set_yscale(scale, **kwargs)\n1003         else:\n1004             self.ax.set_xscale(scale, **kwargs)\n1005         if isinstance(scale, mscale.ScaleBase):\n1006             self.__scale = scale.name\n1007         else:\n1008             self.__scale = scale\n1009 \n1010     def remove(self):\n1011         \"\"\"\n1012         Remove this colorbar from the figure.\n1013 \n1014         If the colorbar was created with ``use_gridspec=True`` the previous\n1015         gridspec is restored.\n1016         \"\"\"\n1017         if hasattr(self.ax, '_colorbar_info'):\n1018             parents = self.ax._colorbar_info['parents']\n1019             for a in parents:\n1020                 if self.ax in a._colorbars:\n1021                     a._colorbars.remove(self.ax)\n1022 \n1023         self.ax.remove()\n1024 \n1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)\n1026         self.mappable.colorbar = None\n1027         self.mappable.colorbar_cid = None\n1028 \n1029         try:\n1030             ax = self.mappable.axes\n1031         except AttributeError:\n1032             return\n1033         try:\n1034             gs = ax.get_subplotspec().get_gridspec()\n1035             subplotspec = gs.get_topmost_subplotspec()\n1036         except AttributeError:\n1037             # use_gridspec was False\n1038             pos = ax.get_position(original=True)\n1039             ax._set_position(pos)\n1040         else:\n1041             # use_gridspec was True\n1042             ax.set_subplotspec(subplotspec)\n1043 \n1044     def _ticker(self, locator, formatter):\n1045         \"\"\"\n1046         Return the sequence of ticks (colorbar data locations),\n1047         ticklabels (strings), and the corresponding offset string.\n1048         \"\"\"\n1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:\n1050             intv = self._values[0], self._values[-1]\n1051         else:\n1052             intv = self.vmin, self.vmax\n1053         locator.create_dummy_axis(minpos=intv[0])\n1054         locator.axis.set_view_interval(*intv)\n1055         locator.axis.set_data_interval(*intv)\n1056         formatter.set_axis(locator.axis)\n1057 \n1058         b = np.array(locator())\n1059         if isinstance(locator, ticker.LogLocator):\n1060             eps = 1e-10\n1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]\n1062         else:\n1063             eps = (intv[1] - intv[0]) * 1e-10\n1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]\n1065         ticks = self._locate(b)\n1066         ticklabels = formatter.format_ticks(b)\n1067         offset_string = formatter.get_offset()\n1068         return ticks, ticklabels, offset_string\n1069 \n1070     def _process_values(self):\n1071         \"\"\"\n1072         Set `_boundaries` and `_values` based on the self.boundaries and\n1073         self.values if not None, or based on the size of the colormap and\n1074         the vmin/vmax of the norm.\n1075         \"\"\"\n1076         if self.values is not None:\n1077             # set self._boundaries from the values...\n1078             self._values = np.array(self.values)\n1079             if self.boundaries is None:\n1080                 # bracket values by 1/2 dv:\n1081                 b = np.zeros(len(self.values) + 1)\n1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n1083                 b[0] = 2.0 * b[1] - b[2]\n1084                 b[-1] = 2.0 * b[-2] - b[-3]\n1085                 self._boundaries = b\n1086                 return\n1087             self._boundaries = np.array(self.boundaries)\n1088             return\n1089 \n1090         # otherwise values are set from the boundaries\n1091         if isinstance(self.norm, colors.BoundaryNorm):\n1092             b = self.norm.boundaries\n1093         else:\n1094             # otherwise make the boundaries from the size of the cmap:\n1095             N = self.cmap.N + 1\n1096             b, _ = self._uniform_y(N)\n1097         # add extra boundaries if needed:\n1098         if self._extend_lower():\n1099             b = np.hstack((b[0] - 1, b))\n1100         if self._extend_upper():\n1101             b = np.hstack((b, b[-1] + 1))\n1102 \n1103         # transform from 0-1 to vmin-vmax:\n1104         if not self.norm.scaled():\n1105             self.norm.vmin = 0\n1106             self.norm.vmax = 1\n1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n1108             self.norm.vmin, self.norm.vmax, expander=0.1)\n1109         if not isinstance(self.norm, colors.BoundaryNorm):\n1110             b = self.norm.inverse(b)\n1111 \n1112         self._boundaries = np.asarray(b, dtype=float)\n1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n1114         if isinstance(self.norm, colors.NoNorm):\n1115             self._values = (self._values + 0.00001).astype(np.int16)\n1116 \n1117     def _mesh(self):\n1118         \"\"\"\n1119         Return the coordinate arrays for the colorbar pcolormesh/patches.\n1120 \n1121         These are scaled between vmin and vmax, and already handle colorbar\n1122         orientation.\n1123         \"\"\"\n1124         # copy the norm and change the vmin and vmax to the vmin and\n1125         # vmax of the colorbar, not the norm.  This allows the situation\n1126         # where the colormap has a narrower range than the colorbar, to\n1127         # accommodate extra contours:\n1128         norm = copy.deepcopy(self.norm)\n1129         norm.vmin = self.vmin\n1130         norm.vmax = self.vmax\n1131         y, extendlen = self._proportional_y()\n1132         # invert:\n1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):\n1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.\n1135         else:\n1136             y = norm.inverse(y)\n1137         self._y = y\n1138         X, Y = np.meshgrid([0., 1.], y)\n1139         if self.orientation == 'vertical':\n1140             return (X, Y, extendlen)\n1141         else:\n1142             return (Y, X, extendlen)\n1143 \n1144     def _forward_boundaries(self, x):\n1145         b = self._boundaries\n1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))\n1147         eps = (b[-1] - b[0]) * 1e-6\n1148         y[x < b[0]-eps] = -1\n1149         y[x > b[-1]+eps] = 2\n1150         return y\n1151 \n1152     def _inverse_boundaries(self, x):\n1153         b = self._boundaries\n1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)\n1155 \n1156     def _reset_locator_formatter_scale(self):\n1157         \"\"\"\n1158         Reset the locator et al to defaults.  Any user-hardcoded changes\n1159         need to be re-entered if this gets called (either at init, or when\n1160         the mappable normal gets changed: Colorbar.update_normal)\n1161         \"\"\"\n1162         self._process_values()\n1163         self.locator = None\n1164         self.minorlocator = None\n1165         self.formatter = None\n1166         if (self.boundaries is not None or\n1167                 isinstance(self.norm, colors.BoundaryNorm)):\n1168             if self.spacing == 'uniform':\n1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)\n1170                 self._set_scale('function', functions=funcs)\n1171             elif self.spacing == 'proportional':\n1172                 self._set_scale('linear')\n1173         elif getattr(self.norm, '_scale', None):\n1174             # use the norm's scale (if it exists and is not None):\n1175             self._set_scale(self.norm._scale)\n1176         elif type(self.norm) is colors.Normalize:\n1177             # plain Normalize:\n1178             self._set_scale('linear')\n1179         else:\n1180             # norm._scale is None or not an attr: derive the scale from\n1181             # the Norm:\n1182             funcs = (self.norm, self.norm.inverse)\n1183             self._set_scale('function', functions=funcs)\n1184 \n1185     def _locate(self, x):\n1186         \"\"\"\n1187         Given a set of color data values, return their\n1188         corresponding colorbar data coordinates.\n1189         \"\"\"\n1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n1191             b = self._boundaries\n1192             xn = x\n1193         else:\n1194             # Do calculations using normalized coordinates so\n1195             # as to make the interpolation more accurate.\n1196             b = self.norm(self._boundaries, clip=False).filled()\n1197             xn = self.norm(x, clip=False).filled()\n1198 \n1199         bunique = b[self._inside]\n1200         yunique = self._y\n1201 \n1202         z = np.interp(xn, bunique, yunique)\n1203         return z\n1204 \n1205     # trivial helpers\n1206 \n1207     def _uniform_y(self, N):\n1208         \"\"\"\n1209         Return colorbar data coordinates for *N* uniformly\n1210         spaced boundaries, plus extension lengths if required.\n1211         \"\"\"\n1212         automin = automax = 1. / (N - 1.)\n1213         extendlength = self._get_extension_lengths(self.extendfrac,\n1214                                                    automin, automax,\n1215                                                    default=0.05)\n1216         y = np.linspace(0, 1, N)\n1217         return y, extendlength\n1218 \n1219     def _proportional_y(self):\n1220         \"\"\"\n1221         Return colorbar data coordinates for the boundaries of\n1222         a proportional colorbar, plus extension lengths if required:\n1223         \"\"\"\n1224         if isinstance(self.norm, colors.BoundaryNorm):\n1225             y = (self._boundaries - self._boundaries[self._inside][0])\n1226             y = y / (self._boundaries[self._inside][-1] -\n1227                      self._boundaries[self._inside][0])\n1228             # need yscaled the same as the axes scale to get\n1229             # the extend lengths.\n1230             if self.spacing == 'uniform':\n1231                 yscaled = self._forward_boundaries(self._boundaries)\n1232             else:\n1233                 yscaled = y\n1234         else:\n1235             y = self.norm(self._boundaries.copy())\n1236             y = np.ma.filled(y, np.nan)\n1237             # the norm and the scale should be the same...\n1238             yscaled = y\n1239         y = y[self._inside]\n1240         yscaled = yscaled[self._inside]\n1241         # normalize from 0..1:\n1242         norm = colors.Normalize(y[0], y[-1])\n1243         y = np.ma.filled(norm(y), np.nan)\n1244         norm = colors.Normalize(yscaled[0], yscaled[-1])\n1245         yscaled = np.ma.filled(norm(yscaled), np.nan)\n1246         # make the lower and upper extend lengths proportional to the lengths\n1247         # of the first and last boundary spacing (if extendfrac='auto'):\n1248         automin = yscaled[1] - yscaled[0]\n1249         automax = yscaled[-1] - yscaled[-2]\n1250         extendlength = [0, 0]\n1251         if self._extend_lower() or self._extend_upper():\n1252             extendlength = self._get_extension_lengths(\n1253                     self.extendfrac, automin, automax, default=0.05)\n1254         return y, extendlength\n1255 \n1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n1257         \"\"\"\n1258         Return the lengths of colorbar extensions.\n1259 \n1260         This is a helper method for _uniform_y and _proportional_y.\n1261         \"\"\"\n1262         # Set the default value.\n1263         extendlength = np.array([default, default])\n1264         if isinstance(frac, str):\n1265             _api.check_in_list(['auto'], extendfrac=frac.lower())\n1266             # Use the provided values when 'auto' is required.\n1267             extendlength[:] = [automin, automax]\n1268         elif frac is not None:\n1269             try:\n1270                 # Try to set min and max extension fractions directly.\n1271                 extendlength[:] = frac\n1272                 # If frac is a sequence containing None then NaN may\n1273                 # be encountered. This is an error.\n1274                 if np.isnan(extendlength).any():\n1275                     raise ValueError()\n1276             except (TypeError, ValueError) as err:\n1277                 # Raise an error on encountering an invalid value for frac.\n1278                 raise ValueError('invalid value for extendfrac') from err\n1279         return extendlength\n1280 \n1281     def _extend_lower(self):\n1282         \"\"\"Return whether the lower limit is open ended.\"\"\"\n1283         return self.extend in ('both', 'min')\n1284 \n1285     def _extend_upper(self):\n1286         \"\"\"Return whether the upper limit is open ended.\"\"\"\n1287         return self.extend in ('both', 'max')\n1288 \n1289     def _long_axis(self):\n1290         \"\"\"Return the long axis\"\"\"\n1291         if self.orientation == 'vertical':\n1292             return self.ax.yaxis\n1293         return self.ax.xaxis\n1294 \n1295     def _short_axis(self):\n1296         \"\"\"Return the short axis\"\"\"\n1297         if self.orientation == 'vertical':\n1298             return self.ax.xaxis\n1299         return self.ax.yaxis\n1300 \n1301     def _get_view(self):\n1302         # docstring inherited\n1303         # An interactive view for a colorbar is the norm's vmin/vmax\n1304         return self.norm.vmin, self.norm.vmax\n1305 \n1306     def _set_view(self, view):\n1307         # docstring inherited\n1308         # An interactive view for a colorbar is the norm's vmin/vmax\n1309         self.norm.vmin, self.norm.vmax = view\n1310 \n1311     def _set_view_from_bbox(self, bbox, direction='in',\n1312                             mode=None, twinx=False, twiny=False):\n1313         # docstring inherited\n1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax\n1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(\n1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)\n1317         if self.orientation == 'horizontal':\n1318             self.norm.vmin, self.norm.vmax = new_xbound\n1319         elif self.orientation == 'vertical':\n1320             self.norm.vmin, self.norm.vmax = new_ybound\n1321 \n1322     def drag_pan(self, button, key, x, y):\n1323         # docstring inherited\n1324         points = self.ax._get_pan_points(button, key, x, y)\n1325         if points is not None:\n1326             if self.orientation == 'horizontal':\n1327                 self.norm.vmin, self.norm.vmax = points[:, 0]\n1328             elif self.orientation == 'vertical':\n1329                 self.norm.vmin, self.norm.vmax = points[:, 1]\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "lib/matplotlib/colorbar.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.4/lib/matplotlib/colorbar.py",
        "start": 1,
        "end": 1601,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Colorbars are a visualization of the mapping from scalar values to colors.\n3 In Matplotlib they are drawn into a dedicated `~.axes.Axes`.\n4 \n5 .. note::\n6    Colorbars are typically created through `.Figure.colorbar` or its pyplot\n7    wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with\n8    `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for\n9    non-`.GridSpec`-positioned axes).\n10 \n11    End-users most likely won't need to directly use this module's API.\n12 \"\"\"\n13 \n14 import copy\n15 import logging\n16 import textwrap\n17 \n18 import numpy as np\n19 \n20 import matplotlib as mpl\n21 from matplotlib import _api, collections, cm, colors, contour, ticker\n22 import matplotlib.artist as martist\n23 import matplotlib.patches as mpatches\n24 import matplotlib.path as mpath\n25 import matplotlib.scale as mscale\n26 import matplotlib.spines as mspines\n27 import matplotlib.transforms as mtransforms\n28 from matplotlib import docstring\n29 \n30 _log = logging.getLogger(__name__)\n31 \n32 _make_axes_param_doc = \"\"\"\n33 location : None or {'left', 'right', 'top', 'bottom'}\n34     The location, relative to the parent axes, where the colorbar axes\n35     is created.  It also determines the *orientation* of the colorbar\n36     (colorbars on the left and right are vertical, colorbars at the top\n37     and bottom are horizontal).  If None, the location will come from the\n38     *orientation* if it is set (vertical colorbars on the right, horizontal\n39     ones at the bottom), or default to 'right' if *orientation* is unset.\n40 orientation : None or {'vertical', 'horizontal'}\n41     The orientation of the colorbar.  It is preferable to set the *location*\n42     of the colorbar, as that also determines the *orientation*; passing\n43     incompatible values for *location* and *orientation* raises an exception.\n44 fraction : float, default: 0.15\n45     Fraction of original axes to use for colorbar.\n46 shrink : float, default: 1.0\n47     Fraction by which to multiply the size of the colorbar.\n48 aspect : float, default: 20\n49     Ratio of long to short dimensions.\n50 \"\"\"\n51 _make_axes_other_param_doc = \"\"\"\n52 pad : float, default: 0.05 if vertical, 0.15 if horizontal\n53     Fraction of original axes between colorbar and new image axes.\n54 anchor : (float, float), optional\n55     The anchor point of the colorbar axes.\n56     Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal.\n57 panchor : (float, float), or *False*, optional\n58     The anchor point of the colorbar parent axes. If *False*, the parent\n59     axes' anchor will be unchanged.\n60     Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.\n61 \"\"\"\n62 \n63 _colormap_kw_doc = \"\"\"\n64 \n65     ============  ====================================================\n66     Property      Description\n67     ============  ====================================================\n68     *extend*      {'neither', 'both', 'min', 'max'}\n69                   If not 'neither', make pointed end(s) for out-of-\n70                   range values.  These are set for a given colormap\n71                   using the colormap set_under and set_over methods.\n72     *extendfrac*  {*None*, 'auto', length, lengths}\n73                   If set to *None*, both the minimum and maximum\n74                   triangular colorbar extensions with have a length of\n75                   5% of the interior colorbar length (this is the\n76                   default setting). If set to 'auto', makes the\n77                   triangular colorbar extensions the same lengths as\n78                   the interior boxes (when *spacing* is set to\n79                   'uniform') or the same lengths as the respective\n80                   adjacent interior boxes (when *spacing* is set to\n81                   'proportional'). If a scalar, indicates the length\n82                   of both the minimum and maximum triangular colorbar\n83                   extensions as a fraction of the interior colorbar\n84                   length. A two-element sequence of fractions may also\n85                   be given, indicating the lengths of the minimum and\n86                   maximum colorbar extensions respectively as a\n87                   fraction of the interior colorbar length.\n88     *extendrect*  bool\n89                   If *False* the minimum and maximum colorbar extensions\n90                   will be triangular (the default). If *True* the\n91                   extensions will be rectangular.\n92     *spacing*     {'uniform', 'proportional'}\n93                   Uniform spacing gives each discrete color the same\n94                   space; proportional makes the space proportional to\n95                   the data interval.\n96     *ticks*       *None* or list of ticks or Locator\n97                   If None, ticks are determined automatically from the\n98                   input.\n99     *format*      None or str or Formatter\n100                   If None, `~.ticker.ScalarFormatter` is used.\n101                   If a format string is given, e.g., '%.3f', that is used.\n102                   An alternative `~.ticker.Formatter` may be given instead.\n103     *drawedges*   bool\n104                   Whether to draw lines at color boundaries.\n105     *label*       str\n106                   The label on the colorbar's long axis.\n107     ============  ====================================================\n108 \n109     The following will probably be useful only in the context of\n110     indexed colors (that is, when the mappable has norm=NoNorm()),\n111     or other unusual circumstances.\n112 \n113     ============   ===================================================\n114     Property       Description\n115     ============   ===================================================\n116     *boundaries*   None or a sequence\n117     *values*       None or a sequence which must be of length 1 less\n118                    than the sequence of *boundaries*. For each region\n119                    delimited by adjacent entries in *boundaries*, the\n120                    colormapped to the corresponding value in values\n121                    will be used.\n122     ============   ===================================================\n123 \n124 \"\"\"\n125 \n126 docstring.interpd.update(colorbar_doc=\"\"\"\n127 Add a colorbar to a plot.\n128 \n129 Parameters\n130 ----------\n131 mappable\n132     The `matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.AxesImage`,\n133     `~matplotlib.contour.ContourSet`, etc.) described by this colorbar.\n134     This argument is mandatory for the `.Figure.colorbar` method but optional\n135     for the `.pyplot.colorbar` function, which sets the default to the current\n136     image.\n137 \n138     Note that one can create a `.ScalarMappable` \"on-the-fly\" to generate\n139     colorbars not attached to a previously drawn artist, e.g. ::\n140 \n141         fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)\n142 \n143 cax : `~matplotlib.axes.Axes`, optional\n144     Axes into which the colorbar will be drawn.\n145 \n146 ax : `~matplotlib.axes.Axes`, list of Axes, optional\n147     One or more parent axes from which space for a new colorbar axes will be\n148     stolen, if *cax* is None.  This has no effect if *cax* is set.\n149 \n150 use_gridspec : bool, optional\n151     If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If\n152     *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is\n153     created as an instance of Subplot using the :mod:`.gridspec` module.\n154 \n155 Returns\n156 -------\n157 colorbar : `~matplotlib.colorbar.Colorbar`\n158 \n159 Notes\n160 -----\n161 Additional keyword arguments are of two kinds:\n162 \n163   axes properties:\n164 %s\n165 %s\n166   colorbar properties:\n167 %s\n168 \n169 If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is included\n170 automatically.\n171 \n172 The *shrink* kwarg provides a simple way to scale the colorbar with respect\n173 to the axes. Note that if *cax* is specified, it determines the size of the\n174 colorbar and *shrink* and *aspect* kwargs are ignored.\n175 \n176 For more precise control, you can manually specify the positions of\n177 the axes objects in which the mappable and the colorbar are drawn.  In\n178 this case, do not use any of the axes properties kwargs.\n179 \n180 It is known that some vector graphics viewers (svg and pdf) renders white gaps\n181 between segments of the colorbar.  This is due to bugs in the viewers, not\n182 Matplotlib.  As a workaround, the colorbar can be rendered with overlapping\n183 segments::\n184 \n185     cbar = colorbar()\n186     cbar.solids.set_edgecolor(\"face\")\n187     draw()\n188 \n189 However this has negative consequences in other circumstances, e.g. with\n190 semi-transparent images (alpha < 1) and colorbar extensions; therefore, this\n191 workaround is not used by default (see issue #1188).\n192 \"\"\" % (textwrap.indent(_make_axes_param_doc, \"    \"),\n193        textwrap.indent(_make_axes_other_param_doc, \"    \"),\n194        _colormap_kw_doc))\n195 \n196 \n197 @_api.caching_module_getattr  # module-level deprecations\n198 class __getattr__:\n199     colorbar_doc = _api.deprecated(\"3.4\", obj_type=\"\")(property(\n200         lambda self: docstring.interpd.params[\"colorbar_doc\"]))\n201     colorbar_kw_doc = _api.deprecated(\"3.4\", obj_type=\"\")(property(\n202         lambda self: _colormap_kw_doc))\n203     make_axes_kw_doc = _api.deprecated(\"3.4\", obj_type=\"\")(property(\n204         lambda self: _make_axes_param_doc + _make_axes_other_param_doc))\n205 \n206 \n207 def _set_ticks_on_axis_warn(*args, **kwargs):\n208     # a top level function which gets put in at the axes'\n209     # set_xticks and set_yticks by Colorbar.__init__.\n210     _api.warn_external(\"Use the colorbar set_ticks() method instead.\")\n211 \n212 \n213 class _ColorbarSpine(mspines.Spine):\n214     def __init__(self, axes):\n215         self._ax = axes\n216         super().__init__(axes, 'colorbar',\n217                          mpath.Path(np.empty((0, 2)), closed=True))\n218         mpatches.Patch.set_transform(self, axes.transAxes)\n219 \n220     def get_window_extent(self, renderer=None):\n221         # This Spine has no Axis associated with it, and doesn't need to adjust\n222         # its location, so we can directly get the window extent from the\n223         # super-super-class.\n224         return mpatches.Patch.get_window_extent(self, renderer=renderer)\n225 \n226     def set_xy(self, xy):\n227         self._path = mpath.Path(xy, closed=True)\n228         self._xy = xy\n229         self.stale = True\n230 \n231     def draw(self, renderer):\n232         ret = mpatches.Patch.draw(self, renderer)\n233         self.stale = False\n234         return ret\n235 \n236 \n237 class _ColorbarAxesLocator:\n238     \"\"\"\n239     Shrink the axes if there are triangular or rectangular extends.\n240     \"\"\"\n241     def __init__(self, cbar):\n242         self._cbar = cbar\n243         self._orig_locator = cbar.ax._axes_locator\n244 \n245     def __call__(self, ax, renderer):\n246         if self._orig_locator is not None:\n247             pos = self._orig_locator(ax, renderer)\n248         else:\n249             pos = ax.get_position(original=True)\n250         if self._cbar.extend == 'neither':\n251             return pos\n252 \n253         y, extendlen = self._cbar._proportional_y()\n254         if not self._cbar._extend_lower():\n255             extendlen[0] = 0\n256         if not self._cbar._extend_upper():\n257             extendlen[1] = 0\n258         len = sum(extendlen) + 1\n259         shrink = 1 / len\n260         offset = extendlen[0] / len\n261         # we need to reset the aspect ratio of the axes to account\n262         # of the extends...\n263         if hasattr(ax, '_colorbar_info'):\n264             aspect = ax._colorbar_info['aspect']\n265         else:\n266             aspect = False\n267         # now shrink and/or offset to take into account the\n268         # extend tri/rectangles.\n269         if self._cbar.orientation == 'vertical':\n270             if aspect:\n271                 self._cbar.ax.set_box_aspect(aspect*shrink)\n272             pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)\n273         else:\n274             if aspect:\n275                 self._cbar.ax.set_box_aspect(1/(aspect * shrink))\n276             pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)\n277         return pos\n278 \n279     def get_subplotspec(self):\n280         # make tight_layout happy..\n281         ss = getattr(self._cbar.ax, 'get_subplotspec', None)\n282         if ss is None:\n283             ss = self._orig_locator.get_subplotspec()\n284         else:\n285             ss = ss()\n286         return ss\n287 \n288 \n289 class Colorbar:\n290     r\"\"\"\n291     Draw a colorbar in an existing axes.\n292 \n293     Typically, colorbars are created using `.Figure.colorbar` or\n294     `.pyplot.colorbar` and associated with `.ScalarMappable`\\s (such as an\n295     `.AxesImage` generated via `~.axes.Axes.imshow`).\n296 \n297     In order to draw a colorbar not associated with other elements in the\n298     figure, e.g. when showing a colormap by itself, one can create an empty\n299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*\n300     to `Colorbar`.\n301 \n302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n303 \n304     Attributes\n305     ----------\n306     ax : `~matplotlib.axes.Axes`\n307         The `~.axes.Axes` instance in which the colorbar is drawn.\n308     lines : list\n309         A list of `.LineCollection` (empty if no lines were drawn).\n310     dividers : `.LineCollection`\n311         A LineCollection (empty if *drawedges* is ``False``).\n312 \n313     Parameters\n314     ----------\n315     ax : `~matplotlib.axes.Axes`\n316         The `~.axes.Axes` instance in which the colorbar is drawn.\n317 \n318     mappable : `.ScalarMappable`\n319         The mappable whose colormap and norm will be used.\n320 \n321         To show the under- and over- value colors, the mappable's norm should\n322         be specified as ::\n323 \n324             norm = colors.Normalize(clip=False)\n325 \n326         To show the colors versus index instead of on a 0-1 scale, use::\n327 \n328             norm=colors.NoNorm()\n329 \n330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n331         The colormap to use.  This parameter is ignored, unless *mappable* is\n332         None.\n333 \n334     norm : `~matplotlib.colors.Normalize`\n335         The normalization to use.  This parameter is ignored, unless *mappable*\n336         is None.\n337 \n338     alpha : float\n339         The colorbar transparency between 0 (transparent) and 1 (opaque).\n340 \n341     values, boundaries\n342         If unset, the colormap will be displayed on a 0-1 scale.\n343 \n344     orientation : {'vertical', 'horizontal'}\n345 \n346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}\n347 \n348     extend : {'neither', 'both', 'min', 'max'}\n349 \n350     spacing : {'uniform', 'proportional'}\n351 \n352     ticks : `~matplotlib.ticker.Locator` or array-like of float\n353 \n354     format : str or `~matplotlib.ticker.Formatter`\n355 \n356     drawedges : bool\n357 \n358     filled : bool\n359 \n360     extendfrac\n361 \n362     extendrec\n363 \n364     label : str\n365     \"\"\"\n366 \n367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n368 \n369     def __init__(self, ax, mappable=None, *, cmap=None,\n370                  norm=None,\n371                  alpha=None,\n372                  values=None,\n373                  boundaries=None,\n374                  orientation='vertical',\n375                  ticklocation='auto',\n376                  extend=None,\n377                  spacing='uniform',  # uniform or proportional\n378                  ticks=None,\n379                  format=None,\n380                  drawedges=False,\n381                  filled=True,\n382                  extendfrac=None,\n383                  extendrect=False,\n384                  label='',\n385                  ):\n386 \n387         if mappable is None:\n388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n389 \n390         # Ensure the given mappable's norm has appropriate vmin and vmax\n391         # set even if mappable.draw has not yet been called.\n392         if mappable.get_array() is not None:\n393             mappable.autoscale_None()\n394 \n395         self.mappable = mappable\n396         cmap = mappable.cmap\n397         norm = mappable.norm\n398 \n399         if isinstance(mappable, contour.ContourSet):\n400             cs = mappable\n401             alpha = cs.get_alpha()\n402             boundaries = cs._levels\n403             values = cs.cvalues\n404             extend = cs.extend\n405             filled = cs.filled\n406             if ticks is None:\n407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)\n408         elif isinstance(mappable, martist.Artist):\n409             alpha = mappable.get_alpha()\n410 \n411         mappable.colorbar = self\n412         mappable.colorbar_cid = mappable.callbacks.connect(\n413             'changed', self.update_normal)\n414 \n415         _api.check_in_list(\n416             ['vertical', 'horizontal'], orientation=orientation)\n417         _api.check_in_list(\n418             ['auto', 'left', 'right', 'top', 'bottom'],\n419             ticklocation=ticklocation)\n420         _api.check_in_list(\n421             ['uniform', 'proportional'], spacing=spacing)\n422 \n423         self.ax = ax\n424         self.ax._axes_locator = _ColorbarAxesLocator(self)\n425 \n426         if extend is None:\n427             if (not isinstance(mappable, contour.ContourSet)\n428                     and getattr(cmap, 'colorbar_extend', False) is not False):\n429                 extend = cmap.colorbar_extend\n430             elif hasattr(norm, 'extend'):\n431                 extend = norm.extend\n432             else:\n433                 extend = 'neither'\n434         self.alpha = None\n435         # Call set_alpha to handle array-like alphas properly\n436         self.set_alpha(alpha)\n437         self.cmap = cmap\n438         self.norm = norm\n439         self.values = values\n440         self.boundaries = boundaries\n441         self.extend = extend\n442         self._inside = _api.check_getitem(\n443             {'neither': slice(0, None), 'both': slice(1, -1),\n444              'min': slice(1, None), 'max': slice(0, -1)},\n445             extend=extend)\n446         self.spacing = spacing\n447         self.orientation = orientation\n448         self.drawedges = drawedges\n449         self.filled = filled\n450         self.extendfrac = extendfrac\n451         self.extendrect = extendrect\n452         self.solids = None\n453         self.solids_patches = []\n454         self.lines = []\n455 \n456         for spine in self.ax.spines.values():\n457             spine.set_visible(False)\n458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)\n459         self._short_axis().set_visible(False)\n460         # Only kept for backcompat; remove after deprecation of .patch elapses.\n461         self._patch = mpatches.Polygon(\n462             np.empty((0, 2)),\n463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)\n464         ax.add_artist(self._patch)\n465 \n466         self.dividers = collections.LineCollection(\n467             [],\n468             colors=[mpl.rcParams['axes.edgecolor']],\n469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])\n470         self.ax.add_collection(self.dividers)\n471 \n472         self.locator = None\n473         self.minorlocator = None\n474         self.formatter = None\n475         self.__scale = None  # linear, log10 for now.  Hopefully more?\n476 \n477         if ticklocation == 'auto':\n478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'\n479         self.ticklocation = ticklocation\n480 \n481         self.set_label(label)\n482         self._reset_locator_formatter_scale()\n483 \n484         if np.iterable(ticks):\n485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n486         else:\n487             self.locator = ticks    # Handle default in _ticker()\n488 \n489         if isinstance(format, str):\n490             self.formatter = ticker.FormatStrFormatter(format)\n491         else:\n492             self.formatter = format  # Assume it is a Formatter or None\n493         self.draw_all()\n494 \n495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:\n496             self.add_lines(mappable)\n497 \n498         # Link the Axes and Colorbar for interactive use\n499         self.ax._colorbar = self\n500         # Don't navigate on any of these types of mappables\n501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or\n502                 isinstance(self.mappable, contour.ContourSet)):\n503             self.ax.set_navigate(False)\n504 \n505         # These are the functions that set up interactivity on this colorbar\n506         self._interactive_funcs = [\"_get_view\", \"_set_view\",\n507                                    \"_set_view_from_bbox\", \"drag_pan\"]\n508         for x in self._interactive_funcs:\n509             setattr(self.ax, x, getattr(self, x))\n510         # Set the cla function to the cbar's method to override it\n511         self.ax.cla = self._cbar_cla\n512 \n513     def _cbar_cla(self):\n514         \"\"\"Function to clear the interactive colorbar state.\"\"\"\n515         for x in self._interactive_funcs:\n516             delattr(self.ax, x)\n517         # We now restore the old cla() back and can call it directly\n518         del self.ax.cla\n519         self.ax.cla()\n520 \n521     # Also remove ._patch after deprecation elapses.\n522     patch = _api.deprecate_privatize_attribute(\"3.5\", alternative=\"ax\")\n523 \n524     def update_normal(self, mappable):\n525         \"\"\"\n526         Update solid patches, lines, etc.\n527 \n528         This is meant to be called when the norm of the image or contour plot\n529         to which this colorbar belongs changes.\n530 \n531         If the norm on the mappable is different than before, this resets the\n532         locator and formatter for the axis, so if these have been customized,\n533         they will need to be customized again.  However, if the norm only\n534         changes values of *vmin*, *vmax* or *cmap* then the old formatter\n535         and locator will be preserved.\n536         \"\"\"\n537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n538         self.mappable = mappable\n539         self.set_alpha(mappable.get_alpha())\n540         self.cmap = mappable.cmap\n541         if mappable.norm != self.norm:\n542             self.norm = mappable.norm\n543             self._reset_locator_formatter_scale()\n544 \n545         self.draw_all()\n546         if isinstance(self.mappable, contour.ContourSet):\n547             CS = self.mappable\n548             if not CS.filled:\n549                 self.add_lines(CS)\n550         self.stale = True\n551 \n552     def draw_all(self):\n553         \"\"\"\n554         Calculate any free parameters based on the current cmap and norm,\n555         and do all the drawing.\n556         \"\"\"\n557         if self.orientation == 'vertical':\n558             if mpl.rcParams['ytick.minor.visible']:\n559                 self.minorticks_on()\n560         else:\n561             if mpl.rcParams['xtick.minor.visible']:\n562                 self.minorticks_on()\n563         self._long_axis().set(label_position=self.ticklocation,\n564                               ticks_position=self.ticklocation)\n565         self._short_axis().set_ticks([])\n566         self._short_axis().set_ticks([], minor=True)\n567 \n568         # Set self._boundaries and self._values, including extensions.\n569         # self._boundaries are the edges of each square of color, and\n570         # self._values are the value to map into the norm to get the\n571         # color:\n572         self._process_values()\n573         # Set self.vmin and self.vmax to first and last boundary, excluding\n574         # extensions:\n575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]\n576         # Compute the X/Y mesh.\n577         X, Y, extendlen = self._mesh()\n578         # draw the extend triangles, and shrink the inner axes to accommodate.\n579         # also adds the outline path to self.outline spine:\n580         self._do_extends(extendlen)\n581 \n582         if self.orientation == 'vertical':\n583             self.ax.set_xlim(0, 1)\n584             self.ax.set_ylim(self.vmin, self.vmax)\n585         else:\n586             self.ax.set_ylim(0, 1)\n587             self.ax.set_xlim(self.vmin, self.vmax)\n588 \n589         # set up the tick locators and formatters.  A bit complicated because\n590         # boundary norms + uniform spacing requires a manual locator.\n591         self.update_ticks()\n592 \n593         if self.filled:\n594             ind = np.arange(len(self._values))\n595             if self._extend_lower():\n596                 ind = ind[1:]\n597             if self._extend_upper():\n598                 ind = ind[:-1]\n599             self._add_solids(X, Y, self._values[ind, np.newaxis])\n600 \n601     def _add_solids(self, X, Y, C):\n602         \"\"\"Draw the colors; optionally add separators.\"\"\"\n603         # Cleanup previously set artists.\n604         if self.solids is not None:\n605             self.solids.remove()\n606         for solid in self.solids_patches:\n607             solid.remove()\n608         # Add new artist(s), based on mappable type.  Use individual patches if\n609         # hatching is needed, pcolormesh otherwise.\n610         mappable = getattr(self, 'mappable', None)\n611         if (isinstance(mappable, contour.ContourSet)\n612                 and any(hatch is not None for hatch in mappable.hatches)):\n613             self._add_solids_patches(X, Y, C, mappable)\n614         else:\n615             self.solids = self.ax.pcolormesh(\n616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,\n617                 edgecolors='none', shading='flat')\n618             if not self.drawedges:\n619                 if len(self._y) >= self.n_rasterize:\n620                     self.solids.set_rasterized(True)\n621         self.dividers.set_segments(\n622             np.dstack([X, Y])[1:-1] if self.drawedges else [])\n623 \n624     def _add_solids_patches(self, X, Y, C, mappable):\n625         hatches = mappable.hatches * len(C)  # Have enough hatches.\n626         patches = []\n627         for i in range(len(X) - 1):\n628             xy = np.array([[X[i, 0], Y[i, 0]],\n629                            [X[i, 1], Y[i, 0]],\n630                            [X[i + 1, 1], Y[i + 1, 0]],\n631                            [X[i + 1, 0], Y[i + 1, 1]]])\n632             patch = mpatches.PathPatch(mpath.Path(xy),\n633                                        facecolor=self.cmap(self.norm(C[i][0])),\n634                                        hatch=hatches[i], linewidth=0,\n635                                        antialiased=False, alpha=self.alpha)\n636             self.ax.add_patch(patch)\n637             patches.append(patch)\n638         self.solids_patches = patches\n639 \n640     def _do_extends(self, extendlen):\n641         \"\"\"\n642         Add the extend tri/rectangles on the outside of the axes.\n643         \"\"\"\n644         # extend lengths are fraction of the *inner* part of colorbar,\n645         # not the total colorbar:\n646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)\n647         top = 1 + (extendlen[1] if self._extend_upper() else 0)\n648 \n649         # xyout is the outline of the colorbar including the extend patches:\n650         if not self.extendrect:\n651             # triangle:\n652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],\n653                               [1, 1], [0.5, top], [0, 1], [0, 0]])\n654         else:\n655             # rectangle:\n656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],\n657                               [1, 1], [1, top], [0, top], [0, 1],\n658                               [0, 0]])\n659 \n660         if self.orientation == 'horizontal':\n661             xyout = xyout[:, ::-1]\n662 \n663         # xyout is the path for the spine:\n664         self.outline.set_xy(xyout)\n665         if not self.filled:\n666             return\n667 \n668         # Make extend triangles or rectangles filled patches.  These are\n669         # defined in the outer parent axes' coordinates:\n670         mappable = getattr(self, 'mappable', None)\n671         if (isinstance(mappable, contour.ContourSet)\n672                 and any(hatch is not None for hatch in mappable.hatches)):\n673             hatches = mappable.hatches\n674         else:\n675             hatches = [None]\n676 \n677         if self._extend_lower():\n678             if not self.extendrect:\n679                 # triangle\n680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])\n681             else:\n682                 # rectangle\n683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])\n684             if self.orientation == 'horizontal':\n685                 xy = xy[:, ::-1]\n686             # add the patch\n687             color = self.cmap(self.norm(self._values[0]))\n688             patch = mpatches.PathPatch(\n689                 mpath.Path(xy), facecolor=color, linewidth=0,\n690                 antialiased=False, transform=self.ax.transAxes,\n691                 hatch=hatches[0], clip_on=False)\n692             self.ax.add_patch(patch)\n693         if self._extend_upper():\n694             if not self.extendrect:\n695                 # triangle\n696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])\n697             else:\n698                 # rectangle\n699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])\n700             if self.orientation == 'horizontal':\n701                 xy = xy[:, ::-1]\n702             # add the patch\n703             color = self.cmap(self.norm(self._values[-1]))\n704             patch = mpatches.PathPatch(\n705                 mpath.Path(xy), facecolor=color,\n706                 linewidth=0, antialiased=False,\n707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)\n708             self.ax.add_patch(patch)\n709         return\n710 \n711     def add_lines(self, *args, **kwargs):\n712         \"\"\"\n713         Draw lines on the colorbar.\n714 \n715         The lines are appended to the list :attr:`lines`.\n716 \n717         Parameters\n718         ----------\n719         levels : array-like\n720             The positions of the lines.\n721         colors : color or list of colors\n722             Either a single color applying to all lines or one color value for\n723             each line.\n724         linewidths : float or array-like\n725             Either a single linewidth applying to all lines or one linewidth\n726             for each line.\n727         erase : bool, default: True\n728             Whether to remove any previously added lines.\n729 \n730         Notes\n731         -----\n732         Alternatively, this method can also be called with the signature\n733         ``colorbar.add_lines(contour_set, erase=True)``, in which case\n734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.\n735         \"\"\"\n736         params = _api.select_matching_signature(\n737             [lambda self, CS, erase=True: locals(),\n738              lambda self, levels, colors, linewidths, erase=True: locals()],\n739             self, *args, **kwargs)\n740         if \"CS\" in params:\n741             self, CS, erase = params.values()\n742             if not isinstance(CS, contour.ContourSet) or CS.filled:\n743                 raise ValueError(\"If a single artist is passed to add_lines, \"\n744                                  \"it must be a ContourSet of lines\")\n745             # TODO: Make colorbar lines auto-follow changes in contour lines.\n746             return self.add_lines(\n747                 CS.levels,\n748                 [c[0] for c in CS.tcolors],\n749                 [t[0] for t in CS.tlinewidths],\n750                 erase=erase)\n751         else:\n752             self, levels, colors, linewidths, erase = params.values()\n753 \n754         y = self._locate(levels)\n755         rtol = (self._y[-1] - self._y[0]) * 1e-10\n756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)\n757         y = y[igood]\n758         if np.iterable(colors):\n759             colors = np.asarray(colors)[igood]\n760         if np.iterable(linewidths):\n761             linewidths = np.asarray(linewidths)[igood]\n762         X, Y = np.meshgrid([0, 1], y)\n763         if self.orientation == 'vertical':\n764             xy = np.stack([X, Y], axis=-1)\n765         else:\n766             xy = np.stack([Y, X], axis=-1)\n767         col = collections.LineCollection(xy, linewidths=linewidths,\n768                                          colors=colors)\n769 \n770         if erase and self.lines:\n771             for lc in self.lines:\n772                 lc.remove()\n773             self.lines = []\n774         self.lines.append(col)\n775 \n776         # make a clip path that is just a linewidth bigger than the axes...\n777         fac = np.max(linewidths) / 72\n778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])\n779         inches = self.ax.get_figure().dpi_scale_trans\n780         # do in inches:\n781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))\n782         xy[[0, 1, 4], 1] -= fac\n783         xy[[2, 3], 1] += fac\n784         # back to axes units...\n785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))\n786         if self.orientation == 'horizontal':\n787             xy = xy.T\n788         col.set_clip_path(mpath.Path(xy, closed=True),\n789                           self.ax.transAxes)\n790         self.ax.add_collection(col)\n791         self.stale = True\n792 \n793     def update_ticks(self):\n794         \"\"\"\n795         Setup the ticks and ticklabels. This should not be needed by users.\n796         \"\"\"\n797         # Get the locator and formatter; defaults to self.locator if not None.\n798         self._get_ticker_locator_formatter()\n799         self._long_axis().set_major_locator(self.locator)\n800         self._long_axis().set_minor_locator(self.minorlocator)\n801         self._long_axis().set_major_formatter(self.formatter)\n802 \n803     def _get_ticker_locator_formatter(self):\n804         \"\"\"\n805         Return the ``locator`` and ``formatter`` of the colorbar.\n806 \n807         If they have not been defined (i.e. are *None*), the formatter and\n808         locator are retrieved from the axis, or from the value of the\n809         boundaries for a boundary norm.\n810 \n811         Called by update_ticks...\n812         \"\"\"\n813         locator = self.locator\n814         formatter = self.formatter\n815         minorlocator = self.minorlocator\n816         if isinstance(self.norm, colors.BoundaryNorm):\n817             b = self.norm.boundaries\n818             if locator is None:\n819                 locator = ticker.FixedLocator(b, nbins=10)\n820         elif self.boundaries is not None:\n821             b = self._boundaries[self._inside]\n822             if locator is None:\n823                 locator = ticker.FixedLocator(b, nbins=10)\n824         else:  # most cases:\n825             if locator is None:\n826                 # we haven't set the locator explicitly, so use the default\n827                 # for this axis:\n828                 locator = self._long_axis().get_major_locator()\n829             if minorlocator is None:\n830                 minorlocator = self._long_axis().get_minor_locator()\n831             if isinstance(self.norm, colors.NoNorm):\n832                 # default locator:\n833                 nv = len(self._values)\n834                 base = 1 + int(nv / 10)\n835                 locator = ticker.IndexLocator(base=base, offset=0)\n836 \n837         if minorlocator is None:\n838             minorlocator = ticker.NullLocator()\n839 \n840         if formatter is None:\n841             formatter = self._long_axis().get_major_formatter()\n842 \n843         self.locator = locator\n844         self.formatter = formatter\n845         self.minorlocator = minorlocator\n846         _log.debug('locator: %r', locator)\n847 \n848     @_api.delete_parameter(\"3.5\", \"update_ticks\")\n849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,\n850                   minor=False, **kwargs):\n851         \"\"\"\n852         Set tick locations.\n853 \n854         Parameters\n855         ----------\n856         ticks : list of floats\n857             List of tick locations.\n858         labels : list of str, optional\n859             List of tick labels. If not set, the labels show the data value.\n860         minor : bool, default: False\n861             If ``False``, set the major ticks; if ``True``, the minor ticks.\n862         **kwargs\n863             `.Text` properties for the labels. These take effect only if you\n864             pass *labels*. In other cases, please use `~.Axes.tick_params`.\n865         \"\"\"\n866         if np.iterable(ticks):\n867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,\n868                                         **kwargs)\n869             self.locator = self._long_axis().get_major_locator()\n870         else:\n871             self.locator = ticks\n872             self._long_axis().set_major_locator(self.locator)\n873         self.stale = True\n874 \n875     def get_ticks(self, minor=False):\n876         \"\"\"\n877         Return the ticks as a list of locations.\n878 \n879         Parameters\n880         ----------\n881         minor : boolean, default: False\n882             if True return the minor ticks.\n883         \"\"\"\n884         if minor:\n885             return self._long_axis().get_minorticklocs()\n886         else:\n887             return self._long_axis().get_majorticklocs()\n888 \n889     @_api.delete_parameter(\"3.5\", \"update_ticks\")\n890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,\n891                        **kwargs):\n892         \"\"\"\n893         Set tick labels.\n894 \n895         .. admonition:: Discouraged\n896 \n897             The use of this method is discouraged, because of the dependency\n898             on tick positions. In most cases, you'll want to use\n899             ``set_ticks(positions, labels=labels)`` instead.\n900 \n901             If you are using this method, you should always fix the tick\n902             positions before, e.g. by using `.Colorbar.set_ticks` or by\n903             explicitly setting a `~.ticker.FixedLocator` on the long axis\n904             of the colorbar. Otherwise, ticks are free to move and the\n905             labels may end up in unexpected positions.\n906 \n907         Parameters\n908         ----------\n909         ticklabels : sequence of str or of `.Text`\n910             Texts for labeling each tick location in the sequence set by\n911             `.Colorbar.set_ticks`; the number of labels must match the number\n912             of locations.\n913 \n914         update_ticks : bool, default: True\n915             This keyword argument is ignored and will be be removed.\n916             Deprecated\n917 \n918          minor : bool\n919             If True, set minor ticks instead of major ticks.\n920 \n921         **kwargs\n922             `.Text` properties for the labels.\n923         \"\"\"\n924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)\n925 \n926     def minorticks_on(self):\n927         \"\"\"\n928         Turn on colorbar minor ticks.\n929         \"\"\"\n930         self.ax.minorticks_on()\n931         self.minorlocator = self._long_axis().get_minor_locator()\n932         self._short_axis().set_minor_locator(ticker.NullLocator())\n933 \n934     def minorticks_off(self):\n935         \"\"\"Turn the minor ticks of the colorbar off.\"\"\"\n936         self.minorlocator = ticker.NullLocator()\n937         self._long_axis().set_minor_locator(self.minorlocator)\n938 \n939     def set_label(self, label, *, loc=None, **kwargs):\n940         \"\"\"\n941         Add a label to the long axis of the colorbar.\n942 \n943         Parameters\n944         ----------\n945         label : str\n946             The label text.\n947         loc : str, optional\n948             The location of the label.\n949 \n950             - For horizontal orientation one of {'left', 'center', 'right'}\n951             - For vertical orientation one of {'bottom', 'center', 'top'}\n952 \n953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`\n954             depending on the orientation.\n955         **kwargs\n956             Keyword arguments are passed to `~.Axes.set_xlabel` /\n957             `~.Axes.set_ylabel`.\n958             Supported keywords are *labelpad* and `.Text` properties.\n959         \"\"\"\n960         if self.orientation == \"vertical\":\n961             self.ax.set_ylabel(label, loc=loc, **kwargs)\n962         else:\n963             self.ax.set_xlabel(label, loc=loc, **kwargs)\n964         self.stale = True\n965 \n966     def set_alpha(self, alpha):\n967         \"\"\"\n968         Set the transparency between 0 (transparent) and 1 (opaque).\n969 \n970         If an array is provided, *alpha* will be set to None to use the\n971         transparency values associated with the colormap.\n972         \"\"\"\n973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha\n974 \n975     def _set_scale(self, scale, **kwargs):\n976         \"\"\"\n977         Set the colorbar long axis scale.\n978 \n979         Parameters\n980         ----------\n981         value : {\"linear\", \"log\", \"symlog\", \"logit\", ...} or `.ScaleBase`\n982             The axis scale type to apply.\n983 \n984         **kwargs\n985             Different keyword arguments are accepted, depending on the scale.\n986             See the respective class keyword arguments:\n987 \n988             - `matplotlib.scale.LinearScale`\n989             - `matplotlib.scale.LogScale`\n990             - `matplotlib.scale.SymmetricalLogScale`\n991             - `matplotlib.scale.LogitScale`\n992             - `matplotlib.scale.FuncScale`\n993 \n994         Notes\n995         -----\n996         By default, Matplotlib supports the above mentioned scales.\n997         Additionally, custom scales may be registered using\n998         `matplotlib.scale.register_scale`. These scales can then also\n999         be used here.\n1000         \"\"\"\n1001         if self.orientation == 'vertical':\n1002             self.ax.set_yscale(scale, **kwargs)\n1003         else:\n1004             self.ax.set_xscale(scale, **kwargs)\n1005         if isinstance(scale, mscale.ScaleBase):\n1006             self.__scale = scale.name\n1007         else:\n1008             self.__scale = scale\n1009 \n1010     def remove(self):\n1011         \"\"\"\n1012         Remove this colorbar from the figure.\n1013 \n1014         If the colorbar was created with ``use_gridspec=True`` the previous\n1015         gridspec is restored.\n1016         \"\"\"\n1017         if hasattr(self.ax, '_colorbar_info'):\n1018             parents = self.ax._colorbar_info['parents']\n1019             for a in parents:\n1020                 if self.ax in a._colorbars:\n1021                     a._colorbars.remove(self.ax)\n1022 \n1023         self.ax.remove()\n1024 \n1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)\n1026         self.mappable.colorbar = None\n1027         self.mappable.colorbar_cid = None\n1028 \n1029         try:\n1030             ax = self.mappable.axes\n1031         except AttributeError:\n1032             return\n1033         try:\n1034             gs = ax.get_subplotspec().get_gridspec()\n1035             subplotspec = gs.get_topmost_subplotspec()\n1036         except AttributeError:\n1037             # use_gridspec was False\n1038             pos = ax.get_position(original=True)\n1039             ax._set_position(pos)\n1040         else:\n1041             # use_gridspec was True\n1042             ax.set_subplotspec(subplotspec)\n1043 \n1044     def _ticker(self, locator, formatter):\n1045         \"\"\"\n1046         Return the sequence of ticks (colorbar data locations),\n1047         ticklabels (strings), and the corresponding offset string.\n1048         \"\"\"\n1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:\n1050             intv = self._values[0], self._values[-1]\n1051         else:\n1052             intv = self.vmin, self.vmax\n1053         locator.create_dummy_axis(minpos=intv[0])\n1054         locator.axis.set_view_interval(*intv)\n1055         locator.axis.set_data_interval(*intv)\n1056         formatter.set_axis(locator.axis)\n1057 \n1058         b = np.array(locator())\n1059         if isinstance(locator, ticker.LogLocator):\n1060             eps = 1e-10\n1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]\n1062         else:\n1063             eps = (intv[1] - intv[0]) * 1e-10\n1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]\n1065         ticks = self._locate(b)\n1066         ticklabels = formatter.format_ticks(b)\n1067         offset_string = formatter.get_offset()\n1068         return ticks, ticklabels, offset_string\n1069 \n1070     def _process_values(self):\n1071         \"\"\"\n1072         Set `_boundaries` and `_values` based on the self.boundaries and\n1073         self.values if not None, or based on the size of the colormap and\n1074         the vmin/vmax of the norm.\n1075         \"\"\"\n1076         if self.values is not None:\n1077             # set self._boundaries from the values...\n1078             self._values = np.array(self.values)\n1079             if self.boundaries is None:\n1080                 # bracket values by 1/2 dv:\n1081                 b = np.zeros(len(self.values) + 1)\n1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])\n1083                 b[0] = 2.0 * b[1] - b[2]\n1084                 b[-1] = 2.0 * b[-2] - b[-3]\n1085                 self._boundaries = b\n1086                 return\n1087             self._boundaries = np.array(self.boundaries)\n1088             return\n1089 \n1090         # otherwise values are set from the boundaries\n1091         if isinstance(self.norm, colors.BoundaryNorm):\n1092             b = self.norm.boundaries\n1093         else:\n1094             # otherwise make the boundaries from the size of the cmap:\n1095             N = self.cmap.N + 1\n1096             b, _ = self._uniform_y(N)\n1097         # add extra boundaries if needed:\n1098         if self._extend_lower():\n1099             b = np.hstack((b[0] - 1, b))\n1100         if self._extend_upper():\n1101             b = np.hstack((b, b[-1] + 1))\n1102 \n1103         # transform from 0-1 to vmin-vmax:\n1104         if not self.norm.scaled():\n1105             self.norm.vmin = 0\n1106             self.norm.vmax = 1\n1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n1108             self.norm.vmin, self.norm.vmax, expander=0.1)\n1109         if not isinstance(self.norm, colors.BoundaryNorm):\n1110             b = self.norm.inverse(b)\n1111 \n1112         self._boundaries = np.asarray(b, dtype=float)\n1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])\n1114         if isinstance(self.norm, colors.NoNorm):\n1115             self._values = (self._values + 0.00001).astype(np.int16)\n1116 \n1117     def _mesh(self):\n1118         \"\"\"\n1119         Return the coordinate arrays for the colorbar pcolormesh/patches.\n1120 \n1121         These are scaled between vmin and vmax, and already handle colorbar\n1122         orientation.\n1123         \"\"\"\n1124         # copy the norm and change the vmin and vmax to the vmin and\n1125         # vmax of the colorbar, not the norm.  This allows the situation\n1126         # where the colormap has a narrower range than the colorbar, to\n1127         # accommodate extra contours:\n1128         norm = copy.deepcopy(self.norm)\n1129         norm.vmin = self.vmin\n1130         norm.vmax = self.vmax\n1131         y, extendlen = self._proportional_y()\n1132         # invert:\n1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):\n1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.\n1135         else:\n1136             y = norm.inverse(y)\n1137         self._y = y\n1138         X, Y = np.meshgrid([0., 1.], y)\n1139         if self.orientation == 'vertical':\n1140             return (X, Y, extendlen)\n1141         else:\n1142             return (Y, X, extendlen)\n1143 \n1144     def _forward_boundaries(self, x):\n1145         b = self._boundaries\n1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))\n1147         eps = (b[-1] - b[0]) * 1e-6\n1148         y[x < b[0]-eps] = -1\n1149         y[x > b[-1]+eps] = 2\n1150         return y\n1151 \n1152     def _inverse_boundaries(self, x):\n1153         b = self._boundaries\n1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)\n1155 \n1156     def _reset_locator_formatter_scale(self):\n1157         \"\"\"\n1158         Reset the locator et al to defaults.  Any user-hardcoded changes\n1159         need to be re-entered if this gets called (either at init, or when\n1160         the mappable normal gets changed: Colorbar.update_normal)\n1161         \"\"\"\n1162         self._process_values()\n1163         self.locator = None\n1164         self.minorlocator = None\n1165         self.formatter = None\n1166         if (self.boundaries is not None or\n1167                 isinstance(self.norm, colors.BoundaryNorm)):\n1168             if self.spacing == 'uniform':\n1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)\n1170                 self._set_scale('function', functions=funcs)\n1171             elif self.spacing == 'proportional':\n1172                 self._set_scale('linear')\n1173         elif getattr(self.norm, '_scale', None):\n1174             # use the norm's scale (if it exists and is not None):\n1175             self._set_scale(self.norm._scale)\n1176         elif type(self.norm) is colors.Normalize:\n1177             # plain Normalize:\n1178             self._set_scale('linear')\n1179         else:\n1180             # norm._scale is None or not an attr: derive the scale from\n1181             # the Norm:\n1182             funcs = (self.norm, self.norm.inverse)\n1183             self._set_scale('function', functions=funcs)\n1184 \n1185     def _locate(self, x):\n1186         \"\"\"\n1187         Given a set of color data values, return their\n1188         corresponding colorbar data coordinates.\n1189         \"\"\"\n1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):\n1191             b = self._boundaries\n1192             xn = x\n1193         else:\n1194             # Do calculations using normalized coordinates so\n1195             # as to make the interpolation more accurate.\n1196             b = self.norm(self._boundaries, clip=False).filled()\n1197             xn = self.norm(x, clip=False).filled()\n1198 \n1199         bunique = b[self._inside]\n1200         yunique = self._y\n1201 \n1202         z = np.interp(xn, bunique, yunique)\n1203         return z\n1204 \n1205     # trivial helpers\n1206 \n1207     def _uniform_y(self, N):\n1208         \"\"\"\n1209         Return colorbar data coordinates for *N* uniformly\n1210         spaced boundaries, plus extension lengths if required.\n1211         \"\"\"\n1212         automin = automax = 1. / (N - 1.)\n1213         extendlength = self._get_extension_lengths(self.extendfrac,\n1214                                                    automin, automax,\n1215                                                    default=0.05)\n1216         y = np.linspace(0, 1, N)\n1217         return y, extendlength\n1218 \n1219     def _proportional_y(self):\n1220         \"\"\"\n1221         Return colorbar data coordinates for the boundaries of\n1222         a proportional colorbar, plus extension lengths if required:\n1223         \"\"\"\n1224         if isinstance(self.norm, colors.BoundaryNorm):\n1225             y = (self._boundaries - self._boundaries[self._inside][0])\n1226             y = y / (self._boundaries[self._inside][-1] -\n1227                      self._boundaries[self._inside][0])\n1228             # need yscaled the same as the axes scale to get\n1229             # the extend lengths.\n1230             if self.spacing == 'uniform':\n1231                 yscaled = self._forward_boundaries(self._boundaries)\n1232             else:\n1233                 yscaled = y\n1234         else:\n1235             y = self.norm(self._boundaries.copy())\n1236             y = np.ma.filled(y, np.nan)\n1237             # the norm and the scale should be the same...\n1238             yscaled = y\n1239         y = y[self._inside]\n1240         yscaled = yscaled[self._inside]\n1241         # normalize from 0..1:\n1242         norm = colors.Normalize(y[0], y[-1])\n1243         y = np.ma.filled(norm(y), np.nan)\n1244         norm = colors.Normalize(yscaled[0], yscaled[-1])\n1245         yscaled = np.ma.filled(norm(yscaled), np.nan)\n1246         # make the lower and upper extend lengths proportional to the lengths\n1247         # of the first and last boundary spacing (if extendfrac='auto'):\n1248         automin = yscaled[1] - yscaled[0]\n1249         automax = yscaled[-1] - yscaled[-2]\n1250         extendlength = [0, 0]\n1251         if self._extend_lower() or self._extend_upper():\n1252             extendlength = self._get_extension_lengths(\n1253                     self.extendfrac, automin, automax, default=0.05)\n1254         return y, extendlength\n1255 \n1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):\n1257         \"\"\"\n1258         Return the lengths of colorbar extensions.\n1259 \n1260         This is a helper method for _uniform_y and _proportional_y.\n1261         \"\"\"\n1262         # Set the default value.\n1263         extendlength = np.array([default, default])\n1264         if isinstance(frac, str):\n1265             _api.check_in_list(['auto'], extendfrac=frac.lower())\n1266             # Use the provided values when 'auto' is required.\n1267             extendlength[:] = [automin, automax]\n1268         elif frac is not None:\n1269             try:\n1270                 # Try to set min and max extension fractions directly.\n1271                 extendlength[:] = frac\n1272                 # If frac is a sequence containing None then NaN may\n1273                 # be encountered. This is an error.\n1274                 if np.isnan(extendlength).any():\n1275                     raise ValueError()\n1276             except (TypeError, ValueError) as err:\n1277                 # Raise an error on encountering an invalid value for frac.\n1278                 raise ValueError('invalid value for extendfrac') from err\n1279         return extendlength\n1280 \n1281     def _extend_lower(self):\n1282         \"\"\"Return whether the lower limit is open ended.\"\"\"\n1283         return self.extend in ('both', 'min')\n1284 \n1285     def _extend_upper(self):\n1286         \"\"\"Return whether the upper limit is open ended.\"\"\"\n1287         return self.extend in ('both', 'max')\n1288 \n1289     def _long_axis(self):\n1290         \"\"\"Return the long axis\"\"\"\n1291         if self.orientation == 'vertical':\n1292             return self.ax.yaxis\n1293         return self.ax.xaxis\n1294 \n1295     def _short_axis(self):\n1296         \"\"\"Return the short axis\"\"\"\n1297         if self.orientation == 'vertical':\n1298             return self.ax.xaxis\n1299         return self.ax.yaxis\n1300 \n1301     def _get_view(self):\n1302         # docstring inherited\n1303         # An interactive view for a colorbar is the norm's vmin/vmax\n1304         return self.norm.vmin, self.norm.vmax\n1305 \n1306     def _set_view(self, view):\n1307         # docstring inherited\n1308         # An interactive view for a colorbar is the norm's vmin/vmax\n1309         self.norm.vmin, self.norm.vmax = view\n1310 \n1311     def _set_view_from_bbox(self, bbox, direction='in',\n1312                             mode=None, twinx=False, twiny=False):\n1313         # docstring inherited\n1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax\n1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(\n1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)\n1317         if self.orientation == 'horizontal':\n1318             self.norm.vmin, self.norm.vmax = new_xbound\n1319         elif self.orientation == 'vertical':\n1320             self.norm.vmin, self.norm.vmax = new_ybound\n1321 \n1322     def drag_pan(self, button, key, x, y):\n1323         # docstring inherited\n1324         points = self.ax._get_pan_points(button, key, x, y)\n1325         if points is not None:\n1326             if self.orientation == 'horizontal':\n1327                 self.norm.vmin, self.norm.vmax = points[:, 0]\n1328             elif self.orientation == 'vertical':\n1329                 self.norm.vmin, self.norm.vmax = points[:, 1]\n1330 \n1331 \n1332 ColorbarBase = Colorbar  # Backcompat API\n1333 \n1334 \n1335 def _normalize_location_orientation(location, orientation):\n1336     if location is None:\n1337         location = _api.check_getitem(\n1338             {None: \"right\", \"vertical\": \"right\", \"horizontal\": \"bottom\"},\n1339             orientation=orientation)\n1340     loc_settings = _api.check_getitem({\n1341         \"left\":   {\"location\": \"left\", \"orientation\": \"vertical\",\n1342                    \"anchor\": (1.0, 0.5), \"panchor\": (0.0, 0.5), \"pad\": 0.10},\n1343         \"right\":  {\"location\": \"right\", \"orientation\": \"vertical\",\n1344                    \"anchor\": (0.0, 0.5), \"panchor\": (1.0, 0.5), \"pad\": 0.05},\n1345         \"top\":    {\"location\": \"top\", \"orientation\": \"horizontal\",\n1346                    \"anchor\": (0.5, 0.0), \"panchor\": (0.5, 1.0), \"pad\": 0.05},\n1347         \"bottom\": {\"location\": \"bottom\", \"orientation\": \"horizontal\",\n1348                    \"anchor\": (0.5, 1.0), \"panchor\": (0.5, 0.0), \"pad\": 0.15},\n1349     }, location=location)\n1350     if orientation is not None and orientation != loc_settings[\"orientation\"]:\n1351         # Allow the user to pass both if they are consistent.\n1352         raise TypeError(\"location and orientation are mutually exclusive\")\n1353     return loc_settings\n1354 \n1355 \n1356 @docstring.Substitution(_make_axes_param_doc, _make_axes_other_param_doc)\n1357 def make_axes(parents, location=None, orientation=None, fraction=0.15,\n1358               shrink=1.0, aspect=20, **kwargs):\n1359     \"\"\"\n1360     Create an `~.axes.Axes` suitable for a colorbar.\n1361 \n1362     The axes is placed in the figure of the *parents* axes, by resizing and\n1363     repositioning *parents*.\n1364 \n1365     Parameters\n1366     ----------\n1367     parents : `~.axes.Axes` or list of `~.axes.Axes`\n1368         The Axes to use as parents for placing the colorbar.\n1369     %s\n1370 \n1371     Returns\n1372     -------\n1373     cax : `~.axes.Axes`\n1374         The child axes.\n1375     kwargs : dict\n1376         The reduced keyword dictionary to be passed when creating the colorbar\n1377         instance.\n1378 \n1379     Other Parameters\n1380     ----------------\n1381     %s\n1382     \"\"\"\n1383     loc_settings = _normalize_location_orientation(location, orientation)\n1384     # put appropriate values into the kwargs dict for passing back to\n1385     # the Colorbar class\n1386     kwargs['orientation'] = loc_settings['orientation']\n1387     location = kwargs['ticklocation'] = loc_settings['location']\n1388 \n1389     anchor = kwargs.pop('anchor', loc_settings['anchor'])\n1390     panchor = kwargs.pop('panchor', loc_settings['panchor'])\n1391     aspect0 = aspect\n1392     # turn parents into a list if it is not already. We do this w/ np\n1393     # because `plt.subplots` can return an ndarray and is natural to\n1394     # pass to `colorbar`.\n1395     parents = np.atleast_1d(parents).ravel()\n1396     fig = parents[0].get_figure()\n1397 \n1398     pad0 = 0.05 if fig.get_constrained_layout() else loc_settings['pad']\n1399     pad = kwargs.pop('pad', pad0)\n1400 \n1401     if not all(fig is ax.get_figure() for ax in parents):\n1402         raise ValueError('Unable to create a colorbar axes as not all '\n1403                          'parents share the same figure.')\n1404 \n1405     # take a bounding box around all of the given axes\n1406     parents_bbox = mtransforms.Bbox.union(\n1407         [ax.get_position(original=True).frozen() for ax in parents])\n1408 \n1409     pb = parents_bbox\n1410     if location in ('left', 'right'):\n1411         if location == 'left':\n1412             pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)\n1413         else:\n1414             pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)\n1415         pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)\n1416     else:\n1417         if location == 'bottom':\n1418             pbcb, _, pb1 = pb.splity(fraction, fraction + pad)\n1419         else:\n1420             pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)\n1421         pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)\n1422 \n1423         # define the aspect ratio in terms of y's per x rather than x's per y\n1424         aspect = 1.0 / aspect\n1425 \n1426     # define a transform which takes us from old axes coordinates to\n1427     # new axes coordinates\n1428     shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)\n1429 \n1430     # transform each of the axes in parents using the new transform\n1431     for ax in parents:\n1432         new_posn = shrinking_trans.transform(ax.get_position(original=True))\n1433         new_posn = mtransforms.Bbox(new_posn)\n1434         ax._set_position(new_posn)\n1435         if panchor is not False:\n1436             ax.set_anchor(panchor)\n1437 \n1438     cax = fig.add_axes(pbcb, label=\"<colorbar>\")\n1439     for a in parents:\n1440         # tell the parent it has a colorbar\n1441         a._colorbars += [cax]\n1442     cax._colorbar_info = dict(\n1443         location=location,\n1444         parents=parents,\n1445         shrink=shrink,\n1446         anchor=anchor,\n1447         panchor=panchor,\n1448         fraction=fraction,\n1449         aspect=aspect0,\n1450         pad=pad)\n1451     # and we need to set the aspect ratio by hand...\n1452     cax.set_anchor(anchor)\n1453     cax.set_box_aspect(aspect)\n1454     cax.set_aspect('auto')\n1455 \n1456     return cax, kwargs\n1457 \n1458 \n1459 @docstring.Substitution(_make_axes_param_doc, _make_axes_other_param_doc)\n1460 def make_axes_gridspec(parent, *, location=None, orientation=None,\n1461                        fraction=0.15, shrink=1.0, aspect=20, **kwargs):\n1462     \"\"\"\n1463     Create a `.SubplotBase` suitable for a colorbar.\n1464 \n1465     The axes is placed in the figure of the *parent* axes, by resizing and\n1466     repositioning *parent*.\n1467 \n1468     This function is similar to `.make_axes`. Primary differences are\n1469 \n1470     - `.make_axes_gridspec` should only be used with a `.SubplotBase` parent.\n1471 \n1472     - `.make_axes` creates an `~.axes.Axes`; `.make_axes_gridspec` creates a\n1473       `.SubplotBase`.\n1474 \n1475     - `.make_axes` updates the position of the parent.  `.make_axes_gridspec`\n1476       replaces the ``grid_spec`` attribute of the parent with a new one.\n1477 \n1478     While this function is meant to be compatible with `.make_axes`,\n1479     there could be some minor differences.\n1480 \n1481     Parameters\n1482     ----------\n1483     parent : `~.axes.Axes`\n1484         The Axes to use as parent for placing the colorbar.\n1485     %s\n1486 \n1487     Returns\n1488     -------\n1489     cax : `~.axes.SubplotBase`\n1490         The child axes.\n1491     kwargs : dict\n1492         The reduced keyword dictionary to be passed when creating the colorbar\n1493         instance.\n1494 \n1495     Other Parameters\n1496     ----------------\n1497     %s\n1498     \"\"\"\n1499 \n1500     loc_settings = _normalize_location_orientation(location, orientation)\n1501     kwargs['orientation'] = loc_settings['orientation']\n1502     location = kwargs['ticklocation'] = loc_settings['location']\n1503 \n1504     aspect0 = aspect\n1505     anchor = kwargs.pop('anchor', loc_settings['anchor'])\n1506     panchor = kwargs.pop('panchor', loc_settings['panchor'])\n1507     pad = kwargs.pop('pad', loc_settings[\"pad\"])\n1508     wh_space = 2 * pad / (1 - pad)\n1509 \n1510     if location in ('left', 'right'):\n1511         # for shrinking\n1512         height_ratios = [\n1513                 (1-anchor[1])*(1-shrink), shrink, anchor[1]*(1-shrink)]\n1514 \n1515         if location == 'left':\n1516             gs = parent.get_subplotspec().subgridspec(\n1517                     1, 2, wspace=wh_space,\n1518                     width_ratios=[fraction, 1-fraction-pad])\n1519             ss_main = gs[1]\n1520             ss_cb = gs[0].subgridspec(\n1521                     3, 1, hspace=0, height_ratios=height_ratios)[1]\n1522         else:\n1523             gs = parent.get_subplotspec().subgridspec(\n1524                     1, 2, wspace=wh_space,\n1525                     width_ratios=[1-fraction-pad, fraction])\n1526             ss_main = gs[0]\n1527             ss_cb = gs[1].subgridspec(\n1528                     3, 1, hspace=0, height_ratios=height_ratios)[1]\n1529     else:\n1530         # for shrinking\n1531         width_ratios = [\n1532                 anchor[0]*(1-shrink), shrink, (1-anchor[0])*(1-shrink)]\n1533 \n1534         if location == 'bottom':\n1535             gs = parent.get_subplotspec().subgridspec(\n1536                     2, 1, hspace=wh_space,\n1537                     height_ratios=[1-fraction-pad, fraction])\n1538             ss_main = gs[0]\n1539             ss_cb = gs[1].subgridspec(\n1540                     1, 3, wspace=0, width_ratios=width_ratios)[1]\n1541             aspect = 1 / aspect\n1542         else:\n1543             gs = parent.get_subplotspec().subgridspec(\n1544                     2, 1, hspace=wh_space,\n1545                     height_ratios=[fraction, 1-fraction-pad])\n1546             ss_main = gs[1]\n1547             ss_cb = gs[0].subgridspec(\n1548                     1, 3, wspace=0, width_ratios=width_ratios)[1]\n1549             aspect = 1 / aspect\n1550 \n1551     parent.set_subplotspec(ss_main)\n1552     parent.set_anchor(panchor)\n1553 \n1554     fig = parent.get_figure()\n1555     cax = fig.add_subplot(ss_cb, label=\"<colorbar>\")\n1556     cax.set_anchor(anchor)\n1557     cax.set_box_aspect(aspect)\n1558     cax.set_aspect('auto')\n1559     cax._colorbar_info = dict(\n1560         location=location,\n1561         parents=[parent],\n1562         shrink=shrink,\n1563         anchor=anchor,\n1564         panchor=panchor,\n1565         fraction=fraction,\n1566         aspect=aspect0,\n1567         pad=pad)\n1568     return cax, kwargs\n1569 \n1570 \n1571 @_api.deprecated(\"3.4\", alternative=\"Colorbar\")\n1572 class ColorbarPatch(Colorbar):\n1573     pass\n1574 \n1575 \n1576 @_api.deprecated(\"3.4\", alternative=\"Colorbar\")\n1577 def colorbar_factory(cax, mappable, **kwargs):\n1578     \"\"\"\n1579     Create a colorbar on the given axes for the given mappable.\n1580 \n1581     .. note::\n1582         This is a low-level function to turn an existing axes into a colorbar\n1583         axes.  Typically, you'll want to use `~.Figure.colorbar` instead, which\n1584         automatically handles creation and placement of a suitable axes as\n1585         well.\n1586 \n1587     Parameters\n1588     ----------\n1589     cax : `~matplotlib.axes.Axes`\n1590         The `~.axes.Axes` to turn into a colorbar.\n1591     mappable : `~matplotlib.cm.ScalarMappable`\n1592         The mappable to be described by the colorbar.\n1593     **kwargs\n1594         Keyword arguments are passed to the respective colorbar class.\n1595 \n1596     Returns\n1597     -------\n1598     `.Colorbar`\n1599         The created colorbar instance.\n1600     \"\"\"\n1601     return Colorbar(cax, mappable, **kwargs)\n",
        "intended_behavior": "While not directly a \"bug,\" the current implementation does not clearly support or document the ability for users to pass callable formatters directly to the colorbar's format parameter. With the intended change in how format strings are processed (moving to new-style format strings), it's also an opportunity to align and potentially enhance the documentation or code comments regarding the use of callable formatters in colorbar initialization, ensuring users are aware of this capability and its intended usage aligns with the broader matplotlib formatting logic."
    }
]