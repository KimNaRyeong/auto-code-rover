2025-10-18 13:56:01.388 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 13:56:06.688 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=375, output_tokens=12, cost=0.004110
2025-10-18 13:56:06.689 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 13:56:06.695 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:56:13.218 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=682, output_tokens=261, cost=0.014650
2025-10-18 13:56:13.266 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:56:15.671 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=615, output_tokens=66, cost=0.008130
2025-10-18 13:56:15.673 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("lib/matplotlib/colorbar.py", 489, 5)': old result is ['lib/matplotlib/colorbar.py', '489', '5'], new result  is ['lib/matplotlib/colorbar.py', 489, 5]
2025-10-18 13:56:15.674 | DEBUG    | Extracted a valid json.
2025-10-18 13:56:15.674 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "get_code_around_line(\"lib/matplotlib/colorbar.py\", 489, 5)",
        "search_method_in_file(\"update_ticks\", \"lib/matplotlib/colorbar.py\")",
        "search_method(\"_set_formatter\")"
    ],
    "bug_locations": []
}
2025-10-18 13:56:15.677 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("lib/matplotlib/colorbar.py", 489, 5)': old result is ['lib/matplotlib/colorbar.py', '489', '5'], new result  is ['lib/matplotlib/colorbar.py', 489, 5]
2025-10-18 13:56:15.708 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:56:15.708 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:56:33.402 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2156, output_tokens=742, cost=0.043820
2025-10-18 13:56:33.417 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:56:43.302 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3114, output_tokens=434, cost=0.044160
2025-10-18 13:56:43.311 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:56:51.370 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=788, output_tokens=290, cost=0.016580
2025-10-18 13:56:51.371 | DEBUG    | Extracted a valid json.
2025-10-18 13:56:51.371 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/colorbar.py",
            "class": "Colorbar",
            "method": "__init__",
            "intended_behavior": "Instead of directly initializing a FormatStrFormatter when format is a string, the Colorbar class should adopt a new strategy that is consistent with the handling of format strings in Axis._set_formatter. The __init__ method should either directly use or mirror the logic seen in Axis._set_formatter to support new-style format strings by default. This change ensures that format strings used in colorbars are handled in the same versatile and flexible manner as those in axes, which already support new-style format strings following enhancement #16715."
        },
        {
            "file": "lib/matplotlib/colorbar.py",
            "class": "",
            "method": "",
            "intended_behavior": "While not directly a \"bug,\" the current implementation does not clearly support or document the ability for users to pass callable formatters directly to the colorbar's format parameter. With the intended change in how format strings are processed (moving to new-style format strings), it's also an opportunity to align and potentially enhance the documentation or code comments regarding the use of callable formatters in colorbar initialization, ensuring users are aware of this capability and its intended usage aligns with the broader matplotlib formatting logic."
        }
    ]
}
2025-10-18 13:56:51.382 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>__init__</method>
<code>
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla

</code><intended_behavior>Instead of directly initializing a FormatStrFormatter when format is a string, the Colorbar class should adopt a new strategy that is consistent with the handling of format strings in Axis._set_formatter. The __init__ method should either directly use or mirror the logic seen in Axis._set_formatter to support new-style format strings by default. This change ensures that format strings used in colorbars are handled in the same versatile and flexible manner as those in axes, which already support new-style format strings following enhancement #16715.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>None</method>
<code>
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Colorbars are a visualization of the mapping from scalar values to colors.
3 In Matplotlib they are drawn into a dedicated `~.axes.Axes`.
4 
5 .. note::
6    Colorbars are typically created through `.Figure.colorbar` or its pyplot
7    wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with
8    `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for
9    non-`.GridSpec`-positioned axes).
10 
11    End-users most likely won't need to directly use this module's API.
12 """
13 
14 import copy
15 import logging
16 import textwrap
17 
18 import numpy as np
19 
20 import matplotlib as mpl
21 from matplotlib import _api, collections, cm, colors, contour, ticker
22 import matplotlib.artist as martist
23 import matplotlib.patches as mpatches
24 import matplotlib.path as mpath
25 import matplotlib.scale as mscale
26 import matplotlib.spines as mspines
27 import matplotlib.transforms as mtransforms
28 from matplotlib import docstring
29 
30 _log = logging.getLogger(__name__)
31 
32 _make_axes_param_doc = """
33 location : None or {'left', 'right', 'top', 'bottom'}
34     The location, relative to the parent axes, where the colorbar axes
35     is created.  It also determines the *orientation* of the colorbar
36     (colorbars on the left and right are vertical, colorbars at the top
37     and bottom are horizontal).  If None, the location will come from the
38     *orientation* if it is set (vertical colorbars on the right, horizontal
39     ones at the bottom), or default to 'right' if *orientation* is unset.
40 orientation : None or {'vertical', 'horizontal'}
41     The orientation of the colorbar.  It is preferable to set the *location*
42     of the colorbar, as that also determines the *orientation*; passing
43     incompatible values for *location* and *orientation* raises an exception.
44 fraction : float, default: 0.15
45     Fraction of original axes to use for colorbar.
46 shrink : float, default: 1.0
47     Fraction by which to multiply the size of the colorbar.
48 aspect : float, default: 20
49     Ratio of long to short dimensions.
50 """
51 _make_axes_other_param_doc = """
52 pad : float, default: 0.05 if vertical, 0.15 if horizontal
53     Fraction of original axes between colorbar and new image axes.
54 anchor : (float, float), optional
55     The anchor point of the colorbar axes.
56     Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal.
57 panchor : (float, float), or *False*, optional
58     The anchor point of the colorbar parent axes. If *False*, the parent
59     axes' anchor will be unchanged.
60     Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.
61 """
62 
63 _colormap_kw_doc = """
64 
65     ============  ====================================================
66     Property      Description
67     ============  ====================================================
68     *extend*      {'neither', 'both', 'min', 'max'}
69                   If not 'neither', make pointed end(s) for out-of-
70                   range values.  These are set for a given colormap
71                   using the colormap set_under and set_over methods.
72     *extendfrac*  {*None*, 'auto', length, lengths}
73                   If set to *None*, both the minimum and maximum
74                   triangular colorbar extensions with have a length of
75                   5% of the interior colorbar length (this is the
76                   default setting). If set to 'auto', makes the
77                   triangular colorbar extensions the same lengths as
78                   the interior boxes (when *spacing* is set to
79                   'uniform') or the same lengths as the respective
80                   adjacent interior boxes (when *spacing* is set to
81                   'proportional'). If a scalar, indicates the length
82                   of both the minimum and maximum triangular colorbar
83                   extensions as a fraction of the interior colorbar
84                   length. A two-element sequence of fractions may also
85                   be given, indicating the lengths of the minimum and
86                   maximum colorbar extensions respectively as a
87                   fraction of the interior colorbar length.
88     *extendrect*  bool
89                   If *False* the minimum and maximum colorbar extensions
90                   will be triangular (the default). If *True* the
91                   extensions will be rectangular.
92     *spacing*     {'uniform', 'proportional'}
93                   Uniform spacing gives each discrete color the same
94                   space; proportional makes the space proportional to
95                   the data interval.
96     *ticks*       *None* or list of ticks or Locator
97                   If None, ticks are determined automatically from the
98                   input.
99     *format*      None or str or Formatter
100                   If None, `~.ticker.ScalarFormatter` is used.
101                   If a format string is given, e.g., '%.3f', that is used.
102                   An alternative `~.ticker.Formatter` may be given instead.
103     *drawedges*   bool
104                   Whether to draw lines at color boundaries.
105     *label*       str
106                   The label on the colorbar's long axis.
107     ============  ====================================================
108 
109     The following will probably be useful only in the context of
110     indexed colors (that is, when the mappable has norm=NoNorm()),
111     or other unusual circumstances.
112 
113     ============   ===================================================
114     Property       Description
115     ============   ===================================================
116     *boundaries*   None or a sequence
117     *values*       None or a sequence which must be of length 1 less
118                    than the sequence of *boundaries*. For each region
119                    delimited by adjacent entries in *boundaries*, the
120                    colormapped to the corresponding value in values
121                    will be used.
122     ============   ===================================================
123 
124 """
125 
126 docstring.interpd.update(colorbar_doc="""
127 Add a colorbar to a plot.
128 
129 Parameters
130 ----------
131 mappable
132     The `matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.AxesImage`,
133     `~matplotlib.contour.ContourSet`, etc.) described by this colorbar.
134     This argument is mandatory for the `.Figure.colorbar` method but optional
135     for the `.pyplot.colorbar` function, which sets the default to the current
136     image.
137 
138     Note that one can create a `.ScalarMappable` "on-the-fly" to generate
139     colorbars not attached to a previously drawn artist, e.g. ::
140 
141         fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)
142 
143 cax : `~matplotlib.axes.Axes`, optional
144     Axes into which the colorbar will be drawn.
145 
146 ax : `~matplotlib.axes.Axes`, list of Axes, optional
147     One or more parent axes from which space for a new colorbar axes will be
148     stolen, if *cax* is None.  This has no effect if *cax* is set.
149 
150 use_gridspec : bool, optional
151     If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If
152     *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is
153     created as an instance of Subplot using the :mod:`.gridspec` module.
154 
155 Returns
156 -------
157 colorbar : `~matplotlib.colorbar.Colorbar`
158 
159 Notes
160 -----
161 Additional keyword arguments are of two kinds:
162 
163   axes properties:
164 %s
165 %s
166   colorbar properties:
167 %s
168 
169 If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is included
170 automatically.
171 
172 The *shrink* kwarg provides a simple way to scale the colorbar with respect
173 to the axes. Note that if *cax* is specified, it determines the size of the
174 colorbar and *shrink* and *aspect* kwargs are ignored.
175 
176 For more precise control, you can manually specify the positions of
177 the axes objects in which the mappable and the colorbar are drawn.  In
178 this case, do not use any of the axes properties kwargs.
179 
180 It is known that some vector graphics viewers (svg and pdf) renders white gaps
181 between segments of the colorbar.  This is due to bugs in the viewers, not
182 Matplotlib.  As a workaround, the colorbar can be rendered with overlapping
183 segments::
184 
185     cbar = colorbar()
186     cbar.solids.set_edgecolor("face")
187     draw()
188 
189 However this has negative consequences in other circumstances, e.g. with
190 semi-transparent images (alpha < 1) and colorbar extensions; therefore, this
191 workaround is not used by default (see issue #1188).
192 """ % (textwrap.indent(_make_axes_param_doc, "    "),
193        textwrap.indent(_make_axes_other_param_doc, "    "),
194        _colormap_kw_doc))
195 
196 
197 @_api.caching_module_getattr  # module-level deprecations
198 class __getattr__:
199     colorbar_doc = _api.deprecated("3.4", obj_type="")(property(
200         lambda self: docstring.interpd.params["colorbar_doc"]))
201     colorbar_kw_doc = _api.deprecated("3.4", obj_type="")(property(
202         lambda self: _colormap_kw_doc))
203     make_axes_kw_doc = _api.deprecated("3.4", obj_type="")(property(
204         lambda self: _make_axes_param_doc + _make_axes_other_param_doc))
205 
206 
207 def _set_ticks_on_axis_warn(*args, **kwargs):
208     # a top level function which gets put in at the axes'
209     # set_xticks and set_yticks by Colorbar.__init__.
210     _api.warn_external("Use the colorbar set_ticks() method instead.")
211 
212 
213 class _ColorbarSpine(mspines.Spine):
214     def __init__(self, axes):
215         self._ax = axes
216         super().__init__(axes, 'colorbar',
217                          mpath.Path(np.empty((0, 2)), closed=True))
218         mpatches.Patch.set_transform(self, axes.transAxes)
219 
220     def get_window_extent(self, renderer=None):
221         # This Spine has no Axis associated with it, and doesn't need to adjust
222         # its location, so we can directly get the window extent from the
223         # super-super-class.
224         return mpatches.Patch.get_window_extent(self, renderer=renderer)
225 
226     def set_xy(self, xy):
227         self._path = mpath.Path(xy, closed=True)
228         self._xy = xy
229         self.stale = True
230 
231     def draw(self, renderer):
232         ret = mpatches.Patch.draw(self, renderer)
233         self.stale = False
234         return ret
235 
236 
237 class _ColorbarAxesLocator:
238     """
239     Shrink the axes if there are triangular or rectangular extends.
240     """
241     def __init__(self, cbar):
242         self._cbar = cbar
243         self._orig_locator = cbar.ax._axes_locator
244 
245     def __call__(self, ax, renderer):
246         if self._orig_locator is not None:
247             pos = self._orig_locator(ax, renderer)
248         else:
249             pos = ax.get_position(original=True)
250         if self._cbar.extend == 'neither':
251             return pos
252 
253         y, extendlen = self._cbar._proportional_y()
254         if not self._cbar._extend_lower():
255             extendlen[0] = 0
256         if not self._cbar._extend_upper():
257             extendlen[1] = 0
258         len = sum(extendlen) + 1
259         shrink = 1 / len
260         offset = extendlen[0] / len
261         # we need to reset the aspect ratio of the axes to account
262         # of the extends...
263         if hasattr(ax, '_colorbar_info'):
264             aspect = ax._colorbar_info['aspect']
265         else:
266             aspect = False
267         # now shrink and/or offset to take into account the
268         # extend tri/rectangles.
269         if self._cbar.orientation == 'vertical':
270             if aspect:
271                 self._cbar.ax.set_box_aspect(aspect*shrink)
272             pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)
273         else:
274             if aspect:
275                 self._cbar.ax.set_box_aspect(1/(aspect * shrink))
276             pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)
277         return pos
278 
279     def get_subplotspec(self):
280         # make tight_layout happy..
281         ss = getattr(self._cbar.ax, 'get_subplotspec', None)
282         if ss is None:
283             ss = self._orig_locator.get_subplotspec()
284         else:
285             ss = ss()
286         return ss
287 
288 
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]
1330 
1331 
1332 ColorbarBase = Colorbar  # Backcompat API
1333 
1334 
1335 def _normalize_location_orientation(location, orientation):
1336     if location is None:
1337         location = _api.check_getitem(
1338             {None: "right", "vertical": "right", "horizontal": "bottom"},
1339             orientation=orientation)
1340     loc_settings = _api.check_getitem({
1341         "left":   {"location": "left", "orientation": "vertical",
1342                    "anchor": (1.0, 0.5), "panchor": (0.0, 0.5), "pad": 0.10},
1343         "right":  {"location": "right", "orientation": "vertical",
1344                    "anchor": (0.0, 0.5), "panchor": (1.0, 0.5), "pad": 0.05},
1345         "top":    {"location": "top", "orientation": "horizontal",
1346                    "anchor": (0.5, 0.0), "panchor": (0.5, 1.0), "pad": 0.05},
1347         "bottom": {"location": "bottom", "orientation": "horizontal",
1348                    "anchor": (0.5, 1.0), "panchor": (0.5, 0.0), "pad": 0.15},
1349     }, location=location)
1350     if orientation is not None and orientation != loc_settings["orientation"]:
1351         # Allow the user to pass both if they are consistent.
1352         raise TypeError("location and orientation are mutually exclusive")
1353     return loc_settings
1354 
1355 
1356 @docstring.Substitution(_make_axes_param_doc, _make_axes_other_param_doc)
1357 def make_axes(parents, location=None, orientation=None, fraction=0.15,
1358               shrink=1.0, aspect=20, **kwargs):
1359     """
1360     Create an `~.axes.Axes` suitable for a colorbar.
1361 
1362     The axes is placed in the figure of the *parents* axes, by resizing and
1363     repositioning *parents*.
1364 
1365     Parameters
1366     ----------
1367     parents : `~.axes.Axes` or list of `~.axes.Axes`
1368         The Axes to use as parents for placing the colorbar.
1369     %s
1370 
1371     Returns
1372     -------
1373     cax : `~.axes.Axes`
1374         The child axes.
1375     kwargs : dict
1376         The reduced keyword dictionary to be passed when creating the colorbar
1377         instance.
1378 
1379     Other Parameters
1380     ----------------
1381     %s
1382     """
1383     loc_settings = _normalize_location_orientation(location, orientation)
1384     # put appropriate values into the kwargs dict for passing back to
1385     # the Colorbar class
1386     kwargs['orientation'] = loc_settings['orientation']
1387     location = kwargs['ticklocation'] = loc_settings['location']
1388 
1389     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1390     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1391     aspect0 = aspect
1392     # turn parents into a list if it is not already. We do this w/ np
1393     # because `plt.subplots` can return an ndarray and is natural to
1394     # pass to `colorbar`.
1395     parents = np.atleast_1d(parents).ravel()
1396     fig = parents[0].get_figure()
1397 
1398     pad0 = 0.05 if fig.get_constrained_layout() else loc_settings['pad']
1399     pad = kwargs.pop('pad', pad0)
1400 
1401     if not all(fig is ax.get_figure() for ax in parents):
1402         raise ValueError('Unable to create a colorbar axes as not all '
1403                          'parents share the same figure.')
1404 
1405     # take a bounding box around all of the given axes
1406     parents_bbox = mtransforms.Bbox.union(
1407         [ax.get_position(original=True).frozen() for ax in parents])
1408 
1409     pb = parents_bbox
1410     if location in ('left', 'right'):
1411         if location == 'left':
1412             pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)
1413         else:
1414             pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)
1415         pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)
1416     else:
1417         if location == 'bottom':
1418             pbcb, _, pb1 = pb.splity(fraction, fraction + pad)
1419         else:
1420             pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)
1421         pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)
1422 
1423         # define the aspect ratio in terms of y's per x rather than x's per y
1424         aspect = 1.0 / aspect
1425 
1426     # define a transform which takes us from old axes coordinates to
1427     # new axes coordinates
1428     shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)
1429 
1430     # transform each of the axes in parents using the new transform
1431     for ax in parents:
1432         new_posn = shrinking_trans.transform(ax.get_position(original=True))
1433         new_posn = mtransforms.Bbox(new_posn)
1434         ax._set_position(new_posn)
1435         if panchor is not False:
1436             ax.set_anchor(panchor)
1437 
1438     cax = fig.add_axes(pbcb, label="<colorbar>")
1439     for a in parents:
1440         # tell the parent it has a colorbar
1441         a._colorbars += [cax]
1442     cax._colorbar_info = dict(
1443         location=location,
1444         parents=parents,
1445         shrink=shrink,
1446         anchor=anchor,
1447         panchor=panchor,
1448         fraction=fraction,
1449         aspect=aspect0,
1450         pad=pad)
1451     # and we need to set the aspect ratio by hand...
1452     cax.set_anchor(anchor)
1453     cax.set_box_aspect(aspect)
1454     cax.set_aspect('auto')
1455 
1456     return cax, kwargs
1457 
1458 
1459 @docstring.Substitution(_make_axes_param_doc, _make_axes_other_param_doc)
1460 def make_axes_gridspec(parent, *, location=None, orientation=None,
1461                        fraction=0.15, shrink=1.0, aspect=20, **kwargs):
1462     """
1463     Create a `.SubplotBase` suitable for a colorbar.
1464 
1465     The axes is placed in the figure of the *parent* axes, by resizing and
1466     repositioning *parent*.
1467 
1468     This function is similar to `.make_axes`. Primary differences are
1469 
1470     - `.make_axes_gridspec` should only be used with a `.SubplotBase` parent.
1471 
1472     - `.make_axes` creates an `~.axes.Axes`; `.make_axes_gridspec` creates a
1473       `.SubplotBase`.
1474 
1475     - `.make_axes` updates the position of the parent.  `.make_axes_gridspec`
1476       replaces the ``grid_spec`` attribute of the parent with a new one.
1477 
1478     While this function is meant to be compatible with `.make_axes`,
1479     there could be some minor differences.
1480 
1481     Parameters
1482     ----------
1483     parent : `~.axes.Axes`
1484         The Axes to use as parent for placing the colorbar.
1485     %s
1486 
1487     Returns
1488     -------
1489     cax : `~.axes.SubplotBase`
1490         The child axes.
1491     kwargs : dict
1492         The reduced keyword dictionary to be passed when creating the colorbar
1493         instance.
1494 
1495     Other Parameters
1496     ----------------
1497     %s
1498     """
1499 
1500     loc_settings = _normalize_location_orientation(location, orientation)
1501     kwargs['orientation'] = loc_settings['orientation']
1502     location = kwargs['ticklocation'] = loc_settings['location']
1503 
1504     aspect0 = aspect
1505     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1506     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1507     pad = kwargs.pop('pad', loc_settings["pad"])
1508     wh_space = 2 * pad / (1 - pad)
1509 
1510     if location in ('left', 'right'):
1511         # for shrinking
1512         height_ratios = [
1513                 (1-anchor[1])*(1-shrink), shrink, anchor[1]*(1-shrink)]
1514 
1515         if location == 'left':
1516             gs = parent.get_subplotspec().subgridspec(
1517                     1, 2, wspace=wh_space,
1518                     width_ratios=[fraction, 1-fraction-pad])
1519             ss_main = gs[1]
1520             ss_cb = gs[0].subgridspec(
1521                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1522         else:
1523             gs = parent.get_subplotspec().subgridspec(
1524                     1, 2, wspace=wh_space,
1525                     width_ratios=[1-fraction-pad, fraction])
1526             ss_main = gs[0]
1527             ss_cb = gs[1].subgridspec(
1528                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1529     else:
1530         # for shrinking
1531         width_ratios = [
1532                 anchor[0]*(1-shrink), shrink, (1-anchor[0])*(1-shrink)]
1533 
1534         if location == 'bottom':
1535             gs = parent.get_subplotspec().subgridspec(
1536                     2, 1, hspace=wh_space,
1537                     height_ratios=[1-fraction-pad, fraction])
1538             ss_main = gs[0]
1539             ss_cb = gs[1].subgridspec(
1540                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1541             aspect = 1 / aspect
1542         else:
1543             gs = parent.get_subplotspec().subgridspec(
1544                     2, 1, hspace=wh_space,
1545                     height_ratios=[fraction, 1-fraction-pad])
1546             ss_main = gs[1]
1547             ss_cb = gs[0].subgridspec(
1548                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1549             aspect = 1 / aspect
1550 
1551     parent.set_subplotspec(ss_main)
1552     parent.set_anchor(panchor)
1553 
1554     fig = parent.get_figure()
1555     cax = fig.add_subplot(ss_cb, label="<colorbar>")
1556     cax.set_anchor(anchor)
1557     cax.set_box_aspect(aspect)
1558     cax.set_aspect('auto')
1559     cax._colorbar_info = dict(
1560         location=location,
1561         parents=[parent],
1562         shrink=shrink,
1563         anchor=anchor,
1564         panchor=panchor,
1565         fraction=fraction,
1566         aspect=aspect0,
1567         pad=pad)
1568     return cax, kwargs
1569 
1570 
1571 @_api.deprecated("3.4", alternative="Colorbar")
1572 class ColorbarPatch(Colorbar):
1573     pass
1574 
1575 
1576 @_api.deprecated("3.4", alternative="Colorbar")
1577 def colorbar_factory(cax, mappable, **kwargs):
1578     """
1579     Create a colorbar on the given axes for the given mappable.
1580 
1581     .. note::
1582         This is a low-level function to turn an existing axes into a colorbar
1583         axes.  Typically, you'll want to use `~.Figure.colorbar` instead, which
1584         automatically handles creation and placement of a suitable axes as
1585         well.
1586 
1587     Parameters
1588     ----------
1589     cax : `~matplotlib.axes.Axes`
1590         The `~.axes.Axes` to turn into a colorbar.
1591     mappable : `~matplotlib.cm.ScalarMappable`
1592         The mappable to be described by the colorbar.
1593     **kwargs
1594         Keyword arguments are passed to the respective colorbar class.
1595 
1596     Returns
1597     -------
1598     `.Colorbar`
1599         The created colorbar instance.
1600     """
1601     return Colorbar(cax, mappable, **kwargs)

</code><intended_behavior>While not directly a "bug," the current implementation does not clearly support or document the ability for users to pass callable formatters directly to the colorbar's format parameter. With the intended change in how format strings are processed (moving to new-style format strings), it's also an opportunity to align and potentially enhance the documentation or code comments regarding the use of callable formatters in colorbar initialization, ensuring users are aware of this capability and its intended usage aligns with the broader matplotlib formatting logic.</intended_behavior>]
2025-10-18 13:56:51.383 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>__init__</method>
<code>
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla

</code><intended_behavior>Instead of directly initializing a FormatStrFormatter when format is a string, the Colorbar class should adopt a new strategy that is consistent with the handling of format strings in Axis._set_formatter. The __init__ method should either directly use or mirror the logic seen in Axis._set_formatter to support new-style format strings by default. This change ensures that format strings used in colorbars are handled in the same versatile and flexible manner as those in axes, which already support new-style format strings following enhancement #16715.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>Colorbar</class>
<method>None</method>
<code>
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/colorbar.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Colorbars are a visualization of the mapping from scalar values to colors.
3 In Matplotlib they are drawn into a dedicated `~.axes.Axes`.
4 
5 .. note::
6    Colorbars are typically created through `.Figure.colorbar` or its pyplot
7    wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with
8    `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for
9    non-`.GridSpec`-positioned axes).
10 
11    End-users most likely won't need to directly use this module's API.
12 """
13 
14 import copy
15 import logging
16 import textwrap
17 
18 import numpy as np
19 
20 import matplotlib as mpl
21 from matplotlib import _api, collections, cm, colors, contour, ticker
22 import matplotlib.artist as martist
23 import matplotlib.patches as mpatches
24 import matplotlib.path as mpath
25 import matplotlib.scale as mscale
26 import matplotlib.spines as mspines
27 import matplotlib.transforms as mtransforms
28 from matplotlib import docstring
29 
30 _log = logging.getLogger(__name__)
31 
32 _make_axes_param_doc = """
33 location : None or {'left', 'right', 'top', 'bottom'}
34     The location, relative to the parent axes, where the colorbar axes
35     is created.  It also determines the *orientation* of the colorbar
36     (colorbars on the left and right are vertical, colorbars at the top
37     and bottom are horizontal).  If None, the location will come from the
38     *orientation* if it is set (vertical colorbars on the right, horizontal
39     ones at the bottom), or default to 'right' if *orientation* is unset.
40 orientation : None or {'vertical', 'horizontal'}
41     The orientation of the colorbar.  It is preferable to set the *location*
42     of the colorbar, as that also determines the *orientation*; passing
43     incompatible values for *location* and *orientation* raises an exception.
44 fraction : float, default: 0.15
45     Fraction of original axes to use for colorbar.
46 shrink : float, default: 1.0
47     Fraction by which to multiply the size of the colorbar.
48 aspect : float, default: 20
49     Ratio of long to short dimensions.
50 """
51 _make_axes_other_param_doc = """
52 pad : float, default: 0.05 if vertical, 0.15 if horizontal
53     Fraction of original axes between colorbar and new image axes.
54 anchor : (float, float), optional
55     The anchor point of the colorbar axes.
56     Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal.
57 panchor : (float, float), or *False*, optional
58     The anchor point of the colorbar parent axes. If *False*, the parent
59     axes' anchor will be unchanged.
60     Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.
61 """
62 
63 _colormap_kw_doc = """
64 
65     ============  ====================================================
66     Property      Description
67     ============  ====================================================
68     *extend*      {'neither', 'both', 'min', 'max'}
69                   If not 'neither', make pointed end(s) for out-of-
70                   range values.  These are set for a given colormap
71                   using the colormap set_under and set_over methods.
72     *extendfrac*  {*None*, 'auto', length, lengths}
73                   If set to *None*, both the minimum and maximum
74                   triangular colorbar extensions with have a length of
75                   5% of the interior colorbar length (this is the
76                   default setting). If set to 'auto', makes the
77                   triangular colorbar extensions the same lengths as
78                   the interior boxes (when *spacing* is set to
79                   'uniform') or the same lengths as the respective
80                   adjacent interior boxes (when *spacing* is set to
81                   'proportional'). If a scalar, indicates the length
82                   of both the minimum and maximum triangular colorbar
83                   extensions as a fraction of the interior colorbar
84                   length. A two-element sequence of fractions may also
85                   be given, indicating the lengths of the minimum and
86                   maximum colorbar extensions respectively as a
87                   fraction of the interior colorbar length.
88     *extendrect*  bool
89                   If *False* the minimum and maximum colorbar extensions
90                   will be triangular (the default). If *True* the
91                   extensions will be rectangular.
92     *spacing*     {'uniform', 'proportional'}
93                   Uniform spacing gives each discrete color the same
94                   space; proportional makes the space proportional to
95                   the data interval.
96     *ticks*       *None* or list of ticks or Locator
97                   If None, ticks are determined automatically from the
98                   input.
99     *format*      None or str or Formatter
100                   If None, `~.ticker.ScalarFormatter` is used.
101                   If a format string is given, e.g., '%.3f', that is used.
102                   An alternative `~.ticker.Formatter` may be given instead.
103     *drawedges*   bool
104                   Whether to draw lines at color boundaries.
105     *label*       str
106                   The label on the colorbar's long axis.
107     ============  ====================================================
108 
109     The following will probably be useful only in the context of
110     indexed colors (that is, when the mappable has norm=NoNorm()),
111     or other unusual circumstances.
112 
113     ============   ===================================================
114     Property       Description
115     ============   ===================================================
116     *boundaries*   None or a sequence
117     *values*       None or a sequence which must be of length 1 less
118                    than the sequence of *boundaries*. For each region
119                    delimited by adjacent entries in *boundaries*, the
120                    colormapped to the corresponding value in values
121                    will be used.
122     ============   ===================================================
123 
124 """
125 
126 docstring.interpd.update(colorbar_doc="""
127 Add a colorbar to a plot.
128 
129 Parameters
130 ----------
131 mappable
132     The `matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.AxesImage`,
133     `~matplotlib.contour.ContourSet`, etc.) described by this colorbar.
134     This argument is mandatory for the `.Figure.colorbar` method but optional
135     for the `.pyplot.colorbar` function, which sets the default to the current
136     image.
137 
138     Note that one can create a `.ScalarMappable` "on-the-fly" to generate
139     colorbars not attached to a previously drawn artist, e.g. ::
140 
141         fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)
142 
143 cax : `~matplotlib.axes.Axes`, optional
144     Axes into which the colorbar will be drawn.
145 
146 ax : `~matplotlib.axes.Axes`, list of Axes, optional
147     One or more parent axes from which space for a new colorbar axes will be
148     stolen, if *cax* is None.  This has no effect if *cax* is set.
149 
150 use_gridspec : bool, optional
151     If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If
152     *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is
153     created as an instance of Subplot using the :mod:`.gridspec` module.
154 
155 Returns
156 -------
157 colorbar : `~matplotlib.colorbar.Colorbar`
158 
159 Notes
160 -----
161 Additional keyword arguments are of two kinds:
162 
163   axes properties:
164 %s
165 %s
166   colorbar properties:
167 %s
168 
169 If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is included
170 automatically.
171 
172 The *shrink* kwarg provides a simple way to scale the colorbar with respect
173 to the axes. Note that if *cax* is specified, it determines the size of the
174 colorbar and *shrink* and *aspect* kwargs are ignored.
175 
176 For more precise control, you can manually specify the positions of
177 the axes objects in which the mappable and the colorbar are drawn.  In
178 this case, do not use any of the axes properties kwargs.
179 
180 It is known that some vector graphics viewers (svg and pdf) renders white gaps
181 between segments of the colorbar.  This is due to bugs in the viewers, not
182 Matplotlib.  As a workaround, the colorbar can be rendered with overlapping
183 segments::
184 
185     cbar = colorbar()
186     cbar.solids.set_edgecolor("face")
187     draw()
188 
189 However this has negative consequences in other circumstances, e.g. with
190 semi-transparent images (alpha < 1) and colorbar extensions; therefore, this
191 workaround is not used by default (see issue #1188).
192 """ % (textwrap.indent(_make_axes_param_doc, "    "),
193        textwrap.indent(_make_axes_other_param_doc, "    "),
194        _colormap_kw_doc))
195 
196 
197 @_api.caching_module_getattr  # module-level deprecations
198 class __getattr__:
199     colorbar_doc = _api.deprecated("3.4", obj_type="")(property(
200         lambda self: docstring.interpd.params["colorbar_doc"]))
201     colorbar_kw_doc = _api.deprecated("3.4", obj_type="")(property(
202         lambda self: _colormap_kw_doc))
203     make_axes_kw_doc = _api.deprecated("3.4", obj_type="")(property(
204         lambda self: _make_axes_param_doc + _make_axes_other_param_doc))
205 
206 
207 def _set_ticks_on_axis_warn(*args, **kwargs):
208     # a top level function which gets put in at the axes'
209     # set_xticks and set_yticks by Colorbar.__init__.
210     _api.warn_external("Use the colorbar set_ticks() method instead.")
211 
212 
213 class _ColorbarSpine(mspines.Spine):
214     def __init__(self, axes):
215         self._ax = axes
216         super().__init__(axes, 'colorbar',
217                          mpath.Path(np.empty((0, 2)), closed=True))
218         mpatches.Patch.set_transform(self, axes.transAxes)
219 
220     def get_window_extent(self, renderer=None):
221         # This Spine has no Axis associated with it, and doesn't need to adjust
222         # its location, so we can directly get the window extent from the
223         # super-super-class.
224         return mpatches.Patch.get_window_extent(self, renderer=renderer)
225 
226     def set_xy(self, xy):
227         self._path = mpath.Path(xy, closed=True)
228         self._xy = xy
229         self.stale = True
230 
231     def draw(self, renderer):
232         ret = mpatches.Patch.draw(self, renderer)
233         self.stale = False
234         return ret
235 
236 
237 class _ColorbarAxesLocator:
238     """
239     Shrink the axes if there are triangular or rectangular extends.
240     """
241     def __init__(self, cbar):
242         self._cbar = cbar
243         self._orig_locator = cbar.ax._axes_locator
244 
245     def __call__(self, ax, renderer):
246         if self._orig_locator is not None:
247             pos = self._orig_locator(ax, renderer)
248         else:
249             pos = ax.get_position(original=True)
250         if self._cbar.extend == 'neither':
251             return pos
252 
253         y, extendlen = self._cbar._proportional_y()
254         if not self._cbar._extend_lower():
255             extendlen[0] = 0
256         if not self._cbar._extend_upper():
257             extendlen[1] = 0
258         len = sum(extendlen) + 1
259         shrink = 1 / len
260         offset = extendlen[0] / len
261         # we need to reset the aspect ratio of the axes to account
262         # of the extends...
263         if hasattr(ax, '_colorbar_info'):
264             aspect = ax._colorbar_info['aspect']
265         else:
266             aspect = False
267         # now shrink and/or offset to take into account the
268         # extend tri/rectangles.
269         if self._cbar.orientation == 'vertical':
270             if aspect:
271                 self._cbar.ax.set_box_aspect(aspect*shrink)
272             pos = pos.shrunk(1, shrink).translated(0, offset * pos.height)
273         else:
274             if aspect:
275                 self._cbar.ax.set_box_aspect(1/(aspect * shrink))
276             pos = pos.shrunk(shrink, 1).translated(offset * pos.width, 0)
277         return pos
278 
279     def get_subplotspec(self):
280         # make tight_layout happy..
281         ss = getattr(self._cbar.ax, 'get_subplotspec', None)
282         if ss is None:
283             ss = self._orig_locator.get_subplotspec()
284         else:
285             ss = ss()
286         return ss
287 
288 
289 class Colorbar:
290     r"""
291     Draw a colorbar in an existing axes.
292 
293     Typically, colorbars are created using `.Figure.colorbar` or
294     `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an
295     `.AxesImage` generated via `~.axes.Axes.imshow`).
296 
297     In order to draw a colorbar not associated with other elements in the
298     figure, e.g. when showing a colormap by itself, one can create an empty
299     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*
300     to `Colorbar`.
301 
302     Useful public methods are :meth:`set_label` and :meth:`add_lines`.
303 
304     Attributes
305     ----------
306     ax : `~matplotlib.axes.Axes`
307         The `~.axes.Axes` instance in which the colorbar is drawn.
308     lines : list
309         A list of `.LineCollection` (empty if no lines were drawn).
310     dividers : `.LineCollection`
311         A LineCollection (empty if *drawedges* is ``False``).
312 
313     Parameters
314     ----------
315     ax : `~matplotlib.axes.Axes`
316         The `~.axes.Axes` instance in which the colorbar is drawn.
317 
318     mappable : `.ScalarMappable`
319         The mappable whose colormap and norm will be used.
320 
321         To show the under- and over- value colors, the mappable's norm should
322         be specified as ::
323 
324             norm = colors.Normalize(clip=False)
325 
326         To show the colors versus index instead of on a 0-1 scale, use::
327 
328             norm=colors.NoNorm()
329 
330     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`
331         The colormap to use.  This parameter is ignored, unless *mappable* is
332         None.
333 
334     norm : `~matplotlib.colors.Normalize`
335         The normalization to use.  This parameter is ignored, unless *mappable*
336         is None.
337 
338     alpha : float
339         The colorbar transparency between 0 (transparent) and 1 (opaque).
340 
341     values, boundaries
342         If unset, the colormap will be displayed on a 0-1 scale.
343 
344     orientation : {'vertical', 'horizontal'}
345 
346     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}
347 
348     extend : {'neither', 'both', 'min', 'max'}
349 
350     spacing : {'uniform', 'proportional'}
351 
352     ticks : `~matplotlib.ticker.Locator` or array-like of float
353 
354     format : str or `~matplotlib.ticker.Formatter`
355 
356     drawedges : bool
357 
358     filled : bool
359 
360     extendfrac
361 
362     extendrec
363 
364     label : str
365     """
366 
367     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize
368 
369     def __init__(self, ax, mappable=None, *, cmap=None,
370                  norm=None,
371                  alpha=None,
372                  values=None,
373                  boundaries=None,
374                  orientation='vertical',
375                  ticklocation='auto',
376                  extend=None,
377                  spacing='uniform',  # uniform or proportional
378                  ticks=None,
379                  format=None,
380                  drawedges=False,
381                  filled=True,
382                  extendfrac=None,
383                  extendrect=False,
384                  label='',
385                  ):
386 
387         if mappable is None:
388             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
389 
390         # Ensure the given mappable's norm has appropriate vmin and vmax
391         # set even if mappable.draw has not yet been called.
392         if mappable.get_array() is not None:
393             mappable.autoscale_None()
394 
395         self.mappable = mappable
396         cmap = mappable.cmap
397         norm = mappable.norm
398 
399         if isinstance(mappable, contour.ContourSet):
400             cs = mappable
401             alpha = cs.get_alpha()
402             boundaries = cs._levels
403             values = cs.cvalues
404             extend = cs.extend
405             filled = cs.filled
406             if ticks is None:
407                 ticks = ticker.FixedLocator(cs.levels, nbins=10)
408         elif isinstance(mappable, martist.Artist):
409             alpha = mappable.get_alpha()
410 
411         mappable.colorbar = self
412         mappable.colorbar_cid = mappable.callbacks.connect(
413             'changed', self.update_normal)
414 
415         _api.check_in_list(
416             ['vertical', 'horizontal'], orientation=orientation)
417         _api.check_in_list(
418             ['auto', 'left', 'right', 'top', 'bottom'],
419             ticklocation=ticklocation)
420         _api.check_in_list(
421             ['uniform', 'proportional'], spacing=spacing)
422 
423         self.ax = ax
424         self.ax._axes_locator = _ColorbarAxesLocator(self)
425 
426         if extend is None:
427             if (not isinstance(mappable, contour.ContourSet)
428                     and getattr(cmap, 'colorbar_extend', False) is not False):
429                 extend = cmap.colorbar_extend
430             elif hasattr(norm, 'extend'):
431                 extend = norm.extend
432             else:
433                 extend = 'neither'
434         self.alpha = None
435         # Call set_alpha to handle array-like alphas properly
436         self.set_alpha(alpha)
437         self.cmap = cmap
438         self.norm = norm
439         self.values = values
440         self.boundaries = boundaries
441         self.extend = extend
442         self._inside = _api.check_getitem(
443             {'neither': slice(0, None), 'both': slice(1, -1),
444              'min': slice(1, None), 'max': slice(0, -1)},
445             extend=extend)
446         self.spacing = spacing
447         self.orientation = orientation
448         self.drawedges = drawedges
449         self.filled = filled
450         self.extendfrac = extendfrac
451         self.extendrect = extendrect
452         self.solids = None
453         self.solids_patches = []
454         self.lines = []
455 
456         for spine in self.ax.spines.values():
457             spine.set_visible(False)
458         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)
459         self._short_axis().set_visible(False)
460         # Only kept for backcompat; remove after deprecation of .patch elapses.
461         self._patch = mpatches.Polygon(
462             np.empty((0, 2)),
463             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)
464         ax.add_artist(self._patch)
465 
466         self.dividers = collections.LineCollection(
467             [],
468             colors=[mpl.rcParams['axes.edgecolor']],
469             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])
470         self.ax.add_collection(self.dividers)
471 
472         self.locator = None
473         self.minorlocator = None
474         self.formatter = None
475         self.__scale = None  # linear, log10 for now.  Hopefully more?
476 
477         if ticklocation == 'auto':
478             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'
479         self.ticklocation = ticklocation
480 
481         self.set_label(label)
482         self._reset_locator_formatter_scale()
483 
484         if np.iterable(ticks):
485             self.locator = ticker.FixedLocator(ticks, nbins=len(ticks))
486         else:
487             self.locator = ticks    # Handle default in _ticker()
488 
489         if isinstance(format, str):
490             self.formatter = ticker.FormatStrFormatter(format)
491         else:
492             self.formatter = format  # Assume it is a Formatter or None
493         self.draw_all()
494 
495         if isinstance(mappable, contour.ContourSet) and not mappable.filled:
496             self.add_lines(mappable)
497 
498         # Link the Axes and Colorbar for interactive use
499         self.ax._colorbar = self
500         # Don't navigate on any of these types of mappables
501         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or
502                 isinstance(self.mappable, contour.ContourSet)):
503             self.ax.set_navigate(False)
504 
505         # These are the functions that set up interactivity on this colorbar
506         self._interactive_funcs = ["_get_view", "_set_view",
507                                    "_set_view_from_bbox", "drag_pan"]
508         for x in self._interactive_funcs:
509             setattr(self.ax, x, getattr(self, x))
510         # Set the cla function to the cbar's method to override it
511         self.ax.cla = self._cbar_cla
512 
513     def _cbar_cla(self):
514         """Function to clear the interactive colorbar state."""
515         for x in self._interactive_funcs:
516             delattr(self.ax, x)
517         # We now restore the old cla() back and can call it directly
518         del self.ax.cla
519         self.ax.cla()
520 
521     # Also remove ._patch after deprecation elapses.
522     patch = _api.deprecate_privatize_attribute("3.5", alternative="ax")
523 
524     def update_normal(self, mappable):
525         """
526         Update solid patches, lines, etc.
527 
528         This is meant to be called when the norm of the image or contour plot
529         to which this colorbar belongs changes.
530 
531         If the norm on the mappable is different than before, this resets the
532         locator and formatter for the axis, so if these have been customized,
533         they will need to be customized again.  However, if the norm only
534         changes values of *vmin*, *vmax* or *cmap* then the old formatter
535         and locator will be preserved.
536         """
537         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)
538         self.mappable = mappable
539         self.set_alpha(mappable.get_alpha())
540         self.cmap = mappable.cmap
541         if mappable.norm != self.norm:
542             self.norm = mappable.norm
543             self._reset_locator_formatter_scale()
544 
545         self.draw_all()
546         if isinstance(self.mappable, contour.ContourSet):
547             CS = self.mappable
548             if not CS.filled:
549                 self.add_lines(CS)
550         self.stale = True
551 
552     def draw_all(self):
553         """
554         Calculate any free parameters based on the current cmap and norm,
555         and do all the drawing.
556         """
557         if self.orientation == 'vertical':
558             if mpl.rcParams['ytick.minor.visible']:
559                 self.minorticks_on()
560         else:
561             if mpl.rcParams['xtick.minor.visible']:
562                 self.minorticks_on()
563         self._long_axis().set(label_position=self.ticklocation,
564                               ticks_position=self.ticklocation)
565         self._short_axis().set_ticks([])
566         self._short_axis().set_ticks([], minor=True)
567 
568         # Set self._boundaries and self._values, including extensions.
569         # self._boundaries are the edges of each square of color, and
570         # self._values are the value to map into the norm to get the
571         # color:
572         self._process_values()
573         # Set self.vmin and self.vmax to first and last boundary, excluding
574         # extensions:
575         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]
576         # Compute the X/Y mesh.
577         X, Y, extendlen = self._mesh()
578         # draw the extend triangles, and shrink the inner axes to accommodate.
579         # also adds the outline path to self.outline spine:
580         self._do_extends(extendlen)
581 
582         if self.orientation == 'vertical':
583             self.ax.set_xlim(0, 1)
584             self.ax.set_ylim(self.vmin, self.vmax)
585         else:
586             self.ax.set_ylim(0, 1)
587             self.ax.set_xlim(self.vmin, self.vmax)
588 
589         # set up the tick locators and formatters.  A bit complicated because
590         # boundary norms + uniform spacing requires a manual locator.
591         self.update_ticks()
592 
593         if self.filled:
594             ind = np.arange(len(self._values))
595             if self._extend_lower():
596                 ind = ind[1:]
597             if self._extend_upper():
598                 ind = ind[:-1]
599             self._add_solids(X, Y, self._values[ind, np.newaxis])
600 
601     def _add_solids(self, X, Y, C):
602         """Draw the colors; optionally add separators."""
603         # Cleanup previously set artists.
604         if self.solids is not None:
605             self.solids.remove()
606         for solid in self.solids_patches:
607             solid.remove()
608         # Add new artist(s), based on mappable type.  Use individual patches if
609         # hatching is needed, pcolormesh otherwise.
610         mappable = getattr(self, 'mappable', None)
611         if (isinstance(mappable, contour.ContourSet)
612                 and any(hatch is not None for hatch in mappable.hatches)):
613             self._add_solids_patches(X, Y, C, mappable)
614         else:
615             self.solids = self.ax.pcolormesh(
616                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,
617                 edgecolors='none', shading='flat')
618             if not self.drawedges:
619                 if len(self._y) >= self.n_rasterize:
620                     self.solids.set_rasterized(True)
621         self.dividers.set_segments(
622             np.dstack([X, Y])[1:-1] if self.drawedges else [])
623 
624     def _add_solids_patches(self, X, Y, C, mappable):
625         hatches = mappable.hatches * len(C)  # Have enough hatches.
626         patches = []
627         for i in range(len(X) - 1):
628             xy = np.array([[X[i, 0], Y[i, 0]],
629                            [X[i, 1], Y[i, 0]],
630                            [X[i + 1, 1], Y[i + 1, 0]],
631                            [X[i + 1, 0], Y[i + 1, 1]]])
632             patch = mpatches.PathPatch(mpath.Path(xy),
633                                        facecolor=self.cmap(self.norm(C[i][0])),
634                                        hatch=hatches[i], linewidth=0,
635                                        antialiased=False, alpha=self.alpha)
636             self.ax.add_patch(patch)
637             patches.append(patch)
638         self.solids_patches = patches
639 
640     def _do_extends(self, extendlen):
641         """
642         Add the extend tri/rectangles on the outside of the axes.
643         """
644         # extend lengths are fraction of the *inner* part of colorbar,
645         # not the total colorbar:
646         bot = 0 - (extendlen[0] if self._extend_lower() else 0)
647         top = 1 + (extendlen[1] if self._extend_upper() else 0)
648 
649         # xyout is the outline of the colorbar including the extend patches:
650         if not self.extendrect:
651             # triangle:
652             xyout = np.array([[0, 0], [0.5, bot], [1, 0],
653                               [1, 1], [0.5, top], [0, 1], [0, 0]])
654         else:
655             # rectangle:
656             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],
657                               [1, 1], [1, top], [0, top], [0, 1],
658                               [0, 0]])
659 
660         if self.orientation == 'horizontal':
661             xyout = xyout[:, ::-1]
662 
663         # xyout is the path for the spine:
664         self.outline.set_xy(xyout)
665         if not self.filled:
666             return
667 
668         # Make extend triangles or rectangles filled patches.  These are
669         # defined in the outer parent axes' coordinates:
670         mappable = getattr(self, 'mappable', None)
671         if (isinstance(mappable, contour.ContourSet)
672                 and any(hatch is not None for hatch in mappable.hatches)):
673             hatches = mappable.hatches
674         else:
675             hatches = [None]
676 
677         if self._extend_lower():
678             if not self.extendrect:
679                 # triangle
680                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])
681             else:
682                 # rectangle
683                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])
684             if self.orientation == 'horizontal':
685                 xy = xy[:, ::-1]
686             # add the patch
687             color = self.cmap(self.norm(self._values[0]))
688             patch = mpatches.PathPatch(
689                 mpath.Path(xy), facecolor=color, linewidth=0,
690                 antialiased=False, transform=self.ax.transAxes,
691                 hatch=hatches[0], clip_on=False)
692             self.ax.add_patch(patch)
693         if self._extend_upper():
694             if not self.extendrect:
695                 # triangle
696                 xy = np.array([[0, 1], [0.5, top], [1, 1]])
697             else:
698                 # rectangle
699                 xy = np.array([[0, 1], [0, top], [1, top], [1, 1]])
700             if self.orientation == 'horizontal':
701                 xy = xy[:, ::-1]
702             # add the patch
703             color = self.cmap(self.norm(self._values[-1]))
704             patch = mpatches.PathPatch(
705                 mpath.Path(xy), facecolor=color,
706                 linewidth=0, antialiased=False,
707                 transform=self.ax.transAxes, hatch=hatches[-1], clip_on=False)
708             self.ax.add_patch(patch)
709         return
710 
711     def add_lines(self, *args, **kwargs):
712         """
713         Draw lines on the colorbar.
714 
715         The lines are appended to the list :attr:`lines`.
716 
717         Parameters
718         ----------
719         levels : array-like
720             The positions of the lines.
721         colors : color or list of colors
722             Either a single color applying to all lines or one color value for
723             each line.
724         linewidths : float or array-like
725             Either a single linewidth applying to all lines or one linewidth
726             for each line.
727         erase : bool, default: True
728             Whether to remove any previously added lines.
729 
730         Notes
731         -----
732         Alternatively, this method can also be called with the signature
733         ``colorbar.add_lines(contour_set, erase=True)``, in which case
734         *levels*, *colors*, and *linewidths* are taken from *contour_set*.
735         """
736         params = _api.select_matching_signature(
737             [lambda self, CS, erase=True: locals(),
738              lambda self, levels, colors, linewidths, erase=True: locals()],
739             self, *args, **kwargs)
740         if "CS" in params:
741             self, CS, erase = params.values()
742             if not isinstance(CS, contour.ContourSet) or CS.filled:
743                 raise ValueError("If a single artist is passed to add_lines, "
744                                  "it must be a ContourSet of lines")
745             # TODO: Make colorbar lines auto-follow changes in contour lines.
746             return self.add_lines(
747                 CS.levels,
748                 [c[0] for c in CS.tcolors],
749                 [t[0] for t in CS.tlinewidths],
750                 erase=erase)
751         else:
752             self, levels, colors, linewidths, erase = params.values()
753 
754         y = self._locate(levels)
755         rtol = (self._y[-1] - self._y[0]) * 1e-10
756         igood = (y < self._y[-1] + rtol) & (y > self._y[0] - rtol)
757         y = y[igood]
758         if np.iterable(colors):
759             colors = np.asarray(colors)[igood]
760         if np.iterable(linewidths):
761             linewidths = np.asarray(linewidths)[igood]
762         X, Y = np.meshgrid([0, 1], y)
763         if self.orientation == 'vertical':
764             xy = np.stack([X, Y], axis=-1)
765         else:
766             xy = np.stack([Y, X], axis=-1)
767         col = collections.LineCollection(xy, linewidths=linewidths,
768                                          colors=colors)
769 
770         if erase and self.lines:
771             for lc in self.lines:
772                 lc.remove()
773             self.lines = []
774         self.lines.append(col)
775 
776         # make a clip path that is just a linewidth bigger than the axes...
777         fac = np.max(linewidths) / 72
778         xy = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
779         inches = self.ax.get_figure().dpi_scale_trans
780         # do in inches:
781         xy = inches.inverted().transform(self.ax.transAxes.transform(xy))
782         xy[[0, 1, 4], 1] -= fac
783         xy[[2, 3], 1] += fac
784         # back to axes units...
785         xy = self.ax.transAxes.inverted().transform(inches.transform(xy))
786         if self.orientation == 'horizontal':
787             xy = xy.T
788         col.set_clip_path(mpath.Path(xy, closed=True),
789                           self.ax.transAxes)
790         self.ax.add_collection(col)
791         self.stale = True
792 
793     def update_ticks(self):
794         """
795         Setup the ticks and ticklabels. This should not be needed by users.
796         """
797         # Get the locator and formatter; defaults to self.locator if not None.
798         self._get_ticker_locator_formatter()
799         self._long_axis().set_major_locator(self.locator)
800         self._long_axis().set_minor_locator(self.minorlocator)
801         self._long_axis().set_major_formatter(self.formatter)
802 
803     def _get_ticker_locator_formatter(self):
804         """
805         Return the ``locator`` and ``formatter`` of the colorbar.
806 
807         If they have not been defined (i.e. are *None*), the formatter and
808         locator are retrieved from the axis, or from the value of the
809         boundaries for a boundary norm.
810 
811         Called by update_ticks...
812         """
813         locator = self.locator
814         formatter = self.formatter
815         minorlocator = self.minorlocator
816         if isinstance(self.norm, colors.BoundaryNorm):
817             b = self.norm.boundaries
818             if locator is None:
819                 locator = ticker.FixedLocator(b, nbins=10)
820         elif self.boundaries is not None:
821             b = self._boundaries[self._inside]
822             if locator is None:
823                 locator = ticker.FixedLocator(b, nbins=10)
824         else:  # most cases:
825             if locator is None:
826                 # we haven't set the locator explicitly, so use the default
827                 # for this axis:
828                 locator = self._long_axis().get_major_locator()
829             if minorlocator is None:
830                 minorlocator = self._long_axis().get_minor_locator()
831             if isinstance(self.norm, colors.NoNorm):
832                 # default locator:
833                 nv = len(self._values)
834                 base = 1 + int(nv / 10)
835                 locator = ticker.IndexLocator(base=base, offset=0)
836 
837         if minorlocator is None:
838             minorlocator = ticker.NullLocator()
839 
840         if formatter is None:
841             formatter = self._long_axis().get_major_formatter()
842 
843         self.locator = locator
844         self.formatter = formatter
845         self.minorlocator = minorlocator
846         _log.debug('locator: %r', locator)
847 
848     @_api.delete_parameter("3.5", "update_ticks")
849     def set_ticks(self, ticks, update_ticks=True, labels=None, *,
850                   minor=False, **kwargs):
851         """
852         Set tick locations.
853 
854         Parameters
855         ----------
856         ticks : list of floats
857             List of tick locations.
858         labels : list of str, optional
859             List of tick labels. If not set, the labels show the data value.
860         minor : bool, default: False
861             If ``False``, set the major ticks; if ``True``, the minor ticks.
862         **kwargs
863             `.Text` properties for the labels. These take effect only if you
864             pass *labels*. In other cases, please use `~.Axes.tick_params`.
865         """
866         if np.iterable(ticks):
867             self._long_axis().set_ticks(ticks, labels=labels, minor=minor,
868                                         **kwargs)
869             self.locator = self._long_axis().get_major_locator()
870         else:
871             self.locator = ticks
872             self._long_axis().set_major_locator(self.locator)
873         self.stale = True
874 
875     def get_ticks(self, minor=False):
876         """
877         Return the ticks as a list of locations.
878 
879         Parameters
880         ----------
881         minor : boolean, default: False
882             if True return the minor ticks.
883         """
884         if minor:
885             return self._long_axis().get_minorticklocs()
886         else:
887             return self._long_axis().get_majorticklocs()
888 
889     @_api.delete_parameter("3.5", "update_ticks")
890     def set_ticklabels(self, ticklabels, update_ticks=True, *, minor=False,
891                        **kwargs):
892         """
893         Set tick labels.
894 
895         .. admonition:: Discouraged
896 
897             The use of this method is discouraged, because of the dependency
898             on tick positions. In most cases, you'll want to use
899             ``set_ticks(positions, labels=labels)`` instead.
900 
901             If you are using this method, you should always fix the tick
902             positions before, e.g. by using `.Colorbar.set_ticks` or by
903             explicitly setting a `~.ticker.FixedLocator` on the long axis
904             of the colorbar. Otherwise, ticks are free to move and the
905             labels may end up in unexpected positions.
906 
907         Parameters
908         ----------
909         ticklabels : sequence of str or of `.Text`
910             Texts for labeling each tick location in the sequence set by
911             `.Colorbar.set_ticks`; the number of labels must match the number
912             of locations.
913 
914         update_ticks : bool, default: True
915             This keyword argument is ignored and will be be removed.
916             Deprecated
917 
918          minor : bool
919             If True, set minor ticks instead of major ticks.
920 
921         **kwargs
922             `.Text` properties for the labels.
923         """
924         self._long_axis().set_ticklabels(ticklabels, minor=minor, **kwargs)
925 
926     def minorticks_on(self):
927         """
928         Turn on colorbar minor ticks.
929         """
930         self.ax.minorticks_on()
931         self.minorlocator = self._long_axis().get_minor_locator()
932         self._short_axis().set_minor_locator(ticker.NullLocator())
933 
934     def minorticks_off(self):
935         """Turn the minor ticks of the colorbar off."""
936         self.minorlocator = ticker.NullLocator()
937         self._long_axis().set_minor_locator(self.minorlocator)
938 
939     def set_label(self, label, *, loc=None, **kwargs):
940         """
941         Add a label to the long axis of the colorbar.
942 
943         Parameters
944         ----------
945         label : str
946             The label text.
947         loc : str, optional
948             The location of the label.
949 
950             - For horizontal orientation one of {'left', 'center', 'right'}
951             - For vertical orientation one of {'bottom', 'center', 'top'}
952 
953             Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation`
954             depending on the orientation.
955         **kwargs
956             Keyword arguments are passed to `~.Axes.set_xlabel` /
957             `~.Axes.set_ylabel`.
958             Supported keywords are *labelpad* and `.Text` properties.
959         """
960         if self.orientation == "vertical":
961             self.ax.set_ylabel(label, loc=loc, **kwargs)
962         else:
963             self.ax.set_xlabel(label, loc=loc, **kwargs)
964         self.stale = True
965 
966     def set_alpha(self, alpha):
967         """
968         Set the transparency between 0 (transparent) and 1 (opaque).
969 
970         If an array is provided, *alpha* will be set to None to use the
971         transparency values associated with the colormap.
972         """
973         self.alpha = None if isinstance(alpha, np.ndarray) else alpha
974 
975     def _set_scale(self, scale, **kwargs):
976         """
977         Set the colorbar long axis scale.
978 
979         Parameters
980         ----------
981         value : {"linear", "log", "symlog", "logit", ...} or `.ScaleBase`
982             The axis scale type to apply.
983 
984         **kwargs
985             Different keyword arguments are accepted, depending on the scale.
986             See the respective class keyword arguments:
987 
988             - `matplotlib.scale.LinearScale`
989             - `matplotlib.scale.LogScale`
990             - `matplotlib.scale.SymmetricalLogScale`
991             - `matplotlib.scale.LogitScale`
992             - `matplotlib.scale.FuncScale`
993 
994         Notes
995         -----
996         By default, Matplotlib supports the above mentioned scales.
997         Additionally, custom scales may be registered using
998         `matplotlib.scale.register_scale`. These scales can then also
999         be used here.
1000         """
1001         if self.orientation == 'vertical':
1002             self.ax.set_yscale(scale, **kwargs)
1003         else:
1004             self.ax.set_xscale(scale, **kwargs)
1005         if isinstance(scale, mscale.ScaleBase):
1006             self.__scale = scale.name
1007         else:
1008             self.__scale = scale
1009 
1010     def remove(self):
1011         """
1012         Remove this colorbar from the figure.
1013 
1014         If the colorbar was created with ``use_gridspec=True`` the previous
1015         gridspec is restored.
1016         """
1017         if hasattr(self.ax, '_colorbar_info'):
1018             parents = self.ax._colorbar_info['parents']
1019             for a in parents:
1020                 if self.ax in a._colorbars:
1021                     a._colorbars.remove(self.ax)
1022 
1023         self.ax.remove()
1024 
1025         self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)
1026         self.mappable.colorbar = None
1027         self.mappable.colorbar_cid = None
1028 
1029         try:
1030             ax = self.mappable.axes
1031         except AttributeError:
1032             return
1033         try:
1034             gs = ax.get_subplotspec().get_gridspec()
1035             subplotspec = gs.get_topmost_subplotspec()
1036         except AttributeError:
1037             # use_gridspec was False
1038             pos = ax.get_position(original=True)
1039             ax._set_position(pos)
1040         else:
1041             # use_gridspec was True
1042             ax.set_subplotspec(subplotspec)
1043 
1044     def _ticker(self, locator, formatter):
1045         """
1046         Return the sequence of ticks (colorbar data locations),
1047         ticklabels (strings), and the corresponding offset string.
1048         """
1049         if isinstance(self.norm, colors.NoNorm) and self.boundaries is None:
1050             intv = self._values[0], self._values[-1]
1051         else:
1052             intv = self.vmin, self.vmax
1053         locator.create_dummy_axis(minpos=intv[0])
1054         locator.axis.set_view_interval(*intv)
1055         locator.axis.set_data_interval(*intv)
1056         formatter.set_axis(locator.axis)
1057 
1058         b = np.array(locator())
1059         if isinstance(locator, ticker.LogLocator):
1060             eps = 1e-10
1061             b = b[(b <= intv[1] * (1 + eps)) & (b >= intv[0] * (1 - eps))]
1062         else:
1063             eps = (intv[1] - intv[0]) * 1e-10
1064             b = b[(b <= intv[1] + eps) & (b >= intv[0] - eps)]
1065         ticks = self._locate(b)
1066         ticklabels = formatter.format_ticks(b)
1067         offset_string = formatter.get_offset()
1068         return ticks, ticklabels, offset_string
1069 
1070     def _process_values(self):
1071         """
1072         Set `_boundaries` and `_values` based on the self.boundaries and
1073         self.values if not None, or based on the size of the colormap and
1074         the vmin/vmax of the norm.
1075         """
1076         if self.values is not None:
1077             # set self._boundaries from the values...
1078             self._values = np.array(self.values)
1079             if self.boundaries is None:
1080                 # bracket values by 1/2 dv:
1081                 b = np.zeros(len(self.values) + 1)
1082                 b[1:-1] = 0.5 * (self._values[:-1] + self._values[1:])
1083                 b[0] = 2.0 * b[1] - b[2]
1084                 b[-1] = 2.0 * b[-2] - b[-3]
1085                 self._boundaries = b
1086                 return
1087             self._boundaries = np.array(self.boundaries)
1088             return
1089 
1090         # otherwise values are set from the boundaries
1091         if isinstance(self.norm, colors.BoundaryNorm):
1092             b = self.norm.boundaries
1093         else:
1094             # otherwise make the boundaries from the size of the cmap:
1095             N = self.cmap.N + 1
1096             b, _ = self._uniform_y(N)
1097         # add extra boundaries if needed:
1098         if self._extend_lower():
1099             b = np.hstack((b[0] - 1, b))
1100         if self._extend_upper():
1101             b = np.hstack((b, b[-1] + 1))
1102 
1103         # transform from 0-1 to vmin-vmax:
1104         if not self.norm.scaled():
1105             self.norm.vmin = 0
1106             self.norm.vmax = 1
1107         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(
1108             self.norm.vmin, self.norm.vmax, expander=0.1)
1109         if not isinstance(self.norm, colors.BoundaryNorm):
1110             b = self.norm.inverse(b)
1111 
1112         self._boundaries = np.asarray(b, dtype=float)
1113         self._values = 0.5 * (self._boundaries[:-1] + self._boundaries[1:])
1114         if isinstance(self.norm, colors.NoNorm):
1115             self._values = (self._values + 0.00001).astype(np.int16)
1116 
1117     def _mesh(self):
1118         """
1119         Return the coordinate arrays for the colorbar pcolormesh/patches.
1120 
1121         These are scaled between vmin and vmax, and already handle colorbar
1122         orientation.
1123         """
1124         # copy the norm and change the vmin and vmax to the vmin and
1125         # vmax of the colorbar, not the norm.  This allows the situation
1126         # where the colormap has a narrower range than the colorbar, to
1127         # accommodate extra contours:
1128         norm = copy.deepcopy(self.norm)
1129         norm.vmin = self.vmin
1130         norm.vmax = self.vmax
1131         y, extendlen = self._proportional_y()
1132         # invert:
1133         if isinstance(norm, (colors.BoundaryNorm, colors.NoNorm)):
1134             y = y * (self.vmax - self.vmin) + self.vmin  # not using a norm.
1135         else:
1136             y = norm.inverse(y)
1137         self._y = y
1138         X, Y = np.meshgrid([0., 1.], y)
1139         if self.orientation == 'vertical':
1140             return (X, Y, extendlen)
1141         else:
1142             return (Y, X, extendlen)
1143 
1144     def _forward_boundaries(self, x):
1145         b = self._boundaries
1146         y = np.interp(x, b, np.linspace(0, b[-1], len(b)))
1147         eps = (b[-1] - b[0]) * 1e-6
1148         y[x < b[0]-eps] = -1
1149         y[x > b[-1]+eps] = 2
1150         return y
1151 
1152     def _inverse_boundaries(self, x):
1153         b = self._boundaries
1154         return np.interp(x, np.linspace(0, b[-1], len(b)), b)
1155 
1156     def _reset_locator_formatter_scale(self):
1157         """
1158         Reset the locator et al to defaults.  Any user-hardcoded changes
1159         need to be re-entered if this gets called (either at init, or when
1160         the mappable normal gets changed: Colorbar.update_normal)
1161         """
1162         self._process_values()
1163         self.locator = None
1164         self.minorlocator = None
1165         self.formatter = None
1166         if (self.boundaries is not None or
1167                 isinstance(self.norm, colors.BoundaryNorm)):
1168             if self.spacing == 'uniform':
1169                 funcs = (self._forward_boundaries, self._inverse_boundaries)
1170                 self._set_scale('function', functions=funcs)
1171             elif self.spacing == 'proportional':
1172                 self._set_scale('linear')
1173         elif getattr(self.norm, '_scale', None):
1174             # use the norm's scale (if it exists and is not None):
1175             self._set_scale(self.norm._scale)
1176         elif type(self.norm) is colors.Normalize:
1177             # plain Normalize:
1178             self._set_scale('linear')
1179         else:
1180             # norm._scale is None or not an attr: derive the scale from
1181             # the Norm:
1182             funcs = (self.norm, self.norm.inverse)
1183             self._set_scale('function', functions=funcs)
1184 
1185     def _locate(self, x):
1186         """
1187         Given a set of color data values, return their
1188         corresponding colorbar data coordinates.
1189         """
1190         if isinstance(self.norm, (colors.NoNorm, colors.BoundaryNorm)):
1191             b = self._boundaries
1192             xn = x
1193         else:
1194             # Do calculations using normalized coordinates so
1195             # as to make the interpolation more accurate.
1196             b = self.norm(self._boundaries, clip=False).filled()
1197             xn = self.norm(x, clip=False).filled()
1198 
1199         bunique = b[self._inside]
1200         yunique = self._y
1201 
1202         z = np.interp(xn, bunique, yunique)
1203         return z
1204 
1205     # trivial helpers
1206 
1207     def _uniform_y(self, N):
1208         """
1209         Return colorbar data coordinates for *N* uniformly
1210         spaced boundaries, plus extension lengths if required.
1211         """
1212         automin = automax = 1. / (N - 1.)
1213         extendlength = self._get_extension_lengths(self.extendfrac,
1214                                                    automin, automax,
1215                                                    default=0.05)
1216         y = np.linspace(0, 1, N)
1217         return y, extendlength
1218 
1219     def _proportional_y(self):
1220         """
1221         Return colorbar data coordinates for the boundaries of
1222         a proportional colorbar, plus extension lengths if required:
1223         """
1224         if isinstance(self.norm, colors.BoundaryNorm):
1225             y = (self._boundaries - self._boundaries[self._inside][0])
1226             y = y / (self._boundaries[self._inside][-1] -
1227                      self._boundaries[self._inside][0])
1228             # need yscaled the same as the axes scale to get
1229             # the extend lengths.
1230             if self.spacing == 'uniform':
1231                 yscaled = self._forward_boundaries(self._boundaries)
1232             else:
1233                 yscaled = y
1234         else:
1235             y = self.norm(self._boundaries.copy())
1236             y = np.ma.filled(y, np.nan)
1237             # the norm and the scale should be the same...
1238             yscaled = y
1239         y = y[self._inside]
1240         yscaled = yscaled[self._inside]
1241         # normalize from 0..1:
1242         norm = colors.Normalize(y[0], y[-1])
1243         y = np.ma.filled(norm(y), np.nan)
1244         norm = colors.Normalize(yscaled[0], yscaled[-1])
1245         yscaled = np.ma.filled(norm(yscaled), np.nan)
1246         # make the lower and upper extend lengths proportional to the lengths
1247         # of the first and last boundary spacing (if extendfrac='auto'):
1248         automin = yscaled[1] - yscaled[0]
1249         automax = yscaled[-1] - yscaled[-2]
1250         extendlength = [0, 0]
1251         if self._extend_lower() or self._extend_upper():
1252             extendlength = self._get_extension_lengths(
1253                     self.extendfrac, automin, automax, default=0.05)
1254         return y, extendlength
1255 
1256     def _get_extension_lengths(self, frac, automin, automax, default=0.05):
1257         """
1258         Return the lengths of colorbar extensions.
1259 
1260         This is a helper method for _uniform_y and _proportional_y.
1261         """
1262         # Set the default value.
1263         extendlength = np.array([default, default])
1264         if isinstance(frac, str):
1265             _api.check_in_list(['auto'], extendfrac=frac.lower())
1266             # Use the provided values when 'auto' is required.
1267             extendlength[:] = [automin, automax]
1268         elif frac is not None:
1269             try:
1270                 # Try to set min and max extension fractions directly.
1271                 extendlength[:] = frac
1272                 # If frac is a sequence containing None then NaN may
1273                 # be encountered. This is an error.
1274                 if np.isnan(extendlength).any():
1275                     raise ValueError()
1276             except (TypeError, ValueError) as err:
1277                 # Raise an error on encountering an invalid value for frac.
1278                 raise ValueError('invalid value for extendfrac') from err
1279         return extendlength
1280 
1281     def _extend_lower(self):
1282         """Return whether the lower limit is open ended."""
1283         return self.extend in ('both', 'min')
1284 
1285     def _extend_upper(self):
1286         """Return whether the upper limit is open ended."""
1287         return self.extend in ('both', 'max')
1288 
1289     def _long_axis(self):
1290         """Return the long axis"""
1291         if self.orientation == 'vertical':
1292             return self.ax.yaxis
1293         return self.ax.xaxis
1294 
1295     def _short_axis(self):
1296         """Return the short axis"""
1297         if self.orientation == 'vertical':
1298             return self.ax.xaxis
1299         return self.ax.yaxis
1300 
1301     def _get_view(self):
1302         # docstring inherited
1303         # An interactive view for a colorbar is the norm's vmin/vmax
1304         return self.norm.vmin, self.norm.vmax
1305 
1306     def _set_view(self, view):
1307         # docstring inherited
1308         # An interactive view for a colorbar is the norm's vmin/vmax
1309         self.norm.vmin, self.norm.vmax = view
1310 
1311     def _set_view_from_bbox(self, bbox, direction='in',
1312                             mode=None, twinx=False, twiny=False):
1313         # docstring inherited
1314         # For colorbars, we use the zoom bbox to scale the norm's vmin/vmax
1315         new_xbound, new_ybound = self.ax._prepare_view_from_bbox(
1316             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
1317         if self.orientation == 'horizontal':
1318             self.norm.vmin, self.norm.vmax = new_xbound
1319         elif self.orientation == 'vertical':
1320             self.norm.vmin, self.norm.vmax = new_ybound
1321 
1322     def drag_pan(self, button, key, x, y):
1323         # docstring inherited
1324         points = self.ax._get_pan_points(button, key, x, y)
1325         if points is not None:
1326             if self.orientation == 'horizontal':
1327                 self.norm.vmin, self.norm.vmax = points[:, 0]
1328             elif self.orientation == 'vertical':
1329                 self.norm.vmin, self.norm.vmax = points[:, 1]
1330 
1331 
1332 ColorbarBase = Colorbar  # Backcompat API
1333 
1334 
1335 def _normalize_location_orientation(location, orientation):
1336     if location is None:
1337         location = _api.check_getitem(
1338             {None: "right", "vertical": "right", "horizontal": "bottom"},
1339             orientation=orientation)
1340     loc_settings = _api.check_getitem({
1341         "left":   {"location": "left", "orientation": "vertical",
1342                    "anchor": (1.0, 0.5), "panchor": (0.0, 0.5), "pad": 0.10},
1343         "right":  {"location": "right", "orientation": "vertical",
1344                    "anchor": (0.0, 0.5), "panchor": (1.0, 0.5), "pad": 0.05},
1345         "top":    {"location": "top", "orientation": "horizontal",
1346                    "anchor": (0.5, 0.0), "panchor": (0.5, 1.0), "pad": 0.05},
1347         "bottom": {"location": "bottom", "orientation": "horizontal",
1348                    "anchor": (0.5, 1.0), "panchor": (0.5, 0.0), "pad": 0.15},
1349     }, location=location)
1350     if orientation is not None and orientation != loc_settings["orientation"]:
1351         # Allow the user to pass both if they are consistent.
1352         raise TypeError("location and orientation are mutually exclusive")
1353     return loc_settings
1354 
1355 
1356 @docstring.Substitution(_make_axes_param_doc, _make_axes_other_param_doc)
1357 def make_axes(parents, location=None, orientation=None, fraction=0.15,
1358               shrink=1.0, aspect=20, **kwargs):
1359     """
1360     Create an `~.axes.Axes` suitable for a colorbar.
1361 
1362     The axes is placed in the figure of the *parents* axes, by resizing and
1363     repositioning *parents*.
1364 
1365     Parameters
1366     ----------
1367     parents : `~.axes.Axes` or list of `~.axes.Axes`
1368         The Axes to use as parents for placing the colorbar.
1369     %s
1370 
1371     Returns
1372     -------
1373     cax : `~.axes.Axes`
1374         The child axes.
1375     kwargs : dict
1376         The reduced keyword dictionary to be passed when creating the colorbar
1377         instance.
1378 
1379     Other Parameters
1380     ----------------
1381     %s
1382     """
1383     loc_settings = _normalize_location_orientation(location, orientation)
1384     # put appropriate values into the kwargs dict for passing back to
1385     # the Colorbar class
1386     kwargs['orientation'] = loc_settings['orientation']
1387     location = kwargs['ticklocation'] = loc_settings['location']
1388 
1389     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1390     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1391     aspect0 = aspect
1392     # turn parents into a list if it is not already. We do this w/ np
1393     # because `plt.subplots` can return an ndarray and is natural to
1394     # pass to `colorbar`.
1395     parents = np.atleast_1d(parents).ravel()
1396     fig = parents[0].get_figure()
1397 
1398     pad0 = 0.05 if fig.get_constrained_layout() else loc_settings['pad']
1399     pad = kwargs.pop('pad', pad0)
1400 
1401     if not all(fig is ax.get_figure() for ax in parents):
1402         raise ValueError('Unable to create a colorbar axes as not all '
1403                          'parents share the same figure.')
1404 
1405     # take a bounding box around all of the given axes
1406     parents_bbox = mtransforms.Bbox.union(
1407         [ax.get_position(original=True).frozen() for ax in parents])
1408 
1409     pb = parents_bbox
1410     if location in ('left', 'right'):
1411         if location == 'left':
1412             pbcb, _, pb1 = pb.splitx(fraction, fraction + pad)
1413         else:
1414             pb1, _, pbcb = pb.splitx(1 - fraction - pad, 1 - fraction)
1415         pbcb = pbcb.shrunk(1.0, shrink).anchored(anchor, pbcb)
1416     else:
1417         if location == 'bottom':
1418             pbcb, _, pb1 = pb.splity(fraction, fraction + pad)
1419         else:
1420             pb1, _, pbcb = pb.splity(1 - fraction - pad, 1 - fraction)
1421         pbcb = pbcb.shrunk(shrink, 1.0).anchored(anchor, pbcb)
1422 
1423         # define the aspect ratio in terms of y's per x rather than x's per y
1424         aspect = 1.0 / aspect
1425 
1426     # define a transform which takes us from old axes coordinates to
1427     # new axes coordinates
1428     shrinking_trans = mtransforms.BboxTransform(parents_bbox, pb1)
1429 
1430     # transform each of the axes in parents using the new transform
1431     for ax in parents:
1432         new_posn = shrinking_trans.transform(ax.get_position(original=True))
1433         new_posn = mtransforms.Bbox(new_posn)
1434         ax._set_position(new_posn)
1435         if panchor is not False:
1436             ax.set_anchor(panchor)
1437 
1438     cax = fig.add_axes(pbcb, label="<colorbar>")
1439     for a in parents:
1440         # tell the parent it has a colorbar
1441         a._colorbars += [cax]
1442     cax._colorbar_info = dict(
1443         location=location,
1444         parents=parents,
1445         shrink=shrink,
1446         anchor=anchor,
1447         panchor=panchor,
1448         fraction=fraction,
1449         aspect=aspect0,
1450         pad=pad)
1451     # and we need to set the aspect ratio by hand...
1452     cax.set_anchor(anchor)
1453     cax.set_box_aspect(aspect)
1454     cax.set_aspect('auto')
1455 
1456     return cax, kwargs
1457 
1458 
1459 @docstring.Substitution(_make_axes_param_doc, _make_axes_other_param_doc)
1460 def make_axes_gridspec(parent, *, location=None, orientation=None,
1461                        fraction=0.15, shrink=1.0, aspect=20, **kwargs):
1462     """
1463     Create a `.SubplotBase` suitable for a colorbar.
1464 
1465     The axes is placed in the figure of the *parent* axes, by resizing and
1466     repositioning *parent*.
1467 
1468     This function is similar to `.make_axes`. Primary differences are
1469 
1470     - `.make_axes_gridspec` should only be used with a `.SubplotBase` parent.
1471 
1472     - `.make_axes` creates an `~.axes.Axes`; `.make_axes_gridspec` creates a
1473       `.SubplotBase`.
1474 
1475     - `.make_axes` updates the position of the parent.  `.make_axes_gridspec`
1476       replaces the ``grid_spec`` attribute of the parent with a new one.
1477 
1478     While this function is meant to be compatible with `.make_axes`,
1479     there could be some minor differences.
1480 
1481     Parameters
1482     ----------
1483     parent : `~.axes.Axes`
1484         The Axes to use as parent for placing the colorbar.
1485     %s
1486 
1487     Returns
1488     -------
1489     cax : `~.axes.SubplotBase`
1490         The child axes.
1491     kwargs : dict
1492         The reduced keyword dictionary to be passed when creating the colorbar
1493         instance.
1494 
1495     Other Parameters
1496     ----------------
1497     %s
1498     """
1499 
1500     loc_settings = _normalize_location_orientation(location, orientation)
1501     kwargs['orientation'] = loc_settings['orientation']
1502     location = kwargs['ticklocation'] = loc_settings['location']
1503 
1504     aspect0 = aspect
1505     anchor = kwargs.pop('anchor', loc_settings['anchor'])
1506     panchor = kwargs.pop('panchor', loc_settings['panchor'])
1507     pad = kwargs.pop('pad', loc_settings["pad"])
1508     wh_space = 2 * pad / (1 - pad)
1509 
1510     if location in ('left', 'right'):
1511         # for shrinking
1512         height_ratios = [
1513                 (1-anchor[1])*(1-shrink), shrink, anchor[1]*(1-shrink)]
1514 
1515         if location == 'left':
1516             gs = parent.get_subplotspec().subgridspec(
1517                     1, 2, wspace=wh_space,
1518                     width_ratios=[fraction, 1-fraction-pad])
1519             ss_main = gs[1]
1520             ss_cb = gs[0].subgridspec(
1521                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1522         else:
1523             gs = parent.get_subplotspec().subgridspec(
1524                     1, 2, wspace=wh_space,
1525                     width_ratios=[1-fraction-pad, fraction])
1526             ss_main = gs[0]
1527             ss_cb = gs[1].subgridspec(
1528                     3, 1, hspace=0, height_ratios=height_ratios)[1]
1529     else:
1530         # for shrinking
1531         width_ratios = [
1532                 anchor[0]*(1-shrink), shrink, (1-anchor[0])*(1-shrink)]
1533 
1534         if location == 'bottom':
1535             gs = parent.get_subplotspec().subgridspec(
1536                     2, 1, hspace=wh_space,
1537                     height_ratios=[1-fraction-pad, fraction])
1538             ss_main = gs[0]
1539             ss_cb = gs[1].subgridspec(
1540                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1541             aspect = 1 / aspect
1542         else:
1543             gs = parent.get_subplotspec().subgridspec(
1544                     2, 1, hspace=wh_space,
1545                     height_ratios=[fraction, 1-fraction-pad])
1546             ss_main = gs[1]
1547             ss_cb = gs[0].subgridspec(
1548                     1, 3, wspace=0, width_ratios=width_ratios)[1]
1549             aspect = 1 / aspect
1550 
1551     parent.set_subplotspec(ss_main)
1552     parent.set_anchor(panchor)
1553 
1554     fig = parent.get_figure()
1555     cax = fig.add_subplot(ss_cb, label="<colorbar>")
1556     cax.set_anchor(anchor)
1557     cax.set_box_aspect(aspect)
1558     cax.set_aspect('auto')
1559     cax._colorbar_info = dict(
1560         location=location,
1561         parents=[parent],
1562         shrink=shrink,
1563         anchor=anchor,
1564         panchor=panchor,
1565         fraction=fraction,
1566         aspect=aspect0,
1567         pad=pad)
1568     return cax, kwargs
1569 
1570 
1571 @_api.deprecated("3.4", alternative="Colorbar")
1572 class ColorbarPatch(Colorbar):
1573     pass
1574 
1575 
1576 @_api.deprecated("3.4", alternative="Colorbar")
1577 def colorbar_factory(cax, mappable, **kwargs):
1578     """
1579     Create a colorbar on the given axes for the given mappable.
1580 
1581     .. note::
1582         This is a low-level function to turn an existing axes into a colorbar
1583         axes.  Typically, you'll want to use `~.Figure.colorbar` instead, which
1584         automatically handles creation and placement of a suitable axes as
1585         well.
1586 
1587     Parameters
1588     ----------
1589     cax : `~matplotlib.axes.Axes`
1590         The `~.axes.Axes` to turn into a colorbar.
1591     mappable : `~matplotlib.cm.ScalarMappable`
1592         The mappable to be described by the colorbar.
1593     **kwargs
1594         Keyword arguments are passed to the respective colorbar class.
1595 
1596     Returns
1597     -------
1598     `.Colorbar`
1599         The created colorbar instance.
1600     """
1601     return Colorbar(cax, mappable, **kwargs)

</code><intended_behavior>While not directly a "bug," the current implementation does not clearly support or document the ability for users to pass callable formatters directly to the colorbar's format parameter. With the intended change in how format strings are processed (moving to new-style format strings), it's also an opportunity to align and potentially enhance the documentation or code comments regarding the use of callable formatters in colorbar initialization, ensuring users are aware of this capability and its intended usage aligns with the broader matplotlib formatting logic.</intended_behavior>]
2025-10-18 13:56:51.383 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 13:56:51.383 | INFO     | Search-only: skipping patch selection
2025-10-18 13:56:51.575 | INFO     | Task matplotlib__matplotlib-21542 completed successfully.
2025-10-18 13:56:51.576 | INFO     | No patch generated. You can try running ACR again.
