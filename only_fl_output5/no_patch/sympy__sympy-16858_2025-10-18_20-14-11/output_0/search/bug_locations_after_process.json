[
    {
        "rel_file_path": "sympy/stats/crv_types.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/stats/crv_types.py",
        "start": 1,
        "end": 3353,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Continuous Random Variables - Prebuilt variables\n3 \n4 Contains\n5 ========\n6 Arcsin\n7 Benini\n8 Beta\n9 BetaNoncentral\n10 BetaPrime\n11 Cauchy\n12 Chi\n13 ChiNoncentral\n14 ChiSquared\n15 Dagum\n16 Erlang\n17 Exponential\n18 FDistribution\n19 FisherZ\n20 Frechet\n21 Gamma\n22 GammaInverse\n23 Gumbel\n24 Gompertz\n25 Kumaraswamy\n26 Laplace\n27 Logistic\n28 LogNormal\n29 Maxwell\n30 Nakagami\n31 Normal\n32 Pareto\n33 QuadraticU\n34 RaisedCosine\n35 Rayleigh\n36 ShiftedGompertz\n37 StudentT\n38 Trapezoidal\n39 Triangular\n40 Uniform\n41 UniformSum\n42 VonMises\n43 Weibull\n44 WignerSemicircle\n45 \"\"\"\n46 \n47 from __future__ import print_function, division\n48 \n49 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma,\n50                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,\n51                    Lambda, Basic, lowergamma, erf, erfi,  erfinv, I, hyper,\n52                    uppergamma, sinh, atan, Ne, expint)\n53 \n54 from sympy import beta as beta_fn\n55 from sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk\n56 from sympy.external import import_module\n57 from sympy.matrices import MatrixBase\n58 from sympy.stats.crv import (SingleContinuousPSpace, SingleContinuousDistribution,\n59         ContinuousDistributionHandmade)\n60 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution\n61 from sympy.stats.joint_rv_types import multivariate_rv\n62 from sympy.stats.rv import _value_check, RandomSymbol\n63 import random\n64 \n65 oo = S.Infinity\n66 \n67 __all__ = ['ContinuousRV',\n68 'Arcsin',\n69 'Benini',\n70 'Beta',\n71 'BetaNoncentral',\n72 'BetaPrime',\n73 'Cauchy',\n74 'Chi',\n75 'ChiNoncentral',\n76 'ChiSquared',\n77 'Dagum',\n78 'Erlang',\n79 'Exponential',\n80 'FDistribution',\n81 'FisherZ',\n82 'Frechet',\n83 'Gamma',\n84 'GammaInverse',\n85 'Gompertz',\n86 'Gumbel',\n87 'Kumaraswamy',\n88 'Laplace',\n89 'Logistic',\n90 'LogNormal',\n91 'Maxwell',\n92 'Nakagami',\n93 'Normal',\n94 'Pareto',\n95 'QuadraticU',\n96 'RaisedCosine',\n97 'Rayleigh',\n98 'StudentT',\n99 'ShiftedGompertz',\n100 'Trapezoidal',\n101 'Triangular',\n102 'Uniform',\n103 'UniformSum',\n104 'VonMises',\n105 'Weibull',\n106 'WignerSemicircle'\n107 ]\n108 \n109 \n110 \n111 def ContinuousRV(symbol, density, set=Interval(-oo, oo)):\n112     \"\"\"\n113     Create a Continuous Random Variable given the following:\n114 \n115     -- a symbol\n116     -- a probability density function\n117     -- set on which the pdf is valid (defaults to entire real line)\n118 \n119     Returns a RandomSymbol.\n120 \n121     Many common continuous random variable types are already implemented.\n122     This function should be necessary only very rarely.\n123 \n124     Examples\n125     ========\n126 \n127     >>> from sympy import Symbol, sqrt, exp, pi\n128     >>> from sympy.stats import ContinuousRV, P, E\n129 \n130     >>> x = Symbol(\"x\")\n131 \n132     >>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution\n133     >>> X = ContinuousRV(x, pdf)\n134 \n135     >>> E(X)\n136     0\n137     >>> P(X>0)\n138     1/2\n139     \"\"\"\n140     pdf = Piecewise((density, set.as_relational(symbol)), (0, True))\n141     pdf = Lambda(symbol, pdf)\n142     dist = ContinuousDistributionHandmade(pdf, set)\n143     return SingleContinuousPSpace(symbol, dist).value\n144 \n145 \n146 def rv(symbol, cls, args):\n147     args = list(map(sympify, args))\n148     dist = cls(*args)\n149     dist.check(*args)\n150     pspace = SingleContinuousPSpace(symbol, dist)\n151     if any(isinstance(arg, RandomSymbol) for arg in args):\n152         pspace = JointPSpace(symbol, CompoundDistribution(dist))\n153     return pspace.value\n154 \n155 ########################################\n156 # Continuous Probability Distributions #\n157 ########################################\n158 \n159 #-------------------------------------------------------------------------------\n160 # Arcsin distribution ----------------------------------------------------------\n161 \n162 \n163 class ArcsinDistribution(SingleContinuousDistribution):\n164     _argnames = ('a', 'b')\n165 \n166     def pdf(self, x):\n167         return 1/(pi*sqrt((x - self.a)*(self.b - x)))\n168 \n169     def _cdf(self, x):\n170         from sympy import asin\n171         a, b = self.a, self.b\n172         return Piecewise(\n173             (S.Zero, x < a),\n174             (2*asin(sqrt((x - a)/(b - a)))/pi, x <= b),\n175             (S.One, True))\n176 \n177 \n178 def Arcsin(name, a=0, b=1):\n179     r\"\"\"\n180     Create a Continuous Random Variable with an arcsin distribution.\n181 \n182     The density of the arcsin distribution is given by\n183 \n184     .. math::\n185         f(x) := \\frac{1}{\\pi\\sqrt{(x-a)(b-x)}}\n186 \n187     with :math:`x \\in (a,b)`. It must hold that :math:`-\\infty < a < b < \\infty`.\n188 \n189     Parameters\n190     ==========\n191 \n192     a : Real number, the left interval boundary\n193     b : Real number, the right interval boundary\n194 \n195     Returns\n196     =======\n197 \n198     A RandomSymbol.\n199 \n200     Examples\n201     ========\n202 \n203     >>> from sympy.stats import Arcsin, density, cdf\n204     >>> from sympy import Symbol, simplify\n205 \n206     >>> a = Symbol(\"a\", real=True)\n207     >>> b = Symbol(\"b\", real=True)\n208     >>> z = Symbol(\"z\")\n209 \n210     >>> X = Arcsin(\"x\", a, b)\n211 \n212     >>> density(X)(z)\n213     1/(pi*sqrt((-a + z)*(b - z)))\n214 \n215     >>> cdf(X)(z)\n216     Piecewise((0, a > z),\n217             (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),\n218             (1, True))\n219 \n220 \n221     References\n222     ==========\n223 \n224     .. [1] https://en.wikipedia.org/wiki/Arcsine_distribution\n225 \n226     \"\"\"\n227 \n228     return rv(name, ArcsinDistribution, (a, b))\n229 \n230 #-------------------------------------------------------------------------------\n231 # Benini distribution ----------------------------------------------------------\n232 \n233 \n234 class BeniniDistribution(SingleContinuousDistribution):\n235     _argnames = ('alpha', 'beta', 'sigma')\n236 \n237     @staticmethod\n238     def check(alpha, beta, sigma):\n239         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n240         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n241         _value_check(sigma > 0, \"Scale parameter Sigma must be positive.\")\n242 \n243     @property\n244     def set(self):\n245         return Interval(self.sigma, oo)\n246 \n247     def pdf(self, x):\n248         alpha, beta, sigma = self.alpha, self.beta, self.sigma\n249         return (exp(-alpha*log(x/sigma) - beta*log(x/sigma)**2)\n250                *(alpha/x + 2*beta*log(x/sigma)/x))\n251 \n252     def _moment_generating_function(self, t):\n253         raise NotImplementedError('The moment generating function of the '\n254                                   'Benini distribution does not exist.')\n255 \n256 def Benini(name, alpha, beta, sigma):\n257     r\"\"\"\n258     Create a Continuous Random Variable with a Benini distribution.\n259 \n260     The density of the Benini distribution is given by\n261 \n262     .. math::\n263         f(x) := e^{-\\alpha\\log{\\frac{x}{\\sigma}}\n264                 -\\beta\\log^2\\left[{\\frac{x}{\\sigma}}\\right]}\n265                 \\left(\\frac{\\alpha}{x}+\\frac{2\\beta\\log{\\frac{x}{\\sigma}}}{x}\\right)\n266 \n267     This is a heavy-tailed distrubtion and is also known as the log-Rayleigh\n268     distribution.\n269 \n270     Parameters\n271     ==========\n272 \n273     alpha : Real number, `\\alpha > 0`, a shape\n274     beta : Real number, `\\beta > 0`, a shape\n275     sigma : Real number, `\\sigma > 0`, a scale\n276 \n277     Returns\n278     =======\n279 \n280     A RandomSymbol.\n281 \n282     Examples\n283     ========\n284 \n285     >>> from sympy.stats import Benini, density, cdf\n286     >>> from sympy import Symbol, simplify, pprint\n287 \n288     >>> alpha = Symbol(\"alpha\", positive=True)\n289     >>> beta = Symbol(\"beta\", positive=True)\n290     >>> sigma = Symbol(\"sigma\", positive=True)\n291     >>> z = Symbol(\"z\")\n292 \n293     >>> X = Benini(\"x\", alpha, beta, sigma)\n294 \n295     >>> D = density(X)(z)\n296     >>> pprint(D, use_unicode=False)\n297     /                  /  z  \\\\             /  z  \\            2/  z  \\\n298     |        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|\n299     |alpha             \\sigma/|             \\sigma/             \\sigma/\n300     |----- + -----------------|*e\n301     \\  z             z        /\n302 \n303     >>> cdf(X)(z)\n304     Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),\n305             (0, True))\n306 \n307 \n308     References\n309     ==========\n310 \n311     .. [1] https://en.wikipedia.org/wiki/Benini_distribution\n312     .. [2] http://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html\n313 \n314     \"\"\"\n315 \n316     return rv(name, BeniniDistribution, (alpha, beta, sigma))\n317 \n318 #-------------------------------------------------------------------------------\n319 # Beta distribution ------------------------------------------------------------\n320 \n321 \n322 class BetaDistribution(SingleContinuousDistribution):\n323     _argnames = ('alpha', 'beta')\n324 \n325     set = Interval(0, 1)\n326 \n327     @staticmethod\n328     def check(alpha, beta):\n329         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n330         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n331 \n332     def pdf(self, x):\n333         alpha, beta = self.alpha, self.beta\n334         return x**(alpha - 1) * (1 - x)**(beta - 1) / beta_fn(alpha, beta)\n335 \n336     def sample(self):\n337         return random.betavariate(self.alpha, self.beta)\n338 \n339     def _characteristic_function(self, t):\n340         return hyper((self.alpha,), (self.alpha + self.beta,), I*t)\n341 \n342     def _moment_generating_function(self, t):\n343         return hyper((self.alpha,), (self.alpha + self.beta,), t)\n344 \n345 def Beta(name, alpha, beta):\n346     r\"\"\"\n347     Create a Continuous Random Variable with a Beta distribution.\n348 \n349     The density of the Beta distribution is given by\n350 \n351     .. math::\n352         f(x) := \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)}\n353 \n354     with :math:`x \\in [0,1]`.\n355 \n356     Parameters\n357     ==========\n358 \n359     alpha : Real number, `\\alpha > 0`, a shape\n360     beta : Real number, `\\beta > 0`, a shape\n361 \n362     Returns\n363     =======\n364 \n365     A RandomSymbol.\n366 \n367     Examples\n368     ========\n369 \n370     >>> from sympy.stats import Beta, density, E, variance\n371     >>> from sympy import Symbol, simplify, pprint, factor\n372 \n373     >>> alpha = Symbol(\"alpha\", positive=True)\n374     >>> beta = Symbol(\"beta\", positive=True)\n375     >>> z = Symbol(\"z\")\n376 \n377     >>> X = Beta(\"x\", alpha, beta)\n378 \n379     >>> D = density(X)(z)\n380     >>> pprint(D, use_unicode=False)\n381      alpha - 1        beta - 1\n382     z         *(1 - z)\n383     --------------------------\n384           B(alpha, beta)\n385 \n386     >>> simplify(E(X))\n387     alpha/(alpha + beta)\n388 \n389     >>> factor(simplify(variance(X)))  #doctest: +SKIP\n390     alpha*beta/((alpha + beta)**2*(alpha + beta + 1))\n391 \n392     References\n393     ==========\n394 \n395     .. [1] https://en.wikipedia.org/wiki/Beta_distribution\n396     .. [2] http://mathworld.wolfram.com/BetaDistribution.html\n397 \n398     \"\"\"\n399 \n400     return rv(name, BetaDistribution, (alpha, beta))\n401 \n402 #-------------------------------------------------------------------------------\n403 # Noncentral Beta distribution ------------------------------------------------------------\n404 \n405 \n406 class BetaNoncentralDistribution(SingleContinuousDistribution):\n407     _argnames = ('alpha', 'beta', 'lamda')\n408 \n409     set = Interval(0, 1)\n410 \n411     @staticmethod\n412     def check(alpha, beta, lamda):\n413         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n414         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n415         _value_check(lamda >= 0, \"Noncentrality parameter Lambda must be positive\")\n416 \n417     def pdf(self, x):\n418         alpha, beta, lamda = self.alpha, self.beta, self.lamda\n419         k = Dummy(\"k\")\n420         return Sum(exp(-lamda / 2) * (lamda / 2)**k * x**(alpha + k - 1) *(\n421             1 - x)**(beta - 1) / (factorial(k) * beta_fn(alpha + k, beta)), (k, 0, oo))\n422 \n423 def BetaNoncentral(name, alpha, beta, lamda):\n424     r\"\"\"\n425     Create a Continuous Random Variable with a Type I Noncentral Beta distribution.\n426 \n427     The density of the Noncentral Beta distribution is given by\n428 \n429     .. math::\n430         f(x) := \\sum_{k=0}^\\infty e^{-\\lambda/2}\\frac{(\\lambda/2)^k}{k!}\n431                 \\frac{x^{\\alpha+k-1}(1-x)^{\\beta-1}}{\\mathrm{B}(\\alpha+k,\\beta)}\n432 \n433     with :math:`x \\in [0,1]`.\n434 \n435     Parameters\n436     ==========\n437 \n438     alpha : Real number, `\\alpha > 0`, a shape\n439     beta : Real number, `\\beta > 0`, a shape\n440     lamda: Real number, `\\lambda >= 0`, noncentrality parameter\n441 \n442     Returns\n443     =======\n444 \n445     A RandomSymbol.\n446 \n447     Examples\n448     ========\n449 \n450     >>> from sympy.stats import BetaNoncentral, density, cdf\n451     >>> from sympy import Symbol, pprint\n452 \n453     >>> alpha = Symbol(\"alpha\", positive=True)\n454     >>> beta = Symbol(\"beta\", positive=True)\n455     >>> lamda = Symbol(\"lamda\", nonnegative=True)\n456     >>> z = Symbol(\"z\")\n457 \n458     >>> X = BetaNoncentral(\"x\", alpha, beta, lamda)\n459 \n460     >>> D = density(X)(z)\n461     >>> pprint(D, use_unicode=False)\n462       oo\n463     _____\n464     \\    `\n465      \\                                              -lamda\n466       \\                          k                  -------\n467        \\    k + alpha - 1 /lamda\\         beta - 1     2\n468         )  z             *|-----| *(1 - z)        *e\n469        /                  \\  2  /\n470       /    ------------------------------------------------\n471      /                  B(k + alpha, beta)*k!\n472     /____,\n473     k = 0\n474 \n475     Compute cdf with specific 'x', 'alpha', 'beta' and 'lamda' values as follows :\n476     >>> cdf(BetaNoncentral(\"x\", 1, 1, 1), evaluate=False)(2).doit()\n477     exp(-1/2)*Integral(Sum(2**(-_k)*_x**_k/(beta(_k + 1, 1)*factorial(_k)), (_k, 0, oo)), (_x, 0, 2))\n478 \n479     The argument evaluate=False prevents an attempt at evaluation\n480     of the sum for general x, before the argument 2 is passed.\n481 \n482     References\n483     ==========\n484 \n485     .. [1] https://en.wikipedia.org/wiki/Noncentral_beta_distribution\n486     .. [2] https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html\n487 \n488     \"\"\"\n489 \n490     return rv(name, BetaNoncentralDistribution, (alpha, beta, lamda))\n491 \n492 \n493 #-------------------------------------------------------------------------------\n494 # Beta prime distribution ------------------------------------------------------\n495 \n496 \n497 class BetaPrimeDistribution(SingleContinuousDistribution):\n498     _argnames = ('alpha', 'beta')\n499 \n500     @staticmethod\n501     def check(alpha, beta):\n502         _value_check(alpha > 0, \"Shape parameter Alpha must be positive.\")\n503         _value_check(beta > 0, \"Shape parameter Beta must be positive.\")\n504 \n505     set = Interval(0, oo)\n506 \n507     def pdf(self, x):\n508         alpha, beta = self.alpha, self.beta\n509         return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)\n510 \n511 def BetaPrime(name, alpha, beta):\n512     r\"\"\"\n513     Create a continuous random variable with a Beta prime distribution.\n514 \n515     The density of the Beta prime distribution is given by\n516 \n517     .. math::\n518         f(x) := \\frac{x^{\\alpha-1} (1+x)^{-\\alpha -\\beta}}{B(\\alpha,\\beta)}\n519 \n520     with :math:`x > 0`.\n521 \n522     Parameters\n523     ==========\n524 \n525     alpha : Real number, `\\alpha > 0`, a shape\n526     beta : Real number, `\\beta > 0`, a shape\n527 \n528     Returns\n529     =======\n530 \n531     A RandomSymbol.\n532 \n533     Examples\n534     ========\n535 \n536     >>> from sympy.stats import BetaPrime, density\n537     >>> from sympy import Symbol, pprint\n538 \n539     >>> alpha = Symbol(\"alpha\", positive=True)\n540     >>> beta = Symbol(\"beta\", positive=True)\n541     >>> z = Symbol(\"z\")\n542 \n543     >>> X = BetaPrime(\"x\", alpha, beta)\n544 \n545     >>> D = density(X)(z)\n546     >>> pprint(D, use_unicode=False)\n547      alpha - 1        -alpha - beta\n548     z         *(z + 1)\n549     -------------------------------\n550              B(alpha, beta)\n551 \n552     References\n553     ==========\n554 \n555     .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution\n556     .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html\n557 \n558     \"\"\"\n559 \n560     return rv(name, BetaPrimeDistribution, (alpha, beta))\n561 \n562 #-------------------------------------------------------------------------------\n563 # Cauchy distribution ----------------------------------------------------------\n564 \n565 \n566 class CauchyDistribution(SingleContinuousDistribution):\n567     _argnames = ('x0', 'gamma')\n568 \n569     @staticmethod\n570     def check(x0, gamma):\n571         _value_check(gamma > 0, \"Scale parameter Gamma must be positive.\")\n572 \n573     def pdf(self, x):\n574         return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))\n575 \n576     def _cdf(self, x):\n577         x0, gamma = self.x0, self.gamma\n578         return (1/pi)*atan((x - x0)/gamma) + S.Half\n579 \n580     def _characteristic_function(self, t):\n581         return exp(self.x0 * I * t -  self.gamma * Abs(t))\n582 \n583     def _moment_generating_function(self, t):\n584         raise NotImplementedError(\"The moment generating function for the \"\n585                                   \"Cauchy distribution does not exist.\")\n586 \n587     def _quantile(self, p):\n588         return self.x0 + self.gamma*tan(pi*(p - S.Half))\n589 \n590 def Cauchy(name, x0, gamma):\n591     r\"\"\"\n592     Create a continuous random variable with a Cauchy distribution.\n593 \n594     The density of the Cauchy distribution is given by\n595 \n596     .. math::\n597         f(x) := \\frac{1}{\\pi \\gamma [1 + {(\\frac{x-x_0}{\\gamma})}^2]}\n598 \n599     Parameters\n600     ==========\n601 \n602     x0 : Real number, the location\n603     gamma : Real number, `\\gamma > 0`, a scale\n604 \n605     Returns\n606     =======\n607 \n608     A RandomSymbol.\n609 \n610     Examples\n611     ========\n612 \n613     >>> from sympy.stats import Cauchy, density\n614     >>> from sympy import Symbol\n615 \n616     >>> x0 = Symbol(\"x0\")\n617     >>> gamma = Symbol(\"gamma\", positive=True)\n618     >>> z = Symbol(\"z\")\n619 \n620     >>> X = Cauchy(\"x\", x0, gamma)\n621 \n622     >>> density(X)(z)\n623     1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2))\n624 \n625     References\n626     ==========\n627 \n628     .. [1] https://en.wikipedia.org/wiki/Cauchy_distribution\n629     .. [2] http://mathworld.wolfram.com/CauchyDistribution.html\n630 \n631     \"\"\"\n632 \n633     return rv(name, CauchyDistribution, (x0, gamma))\n634 \n635 #-------------------------------------------------------------------------------\n636 # Chi distribution -------------------------------------------------------------\n637 \n638 \n639 class ChiDistribution(SingleContinuousDistribution):\n640     _argnames = ('k',)\n641 \n642     @staticmethod\n643     def check(k):\n644         _value_check(k > 0, \"Number of degrees of freedom (k) must be positive.\")\n645         _value_check(k.is_integer, \"Number of degrees of freedom (k) must be an integer.\")\n646 \n647     set = Interval(0, oo)\n648 \n649     def pdf(self, x):\n650         return 2**(1 - self.k/2)*x**(self.k - 1)*exp(-x**2/2)/gamma(self.k/2)\n651 \n652     def _characteristic_function(self, t):\n653         k = self.k\n654 \n655         part_1 = hyper((k/2,), (S(1)/2,), -t**2/2)\n656         part_2 = I*t*sqrt(2)*gamma((k+1)/2)/gamma(k/2)\n657         part_3 = hyper(((k+1)/2,), (S(3)/2,), -t**2/2)\n658         return part_1 + part_2*part_3\n659 \n660     def _moment_generating_function(self, t):\n661         k = self.k\n662 \n663         part_1 = hyper((k / 2,), (S(1) / 2,), t ** 2 / 2)\n664         part_2 = t * sqrt(2) * gamma((k + 1) / 2) / gamma(k / 2)\n665         part_3 = hyper(((k + 1) / 2,), (S(3) / 2,), t ** 2 / 2)\n666         return part_1 + part_2 * part_3\n667 \n668 def Chi(name, k):\n669     r\"\"\"\n670     Create a continuous random variable with a Chi distribution.\n671 \n672     The density of the Chi distribution is given by\n673 \n674     .. math::\n675         f(x) := \\frac{2^{1-k/2}x^{k-1}e^{-x^2/2}}{\\Gamma(k/2)}\n676 \n677     with :math:`x \\geq 0`.\n678 \n679     Parameters\n680     ==========\n681 \n682     k : Positive integer, The number of degrees of freedom\n683 \n684     Returns\n685     =======\n686 \n687     A RandomSymbol.\n688 \n689     Examples\n690     ========\n691 \n692     >>> from sympy.stats import Chi, density, E\n693     >>> from sympy import Symbol, simplify\n694 \n695     >>> k = Symbol(\"k\", integer=True)\n696     >>> z = Symbol(\"z\")\n697 \n698     >>> X = Chi(\"x\", k)\n699 \n700     >>> density(X)(z)\n701     2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2)\n702 \n703     >>> simplify(E(X))\n704     sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2)\n705 \n706     References\n707     ==========\n708 \n709     .. [1] https://en.wikipedia.org/wiki/Chi_distribution\n710     .. [2] http://mathworld.wolfram.com/ChiDistribution.html\n711 \n712     \"\"\"\n713 \n714     return rv(name, ChiDistribution, (k,))\n715 \n716 #-------------------------------------------------------------------------------\n717 # Non-central Chi distribution -------------------------------------------------\n718 \n719 \n720 class ChiNoncentralDistribution(SingleContinuousDistribution):\n721     _argnames = ('k', 'l')\n722 \n723     @staticmethod\n724     def check(k, l):\n725         _value_check(k > 0, \"Number of degrees of freedom (k) must be positive.\")\n726         _value_check(k.is_integer, \"Number of degrees of freedom (k) must be an integer.\")\n727         _value_check(l > 0, \"Shift parameter Lambda must be positive.\")\n728 \n729     set = Interval(0, oo)\n730 \n731     def pdf(self, x):\n732         k, l = self.k, self.l\n733         return exp(-(x**2+l**2)/2)*x**k*l / (l*x)**(k/2) * besseli(k/2-1, l*x)\n734 \n735 def ChiNoncentral(name, k, l):\n736     r\"\"\"\n737     Create a continuous random variable with a non-central Chi distribution.\n738 \n739     The density of the non-central Chi distribution is given by\n740 \n741     .. math::\n742         f(x) := \\frac{e^{-(x^2+\\lambda^2)/2} x^k\\lambda}\n743                 {(\\lambda x)^{k/2}} I_{k/2-1}(\\lambda x)\n744 \n745     with `x \\geq 0`. Here, `I_\\nu (x)` is the\n746     :ref:`modified Bessel function of the first kind <besseli>`.\n747 \n748     Parameters\n749     ==========\n750 \n751     k : A positive Integer, `k > 0`, the number of degrees of freedom\n752     lambda : Real number, `\\lambda > 0`, Shift parameter\n753 \n754     Returns\n755     =======\n756 \n757     A RandomSymbol.\n758 \n759     Examples\n760     ========\n761 \n762     >>> from sympy.stats import ChiNoncentral, density\n763     >>> from sympy import Symbol\n764 \n765     >>> k = Symbol(\"k\", integer=True)\n766     >>> l = Symbol(\"l\")\n767     >>> z = Symbol(\"z\")\n768 \n769     >>> X = ChiNoncentral(\"x\", k, l)\n770 \n771     >>> density(X)(z)\n772     l*z**k*(l*z)**(-k/2)*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)\n773 \n774     References\n775     ==========\n776 \n777     .. [1] https://en.wikipedia.org/wiki/Noncentral_chi_distribution\n778     \"\"\"\n779 \n780     return rv(name, ChiNoncentralDistribution, (k, l))\n781 \n782 #-------------------------------------------------------------------------------\n783 # Chi squared distribution -----------------------------------------------------\n784 \n785 \n786 class ChiSquaredDistribution(SingleContinuousDistribution):\n787     _argnames = ('k',)\n788 \n789     @staticmethod\n790     def check(k):\n791         _value_check(k > 0, \"Number of degrees of freedom (k) must be positive.\")\n792         _value_check(k.is_integer, \"Number of degrees of freedom (k) must be an integer.\")\n793 \n794     set = Interval(0, oo)\n795 \n796     def pdf(self, x):\n797         k = self.k\n798         return 1/(2**(k/2)*gamma(k/2))*x**(k/2 - 1)*exp(-x/2)\n799 \n800     def _cdf(self, x):\n801         k = self.k\n802         return Piecewise(\n803                 (S.One/gamma(k/2)*lowergamma(k/2, x/2), x >= 0),\n804                 (0, True)\n805         )\n806 \n807     def _characteristic_function(self, t):\n808         return (1 - 2*I*t)**(-self.k/2)\n809 \n810     def  _moment_generating_function(self, t):\n811         return (1 - 2*t)**(-self.k/2)\n812 \n813 def ChiSquared(name, k):\n814     r\"\"\"\n815     Create a continuous random variable with a Chi-squared distribution.\n816 \n817     The density of the Chi-squared distribution is given by\n818 \n819     .. math::\n820         f(x) := \\frac{1}{2^{\\frac{k}{2}}\\Gamma\\left(\\frac{k}{2}\\right)}\n821                 x^{\\frac{k}{2}-1} e^{-\\frac{x}{2}}\n822 \n823     with :math:`x \\geq 0`.\n824 \n825     Parameters\n826     ==========\n827 \n828     k : Positive integer, The number of degrees of freedom\n829 \n830     Returns\n831     =======\n832 \n833     A RandomSymbol.\n834 \n835     Examples\n836     ========\n837 \n838     >>> from sympy.stats import ChiSquared, density, E, variance, moment\n839     >>> from sympy import Symbol\n840 \n841     >>> k = Symbol(\"k\", integer=True, positive=True)\n842     >>> z = Symbol(\"z\")\n843 \n844     >>> X = ChiSquared(\"x\", k)\n845 \n846     >>> density(X)(z)\n847     2**(-k/2)*z**(k/2 - 1)*exp(-z/2)/gamma(k/2)\n848 \n849     >>> E(X)\n850     k\n851 \n852     >>> variance(X)\n853     2*k\n854 \n855     >>> moment(X, 3)\n856     k**3 + 6*k**2 + 8*k\n857 \n858     References\n859     ==========\n860 \n861     .. [1] https://en.wikipedia.org/wiki/Chi_squared_distribution\n862     .. [2] http://mathworld.wolfram.com/Chi-SquaredDistribution.html\n863     \"\"\"\n864 \n865     return rv(name, ChiSquaredDistribution, (k, ))\n866 \n867 #-------------------------------------------------------------------------------\n868 # Dagum distribution -----------------------------------------------------------\n869 \n870 \n871 class DagumDistribution(SingleContinuousDistribution):\n872     _argnames = ('p', 'a', 'b')\n873 \n874     @staticmethod\n875     def check(p, a, b):\n876         _value_check(p > 0, \"Shape parameter p must be positive.\")\n877         _value_check(a > 0, \"Shape parameter a must be positive.\")\n878         _value_check(b > 0, \"Scale parameter b must be positive.\")\n879 \n880     def pdf(self, x):\n881         p, a, b = self.p, self.a, self.b\n882         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))\n883 \n884     def _cdf(self, x):\n885         p, a, b = self.p, self.a, self.b\n886         return Piecewise(((S.One + (S(x)/b)**-a)**-p, x>=0),\n887                     (S.Zero, True))\n888 \n889 def Dagum(name, p, a, b):\n890     r\"\"\"\n891     Create a continuous random variable with a Dagum distribution.\n892 \n893     The density of the Dagum distribution is given by\n894 \n895     .. math::\n896         f(x) := \\frac{a p}{x} \\left( \\frac{\\left(\\tfrac{x}{b}\\right)^{a p}}\n897                 {\\left(\\left(\\tfrac{x}{b}\\right)^a + 1 \\right)^{p+1}} \\right)\n898 \n899     with :math:`x > 0`.\n900 \n901     Parameters\n902     ==========\n903 \n904     p : Real number, `p > 0`, a shape\n905     a : Real number, `a > 0`, a shape\n906     b : Real number, `b > 0`, a scale\n907 \n908     Returns\n909     =======\n910 \n911     A RandomSymbol.\n912 \n913     Examples\n914     ========\n915 \n916     >>> from sympy.stats import Dagum, density, cdf\n917     >>> from sympy import Symbol\n918 \n919     >>> p = Symbol(\"p\", positive=True)\n920     >>> a = Symbol(\"a\", positive=True)\n921     >>> b = Symbol(\"b\", positive=True)\n922     >>> z = Symbol(\"z\")\n923 \n924     >>> X = Dagum(\"x\", p, a, b)\n925 \n926     >>> density(X)(z)\n927     a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z\n928 \n929     >>> cdf(X)(z)\n930     Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True))\n931 \n932 \n933     References\n934     ==========\n935 \n936     .. [1] https://en.wikipedia.org/wiki/Dagum_distribution\n937 \n938     \"\"\"\n939 \n940     return rv(name, DagumDistribution, (p, a, b))\n941 \n942 #-------------------------------------------------------------------------------\n943 # Erlang distribution ----------------------------------------------------------\n944 \n945 \n946 def Erlang(name, k, l):\n947     r\"\"\"\n948     Create a continuous random variable with an Erlang distribution.\n949 \n950     The density of the Erlang distribution is given by\n951 \n952     .. math::\n953         f(x) := \\frac{\\lambda^k x^{k-1} e^{-\\lambda x}}{(k-1)!}\n954 \n955     with :math:`x \\in [0,\\infty]`.\n956 \n957     Parameters\n958     ==========\n959 \n960     k : Positive integer\n961     l : Real number, `\\lambda > 0`, the rate\n962 \n963     Returns\n964     =======\n965 \n966     A RandomSymbol.\n967 \n968     Examples\n969     ========\n970 \n971     >>> from sympy.stats import Erlang, density, cdf, E, variance\n972     >>> from sympy import Symbol, simplify, pprint\n973 \n974     >>> k = Symbol(\"k\", integer=True, positive=True)\n975     >>> l = Symbol(\"l\", positive=True)\n976     >>> z = Symbol(\"z\")\n977 \n978     >>> X = Erlang(\"x\", k, l)\n979 \n980     >>> D = density(X)(z)\n981     >>> pprint(D, use_unicode=False)\n982      k  k - 1  -l*z\n983     l *z     *e\n984     ---------------\n985         Gamma(k)\n986 \n987     >>> C = cdf(X)(z)\n988     >>> pprint(C, use_unicode=False)\n989     /lowergamma(k, l*z)\n990     |------------------  for z > 0\n991     <     Gamma(k)\n992     |\n993     \\        0           otherwise\n994 \n995 \n996     >>> E(X)\n997     k/l\n998 \n999     >>> simplify(variance(X))\n1000     k/l**2\n1001 \n1002     References\n1003     ==========\n1004 \n1005     .. [1] https://en.wikipedia.org/wiki/Erlang_distribution\n1006     .. [2] http://mathworld.wolfram.com/ErlangDistribution.html\n1007 \n1008     \"\"\"\n1009 \n1010     return rv(name, GammaDistribution, (k, S.One/l))\n1011 \n1012 #-------------------------------------------------------------------------------\n1013 # Exponential distribution -----------------------------------------------------\n1014 \n1015 \n1016 class ExponentialDistribution(SingleContinuousDistribution):\n1017     _argnames = ('rate',)\n1018 \n1019     set  = Interval(0, oo)\n1020 \n1021     @staticmethod\n1022     def check(rate):\n1023         _value_check(rate > 0, \"Rate must be positive.\")\n1024 \n1025     def pdf(self, x):\n1026         return self.rate * exp(-self.rate*x)\n1027 \n1028     def sample(self):\n1029         return random.expovariate(self.rate)\n1030 \n1031     def _cdf(self, x):\n1032         return Piecewise(\n1033                 (S.One - exp(-self.rate*x), x >= 0),\n1034                 (0, True),\n1035         )\n1036 \n1037     def _characteristic_function(self, t):\n1038         rate = self.rate\n1039         return rate / (rate - I*t)\n1040 \n1041     def _moment_generating_function(self, t):\n1042         rate = self.rate\n1043         return rate / (rate - t)\n1044 \n1045     def _quantile(self, p):\n1046         return -log(1-p)/self.rate\n1047 \n1048 def Exponential(name, rate):\n1049     r\"\"\"\n1050     Create a continuous random variable with an Exponential distribution.\n1051 \n1052     The density of the exponential distribution is given by\n1053 \n1054     .. math::\n1055         f(x) := \\lambda \\exp(-\\lambda x)\n1056 \n1057     with `x > 0`. Note that the expected value is `1/\\lambda`.\n1058 \n1059     Parameters\n1060     ==========\n1061 \n1062     rate : A positive Real number, `\\lambda > 0`, the rate (or inverse scale/inverse mean)\n1063 \n1064     Returns\n1065     =======\n1066 \n1067     A RandomSymbol.\n1068 \n1069     Examples\n1070     ========\n1071 \n1072     >>> from sympy.stats import Exponential, density, cdf, E\n1073     >>> from sympy.stats import variance, std, skewness, quantile\n1074     >>> from sympy import Symbol, symbols\n1075 \n1076     >>> l = Symbol(\"lambda\", positive=True)\n1077     >>> z = Symbol(\"z\")\n1078     >>> p = Symbol(\"p\")\n1079     >>> X = Exponential(\"x\", l)\n1080 \n1081     >>> density(X)(z)\n1082     lambda*exp(-lambda*z)\n1083 \n1084     >>> cdf(X)(z)\n1085     Piecewise((1 - exp(-lambda*z), z >= 0), (0, True))\n1086 \n1087     >>> quantile(X)(p)\n1088     -log(1 - p)/lambda\n1089 \n1090     >>> E(X)\n1091     1/lambda\n1092 \n1093     >>> variance(X)\n1094     lambda**(-2)\n1095 \n1096     >>> skewness(X)\n1097     2\n1098 \n1099     >>> X = Exponential('x', 10)\n1100 \n1101     >>> density(X)(z)\n1102     10*exp(-10*z)\n1103 \n1104     >>> E(X)\n1105     1/10\n1106 \n1107     >>> std(X)\n1108     1/10\n1109 \n1110     References\n1111     ==========\n1112 \n1113     .. [1] https://en.wikipedia.org/wiki/Exponential_distribution\n1114     .. [2] http://mathworld.wolfram.com/ExponentialDistribution.html\n1115 \n1116     \"\"\"\n1117 \n1118     return rv(name, ExponentialDistribution, (rate, ))\n1119 \n1120 #-------------------------------------------------------------------------------\n1121 # F distribution ---------------------------------------------------------------\n1122 \n1123 \n1124 class FDistributionDistribution(SingleContinuousDistribution):\n1125     _argnames = ('d1', 'd2')\n1126 \n1127     set = Interval(0, oo)\n1128 \n1129     @staticmethod\n1130     def check(d1, d2):\n1131         _value_check((d1 > 0, d1.is_integer),\n1132             \"Degrees of freedom d1 must be positive integer.\")\n1133         _value_check((d2 > 0, d2.is_integer),\n1134             \"Degrees of freedom d2 must be positive integer.\")\n1135 \n1136     def pdf(self, x):\n1137         d1, d2 = self.d1, self.d2\n1138         return (sqrt((d1*x)**d1*d2**d2 / (d1*x+d2)**(d1+d2))\n1139                / (x * beta_fn(d1/2, d2/2)))\n1140 \n1141     def _moment_generating_function(self, t):\n1142         raise NotImplementedError('The moment generating function for the '\n1143                                   'F-distribution does not exist.')\n1144 \n1145 def FDistribution(name, d1, d2):\n1146     r\"\"\"\n1147     Create a continuous random variable with a F distribution.\n1148 \n1149     The density of the F distribution is given by\n1150 \n1151     .. math::\n1152         f(x) := \\frac{\\sqrt{\\frac{(d_1 x)^{d_1} d_2^{d_2}}\n1153                 {(d_1 x + d_2)^{d_1 + d_2}}}}\n1154                 {x \\mathrm{B} \\left(\\frac{d_1}{2}, \\frac{d_2}{2}\\right)}\n1155 \n1156     with :math:`x > 0`.\n1157 \n1158     Parameters\n1159     ==========\n1160 \n1161     d1 : `d_1 > 0`, where d_1 is the degrees of freedom (n_1 - 1)\n1162     d2 : `d_2 > 0`, where d_2 is the degrees of freedom (n_2 - 1)\n1163 \n1164     Returns\n1165     =======\n1166 \n1167     A RandomSymbol.\n1168 \n1169     Examples\n1170     ========\n1171 \n1172     >>> from sympy.stats import FDistribution, density\n1173     >>> from sympy import Symbol, simplify, pprint\n1174 \n1175     >>> d1 = Symbol(\"d1\", positive=True)\n1176     >>> d2 = Symbol(\"d2\", positive=True)\n1177     >>> z = Symbol(\"z\")\n1178 \n1179     >>> X = FDistribution(\"x\", d1, d2)\n1180 \n1181     >>> D = density(X)(z)\n1182     >>> pprint(D, use_unicode=False)\n1183       d2\n1184       --    ______________________________\n1185       2    /       d1            -d1 - d2\n1186     d2  *\\/  (d1*z)  *(d1*z + d2)\n1187     --------------------------------------\n1188                     /d1  d2\\\n1189                  z*B|--, --|\n1190                     \\2   2 /\n1191 \n1192     References\n1193     ==========\n1194 \n1195     .. [1] https://en.wikipedia.org/wiki/F-distribution\n1196     .. [2] http://mathworld.wolfram.com/F-Distribution.html\n1197 \n1198     \"\"\"\n1199 \n1200     return rv(name, FDistributionDistribution, (d1, d2))\n1201 \n1202 #-------------------------------------------------------------------------------\n1203 # Fisher Z distribution --------------------------------------------------------\n1204 \n1205 class FisherZDistribution(SingleContinuousDistribution):\n1206     _argnames = ('d1', 'd2')\n1207 \n1208     def pdf(self, x):\n1209         d1, d2 = self.d1, self.d2\n1210         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *\n1211                exp(d1*x) / (d1*exp(2*x)+d2)**((d1+d2)/2))\n1212 \n1213 def FisherZ(name, d1, d2):\n1214     r\"\"\"\n1215     Create a Continuous Random Variable with an Fisher's Z distribution.\n1216 \n1217     The density of the Fisher's Z distribution is given by\n1218 \n1219     .. math::\n1220         f(x) := \\frac{2d_1^{d_1/2} d_2^{d_2/2}} {\\mathrm{B}(d_1/2, d_2/2)}\n1221                 \\frac{e^{d_1z}}{\\left(d_1e^{2z}+d_2\\right)^{\\left(d_1+d_2\\right)/2}}\n1222 \n1223 \n1224     .. TODO - What is the difference between these degrees of freedom?\n1225 \n1226     Parameters\n1227     ==========\n1228 \n1229     d1 : `d_1 > 0`, degree of freedom\n1230     d2 : `d_2 > 0`, degree of freedom\n1231 \n1232     Returns\n1233     =======\n1234 \n1235     A RandomSymbol.\n1236 \n1237     Examples\n1238     ========\n1239 \n1240     >>> from sympy.stats import FisherZ, density\n1241     >>> from sympy import Symbol, simplify, pprint\n1242 \n1243     >>> d1 = Symbol(\"d1\", positive=True)\n1244     >>> d2 = Symbol(\"d2\", positive=True)\n1245     >>> z = Symbol(\"z\")\n1246 \n1247     >>> X = FisherZ(\"x\", d1, d2)\n1248 \n1249     >>> D = density(X)(z)\n1250     >>> pprint(D, use_unicode=False)\n1251                                 d1   d2\n1252         d1   d2               - -- - --\n1253         --   --                 2    2\n1254         2    2  /    2*z     \\           d1*z\n1255     2*d1  *d2  *\\d1*e    + d2/         *e\n1256     -----------------------------------------\n1257                      /d1  d2\\\n1258                     B|--, --|\n1259                      \\2   2 /\n1260 \n1261     References\n1262     ==========\n1263 \n1264     .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution\n1265     .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html\n1266 \n1267     \"\"\"\n1268 \n1269     return rv(name, FisherZDistribution, (d1, d2))\n1270 \n1271 #-------------------------------------------------------------------------------\n1272 # Frechet distribution ---------------------------------------------------------\n1273 \n1274 class FrechetDistribution(SingleContinuousDistribution):\n1275     _argnames = ('a', 's', 'm')\n1276 \n1277     set = Interval(0, oo)\n1278 \n1279     def __new__(cls, a, s=1, m=0):\n1280         a, s, m = list(map(sympify, (a, s, m)))\n1281         return Basic.__new__(cls, a, s, m)\n1282 \n1283     def pdf(self, x):\n1284         a, s, m = self.a, self.s, self.m\n1285         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))\n1286 \n1287     def _cdf(self, x):\n1288         a, s, m = self.a, self.s, self.m\n1289         return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),\n1290                         (S.Zero, True))\n1291 \n1292 def Frechet(name, a, s=1, m=0):\n1293     r\"\"\"\n1294     Create a continuous random variable with a Frechet distribution.\n1295 \n1296     The density of the Frechet distribution is given by\n1297 \n1298     .. math::\n1299         f(x) := \\frac{\\alpha}{s} \\left(\\frac{x-m}{s}\\right)^{-1-\\alpha}\n1300                  e^{-(\\frac{x-m}{s})^{-\\alpha}}\n1301 \n1302     with :math:`x \\geq m`.\n1303 \n1304     Parameters\n1305     ==========\n1306 \n1307     a : Real number, :math:`a \\in \\left(0, \\infty\\right)` the shape\n1308     s : Real number, :math:`s \\in \\left(0, \\infty\\right)` the scale\n1309     m : Real number, :math:`m \\in \\left(-\\infty, \\infty\\right)` the minimum\n1310 \n1311     Returns\n1312     =======\n1313 \n1314     A RandomSymbol.\n1315 \n1316     Examples\n1317     ========\n1318 \n1319     >>> from sympy.stats import Frechet, density, E, std, cdf\n1320     >>> from sympy import Symbol, simplify\n1321 \n1322     >>> a = Symbol(\"a\", positive=True)\n1323     >>> s = Symbol(\"s\", positive=True)\n1324     >>> m = Symbol(\"m\", real=True)\n1325     >>> z = Symbol(\"z\")\n1326 \n1327     >>> X = Frechet(\"x\", a, s, m)\n1328 \n1329     >>> density(X)(z)\n1330     a*((-m + z)/s)**(-a - 1)*exp(-((-m + z)/s)**(-a))/s\n1331 \n1332     >>> cdf(X)(z)\n1333      Piecewise((exp(-((-m + z)/s)**(-a)), m <= z), (0, True))\n1334 \n1335     References\n1336     ==========\n1337 \n1338     .. [1] https://en.wikipedia.org/wiki/Fr%C3%A9chet_distribution\n1339 \n1340     \"\"\"\n1341 \n1342     return rv(name, FrechetDistribution, (a, s, m))\n1343 \n1344 #-------------------------------------------------------------------------------\n1345 # Gamma distribution -----------------------------------------------------------\n1346 \n1347 \n1348 class GammaDistribution(SingleContinuousDistribution):\n1349     _argnames = ('k', 'theta')\n1350 \n1351     set = Interval(0, oo)\n1352 \n1353     @staticmethod\n1354     def check(k, theta):\n1355         _value_check(k > 0, \"k must be positive\")\n1356         _value_check(theta > 0, \"Theta must be positive\")\n1357 \n1358     def pdf(self, x):\n1359         k, theta = self.k, self.theta\n1360         return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)\n1361 \n1362     def sample(self):\n1363         return random.gammavariate(self.k, self.theta)\n1364 \n1365     def _cdf(self, x):\n1366         k, theta = self.k, self.theta\n1367         return Piecewise(\n1368                     (lowergamma(k, S(x)/theta)/gamma(k), x > 0),\n1369                     (S.Zero, True))\n1370 \n1371     def _characteristic_function(self, t):\n1372         return (1 - self.theta*I*t)**(-self.k)\n1373 \n1374     def _moment_generating_function(self, t):\n1375         return (1- self.theta*t)**(-self.k)\n1376 \n1377 def Gamma(name, k, theta):\n1378     r\"\"\"\n1379     Create a continuous random variable with a Gamma distribution.\n1380 \n1381     The density of the Gamma distribution is given by\n1382 \n1383     .. math::\n1384         f(x) := \\frac{1}{\\Gamma(k) \\theta^k} x^{k - 1} e^{-\\frac{x}{\\theta}}\n1385 \n1386     with :math:`x \\in [0,1]`.\n1387 \n1388     Parameters\n1389     ==========\n1390 \n1391     k : Real number, `k > 0`, a shape\n1392     theta : Real number, `\\theta > 0`, a scale\n1393 \n1394     Returns\n1395     =======\n1396 \n1397     A RandomSymbol.\n1398 \n1399     Examples\n1400     ========\n1401 \n1402     >>> from sympy.stats import Gamma, density, cdf, E, variance\n1403     >>> from sympy import Symbol, pprint, simplify\n1404 \n1405     >>> k = Symbol(\"k\", positive=True)\n1406     >>> theta = Symbol(\"theta\", positive=True)\n1407     >>> z = Symbol(\"z\")\n1408 \n1409     >>> X = Gamma(\"x\", k, theta)\n1410 \n1411     >>> D = density(X)(z)\n1412     >>> pprint(D, use_unicode=False)\n1413                       -z\n1414                     -----\n1415          -k  k - 1  theta\n1416     theta  *z     *e\n1417     ---------------------\n1418            Gamma(k)\n1419 \n1420     >>> C = cdf(X, meijerg=True)(z)\n1421     >>> pprint(C, use_unicode=False)\n1422     /            /     z  \\\n1423     |k*lowergamma|k, -----|\n1424     |            \\   theta/\n1425     <----------------------  for z >= 0\n1426     |     Gamma(k + 1)\n1427     |\n1428     \\          0             otherwise\n1429 \n1430     >>> E(X)\n1431     k*theta\n1432 \n1433     >>> V = simplify(variance(X))\n1434     >>> pprint(V, use_unicode=False)\n1435            2\n1436     k*theta\n1437 \n1438 \n1439     References\n1440     ==========\n1441 \n1442     .. [1] https://en.wikipedia.org/wiki/Gamma_distribution\n1443     .. [2] http://mathworld.wolfram.com/GammaDistribution.html\n1444 \n1445     \"\"\"\n1446 \n1447     return rv(name, GammaDistribution, (k, theta))\n1448 \n1449 #-------------------------------------------------------------------------------\n1450 # Inverse Gamma distribution ---------------------------------------------------\n1451 \n1452 \n1453 class GammaInverseDistribution(SingleContinuousDistribution):\n1454     _argnames = ('a', 'b')\n1455 \n1456     set = Interval(0, oo)\n1457 \n1458     @staticmethod\n1459     def check(a, b):\n1460         _value_check(a > 0, \"alpha must be positive\")\n1461         _value_check(b > 0, \"beta must be positive\")\n1462 \n1463     def pdf(self, x):\n1464         a, b = self.a, self.b\n1465         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)\n1466 \n1467     def _cdf(self, x):\n1468         a, b = self.a, self.b\n1469         return Piecewise((uppergamma(a,b/x)/gamma(a), x > 0),\n1470                         (S.Zero, True))\n1471 \n1472     def sample(self):\n1473         scipy = import_module('scipy')\n1474         if scipy:\n1475             from scipy.stats import invgamma\n1476             return invgamma.rvs(float(self.a), 0, float(self.b))\n1477         else:\n1478             raise NotImplementedError('Sampling the inverse Gamma Distribution requires Scipy.')\n1479 \n1480     def _characteristic_function(self, t):\n1481         a, b = self.a, self.b\n1482         return 2 * (-I*b*t)**(a/2) * besselk(sqrt(-4*I*b*t)) / gamma(a)\n1483 \n1484     def _moment_generating_function(self, t):\n1485         raise NotImplementedError('The moment generating function for the '\n1486                                   'gamma inverse distribution does not exist.')\n1487 \n1488 def GammaInverse(name, a, b):\n1489     r\"\"\"\n1490     Create a continuous random variable with an inverse Gamma distribution.\n1491 \n1492     The density of the inverse Gamma distribution is given by\n1493 \n1494     .. math::\n1495         f(x) := \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{-\\alpha - 1}\n1496                 \\exp\\left(\\frac{-\\beta}{x}\\right)\n1497 \n1498     with :math:`x > 0`.\n1499 \n1500     Parameters\n1501     ==========\n1502 \n1503     a : Real number, `a > 0` a shape\n1504     b : Real number, `b > 0` a scale\n1505 \n1506     Returns\n1507     =======\n1508 \n1509     A RandomSymbol.\n1510 \n1511     Examples\n1512     ========\n1513 \n1514     >>> from sympy.stats import GammaInverse, density, cdf, E, variance\n1515     >>> from sympy import Symbol, pprint\n1516 \n1517     >>> a = Symbol(\"a\", positive=True)\n1518     >>> b = Symbol(\"b\", positive=True)\n1519     >>> z = Symbol(\"z\")\n1520 \n1521     >>> X = GammaInverse(\"x\", a, b)\n1522 \n1523     >>> D = density(X)(z)\n1524     >>> pprint(D, use_unicode=False)\n1525                 -b\n1526                 ---\n1527      a  -a - 1   z\n1528     b *z      *e\n1529     ---------------\n1530        Gamma(a)\n1531 \n1532     >>> cdf(X)(z)\n1533     Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))\n1534 \n1535 \n1536     References\n1537     ==========\n1538 \n1539     .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution\n1540 \n1541     \"\"\"\n1542 \n1543     return rv(name, GammaInverseDistribution, (a, b))\n1544 \n1545 #-------------------------------------------------------------------------------\n1546 # Gumbel distribution --------------------------------------------------------\n1547 \n1548 \n1549 class GumbelDistribution(SingleContinuousDistribution):\n1550     _argnames = ('beta', 'mu')\n1551 \n1552     set = Interval(-oo, oo)\n1553 \n1554     def pdf(self, x):\n1555         beta, mu = self.beta, self.mu\n1556         z = (x - mu)/beta\n1557         return (1/beta)*exp(-(z + exp(-z)))\n1558 \n1559     def _cdf(self, x):\n1560         beta, mu = self.beta, self.mu\n1561         return exp(-exp((mu - x)/beta))\n1562 \n1563     def _characteristic_function(self, t):\n1564         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)\n1565 \n1566     def _moment_generating_function(self, t):\n1567         return gamma(1 - self.beta*t) * exp(I*self.mu*t)\n1568 \n1569 def Gumbel(name, beta, mu):\n1570     r\"\"\"\n1571     Create a Continuous Random Variable with Gumbel distribution.\n1572 \n1573     The density of the Gumbel distribution is given by\n1574 \n1575     .. math::\n1576         f(x) := \\dfrac{1}{\\beta} \\exp \\left( -\\dfrac{x-\\mu}{\\beta}\n1577                 - \\exp \\left( -\\dfrac{x - \\mu}{\\beta} \\right) \\right)\n1578 \n1579     with :math:`x \\in [ - \\infty, \\infty ]`.\n1580 \n1581     Parameters\n1582     ==========\n1583 \n1584     mu: Real number, 'mu' is a location\n1585     beta: Real number, 'beta > 0' is a scale\n1586 \n1587     Returns\n1588     ==========\n1589 \n1590     A RandomSymbol\n1591 \n1592     Examples\n1593     ==========\n1594     >>> from sympy.stats import Gumbel, density, E, variance, cdf\n1595     >>> from sympy import Symbol, simplify, pprint\n1596     >>> x = Symbol(\"x\")\n1597     >>> mu = Symbol(\"mu\")\n1598     >>> beta = Symbol(\"beta\", positive=True)\n1599     >>> X = Gumbel(\"x\", beta, mu)\n1600     >>> density(X)(x)\n1601     exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta\n1602     >>> cdf(X)(x)\n1603     exp(-exp((mu - x)/beta))\n1604 \n1605     References\n1606     ==========\n1607 \n1608     .. [1] http://mathworld.wolfram.com/GumbelDistribution.html\n1609     .. [2] https://en.wikipedia.org/wiki/Gumbel_distribution\n1610 \n1611     \"\"\"\n1612     return rv(name, GumbelDistribution, (beta, mu))\n1613 \n1614 #-------------------------------------------------------------------------------\n1615 # Gompertz distribution --------------------------------------------------------\n1616 \n1617 class GompertzDistribution(SingleContinuousDistribution):\n1618     _argnames = ('b', 'eta')\n1619 \n1620     set = Interval(0, oo)\n1621 \n1622     @staticmethod\n1623     def check(b, eta):\n1624         _value_check(b > 0, \"b must be positive\")\n1625         _value_check(eta > 0, \"eta must be positive\")\n1626 \n1627     def pdf(self, x):\n1628         eta, b = self.eta, self.b\n1629         return b*eta*exp(b*x)*exp(eta)*exp(-eta*exp(b*x))\n1630 \n1631     def _cdf(self, x):\n1632         eta, b = self.eta, self.b\n1633         return 1 - exp(eta)*exp(-eta*exp(b*x))\n1634 \n1635     def _moment_generating_function(self, t):\n1636         eta, b = self.eta, self.b\n1637         return eta * exp(eta) * expint(t/b, eta)\n1638 \n1639 def Gompertz(name, b, eta):\n1640     r\"\"\"\n1641     Create a Continuous Random Variable with Gompertz distribution.\n1642 \n1643     The density of the Gompertz distribution is given by\n1644 \n1645     .. math::\n1646         f(x) := b \\eta e^{b x} e^{\\eta} \\exp \\left(-\\eta e^{bx} \\right)\n1647 \n1648     with :math: 'x \\in [0, \\inf)'.\n1649 \n1650     Parameters\n1651     ==========\n1652 \n1653     b: Real number, 'b > 0' a scale\n1654     eta: Real number, 'eta > 0' a shape\n1655 \n1656     Returns\n1657     =======\n1658 \n1659     A RandomSymbol.\n1660 \n1661     Examples\n1662     ========\n1663 \n1664     >>> from sympy.stats import Gompertz, density, E, variance\n1665     >>> from sympy import Symbol, simplify, pprint\n1666 \n1667     >>> b = Symbol(\"b\", positive=True)\n1668     >>> eta = Symbol(\"eta\", positive=True)\n1669     >>> z = Symbol(\"z\")\n1670 \n1671     >>> X = Gompertz(\"x\", b, eta)\n1672 \n1673     >>> density(X)(z)\n1674     b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z))\n1675 \n1676     References\n1677     ==========\n1678 \n1679     .. [1] https://en.wikipedia.org/wiki/Gompertz_distribution\n1680 \n1681     \"\"\"\n1682     return rv(name, GompertzDistribution, (b, eta))\n1683 \n1684 #-------------------------------------------------------------------------------\n1685 # Kumaraswamy distribution -----------------------------------------------------\n1686 \n1687 \n1688 class KumaraswamyDistribution(SingleContinuousDistribution):\n1689     _argnames = ('a', 'b')\n1690 \n1691     set = Interval(0, oo)\n1692 \n1693     @staticmethod\n1694     def check(a, b):\n1695         _value_check(a > 0, \"a must be positive\")\n1696         _value_check(b > 0, \"b must be positive\")\n1697 \n1698     def pdf(self, x):\n1699         a, b = self.a, self.b\n1700         return a * b * x**(a-1) * (1-x**a)**(b-1)\n1701 \n1702     def _cdf(self, x):\n1703         a, b = self.a, self.b\n1704         return Piecewise(\n1705             (S.Zero, x < S.Zero),\n1706             (1 - (1 - x**a)**b, x <= S.One),\n1707             (S.One, True))\n1708 \n1709 def Kumaraswamy(name, a, b):\n1710     r\"\"\"\n1711     Create a Continuous Random Variable with a Kumaraswamy distribution.\n1712 \n1713     The density of the Kumaraswamy distribution is given by\n1714 \n1715     .. math::\n1716         f(x) := a b x^{a-1} (1-x^a)^{b-1}\n1717 \n1718     with :math:`x \\in [0,1]`.\n1719 \n1720     Parameters\n1721     ==========\n1722 \n1723     a : Real number, `a > 0` a shape\n1724     b : Real number, `b > 0` a shape\n1725 \n1726     Returns\n1727     =======\n1728 \n1729     A RandomSymbol.\n1730 \n1731     Examples\n1732     ========\n1733 \n1734     >>> from sympy.stats import Kumaraswamy, density, E, variance, cdf\n1735     >>> from sympy import Symbol, simplify, pprint\n1736 \n1737     >>> a = Symbol(\"a\", positive=True)\n1738     >>> b = Symbol(\"b\", positive=True)\n1739     >>> z = Symbol(\"z\")\n1740 \n1741     >>> X = Kumaraswamy(\"x\", a, b)\n1742 \n1743     >>> D = density(X)(z)\n1744     >>> pprint(D, use_unicode=False)\n1745                        b - 1\n1746          a - 1 /     a\\\n1747     a*b*z     *\\1 - z /\n1748 \n1749     >>> cdf(X)(z)\n1750     Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True))\n1751 \n1752     References\n1753     ==========\n1754 \n1755     .. [1] https://en.wikipedia.org/wiki/Kumaraswamy_distribution\n1756 \n1757     \"\"\"\n1758 \n1759     return rv(name, KumaraswamyDistribution, (a, b))\n1760 \n1761 #-------------------------------------------------------------------------------\n1762 # Laplace distribution ---------------------------------------------------------\n1763 \n1764 \n1765 class LaplaceDistribution(SingleContinuousDistribution):\n1766     _argnames = ('mu', 'b')\n1767 \n1768     def pdf(self, x):\n1769         mu, b = self.mu, self.b\n1770         return 1/(2*b)*exp(-Abs(x - mu)/b)\n1771 \n1772     def _cdf(self, x):\n1773         mu, b = self.mu, self.b\n1774         return Piecewise(\n1775                     (S.Half*exp((x - mu)/b), x < mu),\n1776                     (S.One - S.Half*exp(-(x - mu)/b), x >= mu)\n1777                         )\n1778 \n1779     def _characteristic_function(self, t):\n1780         return exp(self.mu*I*t) / (1 + self.b**2*t**2)\n1781 \n1782     def _moment_generating_function(self, t):\n1783         return exp(self.mu*t) / (1 - self.b**2*t**2)\n1784 \n1785 def Laplace(name, mu, b):\n1786     r\"\"\"\n1787     Create a continuous random variable with a Laplace distribution.\n1788 \n1789     The density of the Laplace distribution is given by\n1790 \n1791     .. math::\n1792         f(x) := \\frac{1}{2 b} \\exp \\left(-\\frac{|x-\\mu|}b \\right)\n1793 \n1794     Parameters\n1795     ==========\n1796 \n1797     mu : Real number or a list/matrix, the location (mean) or the\n1798         location vector\n1799     b : Real number or a positive definite matrix, representing a scale\n1800         or the covariance matrix.\n1801 \n1802     Returns\n1803     =======\n1804 \n1805     A RandomSymbol.\n1806 \n1807     Examples\n1808     ========\n1809 \n1810     >>> from sympy.stats import Laplace, density, cdf\n1811     >>> from sympy import Symbol, pprint\n1812 \n1813     >>> mu = Symbol(\"mu\")\n1814     >>> b = Symbol(\"b\", positive=True)\n1815     >>> z = Symbol(\"z\")\n1816 \n1817     >>> X = Laplace(\"x\", mu, b)\n1818 \n1819     >>> density(X)(z)\n1820     exp(-Abs(mu - z)/b)/(2*b)\n1821 \n1822     >>> cdf(X)(z)\n1823     Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True))\n1824 \n1825     >>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])\n1826     >>> pprint(density(L)(1, 2), use_unicode=False)\n1827      5        /     ____\\\n1828     e *besselk\\0, \\/ 35 /\n1829     ---------------------\n1830               pi\n1831 \n1832     References\n1833     ==========\n1834 \n1835     .. [1] https://en.wikipedia.org/wiki/Laplace_distribution\n1836     .. [2] http://mathworld.wolfram.com/LaplaceDistribution.html\n1837 \n1838     \"\"\"\n1839 \n1840     if isinstance(mu, (list, MatrixBase)) and\\\n1841         isinstance(b, (list, MatrixBase)):\n1842         from sympy.stats.joint_rv_types import MultivariateLaplaceDistribution\n1843         return multivariate_rv(\n1844             MultivariateLaplaceDistribution, name, mu, b)\n1845 \n1846     return rv(name, LaplaceDistribution, (mu, b))\n1847 \n1848 #-------------------------------------------------------------------------------\n1849 # Logistic distribution --------------------------------------------------------\n1850 \n1851 \n1852 class LogisticDistribution(SingleContinuousDistribution):\n1853     _argnames = ('mu', 's')\n1854 \n1855     def pdf(self, x):\n1856         mu, s = self.mu, self.s\n1857         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)\n1858 \n1859     def _cdf(self, x):\n1860         mu, s = self.mu, self.s\n1861         return S.One/(1 + exp(-(x - mu)/s))\n1862 \n1863     def _characteristic_function(self, t):\n1864         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))\n1865 \n1866     def _moment_generating_function(self, t):\n1867         return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)\n1868 \n1869     def _quantile(self, p):\n1870         return self.mu - self.s*log(-S.One + S.One/p)\n1871 \n1872 def Logistic(name, mu, s):\n1873     r\"\"\"\n1874     Create a continuous random variable with a logistic distribution.\n1875 \n1876     The density of the logistic distribution is given by\n1877 \n1878     .. math::\n1879         f(x) := \\frac{e^{-(x-\\mu)/s}} {s\\left(1+e^{-(x-\\mu)/s}\\right)^2}\n1880 \n1881     Parameters\n1882     ==========\n1883 \n1884     mu : Real number, the location (mean)\n1885     s : Real number, `s > 0` a scale\n1886 \n1887     Returns\n1888     =======\n1889 \n1890     A RandomSymbol.\n1891 \n1892     Examples\n1893     ========\n1894 \n1895     >>> from sympy.stats import Logistic, density, cdf\n1896     >>> from sympy import Symbol\n1897 \n1898     >>> mu = Symbol(\"mu\", real=True)\n1899     >>> s = Symbol(\"s\", positive=True)\n1900     >>> z = Symbol(\"z\")\n1901 \n1902     >>> X = Logistic(\"x\", mu, s)\n1903 \n1904     >>> density(X)(z)\n1905     exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2)\n1906 \n1907     >>> cdf(X)(z)\n1908     1/(exp((mu - z)/s) + 1)\n1909 \n1910     References\n1911     ==========\n1912 \n1913     .. [1] https://en.wikipedia.org/wiki/Logistic_distribution\n1914     .. [2] http://mathworld.wolfram.com/LogisticDistribution.html\n1915 \n1916     \"\"\"\n1917 \n1918     return rv(name, LogisticDistribution, (mu, s))\n1919 \n1920 #-------------------------------------------------------------------------------\n1921 # Log Normal distribution ------------------------------------------------------\n1922 \n1923 \n1924 class LogNormalDistribution(SingleContinuousDistribution):\n1925     _argnames = ('mean', 'std')\n1926 \n1927     set = Interval(0, oo)\n1928 \n1929     def pdf(self, x):\n1930         mean, std = self.mean, self.std\n1931         return exp(-(log(x) - mean)**2 / (2*std**2)) / (x*sqrt(2*pi)*std)\n1932 \n1933     def sample(self):\n1934         return random.lognormvariate(self.mean, self.std)\n1935 \n1936     def _cdf(self, x):\n1937         mean, std = self.mean, self.std\n1938         return Piecewise(\n1939                 (S.Half + S.Half*erf((log(x) - mean)/sqrt(2)/std), x > 0),\n1940                 (S.Zero, True)\n1941         )\n1942 \n1943     def _moment_generating_function(self, t):\n1944         raise NotImplementedError('Moment generating function of the log-normal distribution is not defined.')\n1945 \n1946 def LogNormal(name, mean, std):\n1947     r\"\"\"\n1948     Create a continuous random variable with a log-normal distribution.\n1949 \n1950     The density of the log-normal distribution is given by\n1951 \n1952     .. math::\n1953         f(x) := \\frac{1}{x\\sqrt{2\\pi\\sigma^2}}\n1954                 e^{-\\frac{\\left(\\ln x-\\mu\\right)^2}{2\\sigma^2}}\n1955 \n1956     with :math:`x \\geq 0`.\n1957 \n1958     Parameters\n1959     ==========\n1960 \n1961     mu : Real number, the log-scale\n1962     sigma : Real number, :math:`\\sigma^2 > 0` a shape\n1963 \n1964     Returns\n1965     =======\n1966 \n1967     A RandomSymbol.\n1968 \n1969     Examples\n1970     ========\n1971 \n1972     >>> from sympy.stats import LogNormal, density\n1973     >>> from sympy import Symbol, simplify, pprint\n1974 \n1975     >>> mu = Symbol(\"mu\", real=True)\n1976     >>> sigma = Symbol(\"sigma\", positive=True)\n1977     >>> z = Symbol(\"z\")\n1978 \n1979     >>> X = LogNormal(\"x\", mu, sigma)\n1980 \n1981     >>> D = density(X)(z)\n1982     >>> pprint(D, use_unicode=False)\n1983                           2\n1984            -(-mu + log(z))\n1985            -----------------\n1986                       2\n1987       ___      2*sigma\n1988     \\/ 2 *e\n1989     ------------------------\n1990             ____\n1991         2*\\/ pi *sigma*z\n1992 \n1993 \n1994     >>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1\n1995 \n1996     >>> density(X)(z)\n1997     sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z)\n1998 \n1999     References\n2000     ==========\n2001 \n2002     .. [1] https://en.wikipedia.org/wiki/Lognormal\n2003     .. [2] http://mathworld.wolfram.com/LogNormalDistribution.html\n2004 \n2005     \"\"\"\n2006 \n2007     return rv(name, LogNormalDistribution, (mean, std))\n2008 \n2009 #-------------------------------------------------------------------------------\n2010 # Maxwell distribution ---------------------------------------------------------\n2011 \n2012 \n2013 class MaxwellDistribution(SingleContinuousDistribution):\n2014     _argnames = ('a',)\n2015 \n2016     set = Interval(0, oo)\n2017 \n2018     def pdf(self, x):\n2019         a = self.a\n2020         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3\n2021 \n2022     def _cdf(self, x):\n2023         a = self.a\n2024         return erf(sqrt(2)*x/(2*a)) - sqrt(2)*x*exp(-x**2/(2*a**2))/(sqrt(pi)*a)\n2025 \n2026 def Maxwell(name, a):\n2027     r\"\"\"\n2028     Create a continuous random variable with a Maxwell distribution.\n2029 \n2030     The density of the Maxwell distribution is given by\n2031 \n2032     .. math::\n2033         f(x) := \\sqrt{\\frac{2}{\\pi}} \\frac{x^2 e^{-x^2/(2a^2)}}{a^3}\n2034 \n2035     with :math:`x \\geq 0`.\n2036 \n2037     .. TODO - what does the parameter mean?\n2038 \n2039     Parameters\n2040     ==========\n2041 \n2042     a : Real number, `a > 0`\n2043 \n2044     Returns\n2045     =======\n2046 \n2047     A RandomSymbol.\n2048 \n2049     Examples\n2050     ========\n2051 \n2052     >>> from sympy.stats import Maxwell, density, E, variance\n2053     >>> from sympy import Symbol, simplify\n2054 \n2055     >>> a = Symbol(\"a\", positive=True)\n2056     >>> z = Symbol(\"z\")\n2057 \n2058     >>> X = Maxwell(\"x\", a)\n2059 \n2060     >>> density(X)(z)\n2061     sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)\n2062 \n2063     >>> E(X)\n2064     2*sqrt(2)*a/sqrt(pi)\n2065 \n2066     >>> simplify(variance(X))\n2067     a**2*(-8 + 3*pi)/pi\n2068 \n2069     References\n2070     ==========\n2071 \n2072     .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution\n2073     .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html\n2074 \n2075     \"\"\"\n2076 \n2077     return rv(name, MaxwellDistribution, (a, ))\n2078 \n2079 #-------------------------------------------------------------------------------\n2080 # Nakagami distribution --------------------------------------------------------\n2081 \n2082 \n2083 class NakagamiDistribution(SingleContinuousDistribution):\n2084     _argnames = ('mu', 'omega')\n2085 \n2086     set = Interval(0, oo)\n2087 \n2088     def pdf(self, x):\n2089         mu, omega = self.mu, self.omega\n2090         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)\n2091 \n2092     def _cdf(self, x):\n2093         mu, omega = self.mu, self.omega\n2094         return Piecewise(\n2095                     (lowergamma(mu, (mu/omega)*x**2)/gamma(mu), x > 0),\n2096                     (S.Zero, True))\n2097 \n2098 def Nakagami(name, mu, omega):\n2099     r\"\"\"\n2100     Create a continuous random variable with a Nakagami distribution.\n2101 \n2102     The density of the Nakagami distribution is given by\n2103 \n2104     .. math::\n2105         f(x) := \\frac{2\\mu^\\mu}{\\Gamma(\\mu)\\omega^\\mu} x^{2\\mu-1}\n2106                 \\exp\\left(-\\frac{\\mu}{\\omega}x^2 \\right)\n2107 \n2108     with :math:`x > 0`.\n2109 \n2110     Parameters\n2111     ==========\n2112 \n2113     mu : Real number, `\\mu \\geq \\frac{1}{2}` a shape\n2114     omega : Real number, `\\omega > 0`, the spread\n2115 \n2116     Returns\n2117     =======\n2118 \n2119     A RandomSymbol.\n2120 \n2121     Examples\n2122     ========\n2123 \n2124     >>> from sympy.stats import Nakagami, density, E, variance, cdf\n2125     >>> from sympy import Symbol, simplify, pprint\n2126 \n2127     >>> mu = Symbol(\"mu\", positive=True)\n2128     >>> omega = Symbol(\"omega\", positive=True)\n2129     >>> z = Symbol(\"z\")\n2130 \n2131     >>> X = Nakagami(\"x\", mu, omega)\n2132 \n2133     >>> D = density(X)(z)\n2134     >>> pprint(D, use_unicode=False)\n2135                                     2\n2136                                -mu*z\n2137                                -------\n2138         mu      -mu  2*mu - 1  omega\n2139     2*mu  *omega   *z        *e\n2140     ----------------------------------\n2141                 Gamma(mu)\n2142 \n2143     >>> simplify(E(X))\n2144     sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1)\n2145 \n2146     >>> V = simplify(variance(X))\n2147     >>> pprint(V, use_unicode=False)\n2148                         2\n2149              omega*Gamma (mu + 1/2)\n2150     omega - -----------------------\n2151             Gamma(mu)*Gamma(mu + 1)\n2152 \n2153     >>> cdf(X)(z)\n2154     Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),\n2155             (0, True))\n2156 \n2157 \n2158     References\n2159     ==========\n2160 \n2161     .. [1] https://en.wikipedia.org/wiki/Nakagami_distribution\n2162 \n2163     \"\"\"\n2164 \n2165     return rv(name, NakagamiDistribution, (mu, omega))\n2166 \n2167 #-------------------------------------------------------------------------------\n2168 # Normal distribution ----------------------------------------------------------\n2169 \n2170 \n2171 class NormalDistribution(SingleContinuousDistribution):\n2172     _argnames = ('mean', 'std')\n2173 \n2174     @staticmethod\n2175     def check(mean, std):\n2176         _value_check(std > 0, \"Standard deviation must be positive\")\n2177 \n2178     def pdf(self, x):\n2179         return exp(-(x - self.mean)**2 / (2*self.std**2)) / (sqrt(2*pi)*self.std)\n2180 \n2181     def sample(self):\n2182         return random.normalvariate(self.mean, self.std)\n2183 \n2184     def _cdf(self, x):\n2185         mean, std = self.mean, self.std\n2186         return erf(sqrt(2)*(-mean + x)/(2*std))/2 + S.Half\n2187 \n2188     def _characteristic_function(self, t):\n2189         mean, std = self.mean, self.std\n2190         return exp(I*mean*t - std**2*t**2/2)\n2191 \n2192     def _moment_generating_function(self, t):\n2193         mean, std = self.mean, self.std\n2194         return exp(mean*t + std**2*t**2/2)\n2195 \n2196     def _quantile(self, p):\n2197         mean, std = self.mean, self.std\n2198         return mean + std*sqrt(2)*erfinv(2*p - 1)\n2199 \n2200 def Normal(name, mean, std):\n2201     r\"\"\"\n2202     Create a continuous random variable with a Normal distribution.\n2203 \n2204     The density of the Normal distribution is given by\n2205 \n2206     .. math::\n2207         f(x) := \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{ -\\frac{(x-\\mu)^2}{2\\sigma^2} }\n2208 \n2209     Parameters\n2210     ==========\n2211 \n2212     mu : Real number or a list representing the mean or the mean vector\n2213     sigma : Real number or a positive definite sqaure matrix,\n2214          :math:`\\sigma^2 > 0` the variance\n2215 \n2216     Returns\n2217     =======\n2218 \n2219     A RandomSymbol.\n2220 \n2221     Examples\n2222     ========\n2223 \n2224     >>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile\n2225     >>> from sympy import Symbol, simplify, pprint, factor, together, factor_terms\n2226 \n2227     >>> mu = Symbol(\"mu\")\n2228     >>> sigma = Symbol(\"sigma\", positive=True)\n2229     >>> z = Symbol(\"z\")\n2230     >>> y = Symbol(\"y\")\n2231     >>> p = Symbol(\"p\")\n2232     >>> X = Normal(\"x\", mu, sigma)\n2233 \n2234     >>> density(X)(z)\n2235     sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma)\n2236 \n2237     >>> C = simplify(cdf(X))(z) # it needs a little more help...\n2238     >>> pprint(C, use_unicode=False)\n2239        /  ___          \\\n2240        |\\/ 2 *(-mu + z)|\n2241     erf|---------------|\n2242        \\    2*sigma    /   1\n2243     -------------------- + -\n2244              2             2\n2245 \n2246     >>> quantile(X)(p)\n2247     mu + sqrt(2)*sigma*erfinv(2*p - 1)\n2248 \n2249     >>> simplify(skewness(X))\n2250     0\n2251 \n2252     >>> X = Normal(\"x\", 0, 1) # Mean 0, standard deviation 1\n2253     >>> density(X)(z)\n2254     sqrt(2)*exp(-z**2/2)/(2*sqrt(pi))\n2255 \n2256     >>> E(2*X + 1)\n2257     1\n2258 \n2259     >>> simplify(std(2*X + 1))\n2260     2\n2261 \n2262     >>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])\n2263     >>> from sympy.stats.joint_rv import marginal_distribution\n2264     >>> pprint(density(m)(y, z))\n2265            /1   y\\ /2*y   z\\   /    z\\ /  y   2*z    \\\n2266            |- - -|*|--- - -| + |1 - -|*|- - + --- - 1|\n2267       ___  \\2   2/ \\ 3    3/   \\    2/ \\  3    3     /\n2268     \\/ 3 *e\n2269     --------------------------------------------------\n2270                            6*pi\n2271 \n2272     >>> marginal_distribution(m, m[0])(1)\n2273      1/(2*sqrt(pi))\n2274 \n2275 \n2276     References\n2277     ==========\n2278 \n2279     .. [1] https://en.wikipedia.org/wiki/Normal_distribution\n2280     .. [2] http://mathworld.wolfram.com/NormalDistributionFunction.html\n2281 \n2282     \"\"\"\n2283 \n2284     if isinstance(mean, (list, MatrixBase)) and\\\n2285         isinstance(std, (list, MatrixBase)):\n2286         from sympy.stats.joint_rv_types import MultivariateNormalDistribution\n2287         return multivariate_rv(\n2288             MultivariateNormalDistribution, name, mean, std)\n2289     return rv(name, NormalDistribution, (mean, std))\n2290 \n2291 #-------------------------------------------------------------------------------\n2292 # Pareto distribution ----------------------------------------------------------\n2293 \n2294 \n2295 class ParetoDistribution(SingleContinuousDistribution):\n2296     _argnames = ('xm', 'alpha')\n2297 \n2298     @property\n2299     def set(self):\n2300         return Interval(self.xm, oo)\n2301 \n2302     @staticmethod\n2303     def check(xm, alpha):\n2304         _value_check(xm > 0, \"Xm must be positive\")\n2305         _value_check(alpha > 0, \"Alpha must be positive\")\n2306 \n2307     def pdf(self, x):\n2308         xm, alpha = self.xm, self.alpha\n2309         return alpha * xm**alpha / x**(alpha + 1)\n2310 \n2311     def sample(self):\n2312         return random.paretovariate(self.alpha)\n2313 \n2314     def _cdf(self, x):\n2315         xm, alpha = self.xm, self.alpha\n2316         return Piecewise(\n2317                 (S.One - xm**alpha/x**alpha, x>=xm),\n2318                 (0, True),\n2319         )\n2320 \n2321     def _moment_generating_function(self, t):\n2322         xm, alpha = self.xm, self.alpha\n2323         return alpha * (-xm*t)**alpha * uppergamma(-alpha, -xm*t)\n2324 \n2325     def _characteristic_function(self, t):\n2326         xm, alpha = self.xm, self.alpha\n2327         return alpha * (-I * xm * t) ** alpha * uppergamma(-alpha, -I * xm * t)\n2328 \n2329 \n2330 def Pareto(name, xm, alpha):\n2331     r\"\"\"\n2332     Create a continuous random variable with the Pareto distribution.\n2333 \n2334     The density of the Pareto distribution is given by\n2335 \n2336     .. math::\n2337         f(x) := \\frac{\\alpha\\,x_m^\\alpha}{x^{\\alpha+1}}\n2338 \n2339     with :math:`x \\in [x_m,\\infty]`.\n2340 \n2341     Parameters\n2342     ==========\n2343 \n2344     xm : Real number, `x_m > 0`, a scale\n2345     alpha : Real number, `\\alpha > 0`, a shape\n2346 \n2347     Returns\n2348     =======\n2349 \n2350     A RandomSymbol.\n2351 \n2352     Examples\n2353     ========\n2354 \n2355     >>> from sympy.stats import Pareto, density\n2356     >>> from sympy import Symbol\n2357 \n2358     >>> xm = Symbol(\"xm\", positive=True)\n2359     >>> beta = Symbol(\"beta\", positive=True)\n2360     >>> z = Symbol(\"z\")\n2361 \n2362     >>> X = Pareto(\"x\", xm, beta)\n2363 \n2364     >>> density(X)(z)\n2365     beta*xm**beta*z**(-beta - 1)\n2366 \n2367     References\n2368     ==========\n2369 \n2370     .. [1] https://en.wikipedia.org/wiki/Pareto_distribution\n2371     .. [2] http://mathworld.wolfram.com/ParetoDistribution.html\n2372 \n2373     \"\"\"\n2374 \n2375     return rv(name, ParetoDistribution, (xm, alpha))\n2376 \n2377 #-------------------------------------------------------------------------------\n2378 # QuadraticU distribution ------------------------------------------------------\n2379 \n2380 \n2381 class QuadraticUDistribution(SingleContinuousDistribution):\n2382     _argnames = ('a', 'b')\n2383 \n2384     @property\n2385     def set(self):\n2386         return Interval(self.a, self.b)\n2387 \n2388     def pdf(self, x):\n2389         a, b = self.a, self.b\n2390         alpha = 12 / (b-a)**3\n2391         beta = (a+b) / 2\n2392         return Piecewise(\n2393                   (alpha * (x-beta)**2, And(a<=x, x<=b)),\n2394                   (S.Zero, True))\n2395 \n2396     def _moment_generating_function(self, t):\n2397         a, b = self.a, self.b\n2398 \n2399         return -3 * (exp(a*t) * (4  + (a**2 + 2*a*(-2 + b) + b**2) * t) - exp(b*t) * (4 + (-4*b + (a + b)**2) * t)) / ((a-b)**3 * t**2)\n2400 \n2401     def _characteristic_function(self, t):\n2402         def _moment_generating_function(self, t):\n2403             a, b = self.a, self.b\n2404 \n2405             return -3*I*(exp(I*a*t*exp(I*b*t)) * (4*I - (-4*b + (a+b)**2)*t)) / ((a-b)**3 * t**2)\n2406 \n2407 \n2408 def QuadraticU(name, a, b):\n2409     r\"\"\"\n2410     Create a Continuous Random Variable with a U-quadratic distribution.\n2411 \n2412     The density of the U-quadratic distribution is given by\n2413 \n2414     .. math::\n2415         f(x) := \\alpha (x-\\beta)^2\n2416 \n2417     with :math:`x \\in [a,b]`.\n2418 \n2419     Parameters\n2420     ==========\n2421 \n2422     a : Real number\n2423     b : Real number, :math:`a < b`\n2424 \n2425     Returns\n2426     =======\n2427 \n2428     A RandomSymbol.\n2429 \n2430     Examples\n2431     ========\n2432 \n2433     >>> from sympy.stats import QuadraticU, density, E, variance\n2434     >>> from sympy import Symbol, simplify, factor, pprint\n2435 \n2436     >>> a = Symbol(\"a\", real=True)\n2437     >>> b = Symbol(\"b\", real=True)\n2438     >>> z = Symbol(\"z\")\n2439 \n2440     >>> X = QuadraticU(\"x\", a, b)\n2441 \n2442     >>> D = density(X)(z)\n2443     >>> pprint(D, use_unicode=False)\n2444     /                2\n2445     |   /  a   b    \\\n2446     |12*|- - - - + z|\n2447     |   \\  2   2    /\n2448     <-----------------  for And(b >= z, a <= z)\n2449     |            3\n2450     |    (-a + b)\n2451     |\n2452     \\        0                 otherwise\n2453 \n2454     References\n2455     ==========\n2456 \n2457     .. [1] https://en.wikipedia.org/wiki/U-quadratic_distribution\n2458 \n2459     \"\"\"\n2460 \n2461     return rv(name, QuadraticUDistribution, (a, b))\n2462 \n2463 #-------------------------------------------------------------------------------\n2464 # RaisedCosine distribution ----------------------------------------------------\n2465 \n2466 \n2467 class RaisedCosineDistribution(SingleContinuousDistribution):\n2468     _argnames = ('mu', 's')\n2469 \n2470     @property\n2471     def set(self):\n2472         return Interval(self.mu - self.s, self.mu + self.s)\n2473 \n2474     @staticmethod\n2475     def check(mu, s):\n2476         _value_check(s > 0, \"s must be positive\")\n2477 \n2478     def pdf(self, x):\n2479         mu, s = self.mu, self.s\n2480         return Piecewise(\n2481                 ((1+cos(pi*(x-mu)/s)) / (2*s), And(mu-s<=x, x<=mu+s)),\n2482                 (S.Zero, True))\n2483 \n2484     def _characteristic_function(self, t):\n2485         mu, s = self.mu, self.s\n2486         return Piecewise((exp(-I*pi*mu/s)/2, Eq(t, -pi/s)),\n2487                          (exp(I*pi*mu/s)/2, Eq(t, pi/s)),\n2488                          (pi**2*sin(s*t)*exp(I*mu*t) / (s*t*(pi**2 - s**2*t**2)), True))\n2489 \n2490     def _moment_generating_function(self, t):\n2491         mu, s = self.mu, self.s\n2492         return pi**2 * sinh(s*t) * exp(mu*t) /  (s*t*(pi**2 + s**2*t**2))\n2493 \n2494 def RaisedCosine(name, mu, s):\n2495     r\"\"\"\n2496     Create a Continuous Random Variable with a raised cosine distribution.\n2497 \n2498     The density of the raised cosine distribution is given by\n2499 \n2500     .. math::\n2501         f(x) := \\frac{1}{2s}\\left(1+\\cos\\left(\\frac{x-\\mu}{s}\\pi\\right)\\right)\n2502 \n2503     with :math:`x \\in [\\mu-s,\\mu+s]`.\n2504 \n2505     Parameters\n2506     ==========\n2507 \n2508     mu : Real number\n2509     s : Real number, `s > 0`\n2510 \n2511     Returns\n2512     =======\n2513 \n2514     A RandomSymbol.\n2515 \n2516     Examples\n2517     ========\n2518 \n2519     >>> from sympy.stats import RaisedCosine, density, E, variance\n2520     >>> from sympy import Symbol, simplify, pprint\n2521 \n2522     >>> mu = Symbol(\"mu\", real=True)\n2523     >>> s = Symbol(\"s\", positive=True)\n2524     >>> z = Symbol(\"z\")\n2525 \n2526     >>> X = RaisedCosine(\"x\", mu, s)\n2527 \n2528     >>> D = density(X)(z)\n2529     >>> pprint(D, use_unicode=False)\n2530     /   /pi*(-mu + z)\\\n2531     |cos|------------| + 1\n2532     |   \\     s      /\n2533     <---------------------  for And(z >= mu - s, z <= mu + s)\n2534     |         2*s\n2535     |\n2536     \\          0                        otherwise\n2537 \n2538     References\n2539     ==========\n2540 \n2541     .. [1] https://en.wikipedia.org/wiki/Raised_cosine_distribution\n2542 \n2543     \"\"\"\n2544 \n2545     return rv(name, RaisedCosineDistribution, (mu, s))\n2546 \n2547 #-------------------------------------------------------------------------------\n2548 # Rayleigh distribution --------------------------------------------------------\n2549 \n2550 \n2551 class RayleighDistribution(SingleContinuousDistribution):\n2552     _argnames = ('sigma',)\n2553 \n2554     set = Interval(0, oo)\n2555 \n2556     def pdf(self, x):\n2557         sigma = self.sigma\n2558         return x/sigma**2*exp(-x**2/(2*sigma**2))\n2559 \n2560     def _cdf(self, x):\n2561         sigma = self.sigma\n2562         return 1 - exp(-(x**2/(2*sigma**2)))\n2563 \n2564     def _characteristic_function(self, t):\n2565         sigma = self.sigma\n2566         return 1 - sigma*t*exp(-sigma**2*t**2/2) * sqrt(pi/2) * (erfi(sigma*t/sqrt(2)) - I)\n2567 \n2568     def _moment_generating_function(self, t):\n2569         sigma = self.sigma\n2570         return 1 + sigma*t*exp(sigma**2*t**2/2) * sqrt(pi/2) * (erf(sigma*t/sqrt(2)) + 1)\n2571 \n2572 \n2573 def Rayleigh(name, sigma):\n2574     r\"\"\"\n2575     Create a continuous random variable with a Rayleigh distribution.\n2576 \n2577     The density of the Rayleigh distribution is given by\n2578 \n2579     .. math ::\n2580         f(x) := \\frac{x}{\\sigma^2} e^{-x^2/2\\sigma^2}\n2581 \n2582     with :math:`x > 0`.\n2583 \n2584     Parameters\n2585     ==========\n2586 \n2587     sigma : Real number, `\\sigma > 0`\n2588 \n2589     Returns\n2590     =======\n2591 \n2592     A RandomSymbol.\n2593 \n2594     Examples\n2595     ========\n2596 \n2597     >>> from sympy.stats import Rayleigh, density, E, variance\n2598     >>> from sympy import Symbol, simplify\n2599 \n2600     >>> sigma = Symbol(\"sigma\", positive=True)\n2601     >>> z = Symbol(\"z\")\n2602 \n2603     >>> X = Rayleigh(\"x\", sigma)\n2604 \n2605     >>> density(X)(z)\n2606     z*exp(-z**2/(2*sigma**2))/sigma**2\n2607 \n2608     >>> E(X)\n2609     sqrt(2)*sqrt(pi)*sigma/2\n2610 \n2611     >>> variance(X)\n2612     -pi*sigma**2/2 + 2*sigma**2\n2613 \n2614     References\n2615     ==========\n2616 \n2617     .. [1] https://en.wikipedia.org/wiki/Rayleigh_distribution\n2618     .. [2] http://mathworld.wolfram.com/RayleighDistribution.html\n2619 \n2620     \"\"\"\n2621 \n2622     return rv(name, RayleighDistribution, (sigma, ))\n2623 \n2624 #-------------------------------------------------------------------------------\n2625 # Shifted Gompertz distribution ------------------------------------------------\n2626 \n2627 \n2628 class ShiftedGompertzDistribution(SingleContinuousDistribution):\n2629     _argnames = ('b', 'eta')\n2630 \n2631     set = Interval(0, oo)\n2632 \n2633     @staticmethod\n2634     def check(b, eta):\n2635         _value_check(b > 0, \"b must be positive\")\n2636         _value_check(eta > 0, \"eta must be positive\")\n2637 \n2638     def pdf(self, x):\n2639         b, eta = self.b, self.eta\n2640         return b*exp(-b*x)*exp(-eta*exp(-b*x))*(1+eta*(1-exp(-b*x)))\n2641 \n2642 def ShiftedGompertz(name, b, eta):\n2643     r\"\"\"\n2644     Create a continuous random variable with a Shifted Gompertz distribution.\n2645 \n2646     The density of the Shifted Gompertz distribution is given by\n2647 \n2648     .. math::\n2649         f(x) := b e^{-b x} e^{-\\eta \\exp(-b x)} \\left[1 + \\eta(1 - e^(-bx)) \\right]\n2650 \n2651     with :math: 'x \\in [0, \\inf)'.\n2652 \n2653     Parameters\n2654     ==========\n2655 \n2656     b: Real number, 'b > 0' a scale\n2657     eta: Real number, 'eta > 0' a shape\n2658 \n2659     Returns\n2660     =======\n2661 \n2662     A RandomSymbol.\n2663 \n2664     Examples\n2665     ========\n2666     >>> from sympy.stats import ShiftedGompertz, density, E, variance\n2667     >>> from sympy import Symbol\n2668 \n2669     >>> b = Symbol(\"b\", positive=True)\n2670     >>> eta = Symbol(\"eta\", positive=True)\n2671     >>> x = Symbol(\"x\")\n2672 \n2673     >>> X = ShiftedGompertz(\"x\", b, eta)\n2674 \n2675     >>> density(X)(x)\n2676     b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x))\n2677 \n2678     References\n2679     ==========\n2680 \n2681     .. [1] https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution\n2682 \n2683     \"\"\"\n2684     return rv(name, ShiftedGompertzDistribution, (b, eta))\n2685 \n2686 #-------------------------------------------------------------------------------\n2687 # StudentT distribution --------------------------------------------------------\n2688 \n2689 \n2690 class StudentTDistribution(SingleContinuousDistribution):\n2691     _argnames = ('nu',)\n2692 \n2693     def pdf(self, x):\n2694         nu = self.nu\n2695         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)\n2696 \n2697     def _cdf(self, x):\n2698         nu = self.nu\n2699         return S.Half + x*gamma((nu+1)/2)*hyper((S.Half, (nu+1)/2),\n2700                                 (S(3)/2,), -x**2/nu)/(sqrt(pi*nu)*gamma(nu/2))\n2701 \n2702     def _moment_generating_function(self, t):\n2703         raise NotImplementedError('The moment generating function for the Student-T distribution is undefined.')\n2704 \n2705 def StudentT(name, nu):\n2706     r\"\"\"\n2707     Create a continuous random variable with a student's t distribution.\n2708 \n2709     The density of the student's t distribution is given by\n2710 \n2711     .. math::\n2712         f(x) := \\frac{\\Gamma \\left(\\frac{\\nu+1}{2} \\right)}\n2713                 {\\sqrt{\\nu\\pi}\\Gamma \\left(\\frac{\\nu}{2} \\right)}\n2714                 \\left(1+\\frac{x^2}{\\nu} \\right)^{-\\frac{\\nu+1}{2}}\n2715 \n2716     Parameters\n2717     ==========\n2718 \n2719     nu : Real number, `\\nu > 0`, the degrees of freedom\n2720 \n2721     Returns\n2722     =======\n2723 \n2724     A RandomSymbol.\n2725 \n2726     Examples\n2727     ========\n2728 \n2729     >>> from sympy.stats import StudentT, density, E, variance, cdf\n2730     >>> from sympy import Symbol, simplify, pprint\n2731 \n2732     >>> nu = Symbol(\"nu\", positive=True)\n2733     >>> z = Symbol(\"z\")\n2734 \n2735     >>> X = StudentT(\"x\", nu)\n2736 \n2737     >>> D = density(X)(z)\n2738     >>> pprint(D, use_unicode=False)\n2739                nu   1\n2740              - -- - -\n2741                2    2\n2742      /     2\\\n2743      |    z |\n2744      |1 + --|\n2745      \\    nu/\n2746     -----------------\n2747       ____  /     nu\\\n2748     \\/ nu *B|1/2, --|\n2749             \\     2 /\n2750 \n2751     >>> cdf(X)(z)\n2752     1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),\n2753                                 -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2))\n2754 \n2755 \n2756     References\n2757     ==========\n2758 \n2759     .. [1] https://en.wikipedia.org/wiki/Student_t-distribution\n2760     .. [2] http://mathworld.wolfram.com/Studentst-Distribution.html\n2761 \n2762     \"\"\"\n2763 \n2764     return rv(name, StudentTDistribution, (nu, ))\n2765 \n2766 #-------------------------------------------------------------------------------\n2767 # Trapezoidal distribution ------------------------------------------------------\n2768 \n2769 \n2770 class TrapezoidalDistribution(SingleContinuousDistribution):\n2771     _argnames = ('a', 'b', 'c', 'd')\n2772 \n2773     def pdf(self, x):\n2774         a, b, c, d = self.a, self.b, self.c, self.d\n2775         return Piecewise(\n2776             (2*(x-a) / ((b-a)*(d+c-a-b)), And(a <= x, x < b)),\n2777             (2 / (d+c-a-b), And(b <= x, x < c)),\n2778             (2*(d-x) / ((d-c)*(d+c-a-b)), And(c <= x, x <= d)),\n2779             (S.Zero, True))\n2780 \n2781 def Trapezoidal(name, a, b, c, d):\n2782     r\"\"\"\n2783     Create a continuous random variable with a trapezoidal distribution.\n2784 \n2785     The density of the trapezoidal distribution is given by\n2786 \n2787     .. math::\n2788         f(x) := \\begin{cases}\n2789                   0 & \\mathrm{for\\ } x < a, \\\\\n2790                   \\frac{2(x-a)}{(b-a)(d+c-a-b)} & \\mathrm{for\\ } a \\le x < b, \\\\\n2791                   \\frac{2}{d+c-a-b} & \\mathrm{for\\ } b \\le x < c, \\\\\n2792                   \\frac{2(d-x)}{(d-c)(d+c-a-b)} & \\mathrm{for\\ } c \\le x < d, \\\\\n2793                   0 & \\mathrm{for\\ } d < x.\n2794                 \\end{cases}\n2795 \n2796     Parameters\n2797     ==========\n2798 \n2799     a : Real number, :math:`a < d`\n2800     b : Real number, :math:`a <= b < c`\n2801     c : Real number, :math:`b < c <= d`\n2802     d : Real number\n2803 \n2804     Returns\n2805     =======\n2806 \n2807     A RandomSymbol.\n2808 \n2809     Examples\n2810     ========\n2811 \n2812     >>> from sympy.stats import Trapezoidal, density, E\n2813     >>> from sympy import Symbol, pprint\n2814 \n2815     >>> a = Symbol(\"a\")\n2816     >>> b = Symbol(\"b\")\n2817     >>> c = Symbol(\"c\")\n2818     >>> d = Symbol(\"d\")\n2819     >>> z = Symbol(\"z\")\n2820 \n2821     >>> X = Trapezoidal(\"x\", a,b,c,d)\n2822 \n2823     >>> pprint(density(X)(z), use_unicode=False)\n2824     /        -2*a + 2*z\n2825     |-------------------------  for And(a <= z, b > z)\n2826     |(-a + b)*(-a - b + c + d)\n2827     |\n2828     |           2\n2829     |     --------------        for And(b <= z, c > z)\n2830     <     -a - b + c + d\n2831     |\n2832     |        2*d - 2*z\n2833     |-------------------------  for And(d >= z, c <= z)\n2834     |(-c + d)*(-a - b + c + d)\n2835     |\n2836     \\            0                     otherwise\n2837 \n2838     References\n2839     ==========\n2840 \n2841     .. [1] https://en.wikipedia.org/wiki/Trapezoidal_distribution\n2842 \n2843     \"\"\"\n2844     return rv(name, TrapezoidalDistribution, (a, b, c, d))\n2845 \n2846 #-------------------------------------------------------------------------------\n2847 # Triangular distribution ------------------------------------------------------\n2848 \n2849 \n2850 class TriangularDistribution(SingleContinuousDistribution):\n2851     _argnames = ('a', 'b', 'c')\n2852 \n2853     def pdf(self, x):\n2854         a, b, c = self.a, self.b, self.c\n2855         return Piecewise(\n2856             (2*(x - a)/((b - a)*(c - a)), And(a <= x, x < c)),\n2857             (2/(b - a), Eq(x, c)),\n2858             (2*(b - x)/((b - a)*(b - c)), And(c < x, x <= b)),\n2859             (S.Zero, True))\n2860 \n2861     def _characteristic_function(self, t):\n2862         a, b, c = self.a, self.b, self.c\n2863         return -2 *((b-c) * exp(I*a*t) - (b-a) * exp(I*c*t) + (c-a) * exp(I*b*t)) / ((b-a)*(c-a)*(b-c)*t**2)\n2864 \n2865     def _moment_generating_function(self, t):\n2866         a, b, c = self.a, self.b, self.c\n2867         return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (\n2868         (b - a) * (c - a) * (b - c) * t ** 2)\n2869 \n2870 \n2871 def Triangular(name, a, b, c):\n2872     r\"\"\"\n2873     Create a continuous random variable with a triangular distribution.\n2874 \n2875     The density of the triangular distribution is given by\n2876 \n2877     .. math::\n2878         f(x) := \\begin{cases}\n2879                   0 & \\mathrm{for\\ } x < a, \\\\\n2880                   \\frac{2(x-a)}{(b-a)(c-a)} & \\mathrm{for\\ } a \\le x < c, \\\\\n2881                   \\frac{2}{b-a} & \\mathrm{for\\ } x = c, \\\\\n2882                   \\frac{2(b-x)}{(b-a)(b-c)} & \\mathrm{for\\ } c < x \\le b, \\\\\n2883                   0 & \\mathrm{for\\ } b < x.\n2884                 \\end{cases}\n2885 \n2886     Parameters\n2887     ==========\n2888 \n2889     a : Real number, :math:`a \\in \\left(-\\infty, \\infty\\right)`\n2890     b : Real number, :math:`a < b`\n2891     c : Real number, :math:`a \\leq c \\leq b`\n2892 \n2893     Returns\n2894     =======\n2895 \n2896     A RandomSymbol.\n2897 \n2898     Examples\n2899     ========\n2900 \n2901     >>> from sympy.stats import Triangular, density, E\n2902     >>> from sympy import Symbol, pprint\n2903 \n2904     >>> a = Symbol(\"a\")\n2905     >>> b = Symbol(\"b\")\n2906     >>> c = Symbol(\"c\")\n2907     >>> z = Symbol(\"z\")\n2908 \n2909     >>> X = Triangular(\"x\", a,b,c)\n2910 \n2911     >>> pprint(density(X)(z), use_unicode=False)\n2912     /    -2*a + 2*z\n2913     |-----------------  for And(a <= z, c > z)\n2914     |(-a + b)*(-a + c)\n2915     |\n2916     |       2\n2917     |     ------              for c = z\n2918     <     -a + b\n2919     |\n2920     |   2*b - 2*z\n2921     |----------------   for And(b >= z, c < z)\n2922     |(-a + b)*(b - c)\n2923     |\n2924     \\        0                otherwise\n2925 \n2926     References\n2927     ==========\n2928 \n2929     .. [1] https://en.wikipedia.org/wiki/Triangular_distribution\n2930     .. [2] http://mathworld.wolfram.com/TriangularDistribution.html\n2931 \n2932     \"\"\"\n2933 \n2934     return rv(name, TriangularDistribution, (a, b, c))\n2935 \n2936 #-------------------------------------------------------------------------------\n2937 # Uniform distribution ---------------------------------------------------------\n2938 \n2939 \n2940 class UniformDistribution(SingleContinuousDistribution):\n2941     _argnames = ('left', 'right')\n2942 \n2943     def pdf(self, x):\n2944         left, right = self.left, self.right\n2945         return Piecewise(\n2946             (S.One/(right - left), And(left <= x, x <= right)),\n2947             (S.Zero, True)\n2948         )\n2949 \n2950     def _cdf(self, x):\n2951         left, right = self.left, self.right\n2952         return Piecewise(\n2953             (S.Zero, x < left),\n2954             ((x - left)/(right - left), x <= right),\n2955             (S.One, True)\n2956         )\n2957 \n2958     def _characteristic_function(self, t):\n2959         left, right = self.left, self.right\n2960         return Piecewise(((exp(I*t*right) - exp(I*t*left)) / (I*t*(right - left)), Ne(t, 0)),\n2961                          (S.One, True))\n2962 \n2963     def _moment_generating_function(self, t):\n2964         left, right = self.left, self.right\n2965         return Piecewise(((exp(t*right) - exp(t*left)) / (t * (right - left)), Ne(t, 0)),\n2966                          (S.One, True))\n2967 \n2968     def expectation(self, expr, var, **kwargs):\n2969         from sympy import Max, Min\n2970         kwargs['evaluate'] = True\n2971         result = SingleContinuousDistribution.expectation(self, expr, var, **kwargs)\n2972         result = result.subs({Max(self.left, self.right): self.right,\n2973                               Min(self.left, self.right): self.left})\n2974         return result\n2975 \n2976     def sample(self):\n2977         return random.uniform(self.left, self.right)\n2978 \n2979 \n2980 def Uniform(name, left, right):\n2981     r\"\"\"\n2982     Create a continuous random variable with a uniform distribution.\n2983 \n2984     The density of the uniform distribution is given by\n2985 \n2986     .. math::\n2987         f(x) := \\begin{cases}\n2988                   \\frac{1}{b - a} & \\text{for } x \\in [a,b]  \\\\\n2989                   0               & \\text{otherwise}\n2990                 \\end{cases}\n2991 \n2992     with :math:`x \\in [a,b]`.\n2993 \n2994     Parameters\n2995     ==========\n2996 \n2997     a : Real number, :math:`-\\infty < a` the left boundary\n2998     b : Real number, :math:`a < b < \\infty` the right boundary\n2999 \n3000     Returns\n3001     =======\n3002 \n3003     A RandomSymbol.\n3004 \n3005     Examples\n3006     ========\n3007 \n3008     >>> from sympy.stats import Uniform, density, cdf, E, variance, skewness\n3009     >>> from sympy import Symbol, simplify\n3010 \n3011     >>> a = Symbol(\"a\", negative=True)\n3012     >>> b = Symbol(\"b\", positive=True)\n3013     >>> z = Symbol(\"z\")\n3014 \n3015     >>> X = Uniform(\"x\", a, b)\n3016 \n3017     >>> density(X)(z)\n3018     Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True))\n3019 \n3020     >>> cdf(X)(z)  # doctest: +SKIP\n3021     -a/(-a + b) + z/(-a + b)\n3022 \n3023     >>> simplify(E(X))\n3024     a/2 + b/2\n3025 \n3026     >>> simplify(variance(X))\n3027     a**2/12 - a*b/6 + b**2/12\n3028 \n3029     References\n3030     ==========\n3031 \n3032     .. [1] https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29\n3033     .. [2] http://mathworld.wolfram.com/UniformDistribution.html\n3034 \n3035     \"\"\"\n3036 \n3037     return rv(name, UniformDistribution, (left, right))\n3038 \n3039 #-------------------------------------------------------------------------------\n3040 # UniformSum distribution ------------------------------------------------------\n3041 \n3042 \n3043 class UniformSumDistribution(SingleContinuousDistribution):\n3044     _argnames = ('n',)\n3045 \n3046     @property\n3047     def set(self):\n3048         return Interval(0, self.n)\n3049 \n3050     def pdf(self, x):\n3051         n = self.n\n3052         k = Dummy(\"k\")\n3053         return 1/factorial(\n3054             n - 1)*Sum((-1)**k*binomial(n, k)*(x - k)**(n - 1), (k, 0, floor(x)))\n3055 \n3056     def _cdf(self, x):\n3057         n = self.n\n3058         k = Dummy(\"k\")\n3059         return Piecewise((S.Zero, x < 0),\n3060                         (1/factorial(n)*Sum((-1)**k*binomial(n, k)*(x - k)**(n),\n3061                         (k, 0, floor(x))), x <= n),\n3062                         (S.One, True))\n3063 \n3064     def _characteristic_function(self, t):\n3065         return ((exp(I*t) - 1) / (I*t))**self.n\n3066 \n3067     def _moment_generating_function(self, t):\n3068         return ((exp(t) - 1) / t)**self.n\n3069 \n3070 def UniformSum(name, n):\n3071     r\"\"\"\n3072     Create a continuous random variable with an Irwin-Hall distribution.\n3073 \n3074     The probability distribution function depends on a single parameter\n3075     `n` which is an integer.\n3076 \n3077     The density of the Irwin-Hall distribution is given by\n3078 \n3079     .. math ::\n3080         f(x) := \\frac{1}{(n-1)!}\\sum_{k=0}^{\\left\\lfloor x\\right\\rfloor}(-1)^k\n3081                 \\binom{n}{k}(x-k)^{n-1}\n3082 \n3083     Parameters\n3084     ==========\n3085 \n3086     n : A positive Integer, `n > 0`\n3087 \n3088     Returns\n3089     =======\n3090 \n3091     A RandomSymbol.\n3092 \n3093     Examples\n3094     ========\n3095 \n3096     >>> from sympy.stats import UniformSum, density, cdf\n3097     >>> from sympy import Symbol, pprint\n3098 \n3099     >>> n = Symbol(\"n\", integer=True)\n3100     >>> z = Symbol(\"z\")\n3101 \n3102     >>> X = UniformSum(\"x\", n)\n3103 \n3104     >>> D = density(X)(z)\n3105     >>> pprint(D, use_unicode=False)\n3106     floor(z)\n3107       ___\n3108       \\  `\n3109        \\         k         n - 1 /n\\\n3110         )    (-1) *(-k + z)     *| |\n3111        /                         \\k/\n3112       /__,\n3113      k = 0\n3114     --------------------------------\n3115                 (n - 1)!\n3116 \n3117     >>> cdf(X)(z)\n3118     Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),\n3119                     (_k, 0, floor(z)))/factorial(n), n >= z), (1, True))\n3120 \n3121 \n3122     Compute cdf with specific 'x' and 'n' values as follows :\n3123     >>> cdf(UniformSum(\"x\", 5), evaluate=False)(2).doit()\n3124     9/40\n3125 \n3126     The argument evaluate=False prevents an attempt at evaluation\n3127     of the sum for general n, before the argument 2 is passed.\n3128 \n3129     References\n3130     ==========\n3131 \n3132     .. [1] https://en.wikipedia.org/wiki/Uniform_sum_distribution\n3133     .. [2] http://mathworld.wolfram.com/UniformSumDistribution.html\n3134 \n3135     \"\"\"\n3136 \n3137     return rv(name, UniformSumDistribution, (n, ))\n3138 \n3139 #-------------------------------------------------------------------------------\n3140 # VonMises distribution --------------------------------------------------------\n3141 \n3142 \n3143 class VonMisesDistribution(SingleContinuousDistribution):\n3144     _argnames = ('mu', 'k')\n3145 \n3146     set = Interval(0, 2*pi)\n3147 \n3148     @staticmethod\n3149     def check(mu, k):\n3150         _value_check(k > 0, \"k must be positive\")\n3151 \n3152     def pdf(self, x):\n3153         mu, k = self.mu, self.k\n3154         return exp(k*cos(x-mu)) / (2*pi*besseli(0, k))\n3155 \n3156 def VonMises(name, mu, k):\n3157     r\"\"\"\n3158     Create a Continuous Random Variable with a von Mises distribution.\n3159 \n3160     The density of the von Mises distribution is given by\n3161 \n3162     .. math::\n3163         f(x) := \\frac{e^{\\kappa\\cos(x-\\mu)}}{2\\pi I_0(\\kappa)}\n3164 \n3165     with :math:`x \\in [0,2\\pi]`.\n3166 \n3167     Parameters\n3168     ==========\n3169 \n3170     mu : Real number, measure of location\n3171     k : Real number, measure of concentration\n3172 \n3173     Returns\n3174     =======\n3175 \n3176     A RandomSymbol.\n3177 \n3178     Examples\n3179     ========\n3180 \n3181     >>> from sympy.stats import VonMises, density, E, variance\n3182     >>> from sympy import Symbol, simplify, pprint\n3183 \n3184     >>> mu = Symbol(\"mu\")\n3185     >>> k = Symbol(\"k\", positive=True)\n3186     >>> z = Symbol(\"z\")\n3187 \n3188     >>> X = VonMises(\"x\", mu, k)\n3189 \n3190     >>> D = density(X)(z)\n3191     >>> pprint(D, use_unicode=False)\n3192          k*cos(mu - z)\n3193         e\n3194     ------------------\n3195     2*pi*besseli(0, k)\n3196 \n3197 \n3198     References\n3199     ==========\n3200 \n3201     .. [1] https://en.wikipedia.org/wiki/Von_Mises_distribution\n3202     .. [2] http://mathworld.wolfram.com/vonMisesDistribution.html\n3203 \n3204     \"\"\"\n3205 \n3206     return rv(name, VonMisesDistribution, (mu, k))\n3207 \n3208 #-------------------------------------------------------------------------------\n3209 # Weibull distribution ---------------------------------------------------------\n3210 \n3211 \n3212 class WeibullDistribution(SingleContinuousDistribution):\n3213     _argnames = ('alpha', 'beta')\n3214 \n3215     set = Interval(0, oo)\n3216 \n3217     @staticmethod\n3218     def check(alpha, beta):\n3219         _value_check(alpha > 0, \"Alpha must be positive\")\n3220         _value_check(beta > 0, \"Beta must be positive\")\n3221 \n3222     def pdf(self, x):\n3223         alpha, beta = self.alpha, self.beta\n3224         return beta * (x/alpha)**(beta - 1) * exp(-(x/alpha)**beta) / alpha\n3225 \n3226     def sample(self):\n3227         return random.weibullvariate(self.alpha, self.beta)\n3228 \n3229 def Weibull(name, alpha, beta):\n3230     r\"\"\"\n3231     Create a continuous random variable with a Weibull distribution.\n3232 \n3233     The density of the Weibull distribution is given by\n3234 \n3235     .. math::\n3236         f(x) := \\begin{cases}\n3237                   \\frac{k}{\\lambda}\\left(\\frac{x}{\\lambda}\\right)^{k-1}\n3238                   e^{-(x/\\lambda)^{k}} & x\\geq0\\\\\n3239                   0 & x<0\n3240                 \\end{cases}\n3241 \n3242     Parameters\n3243     ==========\n3244 \n3245     lambda : Real number, :math:`\\lambda > 0` a scale\n3246     k : Real number, `k > 0` a shape\n3247 \n3248     Returns\n3249     =======\n3250 \n3251     A RandomSymbol.\n3252 \n3253     Examples\n3254     ========\n3255 \n3256     >>> from sympy.stats import Weibull, density, E, variance\n3257     >>> from sympy import Symbol, simplify\n3258 \n3259     >>> l = Symbol(\"lambda\", positive=True)\n3260     >>> k = Symbol(\"k\", positive=True)\n3261     >>> z = Symbol(\"z\")\n3262 \n3263     >>> X = Weibull(\"x\", l, k)\n3264 \n3265     >>> density(X)(z)\n3266     k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda\n3267 \n3268     >>> simplify(E(X))\n3269     lambda*gamma(1 + 1/k)\n3270 \n3271     >>> simplify(variance(X))\n3272     lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k))\n3273 \n3274     References\n3275     ==========\n3276 \n3277     .. [1] https://en.wikipedia.org/wiki/Weibull_distribution\n3278     .. [2] http://mathworld.wolfram.com/WeibullDistribution.html\n3279 \n3280     \"\"\"\n3281 \n3282     return rv(name, WeibullDistribution, (alpha, beta))\n3283 \n3284 #-------------------------------------------------------------------------------\n3285 # Wigner semicircle distribution -----------------------------------------------\n3286 \n3287 \n3288 class WignerSemicircleDistribution(SingleContinuousDistribution):\n3289     _argnames = ('R',)\n3290 \n3291     @property\n3292     def set(self):\n3293         return Interval(-self.R, self.R)\n3294 \n3295     def pdf(self, x):\n3296         R = self.R\n3297         return 2/(pi*R**2)*sqrt(R**2 - x**2)\n3298 \n3299     def _characteristic_function(self, t):\n3300         return Piecewise((2 * besselj(1, self.R*t) / (self.R*t), Ne(t, 0)),\n3301                          (S.One, True))\n3302 \n3303     def _moment_generating_function(self, t):\n3304         return Piecewise((2 * besseli(1, self.R*t) / (self.R*t), Ne(t, 0)),\n3305                          (S.One, True))\n3306 \n3307 def WignerSemicircle(name, R):\n3308     r\"\"\"\n3309     Create a continuous random variable with a Wigner semicircle distribution.\n3310 \n3311     The density of the Wigner semicircle distribution is given by\n3312 \n3313     .. math::\n3314         f(x) := \\frac2{\\pi R^2}\\,\\sqrt{R^2-x^2}\n3315 \n3316     with :math:`x \\in [-R,R]`.\n3317 \n3318     Parameters\n3319     ==========\n3320 \n3321     R : Real number, `R > 0`, the radius\n3322 \n3323     Returns\n3324     =======\n3325 \n3326     A `RandomSymbol`.\n3327 \n3328     Examples\n3329     ========\n3330 \n3331     >>> from sympy.stats import WignerSemicircle, density, E\n3332     >>> from sympy import Symbol, simplify\n3333 \n3334     >>> R = Symbol(\"R\", positive=True)\n3335     >>> z = Symbol(\"z\")\n3336 \n3337     >>> X = WignerSemicircle(\"x\", R)\n3338 \n3339     >>> density(X)(z)\n3340     2*sqrt(R**2 - z**2)/(pi*R**2)\n3341 \n3342     >>> E(X)\n3343     0\n3344 \n3345     References\n3346     ==========\n3347 \n3348     .. [1] https://en.wikipedia.org/wiki/Wigner_semicircle_distribution\n3349     .. [2] http://mathworld.wolfram.com/WignersSemicircleLaw.html\n3350 \n3351     \"\"\"\n3352 \n3353     return rv(name, WignerSemicircleDistribution, (R,))\n",
        "intended_behavior": "Enhance the `check` methods to include all necessary validations for the parameters of each continuous distribution. Ensure that inappropriate values raise appropriate errors or warnings. Additionally, ensure that all relevant attributes are correctly set and accessible for these distributions."
    },
    {
        "rel_file_path": "sympy/stats/drv_types.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/stats/drv_types.py",
        "start": 1,
        "end": 520,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 \n3 Contains\n4 ========\n5 Geometric\n6 Poisson\n7 Logarithmic\n8 NegativeBinomial\n9 Poisson\n10 YuleSimon\n11 Zeta\n12 \"\"\"\n13 \n14 \n15 from __future__ import print_function, division\n16 \n17 from sympy import (factorial, exp, S, sympify, And, I, zeta, polylog, log, beta,\n18     hyper, binomial, Piecewise, floor)\n19 from sympy.stats import density\n20 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace\n21 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution\n22 from sympy.stats.rv import _value_check, RandomSymbol\n23 import random\n24 \n25 __all__ = ['Geometric',\n26 'Logarithmic',\n27 'NegativeBinomial',\n28 'Poisson',\n29 'YuleSimon',\n30 'Zeta'\n31 ]\n32 \n33 \n34 def rv(symbol, cls, *args):\n35     args = list(map(sympify, args))\n36     dist = cls(*args)\n37     dist.check(*args)\n38     pspace = SingleDiscretePSpace(symbol, dist)\n39     if any(isinstance(arg, RandomSymbol) for arg in args):\n40         pspace = JointPSpace(symbol, CompoundDistribution(dist))\n41     return pspace.value\n42 \n43 \n44 #-------------------------------------------------------------------------------\n45 # Geometric distribution ------------------------------------------------------------\n46 \n47 class GeometricDistribution(SingleDiscreteDistribution):\n48     _argnames = ('p',)\n49     set = S.Naturals\n50 \n51     @staticmethod\n52     def check(p):\n53         _value_check((0 < p, p <= 1), \"p must be between 0 and 1\")\n54 \n55     def pdf(self, k):\n56         return (1 - self.p)**(k - 1) * self.p\n57 \n58     def _characteristic_function(self, t):\n59         p = self.p\n60         return p * exp(I*t) / (1 - (1 - p)*exp(I*t))\n61 \n62     def _moment_generating_function(self, t):\n63         p = self.p\n64         return p * exp(t) / (1 - (1 - p) * exp(t))\n65 \n66 def Geometric(name, p):\n67     r\"\"\"\n68     Create a discrete random variable with a Geometric distribution.\n69 \n70     The density of the Geometric distribution is given by\n71 \n72     .. math::\n73         f(k) := p (1 - p)^{k - 1}\n74 \n75     Parameters\n76     ==========\n77 \n78     p: A probability between 0 and 1\n79 \n80     Returns\n81     =======\n82 \n83     A RandomSymbol.\n84 \n85     Examples\n86     ========\n87 \n88     >>> from sympy.stats import Geometric, density, E, variance\n89     >>> from sympy import Symbol, S\n90 \n91     >>> p = S.One / 5\n92     >>> z = Symbol(\"z\")\n93 \n94     >>> X = Geometric(\"x\", p)\n95 \n96     >>> density(X)(z)\n97     (4/5)**(z - 1)/5\n98 \n99     >>> E(X)\n100     5\n101 \n102     >>> variance(X)\n103     20\n104 \n105     References\n106     ==========\n107 \n108     .. [1] https://en.wikipedia.org/wiki/Geometric_distribution\n109     .. [2] http://mathworld.wolfram.com/GeometricDistribution.html\n110 \n111     \"\"\"\n112     return rv(name, GeometricDistribution, p)\n113 \n114 \n115 #-------------------------------------------------------------------------------\n116 # Logarithmic distribution ------------------------------------------------------------\n117 \n118 class LogarithmicDistribution(SingleDiscreteDistribution):\n119     _argnames = ('p',)\n120 \n121     set = S.Naturals\n122 \n123     @staticmethod\n124     def check(p):\n125         _value_check((p > 0, p < 1), \"p should be between 0 and 1\")\n126 \n127     def pdf(self, k):\n128         p = self.p\n129         return (-1) * p**k / (k * log(1 - p))\n130 \n131     def _characteristic_function(self, t):\n132         p = self.p\n133         return log(1 - p * exp(I*t)) / log(1 - p)\n134 \n135     def _moment_generating_function(self, t):\n136         p = self.p\n137         return log(1 - p * exp(t)) / log(1 - p)\n138 \n139     def sample(self):\n140         ### TODO\n141         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n142 \n143 \n144 def Logarithmic(name, p):\n145     r\"\"\"\n146     Create a discrete random variable with a Logarithmic distribution.\n147 \n148     The density of the Logarithmic distribution is given by\n149 \n150     .. math::\n151         f(k) := \\frac{-p^k}{k \\ln{(1 - p)}}\n152 \n153     Parameters\n154     ==========\n155 \n156     p: A value between 0 and 1\n157 \n158     Returns\n159     =======\n160 \n161     A RandomSymbol.\n162 \n163     Examples\n164     ========\n165 \n166     >>> from sympy.stats import Logarithmic, density, E, variance\n167     >>> from sympy import Symbol, S\n168 \n169     >>> p = S.One / 5\n170     >>> z = Symbol(\"z\")\n171 \n172     >>> X = Logarithmic(\"x\", p)\n173 \n174     >>> density(X)(z)\n175     -5**(-z)/(z*log(4/5))\n176 \n177     >>> E(X)\n178     -1/(-4*log(5) + 8*log(2))\n179 \n180     >>> variance(X)\n181     -1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2))\n182 \n183     References\n184     ==========\n185 \n186     .. [1] https://en.wikipedia.org/wiki/Logarithmic_distribution\n187     .. [2] http://mathworld.wolfram.com/LogarithmicDistribution.html\n188 \n189     \"\"\"\n190     return rv(name, LogarithmicDistribution, p)\n191 \n192 \n193 #-------------------------------------------------------------------------------\n194 # Negative binomial distribution ------------------------------------------------------------\n195 \n196 class NegativeBinomialDistribution(SingleDiscreteDistribution):\n197     _argnames = ('r', 'p')\n198     set = S.Naturals0\n199 \n200     @staticmethod\n201     def check(r, p):\n202         _value_check(r > 0, 'r should be positive')\n203         _value_check((p > 0, p < 1), 'p should be between 0 and 1')\n204 \n205     def pdf(self, k):\n206         r = self.r\n207         p = self.p\n208 \n209         return binomial(k + r - 1, k) * (1 - p)**r * p**k\n210 \n211     def _characteristic_function(self, t):\n212         r = self.r\n213         p = self.p\n214 \n215         return ((1 - p) / (1 - p * exp(I*t)))**r\n216 \n217     def _moment_generating_function(self, t):\n218         r = self.r\n219         p = self.p\n220 \n221         return ((1 - p) / (1 - p * exp(t)))**r\n222 \n223     def sample(self):\n224         ### TODO\n225         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n226 \n227 \n228 def NegativeBinomial(name, r, p):\n229     r\"\"\"\n230     Create a discrete random variable with a Negative Binomial distribution.\n231 \n232     The density of the Negative Binomial distribution is given by\n233 \n234     .. math::\n235         f(k) := \\binom{k + r - 1}{k} (1 - p)^r p^k\n236 \n237     Parameters\n238     ==========\n239 \n240     r: A positive value\n241     p: A value between 0 and 1\n242 \n243     Returns\n244     =======\n245 \n246     A RandomSymbol.\n247 \n248     Examples\n249     ========\n250 \n251     >>> from sympy.stats import NegativeBinomial, density, E, variance\n252     >>> from sympy import Symbol, S\n253 \n254     >>> r = 5\n255     >>> p = S.One / 5\n256     >>> z = Symbol(\"z\")\n257 \n258     >>> X = NegativeBinomial(\"x\", r, p)\n259 \n260     >>> density(X)(z)\n261     1024*5**(-z)*binomial(z + 4, z)/3125\n262 \n263     >>> E(X)\n264     5/4\n265 \n266     >>> variance(X)\n267     25/16\n268 \n269     References\n270     ==========\n271 \n272     .. [1] https://en.wikipedia.org/wiki/Negative_binomial_distribution\n273     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html\n274 \n275     \"\"\"\n276     return rv(name, NegativeBinomialDistribution, r, p)\n277 \n278 \n279 #-------------------------------------------------------------------------------\n280 # Poisson distribution ------------------------------------------------------------\n281 \n282 class PoissonDistribution(SingleDiscreteDistribution):\n283     _argnames = ('lamda',)\n284 \n285     set = S.Naturals0\n286 \n287     @staticmethod\n288     def check(lamda):\n289         _value_check(lamda > 0, \"Lambda must be positive\")\n290 \n291     def pdf(self, k):\n292         return self.lamda**k / factorial(k) * exp(-self.lamda)\n293 \n294     def sample(self):\n295         def search(x, y, u):\n296             while x < y:\n297                 mid = (x + y)//2\n298                 if u <= self.cdf(mid):\n299                     y = mid\n300                 else:\n301                     x = mid + 1\n302             return x\n303 \n304         u = random.uniform(0, 1)\n305         if u <= self.cdf(S.Zero):\n306             return S.Zero\n307         n = S.One\n308         while True:\n309             if u > self.cdf(2*n):\n310                 n *= 2\n311             else:\n312                 return search(n, 2*n, u)\n313 \n314     def _characteristic_function(self, t):\n315         return exp(self.lamda * (exp(I*t) - 1))\n316 \n317     def _moment_generating_function(self, t):\n318         return exp(self.lamda * (exp(t) - 1))\n319 \n320 \n321 def Poisson(name, lamda):\n322     r\"\"\"\n323     Create a discrete random variable with a Poisson distribution.\n324 \n325     The density of the Poisson distribution is given by\n326 \n327     .. math::\n328         f(k) := \\frac{\\lambda^{k} e^{- \\lambda}}{k!}\n329 \n330     Parameters\n331     ==========\n332 \n333     lamda: Positive number, a rate\n334 \n335     Returns\n336     =======\n337 \n338     A RandomSymbol.\n339 \n340     Examples\n341     ========\n342 \n343     >>> from sympy.stats import Poisson, density, E, variance\n344     >>> from sympy import Symbol, simplify\n345 \n346     >>> rate = Symbol(\"lambda\", positive=True)\n347     >>> z = Symbol(\"z\")\n348 \n349     >>> X = Poisson(\"x\", rate)\n350 \n351     >>> density(X)(z)\n352     lambda**z*exp(-lambda)/factorial(z)\n353 \n354     >>> E(X)\n355     lambda\n356 \n357     >>> simplify(variance(X))\n358     lambda\n359 \n360     References\n361     ==========\n362 \n363     .. [1] https://en.wikipedia.org/wiki/Poisson_distribution\n364     .. [2] http://mathworld.wolfram.com/PoissonDistribution.html\n365 \n366     \"\"\"\n367     return rv(name, PoissonDistribution, lamda)\n368 \n369 \n370 #-------------------------------------------------------------------------------\n371 # Yule-Simon distribution ------------------------------------------------------------\n372 \n373 class YuleSimonDistribution(SingleDiscreteDistribution):\n374     _argnames = ('rho',)\n375     set = S.Naturals\n376 \n377     @staticmethod\n378     def check(rho):\n379         _value_check(rho > 0, 'rho should be positive')\n380 \n381     def pdf(self, k):\n382         rho = self.rho\n383         return rho * beta(k, rho + 1)\n384 \n385     def _cdf(self, x):\n386         return Piecewise((1 - floor(x) * beta(floor(x), self.rho + 1), x >= 1), (0, True))\n387 \n388     def _characteristic_function(self, t):\n389         rho = self.rho\n390         return rho * hyper((1, 1), (rho + 2,), exp(I*t)) * exp(I*t) / (rho + 1)\n391 \n392     def _moment_generating_function(self, t):\n393         rho = self.rho\n394         return rho * hyper((1, 1), (rho + 2,), exp(t)) * exp(t) / (rho + 1)\n395 \n396     def sample(self):\n397         ### TODO\n398         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n399 \n400 \n401 def YuleSimon(name, rho):\n402     r\"\"\"\n403     Create a discrete random variable with a Yule-Simon distribution.\n404 \n405     The density of the Yule-Simon distribution is given by\n406 \n407     .. math::\n408         f(k) := \\rho B(k, \\rho + 1)\n409 \n410     Parameters\n411     ==========\n412 \n413     rho: A positive value\n414 \n415     Returns\n416     =======\n417 \n418     A RandomSymbol.\n419 \n420     Examples\n421     ========\n422 \n423     >>> from sympy.stats import YuleSimon, density, E, variance\n424     >>> from sympy import Symbol, simplify\n425 \n426     >>> p = 5\n427     >>> z = Symbol(\"z\")\n428 \n429     >>> X = YuleSimon(\"x\", p)\n430 \n431     >>> density(X)(z)\n432     5*beta(z, 6)\n433 \n434     >>> simplify(E(X))\n435     5/4\n436 \n437     >>> simplify(variance(X))\n438     25/48\n439 \n440     References\n441     ==========\n442 \n443     .. [1] https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution\n444 \n445     \"\"\"\n446     return rv(name, YuleSimonDistribution, rho)\n447 \n448 \n449 #-------------------------------------------------------------------------------\n450 # Zeta distribution ------------------------------------------------------------\n451 \n452 class ZetaDistribution(SingleDiscreteDistribution):\n453     _argnames = ('s',)\n454     set = S.Naturals\n455 \n456     @staticmethod\n457     def check(s):\n458         _value_check(s > 1, 's should be greater than 1')\n459 \n460     def pdf(self, k):\n461         s = self.s\n462         return 1 / (k**s * zeta(s))\n463 \n464     def _characteristic_function(self, t):\n465         return polylog(self.s, exp(I*t)) / zeta(self.s)\n466 \n467     def _moment_generating_function(self, t):\n468         return polylog(self.s, exp(t)) / zeta(self.s)\n469 \n470     def sample(self):\n471         ### TODO\n472         raise NotImplementedError(\"Sampling of %s is not implemented\" % density(self))\n473 \n474 \n475 def Zeta(name, s):\n476     r\"\"\"\n477     Create a discrete random variable with a Zeta distribution.\n478 \n479     The density of the Zeta distribution is given by\n480 \n481     .. math::\n482         f(k) := \\frac{1}{k^s \\zeta{(s)}}\n483 \n484     Parameters\n485     ==========\n486 \n487     s: A value greater than 1\n488 \n489     Returns\n490     =======\n491 \n492     A RandomSymbol.\n493 \n494     Examples\n495     ========\n496 \n497     >>> from sympy.stats import Zeta, density, E, variance\n498     >>> from sympy import Symbol\n499 \n500     >>> s = 5\n501     >>> z = Symbol(\"z\")\n502 \n503     >>> X = Zeta(\"x\", s)\n504 \n505     >>> density(X)(z)\n506     1/(z**5*zeta(5))\n507 \n508     >>> E(X)\n509     pi**4/(90*zeta(5))\n510 \n511     >>> variance(X)\n512     -pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5)\n513 \n514     References\n515     ==========\n516 \n517     .. [1] https://en.wikipedia.org/wiki/Zeta_distribution\n518 \n519     \"\"\"\n520     return rv(name, ZetaDistribution, s)\n",
        "intended_behavior": "Similar to `crv_types.py`, validations within `check` methods should be exhaustive, covering the domain of possible parameters to prevent invalid configurations. Ensure attributes related to the distributions are correctly implemented and documented."
    },
    {
        "rel_file_path": "sympy/stats/joint_rv_types.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/stats/joint_rv_types.py",
        "start": 1,
        "end": 533,
        "class_name": null,
        "method_name": null,
        "code": "1 from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, Gt, IndexedBase,\n2                     besselk, gamma, Interval, Range, factorial, Mul, Integer,\n3                     Add, rf, Eq, Piecewise, Symbol, imageset, Intersection)\n4 from sympy.matrices import ImmutableMatrix\n5 from sympy.matrices.expressions.determinant import det\n6 from sympy.stats.joint_rv import (JointDistribution, JointPSpace,\n7     JointDistributionHandmade, MarginalDistribution)\n8 from sympy.stats.rv import _value_check, random_symbols\n9 \n10 # __all__ = ['MultivariateNormal',\n11 # 'MultivariateLaplace',\n12 # 'MultivariateT',\n13 # 'NormalGamma'\n14 # ]\n15 \n16 def multivariate_rv(cls, sym, *args):\n17     args = list(map(sympify, args))\n18     dist = cls(*args)\n19     args = dist.args\n20     dist.check(*args)\n21     return JointPSpace(sym, dist).value\n22 \n23 def JointRV(symbol, pdf, _set=None):\n24     \"\"\"\n25     Create a Joint Random Variable where each of its component is conitinuous,\n26     given the following:\n27 \n28     -- a symbol\n29     -- a PDF in terms of indexed symbols of the symbol given\n30      as the first argument\n31 \n32     NOTE: As of now, the set for each component for a `JointRV` is\n33     equal to the set of all integers, which can not be changed.\n34 \n35     Returns a RandomSymbol.\n36 \n37     Examples\n38     ========\n39 \n40     >>> from sympy import symbols, exp, pi, Indexed, S\n41     >>> from sympy.stats import density\n42     >>> from sympy.stats.joint_rv_types import JointRV\n43 \n44     >>> x1, x2 = (Indexed('x', i) for i in (1, 2))\n45     >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)\n46 \n47     >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution\n48     >>> density(N1)(1, 2)\n49     exp(-2)/(2*pi)\n50     \"\"\"\n51     #TODO: Add support for sets provided by the user\n52     symbol = sympify(symbol)\n53     syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)\n54         and i.base == IndexedBase(symbol))\n55     syms.sort(key = lambda index: index.args[1])\n56     _set = S.Reals**len(syms)\n57     pdf = Lambda(syms, pdf)\n58     dist = JointDistributionHandmade(pdf, _set)\n59     jrv = JointPSpace(symbol, dist).value\n60     rvs = random_symbols(pdf)\n61     if len(rvs) != 0:\n62         dist = MarginalDistribution(dist, (jrv,))\n63         return JointPSpace(symbol, dist).value\n64     return jrv\n65 \n66 #-------------------------------------------------------------------------------\n67 # Multivariate Normal distribution ---------------------------------------------------------\n68 \n69 class MultivariateNormalDistribution(JointDistribution):\n70     _argnames = ['mu', 'sigma']\n71 \n72     is_Continuous=True\n73 \n74     @property\n75     def set(self):\n76         k = len(self.mu)\n77         return S.Reals**k\n78 \n79     def check(self, mu, sigma):\n80         _value_check(len(mu) == len(sigma.col(0)),\n81             \"Size of the mean vector and covariance matrix are incorrect.\")\n82         #check if covariance matrix is positive definite or not.\n83         _value_check((i > 0 for i in sigma.eigenvals().keys()),\n84             \"The covariance matrix must be positive definite. \")\n85 \n86     def pdf(self, *args):\n87         mu, sigma = self.mu, self.sigma\n88         k = len(mu)\n89         args = ImmutableMatrix(args)\n90         x = args - mu\n91         return  S(1)/sqrt((2*pi)**(k)*det(sigma))*exp(\n92             -S(1)/2*x.transpose()*(sigma.inv()*\\\n93                 x))[0]\n94 \n95     def marginal_distribution(self, indices, sym):\n96         sym = ImmutableMatrix([Indexed(sym, i) for i in indices])\n97         _mu, _sigma = self.mu, self.sigma\n98         k = len(self.mu)\n99         for i in range(k):\n100             if i not in indices:\n101                 _mu = _mu.row_del(i)\n102                 _sigma = _sigma.col_del(i)\n103                 _sigma = _sigma.row_del(i)\n104         return Lambda(sym, S(1)/sqrt((2*pi)**(len(_mu))*det(_sigma))*exp(\n105             -S(1)/2*(_mu - sym).transpose()*(_sigma.inv()*\\\n106                 (_mu - sym)))[0])\n107 \n108 #-------------------------------------------------------------------------------\n109 # Multivariate Laplace distribution ---------------------------------------------------------\n110 \n111 class MultivariateLaplaceDistribution(JointDistribution):\n112     _argnames = ['mu', 'sigma']\n113     is_Continuous=True\n114 \n115     @property\n116     def set(self):\n117         k = len(self.mu)\n118         return S.Reals**k\n119 \n120     def check(self, mu, sigma):\n121         _value_check(len(mu) == len(sigma.col(0)),\n122             \"Size of the mean vector and covariance matrix are incorrect.\")\n123         #check if covariance matrix is positive definite or not.\n124         _value_check((i > 0 for i in sigma.eigenvals().keys()),\n125             \"The covariance matrix must be positive definite. \")\n126 \n127     def pdf(self, *args):\n128         mu, sigma = self.mu, self.sigma\n129         mu_T = mu.transpose()\n130         k = S(len(mu))\n131         sigma_inv = sigma.inv()\n132         args = ImmutableMatrix(args)\n133         args_T = args.transpose()\n134         x = (mu_T*sigma_inv*mu)[0]\n135         y = (args_T*sigma_inv*args)[0]\n136         v = 1 - k/2\n137         return S(2)/((2*pi)**(S(k)/2)*sqrt(det(sigma)))\\\n138         *(y/(2 + x))**(S(v)/2)*besselk(v, sqrt((2 + x)*(y)))\\\n139         *exp((args_T*sigma_inv*mu)[0])\n140 \n141 \n142 #-------------------------------------------------------------------------------\n143 # Multivariate StudentT distribution ---------------------------------------------------------\n144 \n145 class MultivariateTDistribution(JointDistribution):\n146     _argnames = ['mu', 'shape_mat', 'dof']\n147     is_Continuous=True\n148 \n149     @property\n150     def set(self):\n151         k = len(self.mu)\n152         return S.Reals**k\n153 \n154     def check(self, mu, sigma, v):\n155         _value_check(len(mu) == len(sigma.col(0)),\n156             \"Size of the location vector and shape matrix are incorrect.\")\n157         #check if covariance matrix is positive definite or not.\n158         _value_check((i > 0 for i in sigma.eigenvals().keys()),\n159             \"The shape matrix must be positive definite. \")\n160 \n161     def pdf(self, *args):\n162         mu, sigma = self.mu, self.shape_mat\n163         v = S(self.dof)\n164         k = S(len(mu))\n165         sigma_inv = sigma.inv()\n166         args = ImmutableMatrix(args)\n167         x = args - mu\n168         return gamma((k + v)/2)/(gamma(v/2)*(v*pi)**(k/2)*sqrt(det(sigma)))\\\n169         *(1 + 1/v*(x.transpose()*sigma_inv*x)[0])**((-v - k)/2)\n170 \n171 def MultivariateT(syms, mu, sigma, v):\n172     \"\"\"\n173     Creates a joint random variable with multivariate T-distribution.\n174 \n175     Parameters\n176     ==========\n177 \n178     syms: list/tuple/set of symbols for identifying each component\n179     mu: A list/tuple/set consisting of k means,represents a k\n180         dimensional location vector\n181     sigma: The shape matrix for the distribution\n182 \n183     Returns\n184     =======\n185 \n186     A random symbol\n187     \"\"\"\n188     return multivariate_rv(MultivariateTDistribution, syms, mu, sigma, v)\n189 \n190 \n191 #-------------------------------------------------------------------------------\n192 # Multivariate Normal Gamma distribution ---------------------------------------------------------\n193 \n194 class NormalGammaDistribution(JointDistribution):\n195 \n196     _argnames = ['mu', 'lamda', 'alpha', 'beta']\n197     is_Continuous=True\n198 \n199     def check(self, mu, lamda, alpha, beta):\n200         _value_check(mu.is_real, \"Location must be real.\")\n201         _value_check(lamda > 0, \"Lambda must be positive\")\n202         _value_check(alpha > 0, \"alpha must be positive\")\n203         _value_check(beta > 0, \"beta must be positive\")\n204 \n205     @property\n206     def set(self):\n207         return S.Reals*Interval(0, S.Infinity)\n208 \n209     def pdf(self, x, tau):\n210         beta, alpha, lamda = self.beta, self.alpha, self.lamda\n211         mu = self.mu\n212 \n213         return beta**alpha*sqrt(lamda)/(gamma(alpha)*sqrt(2*pi))*\\\n214         tau**(alpha - S(1)/2)*exp(-1*beta*tau)*\\\n215         exp(-1*(lamda*tau*(x - mu)**2)/S(2))\n216 \n217     def marginal_distribution(self, indices, *sym):\n218         if len(indices) == 2:\n219             return self.pdf(*sym)\n220         if indices[0] == 0:\n221             #For marginal over `x`, return non-standardized Student-T's\n222             #distribution\n223             x = sym[0]\n224             v, mu, sigma = self.alpha - S(1)/2, self.mu, \\\n225                 S(self.beta)/(self.lamda * self.alpha)\n226             return Lambda(sym, gamma((v + 1)/2)/(gamma(v/2)*sqrt(pi*v)*sigma)*\\\n227                 (1 + 1/v*((x - mu)/sigma)**2)**((-v -1)/2))\n228         #For marginal over `tau`, return Gamma distribution as per construction\n229         from sympy.stats.crv_types import GammaDistribution\n230         return Lambda(sym, GammaDistribution(self.alpha, self.beta)(sym[0]))\n231 \n232 def NormalGamma(syms, mu, lamda, alpha, beta):\n233     \"\"\"\n234     Creates a bivariate joint random variable with multivariate Normal gamma\n235     distribution.\n236 \n237     Parameters\n238     ==========\n239 \n240     syms: list/tuple/set of two symbols for identifying each component\n241     mu: A real number, as the mean of the normal distribution\n242     alpha: a positive integer\n243     beta: a positive integer\n244     lamda: a positive integer\n245 \n246     Returns\n247     =======\n248 \n249     A random symbol\n250     \"\"\"\n251     return multivariate_rv(NormalGammaDistribution, syms, mu, lamda, alpha, beta)\n252 \n253 #-------------------------------------------------------------------------------\n254 # Multivariate Beta/Dirichlet distribution ---------------------------------------------------------\n255 \n256 class MultivariateBetaDistribution(JointDistribution):\n257 \n258     _argnames = ['alpha']\n259     is_Continuous = True\n260 \n261     def check(self, alpha):\n262         _value_check(len(alpha) >= 2, \"At least two categories should be passed.\")\n263         for a_k in alpha:\n264             _value_check((a_k > 0) != False, \"Each concentration parameter\"\n265                                             \" should be positive.\")\n266 \n267     @property\n268     def set(self):\n269         k = len(self.alpha)\n270         return Interval(0, 1)**k\n271 \n272     def pdf(self, *syms):\n273         alpha = self.alpha\n274         B = Mul.fromiter(map(gamma, alpha))/gamma(Add(*alpha))\n275         return Mul.fromiter([sym**(a_k - 1) for a_k, sym in zip(alpha, syms)])/B\n276 \n277 def MultivariateBeta(syms, *alpha):\n278     \"\"\"\n279     Creates a continuous random variable with Dirichlet/Multivariate Beta\n280     Distribution.\n281 \n282     The density of the dirichlet distribution can be found at [1].\n283 \n284     Parameters\n285     ==========\n286 \n287     alpha: positive real numbers signifying concentration numbers.\n288 \n289     Returns\n290     =======\n291 \n292     A RandomSymbol.\n293 \n294     Examples\n295     ========\n296 \n297     >>> from sympy.stats import density\n298     >>> from sympy.stats.joint_rv import marginal_distribution\n299     >>> from sympy.stats.joint_rv_types import MultivariateBeta\n300     >>> from sympy import Symbol\n301     >>> a1 = Symbol('a1', positive=True)\n302     >>> a2 = Symbol('a2', positive=True)\n303     >>> B = MultivariateBeta('B', [a1, a2])\n304     >>> C = MultivariateBeta('C', a1, a2)\n305     >>> x = Symbol('x')\n306     >>> y = Symbol('y')\n307     >>> density(B)(x, y)\n308     x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))\n309     >>> marginal_distribution(C, C[0])(x)\n310     x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))\n311 \n312     References\n313     ==========\n314 \n315     .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution\n316     .. [2] http://mathworld.wolfram.com/DirichletDistribution.html\n317 \n318     \"\"\"\n319     if not isinstance(alpha[0], list):\n320         alpha = (list(alpha),)\n321     return multivariate_rv(MultivariateBetaDistribution, syms, alpha[0])\n322 \n323 Dirichlet = MultivariateBeta\n324 \n325 #-------------------------------------------------------------------------------\n326 # Multivariate Ewens distribution ---------------------------------------------------------\n327 \n328 class MultivariateEwensDistribution(JointDistribution):\n329 \n330     _argnames = ['n', 'theta']\n331     is_Discrete = True\n332     is_Continuous = False\n333 \n334     def check(self, n, theta):\n335         _value_check(isinstance(n, Integer) and (n > 0) == True,\n336                         \"sample size should be positive integer.\")\n337         _value_check(theta.is_positive, \"mutation rate should be positive.\")\n338 \n339     @property\n340     def set(self):\n341         prod_set = Range(0, self.n//1 + 1)\n342         for i in range(2, self.n + 1):\n343             prod_set *= Range(0, self.n//i + 1)\n344         return prod_set\n345 \n346     def pdf(self, *syms):\n347         n, theta = self.n, self.theta\n348         term_1 = factorial(n)/rf(theta, n)\n349         term_2 = Mul.fromiter([theta**syms[j]/((j+1)**syms[j]*factorial(syms[j]))\n350                             for j in range(n)])\n351         cond = Eq(sum([(k+1)*syms[k] for k in range(n)]), n)\n352         return Piecewise((term_1 * term_2, cond), (0, True))\n353 \n354 def MultivariateEwens(syms, n, theta):\n355     \"\"\"\n356     Creates a discrete random variable with Multivariate Ewens\n357     Distribution.\n358 \n359     The density of the said distribution can be found at [1].\n360 \n361     Parameters\n362     ==========\n363 \n364     n: positive integer of class Integer,\n365             size of the sample or the integer whose partitions are considered\n366     theta: mutation rate, must be positive real number.\n367 \n368     Returns\n369     =======\n370 \n371     A RandomSymbol.\n372 \n373     Examples\n374     ========\n375 \n376     >>> from sympy.stats import density\n377     >>> from sympy.stats.joint_rv import marginal_distribution\n378     >>> from sympy.stats.joint_rv_types import MultivariateEwens\n379     >>> from sympy import Symbol\n380     >>> a1 = Symbol('a1', positive=True)\n381     >>> a2 = Symbol('a2', positive=True)\n382     >>> ed = MultivariateEwens('E', 2, 1)\n383     >>> density(ed)(a1, a2)\n384     Piecewise((2**(-a2)/(factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))\n385     >>> marginal_distribution(ed, ed[0])(a1)\n386     Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True))\n387 \n388     References\n389     ==========\n390 \n391     .. [1] https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula\n392     .. [2] http://www.stat.rutgers.edu/home/hcrane/Papers/STS529.pdf\n393 \n394     \"\"\"\n395     return multivariate_rv(MultivariateEwensDistribution, syms, n, theta)\n396 \n397 #-------------------------------------------------------------------------------\n398 # Multinomial distribution ---------------------------------------------------------\n399 \n400 class MultinomialDistribution(JointDistribution):\n401 \n402     _argnames = ['n', 'p']\n403     is_Continuous=False\n404     is_Discrete = True\n405 \n406     def check(self, n, p):\n407         _value_check(n > 0,\n408                         \"number of trials must be a positve integer\")\n409         for p_k in p:\n410             _value_check((p_k >= 0, p_k <= 1),\n411                         \"probability must be in range [0, 1]\")\n412         _value_check(Eq(sum(p), 1),\n413                         \"probabilities must sum to 1\")\n414 \n415     @property\n416     def set(self):\n417         return Intersection(S.Naturals0, Interval(0, self.n))**len(self.p)\n418 \n419     def pdf(self, *x):\n420         n, p = self.n, self.p\n421         term_1 = factorial(n)/Mul.fromiter([factorial(x_k) for x_k in x])\n422         term_2 = Mul.fromiter([p_k**x_k for p_k, x_k in zip(p, x)])\n423         return Piecewise((term_1 * term_2, Eq(sum(x), n)), (0, True))\n424 \n425 def Multinomial(syms, n, *p):\n426     \"\"\"\n427     Creates a discrete random variable with Multinomial Distribution.\n428 \n429     The density of the said distribution can be found at [1].\n430 \n431     Parameters\n432     ==========\n433     n: positive integer of class Integer,\n434        number of trials\n435     p: event probabilites, >= 0 and <= 1\n436 \n437     Returns\n438     =======\n439     A RandomSymbol.\n440 \n441     Examples\n442     ========\n443     >>> from sympy.stats import density\n444     >>> from sympy.stats.joint_rv import marginal_distribution\n445     >>> from sympy.stats.joint_rv_types import Multinomial\n446     >>> from sympy import symbols\n447     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)\n448     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)\n449     >>> M = Multinomial('M', 3, p1, p2, p3)\n450     >>> density(M)(x1, x2, x3)\n451     Piecewise((6*p1**x1*p2**x2*p3**x3/(factorial(x1)*factorial(x2)*factorial(x3)),\n452     Eq(x1 + x2 + x3, 3)), (0, True))\n453     >>> marginal_distribution(M, M[0])(x1).subs(x1, 1)\n454     3*p1*p2**2 + 6*p1*p2*p3 + 3*p1*p3**2\n455 \n456     References\n457     ==========\n458     .. [1] https://en.wikipedia.org/wiki/Multinomial_distribution\n459     .. [2] http://mathworld.wolfram.com/MultinomialDistribution.html\n460     \"\"\"\n461     if not isinstance(p[0], list):\n462         p = (list(p), )\n463     return multivariate_rv(MultinomialDistribution, syms, n, p[0])\n464 \n465 #-------------------------------------------------------------------------------\n466 # Negative Multinomial Distribution ---------------------------------------------------------\n467 \n468 class NegativeMultinomialDistribution(JointDistribution):\n469 \n470     _argnames = ['k0', 'p']\n471     is_Continuous=False\n472     is_Discrete = True\n473 \n474     def check(self, k0, p):\n475         _value_check(k0 > 0,\n476                         \"number of failures must be a positve integer\")\n477         for p_k in p:\n478             _value_check((p_k >= 0, p_k <= 1),\n479                         \"probability must be in range [0, 1].\")\n480         _value_check(sum(p) <= 1,\n481                         \"success probabilities must not be greater than 1.\")\n482 \n483     @property\n484     def set(self):\n485         return Range(0, S.Infinity)**len(self.p)\n486 \n487     def pdf(self, *k):\n488         k0, p = self.k0, self.p\n489         term_1 = (gamma(k0 + sum(k))*(1 - sum(p))**k0)/gamma(k0)\n490         term_2 = Mul.fromiter([pi**ki/factorial(ki) for pi, ki in zip(p, k)])\n491         return term_1 * term_2\n492 \n493 def NegativeMultinomial(syms, k0, *p):\n494     \"\"\"\n495     Creates a discrete random variable with Negative Multinomial Distribution.\n496 \n497     The density of the said distribution can be found at [1].\n498 \n499     Parameters\n500     ==========\n501     k0: positive integer of class Integer,\n502         number of failures before the experiment is stopped\n503     p: event probabilites, >= 0 and <= 1\n504 \n505     Returns\n506     =======\n507     A RandomSymbol.\n508 \n509     Examples\n510     ========\n511     >>> from sympy.stats import density\n512     >>> from sympy.stats.joint_rv import marginal_distribution\n513     >>> from sympy.stats.joint_rv_types import NegativeMultinomial\n514     >>> from sympy import symbols\n515     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)\n516     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)\n517     >>> N = NegativeMultinomial('M', 3, p1, p2, p3)\n518     >>> N_c = NegativeMultinomial('M', 3, 0.1, 0.1, 0.1)\n519     >>> density(N)(x1, x2, x3)\n520     p1**x1*p2**x2*p3**x3*(-p1 - p2 - p3 + 1)**3*gamma(x1 + x2 +\n521     x3 + 3)/(2*factorial(x1)*factorial(x2)*factorial(x3))\n522     >>> marginal_distribution(N_c, N_c[0])(1).evalf().round(2)\n523     0.25\n524 \n525 \n526     References\n527     ==========\n528     .. [1] https://en.wikipedia.org/wiki/Negative_multinomial_distribution\n529     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html\n530     \"\"\"\n531     if not isinstance(p[0], list):\n532         p = (list(p), )\n533     return multivariate_rv(NegativeMultinomialDistribution, syms, k0, p[0])\n",
        "intended_behavior": "Validate parameters considering their interactions within the joint distributions. This might involve more complex checks to ensure that the parameters of one distribution are compatible with the parameters of another within a joint distribution. Implementation of attributes that clarify these relationships and their constraints is also necessary."
    },
    {
        "rel_file_path": "sympy/stats/frv_types.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/stats/frv_types.py",
        "start": 1,
        "end": 383,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Finite Discrete Random Variables - Prebuilt variable types\n3 \n4 Contains\n5 ========\n6 FiniteRV\n7 DiscreteUniform\n8 Die\n9 Bernoulli\n10 Coin\n11 Binomial\n12 Hypergeometric\n13 Rademacher\n14 \"\"\"\n15 \n16 from __future__ import print_function, division\n17 \n18 from sympy import (S, sympify, Rational, binomial, cacheit, Integer,\n19         Dict, Basic, KroneckerDelta, Dummy, Eq)\n20 from sympy.concrete.summations import Sum\n21 from sympy.core.compatibility import as_int, range\n22 from sympy.stats.rv import _value_check\n23 from sympy.stats.frv import (SingleFinitePSpace, SingleFiniteDistribution)\n24 \n25 __all__ = ['FiniteRV',\n26 'DiscreteUniform',\n27 'Die',\n28 'Bernoulli',\n29 'Coin',\n30 'Binomial',\n31 'Hypergeometric',\n32 'Rademacher'\n33 ]\n34 \n35 def rv(name, cls, *args):\n36     args = list(map(sympify, args))\n37     i = 0\n38     while i < len(args): # Converting to Dict since dict is not hashable\n39         if isinstance(args[i], dict):\n40             args[i] = Dict(args[i])\n41         i += 1\n42     dist = cls(*args)\n43     dist.check(*args)\n44     return SingleFinitePSpace(name, dist).value\n45 \n46 class FiniteDistributionHandmade(SingleFiniteDistribution):\n47     @property\n48     def dict(self):\n49         return self.args[0]\n50 \n51     @staticmethod\n52     def check(density):\n53         for p in density.values():\n54             _value_check((p >= 0, p <= 1),\n55                         \"Probability at a point must be between 0 and 1.\")\n56         _value_check(Eq(sum(density.values()), 1), \"Total Probability must be 1.\")\n57 \n58 def FiniteRV(name, density):\n59     \"\"\"\n60     Create a Finite Random Variable given a dict representing the density.\n61 \n62     Returns a RandomSymbol.\n63 \n64     >>> from sympy.stats import FiniteRV, P, E\n65 \n66     >>> density = {0: .1, 1: .2, 2: .3, 3: .4}\n67     >>> X = FiniteRV('X', density)\n68 \n69     >>> E(X)\n70     2.00000000000000\n71     >>> P(X >= 2)\n72     0.700000000000000\n73     \"\"\"\n74     return rv(name, FiniteDistributionHandmade, density)\n75 \n76 class DiscreteUniformDistribution(SingleFiniteDistribution):\n77     @property\n78     def p(self):\n79         return Rational(1, len(self.args))\n80 \n81     @property\n82     @cacheit\n83     def dict(self):\n84         return dict((k, self.p) for k in self.set)\n85 \n86     @property\n87     def set(self):\n88         return self.args\n89 \n90     def pdf(self, x):\n91         if x in self.args:\n92             return self.p\n93         else:\n94             return S.Zero\n95 \n96 \n97 def DiscreteUniform(name, items):\n98     \"\"\"\n99     Create a Finite Random Variable representing a uniform distribution over\n100     the input set.\n101 \n102     Returns a RandomSymbol.\n103 \n104     Examples\n105     ========\n106 \n107     >>> from sympy.stats import DiscreteUniform, density\n108     >>> from sympy import symbols\n109 \n110     >>> X = DiscreteUniform('X', symbols('a b c')) # equally likely over a, b, c\n111     >>> density(X).dict\n112     {a: 1/3, b: 1/3, c: 1/3}\n113 \n114     >>> Y = DiscreteUniform('Y', list(range(5))) # distribution over a range\n115     >>> density(Y).dict\n116     {0: 1/5, 1: 1/5, 2: 1/5, 3: 1/5, 4: 1/5}\n117 \n118     References\n119     ==========\n120 \n121     .. [1] https://en.wikipedia.org/wiki/Discrete_uniform_distribution\n122     .. [2] http://mathworld.wolfram.com/DiscreteUniformDistribution.html\n123 \n124     \"\"\"\n125     return rv(name, DiscreteUniformDistribution, *items)\n126 \n127 \n128 class DieDistribution(SingleFiniteDistribution):\n129     _argnames = ('sides',)\n130 \n131     @staticmethod\n132     def check(sides):\n133         _value_check((sides.is_positive, sides.is_integer),\n134                     \"number of sides must be a positive integer.\")\n135 \n136     @property\n137     @cacheit\n138     def dict(self):\n139         as_int(self.sides) # Check that self.sides can be converted to an integer\n140         return super(DieDistribution, self).dict\n141 \n142     @property\n143     def set(self):\n144         return list(map(Integer, list(range(1, self.sides + 1))))\n145 \n146     def pdf(self, x):\n147         x = sympify(x)\n148         if x.is_number:\n149             if x.is_Integer and x >= 1 and x <= self.sides:\n150                 return Rational(1, self.sides)\n151             return S.Zero\n152         if x.is_Symbol:\n153             i = Dummy('i', integer=True, positive=True)\n154             return Sum(KroneckerDelta(x, i)/self.sides, (i, 1, self.sides))\n155         raise ValueError(\"'x' expected as an argument of type 'number' or 'symbol', \"\n156                         \"not %s\" % (type(x)))\n157 \n158 \n159 def Die(name, sides=6):\n160     \"\"\"\n161     Create a Finite Random Variable representing a fair die.\n162 \n163     Returns a RandomSymbol.\n164 \n165     Examples\n166     ========\n167 \n168     >>> from sympy.stats import Die, density\n169 \n170     >>> D6 = Die('D6', 6) # Six sided Die\n171     >>> density(D6).dict\n172     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}\n173 \n174     >>> D4 = Die('D4', 4) # Four sided Die\n175     >>> density(D4).dict\n176     {1: 1/4, 2: 1/4, 3: 1/4, 4: 1/4}\n177     \"\"\"\n178 \n179     return rv(name, DieDistribution, sides)\n180 \n181 \n182 class BernoulliDistribution(SingleFiniteDistribution):\n183     _argnames = ('p', 'succ', 'fail')\n184 \n185     @staticmethod\n186     def check(p, succ, fail):\n187         _value_check((p >= 0, p <= 1),\n188                     \"p should be in range [0, 1].\")\n189 \n190     @property\n191     @cacheit\n192     def dict(self):\n193         return {self.succ: self.p, self.fail: 1 - self.p}\n194 \n195 \n196 def Bernoulli(name, p, succ=1, fail=0):\n197     \"\"\"\n198     Create a Finite Random Variable representing a Bernoulli process.\n199 \n200     Returns a RandomSymbol\n201 \n202     Examples\n203     ========\n204 \n205     >>> from sympy.stats import Bernoulli, density\n206     >>> from sympy import S\n207 \n208     >>> X = Bernoulli('X', S(3)/4) # 1-0 Bernoulli variable, probability = 3/4\n209     >>> density(X).dict\n210     {0: 1/4, 1: 3/4}\n211 \n212     >>> X = Bernoulli('X', S.Half, 'Heads', 'Tails') # A fair coin toss\n213     >>> density(X).dict\n214     {Heads: 1/2, Tails: 1/2}\n215 \n216     References\n217     ==========\n218 \n219     .. [1] https://en.wikipedia.org/wiki/Bernoulli_distribution\n220     .. [2] http://mathworld.wolfram.com/BernoulliDistribution.html\n221 \n222     \"\"\"\n223 \n224     return rv(name, BernoulliDistribution, p, succ, fail)\n225 \n226 \n227 def Coin(name, p=S.Half):\n228     \"\"\"\n229     Create a Finite Random Variable representing a Coin toss.\n230 \n231     Probability p is the chance of gettings \"Heads.\" Half by default\n232 \n233     Returns a RandomSymbol.\n234 \n235     Examples\n236     ========\n237 \n238     >>> from sympy.stats import Coin, density\n239     >>> from sympy import Rational\n240 \n241     >>> C = Coin('C') # A fair coin toss\n242     >>> density(C).dict\n243     {H: 1/2, T: 1/2}\n244 \n245     >>> C2 = Coin('C2', Rational(3, 5)) # An unfair coin\n246     >>> density(C2).dict\n247     {H: 3/5, T: 2/5}\n248 \n249     See Also\n250     ========\n251 \n252     sympy.stats.Binomial\n253 \n254     References\n255     ==========\n256 \n257     .. [1] https://en.wikipedia.org/wiki/Coin_flipping\n258 \n259     \"\"\"\n260     return rv(name, BernoulliDistribution, p, 'H', 'T')\n261 \n262 \n263 class BinomialDistribution(SingleFiniteDistribution):\n264     _argnames = ('n', 'p', 'succ', 'fail')\n265 \n266     @staticmethod\n267     def check(n, p, succ, fail):\n268         _value_check((n.is_integer, n.is_nonnegative),\n269                     \"'n' must be nonnegative integer.\")\n270         _value_check((p <= 1, p >= 0),\n271                     \"p should be in range [0, 1].\")\n272 \n273     @property\n274     @cacheit\n275     def dict(self):\n276         n, p, succ, fail = self.n, self.p, self.succ, self.fail\n277         n = as_int(n)\n278         return dict((k*succ + (n - k)*fail,\n279                 binomial(n, k) * p**k * (1 - p)**(n - k)) for k in range(0, n + 1))\n280 \n281 \n282 def Binomial(name, n, p, succ=1, fail=0):\n283     \"\"\"\n284     Create a Finite Random Variable representing a binomial distribution.\n285 \n286     Returns a RandomSymbol.\n287 \n288     Examples\n289     ========\n290 \n291     >>> from sympy.stats import Binomial, density\n292     >>> from sympy import S\n293 \n294     >>> X = Binomial('X', 4, S.Half) # Four \"coin flips\"\n295     >>> density(X).dict\n296     {0: 1/16, 1: 1/4, 2: 3/8, 3: 1/4, 4: 1/16}\n297 \n298     References\n299     ==========\n300 \n301     .. [1] https://en.wikipedia.org/wiki/Binomial_distribution\n302     .. [2] http://mathworld.wolfram.com/BinomialDistribution.html\n303 \n304     \"\"\"\n305 \n306     return rv(name, BinomialDistribution, n, p, succ, fail)\n307 \n308 \n309 class HypergeometricDistribution(SingleFiniteDistribution):\n310     _argnames = ('N', 'm', 'n')\n311 \n312     @property\n313     @cacheit\n314     def dict(self):\n315         N, m, n = self.N, self.m, self.n\n316         N, m, n = list(map(sympify, (N, m, n)))\n317         density = dict((sympify(k),\n318                         Rational(binomial(m, k) * binomial(N - m, n - k),\n319                                  binomial(N, n)))\n320                         for k in range(max(0, n + m - N), min(m, n) + 1))\n321         return density\n322 \n323 \n324 def Hypergeometric(name, N, m, n):\n325     \"\"\"\n326     Create a Finite Random Variable representing a hypergeometric distribution.\n327 \n328     Returns a RandomSymbol.\n329 \n330     Examples\n331     ========\n332 \n333     >>> from sympy.stats import Hypergeometric, density\n334     >>> from sympy import S\n335 \n336     >>> X = Hypergeometric('X', 10, 5, 3) # 10 marbles, 5 white (success), 3 draws\n337     >>> density(X).dict\n338     {0: 1/12, 1: 5/12, 2: 5/12, 3: 1/12}\n339 \n340     References\n341     ==========\n342 \n343     .. [1] https://en.wikipedia.org/wiki/Hypergeometric_distribution\n344     .. [2] http://mathworld.wolfram.com/HypergeometricDistribution.html\n345 \n346     \"\"\"\n347     return rv(name, HypergeometricDistribution, N, m, n)\n348 \n349 \n350 class RademacherDistribution(SingleFiniteDistribution):\n351     @property\n352     @cacheit\n353     def dict(self):\n354         return {-1: S.Half, 1: S.Half}\n355 \n356 \n357 def Rademacher(name):\n358     \"\"\"\n359     Create a Finite Random Variable representing a Rademacher distribution.\n360 \n361     Return a RandomSymbol.\n362 \n363     Examples\n364     ========\n365 \n366     >>> from sympy.stats import Rademacher, density\n367 \n368     >>> X = Rademacher('X')\n369     >>> density(X).dict\n370     {-1: 1/2, 1: 1/2}\n371 \n372     See Also\n373     ========\n374 \n375     sympy.stats.Bernoulli\n376 \n377     References\n378     ==========\n379 \n380     .. [1] https://en.wikipedia.org/wiki/Rademacher_distribution\n381 \n382     \"\"\"\n383     return rv(name, RademacherDistribution)\n",
        "intended_behavior": "Ensure completeness in parameter checking, especially since finite distributions might have specific constraints on their parameters. Attributes related to these distributions should be clear and follow consistent patterns as in other distribution types."
    }
]