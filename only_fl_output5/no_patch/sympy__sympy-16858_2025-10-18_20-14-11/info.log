2025-10-18 20:14:11.298 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 20:14:20.843 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=397, output_tokens=12, cost=0.004330
2025-10-18 20:14:20.844 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 20:14:20.847 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:14:30.611 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=529, output_tokens=429, cost=0.018160
2025-10-18 20:14:30.615 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:14:32.950 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=783, output_tokens=37, cost=0.008940
2025-10-18 20:14:32.951 | DEBUG    | Extracted a valid json.
2025-10-18 20:14:32.951 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"sympy.stats\")", "search_method(\"check\")", "search_code(\"pdf\")"],
    "bug_locations": []
}
2025-10-18 20:14:34.808 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:14:34.809 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:14:50.028 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2473, output_tokens=717, cost=0.046240
2025-10-18 20:14:50.035 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:15:03.807 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3406, output_tokens=639, cost=0.053230
2025-10-18 20:15:03.818 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:15:11.269 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=993, output_tokens=331, cost=0.019860
2025-10-18 20:15:11.271 | DEBUG    | Extracted a valid json.
2025-10-18 20:15:11.271 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/stats/crv_types.py",
            "class": "",
            "method": "",
            "intended_behavior": "Enhance the `check` methods to include all necessary validations for the parameters of each continuous distribution. Ensure that inappropriate values raise appropriate errors or warnings. Additionally, ensure that all relevant attributes are correctly set and accessible for these distributions."
        },
        {
            "file": "sympy/stats/drv_types.py",
            "class": "",
            "method": "",
            "intended_behavior": "Similar to `crv_types.py`, validations within `check` methods should be exhaustive, covering the domain of possible parameters to prevent invalid configurations. Ensure attributes related to the distributions are correctly implemented and documented."
        },
        {
            "file": "sympy/stats/joint_rv_types.py",
            "class": "",
            "method": "",
            "intended_behavior": "Validate parameters considering their interactions within the joint distributions. This might involve more complex checks to ensure that the parameters of one distribution are compatible with the parameters of another within a joint distribution. Implementation of attributes that clarify these relationships and their constraints is also necessary."
        },
        {
            "file": "sympy/stats/frv_types.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure completeness in parameter checking, especially since finite distributions might have specific constraints on their parameters. Attributes related to these distributions should be clear and follow consistent patterns as in other distribution types."
        }
    ]
}
2025-10-18 20:15:11.282 | DEBUG    | Bug location extracted successfully: [<file>sympy/stats/crv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Continuous Random Variables - Prebuilt variables
3 
4 Contains
5 ========
6 Arcsin
7 Benini
8 Beta
9 BetaNoncentral
10 BetaPrime
11 Cauchy
12 Chi
13 ChiNoncentral
14 ChiSquared
15 Dagum
16 Erlang
17 Exponential
18 FDistribution
19 FisherZ
20 Frechet
21 Gamma
22 GammaInverse
23 Gumbel
24 Gompertz
25 Kumaraswamy
26 Laplace
27 Logistic
28 LogNormal
29 Maxwell
30 Nakagami
31 Normal
32 Pareto
33 QuadraticU
34 RaisedCosine
35 Rayleigh
36 ShiftedGompertz
37 StudentT
38 Trapezoidal
39 Triangular
40 Uniform
41 UniformSum
42 VonMises
43 Weibull
44 WignerSemicircle
45 """
46 
47 from __future__ import print_function, division
48 
49 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma,
50                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,
51                    Lambda, Basic, lowergamma, erf, erfi,  erfinv, I, hyper,
52                    uppergamma, sinh, atan, Ne, expint)
53 
54 from sympy import beta as beta_fn
55 from sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk
56 from sympy.external import import_module
57 from sympy.matrices import MatrixBase
58 from sympy.stats.crv import (SingleContinuousPSpace, SingleContinuousDistribution,
59         ContinuousDistributionHandmade)
60 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
61 from sympy.stats.joint_rv_types import multivariate_rv
62 from sympy.stats.rv import _value_check, RandomSymbol
63 import random
64 
65 oo = S.Infinity
66 
67 __all__ = ['ContinuousRV',
68 'Arcsin',
69 'Benini',
70 'Beta',
71 'BetaNoncentral',
72 'BetaPrime',
73 'Cauchy',
74 'Chi',
75 'ChiNoncentral',
76 'ChiSquared',
77 'Dagum',
78 'Erlang',
79 'Exponential',
80 'FDistribution',
81 'FisherZ',
82 'Frechet',
83 'Gamma',
84 'GammaInverse',
85 'Gompertz',
86 'Gumbel',
87 'Kumaraswamy',
88 'Laplace',
89 'Logistic',
90 'LogNormal',
91 'Maxwell',
92 'Nakagami',
93 'Normal',
94 'Pareto',
95 'QuadraticU',
96 'RaisedCosine',
97 'Rayleigh',
98 'StudentT',
99 'ShiftedGompertz',
100 'Trapezoidal',
101 'Triangular',
102 'Uniform',
103 'UniformSum',
104 'VonMises',
105 'Weibull',
106 'WignerSemicircle'
107 ]
108 
109 
110 
111 def ContinuousRV(symbol, density, set=Interval(-oo, oo)):
112     """
113     Create a Continuous Random Variable given the following:
114 
115     -- a symbol
116     -- a probability density function
117     -- set on which the pdf is valid (defaults to entire real line)
118 
119     Returns a RandomSymbol.
120 
121     Many common continuous random variable types are already implemented.
122     This function should be necessary only very rarely.
123 
124     Examples
125     ========
126 
127     >>> from sympy import Symbol, sqrt, exp, pi
128     >>> from sympy.stats import ContinuousRV, P, E
129 
130     >>> x = Symbol("x")
131 
132     >>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution
133     >>> X = ContinuousRV(x, pdf)
134 
135     >>> E(X)
136     0
137     >>> P(X>0)
138     1/2
139     """
140     pdf = Piecewise((density, set.as_relational(symbol)), (0, True))
141     pdf = Lambda(symbol, pdf)
142     dist = ContinuousDistributionHandmade(pdf, set)
143     return SingleContinuousPSpace(symbol, dist).value
144 
145 
146 def rv(symbol, cls, args):
147     args = list(map(sympify, args))
148     dist = cls(*args)
149     dist.check(*args)
150     pspace = SingleContinuousPSpace(symbol, dist)
151     if any(isinstance(arg, RandomSymbol) for arg in args):
152         pspace = JointPSpace(symbol, CompoundDistribution(dist))
153     return pspace.value
154 
155 ########################################
156 # Continuous Probability Distributions #
157 ########################################
158 
159 #-------------------------------------------------------------------------------
160 # Arcsin distribution ----------------------------------------------------------
161 
162 
163 class ArcsinDistribution(SingleContinuousDistribution):
164     _argnames = ('a', 'b')
165 
166     def pdf(self, x):
167         return 1/(pi*sqrt((x - self.a)*(self.b - x)))
168 
169     def _cdf(self, x):
170         from sympy import asin
171         a, b = self.a, self.b
172         return Piecewise(
173             (S.Zero, x < a),
174             (2*asin(sqrt((x - a)/(b - a)))/pi, x <= b),
175             (S.One, True))
176 
177 
178 def Arcsin(name, a=0, b=1):
179     r"""
180     Create a Continuous Random Variable with an arcsin distribution.
181 
182     The density of the arcsin distribution is given by
183 
184     .. math::
185         f(x) := \frac{1}{\pi\sqrt{(x-a)(b-x)}}
186 
187     with :math:`x \in (a,b)`. It must hold that :math:`-\infty < a < b < \infty`.
188 
189     Parameters
190     ==========
191 
192     a : Real number, the left interval boundary
193     b : Real number, the right interval boundary
194 
195     Returns
196     =======
197 
198     A RandomSymbol.
199 
200     Examples
201     ========
202 
203     >>> from sympy.stats import Arcsin, density, cdf
204     >>> from sympy import Symbol, simplify
205 
206     >>> a = Symbol("a", real=True)
207     >>> b = Symbol("b", real=True)
208     >>> z = Symbol("z")
209 
210     >>> X = Arcsin("x", a, b)
211 
212     >>> density(X)(z)
213     1/(pi*sqrt((-a + z)*(b - z)))
214 
215     >>> cdf(X)(z)
216     Piecewise((0, a > z),
217             (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),
218             (1, True))
219 
220 
221     References
222     ==========
223 
224     .. [1] https://en.wikipedia.org/wiki/Arcsine_distribution
225 
226     """
227 
228     return rv(name, ArcsinDistribution, (a, b))
229 
230 #-------------------------------------------------------------------------------
231 # Benini distribution ----------------------------------------------------------
232 
233 
234 class BeniniDistribution(SingleContinuousDistribution):
235     _argnames = ('alpha', 'beta', 'sigma')
236 
237     @staticmethod
238     def check(alpha, beta, sigma):
239         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
240         _value_check(beta > 0, "Shape parameter Beta must be positive.")
241         _value_check(sigma > 0, "Scale parameter Sigma must be positive.")
242 
243     @property
244     def set(self):
245         return Interval(self.sigma, oo)
246 
247     def pdf(self, x):
248         alpha, beta, sigma = self.alpha, self.beta, self.sigma
249         return (exp(-alpha*log(x/sigma) - beta*log(x/sigma)**2)
250                *(alpha/x + 2*beta*log(x/sigma)/x))
251 
252     def _moment_generating_function(self, t):
253         raise NotImplementedError('The moment generating function of the '
254                                   'Benini distribution does not exist.')
255 
256 def Benini(name, alpha, beta, sigma):
257     r"""
258     Create a Continuous Random Variable with a Benini distribution.
259 
260     The density of the Benini distribution is given by
261 
262     .. math::
263         f(x) := e^{-\alpha\log{\frac{x}{\sigma}}
264                 -\beta\log^2\left[{\frac{x}{\sigma}}\right]}
265                 \left(\frac{\alpha}{x}+\frac{2\beta\log{\frac{x}{\sigma}}}{x}\right)
266 
267     This is a heavy-tailed distrubtion and is also known as the log-Rayleigh
268     distribution.
269 
270     Parameters
271     ==========
272 
273     alpha : Real number, `\alpha > 0`, a shape
274     beta : Real number, `\beta > 0`, a shape
275     sigma : Real number, `\sigma > 0`, a scale
276 
277     Returns
278     =======
279 
280     A RandomSymbol.
281 
282     Examples
283     ========
284 
285     >>> from sympy.stats import Benini, density, cdf
286     >>> from sympy import Symbol, simplify, pprint
287 
288     >>> alpha = Symbol("alpha", positive=True)
289     >>> beta = Symbol("beta", positive=True)
290     >>> sigma = Symbol("sigma", positive=True)
291     >>> z = Symbol("z")
292 
293     >>> X = Benini("x", alpha, beta, sigma)
294 
295     >>> D = density(X)(z)
296     >>> pprint(D, use_unicode=False)
297     /                  /  z  \\             /  z  \            2/  z  \
298     |        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|
299     |alpha             \sigma/|             \sigma/             \sigma/
300     |----- + -----------------|*e
301     \  z             z        /
302 
303     >>> cdf(X)(z)
304     Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),
305             (0, True))
306 
307 
308     References
309     ==========
310 
311     .. [1] https://en.wikipedia.org/wiki/Benini_distribution
312     .. [2] http://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html
313 
314     """
315 
316     return rv(name, BeniniDistribution, (alpha, beta, sigma))
317 
318 #-------------------------------------------------------------------------------
319 # Beta distribution ------------------------------------------------------------
320 
321 
322 class BetaDistribution(SingleContinuousDistribution):
323     _argnames = ('alpha', 'beta')
324 
325     set = Interval(0, 1)
326 
327     @staticmethod
328     def check(alpha, beta):
329         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
330         _value_check(beta > 0, "Shape parameter Beta must be positive.")
331 
332     def pdf(self, x):
333         alpha, beta = self.alpha, self.beta
334         return x**(alpha - 1) * (1 - x)**(beta - 1) / beta_fn(alpha, beta)
335 
336     def sample(self):
337         return random.betavariate(self.alpha, self.beta)
338 
339     def _characteristic_function(self, t):
340         return hyper((self.alpha,), (self.alpha + self.beta,), I*t)
341 
342     def _moment_generating_function(self, t):
343         return hyper((self.alpha,), (self.alpha + self.beta,), t)
344 
345 def Beta(name, alpha, beta):
346     r"""
347     Create a Continuous Random Variable with a Beta distribution.
348 
349     The density of the Beta distribution is given by
350 
351     .. math::
352         f(x) := \frac{x^{\alpha-1}(1-x)^{\beta-1}} {\mathrm{B}(\alpha,\beta)}
353 
354     with :math:`x \in [0,1]`.
355 
356     Parameters
357     ==========
358 
359     alpha : Real number, `\alpha > 0`, a shape
360     beta : Real number, `\beta > 0`, a shape
361 
362     Returns
363     =======
364 
365     A RandomSymbol.
366 
367     Examples
368     ========
369 
370     >>> from sympy.stats import Beta, density, E, variance
371     >>> from sympy import Symbol, simplify, pprint, factor
372 
373     >>> alpha = Symbol("alpha", positive=True)
374     >>> beta = Symbol("beta", positive=True)
375     >>> z = Symbol("z")
376 
377     >>> X = Beta("x", alpha, beta)
378 
379     >>> D = density(X)(z)
380     >>> pprint(D, use_unicode=False)
381      alpha - 1        beta - 1
382     z         *(1 - z)
383     --------------------------
384           B(alpha, beta)
385 
386     >>> simplify(E(X))
387     alpha/(alpha + beta)
388 
389     >>> factor(simplify(variance(X)))  #doctest: +SKIP
390     alpha*beta/((alpha + beta)**2*(alpha + beta + 1))
391 
392     References
393     ==========
394 
395     .. [1] https://en.wikipedia.org/wiki/Beta_distribution
396     .. [2] http://mathworld.wolfram.com/BetaDistribution.html
397 
398     """
399 
400     return rv(name, BetaDistribution, (alpha, beta))
401 
402 #-------------------------------------------------------------------------------
403 # Noncentral Beta distribution ------------------------------------------------------------
404 
405 
406 class BetaNoncentralDistribution(SingleContinuousDistribution):
407     _argnames = ('alpha', 'beta', 'lamda')
408 
409     set = Interval(0, 1)
410 
411     @staticmethod
412     def check(alpha, beta, lamda):
413         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
414         _value_check(beta > 0, "Shape parameter Beta must be positive.")
415         _value_check(lamda >= 0, "Noncentrality parameter Lambda must be positive")
416 
417     def pdf(self, x):
418         alpha, beta, lamda = self.alpha, self.beta, self.lamda
419         k = Dummy("k")
420         return Sum(exp(-lamda / 2) * (lamda / 2)**k * x**(alpha + k - 1) *(
421             1 - x)**(beta - 1) / (factorial(k) * beta_fn(alpha + k, beta)), (k, 0, oo))
422 
423 def BetaNoncentral(name, alpha, beta, lamda):
424     r"""
425     Create a Continuous Random Variable with a Type I Noncentral Beta distribution.
426 
427     The density of the Noncentral Beta distribution is given by
428 
429     .. math::
430         f(x) := \sum_{k=0}^\infty e^{-\lambda/2}\frac{(\lambda/2)^k}{k!}
431                 \frac{x^{\alpha+k-1}(1-x)^{\beta-1}}{\mathrm{B}(\alpha+k,\beta)}
432 
433     with :math:`x \in [0,1]`.
434 
435     Parameters
436     ==========
437 
438     alpha : Real number, `\alpha > 0`, a shape
439     beta : Real number, `\beta > 0`, a shape
440     lamda: Real number, `\lambda >= 0`, noncentrality parameter
441 
442     Returns
443     =======
444 
445     A RandomSymbol.
446 
447     Examples
448     ========
449 
450     >>> from sympy.stats import BetaNoncentral, density, cdf
451     >>> from sympy import Symbol, pprint
452 
453     >>> alpha = Symbol("alpha", positive=True)
454     >>> beta = Symbol("beta", positive=True)
455     >>> lamda = Symbol("lamda", nonnegative=True)
456     >>> z = Symbol("z")
457 
458     >>> X = BetaNoncentral("x", alpha, beta, lamda)
459 
460     >>> D = density(X)(z)
461     >>> pprint(D, use_unicode=False)
462       oo
463     _____
464     \    `
465      \                                              -lamda
466       \                          k                  -------
467        \    k + alpha - 1 /lamda\         beta - 1     2
468         )  z             *|-----| *(1 - z)        *e
469        /                  \  2  /
470       /    ------------------------------------------------
471      /                  B(k + alpha, beta)*k!
472     /____,
473     k = 0
474 
475     Compute cdf with specific 'x', 'alpha', 'beta' and 'lamda' values as follows :
476     >>> cdf(BetaNoncentral("x", 1, 1, 1), evaluate=False)(2).doit()
477     exp(-1/2)*Integral(Sum(2**(-_k)*_x**_k/(beta(_k + 1, 1)*factorial(_k)), (_k, 0, oo)), (_x, 0, 2))
478 
479     The argument evaluate=False prevents an attempt at evaluation
480     of the sum for general x, before the argument 2 is passed.
481 
482     References
483     ==========
484 
485     .. [1] https://en.wikipedia.org/wiki/Noncentral_beta_distribution
486     .. [2] https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html
487 
488     """
489 
490     return rv(name, BetaNoncentralDistribution, (alpha, beta, lamda))
491 
492 
493 #-------------------------------------------------------------------------------
494 # Beta prime distribution ------------------------------------------------------
495 
496 
497 class BetaPrimeDistribution(SingleContinuousDistribution):
498     _argnames = ('alpha', 'beta')
499 
500     @staticmethod
501     def check(alpha, beta):
502         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
503         _value_check(beta > 0, "Shape parameter Beta must be positive.")
504 
505     set = Interval(0, oo)
506 
507     def pdf(self, x):
508         alpha, beta = self.alpha, self.beta
509         return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)
510 
511 def BetaPrime(name, alpha, beta):
512     r"""
513     Create a continuous random variable with a Beta prime distribution.
514 
515     The density of the Beta prime distribution is given by
516 
517     .. math::
518         f(x) := \frac{x^{\alpha-1} (1+x)^{-\alpha -\beta}}{B(\alpha,\beta)}
519 
520     with :math:`x > 0`.
521 
522     Parameters
523     ==========
524 
525     alpha : Real number, `\alpha > 0`, a shape
526     beta : Real number, `\beta > 0`, a shape
527 
528     Returns
529     =======
530 
531     A RandomSymbol.
532 
533     Examples
534     ========
535 
536     >>> from sympy.stats import BetaPrime, density
537     >>> from sympy import Symbol, pprint
538 
539     >>> alpha = Symbol("alpha", positive=True)
540     >>> beta = Symbol("beta", positive=True)
541     >>> z = Symbol("z")
542 
543     >>> X = BetaPrime("x", alpha, beta)
544 
545     >>> D = density(X)(z)
546     >>> pprint(D, use_unicode=False)
547      alpha - 1        -alpha - beta
548     z         *(z + 1)
549     -------------------------------
550              B(alpha, beta)
551 
552     References
553     ==========
554 
555     .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution
556     .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html
557 
558     """
559 
560     return rv(name, BetaPrimeDistribution, (alpha, beta))
561 
562 #-------------------------------------------------------------------------------
563 # Cauchy distribution ----------------------------------------------------------
564 
565 
566 class CauchyDistribution(SingleContinuousDistribution):
567     _argnames = ('x0', 'gamma')
568 
569     @staticmethod
570     def check(x0, gamma):
571         _value_check(gamma > 0, "Scale parameter Gamma must be positive.")
572 
573     def pdf(self, x):
574         return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))
575 
576     def _cdf(self, x):
577         x0, gamma = self.x0, self.gamma
578         return (1/pi)*atan((x - x0)/gamma) + S.Half
579 
580     def _characteristic_function(self, t):
581         return exp(self.x0 * I * t -  self.gamma * Abs(t))
582 
583     def _moment_generating_function(self, t):
584         raise NotImplementedError("The moment generating function for the "
585                                   "Cauchy distribution does not exist.")
586 
587     def _quantile(self, p):
588         return self.x0 + self.gamma*tan(pi*(p - S.Half))
589 
590 def Cauchy(name, x0, gamma):
591     r"""
592     Create a continuous random variable with a Cauchy distribution.
593 
594     The density of the Cauchy distribution is given by
595 
596     .. math::
597         f(x) := \frac{1}{\pi \gamma [1 + {(\frac{x-x_0}{\gamma})}^2]}
598 
599     Parameters
600     ==========
601 
602     x0 : Real number, the location
603     gamma : Real number, `\gamma > 0`, a scale
604 
605     Returns
606     =======
607 
608     A RandomSymbol.
609 
610     Examples
611     ========
612 
613     >>> from sympy.stats import Cauchy, density
614     >>> from sympy import Symbol
615 
616     >>> x0 = Symbol("x0")
617     >>> gamma = Symbol("gamma", positive=True)
618     >>> z = Symbol("z")
619 
620     >>> X = Cauchy("x", x0, gamma)
621 
622     >>> density(X)(z)
623     1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2))
624 
625     References
626     ==========
627 
628     .. [1] https://en.wikipedia.org/wiki/Cauchy_distribution
629     .. [2] http://mathworld.wolfram.com/CauchyDistribution.html
630 
631     """
632 
633     return rv(name, CauchyDistribution, (x0, gamma))
634 
635 #-------------------------------------------------------------------------------
636 # Chi distribution -------------------------------------------------------------
637 
638 
639 class ChiDistribution(SingleContinuousDistribution):
640     _argnames = ('k',)
641 
642     @staticmethod
643     def check(k):
644         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
645         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
646 
647     set = Interval(0, oo)
648 
649     def pdf(self, x):
650         return 2**(1 - self.k/2)*x**(self.k - 1)*exp(-x**2/2)/gamma(self.k/2)
651 
652     def _characteristic_function(self, t):
653         k = self.k
654 
655         part_1 = hyper((k/2,), (S(1)/2,), -t**2/2)
656         part_2 = I*t*sqrt(2)*gamma((k+1)/2)/gamma(k/2)
657         part_3 = hyper(((k+1)/2,), (S(3)/2,), -t**2/2)
658         return part_1 + part_2*part_3
659 
660     def _moment_generating_function(self, t):
661         k = self.k
662 
663         part_1 = hyper((k / 2,), (S(1) / 2,), t ** 2 / 2)
664         part_2 = t * sqrt(2) * gamma((k + 1) / 2) / gamma(k / 2)
665         part_3 = hyper(((k + 1) / 2,), (S(3) / 2,), t ** 2 / 2)
666         return part_1 + part_2 * part_3
667 
668 def Chi(name, k):
669     r"""
670     Create a continuous random variable with a Chi distribution.
671 
672     The density of the Chi distribution is given by
673 
674     .. math::
675         f(x) := \frac{2^{1-k/2}x^{k-1}e^{-x^2/2}}{\Gamma(k/2)}
676 
677     with :math:`x \geq 0`.
678 
679     Parameters
680     ==========
681 
682     k : Positive integer, The number of degrees of freedom
683 
684     Returns
685     =======
686 
687     A RandomSymbol.
688 
689     Examples
690     ========
691 
692     >>> from sympy.stats import Chi, density, E
693     >>> from sympy import Symbol, simplify
694 
695     >>> k = Symbol("k", integer=True)
696     >>> z = Symbol("z")
697 
698     >>> X = Chi("x", k)
699 
700     >>> density(X)(z)
701     2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2)
702 
703     >>> simplify(E(X))
704     sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2)
705 
706     References
707     ==========
708 
709     .. [1] https://en.wikipedia.org/wiki/Chi_distribution
710     .. [2] http://mathworld.wolfram.com/ChiDistribution.html
711 
712     """
713 
714     return rv(name, ChiDistribution, (k,))
715 
716 #-------------------------------------------------------------------------------
717 # Non-central Chi distribution -------------------------------------------------
718 
719 
720 class ChiNoncentralDistribution(SingleContinuousDistribution):
721     _argnames = ('k', 'l')
722 
723     @staticmethod
724     def check(k, l):
725         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
726         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
727         _value_check(l > 0, "Shift parameter Lambda must be positive.")
728 
729     set = Interval(0, oo)
730 
731     def pdf(self, x):
732         k, l = self.k, self.l
733         return exp(-(x**2+l**2)/2)*x**k*l / (l*x)**(k/2) * besseli(k/2-1, l*x)
734 
735 def ChiNoncentral(name, k, l):
736     r"""
737     Create a continuous random variable with a non-central Chi distribution.
738 
739     The density of the non-central Chi distribution is given by
740 
741     .. math::
742         f(x) := \frac{e^{-(x^2+\lambda^2)/2} x^k\lambda}
743                 {(\lambda x)^{k/2}} I_{k/2-1}(\lambda x)
744 
745     with `x \geq 0`. Here, `I_\nu (x)` is the
746     :ref:`modified Bessel function of the first kind <besseli>`.
747 
748     Parameters
749     ==========
750 
751     k : A positive Integer, `k > 0`, the number of degrees of freedom
752     lambda : Real number, `\lambda > 0`, Shift parameter
753 
754     Returns
755     =======
756 
757     A RandomSymbol.
758 
759     Examples
760     ========
761 
762     >>> from sympy.stats import ChiNoncentral, density
763     >>> from sympy import Symbol
764 
765     >>> k = Symbol("k", integer=True)
766     >>> l = Symbol("l")
767     >>> z = Symbol("z")
768 
769     >>> X = ChiNoncentral("x", k, l)
770 
771     >>> density(X)(z)
772     l*z**k*(l*z)**(-k/2)*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)
773 
774     References
775     ==========
776 
777     .. [1] https://en.wikipedia.org/wiki/Noncentral_chi_distribution
778     """
779 
780     return rv(name, ChiNoncentralDistribution, (k, l))
781 
782 #-------------------------------------------------------------------------------
783 # Chi squared distribution -----------------------------------------------------
784 
785 
786 class ChiSquaredDistribution(SingleContinuousDistribution):
787     _argnames = ('k',)
788 
789     @staticmethod
790     def check(k):
791         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
792         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
793 
794     set = Interval(0, oo)
795 
796     def pdf(self, x):
797         k = self.k
798         return 1/(2**(k/2)*gamma(k/2))*x**(k/2 - 1)*exp(-x/2)
799 
800     def _cdf(self, x):
801         k = self.k
802         return Piecewise(
803                 (S.One/gamma(k/2)*lowergamma(k/2, x/2), x >= 0),
804                 (0, True)
805         )
806 
807     def _characteristic_function(self, t):
808         return (1 - 2*I*t)**(-self.k/2)
809 
810     def  _moment_generating_function(self, t):
811         return (1 - 2*t)**(-self.k/2)
812 
813 def ChiSquared(name, k):
814     r"""
815     Create a continuous random variable with a Chi-squared distribution.
816 
817     The density of the Chi-squared distribution is given by
818 
819     .. math::
820         f(x) := \frac{1}{2^{\frac{k}{2}}\Gamma\left(\frac{k}{2}\right)}
821                 x^{\frac{k}{2}-1} e^{-\frac{x}{2}}
822 
823     with :math:`x \geq 0`.
824 
825     Parameters
826     ==========
827 
828     k : Positive integer, The number of degrees of freedom
829 
830     Returns
831     =======
832 
833     A RandomSymbol.
834 
835     Examples
836     ========
837 
838     >>> from sympy.stats import ChiSquared, density, E, variance, moment
839     >>> from sympy import Symbol
840 
841     >>> k = Symbol("k", integer=True, positive=True)
842     >>> z = Symbol("z")
843 
844     >>> X = ChiSquared("x", k)
845 
846     >>> density(X)(z)
847     2**(-k/2)*z**(k/2 - 1)*exp(-z/2)/gamma(k/2)
848 
849     >>> E(X)
850     k
851 
852     >>> variance(X)
853     2*k
854 
855     >>> moment(X, 3)
856     k**3 + 6*k**2 + 8*k
857 
858     References
859     ==========
860 
861     .. [1] https://en.wikipedia.org/wiki/Chi_squared_distribution
862     .. [2] http://mathworld.wolfram.com/Chi-SquaredDistribution.html
863     """
864 
865     return rv(name, ChiSquaredDistribution, (k, ))
866 
867 #-------------------------------------------------------------------------------
868 # Dagum distribution -----------------------------------------------------------
869 
870 
871 class DagumDistribution(SingleContinuousDistribution):
872     _argnames = ('p', 'a', 'b')
873 
874     @staticmethod
875     def check(p, a, b):
876         _value_check(p > 0, "Shape parameter p must be positive.")
877         _value_check(a > 0, "Shape parameter a must be positive.")
878         _value_check(b > 0, "Scale parameter b must be positive.")
879 
880     def pdf(self, x):
881         p, a, b = self.p, self.a, self.b
882         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))
883 
884     def _cdf(self, x):
885         p, a, b = self.p, self.a, self.b
886         return Piecewise(((S.One + (S(x)/b)**-a)**-p, x>=0),
887                     (S.Zero, True))
888 
889 def Dagum(name, p, a, b):
890     r"""
891     Create a continuous random variable with a Dagum distribution.
892 
893     The density of the Dagum distribution is given by
894 
895     .. math::
896         f(x) := \frac{a p}{x} \left( \frac{\left(\tfrac{x}{b}\right)^{a p}}
897                 {\left(\left(\tfrac{x}{b}\right)^a + 1 \right)^{p+1}} \right)
898 
899     with :math:`x > 0`.
900 
901     Parameters
902     ==========
903 
904     p : Real number, `p > 0`, a shape
905     a : Real number, `a > 0`, a shape
906     b : Real number, `b > 0`, a scale
907 
908     Returns
909     =======
910 
911     A RandomSymbol.
912 
913     Examples
914     ========
915 
916     >>> from sympy.stats import Dagum, density, cdf
917     >>> from sympy import Symbol
918 
919     >>> p = Symbol("p", positive=True)
920     >>> a = Symbol("a", positive=True)
921     >>> b = Symbol("b", positive=True)
922     >>> z = Symbol("z")
923 
924     >>> X = Dagum("x", p, a, b)
925 
926     >>> density(X)(z)
927     a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z
928 
929     >>> cdf(X)(z)
930     Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True))
931 
932 
933     References
934     ==========
935 
936     .. [1] https://en.wikipedia.org/wiki/Dagum_distribution
937 
938     """
939 
940     return rv(name, DagumDistribution, (p, a, b))
941 
942 #-------------------------------------------------------------------------------
943 # Erlang distribution ----------------------------------------------------------
944 
945 
946 def Erlang(name, k, l):
947     r"""
948     Create a continuous random variable with an Erlang distribution.
949 
950     The density of the Erlang distribution is given by
951 
952     .. math::
953         f(x) := \frac{\lambda^k x^{k-1} e^{-\lambda x}}{(k-1)!}
954 
955     with :math:`x \in [0,\infty]`.
956 
957     Parameters
958     ==========
959 
960     k : Positive integer
961     l : Real number, `\lambda > 0`, the rate
962 
963     Returns
964     =======
965 
966     A RandomSymbol.
967 
968     Examples
969     ========
970 
971     >>> from sympy.stats import Erlang, density, cdf, E, variance
972     >>> from sympy import Symbol, simplify, pprint
973 
974     >>> k = Symbol("k", integer=True, positive=True)
975     >>> l = Symbol("l", positive=True)
976     >>> z = Symbol("z")
977 
978     >>> X = Erlang("x", k, l)
979 
980     >>> D = density(X)(z)
981     >>> pprint(D, use_unicode=False)
982      k  k - 1  -l*z
983     l *z     *e
984     ---------------
985         Gamma(k)
986 
987     >>> C = cdf(X)(z)
988     >>> pprint(C, use_unicode=False)
989     /lowergamma(k, l*z)
990     |------------------  for z > 0
991     <     Gamma(k)
992     |
993     \        0           otherwise
994 
995 
996     >>> E(X)
997     k/l
998 
999     >>> simplify(variance(X))
1000     k/l**2
1001 
1002     References
1003     ==========
1004 
1005     .. [1] https://en.wikipedia.org/wiki/Erlang_distribution
1006     .. [2] http://mathworld.wolfram.com/ErlangDistribution.html
1007 
1008     """
1009 
1010     return rv(name, GammaDistribution, (k, S.One/l))
1011 
1012 #-------------------------------------------------------------------------------
1013 # Exponential distribution -----------------------------------------------------
1014 
1015 
1016 class ExponentialDistribution(SingleContinuousDistribution):
1017     _argnames = ('rate',)
1018 
1019     set  = Interval(0, oo)
1020 
1021     @staticmethod
1022     def check(rate):
1023         _value_check(rate > 0, "Rate must be positive.")
1024 
1025     def pdf(self, x):
1026         return self.rate * exp(-self.rate*x)
1027 
1028     def sample(self):
1029         return random.expovariate(self.rate)
1030 
1031     def _cdf(self, x):
1032         return Piecewise(
1033                 (S.One - exp(-self.rate*x), x >= 0),
1034                 (0, True),
1035         )
1036 
1037     def _characteristic_function(self, t):
1038         rate = self.rate
1039         return rate / (rate - I*t)
1040 
1041     def _moment_generating_function(self, t):
1042         rate = self.rate
1043         return rate / (rate - t)
1044 
1045     def _quantile(self, p):
1046         return -log(1-p)/self.rate
1047 
1048 def Exponential(name, rate):
1049     r"""
1050     Create a continuous random variable with an Exponential distribution.
1051 
1052     The density of the exponential distribution is given by
1053 
1054     .. math::
1055         f(x) := \lambda \exp(-\lambda x)
1056 
1057     with `x > 0`. Note that the expected value is `1/\lambda`.
1058 
1059     Parameters
1060     ==========
1061 
1062     rate : A positive Real number, `\lambda > 0`, the rate (or inverse scale/inverse mean)
1063 
1064     Returns
1065     =======
1066 
1067     A RandomSymbol.
1068 
1069     Examples
1070     ========
1071 
1072     >>> from sympy.stats import Exponential, density, cdf, E
1073     >>> from sympy.stats import variance, std, skewness, quantile
1074     >>> from sympy import Symbol, symbols
1075 
1076     >>> l = Symbol("lambda", positive=True)
1077     >>> z = Symbol("z")
1078     >>> p = Symbol("p")
1079     >>> X = Exponential("x", l)
1080 
1081     >>> density(X)(z)
1082     lambda*exp(-lambda*z)
1083 
1084     >>> cdf(X)(z)
1085     Piecewise((1 - exp(-lambda*z), z >= 0), (0, True))
1086 
1087     >>> quantile(X)(p)
1088     -log(1 - p)/lambda
1089 
1090     >>> E(X)
1091     1/lambda
1092 
1093     >>> variance(X)
1094     lambda**(-2)
1095 
1096     >>> skewness(X)
1097     2
1098 
1099     >>> X = Exponential('x', 10)
1100 
1101     >>> density(X)(z)
1102     10*exp(-10*z)
1103 
1104     >>> E(X)
1105     1/10
1106 
1107     >>> std(X)
1108     1/10
1109 
1110     References
1111     ==========
1112 
1113     .. [1] https://en.wikipedia.org/wiki/Exponential_distribution
1114     .. [2] http://mathworld.wolfram.com/ExponentialDistribution.html
1115 
1116     """
1117 
1118     return rv(name, ExponentialDistribution, (rate, ))
1119 
1120 #-------------------------------------------------------------------------------
1121 # F distribution ---------------------------------------------------------------
1122 
1123 
1124 class FDistributionDistribution(SingleContinuousDistribution):
1125     _argnames = ('d1', 'd2')
1126 
1127     set = Interval(0, oo)
1128 
1129     @staticmethod
1130     def check(d1, d2):
1131         _value_check((d1 > 0, d1.is_integer),
1132             "Degrees of freedom d1 must be positive integer.")
1133         _value_check((d2 > 0, d2.is_integer),
1134             "Degrees of freedom d2 must be positive integer.")
1135 
1136     def pdf(self, x):
1137         d1, d2 = self.d1, self.d2
1138         return (sqrt((d1*x)**d1*d2**d2 / (d1*x+d2)**(d1+d2))
1139                / (x * beta_fn(d1/2, d2/2)))
1140 
1141     def _moment_generating_function(self, t):
1142         raise NotImplementedError('The moment generating function for the '
1143                                   'F-distribution does not exist.')
1144 
1145 def FDistribution(name, d1, d2):
1146     r"""
1147     Create a continuous random variable with a F distribution.
1148 
1149     The density of the F distribution is given by
1150 
1151     .. math::
1152         f(x) := \frac{\sqrt{\frac{(d_1 x)^{d_1} d_2^{d_2}}
1153                 {(d_1 x + d_2)^{d_1 + d_2}}}}
1154                 {x \mathrm{B} \left(\frac{d_1}{2}, \frac{d_2}{2}\right)}
1155 
1156     with :math:`x > 0`.
1157 
1158     Parameters
1159     ==========
1160 
1161     d1 : `d_1 > 0`, where d_1 is the degrees of freedom (n_1 - 1)
1162     d2 : `d_2 > 0`, where d_2 is the degrees of freedom (n_2 - 1)
1163 
1164     Returns
1165     =======
1166 
1167     A RandomSymbol.
1168 
1169     Examples
1170     ========
1171 
1172     >>> from sympy.stats import FDistribution, density
1173     >>> from sympy import Symbol, simplify, pprint
1174 
1175     >>> d1 = Symbol("d1", positive=True)
1176     >>> d2 = Symbol("d2", positive=True)
1177     >>> z = Symbol("z")
1178 
1179     >>> X = FDistribution("x", d1, d2)
1180 
1181     >>> D = density(X)(z)
1182     >>> pprint(D, use_unicode=False)
1183       d2
1184       --    ______________________________
1185       2    /       d1            -d1 - d2
1186     d2  *\/  (d1*z)  *(d1*z + d2)
1187     --------------------------------------
1188                     /d1  d2\
1189                  z*B|--, --|
1190                     \2   2 /
1191 
1192     References
1193     ==========
1194 
1195     .. [1] https://en.wikipedia.org/wiki/F-distribution
1196     .. [2] http://mathworld.wolfram.com/F-Distribution.html
1197 
1198     """
1199 
1200     return rv(name, FDistributionDistribution, (d1, d2))
1201 
1202 #-------------------------------------------------------------------------------
1203 # Fisher Z distribution --------------------------------------------------------
1204 
1205 class FisherZDistribution(SingleContinuousDistribution):
1206     _argnames = ('d1', 'd2')
1207 
1208     def pdf(self, x):
1209         d1, d2 = self.d1, self.d2
1210         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *
1211                exp(d1*x) / (d1*exp(2*x)+d2)**((d1+d2)/2))
1212 
1213 def FisherZ(name, d1, d2):
1214     r"""
1215     Create a Continuous Random Variable with an Fisher's Z distribution.
1216 
1217     The density of the Fisher's Z distribution is given by
1218 
1219     .. math::
1220         f(x) := \frac{2d_1^{d_1/2} d_2^{d_2/2}} {\mathrm{B}(d_1/2, d_2/2)}
1221                 \frac{e^{d_1z}}{\left(d_1e^{2z}+d_2\right)^{\left(d_1+d_2\right)/2}}
1222 
1223 
1224     .. TODO - What is the difference between these degrees of freedom?
1225 
1226     Parameters
1227     ==========
1228 
1229     d1 : `d_1 > 0`, degree of freedom
1230     d2 : `d_2 > 0`, degree of freedom
1231 
1232     Returns
1233     =======
1234 
1235     A RandomSymbol.
1236 
1237     Examples
1238     ========
1239 
1240     >>> from sympy.stats import FisherZ, density
1241     >>> from sympy import Symbol, simplify, pprint
1242 
1243     >>> d1 = Symbol("d1", positive=True)
1244     >>> d2 = Symbol("d2", positive=True)
1245     >>> z = Symbol("z")
1246 
1247     >>> X = FisherZ("x", d1, d2)
1248 
1249     >>> D = density(X)(z)
1250     >>> pprint(D, use_unicode=False)
1251                                 d1   d2
1252         d1   d2               - -- - --
1253         --   --                 2    2
1254         2    2  /    2*z     \           d1*z
1255     2*d1  *d2  *\d1*e    + d2/         *e
1256     -----------------------------------------
1257                      /d1  d2\
1258                     B|--, --|
1259                      \2   2 /
1260 
1261     References
1262     ==========
1263 
1264     .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution
1265     .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html
1266 
1267     """
1268 
1269     return rv(name, FisherZDistribution, (d1, d2))
1270 
1271 #-------------------------------------------------------------------------------
1272 # Frechet distribution ---------------------------------------------------------
1273 
1274 class FrechetDistribution(SingleContinuousDistribution):
1275     _argnames = ('a', 's', 'm')
1276 
1277     set = Interval(0, oo)
1278 
1279     def __new__(cls, a, s=1, m=0):
1280         a, s, m = list(map(sympify, (a, s, m)))
1281         return Basic.__new__(cls, a, s, m)
1282 
1283     def pdf(self, x):
1284         a, s, m = self.a, self.s, self.m
1285         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))
1286 
1287     def _cdf(self, x):
1288         a, s, m = self.a, self.s, self.m
1289         return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),
1290                         (S.Zero, True))
1291 
1292 def Frechet(name, a, s=1, m=0):
1293     r"""
1294     Create a continuous random variable with a Frechet distribution.
1295 
1296     The density of the Frechet distribution is given by
1297 
1298     .. math::
1299         f(x) := \frac{\alpha}{s} \left(\frac{x-m}{s}\right)^{-1-\alpha}
1300                  e^{-(\frac{x-m}{s})^{-\alpha}}
1301 
1302     with :math:`x \geq m`.
1303 
1304     Parameters
1305     ==========
1306 
1307     a : Real number, :math:`a \in \left(0, \infty\right)` the shape
1308     s : Real number, :math:`s \in \left(0, \infty\right)` the scale
1309     m : Real number, :math:`m \in \left(-\infty, \infty\right)` the minimum
1310 
1311     Returns
1312     =======
1313 
1314     A RandomSymbol.
1315 
1316     Examples
1317     ========
1318 
1319     >>> from sympy.stats import Frechet, density, E, std, cdf
1320     >>> from sympy import Symbol, simplify
1321 
1322     >>> a = Symbol("a", positive=True)
1323     >>> s = Symbol("s", positive=True)
1324     >>> m = Symbol("m", real=True)
1325     >>> z = Symbol("z")
1326 
1327     >>> X = Frechet("x", a, s, m)
1328 
1329     >>> density(X)(z)
1330     a*((-m + z)/s)**(-a - 1)*exp(-((-m + z)/s)**(-a))/s
1331 
1332     >>> cdf(X)(z)
1333      Piecewise((exp(-((-m + z)/s)**(-a)), m <= z), (0, True))
1334 
1335     References
1336     ==========
1337 
1338     .. [1] https://en.wikipedia.org/wiki/Fr%C3%A9chet_distribution
1339 
1340     """
1341 
1342     return rv(name, FrechetDistribution, (a, s, m))
1343 
1344 #-------------------------------------------------------------------------------
1345 # Gamma distribution -----------------------------------------------------------
1346 
1347 
1348 class GammaDistribution(SingleContinuousDistribution):
1349     _argnames = ('k', 'theta')
1350 
1351     set = Interval(0, oo)
1352 
1353     @staticmethod
1354     def check(k, theta):
1355         _value_check(k > 0, "k must be positive")
1356         _value_check(theta > 0, "Theta must be positive")
1357 
1358     def pdf(self, x):
1359         k, theta = self.k, self.theta
1360         return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)
1361 
1362     def sample(self):
1363         return random.gammavariate(self.k, self.theta)
1364 
1365     def _cdf(self, x):
1366         k, theta = self.k, self.theta
1367         return Piecewise(
1368                     (lowergamma(k, S(x)/theta)/gamma(k), x > 0),
1369                     (S.Zero, True))
1370 
1371     def _characteristic_function(self, t):
1372         return (1 - self.theta*I*t)**(-self.k)
1373 
1374     def _moment_generating_function(self, t):
1375         return (1- self.theta*t)**(-self.k)
1376 
1377 def Gamma(name, k, theta):
1378     r"""
1379     Create a continuous random variable with a Gamma distribution.
1380 
1381     The density of the Gamma distribution is given by
1382 
1383     .. math::
1384         f(x) := \frac{1}{\Gamma(k) \theta^k} x^{k - 1} e^{-\frac{x}{\theta}}
1385 
1386     with :math:`x \in [0,1]`.
1387 
1388     Parameters
1389     ==========
1390 
1391     k : Real number, `k > 0`, a shape
1392     theta : Real number, `\theta > 0`, a scale
1393 
1394     Returns
1395     =======
1396 
1397     A RandomSymbol.
1398 
1399     Examples
1400     ========
1401 
1402     >>> from sympy.stats import Gamma, density, cdf, E, variance
1403     >>> from sympy import Symbol, pprint, simplify
1404 
1405     >>> k = Symbol("k", positive=True)
1406     >>> theta = Symbol("theta", positive=True)
1407     >>> z = Symbol("z")
1408 
1409     >>> X = Gamma("x", k, theta)
1410 
1411     >>> D = density(X)(z)
1412     >>> pprint(D, use_unicode=False)
1413                       -z
1414                     -----
1415          -k  k - 1  theta
1416     theta  *z     *e
1417     ---------------------
1418            Gamma(k)
1419 
1420     >>> C = cdf(X, meijerg=True)(z)
1421     >>> pprint(C, use_unicode=False)
1422     /            /     z  \
1423     |k*lowergamma|k, -----|
1424     |            \   theta/
1425     <----------------------  for z >= 0
1426     |     Gamma(k + 1)
1427     |
1428     \          0             otherwise
1429 
1430     >>> E(X)
1431     k*theta
1432 
1433     >>> V = simplify(variance(X))
1434     >>> pprint(V, use_unicode=False)
1435            2
1436     k*theta
1437 
1438 
1439     References
1440     ==========
1441 
1442     .. [1] https://en.wikipedia.org/wiki/Gamma_distribution
1443     .. [2] http://mathworld.wolfram.com/GammaDistribution.html
1444 
1445     """
1446 
1447     return rv(name, GammaDistribution, (k, theta))
1448 
1449 #-------------------------------------------------------------------------------
1450 # Inverse Gamma distribution ---------------------------------------------------
1451 
1452 
1453 class GammaInverseDistribution(SingleContinuousDistribution):
1454     _argnames = ('a', 'b')
1455 
1456     set = Interval(0, oo)
1457 
1458     @staticmethod
1459     def check(a, b):
1460         _value_check(a > 0, "alpha must be positive")
1461         _value_check(b > 0, "beta must be positive")
1462 
1463     def pdf(self, x):
1464         a, b = self.a, self.b
1465         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)
1466 
1467     def _cdf(self, x):
1468         a, b = self.a, self.b
1469         return Piecewise((uppergamma(a,b/x)/gamma(a), x > 0),
1470                         (S.Zero, True))
1471 
1472     def sample(self):
1473         scipy = import_module('scipy')
1474         if scipy:
1475             from scipy.stats import invgamma
1476             return invgamma.rvs(float(self.a), 0, float(self.b))
1477         else:
1478             raise NotImplementedError('Sampling the inverse Gamma Distribution requires Scipy.')
1479 
1480     def _characteristic_function(self, t):
1481         a, b = self.a, self.b
1482         return 2 * (-I*b*t)**(a/2) * besselk(sqrt(-4*I*b*t)) / gamma(a)
1483 
1484     def _moment_generating_function(self, t):
1485         raise NotImplementedError('The moment generating function for the '
1486                                   'gamma inverse distribution does not exist.')
1487 
1488 def GammaInverse(name, a, b):
1489     r"""
1490     Create a continuous random variable with an inverse Gamma distribution.
1491 
1492     The density of the inverse Gamma distribution is given by
1493 
1494     .. math::
1495         f(x) := \frac{\beta^\alpha}{\Gamma(\alpha)} x^{-\alpha - 1}
1496                 \exp\left(\frac{-\beta}{x}\right)
1497 
1498     with :math:`x > 0`.
1499 
1500     Parameters
1501     ==========
1502 
1503     a : Real number, `a > 0` a shape
1504     b : Real number, `b > 0` a scale
1505 
1506     Returns
1507     =======
1508 
1509     A RandomSymbol.
1510 
1511     Examples
1512     ========
1513 
1514     >>> from sympy.stats import GammaInverse, density, cdf, E, variance
1515     >>> from sympy import Symbol, pprint
1516 
1517     >>> a = Symbol("a", positive=True)
1518     >>> b = Symbol("b", positive=True)
1519     >>> z = Symbol("z")
1520 
1521     >>> X = GammaInverse("x", a, b)
1522 
1523     >>> D = density(X)(z)
1524     >>> pprint(D, use_unicode=False)
1525                 -b
1526                 ---
1527      a  -a - 1   z
1528     b *z      *e
1529     ---------------
1530        Gamma(a)
1531 
1532     >>> cdf(X)(z)
1533     Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))
1534 
1535 
1536     References
1537     ==========
1538 
1539     .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution
1540 
1541     """
1542 
1543     return rv(name, GammaInverseDistribution, (a, b))
1544 
1545 #-------------------------------------------------------------------------------
1546 # Gumbel distribution --------------------------------------------------------
1547 
1548 
1549 class GumbelDistribution(SingleContinuousDistribution):
1550     _argnames = ('beta', 'mu')
1551 
1552     set = Interval(-oo, oo)
1553 
1554     def pdf(self, x):
1555         beta, mu = self.beta, self.mu
1556         z = (x - mu)/beta
1557         return (1/beta)*exp(-(z + exp(-z)))
1558 
1559     def _cdf(self, x):
1560         beta, mu = self.beta, self.mu
1561         return exp(-exp((mu - x)/beta))
1562 
1563     def _characteristic_function(self, t):
1564         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)
1565 
1566     def _moment_generating_function(self, t):
1567         return gamma(1 - self.beta*t) * exp(I*self.mu*t)
1568 
1569 def Gumbel(name, beta, mu):
1570     r"""
1571     Create a Continuous Random Variable with Gumbel distribution.
1572 
1573     The density of the Gumbel distribution is given by
1574 
1575     .. math::
1576         f(x) := \dfrac{1}{\beta} \exp \left( -\dfrac{x-\mu}{\beta}
1577                 - \exp \left( -\dfrac{x - \mu}{\beta} \right) \right)
1578 
1579     with :math:`x \in [ - \infty, \infty ]`.
1580 
1581     Parameters
1582     ==========
1583 
1584     mu: Real number, 'mu' is a location
1585     beta: Real number, 'beta > 0' is a scale
1586 
1587     Returns
1588     ==========
1589 
1590     A RandomSymbol
1591 
1592     Examples
1593     ==========
1594     >>> from sympy.stats import Gumbel, density, E, variance, cdf
1595     >>> from sympy import Symbol, simplify, pprint
1596     >>> x = Symbol("x")
1597     >>> mu = Symbol("mu")
1598     >>> beta = Symbol("beta", positive=True)
1599     >>> X = Gumbel("x", beta, mu)
1600     >>> density(X)(x)
1601     exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta
1602     >>> cdf(X)(x)
1603     exp(-exp((mu - x)/beta))
1604 
1605     References
1606     ==========
1607 
1608     .. [1] http://mathworld.wolfram.com/GumbelDistribution.html
1609     .. [2] https://en.wikipedia.org/wiki/Gumbel_distribution
1610 
1611     """
1612     return rv(name, GumbelDistribution, (beta, mu))
1613 
1614 #-------------------------------------------------------------------------------
1615 # Gompertz distribution --------------------------------------------------------
1616 
1617 class GompertzDistribution(SingleContinuousDistribution):
1618     _argnames = ('b', 'eta')
1619 
1620     set = Interval(0, oo)
1621 
1622     @staticmethod
1623     def check(b, eta):
1624         _value_check(b > 0, "b must be positive")
1625         _value_check(eta > 0, "eta must be positive")
1626 
1627     def pdf(self, x):
1628         eta, b = self.eta, self.b
1629         return b*eta*exp(b*x)*exp(eta)*exp(-eta*exp(b*x))
1630 
1631     def _cdf(self, x):
1632         eta, b = self.eta, self.b
1633         return 1 - exp(eta)*exp(-eta*exp(b*x))
1634 
1635     def _moment_generating_function(self, t):
1636         eta, b = self.eta, self.b
1637         return eta * exp(eta) * expint(t/b, eta)
1638 
1639 def Gompertz(name, b, eta):
1640     r"""
1641     Create a Continuous Random Variable with Gompertz distribution.
1642 
1643     The density of the Gompertz distribution is given by
1644 
1645     .. math::
1646         f(x) := b \eta e^{b x} e^{\eta} \exp \left(-\eta e^{bx} \right)
1647 
1648     with :math: 'x \in [0, \inf)'.
1649 
1650     Parameters
1651     ==========
1652 
1653     b: Real number, 'b > 0' a scale
1654     eta: Real number, 'eta > 0' a shape
1655 
1656     Returns
1657     =======
1658 
1659     A RandomSymbol.
1660 
1661     Examples
1662     ========
1663 
1664     >>> from sympy.stats import Gompertz, density, E, variance
1665     >>> from sympy import Symbol, simplify, pprint
1666 
1667     >>> b = Symbol("b", positive=True)
1668     >>> eta = Symbol("eta", positive=True)
1669     >>> z = Symbol("z")
1670 
1671     >>> X = Gompertz("x", b, eta)
1672 
1673     >>> density(X)(z)
1674     b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z))
1675 
1676     References
1677     ==========
1678 
1679     .. [1] https://en.wikipedia.org/wiki/Gompertz_distribution
1680 
1681     """
1682     return rv(name, GompertzDistribution, (b, eta))
1683 
1684 #-------------------------------------------------------------------------------
1685 # Kumaraswamy distribution -----------------------------------------------------
1686 
1687 
1688 class KumaraswamyDistribution(SingleContinuousDistribution):
1689     _argnames = ('a', 'b')
1690 
1691     set = Interval(0, oo)
1692 
1693     @staticmethod
1694     def check(a, b):
1695         _value_check(a > 0, "a must be positive")
1696         _value_check(b > 0, "b must be positive")
1697 
1698     def pdf(self, x):
1699         a, b = self.a, self.b
1700         return a * b * x**(a-1) * (1-x**a)**(b-1)
1701 
1702     def _cdf(self, x):
1703         a, b = self.a, self.b
1704         return Piecewise(
1705             (S.Zero, x < S.Zero),
1706             (1 - (1 - x**a)**b, x <= S.One),
1707             (S.One, True))
1708 
1709 def Kumaraswamy(name, a, b):
1710     r"""
1711     Create a Continuous Random Variable with a Kumaraswamy distribution.
1712 
1713     The density of the Kumaraswamy distribution is given by
1714 
1715     .. math::
1716         f(x) := a b x^{a-1} (1-x^a)^{b-1}
1717 
1718     with :math:`x \in [0,1]`.
1719 
1720     Parameters
1721     ==========
1722 
1723     a : Real number, `a > 0` a shape
1724     b : Real number, `b > 0` a shape
1725 
1726     Returns
1727     =======
1728 
1729     A RandomSymbol.
1730 
1731     Examples
1732     ========
1733 
1734     >>> from sympy.stats import Kumaraswamy, density, E, variance, cdf
1735     >>> from sympy import Symbol, simplify, pprint
1736 
1737     >>> a = Symbol("a", positive=True)
1738     >>> b = Symbol("b", positive=True)
1739     >>> z = Symbol("z")
1740 
1741     >>> X = Kumaraswamy("x", a, b)
1742 
1743     >>> D = density(X)(z)
1744     >>> pprint(D, use_unicode=False)
1745                        b - 1
1746          a - 1 /     a\
1747     a*b*z     *\1 - z /
1748 
1749     >>> cdf(X)(z)
1750     Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True))
1751 
1752     References
1753     ==========
1754 
1755     .. [1] https://en.wikipedia.org/wiki/Kumaraswamy_distribution
1756 
1757     """
1758 
1759     return rv(name, KumaraswamyDistribution, (a, b))
1760 
1761 #-------------------------------------------------------------------------------
1762 # Laplace distribution ---------------------------------------------------------
1763 
1764 
1765 class LaplaceDistribution(SingleContinuousDistribution):
1766     _argnames = ('mu', 'b')
1767 
1768     def pdf(self, x):
1769         mu, b = self.mu, self.b
1770         return 1/(2*b)*exp(-Abs(x - mu)/b)
1771 
1772     def _cdf(self, x):
1773         mu, b = self.mu, self.b
1774         return Piecewise(
1775                     (S.Half*exp((x - mu)/b), x < mu),
1776                     (S.One - S.Half*exp(-(x - mu)/b), x >= mu)
1777                         )
1778 
1779     def _characteristic_function(self, t):
1780         return exp(self.mu*I*t) / (1 + self.b**2*t**2)
1781 
1782     def _moment_generating_function(self, t):
1783         return exp(self.mu*t) / (1 - self.b**2*t**2)
1784 
1785 def Laplace(name, mu, b):
1786     r"""
1787     Create a continuous random variable with a Laplace distribution.
1788 
1789     The density of the Laplace distribution is given by
1790 
1791     .. math::
1792         f(x) := \frac{1}{2 b} \exp \left(-\frac{|x-\mu|}b \right)
1793 
1794     Parameters
1795     ==========
1796 
1797     mu : Real number or a list/matrix, the location (mean) or the
1798         location vector
1799     b : Real number or a positive definite matrix, representing a scale
1800         or the covariance matrix.
1801 
1802     Returns
1803     =======
1804 
1805     A RandomSymbol.
1806 
1807     Examples
1808     ========
1809 
1810     >>> from sympy.stats import Laplace, density, cdf
1811     >>> from sympy import Symbol, pprint
1812 
1813     >>> mu = Symbol("mu")
1814     >>> b = Symbol("b", positive=True)
1815     >>> z = Symbol("z")
1816 
1817     >>> X = Laplace("x", mu, b)
1818 
1819     >>> density(X)(z)
1820     exp(-Abs(mu - z)/b)/(2*b)
1821 
1822     >>> cdf(X)(z)
1823     Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True))
1824 
1825     >>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])
1826     >>> pprint(density(L)(1, 2), use_unicode=False)
1827      5        /     ____\
1828     e *besselk\0, \/ 35 /
1829     ---------------------
1830               pi
1831 
1832     References
1833     ==========
1834 
1835     .. [1] https://en.wikipedia.org/wiki/Laplace_distribution
1836     .. [2] http://mathworld.wolfram.com/LaplaceDistribution.html
1837 
1838     """
1839 
1840     if isinstance(mu, (list, MatrixBase)) and\
1841         isinstance(b, (list, MatrixBase)):
1842         from sympy.stats.joint_rv_types import MultivariateLaplaceDistribution
1843         return multivariate_rv(
1844             MultivariateLaplaceDistribution, name, mu, b)
1845 
1846     return rv(name, LaplaceDistribution, (mu, b))
1847 
1848 #-------------------------------------------------------------------------------
1849 # Logistic distribution --------------------------------------------------------
1850 
1851 
1852 class LogisticDistribution(SingleContinuousDistribution):
1853     _argnames = ('mu', 's')
1854 
1855     def pdf(self, x):
1856         mu, s = self.mu, self.s
1857         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)
1858 
1859     def _cdf(self, x):
1860         mu, s = self.mu, self.s
1861         return S.One/(1 + exp(-(x - mu)/s))
1862 
1863     def _characteristic_function(self, t):
1864         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))
1865 
1866     def _moment_generating_function(self, t):
1867         return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)
1868 
1869     def _quantile(self, p):
1870         return self.mu - self.s*log(-S.One + S.One/p)
1871 
1872 def Logistic(name, mu, s):
1873     r"""
1874     Create a continuous random variable with a logistic distribution.
1875 
1876     The density of the logistic distribution is given by
1877 
1878     .. math::
1879         f(x) := \frac{e^{-(x-\mu)/s}} {s\left(1+e^{-(x-\mu)/s}\right)^2}
1880 
1881     Parameters
1882     ==========
1883 
1884     mu : Real number, the location (mean)
1885     s : Real number, `s > 0` a scale
1886 
1887     Returns
1888     =======
1889 
1890     A RandomSymbol.
1891 
1892     Examples
1893     ========
1894 
1895     >>> from sympy.stats import Logistic, density, cdf
1896     >>> from sympy import Symbol
1897 
1898     >>> mu = Symbol("mu", real=True)
1899     >>> s = Symbol("s", positive=True)
1900     >>> z = Symbol("z")
1901 
1902     >>> X = Logistic("x", mu, s)
1903 
1904     >>> density(X)(z)
1905     exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2)
1906 
1907     >>> cdf(X)(z)
1908     1/(exp((mu - z)/s) + 1)
1909 
1910     References
1911     ==========
1912 
1913     .. [1] https://en.wikipedia.org/wiki/Logistic_distribution
1914     .. [2] http://mathworld.wolfram.com/LogisticDistribution.html
1915 
1916     """
1917 
1918     return rv(name, LogisticDistribution, (mu, s))
1919 
1920 #-------------------------------------------------------------------------------
1921 # Log Normal distribution ------------------------------------------------------
1922 
1923 
1924 class LogNormalDistribution(SingleContinuousDistribution):
1925     _argnames = ('mean', 'std')
1926 
1927     set = Interval(0, oo)
1928 
1929     def pdf(self, x):
1930         mean, std = self.mean, self.std
1931         return exp(-(log(x) - mean)**2 / (2*std**2)) / (x*sqrt(2*pi)*std)
1932 
1933     def sample(self):
1934         return random.lognormvariate(self.mean, self.std)
1935 
1936     def _cdf(self, x):
1937         mean, std = self.mean, self.std
1938         return Piecewise(
1939                 (S.Half + S.Half*erf((log(x) - mean)/sqrt(2)/std), x > 0),
1940                 (S.Zero, True)
1941         )
1942 
1943     def _moment_generating_function(self, t):
1944         raise NotImplementedError('Moment generating function of the log-normal distribution is not defined.')
1945 
1946 def LogNormal(name, mean, std):
1947     r"""
1948     Create a continuous random variable with a log-normal distribution.
1949 
1950     The density of the log-normal distribution is given by
1951 
1952     .. math::
1953         f(x) := \frac{1}{x\sqrt{2\pi\sigma^2}}
1954                 e^{-\frac{\left(\ln x-\mu\right)^2}{2\sigma^2}}
1955 
1956     with :math:`x \geq 0`.
1957 
1958     Parameters
1959     ==========
1960 
1961     mu : Real number, the log-scale
1962     sigma : Real number, :math:`\sigma^2 > 0` a shape
1963 
1964     Returns
1965     =======
1966 
1967     A RandomSymbol.
1968 
1969     Examples
1970     ========
1971 
1972     >>> from sympy.stats import LogNormal, density
1973     >>> from sympy import Symbol, simplify, pprint
1974 
1975     >>> mu = Symbol("mu", real=True)
1976     >>> sigma = Symbol("sigma", positive=True)
1977     >>> z = Symbol("z")
1978 
1979     >>> X = LogNormal("x", mu, sigma)
1980 
1981     >>> D = density(X)(z)
1982     >>> pprint(D, use_unicode=False)
1983                           2
1984            -(-mu + log(z))
1985            -----------------
1986                       2
1987       ___      2*sigma
1988     \/ 2 *e
1989     ------------------------
1990             ____
1991         2*\/ pi *sigma*z
1992 
1993 
1994     >>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1
1995 
1996     >>> density(X)(z)
1997     sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z)
1998 
1999     References
2000     ==========
2001 
2002     .. [1] https://en.wikipedia.org/wiki/Lognormal
2003     .. [2] http://mathworld.wolfram.com/LogNormalDistribution.html
2004 
2005     """
2006 
2007     return rv(name, LogNormalDistribution, (mean, std))
2008 
2009 #-------------------------------------------------------------------------------
2010 # Maxwell distribution ---------------------------------------------------------
2011 
2012 
2013 class MaxwellDistribution(SingleContinuousDistribution):
2014     _argnames = ('a',)
2015 
2016     set = Interval(0, oo)
2017 
2018     def pdf(self, x):
2019         a = self.a
2020         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3
2021 
2022     def _cdf(self, x):
2023         a = self.a
2024         return erf(sqrt(2)*x/(2*a)) - sqrt(2)*x*exp(-x**2/(2*a**2))/(sqrt(pi)*a)
2025 
2026 def Maxwell(name, a):
2027     r"""
2028     Create a continuous random variable with a Maxwell distribution.
2029 
2030     The density of the Maxwell distribution is given by
2031 
2032     .. math::
2033         f(x) := \sqrt{\frac{2}{\pi}} \frac{x^2 e^{-x^2/(2a^2)}}{a^3}
2034 
2035     with :math:`x \geq 0`.
2036 
2037     .. TODO - what does the parameter mean?
2038 
2039     Parameters
2040     ==========
2041 
2042     a : Real number, `a > 0`
2043 
2044     Returns
2045     =======
2046 
2047     A RandomSymbol.
2048 
2049     Examples
2050     ========
2051 
2052     >>> from sympy.stats import Maxwell, density, E, variance
2053     >>> from sympy import Symbol, simplify
2054 
2055     >>> a = Symbol("a", positive=True)
2056     >>> z = Symbol("z")
2057 
2058     >>> X = Maxwell("x", a)
2059 
2060     >>> density(X)(z)
2061     sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)
2062 
2063     >>> E(X)
2064     2*sqrt(2)*a/sqrt(pi)
2065 
2066     >>> simplify(variance(X))
2067     a**2*(-8 + 3*pi)/pi
2068 
2069     References
2070     ==========
2071 
2072     .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution
2073     .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html
2074 
2075     """
2076 
2077     return rv(name, MaxwellDistribution, (a, ))
2078 
2079 #-------------------------------------------------------------------------------
2080 # Nakagami distribution --------------------------------------------------------
2081 
2082 
2083 class NakagamiDistribution(SingleContinuousDistribution):
2084     _argnames = ('mu', 'omega')
2085 
2086     set = Interval(0, oo)
2087 
2088     def pdf(self, x):
2089         mu, omega = self.mu, self.omega
2090         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)
2091 
2092     def _cdf(self, x):
2093         mu, omega = self.mu, self.omega
2094         return Piecewise(
2095                     (lowergamma(mu, (mu/omega)*x**2)/gamma(mu), x > 0),
2096                     (S.Zero, True))
2097 
2098 def Nakagami(name, mu, omega):
2099     r"""
2100     Create a continuous random variable with a Nakagami distribution.
2101 
2102     The density of the Nakagami distribution is given by
2103 
2104     .. math::
2105         f(x) := \frac{2\mu^\mu}{\Gamma(\mu)\omega^\mu} x^{2\mu-1}
2106                 \exp\left(-\frac{\mu}{\omega}x^2 \right)
2107 
2108     with :math:`x > 0`.
2109 
2110     Parameters
2111     ==========
2112 
2113     mu : Real number, `\mu \geq \frac{1}{2}` a shape
2114     omega : Real number, `\omega > 0`, the spread
2115 
2116     Returns
2117     =======
2118 
2119     A RandomSymbol.
2120 
2121     Examples
2122     ========
2123 
2124     >>> from sympy.stats import Nakagami, density, E, variance, cdf
2125     >>> from sympy import Symbol, simplify, pprint
2126 
2127     >>> mu = Symbol("mu", positive=True)
2128     >>> omega = Symbol("omega", positive=True)
2129     >>> z = Symbol("z")
2130 
2131     >>> X = Nakagami("x", mu, omega)
2132 
2133     >>> D = density(X)(z)
2134     >>> pprint(D, use_unicode=False)
2135                                     2
2136                                -mu*z
2137                                -------
2138         mu      -mu  2*mu - 1  omega
2139     2*mu  *omega   *z        *e
2140     ----------------------------------
2141                 Gamma(mu)
2142 
2143     >>> simplify(E(X))
2144     sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1)
2145 
2146     >>> V = simplify(variance(X))
2147     >>> pprint(V, use_unicode=False)
2148                         2
2149              omega*Gamma (mu + 1/2)
2150     omega - -----------------------
2151             Gamma(mu)*Gamma(mu + 1)
2152 
2153     >>> cdf(X)(z)
2154     Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),
2155             (0, True))
2156 
2157 
2158     References
2159     ==========
2160 
2161     .. [1] https://en.wikipedia.org/wiki/Nakagami_distribution
2162 
2163     """
2164 
2165     return rv(name, NakagamiDistribution, (mu, omega))
2166 
2167 #-------------------------------------------------------------------------------
2168 # Normal distribution ----------------------------------------------------------
2169 
2170 
2171 class NormalDistribution(SingleContinuousDistribution):
2172     _argnames = ('mean', 'std')
2173 
2174     @staticmethod
2175     def check(mean, std):
2176         _value_check(std > 0, "Standard deviation must be positive")
2177 
2178     def pdf(self, x):
2179         return exp(-(x - self.mean)**2 / (2*self.std**2)) / (sqrt(2*pi)*self.std)
2180 
2181     def sample(self):
2182         return random.normalvariate(self.mean, self.std)
2183 
2184     def _cdf(self, x):
2185         mean, std = self.mean, self.std
2186         return erf(sqrt(2)*(-mean + x)/(2*std))/2 + S.Half
2187 
2188     def _characteristic_function(self, t):
2189         mean, std = self.mean, self.std
2190         return exp(I*mean*t - std**2*t**2/2)
2191 
2192     def _moment_generating_function(self, t):
2193         mean, std = self.mean, self.std
2194         return exp(mean*t + std**2*t**2/2)
2195 
2196     def _quantile(self, p):
2197         mean, std = self.mean, self.std
2198         return mean + std*sqrt(2)*erfinv(2*p - 1)
2199 
2200 def Normal(name, mean, std):
2201     r"""
2202     Create a continuous random variable with a Normal distribution.
2203 
2204     The density of the Normal distribution is given by
2205 
2206     .. math::
2207         f(x) := \frac{1}{\sigma\sqrt{2\pi}} e^{ -\frac{(x-\mu)^2}{2\sigma^2} }
2208 
2209     Parameters
2210     ==========
2211 
2212     mu : Real number or a list representing the mean or the mean vector
2213     sigma : Real number or a positive definite sqaure matrix,
2214          :math:`\sigma^2 > 0` the variance
2215 
2216     Returns
2217     =======
2218 
2219     A RandomSymbol.
2220 
2221     Examples
2222     ========
2223 
2224     >>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile
2225     >>> from sympy import Symbol, simplify, pprint, factor, together, factor_terms
2226 
2227     >>> mu = Symbol("mu")
2228     >>> sigma = Symbol("sigma", positive=True)
2229     >>> z = Symbol("z")
2230     >>> y = Symbol("y")
2231     >>> p = Symbol("p")
2232     >>> X = Normal("x", mu, sigma)
2233 
2234     >>> density(X)(z)
2235     sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma)
2236 
2237     >>> C = simplify(cdf(X))(z) # it needs a little more help...
2238     >>> pprint(C, use_unicode=False)
2239        /  ___          \
2240        |\/ 2 *(-mu + z)|
2241     erf|---------------|
2242        \    2*sigma    /   1
2243     -------------------- + -
2244              2             2
2245 
2246     >>> quantile(X)(p)
2247     mu + sqrt(2)*sigma*erfinv(2*p - 1)
2248 
2249     >>> simplify(skewness(X))
2250     0
2251 
2252     >>> X = Normal("x", 0, 1) # Mean 0, standard deviation 1
2253     >>> density(X)(z)
2254     sqrt(2)*exp(-z**2/2)/(2*sqrt(pi))
2255 
2256     >>> E(2*X + 1)
2257     1
2258 
2259     >>> simplify(std(2*X + 1))
2260     2
2261 
2262     >>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])
2263     >>> from sympy.stats.joint_rv import marginal_distribution
2264     >>> pprint(density(m)(y, z))
2265            /1   y\ /2*y   z\   /    z\ /  y   2*z    \
2266            |- - -|*|--- - -| + |1 - -|*|- - + --- - 1|
2267       ___  \2   2/ \ 3    3/   \    2/ \  3    3     /
2268     \/ 3 *e
2269     --------------------------------------------------
2270                            6*pi
2271 
2272     >>> marginal_distribution(m, m[0])(1)
2273      1/(2*sqrt(pi))
2274 
2275 
2276     References
2277     ==========
2278 
2279     .. [1] https://en.wikipedia.org/wiki/Normal_distribution
2280     .. [2] http://mathworld.wolfram.com/NormalDistributionFunction.html
2281 
2282     """
2283 
2284     if isinstance(mean, (list, MatrixBase)) and\
2285         isinstance(std, (list, MatrixBase)):
2286         from sympy.stats.joint_rv_types import MultivariateNormalDistribution
2287         return multivariate_rv(
2288             MultivariateNormalDistribution, name, mean, std)
2289     return rv(name, NormalDistribution, (mean, std))
2290 
2291 #-------------------------------------------------------------------------------
2292 # Pareto distribution ----------------------------------------------------------
2293 
2294 
2295 class ParetoDistribution(SingleContinuousDistribution):
2296     _argnames = ('xm', 'alpha')
2297 
2298     @property
2299     def set(self):
2300         return Interval(self.xm, oo)
2301 
2302     @staticmethod
2303     def check(xm, alpha):
2304         _value_check(xm > 0, "Xm must be positive")
2305         _value_check(alpha > 0, "Alpha must be positive")
2306 
2307     def pdf(self, x):
2308         xm, alpha = self.xm, self.alpha
2309         return alpha * xm**alpha / x**(alpha + 1)
2310 
2311     def sample(self):
2312         return random.paretovariate(self.alpha)
2313 
2314     def _cdf(self, x):
2315         xm, alpha = self.xm, self.alpha
2316         return Piecewise(
2317                 (S.One - xm**alpha/x**alpha, x>=xm),
2318                 (0, True),
2319         )
2320 
2321     def _moment_generating_function(self, t):
2322         xm, alpha = self.xm, self.alpha
2323         return alpha * (-xm*t)**alpha * uppergamma(-alpha, -xm*t)
2324 
2325     def _characteristic_function(self, t):
2326         xm, alpha = self.xm, self.alpha
2327         return alpha * (-I * xm * t) ** alpha * uppergamma(-alpha, -I * xm * t)
2328 
2329 
2330 def Pareto(name, xm, alpha):
2331     r"""
2332     Create a continuous random variable with the Pareto distribution.
2333 
2334     The density of the Pareto distribution is given by
2335 
2336     .. math::
2337         f(x) := \frac{\alpha\,x_m^\alpha}{x^{\alpha+1}}
2338 
2339     with :math:`x \in [x_m,\infty]`.
2340 
2341     Parameters
2342     ==========
2343 
2344     xm : Real number, `x_m > 0`, a scale
2345     alpha : Real number, `\alpha > 0`, a shape
2346 
2347     Returns
2348     =======
2349 
2350     A RandomSymbol.
2351 
2352     Examples
2353     ========
2354 
2355     >>> from sympy.stats import Pareto, density
2356     >>> from sympy import Symbol
2357 
2358     >>> xm = Symbol("xm", positive=True)
2359     >>> beta = Symbol("beta", positive=True)
2360     >>> z = Symbol("z")
2361 
2362     >>> X = Pareto("x", xm, beta)
2363 
2364     >>> density(X)(z)
2365     beta*xm**beta*z**(-beta - 1)
2366 
2367     References
2368     ==========
2369 
2370     .. [1] https://en.wikipedia.org/wiki/Pareto_distribution
2371     .. [2] http://mathworld.wolfram.com/ParetoDistribution.html
2372 
2373     """
2374 
2375     return rv(name, ParetoDistribution, (xm, alpha))
2376 
2377 #-------------------------------------------------------------------------------
2378 # QuadraticU distribution ------------------------------------------------------
2379 
2380 
2381 class QuadraticUDistribution(SingleContinuousDistribution):
2382     _argnames = ('a', 'b')
2383 
2384     @property
2385     def set(self):
2386         return Interval(self.a, self.b)
2387 
2388     def pdf(self, x):
2389         a, b = self.a, self.b
2390         alpha = 12 / (b-a)**3
2391         beta = (a+b) / 2
2392         return Piecewise(
2393                   (alpha * (x-beta)**2, And(a<=x, x<=b)),
2394                   (S.Zero, True))
2395 
2396     def _moment_generating_function(self, t):
2397         a, b = self.a, self.b
2398 
2399         return -3 * (exp(a*t) * (4  + (a**2 + 2*a*(-2 + b) + b**2) * t) - exp(b*t) * (4 + (-4*b + (a + b)**2) * t)) / ((a-b)**3 * t**2)
2400 
2401     def _characteristic_function(self, t):
2402         def _moment_generating_function(self, t):
2403             a, b = self.a, self.b
2404 
2405             return -3*I*(exp(I*a*t*exp(I*b*t)) * (4*I - (-4*b + (a+b)**2)*t)) / ((a-b)**3 * t**2)
2406 
2407 
2408 def QuadraticU(name, a, b):
2409     r"""
2410     Create a Continuous Random Variable with a U-quadratic distribution.
2411 
2412     The density of the U-quadratic distribution is given by
2413 
2414     .. math::
2415         f(x) := \alpha (x-\beta)^2
2416 
2417     with :math:`x \in [a,b]`.
2418 
2419     Parameters
2420     ==========
2421 
2422     a : Real number
2423     b : Real number, :math:`a < b`
2424 
2425     Returns
2426     =======
2427 
2428     A RandomSymbol.
2429 
2430     Examples
2431     ========
2432 
2433     >>> from sympy.stats import QuadraticU, density, E, variance
2434     >>> from sympy import Symbol, simplify, factor, pprint
2435 
2436     >>> a = Symbol("a", real=True)
2437     >>> b = Symbol("b", real=True)
2438     >>> z = Symbol("z")
2439 
2440     >>> X = QuadraticU("x", a, b)
2441 
2442     >>> D = density(X)(z)
2443     >>> pprint(D, use_unicode=False)
2444     /                2
2445     |   /  a   b    \
2446     |12*|- - - - + z|
2447     |   \  2   2    /
2448     <-----------------  for And(b >= z, a <= z)
2449     |            3
2450     |    (-a + b)
2451     |
2452     \        0                 otherwise
2453 
2454     References
2455     ==========
2456 
2457     .. [1] https://en.wikipedia.org/wiki/U-quadratic_distribution
2458 
2459     """
2460 
2461     return rv(name, QuadraticUDistribution, (a, b))
2462 
2463 #-------------------------------------------------------------------------------
2464 # RaisedCosine distribution ----------------------------------------------------
2465 
2466 
2467 class RaisedCosineDistribution(SingleContinuousDistribution):
2468     _argnames = ('mu', 's')
2469 
2470     @property
2471     def set(self):
2472         return Interval(self.mu - self.s, self.mu + self.s)
2473 
2474     @staticmethod
2475     def check(mu, s):
2476         _value_check(s > 0, "s must be positive")
2477 
2478     def pdf(self, x):
2479         mu, s = self.mu, self.s
2480         return Piecewise(
2481                 ((1+cos(pi*(x-mu)/s)) / (2*s), And(mu-s<=x, x<=mu+s)),
2482                 (S.Zero, True))
2483 
2484     def _characteristic_function(self, t):
2485         mu, s = self.mu, self.s
2486         return Piecewise((exp(-I*pi*mu/s)/2, Eq(t, -pi/s)),
2487                          (exp(I*pi*mu/s)/2, Eq(t, pi/s)),
2488                          (pi**2*sin(s*t)*exp(I*mu*t) / (s*t*(pi**2 - s**2*t**2)), True))
2489 
2490     def _moment_generating_function(self, t):
2491         mu, s = self.mu, self.s
2492         return pi**2 * sinh(s*t) * exp(mu*t) /  (s*t*(pi**2 + s**2*t**2))
2493 
2494 def RaisedCosine(name, mu, s):
2495     r"""
2496     Create a Continuous Random Variable with a raised cosine distribution.
2497 
2498     The density of the raised cosine distribution is given by
2499 
2500     .. math::
2501         f(x) := \frac{1}{2s}\left(1+\cos\left(\frac{x-\mu}{s}\pi\right)\right)
2502 
2503     with :math:`x \in [\mu-s,\mu+s]`.
2504 
2505     Parameters
2506     ==========
2507 
2508     mu : Real number
2509     s : Real number, `s > 0`
2510 
2511     Returns
2512     =======
2513 
2514     A RandomSymbol.
2515 
2516     Examples
2517     ========
2518 
2519     >>> from sympy.stats import RaisedCosine, density, E, variance
2520     >>> from sympy import Symbol, simplify, pprint
2521 
2522     >>> mu = Symbol("mu", real=True)
2523     >>> s = Symbol("s", positive=True)
2524     >>> z = Symbol("z")
2525 
2526     >>> X = RaisedCosine("x", mu, s)
2527 
2528     >>> D = density(X)(z)
2529     >>> pprint(D, use_unicode=False)
2530     /   /pi*(-mu + z)\
2531     |cos|------------| + 1
2532     |   \     s      /
2533     <---------------------  for And(z >= mu - s, z <= mu + s)
2534     |         2*s
2535     |
2536     \          0                        otherwise
2537 
2538     References
2539     ==========
2540 
2541     .. [1] https://en.wikipedia.org/wiki/Raised_cosine_distribution
2542 
2543     """
2544 
2545     return rv(name, RaisedCosineDistribution, (mu, s))
2546 
2547 #-------------------------------------------------------------------------------
2548 # Rayleigh distribution --------------------------------------------------------
2549 
2550 
2551 class RayleighDistribution(SingleContinuousDistribution):
2552     _argnames = ('sigma',)
2553 
2554     set = Interval(0, oo)
2555 
2556     def pdf(self, x):
2557         sigma = self.sigma
2558         return x/sigma**2*exp(-x**2/(2*sigma**2))
2559 
2560     def _cdf(self, x):
2561         sigma = self.sigma
2562         return 1 - exp(-(x**2/(2*sigma**2)))
2563 
2564     def _characteristic_function(self, t):
2565         sigma = self.sigma
2566         return 1 - sigma*t*exp(-sigma**2*t**2/2) * sqrt(pi/2) * (erfi(sigma*t/sqrt(2)) - I)
2567 
2568     def _moment_generating_function(self, t):
2569         sigma = self.sigma
2570         return 1 + sigma*t*exp(sigma**2*t**2/2) * sqrt(pi/2) * (erf(sigma*t/sqrt(2)) + 1)
2571 
2572 
2573 def Rayleigh(name, sigma):
2574     r"""
2575     Create a continuous random variable with a Rayleigh distribution.
2576 
2577     The density of the Rayleigh distribution is given by
2578 
2579     .. math ::
2580         f(x) := \frac{x}{\sigma^2} e^{-x^2/2\sigma^2}
2581 
2582     with :math:`x > 0`.
2583 
2584     Parameters
2585     ==========
2586 
2587     sigma : Real number, `\sigma > 0`
2588 
2589     Returns
2590     =======
2591 
2592     A RandomSymbol.
2593 
2594     Examples
2595     ========
2596 
2597     >>> from sympy.stats import Rayleigh, density, E, variance
2598     >>> from sympy import Symbol, simplify
2599 
2600     >>> sigma = Symbol("sigma", positive=True)
2601     >>> z = Symbol("z")
2602 
2603     >>> X = Rayleigh("x", sigma)
2604 
2605     >>> density(X)(z)
2606     z*exp(-z**2/(2*sigma**2))/sigma**2
2607 
2608     >>> E(X)
2609     sqrt(2)*sqrt(pi)*sigma/2
2610 
2611     >>> variance(X)
2612     -pi*sigma**2/2 + 2*sigma**2
2613 
2614     References
2615     ==========
2616 
2617     .. [1] https://en.wikipedia.org/wiki/Rayleigh_distribution
2618     .. [2] http://mathworld.wolfram.com/RayleighDistribution.html
2619 
2620     """
2621 
2622     return rv(name, RayleighDistribution, (sigma, ))
2623 
2624 #-------------------------------------------------------------------------------
2625 # Shifted Gompertz distribution ------------------------------------------------
2626 
2627 
2628 class ShiftedGompertzDistribution(SingleContinuousDistribution):
2629     _argnames = ('b', 'eta')
2630 
2631     set = Interval(0, oo)
2632 
2633     @staticmethod
2634     def check(b, eta):
2635         _value_check(b > 0, "b must be positive")
2636         _value_check(eta > 0, "eta must be positive")
2637 
2638     def pdf(self, x):
2639         b, eta = self.b, self.eta
2640         return b*exp(-b*x)*exp(-eta*exp(-b*x))*(1+eta*(1-exp(-b*x)))
2641 
2642 def ShiftedGompertz(name, b, eta):
2643     r"""
2644     Create a continuous random variable with a Shifted Gompertz distribution.
2645 
2646     The density of the Shifted Gompertz distribution is given by
2647 
2648     .. math::
2649         f(x) := b e^{-b x} e^{-\eta \exp(-b x)} \left[1 + \eta(1 - e^(-bx)) \right]
2650 
2651     with :math: 'x \in [0, \inf)'.
2652 
2653     Parameters
2654     ==========
2655 
2656     b: Real number, 'b > 0' a scale
2657     eta: Real number, 'eta > 0' a shape
2658 
2659     Returns
2660     =======
2661 
2662     A RandomSymbol.
2663 
2664     Examples
2665     ========
2666     >>> from sympy.stats import ShiftedGompertz, density, E, variance
2667     >>> from sympy import Symbol
2668 
2669     >>> b = Symbol("b", positive=True)
2670     >>> eta = Symbol("eta", positive=True)
2671     >>> x = Symbol("x")
2672 
2673     >>> X = ShiftedGompertz("x", b, eta)
2674 
2675     >>> density(X)(x)
2676     b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x))
2677 
2678     References
2679     ==========
2680 
2681     .. [1] https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution
2682 
2683     """
2684     return rv(name, ShiftedGompertzDistribution, (b, eta))
2685 
2686 #-------------------------------------------------------------------------------
2687 # StudentT distribution --------------------------------------------------------
2688 
2689 
2690 class StudentTDistribution(SingleContinuousDistribution):
2691     _argnames = ('nu',)
2692 
2693     def pdf(self, x):
2694         nu = self.nu
2695         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)
2696 
2697     def _cdf(self, x):
2698         nu = self.nu
2699         return S.Half + x*gamma((nu+1)/2)*hyper((S.Half, (nu+1)/2),
2700                                 (S(3)/2,), -x**2/nu)/(sqrt(pi*nu)*gamma(nu/2))
2701 
2702     def _moment_generating_function(self, t):
2703         raise NotImplementedError('The moment generating function for the Student-T distribution is undefined.')
2704 
2705 def StudentT(name, nu):
2706     r"""
2707     Create a continuous random variable with a student's t distribution.
2708 
2709     The density of the student's t distribution is given by
2710 
2711     .. math::
2712         f(x) := \frac{\Gamma \left(\frac{\nu+1}{2} \right)}
2713                 {\sqrt{\nu\pi}\Gamma \left(\frac{\nu}{2} \right)}
2714                 \left(1+\frac{x^2}{\nu} \right)^{-\frac{\nu+1}{2}}
2715 
2716     Parameters
2717     ==========
2718 
2719     nu : Real number, `\nu > 0`, the degrees of freedom
2720 
2721     Returns
2722     =======
2723 
2724     A RandomSymbol.
2725 
2726     Examples
2727     ========
2728 
2729     >>> from sympy.stats import StudentT, density, E, variance, cdf
2730     >>> from sympy import Symbol, simplify, pprint
2731 
2732     >>> nu = Symbol("nu", positive=True)
2733     >>> z = Symbol("z")
2734 
2735     >>> X = StudentT("x", nu)
2736 
2737     >>> D = density(X)(z)
2738     >>> pprint(D, use_unicode=False)
2739                nu   1
2740              - -- - -
2741                2    2
2742      /     2\
2743      |    z |
2744      |1 + --|
2745      \    nu/
2746     -----------------
2747       ____  /     nu\
2748     \/ nu *B|1/2, --|
2749             \     2 /
2750 
2751     >>> cdf(X)(z)
2752     1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),
2753                                 -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2))
2754 
2755 
2756     References
2757     ==========
2758 
2759     .. [1] https://en.wikipedia.org/wiki/Student_t-distribution
2760     .. [2] http://mathworld.wolfram.com/Studentst-Distribution.html
2761 
2762     """
2763 
2764     return rv(name, StudentTDistribution, (nu, ))
2765 
2766 #-------------------------------------------------------------------------------
2767 # Trapezoidal distribution ------------------------------------------------------
2768 
2769 
2770 class TrapezoidalDistribution(SingleContinuousDistribution):
2771     _argnames = ('a', 'b', 'c', 'd')
2772 
2773     def pdf(self, x):
2774         a, b, c, d = self.a, self.b, self.c, self.d
2775         return Piecewise(
2776             (2*(x-a) / ((b-a)*(d+c-a-b)), And(a <= x, x < b)),
2777             (2 / (d+c-a-b), And(b <= x, x < c)),
2778             (2*(d-x) / ((d-c)*(d+c-a-b)), And(c <= x, x <= d)),
2779             (S.Zero, True))
2780 
2781 def Trapezoidal(name, a, b, c, d):
2782     r"""
2783     Create a continuous random variable with a trapezoidal distribution.
2784 
2785     The density of the trapezoidal distribution is given by
2786 
2787     .. math::
2788         f(x) := \begin{cases}
2789                   0 & \mathrm{for\ } x < a, \\
2790                   \frac{2(x-a)}{(b-a)(d+c-a-b)} & \mathrm{for\ } a \le x < b, \\
2791                   \frac{2}{d+c-a-b} & \mathrm{for\ } b \le x < c, \\
2792                   \frac{2(d-x)}{(d-c)(d+c-a-b)} & \mathrm{for\ } c \le x < d, \\
2793                   0 & \mathrm{for\ } d < x.
2794                 \end{cases}
2795 
2796     Parameters
2797     ==========
2798 
2799     a : Real number, :math:`a < d`
2800     b : Real number, :math:`a <= b < c`
2801     c : Real number, :math:`b < c <= d`
2802     d : Real number
2803 
2804     Returns
2805     =======
2806 
2807     A RandomSymbol.
2808 
2809     Examples
2810     ========
2811 
2812     >>> from sympy.stats import Trapezoidal, density, E
2813     >>> from sympy import Symbol, pprint
2814 
2815     >>> a = Symbol("a")
2816     >>> b = Symbol("b")
2817     >>> c = Symbol("c")
2818     >>> d = Symbol("d")
2819     >>> z = Symbol("z")
2820 
2821     >>> X = Trapezoidal("x", a,b,c,d)
2822 
2823     >>> pprint(density(X)(z), use_unicode=False)
2824     /        -2*a + 2*z
2825     |-------------------------  for And(a <= z, b > z)
2826     |(-a + b)*(-a - b + c + d)
2827     |
2828     |           2
2829     |     --------------        for And(b <= z, c > z)
2830     <     -a - b + c + d
2831     |
2832     |        2*d - 2*z
2833     |-------------------------  for And(d >= z, c <= z)
2834     |(-c + d)*(-a - b + c + d)
2835     |
2836     \            0                     otherwise
2837 
2838     References
2839     ==========
2840 
2841     .. [1] https://en.wikipedia.org/wiki/Trapezoidal_distribution
2842 
2843     """
2844     return rv(name, TrapezoidalDistribution, (a, b, c, d))
2845 
2846 #-------------------------------------------------------------------------------
2847 # Triangular distribution ------------------------------------------------------
2848 
2849 
2850 class TriangularDistribution(SingleContinuousDistribution):
2851     _argnames = ('a', 'b', 'c')
2852 
2853     def pdf(self, x):
2854         a, b, c = self.a, self.b, self.c
2855         return Piecewise(
2856             (2*(x - a)/((b - a)*(c - a)), And(a <= x, x < c)),
2857             (2/(b - a), Eq(x, c)),
2858             (2*(b - x)/((b - a)*(b - c)), And(c < x, x <= b)),
2859             (S.Zero, True))
2860 
2861     def _characteristic_function(self, t):
2862         a, b, c = self.a, self.b, self.c
2863         return -2 *((b-c) * exp(I*a*t) - (b-a) * exp(I*c*t) + (c-a) * exp(I*b*t)) / ((b-a)*(c-a)*(b-c)*t**2)
2864 
2865     def _moment_generating_function(self, t):
2866         a, b, c = self.a, self.b, self.c
2867         return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (
2868         (b - a) * (c - a) * (b - c) * t ** 2)
2869 
2870 
2871 def Triangular(name, a, b, c):
2872     r"""
2873     Create a continuous random variable with a triangular distribution.
2874 
2875     The density of the triangular distribution is given by
2876 
2877     .. math::
2878         f(x) := \begin{cases}
2879                   0 & \mathrm{for\ } x < a, \\
2880                   \frac{2(x-a)}{(b-a)(c-a)} & \mathrm{for\ } a \le x < c, \\
2881                   \frac{2}{b-a} & \mathrm{for\ } x = c, \\
2882                   \frac{2(b-x)}{(b-a)(b-c)} & \mathrm{for\ } c < x \le b, \\
2883                   0 & \mathrm{for\ } b < x.
2884                 \end{cases}
2885 
2886     Parameters
2887     ==========
2888 
2889     a : Real number, :math:`a \in \left(-\infty, \infty\right)`
2890     b : Real number, :math:`a < b`
2891     c : Real number, :math:`a \leq c \leq b`
2892 
2893     Returns
2894     =======
2895 
2896     A RandomSymbol.
2897 
2898     Examples
2899     ========
2900 
2901     >>> from sympy.stats import Triangular, density, E
2902     >>> from sympy import Symbol, pprint
2903 
2904     >>> a = Symbol("a")
2905     >>> b = Symbol("b")
2906     >>> c = Symbol("c")
2907     >>> z = Symbol("z")
2908 
2909     >>> X = Triangular("x", a,b,c)
2910 
2911     >>> pprint(density(X)(z), use_unicode=False)
2912     /    -2*a + 2*z
2913     |-----------------  for And(a <= z, c > z)
2914     |(-a + b)*(-a + c)
2915     |
2916     |       2
2917     |     ------              for c = z
2918     <     -a + b
2919     |
2920     |   2*b - 2*z
2921     |----------------   for And(b >= z, c < z)
2922     |(-a + b)*(b - c)
2923     |
2924     \        0                otherwise
2925 
2926     References
2927     ==========
2928 
2929     .. [1] https://en.wikipedia.org/wiki/Triangular_distribution
2930     .. [2] http://mathworld.wolfram.com/TriangularDistribution.html
2931 
2932     """
2933 
2934     return rv(name, TriangularDistribution, (a, b, c))
2935 
2936 #-------------------------------------------------------------------------------
2937 # Uniform distribution ---------------------------------------------------------
2938 
2939 
2940 class UniformDistribution(SingleContinuousDistribution):
2941     _argnames = ('left', 'right')
2942 
2943     def pdf(self, x):
2944         left, right = self.left, self.right
2945         return Piecewise(
2946             (S.One/(right - left), And(left <= x, x <= right)),
2947             (S.Zero, True)
2948         )
2949 
2950     def _cdf(self, x):
2951         left, right = self.left, self.right
2952         return Piecewise(
2953             (S.Zero, x < left),
2954             ((x - left)/(right - left), x <= right),
2955             (S.One, True)
2956         )
2957 
2958     def _characteristic_function(self, t):
2959         left, right = self.left, self.right
2960         return Piecewise(((exp(I*t*right) - exp(I*t*left)) / (I*t*(right - left)), Ne(t, 0)),
2961                          (S.One, True))
2962 
2963     def _moment_generating_function(self, t):
2964         left, right = self.left, self.right
2965         return Piecewise(((exp(t*right) - exp(t*left)) / (t * (right - left)), Ne(t, 0)),
2966                          (S.One, True))
2967 
2968     def expectation(self, expr, var, **kwargs):
2969         from sympy import Max, Min
2970         kwargs['evaluate'] = True
2971         result = SingleContinuousDistribution.expectation(self, expr, var, **kwargs)
2972         result = result.subs({Max(self.left, self.right): self.right,
2973                               Min(self.left, self.right): self.left})
2974         return result
2975 
2976     def sample(self):
2977         return random.uniform(self.left, self.right)
2978 
2979 
2980 def Uniform(name, left, right):
2981     r"""
2982     Create a continuous random variable with a uniform distribution.
2983 
2984     The density of the uniform distribution is given by
2985 
2986     .. math::
2987         f(x) := \begin{cases}
2988                   \frac{1}{b - a} & \text{for } x \in [a,b]  \\
2989                   0               & \text{otherwise}
2990                 \end{cases}
2991 
2992     with :math:`x \in [a,b]`.
2993 
2994     Parameters
2995     ==========
2996 
2997     a : Real number, :math:`-\infty < a` the left boundary
2998     b : Real number, :math:`a < b < \infty` the right boundary
2999 
3000     Returns
3001     =======
3002 
3003     A RandomSymbol.
3004 
3005     Examples
3006     ========
3007 
3008     >>> from sympy.stats import Uniform, density, cdf, E, variance, skewness
3009     >>> from sympy import Symbol, simplify
3010 
3011     >>> a = Symbol("a", negative=True)
3012     >>> b = Symbol("b", positive=True)
3013     >>> z = Symbol("z")
3014 
3015     >>> X = Uniform("x", a, b)
3016 
3017     >>> density(X)(z)
3018     Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True))
3019 
3020     >>> cdf(X)(z)  # doctest: +SKIP
3021     -a/(-a + b) + z/(-a + b)
3022 
3023     >>> simplify(E(X))
3024     a/2 + b/2
3025 
3026     >>> simplify(variance(X))
3027     a**2/12 - a*b/6 + b**2/12
3028 
3029     References
3030     ==========
3031 
3032     .. [1] https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29
3033     .. [2] http://mathworld.wolfram.com/UniformDistribution.html
3034 
3035     """
3036 
3037     return rv(name, UniformDistribution, (left, right))
3038 
3039 #-------------------------------------------------------------------------------
3040 # UniformSum distribution ------------------------------------------------------
3041 
3042 
3043 class UniformSumDistribution(SingleContinuousDistribution):
3044     _argnames = ('n',)
3045 
3046     @property
3047     def set(self):
3048         return Interval(0, self.n)
3049 
3050     def pdf(self, x):
3051         n = self.n
3052         k = Dummy("k")
3053         return 1/factorial(
3054             n - 1)*Sum((-1)**k*binomial(n, k)*(x - k)**(n - 1), (k, 0, floor(x)))
3055 
3056     def _cdf(self, x):
3057         n = self.n
3058         k = Dummy("k")
3059         return Piecewise((S.Zero, x < 0),
3060                         (1/factorial(n)*Sum((-1)**k*binomial(n, k)*(x - k)**(n),
3061                         (k, 0, floor(x))), x <= n),
3062                         (S.One, True))
3063 
3064     def _characteristic_function(self, t):
3065         return ((exp(I*t) - 1) / (I*t))**self.n
3066 
3067     def _moment_generating_function(self, t):
3068         return ((exp(t) - 1) / t)**self.n
3069 
3070 def UniformSum(name, n):
3071     r"""
3072     Create a continuous random variable with an Irwin-Hall distribution.
3073 
3074     The probability distribution function depends on a single parameter
3075     `n` which is an integer.
3076 
3077     The density of the Irwin-Hall distribution is given by
3078 
3079     .. math ::
3080         f(x) := \frac{1}{(n-1)!}\sum_{k=0}^{\left\lfloor x\right\rfloor}(-1)^k
3081                 \binom{n}{k}(x-k)^{n-1}
3082 
3083     Parameters
3084     ==========
3085 
3086     n : A positive Integer, `n > 0`
3087 
3088     Returns
3089     =======
3090 
3091     A RandomSymbol.
3092 
3093     Examples
3094     ========
3095 
3096     >>> from sympy.stats import UniformSum, density, cdf
3097     >>> from sympy import Symbol, pprint
3098 
3099     >>> n = Symbol("n", integer=True)
3100     >>> z = Symbol("z")
3101 
3102     >>> X = UniformSum("x", n)
3103 
3104     >>> D = density(X)(z)
3105     >>> pprint(D, use_unicode=False)
3106     floor(z)
3107       ___
3108       \  `
3109        \         k         n - 1 /n\
3110         )    (-1) *(-k + z)     *| |
3111        /                         \k/
3112       /__,
3113      k = 0
3114     --------------------------------
3115                 (n - 1)!
3116 
3117     >>> cdf(X)(z)
3118     Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),
3119                     (_k, 0, floor(z)))/factorial(n), n >= z), (1, True))
3120 
3121 
3122     Compute cdf with specific 'x' and 'n' values as follows :
3123     >>> cdf(UniformSum("x", 5), evaluate=False)(2).doit()
3124     9/40
3125 
3126     The argument evaluate=False prevents an attempt at evaluation
3127     of the sum for general n, before the argument 2 is passed.
3128 
3129     References
3130     ==========
3131 
3132     .. [1] https://en.wikipedia.org/wiki/Uniform_sum_distribution
3133     .. [2] http://mathworld.wolfram.com/UniformSumDistribution.html
3134 
3135     """
3136 
3137     return rv(name, UniformSumDistribution, (n, ))
3138 
3139 #-------------------------------------------------------------------------------
3140 # VonMises distribution --------------------------------------------------------
3141 
3142 
3143 class VonMisesDistribution(SingleContinuousDistribution):
3144     _argnames = ('mu', 'k')
3145 
3146     set = Interval(0, 2*pi)
3147 
3148     @staticmethod
3149     def check(mu, k):
3150         _value_check(k > 0, "k must be positive")
3151 
3152     def pdf(self, x):
3153         mu, k = self.mu, self.k
3154         return exp(k*cos(x-mu)) / (2*pi*besseli(0, k))
3155 
3156 def VonMises(name, mu, k):
3157     r"""
3158     Create a Continuous Random Variable with a von Mises distribution.
3159 
3160     The density of the von Mises distribution is given by
3161 
3162     .. math::
3163         f(x) := \frac{e^{\kappa\cos(x-\mu)}}{2\pi I_0(\kappa)}
3164 
3165     with :math:`x \in [0,2\pi]`.
3166 
3167     Parameters
3168     ==========
3169 
3170     mu : Real number, measure of location
3171     k : Real number, measure of concentration
3172 
3173     Returns
3174     =======
3175 
3176     A RandomSymbol.
3177 
3178     Examples
3179     ========
3180 
3181     >>> from sympy.stats import VonMises, density, E, variance
3182     >>> from sympy import Symbol, simplify, pprint
3183 
3184     >>> mu = Symbol("mu")
3185     >>> k = Symbol("k", positive=True)
3186     >>> z = Symbol("z")
3187 
3188     >>> X = VonMises("x", mu, k)
3189 
3190     >>> D = density(X)(z)
3191     >>> pprint(D, use_unicode=False)
3192          k*cos(mu - z)
3193         e
3194     ------------------
3195     2*pi*besseli(0, k)
3196 
3197 
3198     References
3199     ==========
3200 
3201     .. [1] https://en.wikipedia.org/wiki/Von_Mises_distribution
3202     .. [2] http://mathworld.wolfram.com/vonMisesDistribution.html
3203 
3204     """
3205 
3206     return rv(name, VonMisesDistribution, (mu, k))
3207 
3208 #-------------------------------------------------------------------------------
3209 # Weibull distribution ---------------------------------------------------------
3210 
3211 
3212 class WeibullDistribution(SingleContinuousDistribution):
3213     _argnames = ('alpha', 'beta')
3214 
3215     set = Interval(0, oo)
3216 
3217     @staticmethod
3218     def check(alpha, beta):
3219         _value_check(alpha > 0, "Alpha must be positive")
3220         _value_check(beta > 0, "Beta must be positive")
3221 
3222     def pdf(self, x):
3223         alpha, beta = self.alpha, self.beta
3224         return beta * (x/alpha)**(beta - 1) * exp(-(x/alpha)**beta) / alpha
3225 
3226     def sample(self):
3227         return random.weibullvariate(self.alpha, self.beta)
3228 
3229 def Weibull(name, alpha, beta):
3230     r"""
3231     Create a continuous random variable with a Weibull distribution.
3232 
3233     The density of the Weibull distribution is given by
3234 
3235     .. math::
3236         f(x) := \begin{cases}
3237                   \frac{k}{\lambda}\left(\frac{x}{\lambda}\right)^{k-1}
3238                   e^{-(x/\lambda)^{k}} & x\geq0\\
3239                   0 & x<0
3240                 \end{cases}
3241 
3242     Parameters
3243     ==========
3244 
3245     lambda : Real number, :math:`\lambda > 0` a scale
3246     k : Real number, `k > 0` a shape
3247 
3248     Returns
3249     =======
3250 
3251     A RandomSymbol.
3252 
3253     Examples
3254     ========
3255 
3256     >>> from sympy.stats import Weibull, density, E, variance
3257     >>> from sympy import Symbol, simplify
3258 
3259     >>> l = Symbol("lambda", positive=True)
3260     >>> k = Symbol("k", positive=True)
3261     >>> z = Symbol("z")
3262 
3263     >>> X = Weibull("x", l, k)
3264 
3265     >>> density(X)(z)
3266     k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda
3267 
3268     >>> simplify(E(X))
3269     lambda*gamma(1 + 1/k)
3270 
3271     >>> simplify(variance(X))
3272     lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k))
3273 
3274     References
3275     ==========
3276 
3277     .. [1] https://en.wikipedia.org/wiki/Weibull_distribution
3278     .. [2] http://mathworld.wolfram.com/WeibullDistribution.html
3279 
3280     """
3281 
3282     return rv(name, WeibullDistribution, (alpha, beta))
3283 
3284 #-------------------------------------------------------------------------------
3285 # Wigner semicircle distribution -----------------------------------------------
3286 
3287 
3288 class WignerSemicircleDistribution(SingleContinuousDistribution):
3289     _argnames = ('R',)
3290 
3291     @property
3292     def set(self):
3293         return Interval(-self.R, self.R)
3294 
3295     def pdf(self, x):
3296         R = self.R
3297         return 2/(pi*R**2)*sqrt(R**2 - x**2)
3298 
3299     def _characteristic_function(self, t):
3300         return Piecewise((2 * besselj(1, self.R*t) / (self.R*t), Ne(t, 0)),
3301                          (S.One, True))
3302 
3303     def _moment_generating_function(self, t):
3304         return Piecewise((2 * besseli(1, self.R*t) / (self.R*t), Ne(t, 0)),
3305                          (S.One, True))
3306 
3307 def WignerSemicircle(name, R):
3308     r"""
3309     Create a continuous random variable with a Wigner semicircle distribution.
3310 
3311     The density of the Wigner semicircle distribution is given by
3312 
3313     .. math::
3314         f(x) := \frac2{\pi R^2}\,\sqrt{R^2-x^2}
3315 
3316     with :math:`x \in [-R,R]`.
3317 
3318     Parameters
3319     ==========
3320 
3321     R : Real number, `R > 0`, the radius
3322 
3323     Returns
3324     =======
3325 
3326     A `RandomSymbol`.
3327 
3328     Examples
3329     ========
3330 
3331     >>> from sympy.stats import WignerSemicircle, density, E
3332     >>> from sympy import Symbol, simplify
3333 
3334     >>> R = Symbol("R", positive=True)
3335     >>> z = Symbol("z")
3336 
3337     >>> X = WignerSemicircle("x", R)
3338 
3339     >>> density(X)(z)
3340     2*sqrt(R**2 - z**2)/(pi*R**2)
3341 
3342     >>> E(X)
3343     0
3344 
3345     References
3346     ==========
3347 
3348     .. [1] https://en.wikipedia.org/wiki/Wigner_semicircle_distribution
3349     .. [2] http://mathworld.wolfram.com/WignersSemicircleLaw.html
3350 
3351     """
3352 
3353     return rv(name, WignerSemicircleDistribution, (R,))

</code><intended_behavior>Enhance the `check` methods to include all necessary validations for the parameters of each continuous distribution. Ensure that inappropriate values raise appropriate errors or warnings. Additionally, ensure that all relevant attributes are correctly set and accessible for these distributions.</intended_behavior>, <file>sympy/stats/drv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 
3 Contains
4 ========
5 Geometric
6 Poisson
7 Logarithmic
8 NegativeBinomial
9 Poisson
10 YuleSimon
11 Zeta
12 """
13 
14 
15 from __future__ import print_function, division
16 
17 from sympy import (factorial, exp, S, sympify, And, I, zeta, polylog, log, beta,
18     hyper, binomial, Piecewise, floor)
19 from sympy.stats import density
20 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace
21 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
22 from sympy.stats.rv import _value_check, RandomSymbol
23 import random
24 
25 __all__ = ['Geometric',
26 'Logarithmic',
27 'NegativeBinomial',
28 'Poisson',
29 'YuleSimon',
30 'Zeta'
31 ]
32 
33 
34 def rv(symbol, cls, *args):
35     args = list(map(sympify, args))
36     dist = cls(*args)
37     dist.check(*args)
38     pspace = SingleDiscretePSpace(symbol, dist)
39     if any(isinstance(arg, RandomSymbol) for arg in args):
40         pspace = JointPSpace(symbol, CompoundDistribution(dist))
41     return pspace.value
42 
43 
44 #-------------------------------------------------------------------------------
45 # Geometric distribution ------------------------------------------------------------
46 
47 class GeometricDistribution(SingleDiscreteDistribution):
48     _argnames = ('p',)
49     set = S.Naturals
50 
51     @staticmethod
52     def check(p):
53         _value_check((0 < p, p <= 1), "p must be between 0 and 1")
54 
55     def pdf(self, k):
56         return (1 - self.p)**(k - 1) * self.p
57 
58     def _characteristic_function(self, t):
59         p = self.p
60         return p * exp(I*t) / (1 - (1 - p)*exp(I*t))
61 
62     def _moment_generating_function(self, t):
63         p = self.p
64         return p * exp(t) / (1 - (1 - p) * exp(t))
65 
66 def Geometric(name, p):
67     r"""
68     Create a discrete random variable with a Geometric distribution.
69 
70     The density of the Geometric distribution is given by
71 
72     .. math::
73         f(k) := p (1 - p)^{k - 1}
74 
75     Parameters
76     ==========
77 
78     p: A probability between 0 and 1
79 
80     Returns
81     =======
82 
83     A RandomSymbol.
84 
85     Examples
86     ========
87 
88     >>> from sympy.stats import Geometric, density, E, variance
89     >>> from sympy import Symbol, S
90 
91     >>> p = S.One / 5
92     >>> z = Symbol("z")
93 
94     >>> X = Geometric("x", p)
95 
96     >>> density(X)(z)
97     (4/5)**(z - 1)/5
98 
99     >>> E(X)
100     5
101 
102     >>> variance(X)
103     20
104 
105     References
106     ==========
107 
108     .. [1] https://en.wikipedia.org/wiki/Geometric_distribution
109     .. [2] http://mathworld.wolfram.com/GeometricDistribution.html
110 
111     """
112     return rv(name, GeometricDistribution, p)
113 
114 
115 #-------------------------------------------------------------------------------
116 # Logarithmic distribution ------------------------------------------------------------
117 
118 class LogarithmicDistribution(SingleDiscreteDistribution):
119     _argnames = ('p',)
120 
121     set = S.Naturals
122 
123     @staticmethod
124     def check(p):
125         _value_check((p > 0, p < 1), "p should be between 0 and 1")
126 
127     def pdf(self, k):
128         p = self.p
129         return (-1) * p**k / (k * log(1 - p))
130 
131     def _characteristic_function(self, t):
132         p = self.p
133         return log(1 - p * exp(I*t)) / log(1 - p)
134 
135     def _moment_generating_function(self, t):
136         p = self.p
137         return log(1 - p * exp(t)) / log(1 - p)
138 
139     def sample(self):
140         ### TODO
141         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
142 
143 
144 def Logarithmic(name, p):
145     r"""
146     Create a discrete random variable with a Logarithmic distribution.
147 
148     The density of the Logarithmic distribution is given by
149 
150     .. math::
151         f(k) := \frac{-p^k}{k \ln{(1 - p)}}
152 
153     Parameters
154     ==========
155 
156     p: A value between 0 and 1
157 
158     Returns
159     =======
160 
161     A RandomSymbol.
162 
163     Examples
164     ========
165 
166     >>> from sympy.stats import Logarithmic, density, E, variance
167     >>> from sympy import Symbol, S
168 
169     >>> p = S.One / 5
170     >>> z = Symbol("z")
171 
172     >>> X = Logarithmic("x", p)
173 
174     >>> density(X)(z)
175     -5**(-z)/(z*log(4/5))
176 
177     >>> E(X)
178     -1/(-4*log(5) + 8*log(2))
179 
180     >>> variance(X)
181     -1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2))
182 
183     References
184     ==========
185 
186     .. [1] https://en.wikipedia.org/wiki/Logarithmic_distribution
187     .. [2] http://mathworld.wolfram.com/LogarithmicDistribution.html
188 
189     """
190     return rv(name, LogarithmicDistribution, p)
191 
192 
193 #-------------------------------------------------------------------------------
194 # Negative binomial distribution ------------------------------------------------------------
195 
196 class NegativeBinomialDistribution(SingleDiscreteDistribution):
197     _argnames = ('r', 'p')
198     set = S.Naturals0
199 
200     @staticmethod
201     def check(r, p):
202         _value_check(r > 0, 'r should be positive')
203         _value_check((p > 0, p < 1), 'p should be between 0 and 1')
204 
205     def pdf(self, k):
206         r = self.r
207         p = self.p
208 
209         return binomial(k + r - 1, k) * (1 - p)**r * p**k
210 
211     def _characteristic_function(self, t):
212         r = self.r
213         p = self.p
214 
215         return ((1 - p) / (1 - p * exp(I*t)))**r
216 
217     def _moment_generating_function(self, t):
218         r = self.r
219         p = self.p
220 
221         return ((1 - p) / (1 - p * exp(t)))**r
222 
223     def sample(self):
224         ### TODO
225         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
226 
227 
228 def NegativeBinomial(name, r, p):
229     r"""
230     Create a discrete random variable with a Negative Binomial distribution.
231 
232     The density of the Negative Binomial distribution is given by
233 
234     .. math::
235         f(k) := \binom{k + r - 1}{k} (1 - p)^r p^k
236 
237     Parameters
238     ==========
239 
240     r: A positive value
241     p: A value between 0 and 1
242 
243     Returns
244     =======
245 
246     A RandomSymbol.
247 
248     Examples
249     ========
250 
251     >>> from sympy.stats import NegativeBinomial, density, E, variance
252     >>> from sympy import Symbol, S
253 
254     >>> r = 5
255     >>> p = S.One / 5
256     >>> z = Symbol("z")
257 
258     >>> X = NegativeBinomial("x", r, p)
259 
260     >>> density(X)(z)
261     1024*5**(-z)*binomial(z + 4, z)/3125
262 
263     >>> E(X)
264     5/4
265 
266     >>> variance(X)
267     25/16
268 
269     References
270     ==========
271 
272     .. [1] https://en.wikipedia.org/wiki/Negative_binomial_distribution
273     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
274 
275     """
276     return rv(name, NegativeBinomialDistribution, r, p)
277 
278 
279 #-------------------------------------------------------------------------------
280 # Poisson distribution ------------------------------------------------------------
281 
282 class PoissonDistribution(SingleDiscreteDistribution):
283     _argnames = ('lamda',)
284 
285     set = S.Naturals0
286 
287     @staticmethod
288     def check(lamda):
289         _value_check(lamda > 0, "Lambda must be positive")
290 
291     def pdf(self, k):
292         return self.lamda**k / factorial(k) * exp(-self.lamda)
293 
294     def sample(self):
295         def search(x, y, u):
296             while x < y:
297                 mid = (x + y)//2
298                 if u <= self.cdf(mid):
299                     y = mid
300                 else:
301                     x = mid + 1
302             return x
303 
304         u = random.uniform(0, 1)
305         if u <= self.cdf(S.Zero):
306             return S.Zero
307         n = S.One
308         while True:
309             if u > self.cdf(2*n):
310                 n *= 2
311             else:
312                 return search(n, 2*n, u)
313 
314     def _characteristic_function(self, t):
315         return exp(self.lamda * (exp(I*t) - 1))
316 
317     def _moment_generating_function(self, t):
318         return exp(self.lamda * (exp(t) - 1))
319 
320 
321 def Poisson(name, lamda):
322     r"""
323     Create a discrete random variable with a Poisson distribution.
324 
325     The density of the Poisson distribution is given by
326 
327     .. math::
328         f(k) := \frac{\lambda^{k} e^{- \lambda}}{k!}
329 
330     Parameters
331     ==========
332 
333     lamda: Positive number, a rate
334 
335     Returns
336     =======
337 
338     A RandomSymbol.
339 
340     Examples
341     ========
342 
343     >>> from sympy.stats import Poisson, density, E, variance
344     >>> from sympy import Symbol, simplify
345 
346     >>> rate = Symbol("lambda", positive=True)
347     >>> z = Symbol("z")
348 
349     >>> X = Poisson("x", rate)
350 
351     >>> density(X)(z)
352     lambda**z*exp(-lambda)/factorial(z)
353 
354     >>> E(X)
355     lambda
356 
357     >>> simplify(variance(X))
358     lambda
359 
360     References
361     ==========
362 
363     .. [1] https://en.wikipedia.org/wiki/Poisson_distribution
364     .. [2] http://mathworld.wolfram.com/PoissonDistribution.html
365 
366     """
367     return rv(name, PoissonDistribution, lamda)
368 
369 
370 #-------------------------------------------------------------------------------
371 # Yule-Simon distribution ------------------------------------------------------------
372 
373 class YuleSimonDistribution(SingleDiscreteDistribution):
374     _argnames = ('rho',)
375     set = S.Naturals
376 
377     @staticmethod
378     def check(rho):
379         _value_check(rho > 0, 'rho should be positive')
380 
381     def pdf(self, k):
382         rho = self.rho
383         return rho * beta(k, rho + 1)
384 
385     def _cdf(self, x):
386         return Piecewise((1 - floor(x) * beta(floor(x), self.rho + 1), x >= 1), (0, True))
387 
388     def _characteristic_function(self, t):
389         rho = self.rho
390         return rho * hyper((1, 1), (rho + 2,), exp(I*t)) * exp(I*t) / (rho + 1)
391 
392     def _moment_generating_function(self, t):
393         rho = self.rho
394         return rho * hyper((1, 1), (rho + 2,), exp(t)) * exp(t) / (rho + 1)
395 
396     def sample(self):
397         ### TODO
398         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
399 
400 
401 def YuleSimon(name, rho):
402     r"""
403     Create a discrete random variable with a Yule-Simon distribution.
404 
405     The density of the Yule-Simon distribution is given by
406 
407     .. math::
408         f(k) := \rho B(k, \rho + 1)
409 
410     Parameters
411     ==========
412 
413     rho: A positive value
414 
415     Returns
416     =======
417 
418     A RandomSymbol.
419 
420     Examples
421     ========
422 
423     >>> from sympy.stats import YuleSimon, density, E, variance
424     >>> from sympy import Symbol, simplify
425 
426     >>> p = 5
427     >>> z = Symbol("z")
428 
429     >>> X = YuleSimon("x", p)
430 
431     >>> density(X)(z)
432     5*beta(z, 6)
433 
434     >>> simplify(E(X))
435     5/4
436 
437     >>> simplify(variance(X))
438     25/48
439 
440     References
441     ==========
442 
443     .. [1] https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution
444 
445     """
446     return rv(name, YuleSimonDistribution, rho)
447 
448 
449 #-------------------------------------------------------------------------------
450 # Zeta distribution ------------------------------------------------------------
451 
452 class ZetaDistribution(SingleDiscreteDistribution):
453     _argnames = ('s',)
454     set = S.Naturals
455 
456     @staticmethod
457     def check(s):
458         _value_check(s > 1, 's should be greater than 1')
459 
460     def pdf(self, k):
461         s = self.s
462         return 1 / (k**s * zeta(s))
463 
464     def _characteristic_function(self, t):
465         return polylog(self.s, exp(I*t)) / zeta(self.s)
466 
467     def _moment_generating_function(self, t):
468         return polylog(self.s, exp(t)) / zeta(self.s)
469 
470     def sample(self):
471         ### TODO
472         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
473 
474 
475 def Zeta(name, s):
476     r"""
477     Create a discrete random variable with a Zeta distribution.
478 
479     The density of the Zeta distribution is given by
480 
481     .. math::
482         f(k) := \frac{1}{k^s \zeta{(s)}}
483 
484     Parameters
485     ==========
486 
487     s: A value greater than 1
488 
489     Returns
490     =======
491 
492     A RandomSymbol.
493 
494     Examples
495     ========
496 
497     >>> from sympy.stats import Zeta, density, E, variance
498     >>> from sympy import Symbol
499 
500     >>> s = 5
501     >>> z = Symbol("z")
502 
503     >>> X = Zeta("x", s)
504 
505     >>> density(X)(z)
506     1/(z**5*zeta(5))
507 
508     >>> E(X)
509     pi**4/(90*zeta(5))
510 
511     >>> variance(X)
512     -pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5)
513 
514     References
515     ==========
516 
517     .. [1] https://en.wikipedia.org/wiki/Zeta_distribution
518 
519     """
520     return rv(name, ZetaDistribution, s)

</code><intended_behavior>Similar to `crv_types.py`, validations within `check` methods should be exhaustive, covering the domain of possible parameters to prevent invalid configurations. Ensure attributes related to the distributions are correctly implemented and documented.</intended_behavior>, <file>sympy/stats/joint_rv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, Gt, IndexedBase,
2                     besselk, gamma, Interval, Range, factorial, Mul, Integer,
3                     Add, rf, Eq, Piecewise, Symbol, imageset, Intersection)
4 from sympy.matrices import ImmutableMatrix
5 from sympy.matrices.expressions.determinant import det
6 from sympy.stats.joint_rv import (JointDistribution, JointPSpace,
7     JointDistributionHandmade, MarginalDistribution)
8 from sympy.stats.rv import _value_check, random_symbols
9 
10 # __all__ = ['MultivariateNormal',
11 # 'MultivariateLaplace',
12 # 'MultivariateT',
13 # 'NormalGamma'
14 # ]
15 
16 def multivariate_rv(cls, sym, *args):
17     args = list(map(sympify, args))
18     dist = cls(*args)
19     args = dist.args
20     dist.check(*args)
21     return JointPSpace(sym, dist).value
22 
23 def JointRV(symbol, pdf, _set=None):
24     """
25     Create a Joint Random Variable where each of its component is conitinuous,
26     given the following:
27 
28     -- a symbol
29     -- a PDF in terms of indexed symbols of the symbol given
30      as the first argument
31 
32     NOTE: As of now, the set for each component for a `JointRV` is
33     equal to the set of all integers, which can not be changed.
34 
35     Returns a RandomSymbol.
36 
37     Examples
38     ========
39 
40     >>> from sympy import symbols, exp, pi, Indexed, S
41     >>> from sympy.stats import density
42     >>> from sympy.stats.joint_rv_types import JointRV
43 
44     >>> x1, x2 = (Indexed('x', i) for i in (1, 2))
45     >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)
46 
47     >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution
48     >>> density(N1)(1, 2)
49     exp(-2)/(2*pi)
50     """
51     #TODO: Add support for sets provided by the user
52     symbol = sympify(symbol)
53     syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)
54         and i.base == IndexedBase(symbol))
55     syms.sort(key = lambda index: index.args[1])
56     _set = S.Reals**len(syms)
57     pdf = Lambda(syms, pdf)
58     dist = JointDistributionHandmade(pdf, _set)
59     jrv = JointPSpace(symbol, dist).value
60     rvs = random_symbols(pdf)
61     if len(rvs) != 0:
62         dist = MarginalDistribution(dist, (jrv,))
63         return JointPSpace(symbol, dist).value
64     return jrv
65 
66 #-------------------------------------------------------------------------------
67 # Multivariate Normal distribution ---------------------------------------------------------
68 
69 class MultivariateNormalDistribution(JointDistribution):
70     _argnames = ['mu', 'sigma']
71 
72     is_Continuous=True
73 
74     @property
75     def set(self):
76         k = len(self.mu)
77         return S.Reals**k
78 
79     def check(self, mu, sigma):
80         _value_check(len(mu) == len(sigma.col(0)),
81             "Size of the mean vector and covariance matrix are incorrect.")
82         #check if covariance matrix is positive definite or not.
83         _value_check((i > 0 for i in sigma.eigenvals().keys()),
84             "The covariance matrix must be positive definite. ")
85 
86     def pdf(self, *args):
87         mu, sigma = self.mu, self.sigma
88         k = len(mu)
89         args = ImmutableMatrix(args)
90         x = args - mu
91         return  S(1)/sqrt((2*pi)**(k)*det(sigma))*exp(
92             -S(1)/2*x.transpose()*(sigma.inv()*\
93                 x))[0]
94 
95     def marginal_distribution(self, indices, sym):
96         sym = ImmutableMatrix([Indexed(sym, i) for i in indices])
97         _mu, _sigma = self.mu, self.sigma
98         k = len(self.mu)
99         for i in range(k):
100             if i not in indices:
101                 _mu = _mu.row_del(i)
102                 _sigma = _sigma.col_del(i)
103                 _sigma = _sigma.row_del(i)
104         return Lambda(sym, S(1)/sqrt((2*pi)**(len(_mu))*det(_sigma))*exp(
105             -S(1)/2*(_mu - sym).transpose()*(_sigma.inv()*\
106                 (_mu - sym)))[0])
107 
108 #-------------------------------------------------------------------------------
109 # Multivariate Laplace distribution ---------------------------------------------------------
110 
111 class MultivariateLaplaceDistribution(JointDistribution):
112     _argnames = ['mu', 'sigma']
113     is_Continuous=True
114 
115     @property
116     def set(self):
117         k = len(self.mu)
118         return S.Reals**k
119 
120     def check(self, mu, sigma):
121         _value_check(len(mu) == len(sigma.col(0)),
122             "Size of the mean vector and covariance matrix are incorrect.")
123         #check if covariance matrix is positive definite or not.
124         _value_check((i > 0 for i in sigma.eigenvals().keys()),
125             "The covariance matrix must be positive definite. ")
126 
127     def pdf(self, *args):
128         mu, sigma = self.mu, self.sigma
129         mu_T = mu.transpose()
130         k = S(len(mu))
131         sigma_inv = sigma.inv()
132         args = ImmutableMatrix(args)
133         args_T = args.transpose()
134         x = (mu_T*sigma_inv*mu)[0]
135         y = (args_T*sigma_inv*args)[0]
136         v = 1 - k/2
137         return S(2)/((2*pi)**(S(k)/2)*sqrt(det(sigma)))\
138         *(y/(2 + x))**(S(v)/2)*besselk(v, sqrt((2 + x)*(y)))\
139         *exp((args_T*sigma_inv*mu)[0])
140 
141 
142 #-------------------------------------------------------------------------------
143 # Multivariate StudentT distribution ---------------------------------------------------------
144 
145 class MultivariateTDistribution(JointDistribution):
146     _argnames = ['mu', 'shape_mat', 'dof']
147     is_Continuous=True
148 
149     @property
150     def set(self):
151         k = len(self.mu)
152         return S.Reals**k
153 
154     def check(self, mu, sigma, v):
155         _value_check(len(mu) == len(sigma.col(0)),
156             "Size of the location vector and shape matrix are incorrect.")
157         #check if covariance matrix is positive definite or not.
158         _value_check((i > 0 for i in sigma.eigenvals().keys()),
159             "The shape matrix must be positive definite. ")
160 
161     def pdf(self, *args):
162         mu, sigma = self.mu, self.shape_mat
163         v = S(self.dof)
164         k = S(len(mu))
165         sigma_inv = sigma.inv()
166         args = ImmutableMatrix(args)
167         x = args - mu
168         return gamma((k + v)/2)/(gamma(v/2)*(v*pi)**(k/2)*sqrt(det(sigma)))\
169         *(1 + 1/v*(x.transpose()*sigma_inv*x)[0])**((-v - k)/2)
170 
171 def MultivariateT(syms, mu, sigma, v):
172     """
173     Creates a joint random variable with multivariate T-distribution.
174 
175     Parameters
176     ==========
177 
178     syms: list/tuple/set of symbols for identifying each component
179     mu: A list/tuple/set consisting of k means,represents a k
180         dimensional location vector
181     sigma: The shape matrix for the distribution
182 
183     Returns
184     =======
185 
186     A random symbol
187     """
188     return multivariate_rv(MultivariateTDistribution, syms, mu, sigma, v)
189 
190 
191 #-------------------------------------------------------------------------------
192 # Multivariate Normal Gamma distribution ---------------------------------------------------------
193 
194 class NormalGammaDistribution(JointDistribution):
195 
196     _argnames = ['mu', 'lamda', 'alpha', 'beta']
197     is_Continuous=True
198 
199     def check(self, mu, lamda, alpha, beta):
200         _value_check(mu.is_real, "Location must be real.")
201         _value_check(lamda > 0, "Lambda must be positive")
202         _value_check(alpha > 0, "alpha must be positive")
203         _value_check(beta > 0, "beta must be positive")
204 
205     @property
206     def set(self):
207         return S.Reals*Interval(0, S.Infinity)
208 
209     def pdf(self, x, tau):
210         beta, alpha, lamda = self.beta, self.alpha, self.lamda
211         mu = self.mu
212 
213         return beta**alpha*sqrt(lamda)/(gamma(alpha)*sqrt(2*pi))*\
214         tau**(alpha - S(1)/2)*exp(-1*beta*tau)*\
215         exp(-1*(lamda*tau*(x - mu)**2)/S(2))
216 
217     def marginal_distribution(self, indices, *sym):
218         if len(indices) == 2:
219             return self.pdf(*sym)
220         if indices[0] == 0:
221             #For marginal over `x`, return non-standardized Student-T's
222             #distribution
223             x = sym[0]
224             v, mu, sigma = self.alpha - S(1)/2, self.mu, \
225                 S(self.beta)/(self.lamda * self.alpha)
226             return Lambda(sym, gamma((v + 1)/2)/(gamma(v/2)*sqrt(pi*v)*sigma)*\
227                 (1 + 1/v*((x - mu)/sigma)**2)**((-v -1)/2))
228         #For marginal over `tau`, return Gamma distribution as per construction
229         from sympy.stats.crv_types import GammaDistribution
230         return Lambda(sym, GammaDistribution(self.alpha, self.beta)(sym[0]))
231 
232 def NormalGamma(syms, mu, lamda, alpha, beta):
233     """
234     Creates a bivariate joint random variable with multivariate Normal gamma
235     distribution.
236 
237     Parameters
238     ==========
239 
240     syms: list/tuple/set of two symbols for identifying each component
241     mu: A real number, as the mean of the normal distribution
242     alpha: a positive integer
243     beta: a positive integer
244     lamda: a positive integer
245 
246     Returns
247     =======
248 
249     A random symbol
250     """
251     return multivariate_rv(NormalGammaDistribution, syms, mu, lamda, alpha, beta)
252 
253 #-------------------------------------------------------------------------------
254 # Multivariate Beta/Dirichlet distribution ---------------------------------------------------------
255 
256 class MultivariateBetaDistribution(JointDistribution):
257 
258     _argnames = ['alpha']
259     is_Continuous = True
260 
261     def check(self, alpha):
262         _value_check(len(alpha) >= 2, "At least two categories should be passed.")
263         for a_k in alpha:
264             _value_check((a_k > 0) != False, "Each concentration parameter"
265                                             " should be positive.")
266 
267     @property
268     def set(self):
269         k = len(self.alpha)
270         return Interval(0, 1)**k
271 
272     def pdf(self, *syms):
273         alpha = self.alpha
274         B = Mul.fromiter(map(gamma, alpha))/gamma(Add(*alpha))
275         return Mul.fromiter([sym**(a_k - 1) for a_k, sym in zip(alpha, syms)])/B
276 
277 def MultivariateBeta(syms, *alpha):
278     """
279     Creates a continuous random variable with Dirichlet/Multivariate Beta
280     Distribution.
281 
282     The density of the dirichlet distribution can be found at [1].
283 
284     Parameters
285     ==========
286 
287     alpha: positive real numbers signifying concentration numbers.
288 
289     Returns
290     =======
291 
292     A RandomSymbol.
293 
294     Examples
295     ========
296 
297     >>> from sympy.stats import density
298     >>> from sympy.stats.joint_rv import marginal_distribution
299     >>> from sympy.stats.joint_rv_types import MultivariateBeta
300     >>> from sympy import Symbol
301     >>> a1 = Symbol('a1', positive=True)
302     >>> a2 = Symbol('a2', positive=True)
303     >>> B = MultivariateBeta('B', [a1, a2])
304     >>> C = MultivariateBeta('C', a1, a2)
305     >>> x = Symbol('x')
306     >>> y = Symbol('y')
307     >>> density(B)(x, y)
308     x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))
309     >>> marginal_distribution(C, C[0])(x)
310     x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))
311 
312     References
313     ==========
314 
315     .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution
316     .. [2] http://mathworld.wolfram.com/DirichletDistribution.html
317 
318     """
319     if not isinstance(alpha[0], list):
320         alpha = (list(alpha),)
321     return multivariate_rv(MultivariateBetaDistribution, syms, alpha[0])
322 
323 Dirichlet = MultivariateBeta
324 
325 #-------------------------------------------------------------------------------
326 # Multivariate Ewens distribution ---------------------------------------------------------
327 
328 class MultivariateEwensDistribution(JointDistribution):
329 
330     _argnames = ['n', 'theta']
331     is_Discrete = True
332     is_Continuous = False
333 
334     def check(self, n, theta):
335         _value_check(isinstance(n, Integer) and (n > 0) == True,
336                         "sample size should be positive integer.")
337         _value_check(theta.is_positive, "mutation rate should be positive.")
338 
339     @property
340     def set(self):
341         prod_set = Range(0, self.n//1 + 1)
342         for i in range(2, self.n + 1):
343             prod_set *= Range(0, self.n//i + 1)
344         return prod_set
345 
346     def pdf(self, *syms):
347         n, theta = self.n, self.theta
348         term_1 = factorial(n)/rf(theta, n)
349         term_2 = Mul.fromiter([theta**syms[j]/((j+1)**syms[j]*factorial(syms[j]))
350                             for j in range(n)])
351         cond = Eq(sum([(k+1)*syms[k] for k in range(n)]), n)
352         return Piecewise((term_1 * term_2, cond), (0, True))
353 
354 def MultivariateEwens(syms, n, theta):
355     """
356     Creates a discrete random variable with Multivariate Ewens
357     Distribution.
358 
359     The density of the said distribution can be found at [1].
360 
361     Parameters
362     ==========
363 
364     n: positive integer of class Integer,
365             size of the sample or the integer whose partitions are considered
366     theta: mutation rate, must be positive real number.
367 
368     Returns
369     =======
370 
371     A RandomSymbol.
372 
373     Examples
374     ========
375 
376     >>> from sympy.stats import density
377     >>> from sympy.stats.joint_rv import marginal_distribution
378     >>> from sympy.stats.joint_rv_types import MultivariateEwens
379     >>> from sympy import Symbol
380     >>> a1 = Symbol('a1', positive=True)
381     >>> a2 = Symbol('a2', positive=True)
382     >>> ed = MultivariateEwens('E', 2, 1)
383     >>> density(ed)(a1, a2)
384     Piecewise((2**(-a2)/(factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))
385     >>> marginal_distribution(ed, ed[0])(a1)
386     Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True))
387 
388     References
389     ==========
390 
391     .. [1] https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula
392     .. [2] http://www.stat.rutgers.edu/home/hcrane/Papers/STS529.pdf
393 
394     """
395     return multivariate_rv(MultivariateEwensDistribution, syms, n, theta)
396 
397 #-------------------------------------------------------------------------------
398 # Multinomial distribution ---------------------------------------------------------
399 
400 class MultinomialDistribution(JointDistribution):
401 
402     _argnames = ['n', 'p']
403     is_Continuous=False
404     is_Discrete = True
405 
406     def check(self, n, p):
407         _value_check(n > 0,
408                         "number of trials must be a positve integer")
409         for p_k in p:
410             _value_check((p_k >= 0, p_k <= 1),
411                         "probability must be in range [0, 1]")
412         _value_check(Eq(sum(p), 1),
413                         "probabilities must sum to 1")
414 
415     @property
416     def set(self):
417         return Intersection(S.Naturals0, Interval(0, self.n))**len(self.p)
418 
419     def pdf(self, *x):
420         n, p = self.n, self.p
421         term_1 = factorial(n)/Mul.fromiter([factorial(x_k) for x_k in x])
422         term_2 = Mul.fromiter([p_k**x_k for p_k, x_k in zip(p, x)])
423         return Piecewise((term_1 * term_2, Eq(sum(x), n)), (0, True))
424 
425 def Multinomial(syms, n, *p):
426     """
427     Creates a discrete random variable with Multinomial Distribution.
428 
429     The density of the said distribution can be found at [1].
430 
431     Parameters
432     ==========
433     n: positive integer of class Integer,
434        number of trials
435     p: event probabilites, >= 0 and <= 1
436 
437     Returns
438     =======
439     A RandomSymbol.
440 
441     Examples
442     ========
443     >>> from sympy.stats import density
444     >>> from sympy.stats.joint_rv import marginal_distribution
445     >>> from sympy.stats.joint_rv_types import Multinomial
446     >>> from sympy import symbols
447     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
448     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
449     >>> M = Multinomial('M', 3, p1, p2, p3)
450     >>> density(M)(x1, x2, x3)
451     Piecewise((6*p1**x1*p2**x2*p3**x3/(factorial(x1)*factorial(x2)*factorial(x3)),
452     Eq(x1 + x2 + x3, 3)), (0, True))
453     >>> marginal_distribution(M, M[0])(x1).subs(x1, 1)
454     3*p1*p2**2 + 6*p1*p2*p3 + 3*p1*p3**2
455 
456     References
457     ==========
458     .. [1] https://en.wikipedia.org/wiki/Multinomial_distribution
459     .. [2] http://mathworld.wolfram.com/MultinomialDistribution.html
460     """
461     if not isinstance(p[0], list):
462         p = (list(p), )
463     return multivariate_rv(MultinomialDistribution, syms, n, p[0])
464 
465 #-------------------------------------------------------------------------------
466 # Negative Multinomial Distribution ---------------------------------------------------------
467 
468 class NegativeMultinomialDistribution(JointDistribution):
469 
470     _argnames = ['k0', 'p']
471     is_Continuous=False
472     is_Discrete = True
473 
474     def check(self, k0, p):
475         _value_check(k0 > 0,
476                         "number of failures must be a positve integer")
477         for p_k in p:
478             _value_check((p_k >= 0, p_k <= 1),
479                         "probability must be in range [0, 1].")
480         _value_check(sum(p) <= 1,
481                         "success probabilities must not be greater than 1.")
482 
483     @property
484     def set(self):
485         return Range(0, S.Infinity)**len(self.p)
486 
487     def pdf(self, *k):
488         k0, p = self.k0, self.p
489         term_1 = (gamma(k0 + sum(k))*(1 - sum(p))**k0)/gamma(k0)
490         term_2 = Mul.fromiter([pi**ki/factorial(ki) for pi, ki in zip(p, k)])
491         return term_1 * term_2
492 
493 def NegativeMultinomial(syms, k0, *p):
494     """
495     Creates a discrete random variable with Negative Multinomial Distribution.
496 
497     The density of the said distribution can be found at [1].
498 
499     Parameters
500     ==========
501     k0: positive integer of class Integer,
502         number of failures before the experiment is stopped
503     p: event probabilites, >= 0 and <= 1
504 
505     Returns
506     =======
507     A RandomSymbol.
508 
509     Examples
510     ========
511     >>> from sympy.stats import density
512     >>> from sympy.stats.joint_rv import marginal_distribution
513     >>> from sympy.stats.joint_rv_types import NegativeMultinomial
514     >>> from sympy import symbols
515     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
516     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
517     >>> N = NegativeMultinomial('M', 3, p1, p2, p3)
518     >>> N_c = NegativeMultinomial('M', 3, 0.1, 0.1, 0.1)
519     >>> density(N)(x1, x2, x3)
520     p1**x1*p2**x2*p3**x3*(-p1 - p2 - p3 + 1)**3*gamma(x1 + x2 +
521     x3 + 3)/(2*factorial(x1)*factorial(x2)*factorial(x3))
522     >>> marginal_distribution(N_c, N_c[0])(1).evalf().round(2)
523     0.25
524 
525 
526     References
527     ==========
528     .. [1] https://en.wikipedia.org/wiki/Negative_multinomial_distribution
529     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
530     """
531     if not isinstance(p[0], list):
532         p = (list(p), )
533     return multivariate_rv(NegativeMultinomialDistribution, syms, k0, p[0])

</code><intended_behavior>Validate parameters considering their interactions within the joint distributions. This might involve more complex checks to ensure that the parameters of one distribution are compatible with the parameters of another within a joint distribution. Implementation of attributes that clarify these relationships and their constraints is also necessary.</intended_behavior>, <file>sympy/stats/frv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Finite Discrete Random Variables - Prebuilt variable types
3 
4 Contains
5 ========
6 FiniteRV
7 DiscreteUniform
8 Die
9 Bernoulli
10 Coin
11 Binomial
12 Hypergeometric
13 Rademacher
14 """
15 
16 from __future__ import print_function, division
17 
18 from sympy import (S, sympify, Rational, binomial, cacheit, Integer,
19         Dict, Basic, KroneckerDelta, Dummy, Eq)
20 from sympy.concrete.summations import Sum
21 from sympy.core.compatibility import as_int, range
22 from sympy.stats.rv import _value_check
23 from sympy.stats.frv import (SingleFinitePSpace, SingleFiniteDistribution)
24 
25 __all__ = ['FiniteRV',
26 'DiscreteUniform',
27 'Die',
28 'Bernoulli',
29 'Coin',
30 'Binomial',
31 'Hypergeometric',
32 'Rademacher'
33 ]
34 
35 def rv(name, cls, *args):
36     args = list(map(sympify, args))
37     i = 0
38     while i < len(args): # Converting to Dict since dict is not hashable
39         if isinstance(args[i], dict):
40             args[i] = Dict(args[i])
41         i += 1
42     dist = cls(*args)
43     dist.check(*args)
44     return SingleFinitePSpace(name, dist).value
45 
46 class FiniteDistributionHandmade(SingleFiniteDistribution):
47     @property
48     def dict(self):
49         return self.args[0]
50 
51     @staticmethod
52     def check(density):
53         for p in density.values():
54             _value_check((p >= 0, p <= 1),
55                         "Probability at a point must be between 0 and 1.")
56         _value_check(Eq(sum(density.values()), 1), "Total Probability must be 1.")
57 
58 def FiniteRV(name, density):
59     """
60     Create a Finite Random Variable given a dict representing the density.
61 
62     Returns a RandomSymbol.
63 
64     >>> from sympy.stats import FiniteRV, P, E
65 
66     >>> density = {0: .1, 1: .2, 2: .3, 3: .4}
67     >>> X = FiniteRV('X', density)
68 
69     >>> E(X)
70     2.00000000000000
71     >>> P(X >= 2)
72     0.700000000000000
73     """
74     return rv(name, FiniteDistributionHandmade, density)
75 
76 class DiscreteUniformDistribution(SingleFiniteDistribution):
77     @property
78     def p(self):
79         return Rational(1, len(self.args))
80 
81     @property
82     @cacheit
83     def dict(self):
84         return dict((k, self.p) for k in self.set)
85 
86     @property
87     def set(self):
88         return self.args
89 
90     def pdf(self, x):
91         if x in self.args:
92             return self.p
93         else:
94             return S.Zero
95 
96 
97 def DiscreteUniform(name, items):
98     """
99     Create a Finite Random Variable representing a uniform distribution over
100     the input set.
101 
102     Returns a RandomSymbol.
103 
104     Examples
105     ========
106 
107     >>> from sympy.stats import DiscreteUniform, density
108     >>> from sympy import symbols
109 
110     >>> X = DiscreteUniform('X', symbols('a b c')) # equally likely over a, b, c
111     >>> density(X).dict
112     {a: 1/3, b: 1/3, c: 1/3}
113 
114     >>> Y = DiscreteUniform('Y', list(range(5))) # distribution over a range
115     >>> density(Y).dict
116     {0: 1/5, 1: 1/5, 2: 1/5, 3: 1/5, 4: 1/5}
117 
118     References
119     ==========
120 
121     .. [1] https://en.wikipedia.org/wiki/Discrete_uniform_distribution
122     .. [2] http://mathworld.wolfram.com/DiscreteUniformDistribution.html
123 
124     """
125     return rv(name, DiscreteUniformDistribution, *items)
126 
127 
128 class DieDistribution(SingleFiniteDistribution):
129     _argnames = ('sides',)
130 
131     @staticmethod
132     def check(sides):
133         _value_check((sides.is_positive, sides.is_integer),
134                     "number of sides must be a positive integer.")
135 
136     @property
137     @cacheit
138     def dict(self):
139         as_int(self.sides) # Check that self.sides can be converted to an integer
140         return super(DieDistribution, self).dict
141 
142     @property
143     def set(self):
144         return list(map(Integer, list(range(1, self.sides + 1))))
145 
146     def pdf(self, x):
147         x = sympify(x)
148         if x.is_number:
149             if x.is_Integer and x >= 1 and x <= self.sides:
150                 return Rational(1, self.sides)
151             return S.Zero
152         if x.is_Symbol:
153             i = Dummy('i', integer=True, positive=True)
154             return Sum(KroneckerDelta(x, i)/self.sides, (i, 1, self.sides))
155         raise ValueError("'x' expected as an argument of type 'number' or 'symbol', "
156                         "not %s" % (type(x)))
157 
158 
159 def Die(name, sides=6):
160     """
161     Create a Finite Random Variable representing a fair die.
162 
163     Returns a RandomSymbol.
164 
165     Examples
166     ========
167 
168     >>> from sympy.stats import Die, density
169 
170     >>> D6 = Die('D6', 6) # Six sided Die
171     >>> density(D6).dict
172     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}
173 
174     >>> D4 = Die('D4', 4) # Four sided Die
175     >>> density(D4).dict
176     {1: 1/4, 2: 1/4, 3: 1/4, 4: 1/4}
177     """
178 
179     return rv(name, DieDistribution, sides)
180 
181 
182 class BernoulliDistribution(SingleFiniteDistribution):
183     _argnames = ('p', 'succ', 'fail')
184 
185     @staticmethod
186     def check(p, succ, fail):
187         _value_check((p >= 0, p <= 1),
188                     "p should be in range [0, 1].")
189 
190     @property
191     @cacheit
192     def dict(self):
193         return {self.succ: self.p, self.fail: 1 - self.p}
194 
195 
196 def Bernoulli(name, p, succ=1, fail=0):
197     """
198     Create a Finite Random Variable representing a Bernoulli process.
199 
200     Returns a RandomSymbol
201 
202     Examples
203     ========
204 
205     >>> from sympy.stats import Bernoulli, density
206     >>> from sympy import S
207 
208     >>> X = Bernoulli('X', S(3)/4) # 1-0 Bernoulli variable, probability = 3/4
209     >>> density(X).dict
210     {0: 1/4, 1: 3/4}
211 
212     >>> X = Bernoulli('X', S.Half, 'Heads', 'Tails') # A fair coin toss
213     >>> density(X).dict
214     {Heads: 1/2, Tails: 1/2}
215 
216     References
217     ==========
218 
219     .. [1] https://en.wikipedia.org/wiki/Bernoulli_distribution
220     .. [2] http://mathworld.wolfram.com/BernoulliDistribution.html
221 
222     """
223 
224     return rv(name, BernoulliDistribution, p, succ, fail)
225 
226 
227 def Coin(name, p=S.Half):
228     """
229     Create a Finite Random Variable representing a Coin toss.
230 
231     Probability p is the chance of gettings "Heads." Half by default
232 
233     Returns a RandomSymbol.
234 
235     Examples
236     ========
237 
238     >>> from sympy.stats import Coin, density
239     >>> from sympy import Rational
240 
241     >>> C = Coin('C') # A fair coin toss
242     >>> density(C).dict
243     {H: 1/2, T: 1/2}
244 
245     >>> C2 = Coin('C2', Rational(3, 5)) # An unfair coin
246     >>> density(C2).dict
247     {H: 3/5, T: 2/5}
248 
249     See Also
250     ========
251 
252     sympy.stats.Binomial
253 
254     References
255     ==========
256 
257     .. [1] https://en.wikipedia.org/wiki/Coin_flipping
258 
259     """
260     return rv(name, BernoulliDistribution, p, 'H', 'T')
261 
262 
263 class BinomialDistribution(SingleFiniteDistribution):
264     _argnames = ('n', 'p', 'succ', 'fail')
265 
266     @staticmethod
267     def check(n, p, succ, fail):
268         _value_check((n.is_integer, n.is_nonnegative),
269                     "'n' must be nonnegative integer.")
270         _value_check((p <= 1, p >= 0),
271                     "p should be in range [0, 1].")
272 
273     @property
274     @cacheit
275     def dict(self):
276         n, p, succ, fail = self.n, self.p, self.succ, self.fail
277         n = as_int(n)
278         return dict((k*succ + (n - k)*fail,
279                 binomial(n, k) * p**k * (1 - p)**(n - k)) for k in range(0, n + 1))
280 
281 
282 def Binomial(name, n, p, succ=1, fail=0):
283     """
284     Create a Finite Random Variable representing a binomial distribution.
285 
286     Returns a RandomSymbol.
287 
288     Examples
289     ========
290 
291     >>> from sympy.stats import Binomial, density
292     >>> from sympy import S
293 
294     >>> X = Binomial('X', 4, S.Half) # Four "coin flips"
295     >>> density(X).dict
296     {0: 1/16, 1: 1/4, 2: 3/8, 3: 1/4, 4: 1/16}
297 
298     References
299     ==========
300 
301     .. [1] https://en.wikipedia.org/wiki/Binomial_distribution
302     .. [2] http://mathworld.wolfram.com/BinomialDistribution.html
303 
304     """
305 
306     return rv(name, BinomialDistribution, n, p, succ, fail)
307 
308 
309 class HypergeometricDistribution(SingleFiniteDistribution):
310     _argnames = ('N', 'm', 'n')
311 
312     @property
313     @cacheit
314     def dict(self):
315         N, m, n = self.N, self.m, self.n
316         N, m, n = list(map(sympify, (N, m, n)))
317         density = dict((sympify(k),
318                         Rational(binomial(m, k) * binomial(N - m, n - k),
319                                  binomial(N, n)))
320                         for k in range(max(0, n + m - N), min(m, n) + 1))
321         return density
322 
323 
324 def Hypergeometric(name, N, m, n):
325     """
326     Create a Finite Random Variable representing a hypergeometric distribution.
327 
328     Returns a RandomSymbol.
329 
330     Examples
331     ========
332 
333     >>> from sympy.stats import Hypergeometric, density
334     >>> from sympy import S
335 
336     >>> X = Hypergeometric('X', 10, 5, 3) # 10 marbles, 5 white (success), 3 draws
337     >>> density(X).dict
338     {0: 1/12, 1: 5/12, 2: 5/12, 3: 1/12}
339 
340     References
341     ==========
342 
343     .. [1] https://en.wikipedia.org/wiki/Hypergeometric_distribution
344     .. [2] http://mathworld.wolfram.com/HypergeometricDistribution.html
345 
346     """
347     return rv(name, HypergeometricDistribution, N, m, n)
348 
349 
350 class RademacherDistribution(SingleFiniteDistribution):
351     @property
352     @cacheit
353     def dict(self):
354         return {-1: S.Half, 1: S.Half}
355 
356 
357 def Rademacher(name):
358     """
359     Create a Finite Random Variable representing a Rademacher distribution.
360 
361     Return a RandomSymbol.
362 
363     Examples
364     ========
365 
366     >>> from sympy.stats import Rademacher, density
367 
368     >>> X = Rademacher('X')
369     >>> density(X).dict
370     {-1: 1/2, 1: 1/2}
371 
372     See Also
373     ========
374 
375     sympy.stats.Bernoulli
376 
377     References
378     ==========
379 
380     .. [1] https://en.wikipedia.org/wiki/Rademacher_distribution
381 
382     """
383     return rv(name, RademacherDistribution)

</code><intended_behavior>Ensure completeness in parameter checking, especially since finite distributions might have specific constraints on their parameters. Attributes related to these distributions should be clear and follow consistent patterns as in other distribution types.</intended_behavior>]
2025-10-18 20:15:11.283 | INFO     | Search completed. Bug locations: [<file>sympy/stats/crv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Continuous Random Variables - Prebuilt variables
3 
4 Contains
5 ========
6 Arcsin
7 Benini
8 Beta
9 BetaNoncentral
10 BetaPrime
11 Cauchy
12 Chi
13 ChiNoncentral
14 ChiSquared
15 Dagum
16 Erlang
17 Exponential
18 FDistribution
19 FisherZ
20 Frechet
21 Gamma
22 GammaInverse
23 Gumbel
24 Gompertz
25 Kumaraswamy
26 Laplace
27 Logistic
28 LogNormal
29 Maxwell
30 Nakagami
31 Normal
32 Pareto
33 QuadraticU
34 RaisedCosine
35 Rayleigh
36 ShiftedGompertz
37 StudentT
38 Trapezoidal
39 Triangular
40 Uniform
41 UniformSum
42 VonMises
43 Weibull
44 WignerSemicircle
45 """
46 
47 from __future__ import print_function, division
48 
49 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma,
50                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,
51                    Lambda, Basic, lowergamma, erf, erfi,  erfinv, I, hyper,
52                    uppergamma, sinh, atan, Ne, expint)
53 
54 from sympy import beta as beta_fn
55 from sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk
56 from sympy.external import import_module
57 from sympy.matrices import MatrixBase
58 from sympy.stats.crv import (SingleContinuousPSpace, SingleContinuousDistribution,
59         ContinuousDistributionHandmade)
60 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
61 from sympy.stats.joint_rv_types import multivariate_rv
62 from sympy.stats.rv import _value_check, RandomSymbol
63 import random
64 
65 oo = S.Infinity
66 
67 __all__ = ['ContinuousRV',
68 'Arcsin',
69 'Benini',
70 'Beta',
71 'BetaNoncentral',
72 'BetaPrime',
73 'Cauchy',
74 'Chi',
75 'ChiNoncentral',
76 'ChiSquared',
77 'Dagum',
78 'Erlang',
79 'Exponential',
80 'FDistribution',
81 'FisherZ',
82 'Frechet',
83 'Gamma',
84 'GammaInverse',
85 'Gompertz',
86 'Gumbel',
87 'Kumaraswamy',
88 'Laplace',
89 'Logistic',
90 'LogNormal',
91 'Maxwell',
92 'Nakagami',
93 'Normal',
94 'Pareto',
95 'QuadraticU',
96 'RaisedCosine',
97 'Rayleigh',
98 'StudentT',
99 'ShiftedGompertz',
100 'Trapezoidal',
101 'Triangular',
102 'Uniform',
103 'UniformSum',
104 'VonMises',
105 'Weibull',
106 'WignerSemicircle'
107 ]
108 
109 
110 
111 def ContinuousRV(symbol, density, set=Interval(-oo, oo)):
112     """
113     Create a Continuous Random Variable given the following:
114 
115     -- a symbol
116     -- a probability density function
117     -- set on which the pdf is valid (defaults to entire real line)
118 
119     Returns a RandomSymbol.
120 
121     Many common continuous random variable types are already implemented.
122     This function should be necessary only very rarely.
123 
124     Examples
125     ========
126 
127     >>> from sympy import Symbol, sqrt, exp, pi
128     >>> from sympy.stats import ContinuousRV, P, E
129 
130     >>> x = Symbol("x")
131 
132     >>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution
133     >>> X = ContinuousRV(x, pdf)
134 
135     >>> E(X)
136     0
137     >>> P(X>0)
138     1/2
139     """
140     pdf = Piecewise((density, set.as_relational(symbol)), (0, True))
141     pdf = Lambda(symbol, pdf)
142     dist = ContinuousDistributionHandmade(pdf, set)
143     return SingleContinuousPSpace(symbol, dist).value
144 
145 
146 def rv(symbol, cls, args):
147     args = list(map(sympify, args))
148     dist = cls(*args)
149     dist.check(*args)
150     pspace = SingleContinuousPSpace(symbol, dist)
151     if any(isinstance(arg, RandomSymbol) for arg in args):
152         pspace = JointPSpace(symbol, CompoundDistribution(dist))
153     return pspace.value
154 
155 ########################################
156 # Continuous Probability Distributions #
157 ########################################
158 
159 #-------------------------------------------------------------------------------
160 # Arcsin distribution ----------------------------------------------------------
161 
162 
163 class ArcsinDistribution(SingleContinuousDistribution):
164     _argnames = ('a', 'b')
165 
166     def pdf(self, x):
167         return 1/(pi*sqrt((x - self.a)*(self.b - x)))
168 
169     def _cdf(self, x):
170         from sympy import asin
171         a, b = self.a, self.b
172         return Piecewise(
173             (S.Zero, x < a),
174             (2*asin(sqrt((x - a)/(b - a)))/pi, x <= b),
175             (S.One, True))
176 
177 
178 def Arcsin(name, a=0, b=1):
179     r"""
180     Create a Continuous Random Variable with an arcsin distribution.
181 
182     The density of the arcsin distribution is given by
183 
184     .. math::
185         f(x) := \frac{1}{\pi\sqrt{(x-a)(b-x)}}
186 
187     with :math:`x \in (a,b)`. It must hold that :math:`-\infty < a < b < \infty`.
188 
189     Parameters
190     ==========
191 
192     a : Real number, the left interval boundary
193     b : Real number, the right interval boundary
194 
195     Returns
196     =======
197 
198     A RandomSymbol.
199 
200     Examples
201     ========
202 
203     >>> from sympy.stats import Arcsin, density, cdf
204     >>> from sympy import Symbol, simplify
205 
206     >>> a = Symbol("a", real=True)
207     >>> b = Symbol("b", real=True)
208     >>> z = Symbol("z")
209 
210     >>> X = Arcsin("x", a, b)
211 
212     >>> density(X)(z)
213     1/(pi*sqrt((-a + z)*(b - z)))
214 
215     >>> cdf(X)(z)
216     Piecewise((0, a > z),
217             (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),
218             (1, True))
219 
220 
221     References
222     ==========
223 
224     .. [1] https://en.wikipedia.org/wiki/Arcsine_distribution
225 
226     """
227 
228     return rv(name, ArcsinDistribution, (a, b))
229 
230 #-------------------------------------------------------------------------------
231 # Benini distribution ----------------------------------------------------------
232 
233 
234 class BeniniDistribution(SingleContinuousDistribution):
235     _argnames = ('alpha', 'beta', 'sigma')
236 
237     @staticmethod
238     def check(alpha, beta, sigma):
239         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
240         _value_check(beta > 0, "Shape parameter Beta must be positive.")
241         _value_check(sigma > 0, "Scale parameter Sigma must be positive.")
242 
243     @property
244     def set(self):
245         return Interval(self.sigma, oo)
246 
247     def pdf(self, x):
248         alpha, beta, sigma = self.alpha, self.beta, self.sigma
249         return (exp(-alpha*log(x/sigma) - beta*log(x/sigma)**2)
250                *(alpha/x + 2*beta*log(x/sigma)/x))
251 
252     def _moment_generating_function(self, t):
253         raise NotImplementedError('The moment generating function of the '
254                                   'Benini distribution does not exist.')
255 
256 def Benini(name, alpha, beta, sigma):
257     r"""
258     Create a Continuous Random Variable with a Benini distribution.
259 
260     The density of the Benini distribution is given by
261 
262     .. math::
263         f(x) := e^{-\alpha\log{\frac{x}{\sigma}}
264                 -\beta\log^2\left[{\frac{x}{\sigma}}\right]}
265                 \left(\frac{\alpha}{x}+\frac{2\beta\log{\frac{x}{\sigma}}}{x}\right)
266 
267     This is a heavy-tailed distrubtion and is also known as the log-Rayleigh
268     distribution.
269 
270     Parameters
271     ==========
272 
273     alpha : Real number, `\alpha > 0`, a shape
274     beta : Real number, `\beta > 0`, a shape
275     sigma : Real number, `\sigma > 0`, a scale
276 
277     Returns
278     =======
279 
280     A RandomSymbol.
281 
282     Examples
283     ========
284 
285     >>> from sympy.stats import Benini, density, cdf
286     >>> from sympy import Symbol, simplify, pprint
287 
288     >>> alpha = Symbol("alpha", positive=True)
289     >>> beta = Symbol("beta", positive=True)
290     >>> sigma = Symbol("sigma", positive=True)
291     >>> z = Symbol("z")
292 
293     >>> X = Benini("x", alpha, beta, sigma)
294 
295     >>> D = density(X)(z)
296     >>> pprint(D, use_unicode=False)
297     /                  /  z  \\             /  z  \            2/  z  \
298     |        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|
299     |alpha             \sigma/|             \sigma/             \sigma/
300     |----- + -----------------|*e
301     \  z             z        /
302 
303     >>> cdf(X)(z)
304     Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),
305             (0, True))
306 
307 
308     References
309     ==========
310 
311     .. [1] https://en.wikipedia.org/wiki/Benini_distribution
312     .. [2] http://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html
313 
314     """
315 
316     return rv(name, BeniniDistribution, (alpha, beta, sigma))
317 
318 #-------------------------------------------------------------------------------
319 # Beta distribution ------------------------------------------------------------
320 
321 
322 class BetaDistribution(SingleContinuousDistribution):
323     _argnames = ('alpha', 'beta')
324 
325     set = Interval(0, 1)
326 
327     @staticmethod
328     def check(alpha, beta):
329         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
330         _value_check(beta > 0, "Shape parameter Beta must be positive.")
331 
332     def pdf(self, x):
333         alpha, beta = self.alpha, self.beta
334         return x**(alpha - 1) * (1 - x)**(beta - 1) / beta_fn(alpha, beta)
335 
336     def sample(self):
337         return random.betavariate(self.alpha, self.beta)
338 
339     def _characteristic_function(self, t):
340         return hyper((self.alpha,), (self.alpha + self.beta,), I*t)
341 
342     def _moment_generating_function(self, t):
343         return hyper((self.alpha,), (self.alpha + self.beta,), t)
344 
345 def Beta(name, alpha, beta):
346     r"""
347     Create a Continuous Random Variable with a Beta distribution.
348 
349     The density of the Beta distribution is given by
350 
351     .. math::
352         f(x) := \frac{x^{\alpha-1}(1-x)^{\beta-1}} {\mathrm{B}(\alpha,\beta)}
353 
354     with :math:`x \in [0,1]`.
355 
356     Parameters
357     ==========
358 
359     alpha : Real number, `\alpha > 0`, a shape
360     beta : Real number, `\beta > 0`, a shape
361 
362     Returns
363     =======
364 
365     A RandomSymbol.
366 
367     Examples
368     ========
369 
370     >>> from sympy.stats import Beta, density, E, variance
371     >>> from sympy import Symbol, simplify, pprint, factor
372 
373     >>> alpha = Symbol("alpha", positive=True)
374     >>> beta = Symbol("beta", positive=True)
375     >>> z = Symbol("z")
376 
377     >>> X = Beta("x", alpha, beta)
378 
379     >>> D = density(X)(z)
380     >>> pprint(D, use_unicode=False)
381      alpha - 1        beta - 1
382     z         *(1 - z)
383     --------------------------
384           B(alpha, beta)
385 
386     >>> simplify(E(X))
387     alpha/(alpha + beta)
388 
389     >>> factor(simplify(variance(X)))  #doctest: +SKIP
390     alpha*beta/((alpha + beta)**2*(alpha + beta + 1))
391 
392     References
393     ==========
394 
395     .. [1] https://en.wikipedia.org/wiki/Beta_distribution
396     .. [2] http://mathworld.wolfram.com/BetaDistribution.html
397 
398     """
399 
400     return rv(name, BetaDistribution, (alpha, beta))
401 
402 #-------------------------------------------------------------------------------
403 # Noncentral Beta distribution ------------------------------------------------------------
404 
405 
406 class BetaNoncentralDistribution(SingleContinuousDistribution):
407     _argnames = ('alpha', 'beta', 'lamda')
408 
409     set = Interval(0, 1)
410 
411     @staticmethod
412     def check(alpha, beta, lamda):
413         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
414         _value_check(beta > 0, "Shape parameter Beta must be positive.")
415         _value_check(lamda >= 0, "Noncentrality parameter Lambda must be positive")
416 
417     def pdf(self, x):
418         alpha, beta, lamda = self.alpha, self.beta, self.lamda
419         k = Dummy("k")
420         return Sum(exp(-lamda / 2) * (lamda / 2)**k * x**(alpha + k - 1) *(
421             1 - x)**(beta - 1) / (factorial(k) * beta_fn(alpha + k, beta)), (k, 0, oo))
422 
423 def BetaNoncentral(name, alpha, beta, lamda):
424     r"""
425     Create a Continuous Random Variable with a Type I Noncentral Beta distribution.
426 
427     The density of the Noncentral Beta distribution is given by
428 
429     .. math::
430         f(x) := \sum_{k=0}^\infty e^{-\lambda/2}\frac{(\lambda/2)^k}{k!}
431                 \frac{x^{\alpha+k-1}(1-x)^{\beta-1}}{\mathrm{B}(\alpha+k,\beta)}
432 
433     with :math:`x \in [0,1]`.
434 
435     Parameters
436     ==========
437 
438     alpha : Real number, `\alpha > 0`, a shape
439     beta : Real number, `\beta > 0`, a shape
440     lamda: Real number, `\lambda >= 0`, noncentrality parameter
441 
442     Returns
443     =======
444 
445     A RandomSymbol.
446 
447     Examples
448     ========
449 
450     >>> from sympy.stats import BetaNoncentral, density, cdf
451     >>> from sympy import Symbol, pprint
452 
453     >>> alpha = Symbol("alpha", positive=True)
454     >>> beta = Symbol("beta", positive=True)
455     >>> lamda = Symbol("lamda", nonnegative=True)
456     >>> z = Symbol("z")
457 
458     >>> X = BetaNoncentral("x", alpha, beta, lamda)
459 
460     >>> D = density(X)(z)
461     >>> pprint(D, use_unicode=False)
462       oo
463     _____
464     \    `
465      \                                              -lamda
466       \                          k                  -------
467        \    k + alpha - 1 /lamda\         beta - 1     2
468         )  z             *|-----| *(1 - z)        *e
469        /                  \  2  /
470       /    ------------------------------------------------
471      /                  B(k + alpha, beta)*k!
472     /____,
473     k = 0
474 
475     Compute cdf with specific 'x', 'alpha', 'beta' and 'lamda' values as follows :
476     >>> cdf(BetaNoncentral("x", 1, 1, 1), evaluate=False)(2).doit()
477     exp(-1/2)*Integral(Sum(2**(-_k)*_x**_k/(beta(_k + 1, 1)*factorial(_k)), (_k, 0, oo)), (_x, 0, 2))
478 
479     The argument evaluate=False prevents an attempt at evaluation
480     of the sum for general x, before the argument 2 is passed.
481 
482     References
483     ==========
484 
485     .. [1] https://en.wikipedia.org/wiki/Noncentral_beta_distribution
486     .. [2] https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html
487 
488     """
489 
490     return rv(name, BetaNoncentralDistribution, (alpha, beta, lamda))
491 
492 
493 #-------------------------------------------------------------------------------
494 # Beta prime distribution ------------------------------------------------------
495 
496 
497 class BetaPrimeDistribution(SingleContinuousDistribution):
498     _argnames = ('alpha', 'beta')
499 
500     @staticmethod
501     def check(alpha, beta):
502         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
503         _value_check(beta > 0, "Shape parameter Beta must be positive.")
504 
505     set = Interval(0, oo)
506 
507     def pdf(self, x):
508         alpha, beta = self.alpha, self.beta
509         return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)
510 
511 def BetaPrime(name, alpha, beta):
512     r"""
513     Create a continuous random variable with a Beta prime distribution.
514 
515     The density of the Beta prime distribution is given by
516 
517     .. math::
518         f(x) := \frac{x^{\alpha-1} (1+x)^{-\alpha -\beta}}{B(\alpha,\beta)}
519 
520     with :math:`x > 0`.
521 
522     Parameters
523     ==========
524 
525     alpha : Real number, `\alpha > 0`, a shape
526     beta : Real number, `\beta > 0`, a shape
527 
528     Returns
529     =======
530 
531     A RandomSymbol.
532 
533     Examples
534     ========
535 
536     >>> from sympy.stats import BetaPrime, density
537     >>> from sympy import Symbol, pprint
538 
539     >>> alpha = Symbol("alpha", positive=True)
540     >>> beta = Symbol("beta", positive=True)
541     >>> z = Symbol("z")
542 
543     >>> X = BetaPrime("x", alpha, beta)
544 
545     >>> D = density(X)(z)
546     >>> pprint(D, use_unicode=False)
547      alpha - 1        -alpha - beta
548     z         *(z + 1)
549     -------------------------------
550              B(alpha, beta)
551 
552     References
553     ==========
554 
555     .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution
556     .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html
557 
558     """
559 
560     return rv(name, BetaPrimeDistribution, (alpha, beta))
561 
562 #-------------------------------------------------------------------------------
563 # Cauchy distribution ----------------------------------------------------------
564 
565 
566 class CauchyDistribution(SingleContinuousDistribution):
567     _argnames = ('x0', 'gamma')
568 
569     @staticmethod
570     def check(x0, gamma):
571         _value_check(gamma > 0, "Scale parameter Gamma must be positive.")
572 
573     def pdf(self, x):
574         return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))
575 
576     def _cdf(self, x):
577         x0, gamma = self.x0, self.gamma
578         return (1/pi)*atan((x - x0)/gamma) + S.Half
579 
580     def _characteristic_function(self, t):
581         return exp(self.x0 * I * t -  self.gamma * Abs(t))
582 
583     def _moment_generating_function(self, t):
584         raise NotImplementedError("The moment generating function for the "
585                                   "Cauchy distribution does not exist.")
586 
587     def _quantile(self, p):
588         return self.x0 + self.gamma*tan(pi*(p - S.Half))
589 
590 def Cauchy(name, x0, gamma):
591     r"""
592     Create a continuous random variable with a Cauchy distribution.
593 
594     The density of the Cauchy distribution is given by
595 
596     .. math::
597         f(x) := \frac{1}{\pi \gamma [1 + {(\frac{x-x_0}{\gamma})}^2]}
598 
599     Parameters
600     ==========
601 
602     x0 : Real number, the location
603     gamma : Real number, `\gamma > 0`, a scale
604 
605     Returns
606     =======
607 
608     A RandomSymbol.
609 
610     Examples
611     ========
612 
613     >>> from sympy.stats import Cauchy, density
614     >>> from sympy import Symbol
615 
616     >>> x0 = Symbol("x0")
617     >>> gamma = Symbol("gamma", positive=True)
618     >>> z = Symbol("z")
619 
620     >>> X = Cauchy("x", x0, gamma)
621 
622     >>> density(X)(z)
623     1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2))
624 
625     References
626     ==========
627 
628     .. [1] https://en.wikipedia.org/wiki/Cauchy_distribution
629     .. [2] http://mathworld.wolfram.com/CauchyDistribution.html
630 
631     """
632 
633     return rv(name, CauchyDistribution, (x0, gamma))
634 
635 #-------------------------------------------------------------------------------
636 # Chi distribution -------------------------------------------------------------
637 
638 
639 class ChiDistribution(SingleContinuousDistribution):
640     _argnames = ('k',)
641 
642     @staticmethod
643     def check(k):
644         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
645         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
646 
647     set = Interval(0, oo)
648 
649     def pdf(self, x):
650         return 2**(1 - self.k/2)*x**(self.k - 1)*exp(-x**2/2)/gamma(self.k/2)
651 
652     def _characteristic_function(self, t):
653         k = self.k
654 
655         part_1 = hyper((k/2,), (S(1)/2,), -t**2/2)
656         part_2 = I*t*sqrt(2)*gamma((k+1)/2)/gamma(k/2)
657         part_3 = hyper(((k+1)/2,), (S(3)/2,), -t**2/2)
658         return part_1 + part_2*part_3
659 
660     def _moment_generating_function(self, t):
661         k = self.k
662 
663         part_1 = hyper((k / 2,), (S(1) / 2,), t ** 2 / 2)
664         part_2 = t * sqrt(2) * gamma((k + 1) / 2) / gamma(k / 2)
665         part_3 = hyper(((k + 1) / 2,), (S(3) / 2,), t ** 2 / 2)
666         return part_1 + part_2 * part_3
667 
668 def Chi(name, k):
669     r"""
670     Create a continuous random variable with a Chi distribution.
671 
672     The density of the Chi distribution is given by
673 
674     .. math::
675         f(x) := \frac{2^{1-k/2}x^{k-1}e^{-x^2/2}}{\Gamma(k/2)}
676 
677     with :math:`x \geq 0`.
678 
679     Parameters
680     ==========
681 
682     k : Positive integer, The number of degrees of freedom
683 
684     Returns
685     =======
686 
687     A RandomSymbol.
688 
689     Examples
690     ========
691 
692     >>> from sympy.stats import Chi, density, E
693     >>> from sympy import Symbol, simplify
694 
695     >>> k = Symbol("k", integer=True)
696     >>> z = Symbol("z")
697 
698     >>> X = Chi("x", k)
699 
700     >>> density(X)(z)
701     2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2)
702 
703     >>> simplify(E(X))
704     sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2)
705 
706     References
707     ==========
708 
709     .. [1] https://en.wikipedia.org/wiki/Chi_distribution
710     .. [2] http://mathworld.wolfram.com/ChiDistribution.html
711 
712     """
713 
714     return rv(name, ChiDistribution, (k,))
715 
716 #-------------------------------------------------------------------------------
717 # Non-central Chi distribution -------------------------------------------------
718 
719 
720 class ChiNoncentralDistribution(SingleContinuousDistribution):
721     _argnames = ('k', 'l')
722 
723     @staticmethod
724     def check(k, l):
725         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
726         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
727         _value_check(l > 0, "Shift parameter Lambda must be positive.")
728 
729     set = Interval(0, oo)
730 
731     def pdf(self, x):
732         k, l = self.k, self.l
733         return exp(-(x**2+l**2)/2)*x**k*l / (l*x)**(k/2) * besseli(k/2-1, l*x)
734 
735 def ChiNoncentral(name, k, l):
736     r"""
737     Create a continuous random variable with a non-central Chi distribution.
738 
739     The density of the non-central Chi distribution is given by
740 
741     .. math::
742         f(x) := \frac{e^{-(x^2+\lambda^2)/2} x^k\lambda}
743                 {(\lambda x)^{k/2}} I_{k/2-1}(\lambda x)
744 
745     with `x \geq 0`. Here, `I_\nu (x)` is the
746     :ref:`modified Bessel function of the first kind <besseli>`.
747 
748     Parameters
749     ==========
750 
751     k : A positive Integer, `k > 0`, the number of degrees of freedom
752     lambda : Real number, `\lambda > 0`, Shift parameter
753 
754     Returns
755     =======
756 
757     A RandomSymbol.
758 
759     Examples
760     ========
761 
762     >>> from sympy.stats import ChiNoncentral, density
763     >>> from sympy import Symbol
764 
765     >>> k = Symbol("k", integer=True)
766     >>> l = Symbol("l")
767     >>> z = Symbol("z")
768 
769     >>> X = ChiNoncentral("x", k, l)
770 
771     >>> density(X)(z)
772     l*z**k*(l*z)**(-k/2)*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)
773 
774     References
775     ==========
776 
777     .. [1] https://en.wikipedia.org/wiki/Noncentral_chi_distribution
778     """
779 
780     return rv(name, ChiNoncentralDistribution, (k, l))
781 
782 #-------------------------------------------------------------------------------
783 # Chi squared distribution -----------------------------------------------------
784 
785 
786 class ChiSquaredDistribution(SingleContinuousDistribution):
787     _argnames = ('k',)
788 
789     @staticmethod
790     def check(k):
791         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
792         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
793 
794     set = Interval(0, oo)
795 
796     def pdf(self, x):
797         k = self.k
798         return 1/(2**(k/2)*gamma(k/2))*x**(k/2 - 1)*exp(-x/2)
799 
800     def _cdf(self, x):
801         k = self.k
802         return Piecewise(
803                 (S.One/gamma(k/2)*lowergamma(k/2, x/2), x >= 0),
804                 (0, True)
805         )
806 
807     def _characteristic_function(self, t):
808         return (1 - 2*I*t)**(-self.k/2)
809 
810     def  _moment_generating_function(self, t):
811         return (1 - 2*t)**(-self.k/2)
812 
813 def ChiSquared(name, k):
814     r"""
815     Create a continuous random variable with a Chi-squared distribution.
816 
817     The density of the Chi-squared distribution is given by
818 
819     .. math::
820         f(x) := \frac{1}{2^{\frac{k}{2}}\Gamma\left(\frac{k}{2}\right)}
821                 x^{\frac{k}{2}-1} e^{-\frac{x}{2}}
822 
823     with :math:`x \geq 0`.
824 
825     Parameters
826     ==========
827 
828     k : Positive integer, The number of degrees of freedom
829 
830     Returns
831     =======
832 
833     A RandomSymbol.
834 
835     Examples
836     ========
837 
838     >>> from sympy.stats import ChiSquared, density, E, variance, moment
839     >>> from sympy import Symbol
840 
841     >>> k = Symbol("k", integer=True, positive=True)
842     >>> z = Symbol("z")
843 
844     >>> X = ChiSquared("x", k)
845 
846     >>> density(X)(z)
847     2**(-k/2)*z**(k/2 - 1)*exp(-z/2)/gamma(k/2)
848 
849     >>> E(X)
850     k
851 
852     >>> variance(X)
853     2*k
854 
855     >>> moment(X, 3)
856     k**3 + 6*k**2 + 8*k
857 
858     References
859     ==========
860 
861     .. [1] https://en.wikipedia.org/wiki/Chi_squared_distribution
862     .. [2] http://mathworld.wolfram.com/Chi-SquaredDistribution.html
863     """
864 
865     return rv(name, ChiSquaredDistribution, (k, ))
866 
867 #-------------------------------------------------------------------------------
868 # Dagum distribution -----------------------------------------------------------
869 
870 
871 class DagumDistribution(SingleContinuousDistribution):
872     _argnames = ('p', 'a', 'b')
873 
874     @staticmethod
875     def check(p, a, b):
876         _value_check(p > 0, "Shape parameter p must be positive.")
877         _value_check(a > 0, "Shape parameter a must be positive.")
878         _value_check(b > 0, "Scale parameter b must be positive.")
879 
880     def pdf(self, x):
881         p, a, b = self.p, self.a, self.b
882         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))
883 
884     def _cdf(self, x):
885         p, a, b = self.p, self.a, self.b
886         return Piecewise(((S.One + (S(x)/b)**-a)**-p, x>=0),
887                     (S.Zero, True))
888 
889 def Dagum(name, p, a, b):
890     r"""
891     Create a continuous random variable with a Dagum distribution.
892 
893     The density of the Dagum distribution is given by
894 
895     .. math::
896         f(x) := \frac{a p}{x} \left( \frac{\left(\tfrac{x}{b}\right)^{a p}}
897                 {\left(\left(\tfrac{x}{b}\right)^a + 1 \right)^{p+1}} \right)
898 
899     with :math:`x > 0`.
900 
901     Parameters
902     ==========
903 
904     p : Real number, `p > 0`, a shape
905     a : Real number, `a > 0`, a shape
906     b : Real number, `b > 0`, a scale
907 
908     Returns
909     =======
910 
911     A RandomSymbol.
912 
913     Examples
914     ========
915 
916     >>> from sympy.stats import Dagum, density, cdf
917     >>> from sympy import Symbol
918 
919     >>> p = Symbol("p", positive=True)
920     >>> a = Symbol("a", positive=True)
921     >>> b = Symbol("b", positive=True)
922     >>> z = Symbol("z")
923 
924     >>> X = Dagum("x", p, a, b)
925 
926     >>> density(X)(z)
927     a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z
928 
929     >>> cdf(X)(z)
930     Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True))
931 
932 
933     References
934     ==========
935 
936     .. [1] https://en.wikipedia.org/wiki/Dagum_distribution
937 
938     """
939 
940     return rv(name, DagumDistribution, (p, a, b))
941 
942 #-------------------------------------------------------------------------------
943 # Erlang distribution ----------------------------------------------------------
944 
945 
946 def Erlang(name, k, l):
947     r"""
948     Create a continuous random variable with an Erlang distribution.
949 
950     The density of the Erlang distribution is given by
951 
952     .. math::
953         f(x) := \frac{\lambda^k x^{k-1} e^{-\lambda x}}{(k-1)!}
954 
955     with :math:`x \in [0,\infty]`.
956 
957     Parameters
958     ==========
959 
960     k : Positive integer
961     l : Real number, `\lambda > 0`, the rate
962 
963     Returns
964     =======
965 
966     A RandomSymbol.
967 
968     Examples
969     ========
970 
971     >>> from sympy.stats import Erlang, density, cdf, E, variance
972     >>> from sympy import Symbol, simplify, pprint
973 
974     >>> k = Symbol("k", integer=True, positive=True)
975     >>> l = Symbol("l", positive=True)
976     >>> z = Symbol("z")
977 
978     >>> X = Erlang("x", k, l)
979 
980     >>> D = density(X)(z)
981     >>> pprint(D, use_unicode=False)
982      k  k - 1  -l*z
983     l *z     *e
984     ---------------
985         Gamma(k)
986 
987     >>> C = cdf(X)(z)
988     >>> pprint(C, use_unicode=False)
989     /lowergamma(k, l*z)
990     |------------------  for z > 0
991     <     Gamma(k)
992     |
993     \        0           otherwise
994 
995 
996     >>> E(X)
997     k/l
998 
999     >>> simplify(variance(X))
1000     k/l**2
1001 
1002     References
1003     ==========
1004 
1005     .. [1] https://en.wikipedia.org/wiki/Erlang_distribution
1006     .. [2] http://mathworld.wolfram.com/ErlangDistribution.html
1007 
1008     """
1009 
1010     return rv(name, GammaDistribution, (k, S.One/l))
1011 
1012 #-------------------------------------------------------------------------------
1013 # Exponential distribution -----------------------------------------------------
1014 
1015 
1016 class ExponentialDistribution(SingleContinuousDistribution):
1017     _argnames = ('rate',)
1018 
1019     set  = Interval(0, oo)
1020 
1021     @staticmethod
1022     def check(rate):
1023         _value_check(rate > 0, "Rate must be positive.")
1024 
1025     def pdf(self, x):
1026         return self.rate * exp(-self.rate*x)
1027 
1028     def sample(self):
1029         return random.expovariate(self.rate)
1030 
1031     def _cdf(self, x):
1032         return Piecewise(
1033                 (S.One - exp(-self.rate*x), x >= 0),
1034                 (0, True),
1035         )
1036 
1037     def _characteristic_function(self, t):
1038         rate = self.rate
1039         return rate / (rate - I*t)
1040 
1041     def _moment_generating_function(self, t):
1042         rate = self.rate
1043         return rate / (rate - t)
1044 
1045     def _quantile(self, p):
1046         return -log(1-p)/self.rate
1047 
1048 def Exponential(name, rate):
1049     r"""
1050     Create a continuous random variable with an Exponential distribution.
1051 
1052     The density of the exponential distribution is given by
1053 
1054     .. math::
1055         f(x) := \lambda \exp(-\lambda x)
1056 
1057     with `x > 0`. Note that the expected value is `1/\lambda`.
1058 
1059     Parameters
1060     ==========
1061 
1062     rate : A positive Real number, `\lambda > 0`, the rate (or inverse scale/inverse mean)
1063 
1064     Returns
1065     =======
1066 
1067     A RandomSymbol.
1068 
1069     Examples
1070     ========
1071 
1072     >>> from sympy.stats import Exponential, density, cdf, E
1073     >>> from sympy.stats import variance, std, skewness, quantile
1074     >>> from sympy import Symbol, symbols
1075 
1076     >>> l = Symbol("lambda", positive=True)
1077     >>> z = Symbol("z")
1078     >>> p = Symbol("p")
1079     >>> X = Exponential("x", l)
1080 
1081     >>> density(X)(z)
1082     lambda*exp(-lambda*z)
1083 
1084     >>> cdf(X)(z)
1085     Piecewise((1 - exp(-lambda*z), z >= 0), (0, True))
1086 
1087     >>> quantile(X)(p)
1088     -log(1 - p)/lambda
1089 
1090     >>> E(X)
1091     1/lambda
1092 
1093     >>> variance(X)
1094     lambda**(-2)
1095 
1096     >>> skewness(X)
1097     2
1098 
1099     >>> X = Exponential('x', 10)
1100 
1101     >>> density(X)(z)
1102     10*exp(-10*z)
1103 
1104     >>> E(X)
1105     1/10
1106 
1107     >>> std(X)
1108     1/10
1109 
1110     References
1111     ==========
1112 
1113     .. [1] https://en.wikipedia.org/wiki/Exponential_distribution
1114     .. [2] http://mathworld.wolfram.com/ExponentialDistribution.html
1115 
1116     """
1117 
1118     return rv(name, ExponentialDistribution, (rate, ))
1119 
1120 #-------------------------------------------------------------------------------
1121 # F distribution ---------------------------------------------------------------
1122 
1123 
1124 class FDistributionDistribution(SingleContinuousDistribution):
1125     _argnames = ('d1', 'd2')
1126 
1127     set = Interval(0, oo)
1128 
1129     @staticmethod
1130     def check(d1, d2):
1131         _value_check((d1 > 0, d1.is_integer),
1132             "Degrees of freedom d1 must be positive integer.")
1133         _value_check((d2 > 0, d2.is_integer),
1134             "Degrees of freedom d2 must be positive integer.")
1135 
1136     def pdf(self, x):
1137         d1, d2 = self.d1, self.d2
1138         return (sqrt((d1*x)**d1*d2**d2 / (d1*x+d2)**(d1+d2))
1139                / (x * beta_fn(d1/2, d2/2)))
1140 
1141     def _moment_generating_function(self, t):
1142         raise NotImplementedError('The moment generating function for the '
1143                                   'F-distribution does not exist.')
1144 
1145 def FDistribution(name, d1, d2):
1146     r"""
1147     Create a continuous random variable with a F distribution.
1148 
1149     The density of the F distribution is given by
1150 
1151     .. math::
1152         f(x) := \frac{\sqrt{\frac{(d_1 x)^{d_1} d_2^{d_2}}
1153                 {(d_1 x + d_2)^{d_1 + d_2}}}}
1154                 {x \mathrm{B} \left(\frac{d_1}{2}, \frac{d_2}{2}\right)}
1155 
1156     with :math:`x > 0`.
1157 
1158     Parameters
1159     ==========
1160 
1161     d1 : `d_1 > 0`, where d_1 is the degrees of freedom (n_1 - 1)
1162     d2 : `d_2 > 0`, where d_2 is the degrees of freedom (n_2 - 1)
1163 
1164     Returns
1165     =======
1166 
1167     A RandomSymbol.
1168 
1169     Examples
1170     ========
1171 
1172     >>> from sympy.stats import FDistribution, density
1173     >>> from sympy import Symbol, simplify, pprint
1174 
1175     >>> d1 = Symbol("d1", positive=True)
1176     >>> d2 = Symbol("d2", positive=True)
1177     >>> z = Symbol("z")
1178 
1179     >>> X = FDistribution("x", d1, d2)
1180 
1181     >>> D = density(X)(z)
1182     >>> pprint(D, use_unicode=False)
1183       d2
1184       --    ______________________________
1185       2    /       d1            -d1 - d2
1186     d2  *\/  (d1*z)  *(d1*z + d2)
1187     --------------------------------------
1188                     /d1  d2\
1189                  z*B|--, --|
1190                     \2   2 /
1191 
1192     References
1193     ==========
1194 
1195     .. [1] https://en.wikipedia.org/wiki/F-distribution
1196     .. [2] http://mathworld.wolfram.com/F-Distribution.html
1197 
1198     """
1199 
1200     return rv(name, FDistributionDistribution, (d1, d2))
1201 
1202 #-------------------------------------------------------------------------------
1203 # Fisher Z distribution --------------------------------------------------------
1204 
1205 class FisherZDistribution(SingleContinuousDistribution):
1206     _argnames = ('d1', 'd2')
1207 
1208     def pdf(self, x):
1209         d1, d2 = self.d1, self.d2
1210         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *
1211                exp(d1*x) / (d1*exp(2*x)+d2)**((d1+d2)/2))
1212 
1213 def FisherZ(name, d1, d2):
1214     r"""
1215     Create a Continuous Random Variable with an Fisher's Z distribution.
1216 
1217     The density of the Fisher's Z distribution is given by
1218 
1219     .. math::
1220         f(x) := \frac{2d_1^{d_1/2} d_2^{d_2/2}} {\mathrm{B}(d_1/2, d_2/2)}
1221                 \frac{e^{d_1z}}{\left(d_1e^{2z}+d_2\right)^{\left(d_1+d_2\right)/2}}
1222 
1223 
1224     .. TODO - What is the difference between these degrees of freedom?
1225 
1226     Parameters
1227     ==========
1228 
1229     d1 : `d_1 > 0`, degree of freedom
1230     d2 : `d_2 > 0`, degree of freedom
1231 
1232     Returns
1233     =======
1234 
1235     A RandomSymbol.
1236 
1237     Examples
1238     ========
1239 
1240     >>> from sympy.stats import FisherZ, density
1241     >>> from sympy import Symbol, simplify, pprint
1242 
1243     >>> d1 = Symbol("d1", positive=True)
1244     >>> d2 = Symbol("d2", positive=True)
1245     >>> z = Symbol("z")
1246 
1247     >>> X = FisherZ("x", d1, d2)
1248 
1249     >>> D = density(X)(z)
1250     >>> pprint(D, use_unicode=False)
1251                                 d1   d2
1252         d1   d2               - -- - --
1253         --   --                 2    2
1254         2    2  /    2*z     \           d1*z
1255     2*d1  *d2  *\d1*e    + d2/         *e
1256     -----------------------------------------
1257                      /d1  d2\
1258                     B|--, --|
1259                      \2   2 /
1260 
1261     References
1262     ==========
1263 
1264     .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution
1265     .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html
1266 
1267     """
1268 
1269     return rv(name, FisherZDistribution, (d1, d2))
1270 
1271 #-------------------------------------------------------------------------------
1272 # Frechet distribution ---------------------------------------------------------
1273 
1274 class FrechetDistribution(SingleContinuousDistribution):
1275     _argnames = ('a', 's', 'm')
1276 
1277     set = Interval(0, oo)
1278 
1279     def __new__(cls, a, s=1, m=0):
1280         a, s, m = list(map(sympify, (a, s, m)))
1281         return Basic.__new__(cls, a, s, m)
1282 
1283     def pdf(self, x):
1284         a, s, m = self.a, self.s, self.m
1285         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))
1286 
1287     def _cdf(self, x):
1288         a, s, m = self.a, self.s, self.m
1289         return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),
1290                         (S.Zero, True))
1291 
1292 def Frechet(name, a, s=1, m=0):
1293     r"""
1294     Create a continuous random variable with a Frechet distribution.
1295 
1296     The density of the Frechet distribution is given by
1297 
1298     .. math::
1299         f(x) := \frac{\alpha}{s} \left(\frac{x-m}{s}\right)^{-1-\alpha}
1300                  e^{-(\frac{x-m}{s})^{-\alpha}}
1301 
1302     with :math:`x \geq m`.
1303 
1304     Parameters
1305     ==========
1306 
1307     a : Real number, :math:`a \in \left(0, \infty\right)` the shape
1308     s : Real number, :math:`s \in \left(0, \infty\right)` the scale
1309     m : Real number, :math:`m \in \left(-\infty, \infty\right)` the minimum
1310 
1311     Returns
1312     =======
1313 
1314     A RandomSymbol.
1315 
1316     Examples
1317     ========
1318 
1319     >>> from sympy.stats import Frechet, density, E, std, cdf
1320     >>> from sympy import Symbol, simplify
1321 
1322     >>> a = Symbol("a", positive=True)
1323     >>> s = Symbol("s", positive=True)
1324     >>> m = Symbol("m", real=True)
1325     >>> z = Symbol("z")
1326 
1327     >>> X = Frechet("x", a, s, m)
1328 
1329     >>> density(X)(z)
1330     a*((-m + z)/s)**(-a - 1)*exp(-((-m + z)/s)**(-a))/s
1331 
1332     >>> cdf(X)(z)
1333      Piecewise((exp(-((-m + z)/s)**(-a)), m <= z), (0, True))
1334 
1335     References
1336     ==========
1337 
1338     .. [1] https://en.wikipedia.org/wiki/Fr%C3%A9chet_distribution
1339 
1340     """
1341 
1342     return rv(name, FrechetDistribution, (a, s, m))
1343 
1344 #-------------------------------------------------------------------------------
1345 # Gamma distribution -----------------------------------------------------------
1346 
1347 
1348 class GammaDistribution(SingleContinuousDistribution):
1349     _argnames = ('k', 'theta')
1350 
1351     set = Interval(0, oo)
1352 
1353     @staticmethod
1354     def check(k, theta):
1355         _value_check(k > 0, "k must be positive")
1356         _value_check(theta > 0, "Theta must be positive")
1357 
1358     def pdf(self, x):
1359         k, theta = self.k, self.theta
1360         return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)
1361 
1362     def sample(self):
1363         return random.gammavariate(self.k, self.theta)
1364 
1365     def _cdf(self, x):
1366         k, theta = self.k, self.theta
1367         return Piecewise(
1368                     (lowergamma(k, S(x)/theta)/gamma(k), x > 0),
1369                     (S.Zero, True))
1370 
1371     def _characteristic_function(self, t):
1372         return (1 - self.theta*I*t)**(-self.k)
1373 
1374     def _moment_generating_function(self, t):
1375         return (1- self.theta*t)**(-self.k)
1376 
1377 def Gamma(name, k, theta):
1378     r"""
1379     Create a continuous random variable with a Gamma distribution.
1380 
1381     The density of the Gamma distribution is given by
1382 
1383     .. math::
1384         f(x) := \frac{1}{\Gamma(k) \theta^k} x^{k - 1} e^{-\frac{x}{\theta}}
1385 
1386     with :math:`x \in [0,1]`.
1387 
1388     Parameters
1389     ==========
1390 
1391     k : Real number, `k > 0`, a shape
1392     theta : Real number, `\theta > 0`, a scale
1393 
1394     Returns
1395     =======
1396 
1397     A RandomSymbol.
1398 
1399     Examples
1400     ========
1401 
1402     >>> from sympy.stats import Gamma, density, cdf, E, variance
1403     >>> from sympy import Symbol, pprint, simplify
1404 
1405     >>> k = Symbol("k", positive=True)
1406     >>> theta = Symbol("theta", positive=True)
1407     >>> z = Symbol("z")
1408 
1409     >>> X = Gamma("x", k, theta)
1410 
1411     >>> D = density(X)(z)
1412     >>> pprint(D, use_unicode=False)
1413                       -z
1414                     -----
1415          -k  k - 1  theta
1416     theta  *z     *e
1417     ---------------------
1418            Gamma(k)
1419 
1420     >>> C = cdf(X, meijerg=True)(z)
1421     >>> pprint(C, use_unicode=False)
1422     /            /     z  \
1423     |k*lowergamma|k, -----|
1424     |            \   theta/
1425     <----------------------  for z >= 0
1426     |     Gamma(k + 1)
1427     |
1428     \          0             otherwise
1429 
1430     >>> E(X)
1431     k*theta
1432 
1433     >>> V = simplify(variance(X))
1434     >>> pprint(V, use_unicode=False)
1435            2
1436     k*theta
1437 
1438 
1439     References
1440     ==========
1441 
1442     .. [1] https://en.wikipedia.org/wiki/Gamma_distribution
1443     .. [2] http://mathworld.wolfram.com/GammaDistribution.html
1444 
1445     """
1446 
1447     return rv(name, GammaDistribution, (k, theta))
1448 
1449 #-------------------------------------------------------------------------------
1450 # Inverse Gamma distribution ---------------------------------------------------
1451 
1452 
1453 class GammaInverseDistribution(SingleContinuousDistribution):
1454     _argnames = ('a', 'b')
1455 
1456     set = Interval(0, oo)
1457 
1458     @staticmethod
1459     def check(a, b):
1460         _value_check(a > 0, "alpha must be positive")
1461         _value_check(b > 0, "beta must be positive")
1462 
1463     def pdf(self, x):
1464         a, b = self.a, self.b
1465         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)
1466 
1467     def _cdf(self, x):
1468         a, b = self.a, self.b
1469         return Piecewise((uppergamma(a,b/x)/gamma(a), x > 0),
1470                         (S.Zero, True))
1471 
1472     def sample(self):
1473         scipy = import_module('scipy')
1474         if scipy:
1475             from scipy.stats import invgamma
1476             return invgamma.rvs(float(self.a), 0, float(self.b))
1477         else:
1478             raise NotImplementedError('Sampling the inverse Gamma Distribution requires Scipy.')
1479 
1480     def _characteristic_function(self, t):
1481         a, b = self.a, self.b
1482         return 2 * (-I*b*t)**(a/2) * besselk(sqrt(-4*I*b*t)) / gamma(a)
1483 
1484     def _moment_generating_function(self, t):
1485         raise NotImplementedError('The moment generating function for the '
1486                                   'gamma inverse distribution does not exist.')
1487 
1488 def GammaInverse(name, a, b):
1489     r"""
1490     Create a continuous random variable with an inverse Gamma distribution.
1491 
1492     The density of the inverse Gamma distribution is given by
1493 
1494     .. math::
1495         f(x) := \frac{\beta^\alpha}{\Gamma(\alpha)} x^{-\alpha - 1}
1496                 \exp\left(\frac{-\beta}{x}\right)
1497 
1498     with :math:`x > 0`.
1499 
1500     Parameters
1501     ==========
1502 
1503     a : Real number, `a > 0` a shape
1504     b : Real number, `b > 0` a scale
1505 
1506     Returns
1507     =======
1508 
1509     A RandomSymbol.
1510 
1511     Examples
1512     ========
1513 
1514     >>> from sympy.stats import GammaInverse, density, cdf, E, variance
1515     >>> from sympy import Symbol, pprint
1516 
1517     >>> a = Symbol("a", positive=True)
1518     >>> b = Symbol("b", positive=True)
1519     >>> z = Symbol("z")
1520 
1521     >>> X = GammaInverse("x", a, b)
1522 
1523     >>> D = density(X)(z)
1524     >>> pprint(D, use_unicode=False)
1525                 -b
1526                 ---
1527      a  -a - 1   z
1528     b *z      *e
1529     ---------------
1530        Gamma(a)
1531 
1532     >>> cdf(X)(z)
1533     Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))
1534 
1535 
1536     References
1537     ==========
1538 
1539     .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution
1540 
1541     """
1542 
1543     return rv(name, GammaInverseDistribution, (a, b))
1544 
1545 #-------------------------------------------------------------------------------
1546 # Gumbel distribution --------------------------------------------------------
1547 
1548 
1549 class GumbelDistribution(SingleContinuousDistribution):
1550     _argnames = ('beta', 'mu')
1551 
1552     set = Interval(-oo, oo)
1553 
1554     def pdf(self, x):
1555         beta, mu = self.beta, self.mu
1556         z = (x - mu)/beta
1557         return (1/beta)*exp(-(z + exp(-z)))
1558 
1559     def _cdf(self, x):
1560         beta, mu = self.beta, self.mu
1561         return exp(-exp((mu - x)/beta))
1562 
1563     def _characteristic_function(self, t):
1564         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)
1565 
1566     def _moment_generating_function(self, t):
1567         return gamma(1 - self.beta*t) * exp(I*self.mu*t)
1568 
1569 def Gumbel(name, beta, mu):
1570     r"""
1571     Create a Continuous Random Variable with Gumbel distribution.
1572 
1573     The density of the Gumbel distribution is given by
1574 
1575     .. math::
1576         f(x) := \dfrac{1}{\beta} \exp \left( -\dfrac{x-\mu}{\beta}
1577                 - \exp \left( -\dfrac{x - \mu}{\beta} \right) \right)
1578 
1579     with :math:`x \in [ - \infty, \infty ]`.
1580 
1581     Parameters
1582     ==========
1583 
1584     mu: Real number, 'mu' is a location
1585     beta: Real number, 'beta > 0' is a scale
1586 
1587     Returns
1588     ==========
1589 
1590     A RandomSymbol
1591 
1592     Examples
1593     ==========
1594     >>> from sympy.stats import Gumbel, density, E, variance, cdf
1595     >>> from sympy import Symbol, simplify, pprint
1596     >>> x = Symbol("x")
1597     >>> mu = Symbol("mu")
1598     >>> beta = Symbol("beta", positive=True)
1599     >>> X = Gumbel("x", beta, mu)
1600     >>> density(X)(x)
1601     exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta
1602     >>> cdf(X)(x)
1603     exp(-exp((mu - x)/beta))
1604 
1605     References
1606     ==========
1607 
1608     .. [1] http://mathworld.wolfram.com/GumbelDistribution.html
1609     .. [2] https://en.wikipedia.org/wiki/Gumbel_distribution
1610 
1611     """
1612     return rv(name, GumbelDistribution, (beta, mu))
1613 
1614 #-------------------------------------------------------------------------------
1615 # Gompertz distribution --------------------------------------------------------
1616 
1617 class GompertzDistribution(SingleContinuousDistribution):
1618     _argnames = ('b', 'eta')
1619 
1620     set = Interval(0, oo)
1621 
1622     @staticmethod
1623     def check(b, eta):
1624         _value_check(b > 0, "b must be positive")
1625         _value_check(eta > 0, "eta must be positive")
1626 
1627     def pdf(self, x):
1628         eta, b = self.eta, self.b
1629         return b*eta*exp(b*x)*exp(eta)*exp(-eta*exp(b*x))
1630 
1631     def _cdf(self, x):
1632         eta, b = self.eta, self.b
1633         return 1 - exp(eta)*exp(-eta*exp(b*x))
1634 
1635     def _moment_generating_function(self, t):
1636         eta, b = self.eta, self.b
1637         return eta * exp(eta) * expint(t/b, eta)
1638 
1639 def Gompertz(name, b, eta):
1640     r"""
1641     Create a Continuous Random Variable with Gompertz distribution.
1642 
1643     The density of the Gompertz distribution is given by
1644 
1645     .. math::
1646         f(x) := b \eta e^{b x} e^{\eta} \exp \left(-\eta e^{bx} \right)
1647 
1648     with :math: 'x \in [0, \inf)'.
1649 
1650     Parameters
1651     ==========
1652 
1653     b: Real number, 'b > 0' a scale
1654     eta: Real number, 'eta > 0' a shape
1655 
1656     Returns
1657     =======
1658 
1659     A RandomSymbol.
1660 
1661     Examples
1662     ========
1663 
1664     >>> from sympy.stats import Gompertz, density, E, variance
1665     >>> from sympy import Symbol, simplify, pprint
1666 
1667     >>> b = Symbol("b", positive=True)
1668     >>> eta = Symbol("eta", positive=True)
1669     >>> z = Symbol("z")
1670 
1671     >>> X = Gompertz("x", b, eta)
1672 
1673     >>> density(X)(z)
1674     b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z))
1675 
1676     References
1677     ==========
1678 
1679     .. [1] https://en.wikipedia.org/wiki/Gompertz_distribution
1680 
1681     """
1682     return rv(name, GompertzDistribution, (b, eta))
1683 
1684 #-------------------------------------------------------------------------------
1685 # Kumaraswamy distribution -----------------------------------------------------
1686 
1687 
1688 class KumaraswamyDistribution(SingleContinuousDistribution):
1689     _argnames = ('a', 'b')
1690 
1691     set = Interval(0, oo)
1692 
1693     @staticmethod
1694     def check(a, b):
1695         _value_check(a > 0, "a must be positive")
1696         _value_check(b > 0, "b must be positive")
1697 
1698     def pdf(self, x):
1699         a, b = self.a, self.b
1700         return a * b * x**(a-1) * (1-x**a)**(b-1)
1701 
1702     def _cdf(self, x):
1703         a, b = self.a, self.b
1704         return Piecewise(
1705             (S.Zero, x < S.Zero),
1706             (1 - (1 - x**a)**b, x <= S.One),
1707             (S.One, True))
1708 
1709 def Kumaraswamy(name, a, b):
1710     r"""
1711     Create a Continuous Random Variable with a Kumaraswamy distribution.
1712 
1713     The density of the Kumaraswamy distribution is given by
1714 
1715     .. math::
1716         f(x) := a b x^{a-1} (1-x^a)^{b-1}
1717 
1718     with :math:`x \in [0,1]`.
1719 
1720     Parameters
1721     ==========
1722 
1723     a : Real number, `a > 0` a shape
1724     b : Real number, `b > 0` a shape
1725 
1726     Returns
1727     =======
1728 
1729     A RandomSymbol.
1730 
1731     Examples
1732     ========
1733 
1734     >>> from sympy.stats import Kumaraswamy, density, E, variance, cdf
1735     >>> from sympy import Symbol, simplify, pprint
1736 
1737     >>> a = Symbol("a", positive=True)
1738     >>> b = Symbol("b", positive=True)
1739     >>> z = Symbol("z")
1740 
1741     >>> X = Kumaraswamy("x", a, b)
1742 
1743     >>> D = density(X)(z)
1744     >>> pprint(D, use_unicode=False)
1745                        b - 1
1746          a - 1 /     a\
1747     a*b*z     *\1 - z /
1748 
1749     >>> cdf(X)(z)
1750     Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True))
1751 
1752     References
1753     ==========
1754 
1755     .. [1] https://en.wikipedia.org/wiki/Kumaraswamy_distribution
1756 
1757     """
1758 
1759     return rv(name, KumaraswamyDistribution, (a, b))
1760 
1761 #-------------------------------------------------------------------------------
1762 # Laplace distribution ---------------------------------------------------------
1763 
1764 
1765 class LaplaceDistribution(SingleContinuousDistribution):
1766     _argnames = ('mu', 'b')
1767 
1768     def pdf(self, x):
1769         mu, b = self.mu, self.b
1770         return 1/(2*b)*exp(-Abs(x - mu)/b)
1771 
1772     def _cdf(self, x):
1773         mu, b = self.mu, self.b
1774         return Piecewise(
1775                     (S.Half*exp((x - mu)/b), x < mu),
1776                     (S.One - S.Half*exp(-(x - mu)/b), x >= mu)
1777                         )
1778 
1779     def _characteristic_function(self, t):
1780         return exp(self.mu*I*t) / (1 + self.b**2*t**2)
1781 
1782     def _moment_generating_function(self, t):
1783         return exp(self.mu*t) / (1 - self.b**2*t**2)
1784 
1785 def Laplace(name, mu, b):
1786     r"""
1787     Create a continuous random variable with a Laplace distribution.
1788 
1789     The density of the Laplace distribution is given by
1790 
1791     .. math::
1792         f(x) := \frac{1}{2 b} \exp \left(-\frac{|x-\mu|}b \right)
1793 
1794     Parameters
1795     ==========
1796 
1797     mu : Real number or a list/matrix, the location (mean) or the
1798         location vector
1799     b : Real number or a positive definite matrix, representing a scale
1800         or the covariance matrix.
1801 
1802     Returns
1803     =======
1804 
1805     A RandomSymbol.
1806 
1807     Examples
1808     ========
1809 
1810     >>> from sympy.stats import Laplace, density, cdf
1811     >>> from sympy import Symbol, pprint
1812 
1813     >>> mu = Symbol("mu")
1814     >>> b = Symbol("b", positive=True)
1815     >>> z = Symbol("z")
1816 
1817     >>> X = Laplace("x", mu, b)
1818 
1819     >>> density(X)(z)
1820     exp(-Abs(mu - z)/b)/(2*b)
1821 
1822     >>> cdf(X)(z)
1823     Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True))
1824 
1825     >>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])
1826     >>> pprint(density(L)(1, 2), use_unicode=False)
1827      5        /     ____\
1828     e *besselk\0, \/ 35 /
1829     ---------------------
1830               pi
1831 
1832     References
1833     ==========
1834 
1835     .. [1] https://en.wikipedia.org/wiki/Laplace_distribution
1836     .. [2] http://mathworld.wolfram.com/LaplaceDistribution.html
1837 
1838     """
1839 
1840     if isinstance(mu, (list, MatrixBase)) and\
1841         isinstance(b, (list, MatrixBase)):
1842         from sympy.stats.joint_rv_types import MultivariateLaplaceDistribution
1843         return multivariate_rv(
1844             MultivariateLaplaceDistribution, name, mu, b)
1845 
1846     return rv(name, LaplaceDistribution, (mu, b))
1847 
1848 #-------------------------------------------------------------------------------
1849 # Logistic distribution --------------------------------------------------------
1850 
1851 
1852 class LogisticDistribution(SingleContinuousDistribution):
1853     _argnames = ('mu', 's')
1854 
1855     def pdf(self, x):
1856         mu, s = self.mu, self.s
1857         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)
1858 
1859     def _cdf(self, x):
1860         mu, s = self.mu, self.s
1861         return S.One/(1 + exp(-(x - mu)/s))
1862 
1863     def _characteristic_function(self, t):
1864         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))
1865 
1866     def _moment_generating_function(self, t):
1867         return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)
1868 
1869     def _quantile(self, p):
1870         return self.mu - self.s*log(-S.One + S.One/p)
1871 
1872 def Logistic(name, mu, s):
1873     r"""
1874     Create a continuous random variable with a logistic distribution.
1875 
1876     The density of the logistic distribution is given by
1877 
1878     .. math::
1879         f(x) := \frac{e^{-(x-\mu)/s}} {s\left(1+e^{-(x-\mu)/s}\right)^2}
1880 
1881     Parameters
1882     ==========
1883 
1884     mu : Real number, the location (mean)
1885     s : Real number, `s > 0` a scale
1886 
1887     Returns
1888     =======
1889 
1890     A RandomSymbol.
1891 
1892     Examples
1893     ========
1894 
1895     >>> from sympy.stats import Logistic, density, cdf
1896     >>> from sympy import Symbol
1897 
1898     >>> mu = Symbol("mu", real=True)
1899     >>> s = Symbol("s", positive=True)
1900     >>> z = Symbol("z")
1901 
1902     >>> X = Logistic("x", mu, s)
1903 
1904     >>> density(X)(z)
1905     exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2)
1906 
1907     >>> cdf(X)(z)
1908     1/(exp((mu - z)/s) + 1)
1909 
1910     References
1911     ==========
1912 
1913     .. [1] https://en.wikipedia.org/wiki/Logistic_distribution
1914     .. [2] http://mathworld.wolfram.com/LogisticDistribution.html
1915 
1916     """
1917 
1918     return rv(name, LogisticDistribution, (mu, s))
1919 
1920 #-------------------------------------------------------------------------------
1921 # Log Normal distribution ------------------------------------------------------
1922 
1923 
1924 class LogNormalDistribution(SingleContinuousDistribution):
1925     _argnames = ('mean', 'std')
1926 
1927     set = Interval(0, oo)
1928 
1929     def pdf(self, x):
1930         mean, std = self.mean, self.std
1931         return exp(-(log(x) - mean)**2 / (2*std**2)) / (x*sqrt(2*pi)*std)
1932 
1933     def sample(self):
1934         return random.lognormvariate(self.mean, self.std)
1935 
1936     def _cdf(self, x):
1937         mean, std = self.mean, self.std
1938         return Piecewise(
1939                 (S.Half + S.Half*erf((log(x) - mean)/sqrt(2)/std), x > 0),
1940                 (S.Zero, True)
1941         )
1942 
1943     def _moment_generating_function(self, t):
1944         raise NotImplementedError('Moment generating function of the log-normal distribution is not defined.')
1945 
1946 def LogNormal(name, mean, std):
1947     r"""
1948     Create a continuous random variable with a log-normal distribution.
1949 
1950     The density of the log-normal distribution is given by
1951 
1952     .. math::
1953         f(x) := \frac{1}{x\sqrt{2\pi\sigma^2}}
1954                 e^{-\frac{\left(\ln x-\mu\right)^2}{2\sigma^2}}
1955 
1956     with :math:`x \geq 0`.
1957 
1958     Parameters
1959     ==========
1960 
1961     mu : Real number, the log-scale
1962     sigma : Real number, :math:`\sigma^2 > 0` a shape
1963 
1964     Returns
1965     =======
1966 
1967     A RandomSymbol.
1968 
1969     Examples
1970     ========
1971 
1972     >>> from sympy.stats import LogNormal, density
1973     >>> from sympy import Symbol, simplify, pprint
1974 
1975     >>> mu = Symbol("mu", real=True)
1976     >>> sigma = Symbol("sigma", positive=True)
1977     >>> z = Symbol("z")
1978 
1979     >>> X = LogNormal("x", mu, sigma)
1980 
1981     >>> D = density(X)(z)
1982     >>> pprint(D, use_unicode=False)
1983                           2
1984            -(-mu + log(z))
1985            -----------------
1986                       2
1987       ___      2*sigma
1988     \/ 2 *e
1989     ------------------------
1990             ____
1991         2*\/ pi *sigma*z
1992 
1993 
1994     >>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1
1995 
1996     >>> density(X)(z)
1997     sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z)
1998 
1999     References
2000     ==========
2001 
2002     .. [1] https://en.wikipedia.org/wiki/Lognormal
2003     .. [2] http://mathworld.wolfram.com/LogNormalDistribution.html
2004 
2005     """
2006 
2007     return rv(name, LogNormalDistribution, (mean, std))
2008 
2009 #-------------------------------------------------------------------------------
2010 # Maxwell distribution ---------------------------------------------------------
2011 
2012 
2013 class MaxwellDistribution(SingleContinuousDistribution):
2014     _argnames = ('a',)
2015 
2016     set = Interval(0, oo)
2017 
2018     def pdf(self, x):
2019         a = self.a
2020         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3
2021 
2022     def _cdf(self, x):
2023         a = self.a
2024         return erf(sqrt(2)*x/(2*a)) - sqrt(2)*x*exp(-x**2/(2*a**2))/(sqrt(pi)*a)
2025 
2026 def Maxwell(name, a):
2027     r"""
2028     Create a continuous random variable with a Maxwell distribution.
2029 
2030     The density of the Maxwell distribution is given by
2031 
2032     .. math::
2033         f(x) := \sqrt{\frac{2}{\pi}} \frac{x^2 e^{-x^2/(2a^2)}}{a^3}
2034 
2035     with :math:`x \geq 0`.
2036 
2037     .. TODO - what does the parameter mean?
2038 
2039     Parameters
2040     ==========
2041 
2042     a : Real number, `a > 0`
2043 
2044     Returns
2045     =======
2046 
2047     A RandomSymbol.
2048 
2049     Examples
2050     ========
2051 
2052     >>> from sympy.stats import Maxwell, density, E, variance
2053     >>> from sympy import Symbol, simplify
2054 
2055     >>> a = Symbol("a", positive=True)
2056     >>> z = Symbol("z")
2057 
2058     >>> X = Maxwell("x", a)
2059 
2060     >>> density(X)(z)
2061     sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)
2062 
2063     >>> E(X)
2064     2*sqrt(2)*a/sqrt(pi)
2065 
2066     >>> simplify(variance(X))
2067     a**2*(-8 + 3*pi)/pi
2068 
2069     References
2070     ==========
2071 
2072     .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution
2073     .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html
2074 
2075     """
2076 
2077     return rv(name, MaxwellDistribution, (a, ))
2078 
2079 #-------------------------------------------------------------------------------
2080 # Nakagami distribution --------------------------------------------------------
2081 
2082 
2083 class NakagamiDistribution(SingleContinuousDistribution):
2084     _argnames = ('mu', 'omega')
2085 
2086     set = Interval(0, oo)
2087 
2088     def pdf(self, x):
2089         mu, omega = self.mu, self.omega
2090         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)
2091 
2092     def _cdf(self, x):
2093         mu, omega = self.mu, self.omega
2094         return Piecewise(
2095                     (lowergamma(mu, (mu/omega)*x**2)/gamma(mu), x > 0),
2096                     (S.Zero, True))
2097 
2098 def Nakagami(name, mu, omega):
2099     r"""
2100     Create a continuous random variable with a Nakagami distribution.
2101 
2102     The density of the Nakagami distribution is given by
2103 
2104     .. math::
2105         f(x) := \frac{2\mu^\mu}{\Gamma(\mu)\omega^\mu} x^{2\mu-1}
2106                 \exp\left(-\frac{\mu}{\omega}x^2 \right)
2107 
2108     with :math:`x > 0`.
2109 
2110     Parameters
2111     ==========
2112 
2113     mu : Real number, `\mu \geq \frac{1}{2}` a shape
2114     omega : Real number, `\omega > 0`, the spread
2115 
2116     Returns
2117     =======
2118 
2119     A RandomSymbol.
2120 
2121     Examples
2122     ========
2123 
2124     >>> from sympy.stats import Nakagami, density, E, variance, cdf
2125     >>> from sympy import Symbol, simplify, pprint
2126 
2127     >>> mu = Symbol("mu", positive=True)
2128     >>> omega = Symbol("omega", positive=True)
2129     >>> z = Symbol("z")
2130 
2131     >>> X = Nakagami("x", mu, omega)
2132 
2133     >>> D = density(X)(z)
2134     >>> pprint(D, use_unicode=False)
2135                                     2
2136                                -mu*z
2137                                -------
2138         mu      -mu  2*mu - 1  omega
2139     2*mu  *omega   *z        *e
2140     ----------------------------------
2141                 Gamma(mu)
2142 
2143     >>> simplify(E(X))
2144     sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1)
2145 
2146     >>> V = simplify(variance(X))
2147     >>> pprint(V, use_unicode=False)
2148                         2
2149              omega*Gamma (mu + 1/2)
2150     omega - -----------------------
2151             Gamma(mu)*Gamma(mu + 1)
2152 
2153     >>> cdf(X)(z)
2154     Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),
2155             (0, True))
2156 
2157 
2158     References
2159     ==========
2160 
2161     .. [1] https://en.wikipedia.org/wiki/Nakagami_distribution
2162 
2163     """
2164 
2165     return rv(name, NakagamiDistribution, (mu, omega))
2166 
2167 #-------------------------------------------------------------------------------
2168 # Normal distribution ----------------------------------------------------------
2169 
2170 
2171 class NormalDistribution(SingleContinuousDistribution):
2172     _argnames = ('mean', 'std')
2173 
2174     @staticmethod
2175     def check(mean, std):
2176         _value_check(std > 0, "Standard deviation must be positive")
2177 
2178     def pdf(self, x):
2179         return exp(-(x - self.mean)**2 / (2*self.std**2)) / (sqrt(2*pi)*self.std)
2180 
2181     def sample(self):
2182         return random.normalvariate(self.mean, self.std)
2183 
2184     def _cdf(self, x):
2185         mean, std = self.mean, self.std
2186         return erf(sqrt(2)*(-mean + x)/(2*std))/2 + S.Half
2187 
2188     def _characteristic_function(self, t):
2189         mean, std = self.mean, self.std
2190         return exp(I*mean*t - std**2*t**2/2)
2191 
2192     def _moment_generating_function(self, t):
2193         mean, std = self.mean, self.std
2194         return exp(mean*t + std**2*t**2/2)
2195 
2196     def _quantile(self, p):
2197         mean, std = self.mean, self.std
2198         return mean + std*sqrt(2)*erfinv(2*p - 1)
2199 
2200 def Normal(name, mean, std):
2201     r"""
2202     Create a continuous random variable with a Normal distribution.
2203 
2204     The density of the Normal distribution is given by
2205 
2206     .. math::
2207         f(x) := \frac{1}{\sigma\sqrt{2\pi}} e^{ -\frac{(x-\mu)^2}{2\sigma^2} }
2208 
2209     Parameters
2210     ==========
2211 
2212     mu : Real number or a list representing the mean or the mean vector
2213     sigma : Real number or a positive definite sqaure matrix,
2214          :math:`\sigma^2 > 0` the variance
2215 
2216     Returns
2217     =======
2218 
2219     A RandomSymbol.
2220 
2221     Examples
2222     ========
2223 
2224     >>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile
2225     >>> from sympy import Symbol, simplify, pprint, factor, together, factor_terms
2226 
2227     >>> mu = Symbol("mu")
2228     >>> sigma = Symbol("sigma", positive=True)
2229     >>> z = Symbol("z")
2230     >>> y = Symbol("y")
2231     >>> p = Symbol("p")
2232     >>> X = Normal("x", mu, sigma)
2233 
2234     >>> density(X)(z)
2235     sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma)
2236 
2237     >>> C = simplify(cdf(X))(z) # it needs a little more help...
2238     >>> pprint(C, use_unicode=False)
2239        /  ___          \
2240        |\/ 2 *(-mu + z)|
2241     erf|---------------|
2242        \    2*sigma    /   1
2243     -------------------- + -
2244              2             2
2245 
2246     >>> quantile(X)(p)
2247     mu + sqrt(2)*sigma*erfinv(2*p - 1)
2248 
2249     >>> simplify(skewness(X))
2250     0
2251 
2252     >>> X = Normal("x", 0, 1) # Mean 0, standard deviation 1
2253     >>> density(X)(z)
2254     sqrt(2)*exp(-z**2/2)/(2*sqrt(pi))
2255 
2256     >>> E(2*X + 1)
2257     1
2258 
2259     >>> simplify(std(2*X + 1))
2260     2
2261 
2262     >>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])
2263     >>> from sympy.stats.joint_rv import marginal_distribution
2264     >>> pprint(density(m)(y, z))
2265            /1   y\ /2*y   z\   /    z\ /  y   2*z    \
2266            |- - -|*|--- - -| + |1 - -|*|- - + --- - 1|
2267       ___  \2   2/ \ 3    3/   \    2/ \  3    3     /
2268     \/ 3 *e
2269     --------------------------------------------------
2270                            6*pi
2271 
2272     >>> marginal_distribution(m, m[0])(1)
2273      1/(2*sqrt(pi))
2274 
2275 
2276     References
2277     ==========
2278 
2279     .. [1] https://en.wikipedia.org/wiki/Normal_distribution
2280     .. [2] http://mathworld.wolfram.com/NormalDistributionFunction.html
2281 
2282     """
2283 
2284     if isinstance(mean, (list, MatrixBase)) and\
2285         isinstance(std, (list, MatrixBase)):
2286         from sympy.stats.joint_rv_types import MultivariateNormalDistribution
2287         return multivariate_rv(
2288             MultivariateNormalDistribution, name, mean, std)
2289     return rv(name, NormalDistribution, (mean, std))
2290 
2291 #-------------------------------------------------------------------------------
2292 # Pareto distribution ----------------------------------------------------------
2293 
2294 
2295 class ParetoDistribution(SingleContinuousDistribution):
2296     _argnames = ('xm', 'alpha')
2297 
2298     @property
2299     def set(self):
2300         return Interval(self.xm, oo)
2301 
2302     @staticmethod
2303     def check(xm, alpha):
2304         _value_check(xm > 0, "Xm must be positive")
2305         _value_check(alpha > 0, "Alpha must be positive")
2306 
2307     def pdf(self, x):
2308         xm, alpha = self.xm, self.alpha
2309         return alpha * xm**alpha / x**(alpha + 1)
2310 
2311     def sample(self):
2312         return random.paretovariate(self.alpha)
2313 
2314     def _cdf(self, x):
2315         xm, alpha = self.xm, self.alpha
2316         return Piecewise(
2317                 (S.One - xm**alpha/x**alpha, x>=xm),
2318                 (0, True),
2319         )
2320 
2321     def _moment_generating_function(self, t):
2322         xm, alpha = self.xm, self.alpha
2323         return alpha * (-xm*t)**alpha * uppergamma(-alpha, -xm*t)
2324 
2325     def _characteristic_function(self, t):
2326         xm, alpha = self.xm, self.alpha
2327         return alpha * (-I * xm * t) ** alpha * uppergamma(-alpha, -I * xm * t)
2328 
2329 
2330 def Pareto(name, xm, alpha):
2331     r"""
2332     Create a continuous random variable with the Pareto distribution.
2333 
2334     The density of the Pareto distribution is given by
2335 
2336     .. math::
2337         f(x) := \frac{\alpha\,x_m^\alpha}{x^{\alpha+1}}
2338 
2339     with :math:`x \in [x_m,\infty]`.
2340 
2341     Parameters
2342     ==========
2343 
2344     xm : Real number, `x_m > 0`, a scale
2345     alpha : Real number, `\alpha > 0`, a shape
2346 
2347     Returns
2348     =======
2349 
2350     A RandomSymbol.
2351 
2352     Examples
2353     ========
2354 
2355     >>> from sympy.stats import Pareto, density
2356     >>> from sympy import Symbol
2357 
2358     >>> xm = Symbol("xm", positive=True)
2359     >>> beta = Symbol("beta", positive=True)
2360     >>> z = Symbol("z")
2361 
2362     >>> X = Pareto("x", xm, beta)
2363 
2364     >>> density(X)(z)
2365     beta*xm**beta*z**(-beta - 1)
2366 
2367     References
2368     ==========
2369 
2370     .. [1] https://en.wikipedia.org/wiki/Pareto_distribution
2371     .. [2] http://mathworld.wolfram.com/ParetoDistribution.html
2372 
2373     """
2374 
2375     return rv(name, ParetoDistribution, (xm, alpha))
2376 
2377 #-------------------------------------------------------------------------------
2378 # QuadraticU distribution ------------------------------------------------------
2379 
2380 
2381 class QuadraticUDistribution(SingleContinuousDistribution):
2382     _argnames = ('a', 'b')
2383 
2384     @property
2385     def set(self):
2386         return Interval(self.a, self.b)
2387 
2388     def pdf(self, x):
2389         a, b = self.a, self.b
2390         alpha = 12 / (b-a)**3
2391         beta = (a+b) / 2
2392         return Piecewise(
2393                   (alpha * (x-beta)**2, And(a<=x, x<=b)),
2394                   (S.Zero, True))
2395 
2396     def _moment_generating_function(self, t):
2397         a, b = self.a, self.b
2398 
2399         return -3 * (exp(a*t) * (4  + (a**2 + 2*a*(-2 + b) + b**2) * t) - exp(b*t) * (4 + (-4*b + (a + b)**2) * t)) / ((a-b)**3 * t**2)
2400 
2401     def _characteristic_function(self, t):
2402         def _moment_generating_function(self, t):
2403             a, b = self.a, self.b
2404 
2405             return -3*I*(exp(I*a*t*exp(I*b*t)) * (4*I - (-4*b + (a+b)**2)*t)) / ((a-b)**3 * t**2)
2406 
2407 
2408 def QuadraticU(name, a, b):
2409     r"""
2410     Create a Continuous Random Variable with a U-quadratic distribution.
2411 
2412     The density of the U-quadratic distribution is given by
2413 
2414     .. math::
2415         f(x) := \alpha (x-\beta)^2
2416 
2417     with :math:`x \in [a,b]`.
2418 
2419     Parameters
2420     ==========
2421 
2422     a : Real number
2423     b : Real number, :math:`a < b`
2424 
2425     Returns
2426     =======
2427 
2428     A RandomSymbol.
2429 
2430     Examples
2431     ========
2432 
2433     >>> from sympy.stats import QuadraticU, density, E, variance
2434     >>> from sympy import Symbol, simplify, factor, pprint
2435 
2436     >>> a = Symbol("a", real=True)
2437     >>> b = Symbol("b", real=True)
2438     >>> z = Symbol("z")
2439 
2440     >>> X = QuadraticU("x", a, b)
2441 
2442     >>> D = density(X)(z)
2443     >>> pprint(D, use_unicode=False)
2444     /                2
2445     |   /  a   b    \
2446     |12*|- - - - + z|
2447     |   \  2   2    /
2448     <-----------------  for And(b >= z, a <= z)
2449     |            3
2450     |    (-a + b)
2451     |
2452     \        0                 otherwise
2453 
2454     References
2455     ==========
2456 
2457     .. [1] https://en.wikipedia.org/wiki/U-quadratic_distribution
2458 
2459     """
2460 
2461     return rv(name, QuadraticUDistribution, (a, b))
2462 
2463 #-------------------------------------------------------------------------------
2464 # RaisedCosine distribution ----------------------------------------------------
2465 
2466 
2467 class RaisedCosineDistribution(SingleContinuousDistribution):
2468     _argnames = ('mu', 's')
2469 
2470     @property
2471     def set(self):
2472         return Interval(self.mu - self.s, self.mu + self.s)
2473 
2474     @staticmethod
2475     def check(mu, s):
2476         _value_check(s > 0, "s must be positive")
2477 
2478     def pdf(self, x):
2479         mu, s = self.mu, self.s
2480         return Piecewise(
2481                 ((1+cos(pi*(x-mu)/s)) / (2*s), And(mu-s<=x, x<=mu+s)),
2482                 (S.Zero, True))
2483 
2484     def _characteristic_function(self, t):
2485         mu, s = self.mu, self.s
2486         return Piecewise((exp(-I*pi*mu/s)/2, Eq(t, -pi/s)),
2487                          (exp(I*pi*mu/s)/2, Eq(t, pi/s)),
2488                          (pi**2*sin(s*t)*exp(I*mu*t) / (s*t*(pi**2 - s**2*t**2)), True))
2489 
2490     def _moment_generating_function(self, t):
2491         mu, s = self.mu, self.s
2492         return pi**2 * sinh(s*t) * exp(mu*t) /  (s*t*(pi**2 + s**2*t**2))
2493 
2494 def RaisedCosine(name, mu, s):
2495     r"""
2496     Create a Continuous Random Variable with a raised cosine distribution.
2497 
2498     The density of the raised cosine distribution is given by
2499 
2500     .. math::
2501         f(x) := \frac{1}{2s}\left(1+\cos\left(\frac{x-\mu}{s}\pi\right)\right)
2502 
2503     with :math:`x \in [\mu-s,\mu+s]`.
2504 
2505     Parameters
2506     ==========
2507 
2508     mu : Real number
2509     s : Real number, `s > 0`
2510 
2511     Returns
2512     =======
2513 
2514     A RandomSymbol.
2515 
2516     Examples
2517     ========
2518 
2519     >>> from sympy.stats import RaisedCosine, density, E, variance
2520     >>> from sympy import Symbol, simplify, pprint
2521 
2522     >>> mu = Symbol("mu", real=True)
2523     >>> s = Symbol("s", positive=True)
2524     >>> z = Symbol("z")
2525 
2526     >>> X = RaisedCosine("x", mu, s)
2527 
2528     >>> D = density(X)(z)
2529     >>> pprint(D, use_unicode=False)
2530     /   /pi*(-mu + z)\
2531     |cos|------------| + 1
2532     |   \     s      /
2533     <---------------------  for And(z >= mu - s, z <= mu + s)
2534     |         2*s
2535     |
2536     \          0                        otherwise
2537 
2538     References
2539     ==========
2540 
2541     .. [1] https://en.wikipedia.org/wiki/Raised_cosine_distribution
2542 
2543     """
2544 
2545     return rv(name, RaisedCosineDistribution, (mu, s))
2546 
2547 #-------------------------------------------------------------------------------
2548 # Rayleigh distribution --------------------------------------------------------
2549 
2550 
2551 class RayleighDistribution(SingleContinuousDistribution):
2552     _argnames = ('sigma',)
2553 
2554     set = Interval(0, oo)
2555 
2556     def pdf(self, x):
2557         sigma = self.sigma
2558         return x/sigma**2*exp(-x**2/(2*sigma**2))
2559 
2560     def _cdf(self, x):
2561         sigma = self.sigma
2562         return 1 - exp(-(x**2/(2*sigma**2)))
2563 
2564     def _characteristic_function(self, t):
2565         sigma = self.sigma
2566         return 1 - sigma*t*exp(-sigma**2*t**2/2) * sqrt(pi/2) * (erfi(sigma*t/sqrt(2)) - I)
2567 
2568     def _moment_generating_function(self, t):
2569         sigma = self.sigma
2570         return 1 + sigma*t*exp(sigma**2*t**2/2) * sqrt(pi/2) * (erf(sigma*t/sqrt(2)) + 1)
2571 
2572 
2573 def Rayleigh(name, sigma):
2574     r"""
2575     Create a continuous random variable with a Rayleigh distribution.
2576 
2577     The density of the Rayleigh distribution is given by
2578 
2579     .. math ::
2580         f(x) := \frac{x}{\sigma^2} e^{-x^2/2\sigma^2}
2581 
2582     with :math:`x > 0`.
2583 
2584     Parameters
2585     ==========
2586 
2587     sigma : Real number, `\sigma > 0`
2588 
2589     Returns
2590     =======
2591 
2592     A RandomSymbol.
2593 
2594     Examples
2595     ========
2596 
2597     >>> from sympy.stats import Rayleigh, density, E, variance
2598     >>> from sympy import Symbol, simplify
2599 
2600     >>> sigma = Symbol("sigma", positive=True)
2601     >>> z = Symbol("z")
2602 
2603     >>> X = Rayleigh("x", sigma)
2604 
2605     >>> density(X)(z)
2606     z*exp(-z**2/(2*sigma**2))/sigma**2
2607 
2608     >>> E(X)
2609     sqrt(2)*sqrt(pi)*sigma/2
2610 
2611     >>> variance(X)
2612     -pi*sigma**2/2 + 2*sigma**2
2613 
2614     References
2615     ==========
2616 
2617     .. [1] https://en.wikipedia.org/wiki/Rayleigh_distribution
2618     .. [2] http://mathworld.wolfram.com/RayleighDistribution.html
2619 
2620     """
2621 
2622     return rv(name, RayleighDistribution, (sigma, ))
2623 
2624 #-------------------------------------------------------------------------------
2625 # Shifted Gompertz distribution ------------------------------------------------
2626 
2627 
2628 class ShiftedGompertzDistribution(SingleContinuousDistribution):
2629     _argnames = ('b', 'eta')
2630 
2631     set = Interval(0, oo)
2632 
2633     @staticmethod
2634     def check(b, eta):
2635         _value_check(b > 0, "b must be positive")
2636         _value_check(eta > 0, "eta must be positive")
2637 
2638     def pdf(self, x):
2639         b, eta = self.b, self.eta
2640         return b*exp(-b*x)*exp(-eta*exp(-b*x))*(1+eta*(1-exp(-b*x)))
2641 
2642 def ShiftedGompertz(name, b, eta):
2643     r"""
2644     Create a continuous random variable with a Shifted Gompertz distribution.
2645 
2646     The density of the Shifted Gompertz distribution is given by
2647 
2648     .. math::
2649         f(x) := b e^{-b x} e^{-\eta \exp(-b x)} \left[1 + \eta(1 - e^(-bx)) \right]
2650 
2651     with :math: 'x \in [0, \inf)'.
2652 
2653     Parameters
2654     ==========
2655 
2656     b: Real number, 'b > 0' a scale
2657     eta: Real number, 'eta > 0' a shape
2658 
2659     Returns
2660     =======
2661 
2662     A RandomSymbol.
2663 
2664     Examples
2665     ========
2666     >>> from sympy.stats import ShiftedGompertz, density, E, variance
2667     >>> from sympy import Symbol
2668 
2669     >>> b = Symbol("b", positive=True)
2670     >>> eta = Symbol("eta", positive=True)
2671     >>> x = Symbol("x")
2672 
2673     >>> X = ShiftedGompertz("x", b, eta)
2674 
2675     >>> density(X)(x)
2676     b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x))
2677 
2678     References
2679     ==========
2680 
2681     .. [1] https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution
2682 
2683     """
2684     return rv(name, ShiftedGompertzDistribution, (b, eta))
2685 
2686 #-------------------------------------------------------------------------------
2687 # StudentT distribution --------------------------------------------------------
2688 
2689 
2690 class StudentTDistribution(SingleContinuousDistribution):
2691     _argnames = ('nu',)
2692 
2693     def pdf(self, x):
2694         nu = self.nu
2695         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)
2696 
2697     def _cdf(self, x):
2698         nu = self.nu
2699         return S.Half + x*gamma((nu+1)/2)*hyper((S.Half, (nu+1)/2),
2700                                 (S(3)/2,), -x**2/nu)/(sqrt(pi*nu)*gamma(nu/2))
2701 
2702     def _moment_generating_function(self, t):
2703         raise NotImplementedError('The moment generating function for the Student-T distribution is undefined.')
2704 
2705 def StudentT(name, nu):
2706     r"""
2707     Create a continuous random variable with a student's t distribution.
2708 
2709     The density of the student's t distribution is given by
2710 
2711     .. math::
2712         f(x) := \frac{\Gamma \left(\frac{\nu+1}{2} \right)}
2713                 {\sqrt{\nu\pi}\Gamma \left(\frac{\nu}{2} \right)}
2714                 \left(1+\frac{x^2}{\nu} \right)^{-\frac{\nu+1}{2}}
2715 
2716     Parameters
2717     ==========
2718 
2719     nu : Real number, `\nu > 0`, the degrees of freedom
2720 
2721     Returns
2722     =======
2723 
2724     A RandomSymbol.
2725 
2726     Examples
2727     ========
2728 
2729     >>> from sympy.stats import StudentT, density, E, variance, cdf
2730     >>> from sympy import Symbol, simplify, pprint
2731 
2732     >>> nu = Symbol("nu", positive=True)
2733     >>> z = Symbol("z")
2734 
2735     >>> X = StudentT("x", nu)
2736 
2737     >>> D = density(X)(z)
2738     >>> pprint(D, use_unicode=False)
2739                nu   1
2740              - -- - -
2741                2    2
2742      /     2\
2743      |    z |
2744      |1 + --|
2745      \    nu/
2746     -----------------
2747       ____  /     nu\
2748     \/ nu *B|1/2, --|
2749             \     2 /
2750 
2751     >>> cdf(X)(z)
2752     1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),
2753                                 -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2))
2754 
2755 
2756     References
2757     ==========
2758 
2759     .. [1] https://en.wikipedia.org/wiki/Student_t-distribution
2760     .. [2] http://mathworld.wolfram.com/Studentst-Distribution.html
2761 
2762     """
2763 
2764     return rv(name, StudentTDistribution, (nu, ))
2765 
2766 #-------------------------------------------------------------------------------
2767 # Trapezoidal distribution ------------------------------------------------------
2768 
2769 
2770 class TrapezoidalDistribution(SingleContinuousDistribution):
2771     _argnames = ('a', 'b', 'c', 'd')
2772 
2773     def pdf(self, x):
2774         a, b, c, d = self.a, self.b, self.c, self.d
2775         return Piecewise(
2776             (2*(x-a) / ((b-a)*(d+c-a-b)), And(a <= x, x < b)),
2777             (2 / (d+c-a-b), And(b <= x, x < c)),
2778             (2*(d-x) / ((d-c)*(d+c-a-b)), And(c <= x, x <= d)),
2779             (S.Zero, True))
2780 
2781 def Trapezoidal(name, a, b, c, d):
2782     r"""
2783     Create a continuous random variable with a trapezoidal distribution.
2784 
2785     The density of the trapezoidal distribution is given by
2786 
2787     .. math::
2788         f(x) := \begin{cases}
2789                   0 & \mathrm{for\ } x < a, \\
2790                   \frac{2(x-a)}{(b-a)(d+c-a-b)} & \mathrm{for\ } a \le x < b, \\
2791                   \frac{2}{d+c-a-b} & \mathrm{for\ } b \le x < c, \\
2792                   \frac{2(d-x)}{(d-c)(d+c-a-b)} & \mathrm{for\ } c \le x < d, \\
2793                   0 & \mathrm{for\ } d < x.
2794                 \end{cases}
2795 
2796     Parameters
2797     ==========
2798 
2799     a : Real number, :math:`a < d`
2800     b : Real number, :math:`a <= b < c`
2801     c : Real number, :math:`b < c <= d`
2802     d : Real number
2803 
2804     Returns
2805     =======
2806 
2807     A RandomSymbol.
2808 
2809     Examples
2810     ========
2811 
2812     >>> from sympy.stats import Trapezoidal, density, E
2813     >>> from sympy import Symbol, pprint
2814 
2815     >>> a = Symbol("a")
2816     >>> b = Symbol("b")
2817     >>> c = Symbol("c")
2818     >>> d = Symbol("d")
2819     >>> z = Symbol("z")
2820 
2821     >>> X = Trapezoidal("x", a,b,c,d)
2822 
2823     >>> pprint(density(X)(z), use_unicode=False)
2824     /        -2*a + 2*z
2825     |-------------------------  for And(a <= z, b > z)
2826     |(-a + b)*(-a - b + c + d)
2827     |
2828     |           2
2829     |     --------------        for And(b <= z, c > z)
2830     <     -a - b + c + d
2831     |
2832     |        2*d - 2*z
2833     |-------------------------  for And(d >= z, c <= z)
2834     |(-c + d)*(-a - b + c + d)
2835     |
2836     \            0                     otherwise
2837 
2838     References
2839     ==========
2840 
2841     .. [1] https://en.wikipedia.org/wiki/Trapezoidal_distribution
2842 
2843     """
2844     return rv(name, TrapezoidalDistribution, (a, b, c, d))
2845 
2846 #-------------------------------------------------------------------------------
2847 # Triangular distribution ------------------------------------------------------
2848 
2849 
2850 class TriangularDistribution(SingleContinuousDistribution):
2851     _argnames = ('a', 'b', 'c')
2852 
2853     def pdf(self, x):
2854         a, b, c = self.a, self.b, self.c
2855         return Piecewise(
2856             (2*(x - a)/((b - a)*(c - a)), And(a <= x, x < c)),
2857             (2/(b - a), Eq(x, c)),
2858             (2*(b - x)/((b - a)*(b - c)), And(c < x, x <= b)),
2859             (S.Zero, True))
2860 
2861     def _characteristic_function(self, t):
2862         a, b, c = self.a, self.b, self.c
2863         return -2 *((b-c) * exp(I*a*t) - (b-a) * exp(I*c*t) + (c-a) * exp(I*b*t)) / ((b-a)*(c-a)*(b-c)*t**2)
2864 
2865     def _moment_generating_function(self, t):
2866         a, b, c = self.a, self.b, self.c
2867         return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (
2868         (b - a) * (c - a) * (b - c) * t ** 2)
2869 
2870 
2871 def Triangular(name, a, b, c):
2872     r"""
2873     Create a continuous random variable with a triangular distribution.
2874 
2875     The density of the triangular distribution is given by
2876 
2877     .. math::
2878         f(x) := \begin{cases}
2879                   0 & \mathrm{for\ } x < a, \\
2880                   \frac{2(x-a)}{(b-a)(c-a)} & \mathrm{for\ } a \le x < c, \\
2881                   \frac{2}{b-a} & \mathrm{for\ } x = c, \\
2882                   \frac{2(b-x)}{(b-a)(b-c)} & \mathrm{for\ } c < x \le b, \\
2883                   0 & \mathrm{for\ } b < x.
2884                 \end{cases}
2885 
2886     Parameters
2887     ==========
2888 
2889     a : Real number, :math:`a \in \left(-\infty, \infty\right)`
2890     b : Real number, :math:`a < b`
2891     c : Real number, :math:`a \leq c \leq b`
2892 
2893     Returns
2894     =======
2895 
2896     A RandomSymbol.
2897 
2898     Examples
2899     ========
2900 
2901     >>> from sympy.stats import Triangular, density, E
2902     >>> from sympy import Symbol, pprint
2903 
2904     >>> a = Symbol("a")
2905     >>> b = Symbol("b")
2906     >>> c = Symbol("c")
2907     >>> z = Symbol("z")
2908 
2909     >>> X = Triangular("x", a,b,c)
2910 
2911     >>> pprint(density(X)(z), use_unicode=False)
2912     /    -2*a + 2*z
2913     |-----------------  for And(a <= z, c > z)
2914     |(-a + b)*(-a + c)
2915     |
2916     |       2
2917     |     ------              for c = z
2918     <     -a + b
2919     |
2920     |   2*b - 2*z
2921     |----------------   for And(b >= z, c < z)
2922     |(-a + b)*(b - c)
2923     |
2924     \        0                otherwise
2925 
2926     References
2927     ==========
2928 
2929     .. [1] https://en.wikipedia.org/wiki/Triangular_distribution
2930     .. [2] http://mathworld.wolfram.com/TriangularDistribution.html
2931 
2932     """
2933 
2934     return rv(name, TriangularDistribution, (a, b, c))
2935 
2936 #-------------------------------------------------------------------------------
2937 # Uniform distribution ---------------------------------------------------------
2938 
2939 
2940 class UniformDistribution(SingleContinuousDistribution):
2941     _argnames = ('left', 'right')
2942 
2943     def pdf(self, x):
2944         left, right = self.left, self.right
2945         return Piecewise(
2946             (S.One/(right - left), And(left <= x, x <= right)),
2947             (S.Zero, True)
2948         )
2949 
2950     def _cdf(self, x):
2951         left, right = self.left, self.right
2952         return Piecewise(
2953             (S.Zero, x < left),
2954             ((x - left)/(right - left), x <= right),
2955             (S.One, True)
2956         )
2957 
2958     def _characteristic_function(self, t):
2959         left, right = self.left, self.right
2960         return Piecewise(((exp(I*t*right) - exp(I*t*left)) / (I*t*(right - left)), Ne(t, 0)),
2961                          (S.One, True))
2962 
2963     def _moment_generating_function(self, t):
2964         left, right = self.left, self.right
2965         return Piecewise(((exp(t*right) - exp(t*left)) / (t * (right - left)), Ne(t, 0)),
2966                          (S.One, True))
2967 
2968     def expectation(self, expr, var, **kwargs):
2969         from sympy import Max, Min
2970         kwargs['evaluate'] = True
2971         result = SingleContinuousDistribution.expectation(self, expr, var, **kwargs)
2972         result = result.subs({Max(self.left, self.right): self.right,
2973                               Min(self.left, self.right): self.left})
2974         return result
2975 
2976     def sample(self):
2977         return random.uniform(self.left, self.right)
2978 
2979 
2980 def Uniform(name, left, right):
2981     r"""
2982     Create a continuous random variable with a uniform distribution.
2983 
2984     The density of the uniform distribution is given by
2985 
2986     .. math::
2987         f(x) := \begin{cases}
2988                   \frac{1}{b - a} & \text{for } x \in [a,b]  \\
2989                   0               & \text{otherwise}
2990                 \end{cases}
2991 
2992     with :math:`x \in [a,b]`.
2993 
2994     Parameters
2995     ==========
2996 
2997     a : Real number, :math:`-\infty < a` the left boundary
2998     b : Real number, :math:`a < b < \infty` the right boundary
2999 
3000     Returns
3001     =======
3002 
3003     A RandomSymbol.
3004 
3005     Examples
3006     ========
3007 
3008     >>> from sympy.stats import Uniform, density, cdf, E, variance, skewness
3009     >>> from sympy import Symbol, simplify
3010 
3011     >>> a = Symbol("a", negative=True)
3012     >>> b = Symbol("b", positive=True)
3013     >>> z = Symbol("z")
3014 
3015     >>> X = Uniform("x", a, b)
3016 
3017     >>> density(X)(z)
3018     Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True))
3019 
3020     >>> cdf(X)(z)  # doctest: +SKIP
3021     -a/(-a + b) + z/(-a + b)
3022 
3023     >>> simplify(E(X))
3024     a/2 + b/2
3025 
3026     >>> simplify(variance(X))
3027     a**2/12 - a*b/6 + b**2/12
3028 
3029     References
3030     ==========
3031 
3032     .. [1] https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29
3033     .. [2] http://mathworld.wolfram.com/UniformDistribution.html
3034 
3035     """
3036 
3037     return rv(name, UniformDistribution, (left, right))
3038 
3039 #-------------------------------------------------------------------------------
3040 # UniformSum distribution ------------------------------------------------------
3041 
3042 
3043 class UniformSumDistribution(SingleContinuousDistribution):
3044     _argnames = ('n',)
3045 
3046     @property
3047     def set(self):
3048         return Interval(0, self.n)
3049 
3050     def pdf(self, x):
3051         n = self.n
3052         k = Dummy("k")
3053         return 1/factorial(
3054             n - 1)*Sum((-1)**k*binomial(n, k)*(x - k)**(n - 1), (k, 0, floor(x)))
3055 
3056     def _cdf(self, x):
3057         n = self.n
3058         k = Dummy("k")
3059         return Piecewise((S.Zero, x < 0),
3060                         (1/factorial(n)*Sum((-1)**k*binomial(n, k)*(x - k)**(n),
3061                         (k, 0, floor(x))), x <= n),
3062                         (S.One, True))
3063 
3064     def _characteristic_function(self, t):
3065         return ((exp(I*t) - 1) / (I*t))**self.n
3066 
3067     def _moment_generating_function(self, t):
3068         return ((exp(t) - 1) / t)**self.n
3069 
3070 def UniformSum(name, n):
3071     r"""
3072     Create a continuous random variable with an Irwin-Hall distribution.
3073 
3074     The probability distribution function depends on a single parameter
3075     `n` which is an integer.
3076 
3077     The density of the Irwin-Hall distribution is given by
3078 
3079     .. math ::
3080         f(x) := \frac{1}{(n-1)!}\sum_{k=0}^{\left\lfloor x\right\rfloor}(-1)^k
3081                 \binom{n}{k}(x-k)^{n-1}
3082 
3083     Parameters
3084     ==========
3085 
3086     n : A positive Integer, `n > 0`
3087 
3088     Returns
3089     =======
3090 
3091     A RandomSymbol.
3092 
3093     Examples
3094     ========
3095 
3096     >>> from sympy.stats import UniformSum, density, cdf
3097     >>> from sympy import Symbol, pprint
3098 
3099     >>> n = Symbol("n", integer=True)
3100     >>> z = Symbol("z")
3101 
3102     >>> X = UniformSum("x", n)
3103 
3104     >>> D = density(X)(z)
3105     >>> pprint(D, use_unicode=False)
3106     floor(z)
3107       ___
3108       \  `
3109        \         k         n - 1 /n\
3110         )    (-1) *(-k + z)     *| |
3111        /                         \k/
3112       /__,
3113      k = 0
3114     --------------------------------
3115                 (n - 1)!
3116 
3117     >>> cdf(X)(z)
3118     Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),
3119                     (_k, 0, floor(z)))/factorial(n), n >= z), (1, True))
3120 
3121 
3122     Compute cdf with specific 'x' and 'n' values as follows :
3123     >>> cdf(UniformSum("x", 5), evaluate=False)(2).doit()
3124     9/40
3125 
3126     The argument evaluate=False prevents an attempt at evaluation
3127     of the sum for general n, before the argument 2 is passed.
3128 
3129     References
3130     ==========
3131 
3132     .. [1] https://en.wikipedia.org/wiki/Uniform_sum_distribution
3133     .. [2] http://mathworld.wolfram.com/UniformSumDistribution.html
3134 
3135     """
3136 
3137     return rv(name, UniformSumDistribution, (n, ))
3138 
3139 #-------------------------------------------------------------------------------
3140 # VonMises distribution --------------------------------------------------------
3141 
3142 
3143 class VonMisesDistribution(SingleContinuousDistribution):
3144     _argnames = ('mu', 'k')
3145 
3146     set = Interval(0, 2*pi)
3147 
3148     @staticmethod
3149     def check(mu, k):
3150         _value_check(k > 0, "k must be positive")
3151 
3152     def pdf(self, x):
3153         mu, k = self.mu, self.k
3154         return exp(k*cos(x-mu)) / (2*pi*besseli(0, k))
3155 
3156 def VonMises(name, mu, k):
3157     r"""
3158     Create a Continuous Random Variable with a von Mises distribution.
3159 
3160     The density of the von Mises distribution is given by
3161 
3162     .. math::
3163         f(x) := \frac{e^{\kappa\cos(x-\mu)}}{2\pi I_0(\kappa)}
3164 
3165     with :math:`x \in [0,2\pi]`.
3166 
3167     Parameters
3168     ==========
3169 
3170     mu : Real number, measure of location
3171     k : Real number, measure of concentration
3172 
3173     Returns
3174     =======
3175 
3176     A RandomSymbol.
3177 
3178     Examples
3179     ========
3180 
3181     >>> from sympy.stats import VonMises, density, E, variance
3182     >>> from sympy import Symbol, simplify, pprint
3183 
3184     >>> mu = Symbol("mu")
3185     >>> k = Symbol("k", positive=True)
3186     >>> z = Symbol("z")
3187 
3188     >>> X = VonMises("x", mu, k)
3189 
3190     >>> D = density(X)(z)
3191     >>> pprint(D, use_unicode=False)
3192          k*cos(mu - z)
3193         e
3194     ------------------
3195     2*pi*besseli(0, k)
3196 
3197 
3198     References
3199     ==========
3200 
3201     .. [1] https://en.wikipedia.org/wiki/Von_Mises_distribution
3202     .. [2] http://mathworld.wolfram.com/vonMisesDistribution.html
3203 
3204     """
3205 
3206     return rv(name, VonMisesDistribution, (mu, k))
3207 
3208 #-------------------------------------------------------------------------------
3209 # Weibull distribution ---------------------------------------------------------
3210 
3211 
3212 class WeibullDistribution(SingleContinuousDistribution):
3213     _argnames = ('alpha', 'beta')
3214 
3215     set = Interval(0, oo)
3216 
3217     @staticmethod
3218     def check(alpha, beta):
3219         _value_check(alpha > 0, "Alpha must be positive")
3220         _value_check(beta > 0, "Beta must be positive")
3221 
3222     def pdf(self, x):
3223         alpha, beta = self.alpha, self.beta
3224         return beta * (x/alpha)**(beta - 1) * exp(-(x/alpha)**beta) / alpha
3225 
3226     def sample(self):
3227         return random.weibullvariate(self.alpha, self.beta)
3228 
3229 def Weibull(name, alpha, beta):
3230     r"""
3231     Create a continuous random variable with a Weibull distribution.
3232 
3233     The density of the Weibull distribution is given by
3234 
3235     .. math::
3236         f(x) := \begin{cases}
3237                   \frac{k}{\lambda}\left(\frac{x}{\lambda}\right)^{k-1}
3238                   e^{-(x/\lambda)^{k}} & x\geq0\\
3239                   0 & x<0
3240                 \end{cases}
3241 
3242     Parameters
3243     ==========
3244 
3245     lambda : Real number, :math:`\lambda > 0` a scale
3246     k : Real number, `k > 0` a shape
3247 
3248     Returns
3249     =======
3250 
3251     A RandomSymbol.
3252 
3253     Examples
3254     ========
3255 
3256     >>> from sympy.stats import Weibull, density, E, variance
3257     >>> from sympy import Symbol, simplify
3258 
3259     >>> l = Symbol("lambda", positive=True)
3260     >>> k = Symbol("k", positive=True)
3261     >>> z = Symbol("z")
3262 
3263     >>> X = Weibull("x", l, k)
3264 
3265     >>> density(X)(z)
3266     k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda
3267 
3268     >>> simplify(E(X))
3269     lambda*gamma(1 + 1/k)
3270 
3271     >>> simplify(variance(X))
3272     lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k))
3273 
3274     References
3275     ==========
3276 
3277     .. [1] https://en.wikipedia.org/wiki/Weibull_distribution
3278     .. [2] http://mathworld.wolfram.com/WeibullDistribution.html
3279 
3280     """
3281 
3282     return rv(name, WeibullDistribution, (alpha, beta))
3283 
3284 #-------------------------------------------------------------------------------
3285 # Wigner semicircle distribution -----------------------------------------------
3286 
3287 
3288 class WignerSemicircleDistribution(SingleContinuousDistribution):
3289     _argnames = ('R',)
3290 
3291     @property
3292     def set(self):
3293         return Interval(-self.R, self.R)
3294 
3295     def pdf(self, x):
3296         R = self.R
3297         return 2/(pi*R**2)*sqrt(R**2 - x**2)
3298 
3299     def _characteristic_function(self, t):
3300         return Piecewise((2 * besselj(1, self.R*t) / (self.R*t), Ne(t, 0)),
3301                          (S.One, True))
3302 
3303     def _moment_generating_function(self, t):
3304         return Piecewise((2 * besseli(1, self.R*t) / (self.R*t), Ne(t, 0)),
3305                          (S.One, True))
3306 
3307 def WignerSemicircle(name, R):
3308     r"""
3309     Create a continuous random variable with a Wigner semicircle distribution.
3310 
3311     The density of the Wigner semicircle distribution is given by
3312 
3313     .. math::
3314         f(x) := \frac2{\pi R^2}\,\sqrt{R^2-x^2}
3315 
3316     with :math:`x \in [-R,R]`.
3317 
3318     Parameters
3319     ==========
3320 
3321     R : Real number, `R > 0`, the radius
3322 
3323     Returns
3324     =======
3325 
3326     A `RandomSymbol`.
3327 
3328     Examples
3329     ========
3330 
3331     >>> from sympy.stats import WignerSemicircle, density, E
3332     >>> from sympy import Symbol, simplify
3333 
3334     >>> R = Symbol("R", positive=True)
3335     >>> z = Symbol("z")
3336 
3337     >>> X = WignerSemicircle("x", R)
3338 
3339     >>> density(X)(z)
3340     2*sqrt(R**2 - z**2)/(pi*R**2)
3341 
3342     >>> E(X)
3343     0
3344 
3345     References
3346     ==========
3347 
3348     .. [1] https://en.wikipedia.org/wiki/Wigner_semicircle_distribution
3349     .. [2] http://mathworld.wolfram.com/WignersSemicircleLaw.html
3350 
3351     """
3352 
3353     return rv(name, WignerSemicircleDistribution, (R,))

</code><intended_behavior>Enhance the `check` methods to include all necessary validations for the parameters of each continuous distribution. Ensure that inappropriate values raise appropriate errors or warnings. Additionally, ensure that all relevant attributes are correctly set and accessible for these distributions.</intended_behavior>, <file>sympy/stats/drv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 
3 Contains
4 ========
5 Geometric
6 Poisson
7 Logarithmic
8 NegativeBinomial
9 Poisson
10 YuleSimon
11 Zeta
12 """
13 
14 
15 from __future__ import print_function, division
16 
17 from sympy import (factorial, exp, S, sympify, And, I, zeta, polylog, log, beta,
18     hyper, binomial, Piecewise, floor)
19 from sympy.stats import density
20 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace
21 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
22 from sympy.stats.rv import _value_check, RandomSymbol
23 import random
24 
25 __all__ = ['Geometric',
26 'Logarithmic',
27 'NegativeBinomial',
28 'Poisson',
29 'YuleSimon',
30 'Zeta'
31 ]
32 
33 
34 def rv(symbol, cls, *args):
35     args = list(map(sympify, args))
36     dist = cls(*args)
37     dist.check(*args)
38     pspace = SingleDiscretePSpace(symbol, dist)
39     if any(isinstance(arg, RandomSymbol) for arg in args):
40         pspace = JointPSpace(symbol, CompoundDistribution(dist))
41     return pspace.value
42 
43 
44 #-------------------------------------------------------------------------------
45 # Geometric distribution ------------------------------------------------------------
46 
47 class GeometricDistribution(SingleDiscreteDistribution):
48     _argnames = ('p',)
49     set = S.Naturals
50 
51     @staticmethod
52     def check(p):
53         _value_check((0 < p, p <= 1), "p must be between 0 and 1")
54 
55     def pdf(self, k):
56         return (1 - self.p)**(k - 1) * self.p
57 
58     def _characteristic_function(self, t):
59         p = self.p
60         return p * exp(I*t) / (1 - (1 - p)*exp(I*t))
61 
62     def _moment_generating_function(self, t):
63         p = self.p
64         return p * exp(t) / (1 - (1 - p) * exp(t))
65 
66 def Geometric(name, p):
67     r"""
68     Create a discrete random variable with a Geometric distribution.
69 
70     The density of the Geometric distribution is given by
71 
72     .. math::
73         f(k) := p (1 - p)^{k - 1}
74 
75     Parameters
76     ==========
77 
78     p: A probability between 0 and 1
79 
80     Returns
81     =======
82 
83     A RandomSymbol.
84 
85     Examples
86     ========
87 
88     >>> from sympy.stats import Geometric, density, E, variance
89     >>> from sympy import Symbol, S
90 
91     >>> p = S.One / 5
92     >>> z = Symbol("z")
93 
94     >>> X = Geometric("x", p)
95 
96     >>> density(X)(z)
97     (4/5)**(z - 1)/5
98 
99     >>> E(X)
100     5
101 
102     >>> variance(X)
103     20
104 
105     References
106     ==========
107 
108     .. [1] https://en.wikipedia.org/wiki/Geometric_distribution
109     .. [2] http://mathworld.wolfram.com/GeometricDistribution.html
110 
111     """
112     return rv(name, GeometricDistribution, p)
113 
114 
115 #-------------------------------------------------------------------------------
116 # Logarithmic distribution ------------------------------------------------------------
117 
118 class LogarithmicDistribution(SingleDiscreteDistribution):
119     _argnames = ('p',)
120 
121     set = S.Naturals
122 
123     @staticmethod
124     def check(p):
125         _value_check((p > 0, p < 1), "p should be between 0 and 1")
126 
127     def pdf(self, k):
128         p = self.p
129         return (-1) * p**k / (k * log(1 - p))
130 
131     def _characteristic_function(self, t):
132         p = self.p
133         return log(1 - p * exp(I*t)) / log(1 - p)
134 
135     def _moment_generating_function(self, t):
136         p = self.p
137         return log(1 - p * exp(t)) / log(1 - p)
138 
139     def sample(self):
140         ### TODO
141         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
142 
143 
144 def Logarithmic(name, p):
145     r"""
146     Create a discrete random variable with a Logarithmic distribution.
147 
148     The density of the Logarithmic distribution is given by
149 
150     .. math::
151         f(k) := \frac{-p^k}{k \ln{(1 - p)}}
152 
153     Parameters
154     ==========
155 
156     p: A value between 0 and 1
157 
158     Returns
159     =======
160 
161     A RandomSymbol.
162 
163     Examples
164     ========
165 
166     >>> from sympy.stats import Logarithmic, density, E, variance
167     >>> from sympy import Symbol, S
168 
169     >>> p = S.One / 5
170     >>> z = Symbol("z")
171 
172     >>> X = Logarithmic("x", p)
173 
174     >>> density(X)(z)
175     -5**(-z)/(z*log(4/5))
176 
177     >>> E(X)
178     -1/(-4*log(5) + 8*log(2))
179 
180     >>> variance(X)
181     -1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2))
182 
183     References
184     ==========
185 
186     .. [1] https://en.wikipedia.org/wiki/Logarithmic_distribution
187     .. [2] http://mathworld.wolfram.com/LogarithmicDistribution.html
188 
189     """
190     return rv(name, LogarithmicDistribution, p)
191 
192 
193 #-------------------------------------------------------------------------------
194 # Negative binomial distribution ------------------------------------------------------------
195 
196 class NegativeBinomialDistribution(SingleDiscreteDistribution):
197     _argnames = ('r', 'p')
198     set = S.Naturals0
199 
200     @staticmethod
201     def check(r, p):
202         _value_check(r > 0, 'r should be positive')
203         _value_check((p > 0, p < 1), 'p should be between 0 and 1')
204 
205     def pdf(self, k):
206         r = self.r
207         p = self.p
208 
209         return binomial(k + r - 1, k) * (1 - p)**r * p**k
210 
211     def _characteristic_function(self, t):
212         r = self.r
213         p = self.p
214 
215         return ((1 - p) / (1 - p * exp(I*t)))**r
216 
217     def _moment_generating_function(self, t):
218         r = self.r
219         p = self.p
220 
221         return ((1 - p) / (1 - p * exp(t)))**r
222 
223     def sample(self):
224         ### TODO
225         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
226 
227 
228 def NegativeBinomial(name, r, p):
229     r"""
230     Create a discrete random variable with a Negative Binomial distribution.
231 
232     The density of the Negative Binomial distribution is given by
233 
234     .. math::
235         f(k) := \binom{k + r - 1}{k} (1 - p)^r p^k
236 
237     Parameters
238     ==========
239 
240     r: A positive value
241     p: A value between 0 and 1
242 
243     Returns
244     =======
245 
246     A RandomSymbol.
247 
248     Examples
249     ========
250 
251     >>> from sympy.stats import NegativeBinomial, density, E, variance
252     >>> from sympy import Symbol, S
253 
254     >>> r = 5
255     >>> p = S.One / 5
256     >>> z = Symbol("z")
257 
258     >>> X = NegativeBinomial("x", r, p)
259 
260     >>> density(X)(z)
261     1024*5**(-z)*binomial(z + 4, z)/3125
262 
263     >>> E(X)
264     5/4
265 
266     >>> variance(X)
267     25/16
268 
269     References
270     ==========
271 
272     .. [1] https://en.wikipedia.org/wiki/Negative_binomial_distribution
273     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
274 
275     """
276     return rv(name, NegativeBinomialDistribution, r, p)
277 
278 
279 #-------------------------------------------------------------------------------
280 # Poisson distribution ------------------------------------------------------------
281 
282 class PoissonDistribution(SingleDiscreteDistribution):
283     _argnames = ('lamda',)
284 
285     set = S.Naturals0
286 
287     @staticmethod
288     def check(lamda):
289         _value_check(lamda > 0, "Lambda must be positive")
290 
291     def pdf(self, k):
292         return self.lamda**k / factorial(k) * exp(-self.lamda)
293 
294     def sample(self):
295         def search(x, y, u):
296             while x < y:
297                 mid = (x + y)//2
298                 if u <= self.cdf(mid):
299                     y = mid
300                 else:
301                     x = mid + 1
302             return x
303 
304         u = random.uniform(0, 1)
305         if u <= self.cdf(S.Zero):
306             return S.Zero
307         n = S.One
308         while True:
309             if u > self.cdf(2*n):
310                 n *= 2
311             else:
312                 return search(n, 2*n, u)
313 
314     def _characteristic_function(self, t):
315         return exp(self.lamda * (exp(I*t) - 1))
316 
317     def _moment_generating_function(self, t):
318         return exp(self.lamda * (exp(t) - 1))
319 
320 
321 def Poisson(name, lamda):
322     r"""
323     Create a discrete random variable with a Poisson distribution.
324 
325     The density of the Poisson distribution is given by
326 
327     .. math::
328         f(k) := \frac{\lambda^{k} e^{- \lambda}}{k!}
329 
330     Parameters
331     ==========
332 
333     lamda: Positive number, a rate
334 
335     Returns
336     =======
337 
338     A RandomSymbol.
339 
340     Examples
341     ========
342 
343     >>> from sympy.stats import Poisson, density, E, variance
344     >>> from sympy import Symbol, simplify
345 
346     >>> rate = Symbol("lambda", positive=True)
347     >>> z = Symbol("z")
348 
349     >>> X = Poisson("x", rate)
350 
351     >>> density(X)(z)
352     lambda**z*exp(-lambda)/factorial(z)
353 
354     >>> E(X)
355     lambda
356 
357     >>> simplify(variance(X))
358     lambda
359 
360     References
361     ==========
362 
363     .. [1] https://en.wikipedia.org/wiki/Poisson_distribution
364     .. [2] http://mathworld.wolfram.com/PoissonDistribution.html
365 
366     """
367     return rv(name, PoissonDistribution, lamda)
368 
369 
370 #-------------------------------------------------------------------------------
371 # Yule-Simon distribution ------------------------------------------------------------
372 
373 class YuleSimonDistribution(SingleDiscreteDistribution):
374     _argnames = ('rho',)
375     set = S.Naturals
376 
377     @staticmethod
378     def check(rho):
379         _value_check(rho > 0, 'rho should be positive')
380 
381     def pdf(self, k):
382         rho = self.rho
383         return rho * beta(k, rho + 1)
384 
385     def _cdf(self, x):
386         return Piecewise((1 - floor(x) * beta(floor(x), self.rho + 1), x >= 1), (0, True))
387 
388     def _characteristic_function(self, t):
389         rho = self.rho
390         return rho * hyper((1, 1), (rho + 2,), exp(I*t)) * exp(I*t) / (rho + 1)
391 
392     def _moment_generating_function(self, t):
393         rho = self.rho
394         return rho * hyper((1, 1), (rho + 2,), exp(t)) * exp(t) / (rho + 1)
395 
396     def sample(self):
397         ### TODO
398         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
399 
400 
401 def YuleSimon(name, rho):
402     r"""
403     Create a discrete random variable with a Yule-Simon distribution.
404 
405     The density of the Yule-Simon distribution is given by
406 
407     .. math::
408         f(k) := \rho B(k, \rho + 1)
409 
410     Parameters
411     ==========
412 
413     rho: A positive value
414 
415     Returns
416     =======
417 
418     A RandomSymbol.
419 
420     Examples
421     ========
422 
423     >>> from sympy.stats import YuleSimon, density, E, variance
424     >>> from sympy import Symbol, simplify
425 
426     >>> p = 5
427     >>> z = Symbol("z")
428 
429     >>> X = YuleSimon("x", p)
430 
431     >>> density(X)(z)
432     5*beta(z, 6)
433 
434     >>> simplify(E(X))
435     5/4
436 
437     >>> simplify(variance(X))
438     25/48
439 
440     References
441     ==========
442 
443     .. [1] https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution
444 
445     """
446     return rv(name, YuleSimonDistribution, rho)
447 
448 
449 #-------------------------------------------------------------------------------
450 # Zeta distribution ------------------------------------------------------------
451 
452 class ZetaDistribution(SingleDiscreteDistribution):
453     _argnames = ('s',)
454     set = S.Naturals
455 
456     @staticmethod
457     def check(s):
458         _value_check(s > 1, 's should be greater than 1')
459 
460     def pdf(self, k):
461         s = self.s
462         return 1 / (k**s * zeta(s))
463 
464     def _characteristic_function(self, t):
465         return polylog(self.s, exp(I*t)) / zeta(self.s)
466 
467     def _moment_generating_function(self, t):
468         return polylog(self.s, exp(t)) / zeta(self.s)
469 
470     def sample(self):
471         ### TODO
472         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
473 
474 
475 def Zeta(name, s):
476     r"""
477     Create a discrete random variable with a Zeta distribution.
478 
479     The density of the Zeta distribution is given by
480 
481     .. math::
482         f(k) := \frac{1}{k^s \zeta{(s)}}
483 
484     Parameters
485     ==========
486 
487     s: A value greater than 1
488 
489     Returns
490     =======
491 
492     A RandomSymbol.
493 
494     Examples
495     ========
496 
497     >>> from sympy.stats import Zeta, density, E, variance
498     >>> from sympy import Symbol
499 
500     >>> s = 5
501     >>> z = Symbol("z")
502 
503     >>> X = Zeta("x", s)
504 
505     >>> density(X)(z)
506     1/(z**5*zeta(5))
507 
508     >>> E(X)
509     pi**4/(90*zeta(5))
510 
511     >>> variance(X)
512     -pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5)
513 
514     References
515     ==========
516 
517     .. [1] https://en.wikipedia.org/wiki/Zeta_distribution
518 
519     """
520     return rv(name, ZetaDistribution, s)

</code><intended_behavior>Similar to `crv_types.py`, validations within `check` methods should be exhaustive, covering the domain of possible parameters to prevent invalid configurations. Ensure attributes related to the distributions are correctly implemented and documented.</intended_behavior>, <file>sympy/stats/joint_rv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, Gt, IndexedBase,
2                     besselk, gamma, Interval, Range, factorial, Mul, Integer,
3                     Add, rf, Eq, Piecewise, Symbol, imageset, Intersection)
4 from sympy.matrices import ImmutableMatrix
5 from sympy.matrices.expressions.determinant import det
6 from sympy.stats.joint_rv import (JointDistribution, JointPSpace,
7     JointDistributionHandmade, MarginalDistribution)
8 from sympy.stats.rv import _value_check, random_symbols
9 
10 # __all__ = ['MultivariateNormal',
11 # 'MultivariateLaplace',
12 # 'MultivariateT',
13 # 'NormalGamma'
14 # ]
15 
16 def multivariate_rv(cls, sym, *args):
17     args = list(map(sympify, args))
18     dist = cls(*args)
19     args = dist.args
20     dist.check(*args)
21     return JointPSpace(sym, dist).value
22 
23 def JointRV(symbol, pdf, _set=None):
24     """
25     Create a Joint Random Variable where each of its component is conitinuous,
26     given the following:
27 
28     -- a symbol
29     -- a PDF in terms of indexed symbols of the symbol given
30      as the first argument
31 
32     NOTE: As of now, the set for each component for a `JointRV` is
33     equal to the set of all integers, which can not be changed.
34 
35     Returns a RandomSymbol.
36 
37     Examples
38     ========
39 
40     >>> from sympy import symbols, exp, pi, Indexed, S
41     >>> from sympy.stats import density
42     >>> from sympy.stats.joint_rv_types import JointRV
43 
44     >>> x1, x2 = (Indexed('x', i) for i in (1, 2))
45     >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)
46 
47     >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution
48     >>> density(N1)(1, 2)
49     exp(-2)/(2*pi)
50     """
51     #TODO: Add support for sets provided by the user
52     symbol = sympify(symbol)
53     syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)
54         and i.base == IndexedBase(symbol))
55     syms.sort(key = lambda index: index.args[1])
56     _set = S.Reals**len(syms)
57     pdf = Lambda(syms, pdf)
58     dist = JointDistributionHandmade(pdf, _set)
59     jrv = JointPSpace(symbol, dist).value
60     rvs = random_symbols(pdf)
61     if len(rvs) != 0:
62         dist = MarginalDistribution(dist, (jrv,))
63         return JointPSpace(symbol, dist).value
64     return jrv
65 
66 #-------------------------------------------------------------------------------
67 # Multivariate Normal distribution ---------------------------------------------------------
68 
69 class MultivariateNormalDistribution(JointDistribution):
70     _argnames = ['mu', 'sigma']
71 
72     is_Continuous=True
73 
74     @property
75     def set(self):
76         k = len(self.mu)
77         return S.Reals**k
78 
79     def check(self, mu, sigma):
80         _value_check(len(mu) == len(sigma.col(0)),
81             "Size of the mean vector and covariance matrix are incorrect.")
82         #check if covariance matrix is positive definite or not.
83         _value_check((i > 0 for i in sigma.eigenvals().keys()),
84             "The covariance matrix must be positive definite. ")
85 
86     def pdf(self, *args):
87         mu, sigma = self.mu, self.sigma
88         k = len(mu)
89         args = ImmutableMatrix(args)
90         x = args - mu
91         return  S(1)/sqrt((2*pi)**(k)*det(sigma))*exp(
92             -S(1)/2*x.transpose()*(sigma.inv()*\
93                 x))[0]
94 
95     def marginal_distribution(self, indices, sym):
96         sym = ImmutableMatrix([Indexed(sym, i) for i in indices])
97         _mu, _sigma = self.mu, self.sigma
98         k = len(self.mu)
99         for i in range(k):
100             if i not in indices:
101                 _mu = _mu.row_del(i)
102                 _sigma = _sigma.col_del(i)
103                 _sigma = _sigma.row_del(i)
104         return Lambda(sym, S(1)/sqrt((2*pi)**(len(_mu))*det(_sigma))*exp(
105             -S(1)/2*(_mu - sym).transpose()*(_sigma.inv()*\
106                 (_mu - sym)))[0])
107 
108 #-------------------------------------------------------------------------------
109 # Multivariate Laplace distribution ---------------------------------------------------------
110 
111 class MultivariateLaplaceDistribution(JointDistribution):
112     _argnames = ['mu', 'sigma']
113     is_Continuous=True
114 
115     @property
116     def set(self):
117         k = len(self.mu)
118         return S.Reals**k
119 
120     def check(self, mu, sigma):
121         _value_check(len(mu) == len(sigma.col(0)),
122             "Size of the mean vector and covariance matrix are incorrect.")
123         #check if covariance matrix is positive definite or not.
124         _value_check((i > 0 for i in sigma.eigenvals().keys()),
125             "The covariance matrix must be positive definite. ")
126 
127     def pdf(self, *args):
128         mu, sigma = self.mu, self.sigma
129         mu_T = mu.transpose()
130         k = S(len(mu))
131         sigma_inv = sigma.inv()
132         args = ImmutableMatrix(args)
133         args_T = args.transpose()
134         x = (mu_T*sigma_inv*mu)[0]
135         y = (args_T*sigma_inv*args)[0]
136         v = 1 - k/2
137         return S(2)/((2*pi)**(S(k)/2)*sqrt(det(sigma)))\
138         *(y/(2 + x))**(S(v)/2)*besselk(v, sqrt((2 + x)*(y)))\
139         *exp((args_T*sigma_inv*mu)[0])
140 
141 
142 #-------------------------------------------------------------------------------
143 # Multivariate StudentT distribution ---------------------------------------------------------
144 
145 class MultivariateTDistribution(JointDistribution):
146     _argnames = ['mu', 'shape_mat', 'dof']
147     is_Continuous=True
148 
149     @property
150     def set(self):
151         k = len(self.mu)
152         return S.Reals**k
153 
154     def check(self, mu, sigma, v):
155         _value_check(len(mu) == len(sigma.col(0)),
156             "Size of the location vector and shape matrix are incorrect.")
157         #check if covariance matrix is positive definite or not.
158         _value_check((i > 0 for i in sigma.eigenvals().keys()),
159             "The shape matrix must be positive definite. ")
160 
161     def pdf(self, *args):
162         mu, sigma = self.mu, self.shape_mat
163         v = S(self.dof)
164         k = S(len(mu))
165         sigma_inv = sigma.inv()
166         args = ImmutableMatrix(args)
167         x = args - mu
168         return gamma((k + v)/2)/(gamma(v/2)*(v*pi)**(k/2)*sqrt(det(sigma)))\
169         *(1 + 1/v*(x.transpose()*sigma_inv*x)[0])**((-v - k)/2)
170 
171 def MultivariateT(syms, mu, sigma, v):
172     """
173     Creates a joint random variable with multivariate T-distribution.
174 
175     Parameters
176     ==========
177 
178     syms: list/tuple/set of symbols for identifying each component
179     mu: A list/tuple/set consisting of k means,represents a k
180         dimensional location vector
181     sigma: The shape matrix for the distribution
182 
183     Returns
184     =======
185 
186     A random symbol
187     """
188     return multivariate_rv(MultivariateTDistribution, syms, mu, sigma, v)
189 
190 
191 #-------------------------------------------------------------------------------
192 # Multivariate Normal Gamma distribution ---------------------------------------------------------
193 
194 class NormalGammaDistribution(JointDistribution):
195 
196     _argnames = ['mu', 'lamda', 'alpha', 'beta']
197     is_Continuous=True
198 
199     def check(self, mu, lamda, alpha, beta):
200         _value_check(mu.is_real, "Location must be real.")
201         _value_check(lamda > 0, "Lambda must be positive")
202         _value_check(alpha > 0, "alpha must be positive")
203         _value_check(beta > 0, "beta must be positive")
204 
205     @property
206     def set(self):
207         return S.Reals*Interval(0, S.Infinity)
208 
209     def pdf(self, x, tau):
210         beta, alpha, lamda = self.beta, self.alpha, self.lamda
211         mu = self.mu
212 
213         return beta**alpha*sqrt(lamda)/(gamma(alpha)*sqrt(2*pi))*\
214         tau**(alpha - S(1)/2)*exp(-1*beta*tau)*\
215         exp(-1*(lamda*tau*(x - mu)**2)/S(2))
216 
217     def marginal_distribution(self, indices, *sym):
218         if len(indices) == 2:
219             return self.pdf(*sym)
220         if indices[0] == 0:
221             #For marginal over `x`, return non-standardized Student-T's
222             #distribution
223             x = sym[0]
224             v, mu, sigma = self.alpha - S(1)/2, self.mu, \
225                 S(self.beta)/(self.lamda * self.alpha)
226             return Lambda(sym, gamma((v + 1)/2)/(gamma(v/2)*sqrt(pi*v)*sigma)*\
227                 (1 + 1/v*((x - mu)/sigma)**2)**((-v -1)/2))
228         #For marginal over `tau`, return Gamma distribution as per construction
229         from sympy.stats.crv_types import GammaDistribution
230         return Lambda(sym, GammaDistribution(self.alpha, self.beta)(sym[0]))
231 
232 def NormalGamma(syms, mu, lamda, alpha, beta):
233     """
234     Creates a bivariate joint random variable with multivariate Normal gamma
235     distribution.
236 
237     Parameters
238     ==========
239 
240     syms: list/tuple/set of two symbols for identifying each component
241     mu: A real number, as the mean of the normal distribution
242     alpha: a positive integer
243     beta: a positive integer
244     lamda: a positive integer
245 
246     Returns
247     =======
248 
249     A random symbol
250     """
251     return multivariate_rv(NormalGammaDistribution, syms, mu, lamda, alpha, beta)
252 
253 #-------------------------------------------------------------------------------
254 # Multivariate Beta/Dirichlet distribution ---------------------------------------------------------
255 
256 class MultivariateBetaDistribution(JointDistribution):
257 
258     _argnames = ['alpha']
259     is_Continuous = True
260 
261     def check(self, alpha):
262         _value_check(len(alpha) >= 2, "At least two categories should be passed.")
263         for a_k in alpha:
264             _value_check((a_k > 0) != False, "Each concentration parameter"
265                                             " should be positive.")
266 
267     @property
268     def set(self):
269         k = len(self.alpha)
270         return Interval(0, 1)**k
271 
272     def pdf(self, *syms):
273         alpha = self.alpha
274         B = Mul.fromiter(map(gamma, alpha))/gamma(Add(*alpha))
275         return Mul.fromiter([sym**(a_k - 1) for a_k, sym in zip(alpha, syms)])/B
276 
277 def MultivariateBeta(syms, *alpha):
278     """
279     Creates a continuous random variable with Dirichlet/Multivariate Beta
280     Distribution.
281 
282     The density of the dirichlet distribution can be found at [1].
283 
284     Parameters
285     ==========
286 
287     alpha: positive real numbers signifying concentration numbers.
288 
289     Returns
290     =======
291 
292     A RandomSymbol.
293 
294     Examples
295     ========
296 
297     >>> from sympy.stats import density
298     >>> from sympy.stats.joint_rv import marginal_distribution
299     >>> from sympy.stats.joint_rv_types import MultivariateBeta
300     >>> from sympy import Symbol
301     >>> a1 = Symbol('a1', positive=True)
302     >>> a2 = Symbol('a2', positive=True)
303     >>> B = MultivariateBeta('B', [a1, a2])
304     >>> C = MultivariateBeta('C', a1, a2)
305     >>> x = Symbol('x')
306     >>> y = Symbol('y')
307     >>> density(B)(x, y)
308     x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))
309     >>> marginal_distribution(C, C[0])(x)
310     x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))
311 
312     References
313     ==========
314 
315     .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution
316     .. [2] http://mathworld.wolfram.com/DirichletDistribution.html
317 
318     """
319     if not isinstance(alpha[0], list):
320         alpha = (list(alpha),)
321     return multivariate_rv(MultivariateBetaDistribution, syms, alpha[0])
322 
323 Dirichlet = MultivariateBeta
324 
325 #-------------------------------------------------------------------------------
326 # Multivariate Ewens distribution ---------------------------------------------------------
327 
328 class MultivariateEwensDistribution(JointDistribution):
329 
330     _argnames = ['n', 'theta']
331     is_Discrete = True
332     is_Continuous = False
333 
334     def check(self, n, theta):
335         _value_check(isinstance(n, Integer) and (n > 0) == True,
336                         "sample size should be positive integer.")
337         _value_check(theta.is_positive, "mutation rate should be positive.")
338 
339     @property
340     def set(self):
341         prod_set = Range(0, self.n//1 + 1)
342         for i in range(2, self.n + 1):
343             prod_set *= Range(0, self.n//i + 1)
344         return prod_set
345 
346     def pdf(self, *syms):
347         n, theta = self.n, self.theta
348         term_1 = factorial(n)/rf(theta, n)
349         term_2 = Mul.fromiter([theta**syms[j]/((j+1)**syms[j]*factorial(syms[j]))
350                             for j in range(n)])
351         cond = Eq(sum([(k+1)*syms[k] for k in range(n)]), n)
352         return Piecewise((term_1 * term_2, cond), (0, True))
353 
354 def MultivariateEwens(syms, n, theta):
355     """
356     Creates a discrete random variable with Multivariate Ewens
357     Distribution.
358 
359     The density of the said distribution can be found at [1].
360 
361     Parameters
362     ==========
363 
364     n: positive integer of class Integer,
365             size of the sample or the integer whose partitions are considered
366     theta: mutation rate, must be positive real number.
367 
368     Returns
369     =======
370 
371     A RandomSymbol.
372 
373     Examples
374     ========
375 
376     >>> from sympy.stats import density
377     >>> from sympy.stats.joint_rv import marginal_distribution
378     >>> from sympy.stats.joint_rv_types import MultivariateEwens
379     >>> from sympy import Symbol
380     >>> a1 = Symbol('a1', positive=True)
381     >>> a2 = Symbol('a2', positive=True)
382     >>> ed = MultivariateEwens('E', 2, 1)
383     >>> density(ed)(a1, a2)
384     Piecewise((2**(-a2)/(factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))
385     >>> marginal_distribution(ed, ed[0])(a1)
386     Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True))
387 
388     References
389     ==========
390 
391     .. [1] https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula
392     .. [2] http://www.stat.rutgers.edu/home/hcrane/Papers/STS529.pdf
393 
394     """
395     return multivariate_rv(MultivariateEwensDistribution, syms, n, theta)
396 
397 #-------------------------------------------------------------------------------
398 # Multinomial distribution ---------------------------------------------------------
399 
400 class MultinomialDistribution(JointDistribution):
401 
402     _argnames = ['n', 'p']
403     is_Continuous=False
404     is_Discrete = True
405 
406     def check(self, n, p):
407         _value_check(n > 0,
408                         "number of trials must be a positve integer")
409         for p_k in p:
410             _value_check((p_k >= 0, p_k <= 1),
411                         "probability must be in range [0, 1]")
412         _value_check(Eq(sum(p), 1),
413                         "probabilities must sum to 1")
414 
415     @property
416     def set(self):
417         return Intersection(S.Naturals0, Interval(0, self.n))**len(self.p)
418 
419     def pdf(self, *x):
420         n, p = self.n, self.p
421         term_1 = factorial(n)/Mul.fromiter([factorial(x_k) for x_k in x])
422         term_2 = Mul.fromiter([p_k**x_k for p_k, x_k in zip(p, x)])
423         return Piecewise((term_1 * term_2, Eq(sum(x), n)), (0, True))
424 
425 def Multinomial(syms, n, *p):
426     """
427     Creates a discrete random variable with Multinomial Distribution.
428 
429     The density of the said distribution can be found at [1].
430 
431     Parameters
432     ==========
433     n: positive integer of class Integer,
434        number of trials
435     p: event probabilites, >= 0 and <= 1
436 
437     Returns
438     =======
439     A RandomSymbol.
440 
441     Examples
442     ========
443     >>> from sympy.stats import density
444     >>> from sympy.stats.joint_rv import marginal_distribution
445     >>> from sympy.stats.joint_rv_types import Multinomial
446     >>> from sympy import symbols
447     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
448     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
449     >>> M = Multinomial('M', 3, p1, p2, p3)
450     >>> density(M)(x1, x2, x3)
451     Piecewise((6*p1**x1*p2**x2*p3**x3/(factorial(x1)*factorial(x2)*factorial(x3)),
452     Eq(x1 + x2 + x3, 3)), (0, True))
453     >>> marginal_distribution(M, M[0])(x1).subs(x1, 1)
454     3*p1*p2**2 + 6*p1*p2*p3 + 3*p1*p3**2
455 
456     References
457     ==========
458     .. [1] https://en.wikipedia.org/wiki/Multinomial_distribution
459     .. [2] http://mathworld.wolfram.com/MultinomialDistribution.html
460     """
461     if not isinstance(p[0], list):
462         p = (list(p), )
463     return multivariate_rv(MultinomialDistribution, syms, n, p[0])
464 
465 #-------------------------------------------------------------------------------
466 # Negative Multinomial Distribution ---------------------------------------------------------
467 
468 class NegativeMultinomialDistribution(JointDistribution):
469 
470     _argnames = ['k0', 'p']
471     is_Continuous=False
472     is_Discrete = True
473 
474     def check(self, k0, p):
475         _value_check(k0 > 0,
476                         "number of failures must be a positve integer")
477         for p_k in p:
478             _value_check((p_k >= 0, p_k <= 1),
479                         "probability must be in range [0, 1].")
480         _value_check(sum(p) <= 1,
481                         "success probabilities must not be greater than 1.")
482 
483     @property
484     def set(self):
485         return Range(0, S.Infinity)**len(self.p)
486 
487     def pdf(self, *k):
488         k0, p = self.k0, self.p
489         term_1 = (gamma(k0 + sum(k))*(1 - sum(p))**k0)/gamma(k0)
490         term_2 = Mul.fromiter([pi**ki/factorial(ki) for pi, ki in zip(p, k)])
491         return term_1 * term_2
492 
493 def NegativeMultinomial(syms, k0, *p):
494     """
495     Creates a discrete random variable with Negative Multinomial Distribution.
496 
497     The density of the said distribution can be found at [1].
498 
499     Parameters
500     ==========
501     k0: positive integer of class Integer,
502         number of failures before the experiment is stopped
503     p: event probabilites, >= 0 and <= 1
504 
505     Returns
506     =======
507     A RandomSymbol.
508 
509     Examples
510     ========
511     >>> from sympy.stats import density
512     >>> from sympy.stats.joint_rv import marginal_distribution
513     >>> from sympy.stats.joint_rv_types import NegativeMultinomial
514     >>> from sympy import symbols
515     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
516     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
517     >>> N = NegativeMultinomial('M', 3, p1, p2, p3)
518     >>> N_c = NegativeMultinomial('M', 3, 0.1, 0.1, 0.1)
519     >>> density(N)(x1, x2, x3)
520     p1**x1*p2**x2*p3**x3*(-p1 - p2 - p3 + 1)**3*gamma(x1 + x2 +
521     x3 + 3)/(2*factorial(x1)*factorial(x2)*factorial(x3))
522     >>> marginal_distribution(N_c, N_c[0])(1).evalf().round(2)
523     0.25
524 
525 
526     References
527     ==========
528     .. [1] https://en.wikipedia.org/wiki/Negative_multinomial_distribution
529     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
530     """
531     if not isinstance(p[0], list):
532         p = (list(p), )
533     return multivariate_rv(NegativeMultinomialDistribution, syms, k0, p[0])

</code><intended_behavior>Validate parameters considering their interactions within the joint distributions. This might involve more complex checks to ensure that the parameters of one distribution are compatible with the parameters of another within a joint distribution. Implementation of attributes that clarify these relationships and their constraints is also necessary.</intended_behavior>, <file>sympy/stats/frv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Finite Discrete Random Variables - Prebuilt variable types
3 
4 Contains
5 ========
6 FiniteRV
7 DiscreteUniform
8 Die
9 Bernoulli
10 Coin
11 Binomial
12 Hypergeometric
13 Rademacher
14 """
15 
16 from __future__ import print_function, division
17 
18 from sympy import (S, sympify, Rational, binomial, cacheit, Integer,
19         Dict, Basic, KroneckerDelta, Dummy, Eq)
20 from sympy.concrete.summations import Sum
21 from sympy.core.compatibility import as_int, range
22 from sympy.stats.rv import _value_check
23 from sympy.stats.frv import (SingleFinitePSpace, SingleFiniteDistribution)
24 
25 __all__ = ['FiniteRV',
26 'DiscreteUniform',
27 'Die',
28 'Bernoulli',
29 'Coin',
30 'Binomial',
31 'Hypergeometric',
32 'Rademacher'
33 ]
34 
35 def rv(name, cls, *args):
36     args = list(map(sympify, args))
37     i = 0
38     while i < len(args): # Converting to Dict since dict is not hashable
39         if isinstance(args[i], dict):
40             args[i] = Dict(args[i])
41         i += 1
42     dist = cls(*args)
43     dist.check(*args)
44     return SingleFinitePSpace(name, dist).value
45 
46 class FiniteDistributionHandmade(SingleFiniteDistribution):
47     @property
48     def dict(self):
49         return self.args[0]
50 
51     @staticmethod
52     def check(density):
53         for p in density.values():
54             _value_check((p >= 0, p <= 1),
55                         "Probability at a point must be between 0 and 1.")
56         _value_check(Eq(sum(density.values()), 1), "Total Probability must be 1.")
57 
58 def FiniteRV(name, density):
59     """
60     Create a Finite Random Variable given a dict representing the density.
61 
62     Returns a RandomSymbol.
63 
64     >>> from sympy.stats import FiniteRV, P, E
65 
66     >>> density = {0: .1, 1: .2, 2: .3, 3: .4}
67     >>> X = FiniteRV('X', density)
68 
69     >>> E(X)
70     2.00000000000000
71     >>> P(X >= 2)
72     0.700000000000000
73     """
74     return rv(name, FiniteDistributionHandmade, density)
75 
76 class DiscreteUniformDistribution(SingleFiniteDistribution):
77     @property
78     def p(self):
79         return Rational(1, len(self.args))
80 
81     @property
82     @cacheit
83     def dict(self):
84         return dict((k, self.p) for k in self.set)
85 
86     @property
87     def set(self):
88         return self.args
89 
90     def pdf(self, x):
91         if x in self.args:
92             return self.p
93         else:
94             return S.Zero
95 
96 
97 def DiscreteUniform(name, items):
98     """
99     Create a Finite Random Variable representing a uniform distribution over
100     the input set.
101 
102     Returns a RandomSymbol.
103 
104     Examples
105     ========
106 
107     >>> from sympy.stats import DiscreteUniform, density
108     >>> from sympy import symbols
109 
110     >>> X = DiscreteUniform('X', symbols('a b c')) # equally likely over a, b, c
111     >>> density(X).dict
112     {a: 1/3, b: 1/3, c: 1/3}
113 
114     >>> Y = DiscreteUniform('Y', list(range(5))) # distribution over a range
115     >>> density(Y).dict
116     {0: 1/5, 1: 1/5, 2: 1/5, 3: 1/5, 4: 1/5}
117 
118     References
119     ==========
120 
121     .. [1] https://en.wikipedia.org/wiki/Discrete_uniform_distribution
122     .. [2] http://mathworld.wolfram.com/DiscreteUniformDistribution.html
123 
124     """
125     return rv(name, DiscreteUniformDistribution, *items)
126 
127 
128 class DieDistribution(SingleFiniteDistribution):
129     _argnames = ('sides',)
130 
131     @staticmethod
132     def check(sides):
133         _value_check((sides.is_positive, sides.is_integer),
134                     "number of sides must be a positive integer.")
135 
136     @property
137     @cacheit
138     def dict(self):
139         as_int(self.sides) # Check that self.sides can be converted to an integer
140         return super(DieDistribution, self).dict
141 
142     @property
143     def set(self):
144         return list(map(Integer, list(range(1, self.sides + 1))))
145 
146     def pdf(self, x):
147         x = sympify(x)
148         if x.is_number:
149             if x.is_Integer and x >= 1 and x <= self.sides:
150                 return Rational(1, self.sides)
151             return S.Zero
152         if x.is_Symbol:
153             i = Dummy('i', integer=True, positive=True)
154             return Sum(KroneckerDelta(x, i)/self.sides, (i, 1, self.sides))
155         raise ValueError("'x' expected as an argument of type 'number' or 'symbol', "
156                         "not %s" % (type(x)))
157 
158 
159 def Die(name, sides=6):
160     """
161     Create a Finite Random Variable representing a fair die.
162 
163     Returns a RandomSymbol.
164 
165     Examples
166     ========
167 
168     >>> from sympy.stats import Die, density
169 
170     >>> D6 = Die('D6', 6) # Six sided Die
171     >>> density(D6).dict
172     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}
173 
174     >>> D4 = Die('D4', 4) # Four sided Die
175     >>> density(D4).dict
176     {1: 1/4, 2: 1/4, 3: 1/4, 4: 1/4}
177     """
178 
179     return rv(name, DieDistribution, sides)
180 
181 
182 class BernoulliDistribution(SingleFiniteDistribution):
183     _argnames = ('p', 'succ', 'fail')
184 
185     @staticmethod
186     def check(p, succ, fail):
187         _value_check((p >= 0, p <= 1),
188                     "p should be in range [0, 1].")
189 
190     @property
191     @cacheit
192     def dict(self):
193         return {self.succ: self.p, self.fail: 1 - self.p}
194 
195 
196 def Bernoulli(name, p, succ=1, fail=0):
197     """
198     Create a Finite Random Variable representing a Bernoulli process.
199 
200     Returns a RandomSymbol
201 
202     Examples
203     ========
204 
205     >>> from sympy.stats import Bernoulli, density
206     >>> from sympy import S
207 
208     >>> X = Bernoulli('X', S(3)/4) # 1-0 Bernoulli variable, probability = 3/4
209     >>> density(X).dict
210     {0: 1/4, 1: 3/4}
211 
212     >>> X = Bernoulli('X', S.Half, 'Heads', 'Tails') # A fair coin toss
213     >>> density(X).dict
214     {Heads: 1/2, Tails: 1/2}
215 
216     References
217     ==========
218 
219     .. [1] https://en.wikipedia.org/wiki/Bernoulli_distribution
220     .. [2] http://mathworld.wolfram.com/BernoulliDistribution.html
221 
222     """
223 
224     return rv(name, BernoulliDistribution, p, succ, fail)
225 
226 
227 def Coin(name, p=S.Half):
228     """
229     Create a Finite Random Variable representing a Coin toss.
230 
231     Probability p is the chance of gettings "Heads." Half by default
232 
233     Returns a RandomSymbol.
234 
235     Examples
236     ========
237 
238     >>> from sympy.stats import Coin, density
239     >>> from sympy import Rational
240 
241     >>> C = Coin('C') # A fair coin toss
242     >>> density(C).dict
243     {H: 1/2, T: 1/2}
244 
245     >>> C2 = Coin('C2', Rational(3, 5)) # An unfair coin
246     >>> density(C2).dict
247     {H: 3/5, T: 2/5}
248 
249     See Also
250     ========
251 
252     sympy.stats.Binomial
253 
254     References
255     ==========
256 
257     .. [1] https://en.wikipedia.org/wiki/Coin_flipping
258 
259     """
260     return rv(name, BernoulliDistribution, p, 'H', 'T')
261 
262 
263 class BinomialDistribution(SingleFiniteDistribution):
264     _argnames = ('n', 'p', 'succ', 'fail')
265 
266     @staticmethod
267     def check(n, p, succ, fail):
268         _value_check((n.is_integer, n.is_nonnegative),
269                     "'n' must be nonnegative integer.")
270         _value_check((p <= 1, p >= 0),
271                     "p should be in range [0, 1].")
272 
273     @property
274     @cacheit
275     def dict(self):
276         n, p, succ, fail = self.n, self.p, self.succ, self.fail
277         n = as_int(n)
278         return dict((k*succ + (n - k)*fail,
279                 binomial(n, k) * p**k * (1 - p)**(n - k)) for k in range(0, n + 1))
280 
281 
282 def Binomial(name, n, p, succ=1, fail=0):
283     """
284     Create a Finite Random Variable representing a binomial distribution.
285 
286     Returns a RandomSymbol.
287 
288     Examples
289     ========
290 
291     >>> from sympy.stats import Binomial, density
292     >>> from sympy import S
293 
294     >>> X = Binomial('X', 4, S.Half) # Four "coin flips"
295     >>> density(X).dict
296     {0: 1/16, 1: 1/4, 2: 3/8, 3: 1/4, 4: 1/16}
297 
298     References
299     ==========
300 
301     .. [1] https://en.wikipedia.org/wiki/Binomial_distribution
302     .. [2] http://mathworld.wolfram.com/BinomialDistribution.html
303 
304     """
305 
306     return rv(name, BinomialDistribution, n, p, succ, fail)
307 
308 
309 class HypergeometricDistribution(SingleFiniteDistribution):
310     _argnames = ('N', 'm', 'n')
311 
312     @property
313     @cacheit
314     def dict(self):
315         N, m, n = self.N, self.m, self.n
316         N, m, n = list(map(sympify, (N, m, n)))
317         density = dict((sympify(k),
318                         Rational(binomial(m, k) * binomial(N - m, n - k),
319                                  binomial(N, n)))
320                         for k in range(max(0, n + m - N), min(m, n) + 1))
321         return density
322 
323 
324 def Hypergeometric(name, N, m, n):
325     """
326     Create a Finite Random Variable representing a hypergeometric distribution.
327 
328     Returns a RandomSymbol.
329 
330     Examples
331     ========
332 
333     >>> from sympy.stats import Hypergeometric, density
334     >>> from sympy import S
335 
336     >>> X = Hypergeometric('X', 10, 5, 3) # 10 marbles, 5 white (success), 3 draws
337     >>> density(X).dict
338     {0: 1/12, 1: 5/12, 2: 5/12, 3: 1/12}
339 
340     References
341     ==========
342 
343     .. [1] https://en.wikipedia.org/wiki/Hypergeometric_distribution
344     .. [2] http://mathworld.wolfram.com/HypergeometricDistribution.html
345 
346     """
347     return rv(name, HypergeometricDistribution, N, m, n)
348 
349 
350 class RademacherDistribution(SingleFiniteDistribution):
351     @property
352     @cacheit
353     def dict(self):
354         return {-1: S.Half, 1: S.Half}
355 
356 
357 def Rademacher(name):
358     """
359     Create a Finite Random Variable representing a Rademacher distribution.
360 
361     Return a RandomSymbol.
362 
363     Examples
364     ========
365 
366     >>> from sympy.stats import Rademacher, density
367 
368     >>> X = Rademacher('X')
369     >>> density(X).dict
370     {-1: 1/2, 1: 1/2}
371 
372     See Also
373     ========
374 
375     sympy.stats.Bernoulli
376 
377     References
378     ==========
379 
380     .. [1] https://en.wikipedia.org/wiki/Rademacher_distribution
381 
382     """
383     return rv(name, RademacherDistribution)

</code><intended_behavior>Ensure completeness in parameter checking, especially since finite distributions might have specific constraints on their parameters. Attributes related to these distributions should be clear and follow consistent patterns as in other distribution types.</intended_behavior>]
2025-10-18 20:15:11.283 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 20:15:11.283 | INFO     | Search-only: skipping patch selection
2025-10-18 20:15:11.367 | INFO     | Task sympy__sympy-16858 completed successfully.
2025-10-18 20:15:11.368 | INFO     | No patch generated. You can try running ACR again.
