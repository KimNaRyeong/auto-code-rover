2025-10-18 13:31:27.339 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 13:31:30.646 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1310, output_tokens=12, cost=0.013460
2025-10-18 13:31:42.057 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1490, output_tokens=573, cost=0.032090
2025-10-18 13:31:43.196 | INFO     | registered non reproducing test 0
2025-10-18 13:32:04.404 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2891, output_tokens=1066, cost=0.060890
2025-10-18 13:32:05.522 | INFO     | registered non reproducing test 1
2025-10-18 13:32:30.803 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2927, output_tokens=1037, cost=0.060380
2025-10-18 13:32:31.940 | INFO     | registered non reproducing test 2
2025-10-18 13:32:31.940 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 13:32:31.946 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:32:39.389 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1608, output_tokens=276, cost=0.024360
2025-10-18 13:32:39.395 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:32:41.350 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=630, output_tokens=37, cost=0.007410
2025-10-18 13:32:41.351 | DEBUG    | Extracted a valid json.
2025-10-18 13:32:41.351 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Incident\")",
        "search_code(\"migrations.RenameModel\")"
    ],
    "bug_locations": []
}
2025-10-18 13:32:41.395 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:32:41.396 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:32:55.154 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2139, output_tokens=630, cost=0.040290
2025-10-18 13:32:55.166 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:33:04.281 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2985, output_tokens=402, cost=0.041910
2025-10-18 13:33:04.289 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:33:12.135 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=756, output_tokens=320, cost=0.017160
2025-10-18 13:33:12.136 | DEBUG    | Extracted a valid json.
2025-10-18 13:33:12.136 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "vault/app/migrations directory",
            "class": "",
            "method": "",
            "intended_behavior": "The `RenameModel` operation should not only rename the model but also ensure that any related fields, especially those involved in M2M relationships, are adequately handled. This might involve explicitly renaming M2M relationship tables or fields to reflect the new model name. Alternatively, a custom migration operation might need to be written to tackle the nuances of renaming models involved in such relationships."
        },
        {
            "file": "incidents/models.py",
            "class": "Incident",
            "method": "",
            "intended_behavior": "While not directly a location of a bug, these models' structure and their relationships will need review to ensure that the renaming process considers how these models refer to each other, especially if automatic field names are generated for M2M tables. Any custom handling or explicit field naming that can prevent name clashes during migrations should be considered."
        },
        {
            "file": "vault/models.py",
            "class": "Incident",
            "method": "",
            "intended_behavior": "While not directly a location of a bug, these models' structure and their relationships will need review to ensure that the renaming process considers how these models refer to each other, especially if automatic field names are generated for M2M tables. Any custom handling or explicit field naming that can prevent name clashes during migrations should be considered."
        }
    ]
}
2025-10-18 13:33:12.141 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 13:33:12.142 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 13:33:12.142 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:33:23.880 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3421, output_tokens=452, cost=0.047770
2025-10-18 13:33:23.888 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:33:26.201 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=806, output_tokens=50, cost=0.009560
2025-10-18 13:33:26.202 | DEBUG    | Extracted a valid json.
2025-10-18 13:33:26.202 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"RenameModel\", \"vault/migrations/0002_rename_incident_folder.py\")",
        "search_code(\"ManyToManyField\")"
    ],
    "bug_locations": []
}
2025-10-18 13:33:26.298 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:33:26.298 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:33:43.371 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4377, output_tokens=660, cost=0.063570
2025-10-18 13:33:43.377 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:33:57.292 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5253, output_tokens=577, cost=0.069840
2025-10-18 13:33:57.302 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:34:01.373 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=165, cost=0.014260
2025-10-18 13:34:01.375 | DEBUG    | Extracted a valid json.
2025-10-18 13:34:01.375 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "Not specified",
            "class": "Djangoâ€™s migration system",
            "method": "handling `RenameModel` operations interacting with `ManyToManyField` relationships",
            "intended_behavior": "The code responsible for executing `RenameModel` migration operations should ensure that all references to the old model name are updated, including in automatically generated fields and tables for ManyToMany relationships. This includes the correct handling of `from_<model_name>_id` and `to_<model_name>_id` fields in the intermediary table for M2M relationships. It should also ensure that any attempt to dynamically reference models by their string names correctly accounts for renamed models, particularly during and after the migration process."
        }
    ]
}
2025-10-18 13:34:01.380 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 13:34:01.381 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 13:34:01.381 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:34:05.779 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5864, output_tokens=174, cost=0.063860
2025-10-18 13:34:05.783 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:34:08.633 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=528, output_tokens=14, cost=0.005700
2025-10-18 13:34:08.634 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:08.634 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 13:34:10.612 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=528, output_tokens=14, cost=0.005700
2025-10-18 13:34:10.613 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:10.613 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 13:34:12.168 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=528, output_tokens=14, cost=0.005700
2025-10-18 13:34:12.169 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:12.169 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 13:34:13.764 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=528, output_tokens=14, cost=0.005700
2025-10-18 13:34:13.765 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:13.765 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 13:34:16.565 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=528, output_tokens=14, cost=0.005700
2025-10-18 13:34:16.566 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:16.566 | DEBUG    | Agent proxy return the following json: None
2025-10-18 13:34:16.566 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 13:34:16.567 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 13:34:16.567 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:34:25.941 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6065, output_tokens=337, cost=0.070760
2025-10-18 13:34:25.947 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:34:27.594 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=691, output_tokens=14, cost=0.007330
2025-10-18 13:34:27.595 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:27.595 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 13:34:31.679 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=691, output_tokens=151, cost=0.011440
2025-10-18 13:34:31.680 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-18 13:34:31.686 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 13:34:36.665 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=691, output_tokens=153, cost=0.011500
2025-10-18 13:34:36.666 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-18 13:34:36.666 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 13:34:38.207 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=691, output_tokens=14, cost=0.007330
2025-10-18 13:34:38.208 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:38.208 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 13:34:39.585 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=691, output_tokens=14, cost=0.007330
2025-10-18 13:34:39.586 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:34:39.586 | DEBUG    | Agent proxy return the following json: None
2025-10-18 13:34:39.587 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 13:34:39.587 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 13:34:39.588 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:34:49.504 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6429, output_tokens=390, cost=0.075990
2025-10-18 13:34:49.511 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:34:52.998 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=744, output_tokens=67, cost=0.009450
2025-10-18 13:34:52.999 | DEBUG    | Extracted a valid json.
2025-10-18 13:34:52.999 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"RenameModel\", \"vault/migrations/*.py\")",
        "search_code_in_file(\"class Incident\", \"incidents/models.py\")",
        "search_code_in_file(\"class Incident\", \"vault/models.py\")"
    ],
    "bug_locations": []
}
2025-10-18 13:34:53.004 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:34:53.005 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:35:09.501 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7019, output_tokens=661, cost=0.090020
2025-10-18 13:35:09.514 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:35:22.058 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7896, output_tokens=474, cost=0.093180
2025-10-18 13:35:22.067 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:35:27.591 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=828, output_tokens=205, cost=0.014430
2025-10-18 13:35:27.592 | DEBUG    | Extracted a valid json.
2025-10-18 13:35:27.592 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "Migration files within the `vault` app",
            "class": "Django migration operation classes",
            "method": "",
            "intended_behavior": "Ensure that `RenameModel` operations within migrations accurately update references to the renamed model across all parts of the application, including any ManyToManyField tables that reference the model. This includes updating both 'from' and 'to' references in the case of self-referential or inter-app M2M tables. Specifically, for M2M relationships, the migration logic should rename these intermediary table references or column names to reflect the new model name. Thorough testing and validation are required to ensure all references to the old model name are updated, including in the Django ORM layer, admin interfaces, and any raw SQL queries within the application. Validate the integrity of M2M relationships post-migration to ensure no data associations are lost or corrupted."
        }
    ]
}
2025-10-18 13:35:27.595 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 13:35:27.596 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 13:35:27.596 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:35:31.647 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8404, output_tokens=134, cost=0.088060
2025-10-18 13:35:31.651 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:35:34.867 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 13:35:34.868 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:35:34.868 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 13:35:37.514 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 13:35:37.515 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:35:37.515 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 13:35:40.541 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 13:35:40.542 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:35:40.542 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 13:35:41.947 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 13:35:41.948 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:35:41.948 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 13:35:45.260 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-18 13:35:45.261 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 13:35:45.261 | DEBUG    | Agent proxy return the following json: None
2025-10-18 13:35:45.262 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 13:35:45.263 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 13:35:45.263 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:35:57.470 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8565, output_tokens=465, cost=0.099600
2025-10-18 13:35:57.479 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:36:00.967 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=819, output_tokens=83, cost=0.010680
2025-10-18 13:36:00.969 | DEBUG    | Extracted a valid json.
2025-10-18 13:36:00.969 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file('Incident', 'incidents/models.py')",
        "search_class_in_file('Incident', 'vault/models.py')",
        "search_code_in_file('RenameModel', 'vault/migrations/')",
        "search_method('ManyToManyField')",
        "search_code('RenameModel')"
    ],
    "bug_locations": []
}
2025-10-18 13:36:01.024 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:36:01.025 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:36:19.654 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9362, output_tokens=728, cost=0.115460
2025-10-18 13:36:19.665 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:36:35.217 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10306, output_tokens=569, cost=0.120130
2025-10-18 13:36:35.228 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:36:43.644 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=923, output_tokens=377, cost=0.020540
2025-10-18 13:36:43.645 | DEBUG    | Extracted a valid json.
2025-10-18 13:36:43.645 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/migrations/operations/models.py",
            "class": "RenameModel",
            "method": "",
            "intended_behavior": "The `RenameModel` operation should not only rename the model and update the table name in the database but also ensure that all references to the model, including those in intermediary tables for M2M relationships, are updated. This might involve enhancing the operation to identify and modify table column names or constraints that reference the old model name, ensuring consistency throughout the database schema."
        },
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "method responsible for detecting model renaming and suggesting `RenameModel` operations",
            "intended_behavior": "This component should detect when a model involved in a M2M relationship is being renamed and either automatically generate additional operations to handle the renaming of related fields in intermediary tables or alert the developer to the need for manual intervention. The detection algorithm could be improved to anticipate the complications of renaming models involved in complex relationships and provide more comprehensive migration steps to maintain integrity."
        },
        {
            "file": "django/contrib/contenttypes/management/__init__.py",
            "class": "",
            "method": "part of the code that updates ContentType records following model renames",
            "intended_behavior": "While this area might not be directly involved in the specific KeyError reported, ensuring that ContentType records are accurately updated during model renames is crucial for the overall integrity of Django's content type framework, especially in applications relying heavily on generic relations. The intended behavior is a thorough update process that reflects model renaming across all ContentType references, which could indirectly affect M2M relationships through generic ForeignKey fields."
        }
    ]
}
2025-10-18 13:36:43.662 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/operations/models.py</file>
<class>RenameModel</class>
<method>None</method>
<code>
344 class RenameModel(ModelOperation):
345     """Rename a model."""
346 
347     def __init__(self, old_name, new_name):
348         self.old_name = old_name
349         self.new_name = new_name
350         super().__init__(old_name)
351 
352     @cached_property
353     def old_name_lower(self):
354         return self.old_name.lower()
355 
356     @cached_property
357     def new_name_lower(self):
358         return self.new_name.lower()
359 
360     def deconstruct(self):
361         kwargs = {
362             "old_name": self.old_name,
363             "new_name": self.new_name,
364         }
365         return (self.__class__.__qualname__, [], kwargs)
366 
367     def state_forwards(self, app_label, state):
368         state.rename_model(app_label, self.old_name, self.new_name)
369 
370     def database_forwards(self, app_label, schema_editor, from_state, to_state):
371         new_model = to_state.apps.get_model(app_label, self.new_name)
372         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
373             old_model = from_state.apps.get_model(app_label, self.old_name)
374             # Move the main table
375             schema_editor.alter_db_table(
376                 new_model,
377                 old_model._meta.db_table,
378                 new_model._meta.db_table,
379             )
380             # Alter the fields pointing to us
381             for related_object in old_model._meta.related_objects:
382                 if related_object.related_model == old_model:
383                     model = new_model
384                     related_key = (app_label, self.new_name_lower)
385                 else:
386                     model = related_object.related_model
387                     related_key = (
388                         related_object.related_model._meta.app_label,
389                         related_object.related_model._meta.model_name,
390                     )
391                 to_field = to_state.apps.get_model(*related_key)._meta.get_field(
392                     related_object.field.name
393                 )
394                 schema_editor.alter_field(
395                     model,
396                     related_object.field,
397                     to_field,
398                 )
399             # Rename M2M fields whose name is based on this model's name.
400             fields = zip(
401                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
402             )
403             for old_field, new_field in fields:
404                 # Skip self-referential fields as these are renamed above.
405                 if (
406                     new_field.model == new_field.related_model
407                     or not new_field.remote_field.through._meta.auto_created
408                 ):
409                     continue
410                 # Rename the M2M table that's based on this model's name.
411                 old_m2m_model = old_field.remote_field.through
412                 new_m2m_model = new_field.remote_field.through
413                 schema_editor.alter_db_table(
414                     new_m2m_model,
415                     old_m2m_model._meta.db_table,
416                     new_m2m_model._meta.db_table,
417                 )
418                 # Rename the column in the M2M table that's based on this
419                 # model's name.
420                 schema_editor.alter_field(
421                     new_m2m_model,
422                     old_m2m_model._meta.get_field(old_model._meta.model_name),
423                     new_m2m_model._meta.get_field(new_model._meta.model_name),
424                 )
425 
426     def database_backwards(self, app_label, schema_editor, from_state, to_state):
427         self.new_name_lower, self.old_name_lower = (
428             self.old_name_lower,
429             self.new_name_lower,
430         )
431         self.new_name, self.old_name = self.old_name, self.new_name
432 
433         self.database_forwards(app_label, schema_editor, from_state, to_state)
434 
435         self.new_name_lower, self.old_name_lower = (
436             self.old_name_lower,
437             self.new_name_lower,
438         )
439         self.new_name, self.old_name = self.old_name, self.new_name
440 
441     def references_model(self, name, app_label):
442         return (
443             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
444         )
445 
446     def describe(self):
447         return "Rename model %s to %s" % (self.old_name, self.new_name)
448 
449     @property
450     def migration_name_fragment(self):
451         return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
452 
453     def reduce(self, operation, app_label):
454         if (
455             isinstance(operation, RenameModel)
456             and self.new_name_lower == operation.old_name_lower
457         ):
458             return [
459                 RenameModel(
460                     self.old_name,
461                     operation.new_name,
462                 ),
463             ]
464         # Skip `ModelOperation.reduce` as we want to run `references_model`
465         # against self.new_name.
466         return super(ModelOperation, self).reduce(
467             operation, app_label
468         ) or not operation.references_model(self.new_name, app_label)

</code><intended_behavior>The `RenameModel` operation should not only rename the model and update the table name in the database but also ensure that all references to the model, including those in intermediary tables for M2M relationships, are updated. This might involve enhancing the operation to identify and modify table column names or constraints that reference the old model name, ensuring consistency throughout the database schema.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from graphlib import TopologicalSorter
5 from itertools import chain
6 
7 from django.conf import settings
8 from django.db import models
9 from django.db.migrations import operations
10 from django.db.migrations.migration import Migration
11 from django.db.migrations.operations.models import AlterModelOptions
12 from django.db.migrations.optimizer import MigrationOptimizer
13 from django.db.migrations.questioner import MigrationQuestioner
14 from django.db.migrations.utils import (
15     COMPILED_REGEX_TYPE,
16     RegexObject,
17     resolve_relation,
18 )
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173         self.generate_altered_db_table_comment()
174 
175         # Create the renamed fields and store them in self.renamed_fields.
176         # They are used by create_altered_indexes(), generate_altered_fields(),
177         # generate_removed_altered_index/unique_together(), and
178         # generate_altered_index/unique_together().
179         self.create_renamed_fields()
180         # Create the altered indexes and store them in self.altered_indexes.
181         # This avoids the same computation in generate_removed_indexes()
182         # and generate_added_indexes().
183         self.create_altered_indexes()
184         self.create_altered_constraints()
185         # Generate index removal operations before field is removed
186         self.generate_removed_constraints()
187         self.generate_removed_indexes()
188         # Generate field renaming operations.
189         self.generate_renamed_fields()
190         self.generate_renamed_indexes()
191         # Generate removal of foo together.
192         self.generate_removed_altered_unique_together()
193         self.generate_removed_altered_index_together()  # RemovedInDjango51Warning.
194         # Generate field operations.
195         self.generate_removed_fields()
196         self.generate_added_fields()
197         self.generate_altered_fields()
198         self.generate_altered_order_with_respect_to()
199         self.generate_altered_unique_together()
200         self.generate_altered_index_together()  # RemovedInDjango51Warning.
201         self.generate_added_indexes()
202         self.generate_added_constraints()
203         self.generate_altered_db_table()
204 
205         self._sort_migrations()
206         self._build_migration_list(graph)
207         self._optimize_migrations()
208 
209         return self.migrations
210 
211     def _prepare_field_lists(self):
212         """
213         Prepare field lists and a list of the fields that used through models
214         in the old state so dependencies can be made from the through model
215         deletion to the field that uses it.
216         """
217         self.kept_model_keys = self.old_model_keys & self.new_model_keys
218         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
219         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
220         self.through_users = {}
221         self.old_field_keys = {
222             (app_label, model_name, field_name)
223             for app_label, model_name in self.kept_model_keys
224             for field_name in self.from_state.models[
225                 app_label, self.renamed_models.get((app_label, model_name), model_name)
226             ].fields
227         }
228         self.new_field_keys = {
229             (app_label, model_name, field_name)
230             for app_label, model_name in self.kept_model_keys
231             for field_name in self.to_state.models[app_label, model_name].fields
232         }
233 
234     def _generate_through_model_map(self):
235         """Through model map generation."""
236         for app_label, model_name in sorted(self.old_model_keys):
237             old_model_name = self.renamed_models.get(
238                 (app_label, model_name), model_name
239             )
240             old_model_state = self.from_state.models[app_label, old_model_name]
241             for field_name, field in old_model_state.fields.items():
242                 if hasattr(field, "remote_field") and getattr(
243                     field.remote_field, "through", None
244                 ):
245                     through_key = resolve_relation(
246                         field.remote_field.through, app_label, model_name
247                     )
248                     self.through_users[through_key] = (
249                         app_label,
250                         old_model_name,
251                         field_name,
252                     )
253 
254     @staticmethod
255     def _resolve_dependency(dependency):
256         """
257         Return the resolved dependency and a boolean denoting whether or not
258         it was swappable.
259         """
260         if dependency[0] != "__setting__":
261             return dependency, False
262         resolved_app_label, resolved_object_name = getattr(
263             settings, dependency[1]
264         ).split(".")
265         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
266 
267     def _build_migration_list(self, graph=None):
268         """
269         Chop the lists of operations up into migrations with dependencies on
270         each other. Do this by going through an app's list of operations until
271         one is found that has an outgoing dependency that isn't in another
272         app's migration yet (hasn't been chopped off its list). Then chop off
273         the operations before it into a migration and move onto the next app.
274         If the loops completes without doing anything, there's a circular
275         dependency (which _should_ be impossible as the operations are
276         all split at this point so they can't depend and be depended on).
277         """
278         self.migrations = {}
279         num_ops = sum(len(x) for x in self.generated_operations.values())
280         chop_mode = False
281         while num_ops:
282             # On every iteration, we step through all the apps and see if there
283             # is a completed set of operations.
284             # If we find that a subset of the operations are complete we can
285             # try to chop it off from the rest and continue, but we only
286             # do this if we've already been through the list once before
287             # without any chopping and nothing has changed.
288             for app_label in sorted(self.generated_operations):
289                 chopped = []
290                 dependencies = set()
291                 for operation in list(self.generated_operations[app_label]):
292                     deps_satisfied = True
293                     operation_dependencies = set()
294                     for dep in operation._auto_deps:
295                         # Temporarily resolve the swappable dependency to
296                         # prevent circular references. While keeping the
297                         # dependency checks on the resolved model, add the
298                         # swappable dependencies.
299                         original_dep = dep
300                         dep, is_swappable_dep = self._resolve_dependency(dep)
301                         if dep[0] != app_label:
302                             # External app dependency. See if it's not yet
303                             # satisfied.
304                             for other_operation in self.generated_operations.get(
305                                 dep[0], []
306                             ):
307                                 if self.check_dependency(other_operation, dep):
308                                     deps_satisfied = False
309                                     break
310                             if not deps_satisfied:
311                                 break
312                             else:
313                                 if is_swappable_dep:
314                                     operation_dependencies.add(
315                                         (original_dep[0], original_dep[1])
316                                     )
317                                 elif dep[0] in self.migrations:
318                                     operation_dependencies.add(
319                                         (dep[0], self.migrations[dep[0]][-1].name)
320                                     )
321                                 else:
322                                     # If we can't find the other app, we add a
323                                     # first/last dependency, but only if we've
324                                     # already been through once and checked
325                                     # everything.
326                                     if chop_mode:
327                                         # If the app already exists, we add a
328                                         # dependency on the last migration, as
329                                         # we don't know which migration
330                                         # contains the target field. If it's
331                                         # not yet migrated or has no
332                                         # migrations, we use __first__.
333                                         if graph and graph.leaf_nodes(dep[0]):
334                                             operation_dependencies.add(
335                                                 graph.leaf_nodes(dep[0])[0]
336                                             )
337                                         else:
338                                             operation_dependencies.add(
339                                                 (dep[0], "__first__")
340                                             )
341                                     else:
342                                         deps_satisfied = False
343                     if deps_satisfied:
344                         chopped.append(operation)
345                         dependencies.update(operation_dependencies)
346                         del self.generated_operations[app_label][0]
347                     else:
348                         break
349                 # Make a migration! Well, only if there's stuff to put in it
350                 if dependencies or chopped:
351                     if not self.generated_operations[app_label] or chop_mode:
352                         subclass = type(
353                             "Migration",
354                             (Migration,),
355                             {"operations": [], "dependencies": []},
356                         )
357                         instance = subclass(
358                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
359                             app_label,
360                         )
361                         instance.dependencies = list(dependencies)
362                         instance.operations = chopped
363                         instance.initial = app_label not in self.existing_apps
364                         self.migrations.setdefault(app_label, []).append(instance)
365                         chop_mode = False
366                     else:
367                         self.generated_operations[app_label] = (
368                             chopped + self.generated_operations[app_label]
369                         )
370             new_num_ops = sum(len(x) for x in self.generated_operations.values())
371             if new_num_ops == num_ops:
372                 if not chop_mode:
373                     chop_mode = True
374                 else:
375                     raise ValueError(
376                         "Cannot resolve operation dependencies: %r"
377                         % self.generated_operations
378                     )
379             num_ops = new_num_ops
380 
381     def _sort_migrations(self):
382         """
383         Reorder to make things possible. Reordering may be needed so FKs work
384         nicely inside the same app.
385         """
386         for app_label, ops in sorted(self.generated_operations.items()):
387             ts = TopologicalSorter()
388             for op in ops:
389                 ts.add(op)
390                 for dep in op._auto_deps:
391                     # Resolve intra-app dependencies to handle circular
392                     # references involving a swappable model.
393                     dep = self._resolve_dependency(dep)[0]
394                     if dep[0] != app_label:
395                         continue
396                     ts.add(op, *(x for x in ops if self.check_dependency(x, dep)))
397             self.generated_operations[app_label] = list(ts.static_order())
398 
399     def _optimize_migrations(self):
400         # Add in internal dependencies among the migrations
401         for app_label, migrations in self.migrations.items():
402             for m1, m2 in zip(migrations, migrations[1:]):
403                 m2.dependencies.append((app_label, m1.name))
404 
405         # De-dupe dependencies
406         for migrations in self.migrations.values():
407             for migration in migrations:
408                 migration.dependencies = list(set(migration.dependencies))
409 
410         # Optimize migrations
411         for app_label, migrations in self.migrations.items():
412             for migration in migrations:
413                 migration.operations = MigrationOptimizer().optimize(
414                     migration.operations, app_label
415                 )
416 
417     def check_dependency(self, operation, dependency):
418         """
419         Return True if the given operation depends on the given dependency,
420         False otherwise.
421         """
422         # Created model
423         if dependency[2] is None and dependency[3] is True:
424             return (
425                 isinstance(operation, operations.CreateModel)
426                 and operation.name_lower == dependency[1].lower()
427             )
428         # Created field
429         elif dependency[2] is not None and dependency[3] is True:
430             return (
431                 isinstance(operation, operations.CreateModel)
432                 and operation.name_lower == dependency[1].lower()
433                 and any(dependency[2] == x for x, y in operation.fields)
434             ) or (
435                 isinstance(operation, operations.AddField)
436                 and operation.model_name_lower == dependency[1].lower()
437                 and operation.name_lower == dependency[2].lower()
438             )
439         # Removed field
440         elif dependency[2] is not None and dependency[3] is False:
441             return (
442                 isinstance(operation, operations.RemoveField)
443                 and operation.model_name_lower == dependency[1].lower()
444                 and operation.name_lower == dependency[2].lower()
445             )
446         # Removed model
447         elif dependency[2] is None and dependency[3] is False:
448             return (
449                 isinstance(operation, operations.DeleteModel)
450                 and operation.name_lower == dependency[1].lower()
451             )
452         # Field being altered
453         elif dependency[2] is not None and dependency[3] == "alter":
454             return (
455                 isinstance(operation, operations.AlterField)
456                 and operation.model_name_lower == dependency[1].lower()
457                 and operation.name_lower == dependency[2].lower()
458             )
459         # order_with_respect_to being unset for a field
460         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
461             return (
462                 isinstance(operation, operations.AlterOrderWithRespectTo)
463                 and operation.name_lower == dependency[1].lower()
464                 and (operation.order_with_respect_to or "").lower()
465                 != dependency[2].lower()
466             )
467         # Field is removed and part of an index/unique_together
468         elif dependency[2] is not None and dependency[3] == "foo_together_change":
469             return (
470                 isinstance(
471                     operation,
472                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
473                 )
474                 and operation.name_lower == dependency[1].lower()
475             )
476         # Unknown dependency. Raise an error.
477         else:
478             raise ValueError("Can't handle dependency %r" % (dependency,))
479 
480     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
481         # Dependencies are
482         # (app_label, model_name, field_name, create/delete as True/False)
483         operation._auto_deps = dependencies or []
484         if beginning:
485             self.generated_operations.setdefault(app_label, []).insert(0, operation)
486         else:
487             self.generated_operations.setdefault(app_label, []).append(operation)
488 
489     def swappable_first_key(self, item):
490         """
491         Place potential swappable models first in lists of created models (only
492         real way to solve #22783).
493         """
494         try:
495             model_state = self.to_state.models[item]
496             base_names = {
497                 base if isinstance(base, str) else base.__name__
498                 for base in model_state.bases
499             }
500             string_version = "%s.%s" % (item[0], item[1])
501             if (
502                 model_state.options.get("swappable")
503                 or "AbstractUser" in base_names
504                 or "AbstractBaseUser" in base_names
505                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
506             ):
507                 return ("___" + item[0], "___" + item[1])
508         except LookupError:
509             pass
510         return item
511 
512     def generate_renamed_models(self):
513         """
514         Find any renamed models, generate the operations for them, and remove
515         the old entry from the model lists. Must be run before other
516         model-level generation.
517         """
518         self.renamed_models = {}
519         self.renamed_models_rel = {}
520         added_models = self.new_model_keys - self.old_model_keys
521         for app_label, model_name in sorted(added_models):
522             model_state = self.to_state.models[app_label, model_name]
523             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
524 
525             removed_models = self.old_model_keys - self.new_model_keys
526             for rem_app_label, rem_model_name in removed_models:
527                 if rem_app_label == app_label:
528                     rem_model_state = self.from_state.models[
529                         rem_app_label, rem_model_name
530                     ]
531                     rem_model_fields_def = self.only_relation_agnostic_fields(
532                         rem_model_state.fields
533                     )
534                     if model_fields_def == rem_model_fields_def:
535                         if self.questioner.ask_rename_model(
536                             rem_model_state, model_state
537                         ):
538                             dependencies = []
539                             fields = list(model_state.fields.values()) + [
540                                 field.remote_field
541                                 for relations in self.to_state.relations[
542                                     app_label, model_name
543                                 ].values()
544                                 for field in relations.values()
545                             ]
546                             for field in fields:
547                                 if field.is_relation:
548                                     dependencies.extend(
549                                         self._get_dependencies_for_foreign_key(
550                                             app_label,
551                                             model_name,
552                                             field,
553                                             self.to_state,
554                                         )
555                                     )
556                             self.add_operation(
557                                 app_label,
558                                 operations.RenameModel(
559                                     old_name=rem_model_state.name,
560                                     new_name=model_state.name,
561                                 ),
562                                 dependencies=dependencies,
563                             )
564                             self.renamed_models[app_label, model_name] = rem_model_name
565                             renamed_models_rel_key = "%s.%s" % (
566                                 rem_model_state.app_label,
567                                 rem_model_state.name_lower,
568                             )
569                             self.renamed_models_rel[
570                                 renamed_models_rel_key
571                             ] = "%s.%s" % (
572                                 model_state.app_label,
573                                 model_state.name_lower,
574                             )
575                             self.old_model_keys.remove((rem_app_label, rem_model_name))
576                             self.old_model_keys.add((app_label, model_name))
577                             break
578 
579     def generate_created_models(self):
580         """
581         Find all new models (both managed and unmanaged) and make create
582         operations for them as well as separate operations to create any
583         foreign key or M2M relationships (these are optimized later, if
584         possible).
585 
586         Defer any model options that refer to collections of fields that might
587         be deferred (e.g. unique_together, index_together).
588         """
589         old_keys = self.old_model_keys | self.old_unmanaged_keys
590         added_models = self.new_model_keys - old_keys
591         added_unmanaged_models = self.new_unmanaged_keys - old_keys
592         all_added_models = chain(
593             sorted(added_models, key=self.swappable_first_key, reverse=True),
594             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
595         )
596         for app_label, model_name in all_added_models:
597             model_state = self.to_state.models[app_label, model_name]
598             # Gather related fields
599             related_fields = {}
600             primary_key_rel = None
601             for field_name, field in model_state.fields.items():
602                 if field.remote_field:
603                     if field.remote_field.model:
604                         if field.primary_key:
605                             primary_key_rel = field.remote_field.model
606                         elif not field.remote_field.parent_link:
607                             related_fields[field_name] = field
608                     if getattr(field.remote_field, "through", None):
609                         related_fields[field_name] = field
610 
611             # Are there indexes/unique|index_together to defer?
612             indexes = model_state.options.pop("indexes")
613             constraints = model_state.options.pop("constraints")
614             unique_together = model_state.options.pop("unique_together", None)
615             # RemovedInDjango51Warning.
616             index_together = model_state.options.pop("index_together", None)
617             order_with_respect_to = model_state.options.pop(
618                 "order_with_respect_to", None
619             )
620             # Depend on the deletion of any possible proxy version of us
621             dependencies = [
622                 (app_label, model_name, None, False),
623             ]
624             # Depend on all bases
625             for base in model_state.bases:
626                 if isinstance(base, str) and "." in base:
627                     base_app_label, base_name = base.split(".", 1)
628                     dependencies.append((base_app_label, base_name, None, True))
629                     # Depend on the removal of base fields if the new model has
630                     # a field with the same name.
631                     old_base_model_state = self.from_state.models.get(
632                         (base_app_label, base_name)
633                     )
634                     new_base_model_state = self.to_state.models.get(
635                         (base_app_label, base_name)
636                     )
637                     if old_base_model_state and new_base_model_state:
638                         removed_base_fields = (
639                             set(old_base_model_state.fields)
640                             .difference(
641                                 new_base_model_state.fields,
642                             )
643                             .intersection(model_state.fields)
644                         )
645                         for removed_base_field in removed_base_fields:
646                             dependencies.append(
647                                 (base_app_label, base_name, removed_base_field, False)
648                             )
649             # Depend on the other end of the primary key if it's a relation
650             if primary_key_rel:
651                 dependencies.append(
652                     resolve_relation(
653                         primary_key_rel,
654                         app_label,
655                         model_name,
656                     )
657                     + (None, True)
658                 )
659             # Generate creation operation
660             self.add_operation(
661                 app_label,
662                 operations.CreateModel(
663                     name=model_state.name,
664                     fields=[
665                         d
666                         for d in model_state.fields.items()
667                         if d[0] not in related_fields
668                     ],
669                     options=model_state.options,
670                     bases=model_state.bases,
671                     managers=model_state.managers,
672                 ),
673                 dependencies=dependencies,
674                 beginning=True,
675             )
676 
677             # Don't add operations which modify the database for unmanaged models
678             if not model_state.options.get("managed", True):
679                 continue
680 
681             # Generate operations for each related field
682             for name, field in sorted(related_fields.items()):
683                 dependencies = self._get_dependencies_for_foreign_key(
684                     app_label,
685                     model_name,
686                     field,
687                     self.to_state,
688                 )
689                 # Depend on our own model being created
690                 dependencies.append((app_label, model_name, None, True))
691                 # Make operation
692                 self.add_operation(
693                     app_label,
694                     operations.AddField(
695                         model_name=model_name,
696                         name=name,
697                         field=field,
698                     ),
699                     dependencies=list(set(dependencies)),
700                 )
701             # Generate other opns
702             if order_with_respect_to:
703                 self.add_operation(
704                     app_label,
705                     operations.AlterOrderWithRespectTo(
706                         name=model_name,
707                         order_with_respect_to=order_with_respect_to,
708                     ),
709                     dependencies=[
710                         (app_label, model_name, order_with_respect_to, True),
711                         (app_label, model_name, None, True),
712                     ],
713                 )
714             related_dependencies = [
715                 (app_label, model_name, name, True) for name in sorted(related_fields)
716             ]
717             related_dependencies.append((app_label, model_name, None, True))
718             for index in indexes:
719                 self.add_operation(
720                     app_label,
721                     operations.AddIndex(
722                         model_name=model_name,
723                         index=index,
724                     ),
725                     dependencies=related_dependencies,
726                 )
727             for constraint in constraints:
728                 self.add_operation(
729                     app_label,
730                     operations.AddConstraint(
731                         model_name=model_name,
732                         constraint=constraint,
733                     ),
734                     dependencies=related_dependencies,
735                 )
736             if unique_together:
737                 self.add_operation(
738                     app_label,
739                     operations.AlterUniqueTogether(
740                         name=model_name,
741                         unique_together=unique_together,
742                     ),
743                     dependencies=related_dependencies,
744                 )
745             # RemovedInDjango51Warning.
746             if index_together:
747                 self.add_operation(
748                     app_label,
749                     operations.AlterIndexTogether(
750                         name=model_name,
751                         index_together=index_together,
752                     ),
753                     dependencies=related_dependencies,
754                 )
755             # Fix relationships if the model changed from a proxy model to a
756             # concrete model.
757             relations = self.to_state.relations
758             if (app_label, model_name) in self.old_proxy_keys:
759                 for related_model_key, related_fields in relations[
760                     app_label, model_name
761                 ].items():
762                     related_model_state = self.to_state.models[related_model_key]
763                     for related_field_name, related_field in related_fields.items():
764                         self.add_operation(
765                             related_model_state.app_label,
766                             operations.AlterField(
767                                 model_name=related_model_state.name,
768                                 name=related_field_name,
769                                 field=related_field,
770                             ),
771                             dependencies=[(app_label, model_name, None, True)],
772                         )
773 
774     def generate_created_proxies(self):
775         """
776         Make CreateModel statements for proxy models. Use the same statements
777         as that way there's less code duplication, but for proxy models it's
778         safe to skip all the pointless field stuff and chuck out an operation.
779         """
780         added = self.new_proxy_keys - self.old_proxy_keys
781         for app_label, model_name in sorted(added):
782             model_state = self.to_state.models[app_label, model_name]
783             assert model_state.options.get("proxy")
784             # Depend on the deletion of any possible non-proxy version of us
785             dependencies = [
786                 (app_label, model_name, None, False),
787             ]
788             # Depend on all bases
789             for base in model_state.bases:
790                 if isinstance(base, str) and "." in base:
791                     base_app_label, base_name = base.split(".", 1)
792                     dependencies.append((base_app_label, base_name, None, True))
793             # Generate creation operation
794             self.add_operation(
795                 app_label,
796                 operations.CreateModel(
797                     name=model_state.name,
798                     fields=[],
799                     options=model_state.options,
800                     bases=model_state.bases,
801                     managers=model_state.managers,
802                 ),
803                 # Depend on the deletion of any possible non-proxy version of us
804                 dependencies=dependencies,
805             )
806 
807     def generate_deleted_models(self):
808         """
809         Find all deleted models (managed and unmanaged) and make delete
810         operations for them as well as separate operations to delete any
811         foreign key or M2M relationships (these are optimized later, if
812         possible).
813 
814         Also bring forward removal of any model options that refer to
815         collections of fields - the inverse of generate_created_models().
816         """
817         new_keys = self.new_model_keys | self.new_unmanaged_keys
818         deleted_models = self.old_model_keys - new_keys
819         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
820         all_deleted_models = chain(
821             sorted(deleted_models), sorted(deleted_unmanaged_models)
822         )
823         for app_label, model_name in all_deleted_models:
824             model_state = self.from_state.models[app_label, model_name]
825             # Gather related fields
826             related_fields = {}
827             for field_name, field in model_state.fields.items():
828                 if field.remote_field:
829                     if field.remote_field.model:
830                         related_fields[field_name] = field
831                     if getattr(field.remote_field, "through", None):
832                         related_fields[field_name] = field
833             # Generate option removal first
834             unique_together = model_state.options.pop("unique_together", None)
835             # RemovedInDjango51Warning.
836             index_together = model_state.options.pop("index_together", None)
837             if unique_together:
838                 self.add_operation(
839                     app_label,
840                     operations.AlterUniqueTogether(
841                         name=model_name,
842                         unique_together=None,
843                     ),
844                 )
845             # RemovedInDjango51Warning.
846             if index_together:
847                 self.add_operation(
848                     app_label,
849                     operations.AlterIndexTogether(
850                         name=model_name,
851                         index_together=None,
852                     ),
853                 )
854             # Then remove each related field
855             for name in sorted(related_fields):
856                 self.add_operation(
857                     app_label,
858                     operations.RemoveField(
859                         model_name=model_name,
860                         name=name,
861                     ),
862                 )
863             # Finally, remove the model.
864             # This depends on both the removal/alteration of all incoming fields
865             # and the removal of all its own related fields, and if it's
866             # a through model the field that references it.
867             dependencies = []
868             relations = self.from_state.relations
869             for (
870                 related_object_app_label,
871                 object_name,
872             ), relation_related_fields in relations[app_label, model_name].items():
873                 for field_name, field in relation_related_fields.items():
874                     dependencies.append(
875                         (related_object_app_label, object_name, field_name, False),
876                     )
877                     if not field.many_to_many:
878                         dependencies.append(
879                             (
880                                 related_object_app_label,
881                                 object_name,
882                                 field_name,
883                                 "alter",
884                             ),
885                         )
886 
887             for name in sorted(related_fields):
888                 dependencies.append((app_label, model_name, name, False))
889             # We're referenced in another field's through=
890             through_user = self.through_users.get((app_label, model_state.name_lower))
891             if through_user:
892                 dependencies.append(
893                     (through_user[0], through_user[1], through_user[2], False)
894                 )
895             # Finally, make the operation, deduping any dependencies
896             self.add_operation(
897                 app_label,
898                 operations.DeleteModel(
899                     name=model_state.name,
900                 ),
901                 dependencies=list(set(dependencies)),
902             )
903 
904     def generate_deleted_proxies(self):
905         """Make DeleteModel options for proxy models."""
906         deleted = self.old_proxy_keys - self.new_proxy_keys
907         for app_label, model_name in sorted(deleted):
908             model_state = self.from_state.models[app_label, model_name]
909             assert model_state.options.get("proxy")
910             self.add_operation(
911                 app_label,
912                 operations.DeleteModel(
913                     name=model_state.name,
914                 ),
915             )
916 
917     def create_renamed_fields(self):
918         """Work out renamed fields."""
919         self.renamed_operations = []
920         old_field_keys = self.old_field_keys.copy()
921         for app_label, model_name, field_name in sorted(
922             self.new_field_keys - old_field_keys
923         ):
924             old_model_name = self.renamed_models.get(
925                 (app_label, model_name), model_name
926             )
927             old_model_state = self.from_state.models[app_label, old_model_name]
928             new_model_state = self.to_state.models[app_label, model_name]
929             field = new_model_state.get_field(field_name)
930             # Scan to see if this is actually a rename!
931             field_dec = self.deep_deconstruct(field)
932             for rem_app_label, rem_model_name, rem_field_name in sorted(
933                 old_field_keys - self.new_field_keys
934             ):
935                 if rem_app_label == app_label and rem_model_name == model_name:
936                     old_field = old_model_state.get_field(rem_field_name)
937                     old_field_dec = self.deep_deconstruct(old_field)
938                     if (
939                         field.remote_field
940                         and field.remote_field.model
941                         and "to" in old_field_dec[2]
942                     ):
943                         old_rel_to = old_field_dec[2]["to"]
944                         if old_rel_to in self.renamed_models_rel:
945                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
946                     old_field.set_attributes_from_name(rem_field_name)
947                     old_db_column = old_field.get_attname_column()[1]
948                     if old_field_dec == field_dec or (
949                         # Was the field renamed and db_column equal to the
950                         # old field's column added?
951                         old_field_dec[0:2] == field_dec[0:2]
952                         and dict(old_field_dec[2], db_column=old_db_column)
953                         == field_dec[2]
954                     ):
955                         if self.questioner.ask_rename(
956                             model_name, rem_field_name, field_name, field
957                         ):
958                             self.renamed_operations.append(
959                                 (
960                                     rem_app_label,
961                                     rem_model_name,
962                                     old_field.db_column,
963                                     rem_field_name,
964                                     app_label,
965                                     model_name,
966                                     field,
967                                     field_name,
968                                 )
969                             )
970                             old_field_keys.remove(
971                                 (rem_app_label, rem_model_name, rem_field_name)
972                             )
973                             old_field_keys.add((app_label, model_name, field_name))
974                             self.renamed_fields[
975                                 app_label, model_name, field_name
976                             ] = rem_field_name
977                             break
978 
979     def generate_renamed_fields(self):
980         """Generate RenameField operations."""
981         for (
982             rem_app_label,
983             rem_model_name,
984             rem_db_column,
985             rem_field_name,
986             app_label,
987             model_name,
988             field,
989             field_name,
990         ) in self.renamed_operations:
991             # A db_column mismatch requires a prior noop AlterField for the
992             # subsequent RenameField to be a noop on attempts at preserving the
993             # old name.
994             if rem_db_column != field.db_column:
995                 altered_field = field.clone()
996                 altered_field.name = rem_field_name
997                 self.add_operation(
998                     app_label,
999                     operations.AlterField(
1000                         model_name=model_name,
1001                         name=rem_field_name,
1002                         field=altered_field,
1003                     ),
1004                 )
1005             self.add_operation(
1006                 app_label,
1007                 operations.RenameField(
1008                     model_name=model_name,
1009                     old_name=rem_field_name,
1010                     new_name=field_name,
1011                 ),
1012             )
1013             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1014             self.old_field_keys.add((app_label, model_name, field_name))
1015 
1016     def generate_added_fields(self):
1017         """Make AddField operations."""
1018         for app_label, model_name, field_name in sorted(
1019             self.new_field_keys - self.old_field_keys
1020         ):
1021             self._generate_added_field(app_label, model_name, field_name)
1022 
1023     def _generate_added_field(self, app_label, model_name, field_name):
1024         field = self.to_state.models[app_label, model_name].get_field(field_name)
1025         # Adding a field always depends at least on its removal.
1026         dependencies = [(app_label, model_name, field_name, False)]
1027         # Fields that are foreignkeys/m2ms depend on stuff.
1028         if field.remote_field and field.remote_field.model:
1029             dependencies.extend(
1030                 self._get_dependencies_for_foreign_key(
1031                     app_label,
1032                     model_name,
1033                     field,
1034                     self.to_state,
1035                 )
1036             )
1037         # You can't just add NOT NULL fields with no default or fields
1038         # which don't allow empty strings as default.
1039         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1040         preserve_default = (
1041             field.null
1042             or field.has_default()
1043             or field.many_to_many
1044             or (field.blank and field.empty_strings_allowed)
1045             or (isinstance(field, time_fields) and field.auto_now)
1046         )
1047         if not preserve_default:
1048             field = field.clone()
1049             if isinstance(field, time_fields) and field.auto_now_add:
1050                 field.default = self.questioner.ask_auto_now_add_addition(
1051                     field_name, model_name
1052                 )
1053             else:
1054                 field.default = self.questioner.ask_not_null_addition(
1055                     field_name, model_name
1056                 )
1057         if (
1058             field.unique
1059             and field.default is not models.NOT_PROVIDED
1060             and callable(field.default)
1061         ):
1062             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1063         self.add_operation(
1064             app_label,
1065             operations.AddField(
1066                 model_name=model_name,
1067                 name=field_name,
1068                 field=field,
1069                 preserve_default=preserve_default,
1070             ),
1071             dependencies=dependencies,
1072         )
1073 
1074     def generate_removed_fields(self):
1075         """Make RemoveField operations."""
1076         for app_label, model_name, field_name in sorted(
1077             self.old_field_keys - self.new_field_keys
1078         ):
1079             self._generate_removed_field(app_label, model_name, field_name)
1080 
1081     def _generate_removed_field(self, app_label, model_name, field_name):
1082         self.add_operation(
1083             app_label,
1084             operations.RemoveField(
1085                 model_name=model_name,
1086                 name=field_name,
1087             ),
1088             # We might need to depend on the removal of an
1089             # order_with_respect_to or index/unique_together operation;
1090             # this is safely ignored if there isn't one
1091             dependencies=[
1092                 (app_label, model_name, field_name, "order_wrt_unset"),
1093                 (app_label, model_name, field_name, "foo_together_change"),
1094             ],
1095         )
1096 
1097     def generate_altered_fields(self):
1098         """
1099         Make AlterField operations, or possibly RemovedField/AddField if alter
1100         isn't possible.
1101         """
1102         for app_label, model_name, field_name in sorted(
1103             self.old_field_keys & self.new_field_keys
1104         ):
1105             # Did the field change?
1106             old_model_name = self.renamed_models.get(
1107                 (app_label, model_name), model_name
1108             )
1109             old_field_name = self.renamed_fields.get(
1110                 (app_label, model_name, field_name), field_name
1111             )
1112             old_field = self.from_state.models[app_label, old_model_name].get_field(
1113                 old_field_name
1114             )
1115             new_field = self.to_state.models[app_label, model_name].get_field(
1116                 field_name
1117             )
1118             dependencies = []
1119             # Implement any model renames on relations; these are handled by RenameModel
1120             # so we need to exclude them from the comparison
1121             if hasattr(new_field, "remote_field") and getattr(
1122                 new_field.remote_field, "model", None
1123             ):
1124                 rename_key = resolve_relation(
1125                     new_field.remote_field.model, app_label, model_name
1126                 )
1127                 if rename_key in self.renamed_models:
1128                     new_field.remote_field.model = old_field.remote_field.model
1129                 # Handle ForeignKey which can only have a single to_field.
1130                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1131                 if remote_field_name:
1132                     to_field_rename_key = rename_key + (remote_field_name,)
1133                     if to_field_rename_key in self.renamed_fields:
1134                         # Repoint both model and field name because to_field
1135                         # inclusion in ForeignKey.deconstruct() is based on
1136                         # both.
1137                         new_field.remote_field.model = old_field.remote_field.model
1138                         new_field.remote_field.field_name = (
1139                             old_field.remote_field.field_name
1140                         )
1141                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1142                 from_fields = getattr(new_field, "from_fields", None)
1143                 if from_fields:
1144                     from_rename_key = (app_label, model_name)
1145                     new_field.from_fields = tuple(
1146                         [
1147                             self.renamed_fields.get(
1148                                 from_rename_key + (from_field,), from_field
1149                             )
1150                             for from_field in from_fields
1151                         ]
1152                     )
1153                     new_field.to_fields = tuple(
1154                         [
1155                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1156                             for to_field in new_field.to_fields
1157                         ]
1158                     )
1159                 dependencies.extend(
1160                     self._get_dependencies_for_foreign_key(
1161                         app_label,
1162                         model_name,
1163                         new_field,
1164                         self.to_state,
1165                     )
1166                 )
1167             if hasattr(new_field, "remote_field") and getattr(
1168                 new_field.remote_field, "through", None
1169             ):
1170                 rename_key = resolve_relation(
1171                     new_field.remote_field.through, app_label, model_name
1172                 )
1173                 if rename_key in self.renamed_models:
1174                     new_field.remote_field.through = old_field.remote_field.through
1175             old_field_dec = self.deep_deconstruct(old_field)
1176             new_field_dec = self.deep_deconstruct(new_field)
1177             # If the field was confirmed to be renamed it means that only
1178             # db_column was allowed to change which generate_renamed_fields()
1179             # already accounts for by adding an AlterField operation.
1180             if old_field_dec != new_field_dec and old_field_name == field_name:
1181                 both_m2m = old_field.many_to_many and new_field.many_to_many
1182                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1183                 if both_m2m or neither_m2m:
1184                     # Either both fields are m2m or neither is
1185                     preserve_default = True
1186                     if (
1187                         old_field.null
1188                         and not new_field.null
1189                         and not new_field.has_default()
1190                         and not new_field.many_to_many
1191                     ):
1192                         field = new_field.clone()
1193                         new_default = self.questioner.ask_not_null_alteration(
1194                             field_name, model_name
1195                         )
1196                         if new_default is not models.NOT_PROVIDED:
1197                             field.default = new_default
1198                             preserve_default = False
1199                     else:
1200                         field = new_field
1201                     self.add_operation(
1202                         app_label,
1203                         operations.AlterField(
1204                             model_name=model_name,
1205                             name=field_name,
1206                             field=field,
1207                             preserve_default=preserve_default,
1208                         ),
1209                         dependencies=dependencies,
1210                     )
1211                 else:
1212                     # We cannot alter between m2m and concrete fields
1213                     self._generate_removed_field(app_label, model_name, field_name)
1214                     self._generate_added_field(app_label, model_name, field_name)
1215 
1216     def create_altered_indexes(self):
1217         option_name = operations.AddIndex.option_name
1218         self.renamed_index_together_values = defaultdict(list)
1219 
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get(
1222                 (app_label, model_name), model_name
1223             )
1224             old_model_state = self.from_state.models[app_label, old_model_name]
1225             new_model_state = self.to_state.models[app_label, model_name]
1226 
1227             old_indexes = old_model_state.options[option_name]
1228             new_indexes = new_model_state.options[option_name]
1229             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1230             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1231             renamed_indexes = []
1232             # Find renamed indexes.
1233             remove_from_added = []
1234             remove_from_removed = []
1235             for new_index in added_indexes:
1236                 new_index_dec = new_index.deconstruct()
1237                 new_index_name = new_index_dec[2].pop("name")
1238                 for old_index in removed_indexes:
1239                     old_index_dec = old_index.deconstruct()
1240                     old_index_name = old_index_dec[2].pop("name")
1241                     # Indexes are the same except for the names.
1242                     if (
1243                         new_index_dec == old_index_dec
1244                         and new_index_name != old_index_name
1245                     ):
1246                         renamed_indexes.append((old_index_name, new_index_name, None))
1247                         remove_from_added.append(new_index)
1248                         remove_from_removed.append(old_index)
1249             # Find index_together changed to indexes.
1250             for (
1251                 old_value,
1252                 new_value,
1253                 index_together_app_label,
1254                 index_together_model_name,
1255                 dependencies,
1256             ) in self._get_altered_foo_together_operations(
1257                 operations.AlterIndexTogether.option_name
1258             ):
1259                 if (
1260                     app_label != index_together_app_label
1261                     or model_name != index_together_model_name
1262                 ):
1263                     continue
1264                 removed_values = old_value.difference(new_value)
1265                 for removed_index_together in removed_values:
1266                     renamed_index_together_indexes = []
1267                     for new_index in added_indexes:
1268                         _, args, kwargs = new_index.deconstruct()
1269                         # Ensure only 'fields' are defined in the Index.
1270                         if (
1271                             not args
1272                             and new_index.fields == list(removed_index_together)
1273                             and set(kwargs) == {"name", "fields"}
1274                         ):
1275                             renamed_index_together_indexes.append(new_index)
1276 
1277                     if len(renamed_index_together_indexes) == 1:
1278                         renamed_index = renamed_index_together_indexes[0]
1279                         remove_from_added.append(renamed_index)
1280                         renamed_indexes.append(
1281                             (None, renamed_index.name, removed_index_together)
1282                         )
1283                         self.renamed_index_together_values[
1284                             index_together_app_label, index_together_model_name
1285                         ].append(removed_index_together)
1286             # Remove renamed indexes from the lists of added and removed
1287             # indexes.
1288             added_indexes = [
1289                 idx for idx in added_indexes if idx not in remove_from_added
1290             ]
1291             removed_indexes = [
1292                 idx for idx in removed_indexes if idx not in remove_from_removed
1293             ]
1294 
1295             self.altered_indexes.update(
1296                 {
1297                     (app_label, model_name): {
1298                         "added_indexes": added_indexes,
1299                         "removed_indexes": removed_indexes,
1300                         "renamed_indexes": renamed_indexes,
1301                     }
1302                 }
1303             )
1304 
1305     def generate_added_indexes(self):
1306         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1307             for index in alt_indexes["added_indexes"]:
1308                 self.add_operation(
1309                     app_label,
1310                     operations.AddIndex(
1311                         model_name=model_name,
1312                         index=index,
1313                     ),
1314                 )
1315 
1316     def generate_removed_indexes(self):
1317         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1318             for index in alt_indexes["removed_indexes"]:
1319                 self.add_operation(
1320                     app_label,
1321                     operations.RemoveIndex(
1322                         model_name=model_name,
1323                         name=index.name,
1324                     ),
1325                 )
1326 
1327     def generate_renamed_indexes(self):
1328         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1329             for old_index_name, new_index_name, old_fields in alt_indexes[
1330                 "renamed_indexes"
1331             ]:
1332                 self.add_operation(
1333                     app_label,
1334                     operations.RenameIndex(
1335                         model_name=model_name,
1336                         new_name=new_index_name,
1337                         old_name=old_index_name,
1338                         old_fields=old_fields,
1339                     ),
1340                 )
1341 
1342     def create_altered_constraints(self):
1343         option_name = operations.AddConstraint.option_name
1344         for app_label, model_name in sorted(self.kept_model_keys):
1345             old_model_name = self.renamed_models.get(
1346                 (app_label, model_name), model_name
1347             )
1348             old_model_state = self.from_state.models[app_label, old_model_name]
1349             new_model_state = self.to_state.models[app_label, model_name]
1350 
1351             old_constraints = old_model_state.options[option_name]
1352             new_constraints = new_model_state.options[option_name]
1353             add_constraints = [c for c in new_constraints if c not in old_constraints]
1354             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1355 
1356             self.altered_constraints.update(
1357                 {
1358                     (app_label, model_name): {
1359                         "added_constraints": add_constraints,
1360                         "removed_constraints": rem_constraints,
1361                     }
1362                 }
1363             )
1364 
1365     def generate_added_constraints(self):
1366         for (
1367             app_label,
1368             model_name,
1369         ), alt_constraints in self.altered_constraints.items():
1370             for constraint in alt_constraints["added_constraints"]:
1371                 self.add_operation(
1372                     app_label,
1373                     operations.AddConstraint(
1374                         model_name=model_name,
1375                         constraint=constraint,
1376                     ),
1377                 )
1378 
1379     def generate_removed_constraints(self):
1380         for (
1381             app_label,
1382             model_name,
1383         ), alt_constraints in self.altered_constraints.items():
1384             for constraint in alt_constraints["removed_constraints"]:
1385                 self.add_operation(
1386                     app_label,
1387                     operations.RemoveConstraint(
1388                         model_name=model_name,
1389                         name=constraint.name,
1390                     ),
1391                 )
1392 
1393     @staticmethod
1394     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1395         remote_field_model = None
1396         if hasattr(field.remote_field, "model"):
1397             remote_field_model = field.remote_field.model
1398         else:
1399             relations = project_state.relations[app_label, model_name]
1400             for (remote_app_label, remote_model_name), fields in relations.items():
1401                 if any(
1402                     field == related_field.remote_field
1403                     for related_field in fields.values()
1404                 ):
1405                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1406                     break
1407         # Account for FKs to swappable models
1408         swappable_setting = getattr(field, "swappable_setting", None)
1409         if swappable_setting is not None:
1410             dep_app_label = "__setting__"
1411             dep_object_name = swappable_setting
1412         else:
1413             dep_app_label, dep_object_name = resolve_relation(
1414                 remote_field_model,
1415                 app_label,
1416                 model_name,
1417             )
1418         dependencies = [(dep_app_label, dep_object_name, None, True)]
1419         if getattr(field.remote_field, "through", None):
1420             through_app_label, through_object_name = resolve_relation(
1421                 field.remote_field.through,
1422                 app_label,
1423                 model_name,
1424             )
1425             dependencies.append((through_app_label, through_object_name, None, True))
1426         return dependencies
1427 
1428     def _get_altered_foo_together_operations(self, option_name):
1429         for app_label, model_name in sorted(self.kept_model_keys):
1430             old_model_name = self.renamed_models.get(
1431                 (app_label, model_name), model_name
1432             )
1433             old_model_state = self.from_state.models[app_label, old_model_name]
1434             new_model_state = self.to_state.models[app_label, model_name]
1435 
1436             # We run the old version through the field renames to account for those
1437             old_value = old_model_state.options.get(option_name)
1438             old_value = (
1439                 {
1440                     tuple(
1441                         self.renamed_fields.get((app_label, model_name, n), n)
1442                         for n in unique
1443                     )
1444                     for unique in old_value
1445                 }
1446                 if old_value
1447                 else set()
1448             )
1449 
1450             new_value = new_model_state.options.get(option_name)
1451             new_value = set(new_value) if new_value else set()
1452 
1453             if old_value != new_value:
1454                 dependencies = []
1455                 for foo_togethers in new_value:
1456                     for field_name in foo_togethers:
1457                         field = new_model_state.get_field(field_name)
1458                         if field.remote_field and field.remote_field.model:
1459                             dependencies.extend(
1460                                 self._get_dependencies_for_foreign_key(
1461                                     app_label,
1462                                     model_name,
1463                                     field,
1464                                     self.to_state,
1465                                 )
1466                             )
1467                 yield (
1468                     old_value,
1469                     new_value,
1470                     app_label,
1471                     model_name,
1472                     dependencies,
1473                 )
1474 
1475     def _generate_removed_altered_foo_together(self, operation):
1476         for (
1477             old_value,
1478             new_value,
1479             app_label,
1480             model_name,
1481             dependencies,
1482         ) in self._get_altered_foo_together_operations(operation.option_name):
1483             if operation == operations.AlterIndexTogether:
1484                 old_value = {
1485                     value
1486                     for value in old_value
1487                     if value
1488                     not in self.renamed_index_together_values[app_label, model_name]
1489                 }
1490             removal_value = new_value.intersection(old_value)
1491             if removal_value or old_value:
1492                 self.add_operation(
1493                     app_label,
1494                     operation(
1495                         name=model_name, **{operation.option_name: removal_value}
1496                     ),
1497                     dependencies=dependencies,
1498                 )
1499 
1500     def generate_removed_altered_unique_together(self):
1501         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1502 
1503     # RemovedInDjango51Warning.
1504     def generate_removed_altered_index_together(self):
1505         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1506 
1507     def _generate_altered_foo_together(self, operation):
1508         for (
1509             old_value,
1510             new_value,
1511             app_label,
1512             model_name,
1513             dependencies,
1514         ) in self._get_altered_foo_together_operations(operation.option_name):
1515             removal_value = new_value.intersection(old_value)
1516             if new_value != removal_value:
1517                 self.add_operation(
1518                     app_label,
1519                     operation(name=model_name, **{operation.option_name: new_value}),
1520                     dependencies=dependencies,
1521                 )
1522 
1523     def generate_altered_unique_together(self):
1524         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1525 
1526     # RemovedInDjango51Warning.
1527     def generate_altered_index_together(self):
1528         self._generate_altered_foo_together(operations.AlterIndexTogether)
1529 
1530     def generate_altered_db_table(self):
1531         models_to_check = self.kept_model_keys.union(
1532             self.kept_proxy_keys, self.kept_unmanaged_keys
1533         )
1534         for app_label, model_name in sorted(models_to_check):
1535             old_model_name = self.renamed_models.get(
1536                 (app_label, model_name), model_name
1537             )
1538             old_model_state = self.from_state.models[app_label, old_model_name]
1539             new_model_state = self.to_state.models[app_label, model_name]
1540             old_db_table_name = old_model_state.options.get("db_table")
1541             new_db_table_name = new_model_state.options.get("db_table")
1542             if old_db_table_name != new_db_table_name:
1543                 self.add_operation(
1544                     app_label,
1545                     operations.AlterModelTable(
1546                         name=model_name,
1547                         table=new_db_table_name,
1548                     ),
1549                 )
1550 
1551     def generate_altered_db_table_comment(self):
1552         models_to_check = self.kept_model_keys.union(
1553             self.kept_proxy_keys, self.kept_unmanaged_keys
1554         )
1555         for app_label, model_name in sorted(models_to_check):
1556             old_model_name = self.renamed_models.get(
1557                 (app_label, model_name), model_name
1558             )
1559             old_model_state = self.from_state.models[app_label, old_model_name]
1560             new_model_state = self.to_state.models[app_label, model_name]
1561 
1562             old_db_table_comment = old_model_state.options.get("db_table_comment")
1563             new_db_table_comment = new_model_state.options.get("db_table_comment")
1564             if old_db_table_comment != new_db_table_comment:
1565                 self.add_operation(
1566                     app_label,
1567                     operations.AlterModelTableComment(
1568                         name=model_name,
1569                         table_comment=new_db_table_comment,
1570                     ),
1571                 )
1572 
1573     def generate_altered_options(self):
1574         """
1575         Work out if any non-schema-affecting options have changed and make an
1576         operation to represent them in state changes (in case Python code in
1577         migrations needs them).
1578         """
1579         models_to_check = self.kept_model_keys.union(
1580             self.kept_proxy_keys,
1581             self.kept_unmanaged_keys,
1582             # unmanaged converted to managed
1583             self.old_unmanaged_keys & self.new_model_keys,
1584             # managed converted to unmanaged
1585             self.old_model_keys & self.new_unmanaged_keys,
1586         )
1587 
1588         for app_label, model_name in sorted(models_to_check):
1589             old_model_name = self.renamed_models.get(
1590                 (app_label, model_name), model_name
1591             )
1592             old_model_state = self.from_state.models[app_label, old_model_name]
1593             new_model_state = self.to_state.models[app_label, model_name]
1594             old_options = {
1595                 key: value
1596                 for key, value in old_model_state.options.items()
1597                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1598             }
1599             new_options = {
1600                 key: value
1601                 for key, value in new_model_state.options.items()
1602                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1603             }
1604             if old_options != new_options:
1605                 self.add_operation(
1606                     app_label,
1607                     operations.AlterModelOptions(
1608                         name=model_name,
1609                         options=new_options,
1610                     ),
1611                 )
1612 
1613     def generate_altered_order_with_respect_to(self):
1614         for app_label, model_name in sorted(self.kept_model_keys):
1615             old_model_name = self.renamed_models.get(
1616                 (app_label, model_name), model_name
1617             )
1618             old_model_state = self.from_state.models[app_label, old_model_name]
1619             new_model_state = self.to_state.models[app_label, model_name]
1620             if old_model_state.options.get(
1621                 "order_with_respect_to"
1622             ) != new_model_state.options.get("order_with_respect_to"):
1623                 # Make sure it comes second if we're adding
1624                 # (removal dependency is part of RemoveField)
1625                 dependencies = []
1626                 if new_model_state.options.get("order_with_respect_to"):
1627                     dependencies.append(
1628                         (
1629                             app_label,
1630                             model_name,
1631                             new_model_state.options["order_with_respect_to"],
1632                             True,
1633                         )
1634                     )
1635                 # Actually generate the operation
1636                 self.add_operation(
1637                     app_label,
1638                     operations.AlterOrderWithRespectTo(
1639                         name=model_name,
1640                         order_with_respect_to=new_model_state.options.get(
1641                             "order_with_respect_to"
1642                         ),
1643                     ),
1644                     dependencies=dependencies,
1645                 )
1646 
1647     def generate_altered_managers(self):
1648         for app_label, model_name in sorted(self.kept_model_keys):
1649             old_model_name = self.renamed_models.get(
1650                 (app_label, model_name), model_name
1651             )
1652             old_model_state = self.from_state.models[app_label, old_model_name]
1653             new_model_state = self.to_state.models[app_label, model_name]
1654             if old_model_state.managers != new_model_state.managers:
1655                 self.add_operation(
1656                     app_label,
1657                     operations.AlterModelManagers(
1658                         name=model_name,
1659                         managers=new_model_state.managers,
1660                     ),
1661                 )
1662 
1663     def arrange_for_graph(self, changes, graph, migration_name=None):
1664         """
1665         Take a result from changes() and a MigrationGraph, and fix the names
1666         and dependencies of the changes so they extend the graph from the leaf
1667         nodes for each app.
1668         """
1669         leaves = graph.leaf_nodes()
1670         name_map = {}
1671         for app_label, migrations in list(changes.items()):
1672             if not migrations:
1673                 continue
1674             # Find the app label's current leaf node
1675             app_leaf = None
1676             for leaf in leaves:
1677                 if leaf[0] == app_label:
1678                     app_leaf = leaf
1679                     break
1680             # Do they want an initial migration for this app?
1681             if app_leaf is None and not self.questioner.ask_initial(app_label):
1682                 # They don't.
1683                 for migration in migrations:
1684                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1685                 del changes[app_label]
1686                 continue
1687             # Work out the next number in the sequence
1688             if app_leaf is None:
1689                 next_number = 1
1690             else:
1691                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1692             # Name each migration
1693             for i, migration in enumerate(migrations):
1694                 if i == 0 and app_leaf:
1695                     migration.dependencies.append(app_leaf)
1696                 new_name_parts = ["%04i" % next_number]
1697                 if migration_name:
1698                     new_name_parts.append(migration_name)
1699                 elif i == 0 and not app_leaf:
1700                     new_name_parts.append("initial")
1701                 else:
1702                     new_name_parts.append(migration.suggest_name()[:100])
1703                 new_name = "_".join(new_name_parts)
1704                 name_map[(app_label, migration.name)] = (app_label, new_name)
1705                 next_number += 1
1706                 migration.name = new_name
1707         # Now fix dependencies
1708         for migrations in changes.values():
1709             for migration in migrations:
1710                 migration.dependencies = [
1711                     name_map.get(d, d) for d in migration.dependencies
1712                 ]
1713         return changes
1714 
1715     def _trim_to_apps(self, changes, app_labels):
1716         """
1717         Take changes from arrange_for_graph() and set of app labels, and return
1718         a modified set of changes which trims out as many migrations that are
1719         not in app_labels as possible. Note that some other migrations may
1720         still be present as they may be required dependencies.
1721         """
1722         # Gather other app dependencies in a first pass
1723         app_dependencies = {}
1724         for app_label, migrations in changes.items():
1725             for migration in migrations:
1726                 for dep_app_label, name in migration.dependencies:
1727                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1728         required_apps = set(app_labels)
1729         # Keep resolving till there's no change
1730         old_required_apps = None
1731         while old_required_apps != required_apps:
1732             old_required_apps = set(required_apps)
1733             required_apps.update(
1734                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1735             )
1736         # Remove all migrations that aren't needed
1737         for app_label in list(changes):
1738             if app_label not in required_apps:
1739                 del changes[app_label]
1740         return changes
1741 
1742     @classmethod
1743     def parse_number(cls, name):
1744         """
1745         Given a migration name, try to extract a number from the beginning of
1746         it. For a squashed migration such as '0001_squashed_0004â€¦', return the
1747         second number. If no number is found, return None.
1748         """
1749         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1750             return int(squashed_match[1])
1751         match = re.match(r"^\d+", name)
1752         if match:
1753             return int(match[0])
1754         return None

</code><intended_behavior>This component should detect when a model involved in a M2M relationship is being renamed and either automatically generate additional operations to handle the renaming of related fields in intermediary tables or alert the developer to the need for manual intervention. The detection algorithm could be improved to anticipate the complications of renaming models involved in complex relationships and provide more comprehensive migration steps to maintain integrity.</intended_behavior>, <file>django/contrib/contenttypes/management/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.apps import apps as global_apps
2 from django.db import DEFAULT_DB_ALIAS, IntegrityError, migrations, router, transaction
3 
4 
5 class RenameContentType(migrations.RunPython):
6     def __init__(self, app_label, old_model, new_model):
7         self.app_label = app_label
8         self.old_model = old_model
9         self.new_model = new_model
10         super().__init__(self.rename_forward, self.rename_backward)
11 
12     def _rename(self, apps, schema_editor, old_model, new_model):
13         ContentType = apps.get_model("contenttypes", "ContentType")
14         db = schema_editor.connection.alias
15         if not router.allow_migrate_model(db, ContentType):
16             return
17 
18         try:
19             content_type = ContentType.objects.db_manager(db).get_by_natural_key(
20                 self.app_label, old_model
21             )
22         except ContentType.DoesNotExist:
23             pass
24         else:
25             content_type.model = new_model
26             try:
27                 with transaction.atomic(using=db):
28                     content_type.save(using=db, update_fields={"model"})
29             except IntegrityError:
30                 # Gracefully fallback if a stale content type causes a
31                 # conflict as remove_stale_contenttypes will take care of
32                 # asking the user what should be done next.
33                 content_type.model = old_model
34             else:
35                 # Clear the cache as the `get_by_natural_key()` call will cache
36                 # the renamed ContentType instance by its old model name.
37                 ContentType.objects.clear_cache()
38 
39     def rename_forward(self, apps, schema_editor):
40         self._rename(apps, schema_editor, self.old_model, self.new_model)
41 
42     def rename_backward(self, apps, schema_editor):
43         self._rename(apps, schema_editor, self.new_model, self.old_model)
44 
45 
46 def inject_rename_contenttypes_operations(
47     plan=None, apps=global_apps, using=DEFAULT_DB_ALIAS, **kwargs
48 ):
49     """
50     Insert a `RenameContentType` operation after every planned `RenameModel`
51     operation.
52     """
53     if plan is None:
54         return
55 
56     # Determine whether or not the ContentType model is available.
57     try:
58         ContentType = apps.get_model("contenttypes", "ContentType")
59     except LookupError:
60         available = False
61     else:
62         if not router.allow_migrate_model(using, ContentType):
63             return
64         available = True
65 
66     for migration, backward in plan:
67         if (migration.app_label, migration.name) == ("contenttypes", "0001_initial"):
68             # There's no point in going forward if the initial contenttypes
69             # migration is unapplied as the ContentType model will be
70             # unavailable from this point.
71             if backward:
72                 break
73             else:
74                 available = True
75                 continue
76         # The ContentType model is not available yet.
77         if not available:
78             continue
79         inserts = []
80         for index, operation in enumerate(migration.operations):
81             if isinstance(operation, migrations.RenameModel):
82                 operation = RenameContentType(
83                     migration.app_label,
84                     operation.old_name_lower,
85                     operation.new_name_lower,
86                 )
87                 inserts.append((index + 1, operation))
88         for inserted, (index, operation) in enumerate(inserts):
89             migration.operations.insert(inserted + index, operation)
90 
91 
92 def get_contenttypes_and_models(app_config, using, ContentType):
93     if not router.allow_migrate_model(using, ContentType):
94         return None, None
95 
96     ContentType.objects.clear_cache()
97 
98     content_types = {
99         ct.model: ct
100         for ct in ContentType.objects.using(using).filter(app_label=app_config.label)
101     }
102     app_models = {model._meta.model_name: model for model in app_config.get_models()}
103     return content_types, app_models
104 
105 
106 def create_contenttypes(
107     app_config,
108     verbosity=2,
109     interactive=True,
110     using=DEFAULT_DB_ALIAS,
111     apps=global_apps,
112     **kwargs,
113 ):
114     """
115     Create content types for models in the given app.
116     """
117     if not app_config.models_module:
118         return
119 
120     app_label = app_config.label
121     try:
122         app_config = apps.get_app_config(app_label)
123         ContentType = apps.get_model("contenttypes", "ContentType")
124     except LookupError:
125         return
126 
127     content_types, app_models = get_contenttypes_and_models(
128         app_config, using, ContentType
129     )
130 
131     if not app_models:
132         return
133 
134     cts = [
135         ContentType(
136             app_label=app_label,
137             model=model_name,
138         )
139         for (model_name, model) in app_models.items()
140         if model_name not in content_types
141     ]
142     ContentType.objects.using(using).bulk_create(cts)
143     if verbosity >= 2:
144         for ct in cts:
145             print("Adding content type '%s | %s'" % (ct.app_label, ct.model))

</code><intended_behavior>While this area might not be directly involved in the specific KeyError reported, ensuring that ContentType records are accurately updated during model renames is crucial for the overall integrity of Django's content type framework, especially in applications relying heavily on generic relations. The intended behavior is a thorough update process that reflects model renaming across all ContentType references, which could indirectly affect M2M relationships through generic ForeignKey fields.</intended_behavior>]
2025-10-18 13:36:43.663 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/operations/models.py</file>
<class>RenameModel</class>
<method>None</method>
<code>
344 class RenameModel(ModelOperation):
345     """Rename a model."""
346 
347     def __init__(self, old_name, new_name):
348         self.old_name = old_name
349         self.new_name = new_name
350         super().__init__(old_name)
351 
352     @cached_property
353     def old_name_lower(self):
354         return self.old_name.lower()
355 
356     @cached_property
357     def new_name_lower(self):
358         return self.new_name.lower()
359 
360     def deconstruct(self):
361         kwargs = {
362             "old_name": self.old_name,
363             "new_name": self.new_name,
364         }
365         return (self.__class__.__qualname__, [], kwargs)
366 
367     def state_forwards(self, app_label, state):
368         state.rename_model(app_label, self.old_name, self.new_name)
369 
370     def database_forwards(self, app_label, schema_editor, from_state, to_state):
371         new_model = to_state.apps.get_model(app_label, self.new_name)
372         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
373             old_model = from_state.apps.get_model(app_label, self.old_name)
374             # Move the main table
375             schema_editor.alter_db_table(
376                 new_model,
377                 old_model._meta.db_table,
378                 new_model._meta.db_table,
379             )
380             # Alter the fields pointing to us
381             for related_object in old_model._meta.related_objects:
382                 if related_object.related_model == old_model:
383                     model = new_model
384                     related_key = (app_label, self.new_name_lower)
385                 else:
386                     model = related_object.related_model
387                     related_key = (
388                         related_object.related_model._meta.app_label,
389                         related_object.related_model._meta.model_name,
390                     )
391                 to_field = to_state.apps.get_model(*related_key)._meta.get_field(
392                     related_object.field.name
393                 )
394                 schema_editor.alter_field(
395                     model,
396                     related_object.field,
397                     to_field,
398                 )
399             # Rename M2M fields whose name is based on this model's name.
400             fields = zip(
401                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
402             )
403             for old_field, new_field in fields:
404                 # Skip self-referential fields as these are renamed above.
405                 if (
406                     new_field.model == new_field.related_model
407                     or not new_field.remote_field.through._meta.auto_created
408                 ):
409                     continue
410                 # Rename the M2M table that's based on this model's name.
411                 old_m2m_model = old_field.remote_field.through
412                 new_m2m_model = new_field.remote_field.through
413                 schema_editor.alter_db_table(
414                     new_m2m_model,
415                     old_m2m_model._meta.db_table,
416                     new_m2m_model._meta.db_table,
417                 )
418                 # Rename the column in the M2M table that's based on this
419                 # model's name.
420                 schema_editor.alter_field(
421                     new_m2m_model,
422                     old_m2m_model._meta.get_field(old_model._meta.model_name),
423                     new_m2m_model._meta.get_field(new_model._meta.model_name),
424                 )
425 
426     def database_backwards(self, app_label, schema_editor, from_state, to_state):
427         self.new_name_lower, self.old_name_lower = (
428             self.old_name_lower,
429             self.new_name_lower,
430         )
431         self.new_name, self.old_name = self.old_name, self.new_name
432 
433         self.database_forwards(app_label, schema_editor, from_state, to_state)
434 
435         self.new_name_lower, self.old_name_lower = (
436             self.old_name_lower,
437             self.new_name_lower,
438         )
439         self.new_name, self.old_name = self.old_name, self.new_name
440 
441     def references_model(self, name, app_label):
442         return (
443             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
444         )
445 
446     def describe(self):
447         return "Rename model %s to %s" % (self.old_name, self.new_name)
448 
449     @property
450     def migration_name_fragment(self):
451         return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
452 
453     def reduce(self, operation, app_label):
454         if (
455             isinstance(operation, RenameModel)
456             and self.new_name_lower == operation.old_name_lower
457         ):
458             return [
459                 RenameModel(
460                     self.old_name,
461                     operation.new_name,
462                 ),
463             ]
464         # Skip `ModelOperation.reduce` as we want to run `references_model`
465         # against self.new_name.
466         return super(ModelOperation, self).reduce(
467             operation, app_label
468         ) or not operation.references_model(self.new_name, app_label)

</code><intended_behavior>The `RenameModel` operation should not only rename the model and update the table name in the database but also ensure that all references to the model, including those in intermediary tables for M2M relationships, are updated. This might involve enhancing the operation to identify and modify table column names or constraints that reference the old model name, ensuring consistency throughout the database schema.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from graphlib import TopologicalSorter
5 from itertools import chain
6 
7 from django.conf import settings
8 from django.db import models
9 from django.db.migrations import operations
10 from django.db.migrations.migration import Migration
11 from django.db.migrations.operations.models import AlterModelOptions
12 from django.db.migrations.optimizer import MigrationOptimizer
13 from django.db.migrations.questioner import MigrationQuestioner
14 from django.db.migrations.utils import (
15     COMPILED_REGEX_TYPE,
16     RegexObject,
17     resolve_relation,
18 )
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173         self.generate_altered_db_table_comment()
174 
175         # Create the renamed fields and store them in self.renamed_fields.
176         # They are used by create_altered_indexes(), generate_altered_fields(),
177         # generate_removed_altered_index/unique_together(), and
178         # generate_altered_index/unique_together().
179         self.create_renamed_fields()
180         # Create the altered indexes and store them in self.altered_indexes.
181         # This avoids the same computation in generate_removed_indexes()
182         # and generate_added_indexes().
183         self.create_altered_indexes()
184         self.create_altered_constraints()
185         # Generate index removal operations before field is removed
186         self.generate_removed_constraints()
187         self.generate_removed_indexes()
188         # Generate field renaming operations.
189         self.generate_renamed_fields()
190         self.generate_renamed_indexes()
191         # Generate removal of foo together.
192         self.generate_removed_altered_unique_together()
193         self.generate_removed_altered_index_together()  # RemovedInDjango51Warning.
194         # Generate field operations.
195         self.generate_removed_fields()
196         self.generate_added_fields()
197         self.generate_altered_fields()
198         self.generate_altered_order_with_respect_to()
199         self.generate_altered_unique_together()
200         self.generate_altered_index_together()  # RemovedInDjango51Warning.
201         self.generate_added_indexes()
202         self.generate_added_constraints()
203         self.generate_altered_db_table()
204 
205         self._sort_migrations()
206         self._build_migration_list(graph)
207         self._optimize_migrations()
208 
209         return self.migrations
210 
211     def _prepare_field_lists(self):
212         """
213         Prepare field lists and a list of the fields that used through models
214         in the old state so dependencies can be made from the through model
215         deletion to the field that uses it.
216         """
217         self.kept_model_keys = self.old_model_keys & self.new_model_keys
218         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
219         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
220         self.through_users = {}
221         self.old_field_keys = {
222             (app_label, model_name, field_name)
223             for app_label, model_name in self.kept_model_keys
224             for field_name in self.from_state.models[
225                 app_label, self.renamed_models.get((app_label, model_name), model_name)
226             ].fields
227         }
228         self.new_field_keys = {
229             (app_label, model_name, field_name)
230             for app_label, model_name in self.kept_model_keys
231             for field_name in self.to_state.models[app_label, model_name].fields
232         }
233 
234     def _generate_through_model_map(self):
235         """Through model map generation."""
236         for app_label, model_name in sorted(self.old_model_keys):
237             old_model_name = self.renamed_models.get(
238                 (app_label, model_name), model_name
239             )
240             old_model_state = self.from_state.models[app_label, old_model_name]
241             for field_name, field in old_model_state.fields.items():
242                 if hasattr(field, "remote_field") and getattr(
243                     field.remote_field, "through", None
244                 ):
245                     through_key = resolve_relation(
246                         field.remote_field.through, app_label, model_name
247                     )
248                     self.through_users[through_key] = (
249                         app_label,
250                         old_model_name,
251                         field_name,
252                     )
253 
254     @staticmethod
255     def _resolve_dependency(dependency):
256         """
257         Return the resolved dependency and a boolean denoting whether or not
258         it was swappable.
259         """
260         if dependency[0] != "__setting__":
261             return dependency, False
262         resolved_app_label, resolved_object_name = getattr(
263             settings, dependency[1]
264         ).split(".")
265         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
266 
267     def _build_migration_list(self, graph=None):
268         """
269         Chop the lists of operations up into migrations with dependencies on
270         each other. Do this by going through an app's list of operations until
271         one is found that has an outgoing dependency that isn't in another
272         app's migration yet (hasn't been chopped off its list). Then chop off
273         the operations before it into a migration and move onto the next app.
274         If the loops completes without doing anything, there's a circular
275         dependency (which _should_ be impossible as the operations are
276         all split at this point so they can't depend and be depended on).
277         """
278         self.migrations = {}
279         num_ops = sum(len(x) for x in self.generated_operations.values())
280         chop_mode = False
281         while num_ops:
282             # On every iteration, we step through all the apps and see if there
283             # is a completed set of operations.
284             # If we find that a subset of the operations are complete we can
285             # try to chop it off from the rest and continue, but we only
286             # do this if we've already been through the list once before
287             # without any chopping and nothing has changed.
288             for app_label in sorted(self.generated_operations):
289                 chopped = []
290                 dependencies = set()
291                 for operation in list(self.generated_operations[app_label]):
292                     deps_satisfied = True
293                     operation_dependencies = set()
294                     for dep in operation._auto_deps:
295                         # Temporarily resolve the swappable dependency to
296                         # prevent circular references. While keeping the
297                         # dependency checks on the resolved model, add the
298                         # swappable dependencies.
299                         original_dep = dep
300                         dep, is_swappable_dep = self._resolve_dependency(dep)
301                         if dep[0] != app_label:
302                             # External app dependency. See if it's not yet
303                             # satisfied.
304                             for other_operation in self.generated_operations.get(
305                                 dep[0], []
306                             ):
307                                 if self.check_dependency(other_operation, dep):
308                                     deps_satisfied = False
309                                     break
310                             if not deps_satisfied:
311                                 break
312                             else:
313                                 if is_swappable_dep:
314                                     operation_dependencies.add(
315                                         (original_dep[0], original_dep[1])
316                                     )
317                                 elif dep[0] in self.migrations:
318                                     operation_dependencies.add(
319                                         (dep[0], self.migrations[dep[0]][-1].name)
320                                     )
321                                 else:
322                                     # If we can't find the other app, we add a
323                                     # first/last dependency, but only if we've
324                                     # already been through once and checked
325                                     # everything.
326                                     if chop_mode:
327                                         # If the app already exists, we add a
328                                         # dependency on the last migration, as
329                                         # we don't know which migration
330                                         # contains the target field. If it's
331                                         # not yet migrated or has no
332                                         # migrations, we use __first__.
333                                         if graph and graph.leaf_nodes(dep[0]):
334                                             operation_dependencies.add(
335                                                 graph.leaf_nodes(dep[0])[0]
336                                             )
337                                         else:
338                                             operation_dependencies.add(
339                                                 (dep[0], "__first__")
340                                             )
341                                     else:
342                                         deps_satisfied = False
343                     if deps_satisfied:
344                         chopped.append(operation)
345                         dependencies.update(operation_dependencies)
346                         del self.generated_operations[app_label][0]
347                     else:
348                         break
349                 # Make a migration! Well, only if there's stuff to put in it
350                 if dependencies or chopped:
351                     if not self.generated_operations[app_label] or chop_mode:
352                         subclass = type(
353                             "Migration",
354                             (Migration,),
355                             {"operations": [], "dependencies": []},
356                         )
357                         instance = subclass(
358                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
359                             app_label,
360                         )
361                         instance.dependencies = list(dependencies)
362                         instance.operations = chopped
363                         instance.initial = app_label not in self.existing_apps
364                         self.migrations.setdefault(app_label, []).append(instance)
365                         chop_mode = False
366                     else:
367                         self.generated_operations[app_label] = (
368                             chopped + self.generated_operations[app_label]
369                         )
370             new_num_ops = sum(len(x) for x in self.generated_operations.values())
371             if new_num_ops == num_ops:
372                 if not chop_mode:
373                     chop_mode = True
374                 else:
375                     raise ValueError(
376                         "Cannot resolve operation dependencies: %r"
377                         % self.generated_operations
378                     )
379             num_ops = new_num_ops
380 
381     def _sort_migrations(self):
382         """
383         Reorder to make things possible. Reordering may be needed so FKs work
384         nicely inside the same app.
385         """
386         for app_label, ops in sorted(self.generated_operations.items()):
387             ts = TopologicalSorter()
388             for op in ops:
389                 ts.add(op)
390                 for dep in op._auto_deps:
391                     # Resolve intra-app dependencies to handle circular
392                     # references involving a swappable model.
393                     dep = self._resolve_dependency(dep)[0]
394                     if dep[0] != app_label:
395                         continue
396                     ts.add(op, *(x for x in ops if self.check_dependency(x, dep)))
397             self.generated_operations[app_label] = list(ts.static_order())
398 
399     def _optimize_migrations(self):
400         # Add in internal dependencies among the migrations
401         for app_label, migrations in self.migrations.items():
402             for m1, m2 in zip(migrations, migrations[1:]):
403                 m2.dependencies.append((app_label, m1.name))
404 
405         # De-dupe dependencies
406         for migrations in self.migrations.values():
407             for migration in migrations:
408                 migration.dependencies = list(set(migration.dependencies))
409 
410         # Optimize migrations
411         for app_label, migrations in self.migrations.items():
412             for migration in migrations:
413                 migration.operations = MigrationOptimizer().optimize(
414                     migration.operations, app_label
415                 )
416 
417     def check_dependency(self, operation, dependency):
418         """
419         Return True if the given operation depends on the given dependency,
420         False otherwise.
421         """
422         # Created model
423         if dependency[2] is None and dependency[3] is True:
424             return (
425                 isinstance(operation, operations.CreateModel)
426                 and operation.name_lower == dependency[1].lower()
427             )
428         # Created field
429         elif dependency[2] is not None and dependency[3] is True:
430             return (
431                 isinstance(operation, operations.CreateModel)
432                 and operation.name_lower == dependency[1].lower()
433                 and any(dependency[2] == x for x, y in operation.fields)
434             ) or (
435                 isinstance(operation, operations.AddField)
436                 and operation.model_name_lower == dependency[1].lower()
437                 and operation.name_lower == dependency[2].lower()
438             )
439         # Removed field
440         elif dependency[2] is not None and dependency[3] is False:
441             return (
442                 isinstance(operation, operations.RemoveField)
443                 and operation.model_name_lower == dependency[1].lower()
444                 and operation.name_lower == dependency[2].lower()
445             )
446         # Removed model
447         elif dependency[2] is None and dependency[3] is False:
448             return (
449                 isinstance(operation, operations.DeleteModel)
450                 and operation.name_lower == dependency[1].lower()
451             )
452         # Field being altered
453         elif dependency[2] is not None and dependency[3] == "alter":
454             return (
455                 isinstance(operation, operations.AlterField)
456                 and operation.model_name_lower == dependency[1].lower()
457                 and operation.name_lower == dependency[2].lower()
458             )
459         # order_with_respect_to being unset for a field
460         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
461             return (
462                 isinstance(operation, operations.AlterOrderWithRespectTo)
463                 and operation.name_lower == dependency[1].lower()
464                 and (operation.order_with_respect_to or "").lower()
465                 != dependency[2].lower()
466             )
467         # Field is removed and part of an index/unique_together
468         elif dependency[2] is not None and dependency[3] == "foo_together_change":
469             return (
470                 isinstance(
471                     operation,
472                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
473                 )
474                 and operation.name_lower == dependency[1].lower()
475             )
476         # Unknown dependency. Raise an error.
477         else:
478             raise ValueError("Can't handle dependency %r" % (dependency,))
479 
480     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
481         # Dependencies are
482         # (app_label, model_name, field_name, create/delete as True/False)
483         operation._auto_deps = dependencies or []
484         if beginning:
485             self.generated_operations.setdefault(app_label, []).insert(0, operation)
486         else:
487             self.generated_operations.setdefault(app_label, []).append(operation)
488 
489     def swappable_first_key(self, item):
490         """
491         Place potential swappable models first in lists of created models (only
492         real way to solve #22783).
493         """
494         try:
495             model_state = self.to_state.models[item]
496             base_names = {
497                 base if isinstance(base, str) else base.__name__
498                 for base in model_state.bases
499             }
500             string_version = "%s.%s" % (item[0], item[1])
501             if (
502                 model_state.options.get("swappable")
503                 or "AbstractUser" in base_names
504                 or "AbstractBaseUser" in base_names
505                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
506             ):
507                 return ("___" + item[0], "___" + item[1])
508         except LookupError:
509             pass
510         return item
511 
512     def generate_renamed_models(self):
513         """
514         Find any renamed models, generate the operations for them, and remove
515         the old entry from the model lists. Must be run before other
516         model-level generation.
517         """
518         self.renamed_models = {}
519         self.renamed_models_rel = {}
520         added_models = self.new_model_keys - self.old_model_keys
521         for app_label, model_name in sorted(added_models):
522             model_state = self.to_state.models[app_label, model_name]
523             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
524 
525             removed_models = self.old_model_keys - self.new_model_keys
526             for rem_app_label, rem_model_name in removed_models:
527                 if rem_app_label == app_label:
528                     rem_model_state = self.from_state.models[
529                         rem_app_label, rem_model_name
530                     ]
531                     rem_model_fields_def = self.only_relation_agnostic_fields(
532                         rem_model_state.fields
533                     )
534                     if model_fields_def == rem_model_fields_def:
535                         if self.questioner.ask_rename_model(
536                             rem_model_state, model_state
537                         ):
538                             dependencies = []
539                             fields = list(model_state.fields.values()) + [
540                                 field.remote_field
541                                 for relations in self.to_state.relations[
542                                     app_label, model_name
543                                 ].values()
544                                 for field in relations.values()
545                             ]
546                             for field in fields:
547                                 if field.is_relation:
548                                     dependencies.extend(
549                                         self._get_dependencies_for_foreign_key(
550                                             app_label,
551                                             model_name,
552                                             field,
553                                             self.to_state,
554                                         )
555                                     )
556                             self.add_operation(
557                                 app_label,
558                                 operations.RenameModel(
559                                     old_name=rem_model_state.name,
560                                     new_name=model_state.name,
561                                 ),
562                                 dependencies=dependencies,
563                             )
564                             self.renamed_models[app_label, model_name] = rem_model_name
565                             renamed_models_rel_key = "%s.%s" % (
566                                 rem_model_state.app_label,
567                                 rem_model_state.name_lower,
568                             )
569                             self.renamed_models_rel[
570                                 renamed_models_rel_key
571                             ] = "%s.%s" % (
572                                 model_state.app_label,
573                                 model_state.name_lower,
574                             )
575                             self.old_model_keys.remove((rem_app_label, rem_model_name))
576                             self.old_model_keys.add((app_label, model_name))
577                             break
578 
579     def generate_created_models(self):
580         """
581         Find all new models (both managed and unmanaged) and make create
582         operations for them as well as separate operations to create any
583         foreign key or M2M relationships (these are optimized later, if
584         possible).
585 
586         Defer any model options that refer to collections of fields that might
587         be deferred (e.g. unique_together, index_together).
588         """
589         old_keys = self.old_model_keys | self.old_unmanaged_keys
590         added_models = self.new_model_keys - old_keys
591         added_unmanaged_models = self.new_unmanaged_keys - old_keys
592         all_added_models = chain(
593             sorted(added_models, key=self.swappable_first_key, reverse=True),
594             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
595         )
596         for app_label, model_name in all_added_models:
597             model_state = self.to_state.models[app_label, model_name]
598             # Gather related fields
599             related_fields = {}
600             primary_key_rel = None
601             for field_name, field in model_state.fields.items():
602                 if field.remote_field:
603                     if field.remote_field.model:
604                         if field.primary_key:
605                             primary_key_rel = field.remote_field.model
606                         elif not field.remote_field.parent_link:
607                             related_fields[field_name] = field
608                     if getattr(field.remote_field, "through", None):
609                         related_fields[field_name] = field
610 
611             # Are there indexes/unique|index_together to defer?
612             indexes = model_state.options.pop("indexes")
613             constraints = model_state.options.pop("constraints")
614             unique_together = model_state.options.pop("unique_together", None)
615             # RemovedInDjango51Warning.
616             index_together = model_state.options.pop("index_together", None)
617             order_with_respect_to = model_state.options.pop(
618                 "order_with_respect_to", None
619             )
620             # Depend on the deletion of any possible proxy version of us
621             dependencies = [
622                 (app_label, model_name, None, False),
623             ]
624             # Depend on all bases
625             for base in model_state.bases:
626                 if isinstance(base, str) and "." in base:
627                     base_app_label, base_name = base.split(".", 1)
628                     dependencies.append((base_app_label, base_name, None, True))
629                     # Depend on the removal of base fields if the new model has
630                     # a field with the same name.
631                     old_base_model_state = self.from_state.models.get(
632                         (base_app_label, base_name)
633                     )
634                     new_base_model_state = self.to_state.models.get(
635                         (base_app_label, base_name)
636                     )
637                     if old_base_model_state and new_base_model_state:
638                         removed_base_fields = (
639                             set(old_base_model_state.fields)
640                             .difference(
641                                 new_base_model_state.fields,
642                             )
643                             .intersection(model_state.fields)
644                         )
645                         for removed_base_field in removed_base_fields:
646                             dependencies.append(
647                                 (base_app_label, base_name, removed_base_field, False)
648                             )
649             # Depend on the other end of the primary key if it's a relation
650             if primary_key_rel:
651                 dependencies.append(
652                     resolve_relation(
653                         primary_key_rel,
654                         app_label,
655                         model_name,
656                     )
657                     + (None, True)
658                 )
659             # Generate creation operation
660             self.add_operation(
661                 app_label,
662                 operations.CreateModel(
663                     name=model_state.name,
664                     fields=[
665                         d
666                         for d in model_state.fields.items()
667                         if d[0] not in related_fields
668                     ],
669                     options=model_state.options,
670                     bases=model_state.bases,
671                     managers=model_state.managers,
672                 ),
673                 dependencies=dependencies,
674                 beginning=True,
675             )
676 
677             # Don't add operations which modify the database for unmanaged models
678             if not model_state.options.get("managed", True):
679                 continue
680 
681             # Generate operations for each related field
682             for name, field in sorted(related_fields.items()):
683                 dependencies = self._get_dependencies_for_foreign_key(
684                     app_label,
685                     model_name,
686                     field,
687                     self.to_state,
688                 )
689                 # Depend on our own model being created
690                 dependencies.append((app_label, model_name, None, True))
691                 # Make operation
692                 self.add_operation(
693                     app_label,
694                     operations.AddField(
695                         model_name=model_name,
696                         name=name,
697                         field=field,
698                     ),
699                     dependencies=list(set(dependencies)),
700                 )
701             # Generate other opns
702             if order_with_respect_to:
703                 self.add_operation(
704                     app_label,
705                     operations.AlterOrderWithRespectTo(
706                         name=model_name,
707                         order_with_respect_to=order_with_respect_to,
708                     ),
709                     dependencies=[
710                         (app_label, model_name, order_with_respect_to, True),
711                         (app_label, model_name, None, True),
712                     ],
713                 )
714             related_dependencies = [
715                 (app_label, model_name, name, True) for name in sorted(related_fields)
716             ]
717             related_dependencies.append((app_label, model_name, None, True))
718             for index in indexes:
719                 self.add_operation(
720                     app_label,
721                     operations.AddIndex(
722                         model_name=model_name,
723                         index=index,
724                     ),
725                     dependencies=related_dependencies,
726                 )
727             for constraint in constraints:
728                 self.add_operation(
729                     app_label,
730                     operations.AddConstraint(
731                         model_name=model_name,
732                         constraint=constraint,
733                     ),
734                     dependencies=related_dependencies,
735                 )
736             if unique_together:
737                 self.add_operation(
738                     app_label,
739                     operations.AlterUniqueTogether(
740                         name=model_name,
741                         unique_together=unique_together,
742                     ),
743                     dependencies=related_dependencies,
744                 )
745             # RemovedInDjango51Warning.
746             if index_together:
747                 self.add_operation(
748                     app_label,
749                     operations.AlterIndexTogether(
750                         name=model_name,
751                         index_together=index_together,
752                     ),
753                     dependencies=related_dependencies,
754                 )
755             # Fix relationships if the model changed from a proxy model to a
756             # concrete model.
757             relations = self.to_state.relations
758             if (app_label, model_name) in self.old_proxy_keys:
759                 for related_model_key, related_fields in relations[
760                     app_label, model_name
761                 ].items():
762                     related_model_state = self.to_state.models[related_model_key]
763                     for related_field_name, related_field in related_fields.items():
764                         self.add_operation(
765                             related_model_state.app_label,
766                             operations.AlterField(
767                                 model_name=related_model_state.name,
768                                 name=related_field_name,
769                                 field=related_field,
770                             ),
771                             dependencies=[(app_label, model_name, None, True)],
772                         )
773 
774     def generate_created_proxies(self):
775         """
776         Make CreateModel statements for proxy models. Use the same statements
777         as that way there's less code duplication, but for proxy models it's
778         safe to skip all the pointless field stuff and chuck out an operation.
779         """
780         added = self.new_proxy_keys - self.old_proxy_keys
781         for app_label, model_name in sorted(added):
782             model_state = self.to_state.models[app_label, model_name]
783             assert model_state.options.get("proxy")
784             # Depend on the deletion of any possible non-proxy version of us
785             dependencies = [
786                 (app_label, model_name, None, False),
787             ]
788             # Depend on all bases
789             for base in model_state.bases:
790                 if isinstance(base, str) and "." in base:
791                     base_app_label, base_name = base.split(".", 1)
792                     dependencies.append((base_app_label, base_name, None, True))
793             # Generate creation operation
794             self.add_operation(
795                 app_label,
796                 operations.CreateModel(
797                     name=model_state.name,
798                     fields=[],
799                     options=model_state.options,
800                     bases=model_state.bases,
801                     managers=model_state.managers,
802                 ),
803                 # Depend on the deletion of any possible non-proxy version of us
804                 dependencies=dependencies,
805             )
806 
807     def generate_deleted_models(self):
808         """
809         Find all deleted models (managed and unmanaged) and make delete
810         operations for them as well as separate operations to delete any
811         foreign key or M2M relationships (these are optimized later, if
812         possible).
813 
814         Also bring forward removal of any model options that refer to
815         collections of fields - the inverse of generate_created_models().
816         """
817         new_keys = self.new_model_keys | self.new_unmanaged_keys
818         deleted_models = self.old_model_keys - new_keys
819         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
820         all_deleted_models = chain(
821             sorted(deleted_models), sorted(deleted_unmanaged_models)
822         )
823         for app_label, model_name in all_deleted_models:
824             model_state = self.from_state.models[app_label, model_name]
825             # Gather related fields
826             related_fields = {}
827             for field_name, field in model_state.fields.items():
828                 if field.remote_field:
829                     if field.remote_field.model:
830                         related_fields[field_name] = field
831                     if getattr(field.remote_field, "through", None):
832                         related_fields[field_name] = field
833             # Generate option removal first
834             unique_together = model_state.options.pop("unique_together", None)
835             # RemovedInDjango51Warning.
836             index_together = model_state.options.pop("index_together", None)
837             if unique_together:
838                 self.add_operation(
839                     app_label,
840                     operations.AlterUniqueTogether(
841                         name=model_name,
842                         unique_together=None,
843                     ),
844                 )
845             # RemovedInDjango51Warning.
846             if index_together:
847                 self.add_operation(
848                     app_label,
849                     operations.AlterIndexTogether(
850                         name=model_name,
851                         index_together=None,
852                     ),
853                 )
854             # Then remove each related field
855             for name in sorted(related_fields):
856                 self.add_operation(
857                     app_label,
858                     operations.RemoveField(
859                         model_name=model_name,
860                         name=name,
861                     ),
862                 )
863             # Finally, remove the model.
864             # This depends on both the removal/alteration of all incoming fields
865             # and the removal of all its own related fields, and if it's
866             # a through model the field that references it.
867             dependencies = []
868             relations = self.from_state.relations
869             for (
870                 related_object_app_label,
871                 object_name,
872             ), relation_related_fields in relations[app_label, model_name].items():
873                 for field_name, field in relation_related_fields.items():
874                     dependencies.append(
875                         (related_object_app_label, object_name, field_name, False),
876                     )
877                     if not field.many_to_many:
878                         dependencies.append(
879                             (
880                                 related_object_app_label,
881                                 object_name,
882                                 field_name,
883                                 "alter",
884                             ),
885                         )
886 
887             for name in sorted(related_fields):
888                 dependencies.append((app_label, model_name, name, False))
889             # We're referenced in another field's through=
890             through_user = self.through_users.get((app_label, model_state.name_lower))
891             if through_user:
892                 dependencies.append(
893                     (through_user[0], through_user[1], through_user[2], False)
894                 )
895             # Finally, make the operation, deduping any dependencies
896             self.add_operation(
897                 app_label,
898                 operations.DeleteModel(
899                     name=model_state.name,
900                 ),
901                 dependencies=list(set(dependencies)),
902             )
903 
904     def generate_deleted_proxies(self):
905         """Make DeleteModel options for proxy models."""
906         deleted = self.old_proxy_keys - self.new_proxy_keys
907         for app_label, model_name in sorted(deleted):
908             model_state = self.from_state.models[app_label, model_name]
909             assert model_state.options.get("proxy")
910             self.add_operation(
911                 app_label,
912                 operations.DeleteModel(
913                     name=model_state.name,
914                 ),
915             )
916 
917     def create_renamed_fields(self):
918         """Work out renamed fields."""
919         self.renamed_operations = []
920         old_field_keys = self.old_field_keys.copy()
921         for app_label, model_name, field_name in sorted(
922             self.new_field_keys - old_field_keys
923         ):
924             old_model_name = self.renamed_models.get(
925                 (app_label, model_name), model_name
926             )
927             old_model_state = self.from_state.models[app_label, old_model_name]
928             new_model_state = self.to_state.models[app_label, model_name]
929             field = new_model_state.get_field(field_name)
930             # Scan to see if this is actually a rename!
931             field_dec = self.deep_deconstruct(field)
932             for rem_app_label, rem_model_name, rem_field_name in sorted(
933                 old_field_keys - self.new_field_keys
934             ):
935                 if rem_app_label == app_label and rem_model_name == model_name:
936                     old_field = old_model_state.get_field(rem_field_name)
937                     old_field_dec = self.deep_deconstruct(old_field)
938                     if (
939                         field.remote_field
940                         and field.remote_field.model
941                         and "to" in old_field_dec[2]
942                     ):
943                         old_rel_to = old_field_dec[2]["to"]
944                         if old_rel_to in self.renamed_models_rel:
945                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
946                     old_field.set_attributes_from_name(rem_field_name)
947                     old_db_column = old_field.get_attname_column()[1]
948                     if old_field_dec == field_dec or (
949                         # Was the field renamed and db_column equal to the
950                         # old field's column added?
951                         old_field_dec[0:2] == field_dec[0:2]
952                         and dict(old_field_dec[2], db_column=old_db_column)
953                         == field_dec[2]
954                     ):
955                         if self.questioner.ask_rename(
956                             model_name, rem_field_name, field_name, field
957                         ):
958                             self.renamed_operations.append(
959                                 (
960                                     rem_app_label,
961                                     rem_model_name,
962                                     old_field.db_column,
963                                     rem_field_name,
964                                     app_label,
965                                     model_name,
966                                     field,
967                                     field_name,
968                                 )
969                             )
970                             old_field_keys.remove(
971                                 (rem_app_label, rem_model_name, rem_field_name)
972                             )
973                             old_field_keys.add((app_label, model_name, field_name))
974                             self.renamed_fields[
975                                 app_label, model_name, field_name
976                             ] = rem_field_name
977                             break
978 
979     def generate_renamed_fields(self):
980         """Generate RenameField operations."""
981         for (
982             rem_app_label,
983             rem_model_name,
984             rem_db_column,
985             rem_field_name,
986             app_label,
987             model_name,
988             field,
989             field_name,
990         ) in self.renamed_operations:
991             # A db_column mismatch requires a prior noop AlterField for the
992             # subsequent RenameField to be a noop on attempts at preserving the
993             # old name.
994             if rem_db_column != field.db_column:
995                 altered_field = field.clone()
996                 altered_field.name = rem_field_name
997                 self.add_operation(
998                     app_label,
999                     operations.AlterField(
1000                         model_name=model_name,
1001                         name=rem_field_name,
1002                         field=altered_field,
1003                     ),
1004                 )
1005             self.add_operation(
1006                 app_label,
1007                 operations.RenameField(
1008                     model_name=model_name,
1009                     old_name=rem_field_name,
1010                     new_name=field_name,
1011                 ),
1012             )
1013             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1014             self.old_field_keys.add((app_label, model_name, field_name))
1015 
1016     def generate_added_fields(self):
1017         """Make AddField operations."""
1018         for app_label, model_name, field_name in sorted(
1019             self.new_field_keys - self.old_field_keys
1020         ):
1021             self._generate_added_field(app_label, model_name, field_name)
1022 
1023     def _generate_added_field(self, app_label, model_name, field_name):
1024         field = self.to_state.models[app_label, model_name].get_field(field_name)
1025         # Adding a field always depends at least on its removal.
1026         dependencies = [(app_label, model_name, field_name, False)]
1027         # Fields that are foreignkeys/m2ms depend on stuff.
1028         if field.remote_field and field.remote_field.model:
1029             dependencies.extend(
1030                 self._get_dependencies_for_foreign_key(
1031                     app_label,
1032                     model_name,
1033                     field,
1034                     self.to_state,
1035                 )
1036             )
1037         # You can't just add NOT NULL fields with no default or fields
1038         # which don't allow empty strings as default.
1039         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1040         preserve_default = (
1041             field.null
1042             or field.has_default()
1043             or field.many_to_many
1044             or (field.blank and field.empty_strings_allowed)
1045             or (isinstance(field, time_fields) and field.auto_now)
1046         )
1047         if not preserve_default:
1048             field = field.clone()
1049             if isinstance(field, time_fields) and field.auto_now_add:
1050                 field.default = self.questioner.ask_auto_now_add_addition(
1051                     field_name, model_name
1052                 )
1053             else:
1054                 field.default = self.questioner.ask_not_null_addition(
1055                     field_name, model_name
1056                 )
1057         if (
1058             field.unique
1059             and field.default is not models.NOT_PROVIDED
1060             and callable(field.default)
1061         ):
1062             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1063         self.add_operation(
1064             app_label,
1065             operations.AddField(
1066                 model_name=model_name,
1067                 name=field_name,
1068                 field=field,
1069                 preserve_default=preserve_default,
1070             ),
1071             dependencies=dependencies,
1072         )
1073 
1074     def generate_removed_fields(self):
1075         """Make RemoveField operations."""
1076         for app_label, model_name, field_name in sorted(
1077             self.old_field_keys - self.new_field_keys
1078         ):
1079             self._generate_removed_field(app_label, model_name, field_name)
1080 
1081     def _generate_removed_field(self, app_label, model_name, field_name):
1082         self.add_operation(
1083             app_label,
1084             operations.RemoveField(
1085                 model_name=model_name,
1086                 name=field_name,
1087             ),
1088             # We might need to depend on the removal of an
1089             # order_with_respect_to or index/unique_together operation;
1090             # this is safely ignored if there isn't one
1091             dependencies=[
1092                 (app_label, model_name, field_name, "order_wrt_unset"),
1093                 (app_label, model_name, field_name, "foo_together_change"),
1094             ],
1095         )
1096 
1097     def generate_altered_fields(self):
1098         """
1099         Make AlterField operations, or possibly RemovedField/AddField if alter
1100         isn't possible.
1101         """
1102         for app_label, model_name, field_name in sorted(
1103             self.old_field_keys & self.new_field_keys
1104         ):
1105             # Did the field change?
1106             old_model_name = self.renamed_models.get(
1107                 (app_label, model_name), model_name
1108             )
1109             old_field_name = self.renamed_fields.get(
1110                 (app_label, model_name, field_name), field_name
1111             )
1112             old_field = self.from_state.models[app_label, old_model_name].get_field(
1113                 old_field_name
1114             )
1115             new_field = self.to_state.models[app_label, model_name].get_field(
1116                 field_name
1117             )
1118             dependencies = []
1119             # Implement any model renames on relations; these are handled by RenameModel
1120             # so we need to exclude them from the comparison
1121             if hasattr(new_field, "remote_field") and getattr(
1122                 new_field.remote_field, "model", None
1123             ):
1124                 rename_key = resolve_relation(
1125                     new_field.remote_field.model, app_label, model_name
1126                 )
1127                 if rename_key in self.renamed_models:
1128                     new_field.remote_field.model = old_field.remote_field.model
1129                 # Handle ForeignKey which can only have a single to_field.
1130                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1131                 if remote_field_name:
1132                     to_field_rename_key = rename_key + (remote_field_name,)
1133                     if to_field_rename_key in self.renamed_fields:
1134                         # Repoint both model and field name because to_field
1135                         # inclusion in ForeignKey.deconstruct() is based on
1136                         # both.
1137                         new_field.remote_field.model = old_field.remote_field.model
1138                         new_field.remote_field.field_name = (
1139                             old_field.remote_field.field_name
1140                         )
1141                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1142                 from_fields = getattr(new_field, "from_fields", None)
1143                 if from_fields:
1144                     from_rename_key = (app_label, model_name)
1145                     new_field.from_fields = tuple(
1146                         [
1147                             self.renamed_fields.get(
1148                                 from_rename_key + (from_field,), from_field
1149                             )
1150                             for from_field in from_fields
1151                         ]
1152                     )
1153                     new_field.to_fields = tuple(
1154                         [
1155                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1156                             for to_field in new_field.to_fields
1157                         ]
1158                     )
1159                 dependencies.extend(
1160                     self._get_dependencies_for_foreign_key(
1161                         app_label,
1162                         model_name,
1163                         new_field,
1164                         self.to_state,
1165                     )
1166                 )
1167             if hasattr(new_field, "remote_field") and getattr(
1168                 new_field.remote_field, "through", None
1169             ):
1170                 rename_key = resolve_relation(
1171                     new_field.remote_field.through, app_label, model_name
1172                 )
1173                 if rename_key in self.renamed_models:
1174                     new_field.remote_field.through = old_field.remote_field.through
1175             old_field_dec = self.deep_deconstruct(old_field)
1176             new_field_dec = self.deep_deconstruct(new_field)
1177             # If the field was confirmed to be renamed it means that only
1178             # db_column was allowed to change which generate_renamed_fields()
1179             # already accounts for by adding an AlterField operation.
1180             if old_field_dec != new_field_dec and old_field_name == field_name:
1181                 both_m2m = old_field.many_to_many and new_field.many_to_many
1182                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1183                 if both_m2m or neither_m2m:
1184                     # Either both fields are m2m or neither is
1185                     preserve_default = True
1186                     if (
1187                         old_field.null
1188                         and not new_field.null
1189                         and not new_field.has_default()
1190                         and not new_field.many_to_many
1191                     ):
1192                         field = new_field.clone()
1193                         new_default = self.questioner.ask_not_null_alteration(
1194                             field_name, model_name
1195                         )
1196                         if new_default is not models.NOT_PROVIDED:
1197                             field.default = new_default
1198                             preserve_default = False
1199                     else:
1200                         field = new_field
1201                     self.add_operation(
1202                         app_label,
1203                         operations.AlterField(
1204                             model_name=model_name,
1205                             name=field_name,
1206                             field=field,
1207                             preserve_default=preserve_default,
1208                         ),
1209                         dependencies=dependencies,
1210                     )
1211                 else:
1212                     # We cannot alter between m2m and concrete fields
1213                     self._generate_removed_field(app_label, model_name, field_name)
1214                     self._generate_added_field(app_label, model_name, field_name)
1215 
1216     def create_altered_indexes(self):
1217         option_name = operations.AddIndex.option_name
1218         self.renamed_index_together_values = defaultdict(list)
1219 
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get(
1222                 (app_label, model_name), model_name
1223             )
1224             old_model_state = self.from_state.models[app_label, old_model_name]
1225             new_model_state = self.to_state.models[app_label, model_name]
1226 
1227             old_indexes = old_model_state.options[option_name]
1228             new_indexes = new_model_state.options[option_name]
1229             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1230             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1231             renamed_indexes = []
1232             # Find renamed indexes.
1233             remove_from_added = []
1234             remove_from_removed = []
1235             for new_index in added_indexes:
1236                 new_index_dec = new_index.deconstruct()
1237                 new_index_name = new_index_dec[2].pop("name")
1238                 for old_index in removed_indexes:
1239                     old_index_dec = old_index.deconstruct()
1240                     old_index_name = old_index_dec[2].pop("name")
1241                     # Indexes are the same except for the names.
1242                     if (
1243                         new_index_dec == old_index_dec
1244                         and new_index_name != old_index_name
1245                     ):
1246                         renamed_indexes.append((old_index_name, new_index_name, None))
1247                         remove_from_added.append(new_index)
1248                         remove_from_removed.append(old_index)
1249             # Find index_together changed to indexes.
1250             for (
1251                 old_value,
1252                 new_value,
1253                 index_together_app_label,
1254                 index_together_model_name,
1255                 dependencies,
1256             ) in self._get_altered_foo_together_operations(
1257                 operations.AlterIndexTogether.option_name
1258             ):
1259                 if (
1260                     app_label != index_together_app_label
1261                     or model_name != index_together_model_name
1262                 ):
1263                     continue
1264                 removed_values = old_value.difference(new_value)
1265                 for removed_index_together in removed_values:
1266                     renamed_index_together_indexes = []
1267                     for new_index in added_indexes:
1268                         _, args, kwargs = new_index.deconstruct()
1269                         # Ensure only 'fields' are defined in the Index.
1270                         if (
1271                             not args
1272                             and new_index.fields == list(removed_index_together)
1273                             and set(kwargs) == {"name", "fields"}
1274                         ):
1275                             renamed_index_together_indexes.append(new_index)
1276 
1277                     if len(renamed_index_together_indexes) == 1:
1278                         renamed_index = renamed_index_together_indexes[0]
1279                         remove_from_added.append(renamed_index)
1280                         renamed_indexes.append(
1281                             (None, renamed_index.name, removed_index_together)
1282                         )
1283                         self.renamed_index_together_values[
1284                             index_together_app_label, index_together_model_name
1285                         ].append(removed_index_together)
1286             # Remove renamed indexes from the lists of added and removed
1287             # indexes.
1288             added_indexes = [
1289                 idx for idx in added_indexes if idx not in remove_from_added
1290             ]
1291             removed_indexes = [
1292                 idx for idx in removed_indexes if idx not in remove_from_removed
1293             ]
1294 
1295             self.altered_indexes.update(
1296                 {
1297                     (app_label, model_name): {
1298                         "added_indexes": added_indexes,
1299                         "removed_indexes": removed_indexes,
1300                         "renamed_indexes": renamed_indexes,
1301                     }
1302                 }
1303             )
1304 
1305     def generate_added_indexes(self):
1306         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1307             for index in alt_indexes["added_indexes"]:
1308                 self.add_operation(
1309                     app_label,
1310                     operations.AddIndex(
1311                         model_name=model_name,
1312                         index=index,
1313                     ),
1314                 )
1315 
1316     def generate_removed_indexes(self):
1317         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1318             for index in alt_indexes["removed_indexes"]:
1319                 self.add_operation(
1320                     app_label,
1321                     operations.RemoveIndex(
1322                         model_name=model_name,
1323                         name=index.name,
1324                     ),
1325                 )
1326 
1327     def generate_renamed_indexes(self):
1328         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1329             for old_index_name, new_index_name, old_fields in alt_indexes[
1330                 "renamed_indexes"
1331             ]:
1332                 self.add_operation(
1333                     app_label,
1334                     operations.RenameIndex(
1335                         model_name=model_name,
1336                         new_name=new_index_name,
1337                         old_name=old_index_name,
1338                         old_fields=old_fields,
1339                     ),
1340                 )
1341 
1342     def create_altered_constraints(self):
1343         option_name = operations.AddConstraint.option_name
1344         for app_label, model_name in sorted(self.kept_model_keys):
1345             old_model_name = self.renamed_models.get(
1346                 (app_label, model_name), model_name
1347             )
1348             old_model_state = self.from_state.models[app_label, old_model_name]
1349             new_model_state = self.to_state.models[app_label, model_name]
1350 
1351             old_constraints = old_model_state.options[option_name]
1352             new_constraints = new_model_state.options[option_name]
1353             add_constraints = [c for c in new_constraints if c not in old_constraints]
1354             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1355 
1356             self.altered_constraints.update(
1357                 {
1358                     (app_label, model_name): {
1359                         "added_constraints": add_constraints,
1360                         "removed_constraints": rem_constraints,
1361                     }
1362                 }
1363             )
1364 
1365     def generate_added_constraints(self):
1366         for (
1367             app_label,
1368             model_name,
1369         ), alt_constraints in self.altered_constraints.items():
1370             for constraint in alt_constraints["added_constraints"]:
1371                 self.add_operation(
1372                     app_label,
1373                     operations.AddConstraint(
1374                         model_name=model_name,
1375                         constraint=constraint,
1376                     ),
1377                 )
1378 
1379     def generate_removed_constraints(self):
1380         for (
1381             app_label,
1382             model_name,
1383         ), alt_constraints in self.altered_constraints.items():
1384             for constraint in alt_constraints["removed_constraints"]:
1385                 self.add_operation(
1386                     app_label,
1387                     operations.RemoveConstraint(
1388                         model_name=model_name,
1389                         name=constraint.name,
1390                     ),
1391                 )
1392 
1393     @staticmethod
1394     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1395         remote_field_model = None
1396         if hasattr(field.remote_field, "model"):
1397             remote_field_model = field.remote_field.model
1398         else:
1399             relations = project_state.relations[app_label, model_name]
1400             for (remote_app_label, remote_model_name), fields in relations.items():
1401                 if any(
1402                     field == related_field.remote_field
1403                     for related_field in fields.values()
1404                 ):
1405                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1406                     break
1407         # Account for FKs to swappable models
1408         swappable_setting = getattr(field, "swappable_setting", None)
1409         if swappable_setting is not None:
1410             dep_app_label = "__setting__"
1411             dep_object_name = swappable_setting
1412         else:
1413             dep_app_label, dep_object_name = resolve_relation(
1414                 remote_field_model,
1415                 app_label,
1416                 model_name,
1417             )
1418         dependencies = [(dep_app_label, dep_object_name, None, True)]
1419         if getattr(field.remote_field, "through", None):
1420             through_app_label, through_object_name = resolve_relation(
1421                 field.remote_field.through,
1422                 app_label,
1423                 model_name,
1424             )
1425             dependencies.append((through_app_label, through_object_name, None, True))
1426         return dependencies
1427 
1428     def _get_altered_foo_together_operations(self, option_name):
1429         for app_label, model_name in sorted(self.kept_model_keys):
1430             old_model_name = self.renamed_models.get(
1431                 (app_label, model_name), model_name
1432             )
1433             old_model_state = self.from_state.models[app_label, old_model_name]
1434             new_model_state = self.to_state.models[app_label, model_name]
1435 
1436             # We run the old version through the field renames to account for those
1437             old_value = old_model_state.options.get(option_name)
1438             old_value = (
1439                 {
1440                     tuple(
1441                         self.renamed_fields.get((app_label, model_name, n), n)
1442                         for n in unique
1443                     )
1444                     for unique in old_value
1445                 }
1446                 if old_value
1447                 else set()
1448             )
1449 
1450             new_value = new_model_state.options.get(option_name)
1451             new_value = set(new_value) if new_value else set()
1452 
1453             if old_value != new_value:
1454                 dependencies = []
1455                 for foo_togethers in new_value:
1456                     for field_name in foo_togethers:
1457                         field = new_model_state.get_field(field_name)
1458                         if field.remote_field and field.remote_field.model:
1459                             dependencies.extend(
1460                                 self._get_dependencies_for_foreign_key(
1461                                     app_label,
1462                                     model_name,
1463                                     field,
1464                                     self.to_state,
1465                                 )
1466                             )
1467                 yield (
1468                     old_value,
1469                     new_value,
1470                     app_label,
1471                     model_name,
1472                     dependencies,
1473                 )
1474 
1475     def _generate_removed_altered_foo_together(self, operation):
1476         for (
1477             old_value,
1478             new_value,
1479             app_label,
1480             model_name,
1481             dependencies,
1482         ) in self._get_altered_foo_together_operations(operation.option_name):
1483             if operation == operations.AlterIndexTogether:
1484                 old_value = {
1485                     value
1486                     for value in old_value
1487                     if value
1488                     not in self.renamed_index_together_values[app_label, model_name]
1489                 }
1490             removal_value = new_value.intersection(old_value)
1491             if removal_value or old_value:
1492                 self.add_operation(
1493                     app_label,
1494                     operation(
1495                         name=model_name, **{operation.option_name: removal_value}
1496                     ),
1497                     dependencies=dependencies,
1498                 )
1499 
1500     def generate_removed_altered_unique_together(self):
1501         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1502 
1503     # RemovedInDjango51Warning.
1504     def generate_removed_altered_index_together(self):
1505         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1506 
1507     def _generate_altered_foo_together(self, operation):
1508         for (
1509             old_value,
1510             new_value,
1511             app_label,
1512             model_name,
1513             dependencies,
1514         ) in self._get_altered_foo_together_operations(operation.option_name):
1515             removal_value = new_value.intersection(old_value)
1516             if new_value != removal_value:
1517                 self.add_operation(
1518                     app_label,
1519                     operation(name=model_name, **{operation.option_name: new_value}),
1520                     dependencies=dependencies,
1521                 )
1522 
1523     def generate_altered_unique_together(self):
1524         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1525 
1526     # RemovedInDjango51Warning.
1527     def generate_altered_index_together(self):
1528         self._generate_altered_foo_together(operations.AlterIndexTogether)
1529 
1530     def generate_altered_db_table(self):
1531         models_to_check = self.kept_model_keys.union(
1532             self.kept_proxy_keys, self.kept_unmanaged_keys
1533         )
1534         for app_label, model_name in sorted(models_to_check):
1535             old_model_name = self.renamed_models.get(
1536                 (app_label, model_name), model_name
1537             )
1538             old_model_state = self.from_state.models[app_label, old_model_name]
1539             new_model_state = self.to_state.models[app_label, model_name]
1540             old_db_table_name = old_model_state.options.get("db_table")
1541             new_db_table_name = new_model_state.options.get("db_table")
1542             if old_db_table_name != new_db_table_name:
1543                 self.add_operation(
1544                     app_label,
1545                     operations.AlterModelTable(
1546                         name=model_name,
1547                         table=new_db_table_name,
1548                     ),
1549                 )
1550 
1551     def generate_altered_db_table_comment(self):
1552         models_to_check = self.kept_model_keys.union(
1553             self.kept_proxy_keys, self.kept_unmanaged_keys
1554         )
1555         for app_label, model_name in sorted(models_to_check):
1556             old_model_name = self.renamed_models.get(
1557                 (app_label, model_name), model_name
1558             )
1559             old_model_state = self.from_state.models[app_label, old_model_name]
1560             new_model_state = self.to_state.models[app_label, model_name]
1561 
1562             old_db_table_comment = old_model_state.options.get("db_table_comment")
1563             new_db_table_comment = new_model_state.options.get("db_table_comment")
1564             if old_db_table_comment != new_db_table_comment:
1565                 self.add_operation(
1566                     app_label,
1567                     operations.AlterModelTableComment(
1568                         name=model_name,
1569                         table_comment=new_db_table_comment,
1570                     ),
1571                 )
1572 
1573     def generate_altered_options(self):
1574         """
1575         Work out if any non-schema-affecting options have changed and make an
1576         operation to represent them in state changes (in case Python code in
1577         migrations needs them).
1578         """
1579         models_to_check = self.kept_model_keys.union(
1580             self.kept_proxy_keys,
1581             self.kept_unmanaged_keys,
1582             # unmanaged converted to managed
1583             self.old_unmanaged_keys & self.new_model_keys,
1584             # managed converted to unmanaged
1585             self.old_model_keys & self.new_unmanaged_keys,
1586         )
1587 
1588         for app_label, model_name in sorted(models_to_check):
1589             old_model_name = self.renamed_models.get(
1590                 (app_label, model_name), model_name
1591             )
1592             old_model_state = self.from_state.models[app_label, old_model_name]
1593             new_model_state = self.to_state.models[app_label, model_name]
1594             old_options = {
1595                 key: value
1596                 for key, value in old_model_state.options.items()
1597                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1598             }
1599             new_options = {
1600                 key: value
1601                 for key, value in new_model_state.options.items()
1602                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1603             }
1604             if old_options != new_options:
1605                 self.add_operation(
1606                     app_label,
1607                     operations.AlterModelOptions(
1608                         name=model_name,
1609                         options=new_options,
1610                     ),
1611                 )
1612 
1613     def generate_altered_order_with_respect_to(self):
1614         for app_label, model_name in sorted(self.kept_model_keys):
1615             old_model_name = self.renamed_models.get(
1616                 (app_label, model_name), model_name
1617             )
1618             old_model_state = self.from_state.models[app_label, old_model_name]
1619             new_model_state = self.to_state.models[app_label, model_name]
1620             if old_model_state.options.get(
1621                 "order_with_respect_to"
1622             ) != new_model_state.options.get("order_with_respect_to"):
1623                 # Make sure it comes second if we're adding
1624                 # (removal dependency is part of RemoveField)
1625                 dependencies = []
1626                 if new_model_state.options.get("order_with_respect_to"):
1627                     dependencies.append(
1628                         (
1629                             app_label,
1630                             model_name,
1631                             new_model_state.options["order_with_respect_to"],
1632                             True,
1633                         )
1634                     )
1635                 # Actually generate the operation
1636                 self.add_operation(
1637                     app_label,
1638                     operations.AlterOrderWithRespectTo(
1639                         name=model_name,
1640                         order_with_respect_to=new_model_state.options.get(
1641                             "order_with_respect_to"
1642                         ),
1643                     ),
1644                     dependencies=dependencies,
1645                 )
1646 
1647     def generate_altered_managers(self):
1648         for app_label, model_name in sorted(self.kept_model_keys):
1649             old_model_name = self.renamed_models.get(
1650                 (app_label, model_name), model_name
1651             )
1652             old_model_state = self.from_state.models[app_label, old_model_name]
1653             new_model_state = self.to_state.models[app_label, model_name]
1654             if old_model_state.managers != new_model_state.managers:
1655                 self.add_operation(
1656                     app_label,
1657                     operations.AlterModelManagers(
1658                         name=model_name,
1659                         managers=new_model_state.managers,
1660                     ),
1661                 )
1662 
1663     def arrange_for_graph(self, changes, graph, migration_name=None):
1664         """
1665         Take a result from changes() and a MigrationGraph, and fix the names
1666         and dependencies of the changes so they extend the graph from the leaf
1667         nodes for each app.
1668         """
1669         leaves = graph.leaf_nodes()
1670         name_map = {}
1671         for app_label, migrations in list(changes.items()):
1672             if not migrations:
1673                 continue
1674             # Find the app label's current leaf node
1675             app_leaf = None
1676             for leaf in leaves:
1677                 if leaf[0] == app_label:
1678                     app_leaf = leaf
1679                     break
1680             # Do they want an initial migration for this app?
1681             if app_leaf is None and not self.questioner.ask_initial(app_label):
1682                 # They don't.
1683                 for migration in migrations:
1684                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1685                 del changes[app_label]
1686                 continue
1687             # Work out the next number in the sequence
1688             if app_leaf is None:
1689                 next_number = 1
1690             else:
1691                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1692             # Name each migration
1693             for i, migration in enumerate(migrations):
1694                 if i == 0 and app_leaf:
1695                     migration.dependencies.append(app_leaf)
1696                 new_name_parts = ["%04i" % next_number]
1697                 if migration_name:
1698                     new_name_parts.append(migration_name)
1699                 elif i == 0 and not app_leaf:
1700                     new_name_parts.append("initial")
1701                 else:
1702                     new_name_parts.append(migration.suggest_name()[:100])
1703                 new_name = "_".join(new_name_parts)
1704                 name_map[(app_label, migration.name)] = (app_label, new_name)
1705                 next_number += 1
1706                 migration.name = new_name
1707         # Now fix dependencies
1708         for migrations in changes.values():
1709             for migration in migrations:
1710                 migration.dependencies = [
1711                     name_map.get(d, d) for d in migration.dependencies
1712                 ]
1713         return changes
1714 
1715     def _trim_to_apps(self, changes, app_labels):
1716         """
1717         Take changes from arrange_for_graph() and set of app labels, and return
1718         a modified set of changes which trims out as many migrations that are
1719         not in app_labels as possible. Note that some other migrations may
1720         still be present as they may be required dependencies.
1721         """
1722         # Gather other app dependencies in a first pass
1723         app_dependencies = {}
1724         for app_label, migrations in changes.items():
1725             for migration in migrations:
1726                 for dep_app_label, name in migration.dependencies:
1727                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1728         required_apps = set(app_labels)
1729         # Keep resolving till there's no change
1730         old_required_apps = None
1731         while old_required_apps != required_apps:
1732             old_required_apps = set(required_apps)
1733             required_apps.update(
1734                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1735             )
1736         # Remove all migrations that aren't needed
1737         for app_label in list(changes):
1738             if app_label not in required_apps:
1739                 del changes[app_label]
1740         return changes
1741 
1742     @classmethod
1743     def parse_number(cls, name):
1744         """
1745         Given a migration name, try to extract a number from the beginning of
1746         it. For a squashed migration such as '0001_squashed_0004â€¦', return the
1747         second number. If no number is found, return None.
1748         """
1749         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1750             return int(squashed_match[1])
1751         match = re.match(r"^\d+", name)
1752         if match:
1753             return int(match[0])
1754         return None

</code><intended_behavior>This component should detect when a model involved in a M2M relationship is being renamed and either automatically generate additional operations to handle the renaming of related fields in intermediary tables or alert the developer to the need for manual intervention. The detection algorithm could be improved to anticipate the complications of renaming models involved in complex relationships and provide more comprehensive migration steps to maintain integrity.</intended_behavior>, <file>django/contrib/contenttypes/management/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.apps import apps as global_apps
2 from django.db import DEFAULT_DB_ALIAS, IntegrityError, migrations, router, transaction
3 
4 
5 class RenameContentType(migrations.RunPython):
6     def __init__(self, app_label, old_model, new_model):
7         self.app_label = app_label
8         self.old_model = old_model
9         self.new_model = new_model
10         super().__init__(self.rename_forward, self.rename_backward)
11 
12     def _rename(self, apps, schema_editor, old_model, new_model):
13         ContentType = apps.get_model("contenttypes", "ContentType")
14         db = schema_editor.connection.alias
15         if not router.allow_migrate_model(db, ContentType):
16             return
17 
18         try:
19             content_type = ContentType.objects.db_manager(db).get_by_natural_key(
20                 self.app_label, old_model
21             )
22         except ContentType.DoesNotExist:
23             pass
24         else:
25             content_type.model = new_model
26             try:
27                 with transaction.atomic(using=db):
28                     content_type.save(using=db, update_fields={"model"})
29             except IntegrityError:
30                 # Gracefully fallback if a stale content type causes a
31                 # conflict as remove_stale_contenttypes will take care of
32                 # asking the user what should be done next.
33                 content_type.model = old_model
34             else:
35                 # Clear the cache as the `get_by_natural_key()` call will cache
36                 # the renamed ContentType instance by its old model name.
37                 ContentType.objects.clear_cache()
38 
39     def rename_forward(self, apps, schema_editor):
40         self._rename(apps, schema_editor, self.old_model, self.new_model)
41 
42     def rename_backward(self, apps, schema_editor):
43         self._rename(apps, schema_editor, self.new_model, self.old_model)
44 
45 
46 def inject_rename_contenttypes_operations(
47     plan=None, apps=global_apps, using=DEFAULT_DB_ALIAS, **kwargs
48 ):
49     """
50     Insert a `RenameContentType` operation after every planned `RenameModel`
51     operation.
52     """
53     if plan is None:
54         return
55 
56     # Determine whether or not the ContentType model is available.
57     try:
58         ContentType = apps.get_model("contenttypes", "ContentType")
59     except LookupError:
60         available = False
61     else:
62         if not router.allow_migrate_model(using, ContentType):
63             return
64         available = True
65 
66     for migration, backward in plan:
67         if (migration.app_label, migration.name) == ("contenttypes", "0001_initial"):
68             # There's no point in going forward if the initial contenttypes
69             # migration is unapplied as the ContentType model will be
70             # unavailable from this point.
71             if backward:
72                 break
73             else:
74                 available = True
75                 continue
76         # The ContentType model is not available yet.
77         if not available:
78             continue
79         inserts = []
80         for index, operation in enumerate(migration.operations):
81             if isinstance(operation, migrations.RenameModel):
82                 operation = RenameContentType(
83                     migration.app_label,
84                     operation.old_name_lower,
85                     operation.new_name_lower,
86                 )
87                 inserts.append((index + 1, operation))
88         for inserted, (index, operation) in enumerate(inserts):
89             migration.operations.insert(inserted + index, operation)
90 
91 
92 def get_contenttypes_and_models(app_config, using, ContentType):
93     if not router.allow_migrate_model(using, ContentType):
94         return None, None
95 
96     ContentType.objects.clear_cache()
97 
98     content_types = {
99         ct.model: ct
100         for ct in ContentType.objects.using(using).filter(app_label=app_config.label)
101     }
102     app_models = {model._meta.model_name: model for model in app_config.get_models()}
103     return content_types, app_models
104 
105 
106 def create_contenttypes(
107     app_config,
108     verbosity=2,
109     interactive=True,
110     using=DEFAULT_DB_ALIAS,
111     apps=global_apps,
112     **kwargs,
113 ):
114     """
115     Create content types for models in the given app.
116     """
117     if not app_config.models_module:
118         return
119 
120     app_label = app_config.label
121     try:
122         app_config = apps.get_app_config(app_label)
123         ContentType = apps.get_model("contenttypes", "ContentType")
124     except LookupError:
125         return
126 
127     content_types, app_models = get_contenttypes_and_models(
128         app_config, using, ContentType
129     )
130 
131     if not app_models:
132         return
133 
134     cts = [
135         ContentType(
136             app_label=app_label,
137             model=model_name,
138         )
139         for (model_name, model) in app_models.items()
140         if model_name not in content_types
141     ]
142     ContentType.objects.using(using).bulk_create(cts)
143     if verbosity >= 2:
144         for ct in cts:
145             print("Adding content type '%s | %s'" % (ct.app_label, ct.model))

</code><intended_behavior>While this area might not be directly involved in the specific KeyError reported, ensuring that ContentType records are accurately updated during model renames is crucial for the overall integrity of Django's content type framework, especially in applications relying heavily on generic relations. The intended behavior is a thorough update process that reflects model renaming across all ContentType references, which could indirectly affect M2M relationships through generic ForeignKey fields.</intended_behavior>]
2025-10-18 13:36:43.663 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 13:36:43.664 | INFO     | Search-only: skipping patch selection
2025-10-18 13:36:43.821 | INFO     | Task django__django-16532 completed successfully.
2025-10-18 13:36:43.822 | INFO     | No patch generated. You can try running ACR again.
