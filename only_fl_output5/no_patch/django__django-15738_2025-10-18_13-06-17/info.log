2025-10-18 13:06:17.679 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 13:06:20.656 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=530, output_tokens=12, cost=0.005660
2025-10-18 13:06:20.656 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 13:06:20.660 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:06:26.550 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=817, output_tokens=270, cost=0.016270
2025-10-18 13:06:26.554 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:06:29.423 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=624, output_tokens=68, cost=0.008280
2025-10-18 13:06:29.424 | DEBUG    | Extracted a valid json.
2025-10-18 13:06:29.424 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Authors\")",
        "search_class(\"DataSet\")",
        "search_class(\"Project\")",
        "search_class(\"ProjectDataSet\")",
        "search_method(\"makemigrations\")",
        "search_method(\"migrate\")"
    ],
    "bug_locations": []
}
2025-10-18 13:06:29.441 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:06:29.442 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:06:45.133 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2412, output_tokens=693, cost=0.044910
2025-10-18 13:06:45.144 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:06:55.349 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3321, output_tokens=450, cost=0.046710
2025-10-18 13:06:55.358 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:07:02.322 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=804, output_tokens=256, cost=0.015720
2025-10-18 13:07:02.323 | DEBUG    | Extracted a valid json.
2025-10-18 13:07:02.323 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "Migration file(s) generated for the `Authors` model alterations",
            "class": "",
            "method": "",
            "intended_behavior": "The migration files responsible for handling the transition of the `project_data_set` field in the `Authors` model from a ForeignKey to a ManyToManyField should correctly manage the removal of the `unique_together` constraint tied to the ForeignKey relationship. This should be done in a way that does not confuse Django's migration system, possibly requiring a custom migration operation that explicitly instructs Django on how to handle this transition, ensuring that the constraint is properly removed before changing the field type."
        },
        {
            "file": "App's models.py",
            "class": "Authors",
            "method": "",
            "intended_behavior": "Within the `Authors` model definition, when transitioning `project_data_set` to a ManyToManyField, ensure that any related unique constraints (`unique_together`) or other database-level constraints that cannot be applied to ManyToManyFields are properly managed. This may involve adjusting the model meta or providing clear migration paths for these constraints to be removed or redefined appropriately."
        }
    ]
}
2025-10-18 13:07:02.328 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 13:07:02.329 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 13:07:02.329 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:07:12.163 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3805, output_tokens=422, cost=0.050710
2025-10-18 13:07:12.171 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:07:16.138 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=776, output_tokens=82, cost=0.010220
2025-10-18 13:07:16.140 | DEBUG    | Extracted a valid json.
2025-10-18 13:07:16.140 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"Authors project_data_set ManyToManyField\")",
        "search_code(\"unique_together\")",
        "search_code_in_file(\"class Authors\", \"models.py\")",
        "search_code_in_file(\"class ProjectDataSet\", \"models.py\")",
        "search_code(\"Migration plan forwards backwards\")"
    ],
    "bug_locations": []
}
2025-10-18 13:07:16.276 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:07:16.277 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:07:32.583 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4837, output_tokens=651, cost=0.067900
2025-10-18 13:07:32.589 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:07:45.681 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5704, output_tokens=498, cost=0.071980
2025-10-18 13:07:45.688 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:07:52.176 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=852, output_tokens=200, cost=0.014520
2025-10-18 13:07:52.177 | DEBUG    | Extracted a valid json.
2025-10-18 13:07:52.178 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "migration files",
            "class": "",
            "method": "",
            "intended_behavior": "A carefully sequenced migration should first explicitly remove the `unique_together` constraint in a standalone migration step, ensuring the database schema is prepared for changes. Following this, a subsequent migration should change the field type. This ensures that each step is clearly defined and that Django's migration system can accurately track and apply these schema changes without encountering constraint-related errors."
        },
        {
            "file": "models.py",
            "class": "Authors",
            "method": "",
            "intended_behavior": "Before initiating migrations that would change field types or relationships significantly, ensuring that constraints like `unique_together` are reviewed and, if necessary, programmatically addressed (either through model Meta options or direct migration operations) to match the new model relationships and structures being implemented."
        }
    ]
}
2025-10-18 13:07:52.188 | DEBUG    | Bug location extracted successfully: [<file>django/forms/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Helper functions for creating Form classes from Django models
3 and database field objects.
4 """
5 from itertools import chain
6 
7 from django.core.exceptions import (
8     NON_FIELD_ERRORS,
9     FieldError,
10     ImproperlyConfigured,
11     ValidationError,
12 )
13 from django.forms.fields import ChoiceField, Field
14 from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass
15 from django.forms.formsets import BaseFormSet, formset_factory
16 from django.forms.utils import ErrorList
17 from django.forms.widgets import (
18     HiddenInput,
19     MultipleHiddenInput,
20     RadioSelect,
21     SelectMultiple,
22 )
23 from django.utils.text import capfirst, get_text_list
24 from django.utils.translation import gettext
25 from django.utils.translation import gettext_lazy as _
26 
27 __all__ = (
28     "ModelForm",
29     "BaseModelForm",
30     "model_to_dict",
31     "fields_for_model",
32     "ModelChoiceField",
33     "ModelMultipleChoiceField",
34     "ALL_FIELDS",
35     "BaseModelFormSet",
36     "modelformset_factory",
37     "BaseInlineFormSet",
38     "inlineformset_factory",
39     "modelform_factory",
40 )
41 
42 ALL_FIELDS = "__all__"
43 
44 
45 def construct_instance(form, instance, fields=None, exclude=None):
46     """
47     Construct and return a model instance from the bound ``form``'s
48     ``cleaned_data``, but do not save the returned instance to the database.
49     """
50     from django.db import models
51 
52     opts = instance._meta
53 
54     cleaned_data = form.cleaned_data
55     file_field_list = []
56     for f in opts.fields:
57         if (
58             not f.editable
59             or isinstance(f, models.AutoField)
60             or f.name not in cleaned_data
61         ):
62             continue
63         if fields is not None and f.name not in fields:
64             continue
65         if exclude and f.name in exclude:
66             continue
67         # Leave defaults for fields that aren't in POST data, except for
68         # checkbox inputs because they don't appear in POST data if not checked.
69         if (
70             f.has_default()
71             and form[f.name].field.widget.value_omitted_from_data(
72                 form.data, form.files, form.add_prefix(f.name)
73             )
74             and cleaned_data.get(f.name) in form[f.name].field.empty_values
75         ):
76             continue
77         # Defer saving file-type fields until after the other fields, so a
78         # callable upload_to can use the values from other fields.
79         if isinstance(f, models.FileField):
80             file_field_list.append(f)
81         else:
82             f.save_form_data(instance, cleaned_data[f.name])
83 
84     for f in file_field_list:
85         f.save_form_data(instance, cleaned_data[f.name])
86 
87     return instance
88 
89 
90 # ModelForms #################################################################
91 
92 
93 def model_to_dict(instance, fields=None, exclude=None):
94     """
95     Return a dict containing the data in ``instance`` suitable for passing as
96     a Form's ``initial`` keyword argument.
97 
98     ``fields`` is an optional list of field names. If provided, return only the
99     named.
100 
101     ``exclude`` is an optional list of field names. If provided, exclude the
102     named from the returned dict, even if they are listed in the ``fields``
103     argument.
104     """
105     opts = instance._meta
106     data = {}
107     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):
108         if not getattr(f, "editable", False):
109             continue
110         if fields is not None and f.name not in fields:
111             continue
112         if exclude and f.name in exclude:
113             continue
114         data[f.name] = f.value_from_object(instance)
115     return data
116 
117 
118 def apply_limit_choices_to_to_formfield(formfield):
119     """Apply limit_choices_to to the formfield's queryset if needed."""
120     from django.db.models import Exists, OuterRef, Q
121 
122     if hasattr(formfield, "queryset") and hasattr(formfield, "get_limit_choices_to"):
123         limit_choices_to = formfield.get_limit_choices_to()
124         if limit_choices_to:
125             complex_filter = limit_choices_to
126             if not isinstance(complex_filter, Q):
127                 complex_filter = Q(**limit_choices_to)
128             complex_filter &= Q(pk=OuterRef("pk"))
129             # Use Exists() to avoid potential duplicates.
130             formfield.queryset = formfield.queryset.filter(
131                 Exists(formfield.queryset.model._base_manager.filter(complex_filter)),
132             )
133 
134 
135 def fields_for_model(
136     model,
137     fields=None,
138     exclude=None,
139     widgets=None,
140     formfield_callback=None,
141     localized_fields=None,
142     labels=None,
143     help_texts=None,
144     error_messages=None,
145     field_classes=None,
146     *,
147     apply_limit_choices_to=True,
148 ):
149     """
150     Return a dictionary containing form fields for the given model.
151 
152     ``fields`` is an optional list of field names. If provided, return only the
153     named fields.
154 
155     ``exclude`` is an optional list of field names. If provided, exclude the
156     named fields from the returned fields, even if they are listed in the
157     ``fields`` argument.
158 
159     ``widgets`` is a dictionary of model field names mapped to a widget.
160 
161     ``formfield_callback`` is a callable that takes a model field and returns
162     a form field.
163 
164     ``localized_fields`` is a list of names of fields which should be localized.
165 
166     ``labels`` is a dictionary of model field names mapped to a label.
167 
168     ``help_texts`` is a dictionary of model field names mapped to a help text.
169 
170     ``error_messages`` is a dictionary of model field names mapped to a
171     dictionary of error messages.
172 
173     ``field_classes`` is a dictionary of model field names mapped to a form
174     field class.
175 
176     ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to
177     should be applied to a field's queryset.
178     """
179     field_dict = {}
180     ignored = []
181     opts = model._meta
182     # Avoid circular import
183     from django.db.models import Field as ModelField
184 
185     sortable_private_fields = [
186         f for f in opts.private_fields if isinstance(f, ModelField)
187     ]
188     for f in sorted(
189         chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)
190     ):
191         if not getattr(f, "editable", False):
192             if (
193                 fields is not None
194                 and f.name in fields
195                 and (exclude is None or f.name not in exclude)
196             ):
197                 raise FieldError(
198                     "'%s' cannot be specified for %s model form as it is a "
199                     "non-editable field" % (f.name, model.__name__)
200                 )
201             continue
202         if fields is not None and f.name not in fields:
203             continue
204         if exclude and f.name in exclude:
205             continue
206 
207         kwargs = {}
208         if widgets and f.name in widgets:
209             kwargs["widget"] = widgets[f.name]
210         if localized_fields == ALL_FIELDS or (
211             localized_fields and f.name in localized_fields
212         ):
213             kwargs["localize"] = True
214         if labels and f.name in labels:
215             kwargs["label"] = labels[f.name]
216         if help_texts and f.name in help_texts:
217             kwargs["help_text"] = help_texts[f.name]
218         if error_messages and f.name in error_messages:
219             kwargs["error_messages"] = error_messages[f.name]
220         if field_classes and f.name in field_classes:
221             kwargs["form_class"] = field_classes[f.name]
222 
223         if formfield_callback is None:
224             formfield = f.formfield(**kwargs)
225         elif not callable(formfield_callback):
226             raise TypeError("formfield_callback must be a function or callable")
227         else:
228             formfield = formfield_callback(f, **kwargs)
229 
230         if formfield:
231             if apply_limit_choices_to:
232                 apply_limit_choices_to_to_formfield(formfield)
233             field_dict[f.name] = formfield
234         else:
235             ignored.append(f.name)
236     if fields:
237         field_dict = {
238             f: field_dict.get(f)
239             for f in fields
240             if (not exclude or f not in exclude) and f not in ignored
241         }
242     return field_dict
243 
244 
245 class ModelFormOptions:
246     def __init__(self, options=None):
247         self.model = getattr(options, "model", None)
248         self.fields = getattr(options, "fields", None)
249         self.exclude = getattr(options, "exclude", None)
250         self.widgets = getattr(options, "widgets", None)
251         self.localized_fields = getattr(options, "localized_fields", None)
252         self.labels = getattr(options, "labels", None)
253         self.help_texts = getattr(options, "help_texts", None)
254         self.error_messages = getattr(options, "error_messages", None)
255         self.field_classes = getattr(options, "field_classes", None)
256 
257 
258 class ModelFormMetaclass(DeclarativeFieldsMetaclass):
259     def __new__(mcs, name, bases, attrs):
260         base_formfield_callback = None
261         for b in bases:
262             if hasattr(b, "Meta") and hasattr(b.Meta, "formfield_callback"):
263                 base_formfield_callback = b.Meta.formfield_callback
264                 break
265 
266         formfield_callback = attrs.pop("formfield_callback", base_formfield_callback)
267 
268         new_class = super().__new__(mcs, name, bases, attrs)
269 
270         if bases == (BaseModelForm,):
271             return new_class
272 
273         opts = new_class._meta = ModelFormOptions(getattr(new_class, "Meta", None))
274 
275         # We check if a string was passed to `fields` or `exclude`,
276         # which is likely to be a mistake where the user typed ('foo') instead
277         # of ('foo',)
278         for opt in ["fields", "exclude", "localized_fields"]:
279             value = getattr(opts, opt)
280             if isinstance(value, str) and value != ALL_FIELDS:
281                 msg = (
282                     "%(model)s.Meta.%(opt)s cannot be a string. "
283                     "Did you mean to type: ('%(value)s',)?"
284                     % {
285                         "model": new_class.__name__,
286                         "opt": opt,
287                         "value": value,
288                     }
289                 )
290                 raise TypeError(msg)
291 
292         if opts.model:
293             # If a model is defined, extract form fields from it.
294             if opts.fields is None and opts.exclude is None:
295                 raise ImproperlyConfigured(
296                     "Creating a ModelForm without either the 'fields' attribute "
297                     "or the 'exclude' attribute is prohibited; form %s "
298                     "needs updating." % name
299                 )
300 
301             if opts.fields == ALL_FIELDS:
302                 # Sentinel for fields_for_model to indicate "get the list of
303                 # fields from the model"
304                 opts.fields = None
305 
306             fields = fields_for_model(
307                 opts.model,
308                 opts.fields,
309                 opts.exclude,
310                 opts.widgets,
311                 formfield_callback,
312                 opts.localized_fields,
313                 opts.labels,
314                 opts.help_texts,
315                 opts.error_messages,
316                 opts.field_classes,
317                 # limit_choices_to will be applied during ModelForm.__init__().
318                 apply_limit_choices_to=False,
319             )
320 
321             # make sure opts.fields doesn't specify an invalid field
322             none_model_fields = {k for k, v in fields.items() if not v}
323             missing_fields = none_model_fields.difference(new_class.declared_fields)
324             if missing_fields:
325                 message = "Unknown field(s) (%s) specified for %s"
326                 message = message % (", ".join(missing_fields), opts.model.__name__)
327                 raise FieldError(message)
328             # Override default model fields with any custom declared ones
329             # (plus, include all the other declared fields).
330             fields.update(new_class.declared_fields)
331         else:
332             fields = new_class.declared_fields
333 
334         new_class.base_fields = fields
335 
336         return new_class
337 
338 
339 class BaseModelForm(BaseForm):
340     def __init__(
341         self,
342         data=None,
343         files=None,
344         auto_id="id_%s",
345         prefix=None,
346         initial=None,
347         error_class=ErrorList,
348         label_suffix=None,
349         empty_permitted=False,
350         instance=None,
351         use_required_attribute=None,
352         renderer=None,
353     ):
354         opts = self._meta
355         if opts.model is None:
356             raise ValueError("ModelForm has no model class specified.")
357         if instance is None:
358             # if we didn't get an instance, instantiate a new one
359             self.instance = opts.model()
360             object_data = {}
361         else:
362             self.instance = instance
363             object_data = model_to_dict(instance, opts.fields, opts.exclude)
364         # if initial was provided, it should override the values from instance
365         if initial is not None:
366             object_data.update(initial)
367         # self._validate_unique will be set to True by BaseModelForm.clean().
368         # It is False by default so overriding self.clean() and failing to call
369         # super will stop validate_unique from being called.
370         self._validate_unique = False
371         super().__init__(
372             data,
373             files,
374             auto_id,
375             prefix,
376             object_data,
377             error_class,
378             label_suffix,
379             empty_permitted,
380             use_required_attribute=use_required_attribute,
381             renderer=renderer,
382         )
383         for formfield in self.fields.values():
384             apply_limit_choices_to_to_formfield(formfield)
385 
386     def _get_validation_exclusions(self):
387         """
388         For backwards-compatibility, exclude several types of fields from model
389         validation. See tickets #12507, #12521, #12553.
390         """
391         exclude = set()
392         # Build up a list of fields that should be excluded from model field
393         # validation and unique checks.
394         for f in self.instance._meta.fields:
395             field = f.name
396             # Exclude fields that aren't on the form. The developer may be
397             # adding these values to the model after form validation.
398             if field not in self.fields:
399                 exclude.add(f.name)
400 
401             # Don't perform model validation on fields that were defined
402             # manually on the form and excluded via the ModelForm's Meta
403             # class. See #12901.
404             elif self._meta.fields and field not in self._meta.fields:
405                 exclude.add(f.name)
406             elif self._meta.exclude and field in self._meta.exclude:
407                 exclude.add(f.name)
408 
409             # Exclude fields that failed form validation. There's no need for
410             # the model fields to validate them as well.
411             elif field in self._errors:
412                 exclude.add(f.name)
413 
414             # Exclude empty fields that are not required by the form, if the
415             # underlying model field is required. This keeps the model field
416             # from raising a required error. Note: don't exclude the field from
417             # validation if the model field allows blanks. If it does, the blank
418             # value may be included in a unique check, so cannot be excluded
419             # from validation.
420             else:
421                 form_field = self.fields[field]
422                 field_value = self.cleaned_data.get(field)
423                 if (
424                     not f.blank
425                     and not form_field.required
426                     and field_value in form_field.empty_values
427                 ):
428                     exclude.add(f.name)
429         return exclude
430 
431     def clean(self):
432         self._validate_unique = True
433         return self.cleaned_data
434 
435     def _update_errors(self, errors):
436         # Override any validation error messages defined at the model level
437         # with those defined at the form level.
438         opts = self._meta
439 
440         # Allow the model generated by construct_instance() to raise
441         # ValidationError and have them handled in the same way as others.
442         if hasattr(errors, "error_dict"):
443             error_dict = errors.error_dict
444         else:
445             error_dict = {NON_FIELD_ERRORS: errors}
446 
447         for field, messages in error_dict.items():
448             if (
449                 field == NON_FIELD_ERRORS
450                 and opts.error_messages
451                 and NON_FIELD_ERRORS in opts.error_messages
452             ):
453                 error_messages = opts.error_messages[NON_FIELD_ERRORS]
454             elif field in self.fields:
455                 error_messages = self.fields[field].error_messages
456             else:
457                 continue
458 
459             for message in messages:
460                 if (
461                     isinstance(message, ValidationError)
462                     and message.code in error_messages
463                 ):
464                     message.message = error_messages[message.code]
465 
466         self.add_error(None, errors)
467 
468     def _post_clean(self):
469         opts = self._meta
470 
471         exclude = self._get_validation_exclusions()
472 
473         # Foreign Keys being used to represent inline relationships
474         # are excluded from basic field value validation. This is for two
475         # reasons: firstly, the value may not be supplied (#12507; the
476         # case of providing new values to the admin); secondly the
477         # object being referred to may not yet fully exist (#12749).
478         # However, these fields *must* be included in uniqueness checks,
479         # so this can't be part of _get_validation_exclusions().
480         for name, field in self.fields.items():
481             if isinstance(field, InlineForeignKeyField):
482                 exclude.add(name)
483 
484         try:
485             self.instance = construct_instance(
486                 self, self.instance, opts.fields, opts.exclude
487             )
488         except ValidationError as e:
489             self._update_errors(e)
490 
491         try:
492             self.instance.full_clean(exclude=exclude, validate_unique=False)
493         except ValidationError as e:
494             self._update_errors(e)
495 
496         # Validate uniqueness if needed.
497         if self._validate_unique:
498             self.validate_unique()
499 
500     def validate_unique(self):
501         """
502         Call the instance's validate_unique() method and update the form's
503         validation errors if any were raised.
504         """
505         exclude = self._get_validation_exclusions()
506         try:
507             self.instance.validate_unique(exclude=exclude)
508         except ValidationError as e:
509             self._update_errors(e)
510 
511     def _save_m2m(self):
512         """
513         Save the many-to-many fields and generic relations for this form.
514         """
515         cleaned_data = self.cleaned_data
516         exclude = self._meta.exclude
517         fields = self._meta.fields
518         opts = self.instance._meta
519         # Note that for historical reasons we want to include also
520         # private_fields here. (GenericRelation was previously a fake
521         # m2m field).
522         for f in chain(opts.many_to_many, opts.private_fields):
523             if not hasattr(f, "save_form_data"):
524                 continue
525             if fields and f.name not in fields:
526                 continue
527             if exclude and f.name in exclude:
528                 continue
529             if f.name in cleaned_data:
530                 f.save_form_data(self.instance, cleaned_data[f.name])
531 
532     def save(self, commit=True):
533         """
534         Save this form's self.instance object if commit=True. Otherwise, add
535         a save_m2m() method to the form which can be called after the instance
536         is saved manually at a later time. Return the model instance.
537         """
538         if self.errors:
539             raise ValueError(
540                 "The %s could not be %s because the data didn't validate."
541                 % (
542                     self.instance._meta.object_name,
543                     "created" if self.instance._state.adding else "changed",
544                 )
545             )
546         if commit:
547             # If committing, save the instance and the m2m data immediately.
548             self.instance.save()
549             self._save_m2m()
550         else:
551             # If not committing, add a method to the form to allow deferred
552             # saving of m2m data.
553             self.save_m2m = self._save_m2m
554         return self.instance
555 
556     save.alters_data = True
557 
558 
559 class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):
560     pass
561 
562 
563 def modelform_factory(
564     model,
565     form=ModelForm,
566     fields=None,
567     exclude=None,
568     formfield_callback=None,
569     widgets=None,
570     localized_fields=None,
571     labels=None,
572     help_texts=None,
573     error_messages=None,
574     field_classes=None,
575 ):
576     """
577     Return a ModelForm containing form fields for the given model. You can
578     optionally pass a `form` argument to use as a starting point for
579     constructing the ModelForm.
580 
581     ``fields`` is an optional list of field names. If provided, include only
582     the named fields in the returned fields. If omitted or '__all__', use all
583     fields.
584 
585     ``exclude`` is an optional list of field names. If provided, exclude the
586     named fields from the returned fields, even if they are listed in the
587     ``fields`` argument.
588 
589     ``widgets`` is a dictionary of model field names mapped to a widget.
590 
591     ``localized_fields`` is a list of names of fields which should be localized.
592 
593     ``formfield_callback`` is a callable that takes a model field and returns
594     a form field.
595 
596     ``labels`` is a dictionary of model field names mapped to a label.
597 
598     ``help_texts`` is a dictionary of model field names mapped to a help text.
599 
600     ``error_messages`` is a dictionary of model field names mapped to a
601     dictionary of error messages.
602 
603     ``field_classes`` is a dictionary of model field names mapped to a form
604     field class.
605     """
606     # Create the inner Meta class. FIXME: ideally, we should be able to
607     # construct a ModelForm without creating and passing in a temporary
608     # inner class.
609 
610     # Build up a list of attributes that the Meta object will have.
611     attrs = {"model": model}
612     if fields is not None:
613         attrs["fields"] = fields
614     if exclude is not None:
615         attrs["exclude"] = exclude
616     if widgets is not None:
617         attrs["widgets"] = widgets
618     if localized_fields is not None:
619         attrs["localized_fields"] = localized_fields
620     if labels is not None:
621         attrs["labels"] = labels
622     if help_texts is not None:
623         attrs["help_texts"] = help_texts
624     if error_messages is not None:
625         attrs["error_messages"] = error_messages
626     if field_classes is not None:
627         attrs["field_classes"] = field_classes
628 
629     # If parent form class already has an inner Meta, the Meta we're
630     # creating needs to inherit from the parent's inner meta.
631     bases = (form.Meta,) if hasattr(form, "Meta") else ()
632     Meta = type("Meta", bases, attrs)
633     if formfield_callback:
634         Meta.formfield_callback = staticmethod(formfield_callback)
635     # Give this new form class a reasonable name.
636     class_name = model.__name__ + "Form"
637 
638     # Class attributes for the new form class.
639     form_class_attrs = {"Meta": Meta, "formfield_callback": formfield_callback}
640 
641     if getattr(Meta, "fields", None) is None and getattr(Meta, "exclude", None) is None:
642         raise ImproperlyConfigured(
643             "Calling modelform_factory without defining 'fields' or "
644             "'exclude' explicitly is prohibited."
645         )
646 
647     # Instantiate type(form) in order to use the same metaclass as form.
648     return type(form)(class_name, (form,), form_class_attrs)
649 
650 
651 # ModelFormSets ##############################################################
652 
653 
654 class BaseModelFormSet(BaseFormSet):
655     """
656     A ``FormSet`` for editing a queryset and/or adding new objects to it.
657     """
658 
659     model = None
660 
661     # Set of fields that must be unique among forms of this set.
662     unique_fields = set()
663 
664     def __init__(
665         self,
666         data=None,
667         files=None,
668         auto_id="id_%s",
669         prefix=None,
670         queryset=None,
671         *,
672         initial=None,
673         **kwargs,
674     ):
675         self.queryset = queryset
676         self.initial_extra = initial
677         super().__init__(
678             **{
679                 "data": data,
680                 "files": files,
681                 "auto_id": auto_id,
682                 "prefix": prefix,
683                 **kwargs,
684             }
685         )
686 
687     def initial_form_count(self):
688         """Return the number of forms that are required in this FormSet."""
689         if not self.is_bound:
690             return len(self.get_queryset())
691         return super().initial_form_count()
692 
693     def _existing_object(self, pk):
694         if not hasattr(self, "_object_dict"):
695             self._object_dict = {o.pk: o for o in self.get_queryset()}
696         return self._object_dict.get(pk)
697 
698     def _get_to_python(self, field):
699         """
700         If the field is a related field, fetch the concrete field's (that
701         is, the ultimate pointed-to field's) to_python.
702         """
703         while field.remote_field is not None:
704             field = field.remote_field.get_related_field()
705         return field.to_python
706 
707     def _construct_form(self, i, **kwargs):
708         pk_required = i < self.initial_form_count()
709         if pk_required:
710             if self.is_bound:
711                 pk_key = "%s-%s" % (self.add_prefix(i), self.model._meta.pk.name)
712                 try:
713                     pk = self.data[pk_key]
714                 except KeyError:
715                     # The primary key is missing. The user may have tampered
716                     # with POST data.
717                     pass
718                 else:
719                     to_python = self._get_to_python(self.model._meta.pk)
720                     try:
721                         pk = to_python(pk)
722                     except ValidationError:
723                         # The primary key exists but is an invalid value. The
724                         # user may have tampered with POST data.
725                         pass
726                     else:
727                         kwargs["instance"] = self._existing_object(pk)
728             else:
729                 kwargs["instance"] = self.get_queryset()[i]
730         elif self.initial_extra:
731             # Set initial values for extra forms
732             try:
733                 kwargs["initial"] = self.initial_extra[i - self.initial_form_count()]
734             except IndexError:
735                 pass
736         form = super()._construct_form(i, **kwargs)
737         if pk_required:
738             form.fields[self.model._meta.pk.name].required = True
739         return form
740 
741     def get_queryset(self):
742         if not hasattr(self, "_queryset"):
743             if self.queryset is not None:
744                 qs = self.queryset
745             else:
746                 qs = self.model._default_manager.get_queryset()
747 
748             # If the queryset isn't already ordered we need to add an
749             # artificial ordering here to make sure that all formsets
750             # constructed from this queryset have the same form order.
751             if not qs.ordered:
752                 qs = qs.order_by(self.model._meta.pk.name)
753 
754             # Removed queryset limiting here. As per discussion re: #13023
755             # on django-dev, max_num should not prevent existing
756             # related objects/inlines from being displayed.
757             self._queryset = qs
758         return self._queryset
759 
760     def save_new(self, form, commit=True):
761         """Save and return a new model instance for the given form."""
762         return form.save(commit=commit)
763 
764     def save_existing(self, form, instance, commit=True):
765         """Save and return an existing model instance for the given form."""
766         return form.save(commit=commit)
767 
768     def delete_existing(self, obj, commit=True):
769         """Deletes an existing model instance."""
770         if commit:
771             obj.delete()
772 
773     def save(self, commit=True):
774         """
775         Save model instances for every form, adding and changing instances
776         as necessary, and return the list of instances.
777         """
778         if not commit:
779             self.saved_forms = []
780 
781             def save_m2m():
782                 for form in self.saved_forms:
783                     form.save_m2m()
784 
785             self.save_m2m = save_m2m
786         if self.edit_only:
787             return self.save_existing_objects(commit)
788         else:
789             return self.save_existing_objects(commit) + self.save_new_objects(commit)
790 
791     save.alters_data = True
792 
793     def clean(self):
794         self.validate_unique()
795 
796     def validate_unique(self):
797         # Collect unique_checks and date_checks to run from all the forms.
798         all_unique_checks = set()
799         all_date_checks = set()
800         forms_to_delete = self.deleted_forms
801         valid_forms = [
802             form
803             for form in self.forms
804             if form.is_valid() and form not in forms_to_delete
805         ]
806         for form in valid_forms:
807             exclude = form._get_validation_exclusions()
808             unique_checks, date_checks = form.instance._get_unique_checks(
809                 exclude=exclude,
810                 include_meta_constraints=True,
811             )
812             all_unique_checks.update(unique_checks)
813             all_date_checks.update(date_checks)
814 
815         errors = []
816         # Do each of the unique checks (unique and unique_together)
817         for uclass, unique_check in all_unique_checks:
818             seen_data = set()
819             for form in valid_forms:
820                 # Get the data for the set of fields that must be unique among
821                 # the forms.
822                 row_data = (
823                     field if field in self.unique_fields else form.cleaned_data[field]
824                     for field in unique_check
825                     if field in form.cleaned_data
826                 )
827                 # Reduce Model instances to their primary key values
828                 row_data = tuple(
829                     d._get_pk_val() if hasattr(d, "_get_pk_val")
830                     # Prevent "unhashable type: list" errors later on.
831                     else tuple(d) if isinstance(d, list) else d
832                     for d in row_data
833                 )
834                 if row_data and None not in row_data:
835                     # if we've already seen it then we have a uniqueness failure
836                     if row_data in seen_data:
837                         # poke error messages into the right places and mark
838                         # the form as invalid
839                         errors.append(self.get_unique_error_message(unique_check))
840                         form._errors[NON_FIELD_ERRORS] = self.error_class(
841                             [self.get_form_error()],
842                             renderer=self.renderer,
843                         )
844                         # Remove the data from the cleaned_data dict since it
845                         # was invalid.
846                         for field in unique_check:
847                             if field in form.cleaned_data:
848                                 del form.cleaned_data[field]
849                     # mark the data as seen
850                     seen_data.add(row_data)
851         # iterate over each of the date checks now
852         for date_check in all_date_checks:
853             seen_data = set()
854             uclass, lookup, field, unique_for = date_check
855             for form in valid_forms:
856                 # see if we have data for both fields
857                 if (
858                     form.cleaned_data
859                     and form.cleaned_data[field] is not None
860                     and form.cleaned_data[unique_for] is not None
861                 ):
862                     # if it's a date lookup we need to get the data for all the fields
863                     if lookup == "date":
864                         date = form.cleaned_data[unique_for]
865                         date_data = (date.year, date.month, date.day)
866                     # otherwise it's just the attribute on the date/datetime
867                     # object
868                     else:
869                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)
870                     data = (form.cleaned_data[field],) + date_data
871                     # if we've already seen it then we have a uniqueness failure
872                     if data in seen_data:
873                         # poke error messages into the right places and mark
874                         # the form as invalid
875                         errors.append(self.get_date_error_message(date_check))
876                         form._errors[NON_FIELD_ERRORS] = self.error_class(
877                             [self.get_form_error()],
878                             renderer=self.renderer,
879                         )
880                         # Remove the data from the cleaned_data dict since it
881                         # was invalid.
882                         del form.cleaned_data[field]
883                     # mark the data as seen
884                     seen_data.add(data)
885 
886         if errors:
887             raise ValidationError(errors)
888 
889     def get_unique_error_message(self, unique_check):
890         if len(unique_check) == 1:
891             return gettext("Please correct the duplicate data for %(field)s.") % {
892                 "field": unique_check[0],
893             }
894         else:
895             return gettext(
896                 "Please correct the duplicate data for %(field)s, which must be unique."
897             ) % {
898                 "field": get_text_list(unique_check, _("and")),
899             }
900 
901     def get_date_error_message(self, date_check):
902         return gettext(
903             "Please correct the duplicate data for %(field_name)s "
904             "which must be unique for the %(lookup)s in %(date_field)s."
905         ) % {
906             "field_name": date_check[2],
907             "date_field": date_check[3],
908             "lookup": str(date_check[1]),
909         }
910 
911     def get_form_error(self):
912         return gettext("Please correct the duplicate values below.")
913 
914     def save_existing_objects(self, commit=True):
915         self.changed_objects = []
916         self.deleted_objects = []
917         if not self.initial_forms:
918             return []
919 
920         saved_instances = []
921         forms_to_delete = self.deleted_forms
922         for form in self.initial_forms:
923             obj = form.instance
924             # If the pk is None, it means either:
925             # 1. The object is an unexpected empty model, created by invalid
926             #    POST data such as an object outside the formset's queryset.
927             # 2. The object was already deleted from the database.
928             if obj.pk is None:
929                 continue
930             if form in forms_to_delete:
931                 self.deleted_objects.append(obj)
932                 self.delete_existing(obj, commit=commit)
933             elif form.has_changed():
934                 self.changed_objects.append((obj, form.changed_data))
935                 saved_instances.append(self.save_existing(form, obj, commit=commit))
936                 if not commit:
937                     self.saved_forms.append(form)
938         return saved_instances
939 
940     def save_new_objects(self, commit=True):
941         self.new_objects = []
942         for form in self.extra_forms:
943             if not form.has_changed():
944                 continue
945             # If someone has marked an add form for deletion, don't save the
946             # object.
947             if self.can_delete and self._should_delete_form(form):
948                 continue
949             self.new_objects.append(self.save_new(form, commit=commit))
950             if not commit:
951                 self.saved_forms.append(form)
952         return self.new_objects
953 
954     def add_fields(self, form, index):
955         """Add a hidden field for the object's primary key."""
956         from django.db.models import AutoField, ForeignKey, OneToOneField
957 
958         self._pk_field = pk = self.model._meta.pk
959         # If a pk isn't editable, then it won't be on the form, so we need to
960         # add it here so we can tell which object is which when we get the
961         # data back. Generally, pk.editable should be false, but for some
962         # reason, auto_created pk fields and AutoField's editable attribute is
963         # True, so check for that as well.
964 
965         def pk_is_not_editable(pk):
966             return (
967                 (not pk.editable)
968                 or (pk.auto_created or isinstance(pk, AutoField))
969                 or (
970                     pk.remote_field
971                     and pk.remote_field.parent_link
972                     and pk_is_not_editable(pk.remote_field.model._meta.pk)
973                 )
974             )
975 
976         if pk_is_not_editable(pk) or pk.name not in form.fields:
977             if form.is_bound:
978                 # If we're adding the related instance, ignore its primary key
979                 # as it could be an auto-generated default which isn't actually
980                 # in the database.
981                 pk_value = None if form.instance._state.adding else form.instance.pk
982             else:
983                 try:
984                     if index is not None:
985                         pk_value = self.get_queryset()[index].pk
986                     else:
987                         pk_value = None
988                 except IndexError:
989                     pk_value = None
990             if isinstance(pk, (ForeignKey, OneToOneField)):
991                 qs = pk.remote_field.model._default_manager.get_queryset()
992             else:
993                 qs = self.model._default_manager.get_queryset()
994             qs = qs.using(form.instance._state.db)
995             if form._meta.widgets:
996                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)
997             else:
998                 widget = HiddenInput
999             form.fields[self._pk_field.name] = ModelChoiceField(
1000                 qs, initial=pk_value, required=False, widget=widget
1001             )
1002         super().add_fields(form, index)
1003 
1004 
1005 def modelformset_factory(
1006     model,
1007     form=ModelForm,
1008     formfield_callback=None,
1009     formset=BaseModelFormSet,
1010     extra=1,
1011     can_delete=False,
1012     can_order=False,
1013     max_num=None,
1014     fields=None,
1015     exclude=None,
1016     widgets=None,
1017     validate_max=False,
1018     localized_fields=None,
1019     labels=None,
1020     help_texts=None,
1021     error_messages=None,
1022     min_num=None,
1023     validate_min=False,
1024     field_classes=None,
1025     absolute_max=None,
1026     can_delete_extra=True,
1027     renderer=None,
1028     edit_only=False,
1029 ):
1030     """Return a FormSet class for the given Django model class."""
1031     meta = getattr(form, "Meta", None)
1032     if (
1033         getattr(meta, "fields", fields) is None
1034         and getattr(meta, "exclude", exclude) is None
1035     ):
1036         raise ImproperlyConfigured(
1037             "Calling modelformset_factory without defining 'fields' or "
1038             "'exclude' explicitly is prohibited."
1039         )
1040 
1041     form = modelform_factory(
1042         model,
1043         form=form,
1044         fields=fields,
1045         exclude=exclude,
1046         formfield_callback=formfield_callback,
1047         widgets=widgets,
1048         localized_fields=localized_fields,
1049         labels=labels,
1050         help_texts=help_texts,
1051         error_messages=error_messages,
1052         field_classes=field_classes,
1053     )
1054     FormSet = formset_factory(
1055         form,
1056         formset,
1057         extra=extra,
1058         min_num=min_num,
1059         max_num=max_num,
1060         can_order=can_order,
1061         can_delete=can_delete,
1062         validate_min=validate_min,
1063         validate_max=validate_max,
1064         absolute_max=absolute_max,
1065         can_delete_extra=can_delete_extra,
1066         renderer=renderer,
1067     )
1068     FormSet.model = model
1069     FormSet.edit_only = edit_only
1070     return FormSet
1071 
1072 
1073 # InlineFormSets #############################################################
1074 
1075 
1076 class BaseInlineFormSet(BaseModelFormSet):
1077     """A formset for child objects related to a parent."""
1078 
1079     def __init__(
1080         self,
1081         data=None,
1082         files=None,
1083         instance=None,
1084         save_as_new=False,
1085         prefix=None,
1086         queryset=None,
1087         **kwargs,
1088     ):
1089         if instance is None:
1090             self.instance = self.fk.remote_field.model()
1091         else:
1092             self.instance = instance
1093         self.save_as_new = save_as_new
1094         if queryset is None:
1095             queryset = self.model._default_manager
1096         if self.instance.pk is not None:
1097             qs = queryset.filter(**{self.fk.name: self.instance})
1098         else:
1099             qs = queryset.none()
1100         self.unique_fields = {self.fk.name}
1101         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)
1102 
1103         # Add the generated field to form._meta.fields if it's defined to make
1104         # sure validation isn't skipped on that field.
1105         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:
1106             if isinstance(self.form._meta.fields, tuple):
1107                 self.form._meta.fields = list(self.form._meta.fields)
1108             self.form._meta.fields.append(self.fk.name)
1109 
1110     def initial_form_count(self):
1111         if self.save_as_new:
1112             return 0
1113         return super().initial_form_count()
1114 
1115     def _construct_form(self, i, **kwargs):
1116         form = super()._construct_form(i, **kwargs)
1117         if self.save_as_new:
1118             mutable = getattr(form.data, "_mutable", None)
1119             # Allow modifying an immutable QueryDict.
1120             if mutable is not None:
1121                 form.data._mutable = True
1122             # Remove the primary key from the form's data, we are only
1123             # creating new instances
1124             form.data[form.add_prefix(self._pk_field.name)] = None
1125             # Remove the foreign key from the form's data
1126             form.data[form.add_prefix(self.fk.name)] = None
1127             if mutable is not None:
1128                 form.data._mutable = mutable
1129 
1130         # Set the fk value here so that the form can do its validation.
1131         fk_value = self.instance.pk
1132         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1133             fk_value = getattr(self.instance, self.fk.remote_field.field_name)
1134             fk_value = getattr(fk_value, "pk", fk_value)
1135         setattr(form.instance, self.fk.get_attname(), fk_value)
1136         return form
1137 
1138     @classmethod
1139     def get_default_prefix(cls):
1140         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace("+", "")
1141 
1142     def save_new(self, form, commit=True):
1143         # Ensure the latest copy of the related instance is present on each
1144         # form (it may have been saved after the formset was originally
1145         # instantiated).
1146         setattr(form.instance, self.fk.name, self.instance)
1147         return super().save_new(form, commit=commit)
1148 
1149     def add_fields(self, form, index):
1150         super().add_fields(form, index)
1151         if self._pk_field == self.fk:
1152             name = self._pk_field.name
1153             kwargs = {"pk_field": True}
1154         else:
1155             # The foreign key field might not be on the form, so we poke at the
1156             # Model field to get the label, since we need that for error messages.
1157             name = self.fk.name
1158             kwargs = {
1159                 "label": getattr(
1160                     form.fields.get(name), "label", capfirst(self.fk.verbose_name)
1161                 )
1162             }
1163 
1164         # The InlineForeignKeyField assumes that the foreign key relation is
1165         # based on the parent model's pk. If this isn't the case, set to_field
1166         # to correctly resolve the initial form value.
1167         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1168             kwargs["to_field"] = self.fk.remote_field.field_name
1169 
1170         # If we're adding a new object, ignore a parent's auto-generated key
1171         # as it will be regenerated on the save request.
1172         if self.instance._state.adding:
1173             if kwargs.get("to_field") is not None:
1174                 to_field = self.instance._meta.get_field(kwargs["to_field"])
1175             else:
1176                 to_field = self.instance._meta.pk
1177             if to_field.has_default():
1178                 setattr(self.instance, to_field.attname, None)
1179 
1180         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)
1181 
1182     def get_unique_error_message(self, unique_check):
1183         unique_check = [field for field in unique_check if field != self.fk.name]
1184         return super().get_unique_error_message(unique_check)
1185 
1186 
1187 def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):
1188     """
1189     Find and return the ForeignKey from model to parent if there is one
1190     (return None if can_fail is True and no such field exists). If fk_name is
1191     provided, assume it is the name of the ForeignKey field. Unless can_fail is
1192     True, raise an exception if there isn't a ForeignKey from model to
1193     parent_model.
1194     """
1195     # avoid circular import
1196     from django.db.models import ForeignKey
1197 
1198     opts = model._meta
1199     if fk_name:
1200         fks_to_parent = [f for f in opts.fields if f.name == fk_name]
1201         if len(fks_to_parent) == 1:
1202             fk = fks_to_parent[0]
1203             parent_list = parent_model._meta.get_parent_list()
1204             if (
1205                 not isinstance(fk, ForeignKey)
1206                 or (
1207                     # ForeignKey to proxy models.
1208                     fk.remote_field.model._meta.proxy
1209                     and fk.remote_field.model._meta.proxy_for_model not in parent_list
1210                 )
1211                 or (
1212                     # ForeignKey to concrete models.
1213                     not fk.remote_field.model._meta.proxy
1214                     and fk.remote_field.model != parent_model
1215                     and fk.remote_field.model not in parent_list
1216                 )
1217             ):
1218                 raise ValueError(
1219                     "fk_name '%s' is not a ForeignKey to '%s'."
1220                     % (fk_name, parent_model._meta.label)
1221                 )
1222         elif not fks_to_parent:
1223             raise ValueError(
1224                 "'%s' has no field named '%s'." % (model._meta.label, fk_name)
1225             )
1226     else:
1227         # Try to discover what the ForeignKey from model to parent_model is
1228         parent_list = parent_model._meta.get_parent_list()
1229         fks_to_parent = [
1230             f
1231             for f in opts.fields
1232             if isinstance(f, ForeignKey)
1233             and (
1234                 f.remote_field.model == parent_model
1235                 or f.remote_field.model in parent_list
1236                 or (
1237                     f.remote_field.model._meta.proxy
1238                     and f.remote_field.model._meta.proxy_for_model in parent_list
1239                 )
1240             )
1241         ]
1242         if len(fks_to_parent) == 1:
1243             fk = fks_to_parent[0]
1244         elif not fks_to_parent:
1245             if can_fail:
1246                 return
1247             raise ValueError(
1248                 "'%s' has no ForeignKey to '%s'."
1249                 % (
1250                     model._meta.label,
1251                     parent_model._meta.label,
1252                 )
1253             )
1254         else:
1255             raise ValueError(
1256                 "'%s' has more than one ForeignKey to '%s'. You must specify "
1257                 "a 'fk_name' attribute."
1258                 % (
1259                     model._meta.label,
1260                     parent_model._meta.label,
1261                 )
1262             )
1263     return fk
1264 
1265 
1266 def inlineformset_factory(
1267     parent_model,
1268     model,
1269     form=ModelForm,
1270     formset=BaseInlineFormSet,
1271     fk_name=None,
1272     fields=None,
1273     exclude=None,
1274     extra=3,
1275     can_order=False,
1276     can_delete=True,
1277     max_num=None,
1278     formfield_callback=None,
1279     widgets=None,
1280     validate_max=False,
1281     localized_fields=None,
1282     labels=None,
1283     help_texts=None,
1284     error_messages=None,
1285     min_num=None,
1286     validate_min=False,
1287     field_classes=None,
1288     absolute_max=None,
1289     can_delete_extra=True,
1290     renderer=None,
1291     edit_only=False,
1292 ):
1293     """
1294     Return an ``InlineFormSet`` for the given kwargs.
1295 
1296     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``
1297     to ``parent_model``.
1298     """
1299     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
1300     # enforce a max_num=1 when the foreign key to the parent model is unique.
1301     if fk.unique:
1302         max_num = 1
1303     kwargs = {
1304         "form": form,
1305         "formfield_callback": formfield_callback,
1306         "formset": formset,
1307         "extra": extra,
1308         "can_delete": can_delete,
1309         "can_order": can_order,
1310         "fields": fields,
1311         "exclude": exclude,
1312         "min_num": min_num,
1313         "max_num": max_num,
1314         "widgets": widgets,
1315         "validate_min": validate_min,
1316         "validate_max": validate_max,
1317         "localized_fields": localized_fields,
1318         "labels": labels,
1319         "help_texts": help_texts,
1320         "error_messages": error_messages,
1321         "field_classes": field_classes,
1322         "absolute_max": absolute_max,
1323         "can_delete_extra": can_delete_extra,
1324         "renderer": renderer,
1325         "edit_only": edit_only,
1326     }
1327     FormSet = modelformset_factory(model, **kwargs)
1328     FormSet.fk = fk
1329     return FormSet
1330 
1331 
1332 # Fields #####################################################################
1333 
1334 
1335 class InlineForeignKeyField(Field):
1336     """
1337     A basic integer field that deals with validating the given value to a
1338     given parent instance in an inline.
1339     """
1340 
1341     widget = HiddenInput
1342     default_error_messages = {
1343         "invalid_choice": _("The inline value did not match the parent instance."),
1344     }
1345 
1346     def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):
1347         self.parent_instance = parent_instance
1348         self.pk_field = pk_field
1349         self.to_field = to_field
1350         if self.parent_instance is not None:
1351             if self.to_field:
1352                 kwargs["initial"] = getattr(self.parent_instance, self.to_field)
1353             else:
1354                 kwargs["initial"] = self.parent_instance.pk
1355         kwargs["required"] = False
1356         super().__init__(*args, **kwargs)
1357 
1358     def clean(self, value):
1359         if value in self.empty_values:
1360             if self.pk_field:
1361                 return None
1362             # if there is no value act as we did before.
1363             return self.parent_instance
1364         # ensure the we compare the values as equal types.
1365         if self.to_field:
1366             orig = getattr(self.parent_instance, self.to_field)
1367         else:
1368             orig = self.parent_instance.pk
1369         if str(value) != str(orig):
1370             raise ValidationError(
1371                 self.error_messages["invalid_choice"], code="invalid_choice"
1372             )
1373         return self.parent_instance
1374 
1375     def has_changed(self, initial, data):
1376         return False
1377 
1378 
1379 class ModelChoiceIteratorValue:
1380     def __init__(self, value, instance):
1381         self.value = value
1382         self.instance = instance
1383 
1384     def __str__(self):
1385         return str(self.value)
1386 
1387     def __hash__(self):
1388         return hash(self.value)
1389 
1390     def __eq__(self, other):
1391         if isinstance(other, ModelChoiceIteratorValue):
1392             other = other.value
1393         return self.value == other
1394 
1395 
1396 class ModelChoiceIterator:
1397     def __init__(self, field):
1398         self.field = field
1399         self.queryset = field.queryset
1400 
1401     def __iter__(self):
1402         if self.field.empty_label is not None:
1403             yield ("", self.field.empty_label)
1404         queryset = self.queryset
1405         # Can't use iterator() when queryset uses prefetch_related()
1406         if not queryset._prefetch_related_lookups:
1407             queryset = queryset.iterator()
1408         for obj in queryset:
1409             yield self.choice(obj)
1410 
1411     def __len__(self):
1412         # count() adds a query but uses less memory since the QuerySet results
1413         # won't be cached. In most cases, the choices will only be iterated on,
1414         # and __len__() won't be called.
1415         return self.queryset.count() + (1 if self.field.empty_label is not None else 0)
1416 
1417     def __bool__(self):
1418         return self.field.empty_label is not None or self.queryset.exists()
1419 
1420     def choice(self, obj):
1421         return (
1422             ModelChoiceIteratorValue(self.field.prepare_value(obj), obj),
1423             self.field.label_from_instance(obj),
1424         )
1425 
1426 
1427 class ModelChoiceField(ChoiceField):
1428     """A ChoiceField whose choices are a model QuerySet."""
1429 
1430     # This class is a subclass of ChoiceField for purity, but it doesn't
1431     # actually use any of ChoiceField's implementation.
1432     default_error_messages = {
1433         "invalid_choice": _(
1434             "Select a valid choice. That choice is not one of the available choices."
1435         ),
1436     }
1437     iterator = ModelChoiceIterator
1438 
1439     def __init__(
1440         self,
1441         queryset,
1442         *,
1443         empty_label="---------",
1444         required=True,
1445         widget=None,
1446         label=None,
1447         initial=None,
1448         help_text="",
1449         to_field_name=None,
1450         limit_choices_to=None,
1451         blank=False,
1452         **kwargs,
1453     ):
1454         # Call Field instead of ChoiceField __init__() because we don't need
1455         # ChoiceField.__init__().
1456         Field.__init__(
1457             self,
1458             required=required,
1459             widget=widget,
1460             label=label,
1461             initial=initial,
1462             help_text=help_text,
1463             **kwargs,
1464         )
1465         if (required and initial is not None) or (
1466             isinstance(self.widget, RadioSelect) and not blank
1467         ):
1468             self.empty_label = None
1469         else:
1470             self.empty_label = empty_label
1471         self.queryset = queryset
1472         self.limit_choices_to = limit_choices_to  # limit the queryset later.
1473         self.to_field_name = to_field_name
1474 
1475     def get_limit_choices_to(self):
1476         """
1477         Return ``limit_choices_to`` for this form field.
1478 
1479         If it is a callable, invoke it and return the result.
1480         """
1481         if callable(self.limit_choices_to):
1482             return self.limit_choices_to()
1483         return self.limit_choices_to
1484 
1485     def __deepcopy__(self, memo):
1486         result = super(ChoiceField, self).__deepcopy__(memo)
1487         # Need to force a new ModelChoiceIterator to be created, bug #11183
1488         if self.queryset is not None:
1489             result.queryset = self.queryset.all()
1490         return result
1491 
1492     def _get_queryset(self):
1493         return self._queryset
1494 
1495     def _set_queryset(self, queryset):
1496         self._queryset = None if queryset is None else queryset.all()
1497         self.widget.choices = self.choices
1498 
1499     queryset = property(_get_queryset, _set_queryset)
1500 
1501     # this method will be used to create object labels by the QuerySetIterator.
1502     # Override it to customize the label.
1503     def label_from_instance(self, obj):
1504         """
1505         Convert objects into strings and generate the labels for the choices
1506         presented by this object. Subclasses can override this method to
1507         customize the display of the choices.
1508         """
1509         return str(obj)
1510 
1511     def _get_choices(self):
1512         # If self._choices is set, then somebody must have manually set
1513         # the property self.choices. In this case, just return self._choices.
1514         if hasattr(self, "_choices"):
1515             return self._choices
1516 
1517         # Otherwise, execute the QuerySet in self.queryset to determine the
1518         # choices dynamically. Return a fresh ModelChoiceIterator that has not been
1519         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*
1520         # time _get_choices() is called (and, thus, each time self.choices is
1521         # accessed) so that we can ensure the QuerySet has not been consumed. This
1522         # construct might look complicated but it allows for lazy evaluation of
1523         # the queryset.
1524         return self.iterator(self)
1525 
1526     choices = property(_get_choices, ChoiceField._set_choices)
1527 
1528     def prepare_value(self, value):
1529         if hasattr(value, "_meta"):
1530             if self.to_field_name:
1531                 return value.serializable_value(self.to_field_name)
1532             else:
1533                 return value.pk
1534         return super().prepare_value(value)
1535 
1536     def to_python(self, value):
1537         if value in self.empty_values:
1538             return None
1539         try:
1540             key = self.to_field_name or "pk"
1541             if isinstance(value, self.queryset.model):
1542                 value = getattr(value, key)
1543             value = self.queryset.get(**{key: value})
1544         except (ValueError, TypeError, self.queryset.model.DoesNotExist):
1545             raise ValidationError(
1546                 self.error_messages["invalid_choice"],
1547                 code="invalid_choice",
1548                 params={"value": value},
1549             )
1550         return value
1551 
1552     def validate(self, value):
1553         return Field.validate(self, value)
1554 
1555     def has_changed(self, initial, data):
1556         if self.disabled:
1557             return False
1558         initial_value = initial if initial is not None else ""
1559         data_value = data if data is not None else ""
1560         return str(self.prepare_value(initial_value)) != str(data_value)
1561 
1562 
1563 class ModelMultipleChoiceField(ModelChoiceField):
1564     """A MultipleChoiceField whose choices are a model QuerySet."""
1565 
1566     widget = SelectMultiple
1567     hidden_widget = MultipleHiddenInput
1568     default_error_messages = {
1569         "invalid_list": _("Enter a list of values."),
1570         "invalid_choice": _(
1571             "Select a valid choice. %(value)s is not one of the available choices."
1572         ),
1573         "invalid_pk_value": _("%(pk)s is not a valid value."),
1574     }
1575 
1576     def __init__(self, queryset, **kwargs):
1577         super().__init__(queryset, empty_label=None, **kwargs)
1578 
1579     def to_python(self, value):
1580         if not value:
1581             return []
1582         return list(self._check_values(value))
1583 
1584     def clean(self, value):
1585         value = self.prepare_value(value)
1586         if self.required and not value:
1587             raise ValidationError(self.error_messages["required"], code="required")
1588         elif not self.required and not value:
1589             return self.queryset.none()
1590         if not isinstance(value, (list, tuple)):
1591             raise ValidationError(
1592                 self.error_messages["invalid_list"],
1593                 code="invalid_list",
1594             )
1595         qs = self._check_values(value)
1596         # Since this overrides the inherited ModelChoiceField.clean
1597         # we run custom validators here
1598         self.run_validators(value)
1599         return qs
1600 
1601     def _check_values(self, value):
1602         """
1603         Given a list of possible PK values, return a QuerySet of the
1604         corresponding objects. Raise a ValidationError if a given value is
1605         invalid (not a valid PK, not in the queryset, etc.)
1606         """
1607         key = self.to_field_name or "pk"
1608         # deduplicate given values to avoid creating many querysets or
1609         # requiring the database backend deduplicate efficiently.
1610         try:
1611             value = frozenset(value)
1612         except TypeError:
1613             # list of lists isn't hashable, for example
1614             raise ValidationError(
1615                 self.error_messages["invalid_list"],
1616                 code="invalid_list",
1617             )
1618         for pk in value:
1619             try:
1620                 self.queryset.filter(**{key: pk})
1621             except (ValueError, TypeError):
1622                 raise ValidationError(
1623                     self.error_messages["invalid_pk_value"],
1624                     code="invalid_pk_value",
1625                     params={"pk": pk},
1626                 )
1627         qs = self.queryset.filter(**{"%s__in" % key: value})
1628         pks = {str(getattr(o, key)) for o in qs}
1629         for val in value:
1630             if str(val) not in pks:
1631                 raise ValidationError(
1632                     self.error_messages["invalid_choice"],
1633                     code="invalid_choice",
1634                     params={"value": val},
1635                 )
1636         return qs
1637 
1638     def prepare_value(self, value):
1639         if (
1640             hasattr(value, "__iter__")
1641             and not isinstance(value, str)
1642             and not hasattr(value, "_meta")
1643         ):
1644             prepare_value = super().prepare_value
1645             return [prepare_value(v) for v in value]
1646         return super().prepare_value(value)
1647 
1648     def has_changed(self, initial, data):
1649         if self.disabled:
1650             return False
1651         if initial is None:
1652             initial = []
1653         if data is None:
1654             data = []
1655         if len(initial) != len(data):
1656             return True
1657         initial_set = {str(value) for value in self.prepare_value(initial)}
1658         data_set = {str(value) for value in data}
1659         return data_set != initial_set
1660 
1661 
1662 def modelform_defines_fields(form_class):
1663     return hasattr(form_class, "_meta") and (
1664         form_class._meta.fields is not None or form_class._meta.exclude is not None
1665     )

</code><intended_behavior>Before initiating migrations that would change field types or relationships significantly, ensuring that constraints like `unique_together` are reviewed and, if necessary, programmatically addressed (either through model Meta options or direct migration operations) to match the new model relationships and structures being implemented.</intended_behavior>]
2025-10-18 13:07:52.189 | INFO     | Search completed. Bug locations: [<file>django/forms/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Helper functions for creating Form classes from Django models
3 and database field objects.
4 """
5 from itertools import chain
6 
7 from django.core.exceptions import (
8     NON_FIELD_ERRORS,
9     FieldError,
10     ImproperlyConfigured,
11     ValidationError,
12 )
13 from django.forms.fields import ChoiceField, Field
14 from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass
15 from django.forms.formsets import BaseFormSet, formset_factory
16 from django.forms.utils import ErrorList
17 from django.forms.widgets import (
18     HiddenInput,
19     MultipleHiddenInput,
20     RadioSelect,
21     SelectMultiple,
22 )
23 from django.utils.text import capfirst, get_text_list
24 from django.utils.translation import gettext
25 from django.utils.translation import gettext_lazy as _
26 
27 __all__ = (
28     "ModelForm",
29     "BaseModelForm",
30     "model_to_dict",
31     "fields_for_model",
32     "ModelChoiceField",
33     "ModelMultipleChoiceField",
34     "ALL_FIELDS",
35     "BaseModelFormSet",
36     "modelformset_factory",
37     "BaseInlineFormSet",
38     "inlineformset_factory",
39     "modelform_factory",
40 )
41 
42 ALL_FIELDS = "__all__"
43 
44 
45 def construct_instance(form, instance, fields=None, exclude=None):
46     """
47     Construct and return a model instance from the bound ``form``'s
48     ``cleaned_data``, but do not save the returned instance to the database.
49     """
50     from django.db import models
51 
52     opts = instance._meta
53 
54     cleaned_data = form.cleaned_data
55     file_field_list = []
56     for f in opts.fields:
57         if (
58             not f.editable
59             or isinstance(f, models.AutoField)
60             or f.name not in cleaned_data
61         ):
62             continue
63         if fields is not None and f.name not in fields:
64             continue
65         if exclude and f.name in exclude:
66             continue
67         # Leave defaults for fields that aren't in POST data, except for
68         # checkbox inputs because they don't appear in POST data if not checked.
69         if (
70             f.has_default()
71             and form[f.name].field.widget.value_omitted_from_data(
72                 form.data, form.files, form.add_prefix(f.name)
73             )
74             and cleaned_data.get(f.name) in form[f.name].field.empty_values
75         ):
76             continue
77         # Defer saving file-type fields until after the other fields, so a
78         # callable upload_to can use the values from other fields.
79         if isinstance(f, models.FileField):
80             file_field_list.append(f)
81         else:
82             f.save_form_data(instance, cleaned_data[f.name])
83 
84     for f in file_field_list:
85         f.save_form_data(instance, cleaned_data[f.name])
86 
87     return instance
88 
89 
90 # ModelForms #################################################################
91 
92 
93 def model_to_dict(instance, fields=None, exclude=None):
94     """
95     Return a dict containing the data in ``instance`` suitable for passing as
96     a Form's ``initial`` keyword argument.
97 
98     ``fields`` is an optional list of field names. If provided, return only the
99     named.
100 
101     ``exclude`` is an optional list of field names. If provided, exclude the
102     named from the returned dict, even if they are listed in the ``fields``
103     argument.
104     """
105     opts = instance._meta
106     data = {}
107     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):
108         if not getattr(f, "editable", False):
109             continue
110         if fields is not None and f.name not in fields:
111             continue
112         if exclude and f.name in exclude:
113             continue
114         data[f.name] = f.value_from_object(instance)
115     return data
116 
117 
118 def apply_limit_choices_to_to_formfield(formfield):
119     """Apply limit_choices_to to the formfield's queryset if needed."""
120     from django.db.models import Exists, OuterRef, Q
121 
122     if hasattr(formfield, "queryset") and hasattr(formfield, "get_limit_choices_to"):
123         limit_choices_to = formfield.get_limit_choices_to()
124         if limit_choices_to:
125             complex_filter = limit_choices_to
126             if not isinstance(complex_filter, Q):
127                 complex_filter = Q(**limit_choices_to)
128             complex_filter &= Q(pk=OuterRef("pk"))
129             # Use Exists() to avoid potential duplicates.
130             formfield.queryset = formfield.queryset.filter(
131                 Exists(formfield.queryset.model._base_manager.filter(complex_filter)),
132             )
133 
134 
135 def fields_for_model(
136     model,
137     fields=None,
138     exclude=None,
139     widgets=None,
140     formfield_callback=None,
141     localized_fields=None,
142     labels=None,
143     help_texts=None,
144     error_messages=None,
145     field_classes=None,
146     *,
147     apply_limit_choices_to=True,
148 ):
149     """
150     Return a dictionary containing form fields for the given model.
151 
152     ``fields`` is an optional list of field names. If provided, return only the
153     named fields.
154 
155     ``exclude`` is an optional list of field names. If provided, exclude the
156     named fields from the returned fields, even if they are listed in the
157     ``fields`` argument.
158 
159     ``widgets`` is a dictionary of model field names mapped to a widget.
160 
161     ``formfield_callback`` is a callable that takes a model field and returns
162     a form field.
163 
164     ``localized_fields`` is a list of names of fields which should be localized.
165 
166     ``labels`` is a dictionary of model field names mapped to a label.
167 
168     ``help_texts`` is a dictionary of model field names mapped to a help text.
169 
170     ``error_messages`` is a dictionary of model field names mapped to a
171     dictionary of error messages.
172 
173     ``field_classes`` is a dictionary of model field names mapped to a form
174     field class.
175 
176     ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to
177     should be applied to a field's queryset.
178     """
179     field_dict = {}
180     ignored = []
181     opts = model._meta
182     # Avoid circular import
183     from django.db.models import Field as ModelField
184 
185     sortable_private_fields = [
186         f for f in opts.private_fields if isinstance(f, ModelField)
187     ]
188     for f in sorted(
189         chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)
190     ):
191         if not getattr(f, "editable", False):
192             if (
193                 fields is not None
194                 and f.name in fields
195                 and (exclude is None or f.name not in exclude)
196             ):
197                 raise FieldError(
198                     "'%s' cannot be specified for %s model form as it is a "
199                     "non-editable field" % (f.name, model.__name__)
200                 )
201             continue
202         if fields is not None and f.name not in fields:
203             continue
204         if exclude and f.name in exclude:
205             continue
206 
207         kwargs = {}
208         if widgets and f.name in widgets:
209             kwargs["widget"] = widgets[f.name]
210         if localized_fields == ALL_FIELDS or (
211             localized_fields and f.name in localized_fields
212         ):
213             kwargs["localize"] = True
214         if labels and f.name in labels:
215             kwargs["label"] = labels[f.name]
216         if help_texts and f.name in help_texts:
217             kwargs["help_text"] = help_texts[f.name]
218         if error_messages and f.name in error_messages:
219             kwargs["error_messages"] = error_messages[f.name]
220         if field_classes and f.name in field_classes:
221             kwargs["form_class"] = field_classes[f.name]
222 
223         if formfield_callback is None:
224             formfield = f.formfield(**kwargs)
225         elif not callable(formfield_callback):
226             raise TypeError("formfield_callback must be a function or callable")
227         else:
228             formfield = formfield_callback(f, **kwargs)
229 
230         if formfield:
231             if apply_limit_choices_to:
232                 apply_limit_choices_to_to_formfield(formfield)
233             field_dict[f.name] = formfield
234         else:
235             ignored.append(f.name)
236     if fields:
237         field_dict = {
238             f: field_dict.get(f)
239             for f in fields
240             if (not exclude or f not in exclude) and f not in ignored
241         }
242     return field_dict
243 
244 
245 class ModelFormOptions:
246     def __init__(self, options=None):
247         self.model = getattr(options, "model", None)
248         self.fields = getattr(options, "fields", None)
249         self.exclude = getattr(options, "exclude", None)
250         self.widgets = getattr(options, "widgets", None)
251         self.localized_fields = getattr(options, "localized_fields", None)
252         self.labels = getattr(options, "labels", None)
253         self.help_texts = getattr(options, "help_texts", None)
254         self.error_messages = getattr(options, "error_messages", None)
255         self.field_classes = getattr(options, "field_classes", None)
256 
257 
258 class ModelFormMetaclass(DeclarativeFieldsMetaclass):
259     def __new__(mcs, name, bases, attrs):
260         base_formfield_callback = None
261         for b in bases:
262             if hasattr(b, "Meta") and hasattr(b.Meta, "formfield_callback"):
263                 base_formfield_callback = b.Meta.formfield_callback
264                 break
265 
266         formfield_callback = attrs.pop("formfield_callback", base_formfield_callback)
267 
268         new_class = super().__new__(mcs, name, bases, attrs)
269 
270         if bases == (BaseModelForm,):
271             return new_class
272 
273         opts = new_class._meta = ModelFormOptions(getattr(new_class, "Meta", None))
274 
275         # We check if a string was passed to `fields` or `exclude`,
276         # which is likely to be a mistake where the user typed ('foo') instead
277         # of ('foo',)
278         for opt in ["fields", "exclude", "localized_fields"]:
279             value = getattr(opts, opt)
280             if isinstance(value, str) and value != ALL_FIELDS:
281                 msg = (
282                     "%(model)s.Meta.%(opt)s cannot be a string. "
283                     "Did you mean to type: ('%(value)s',)?"
284                     % {
285                         "model": new_class.__name__,
286                         "opt": opt,
287                         "value": value,
288                     }
289                 )
290                 raise TypeError(msg)
291 
292         if opts.model:
293             # If a model is defined, extract form fields from it.
294             if opts.fields is None and opts.exclude is None:
295                 raise ImproperlyConfigured(
296                     "Creating a ModelForm without either the 'fields' attribute "
297                     "or the 'exclude' attribute is prohibited; form %s "
298                     "needs updating." % name
299                 )
300 
301             if opts.fields == ALL_FIELDS:
302                 # Sentinel for fields_for_model to indicate "get the list of
303                 # fields from the model"
304                 opts.fields = None
305 
306             fields = fields_for_model(
307                 opts.model,
308                 opts.fields,
309                 opts.exclude,
310                 opts.widgets,
311                 formfield_callback,
312                 opts.localized_fields,
313                 opts.labels,
314                 opts.help_texts,
315                 opts.error_messages,
316                 opts.field_classes,
317                 # limit_choices_to will be applied during ModelForm.__init__().
318                 apply_limit_choices_to=False,
319             )
320 
321             # make sure opts.fields doesn't specify an invalid field
322             none_model_fields = {k for k, v in fields.items() if not v}
323             missing_fields = none_model_fields.difference(new_class.declared_fields)
324             if missing_fields:
325                 message = "Unknown field(s) (%s) specified for %s"
326                 message = message % (", ".join(missing_fields), opts.model.__name__)
327                 raise FieldError(message)
328             # Override default model fields with any custom declared ones
329             # (plus, include all the other declared fields).
330             fields.update(new_class.declared_fields)
331         else:
332             fields = new_class.declared_fields
333 
334         new_class.base_fields = fields
335 
336         return new_class
337 
338 
339 class BaseModelForm(BaseForm):
340     def __init__(
341         self,
342         data=None,
343         files=None,
344         auto_id="id_%s",
345         prefix=None,
346         initial=None,
347         error_class=ErrorList,
348         label_suffix=None,
349         empty_permitted=False,
350         instance=None,
351         use_required_attribute=None,
352         renderer=None,
353     ):
354         opts = self._meta
355         if opts.model is None:
356             raise ValueError("ModelForm has no model class specified.")
357         if instance is None:
358             # if we didn't get an instance, instantiate a new one
359             self.instance = opts.model()
360             object_data = {}
361         else:
362             self.instance = instance
363             object_data = model_to_dict(instance, opts.fields, opts.exclude)
364         # if initial was provided, it should override the values from instance
365         if initial is not None:
366             object_data.update(initial)
367         # self._validate_unique will be set to True by BaseModelForm.clean().
368         # It is False by default so overriding self.clean() and failing to call
369         # super will stop validate_unique from being called.
370         self._validate_unique = False
371         super().__init__(
372             data,
373             files,
374             auto_id,
375             prefix,
376             object_data,
377             error_class,
378             label_suffix,
379             empty_permitted,
380             use_required_attribute=use_required_attribute,
381             renderer=renderer,
382         )
383         for formfield in self.fields.values():
384             apply_limit_choices_to_to_formfield(formfield)
385 
386     def _get_validation_exclusions(self):
387         """
388         For backwards-compatibility, exclude several types of fields from model
389         validation. See tickets #12507, #12521, #12553.
390         """
391         exclude = set()
392         # Build up a list of fields that should be excluded from model field
393         # validation and unique checks.
394         for f in self.instance._meta.fields:
395             field = f.name
396             # Exclude fields that aren't on the form. The developer may be
397             # adding these values to the model after form validation.
398             if field not in self.fields:
399                 exclude.add(f.name)
400 
401             # Don't perform model validation on fields that were defined
402             # manually on the form and excluded via the ModelForm's Meta
403             # class. See #12901.
404             elif self._meta.fields and field not in self._meta.fields:
405                 exclude.add(f.name)
406             elif self._meta.exclude and field in self._meta.exclude:
407                 exclude.add(f.name)
408 
409             # Exclude fields that failed form validation. There's no need for
410             # the model fields to validate them as well.
411             elif field in self._errors:
412                 exclude.add(f.name)
413 
414             # Exclude empty fields that are not required by the form, if the
415             # underlying model field is required. This keeps the model field
416             # from raising a required error. Note: don't exclude the field from
417             # validation if the model field allows blanks. If it does, the blank
418             # value may be included in a unique check, so cannot be excluded
419             # from validation.
420             else:
421                 form_field = self.fields[field]
422                 field_value = self.cleaned_data.get(field)
423                 if (
424                     not f.blank
425                     and not form_field.required
426                     and field_value in form_field.empty_values
427                 ):
428                     exclude.add(f.name)
429         return exclude
430 
431     def clean(self):
432         self._validate_unique = True
433         return self.cleaned_data
434 
435     def _update_errors(self, errors):
436         # Override any validation error messages defined at the model level
437         # with those defined at the form level.
438         opts = self._meta
439 
440         # Allow the model generated by construct_instance() to raise
441         # ValidationError and have them handled in the same way as others.
442         if hasattr(errors, "error_dict"):
443             error_dict = errors.error_dict
444         else:
445             error_dict = {NON_FIELD_ERRORS: errors}
446 
447         for field, messages in error_dict.items():
448             if (
449                 field == NON_FIELD_ERRORS
450                 and opts.error_messages
451                 and NON_FIELD_ERRORS in opts.error_messages
452             ):
453                 error_messages = opts.error_messages[NON_FIELD_ERRORS]
454             elif field in self.fields:
455                 error_messages = self.fields[field].error_messages
456             else:
457                 continue
458 
459             for message in messages:
460                 if (
461                     isinstance(message, ValidationError)
462                     and message.code in error_messages
463                 ):
464                     message.message = error_messages[message.code]
465 
466         self.add_error(None, errors)
467 
468     def _post_clean(self):
469         opts = self._meta
470 
471         exclude = self._get_validation_exclusions()
472 
473         # Foreign Keys being used to represent inline relationships
474         # are excluded from basic field value validation. This is for two
475         # reasons: firstly, the value may not be supplied (#12507; the
476         # case of providing new values to the admin); secondly the
477         # object being referred to may not yet fully exist (#12749).
478         # However, these fields *must* be included in uniqueness checks,
479         # so this can't be part of _get_validation_exclusions().
480         for name, field in self.fields.items():
481             if isinstance(field, InlineForeignKeyField):
482                 exclude.add(name)
483 
484         try:
485             self.instance = construct_instance(
486                 self, self.instance, opts.fields, opts.exclude
487             )
488         except ValidationError as e:
489             self._update_errors(e)
490 
491         try:
492             self.instance.full_clean(exclude=exclude, validate_unique=False)
493         except ValidationError as e:
494             self._update_errors(e)
495 
496         # Validate uniqueness if needed.
497         if self._validate_unique:
498             self.validate_unique()
499 
500     def validate_unique(self):
501         """
502         Call the instance's validate_unique() method and update the form's
503         validation errors if any were raised.
504         """
505         exclude = self._get_validation_exclusions()
506         try:
507             self.instance.validate_unique(exclude=exclude)
508         except ValidationError as e:
509             self._update_errors(e)
510 
511     def _save_m2m(self):
512         """
513         Save the many-to-many fields and generic relations for this form.
514         """
515         cleaned_data = self.cleaned_data
516         exclude = self._meta.exclude
517         fields = self._meta.fields
518         opts = self.instance._meta
519         # Note that for historical reasons we want to include also
520         # private_fields here. (GenericRelation was previously a fake
521         # m2m field).
522         for f in chain(opts.many_to_many, opts.private_fields):
523             if not hasattr(f, "save_form_data"):
524                 continue
525             if fields and f.name not in fields:
526                 continue
527             if exclude and f.name in exclude:
528                 continue
529             if f.name in cleaned_data:
530                 f.save_form_data(self.instance, cleaned_data[f.name])
531 
532     def save(self, commit=True):
533         """
534         Save this form's self.instance object if commit=True. Otherwise, add
535         a save_m2m() method to the form which can be called after the instance
536         is saved manually at a later time. Return the model instance.
537         """
538         if self.errors:
539             raise ValueError(
540                 "The %s could not be %s because the data didn't validate."
541                 % (
542                     self.instance._meta.object_name,
543                     "created" if self.instance._state.adding else "changed",
544                 )
545             )
546         if commit:
547             # If committing, save the instance and the m2m data immediately.
548             self.instance.save()
549             self._save_m2m()
550         else:
551             # If not committing, add a method to the form to allow deferred
552             # saving of m2m data.
553             self.save_m2m = self._save_m2m
554         return self.instance
555 
556     save.alters_data = True
557 
558 
559 class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):
560     pass
561 
562 
563 def modelform_factory(
564     model,
565     form=ModelForm,
566     fields=None,
567     exclude=None,
568     formfield_callback=None,
569     widgets=None,
570     localized_fields=None,
571     labels=None,
572     help_texts=None,
573     error_messages=None,
574     field_classes=None,
575 ):
576     """
577     Return a ModelForm containing form fields for the given model. You can
578     optionally pass a `form` argument to use as a starting point for
579     constructing the ModelForm.
580 
581     ``fields`` is an optional list of field names. If provided, include only
582     the named fields in the returned fields. If omitted or '__all__', use all
583     fields.
584 
585     ``exclude`` is an optional list of field names. If provided, exclude the
586     named fields from the returned fields, even if they are listed in the
587     ``fields`` argument.
588 
589     ``widgets`` is a dictionary of model field names mapped to a widget.
590 
591     ``localized_fields`` is a list of names of fields which should be localized.
592 
593     ``formfield_callback`` is a callable that takes a model field and returns
594     a form field.
595 
596     ``labels`` is a dictionary of model field names mapped to a label.
597 
598     ``help_texts`` is a dictionary of model field names mapped to a help text.
599 
600     ``error_messages`` is a dictionary of model field names mapped to a
601     dictionary of error messages.
602 
603     ``field_classes`` is a dictionary of model field names mapped to a form
604     field class.
605     """
606     # Create the inner Meta class. FIXME: ideally, we should be able to
607     # construct a ModelForm without creating and passing in a temporary
608     # inner class.
609 
610     # Build up a list of attributes that the Meta object will have.
611     attrs = {"model": model}
612     if fields is not None:
613         attrs["fields"] = fields
614     if exclude is not None:
615         attrs["exclude"] = exclude
616     if widgets is not None:
617         attrs["widgets"] = widgets
618     if localized_fields is not None:
619         attrs["localized_fields"] = localized_fields
620     if labels is not None:
621         attrs["labels"] = labels
622     if help_texts is not None:
623         attrs["help_texts"] = help_texts
624     if error_messages is not None:
625         attrs["error_messages"] = error_messages
626     if field_classes is not None:
627         attrs["field_classes"] = field_classes
628 
629     # If parent form class already has an inner Meta, the Meta we're
630     # creating needs to inherit from the parent's inner meta.
631     bases = (form.Meta,) if hasattr(form, "Meta") else ()
632     Meta = type("Meta", bases, attrs)
633     if formfield_callback:
634         Meta.formfield_callback = staticmethod(formfield_callback)
635     # Give this new form class a reasonable name.
636     class_name = model.__name__ + "Form"
637 
638     # Class attributes for the new form class.
639     form_class_attrs = {"Meta": Meta, "formfield_callback": formfield_callback}
640 
641     if getattr(Meta, "fields", None) is None and getattr(Meta, "exclude", None) is None:
642         raise ImproperlyConfigured(
643             "Calling modelform_factory without defining 'fields' or "
644             "'exclude' explicitly is prohibited."
645         )
646 
647     # Instantiate type(form) in order to use the same metaclass as form.
648     return type(form)(class_name, (form,), form_class_attrs)
649 
650 
651 # ModelFormSets ##############################################################
652 
653 
654 class BaseModelFormSet(BaseFormSet):
655     """
656     A ``FormSet`` for editing a queryset and/or adding new objects to it.
657     """
658 
659     model = None
660 
661     # Set of fields that must be unique among forms of this set.
662     unique_fields = set()
663 
664     def __init__(
665         self,
666         data=None,
667         files=None,
668         auto_id="id_%s",
669         prefix=None,
670         queryset=None,
671         *,
672         initial=None,
673         **kwargs,
674     ):
675         self.queryset = queryset
676         self.initial_extra = initial
677         super().__init__(
678             **{
679                 "data": data,
680                 "files": files,
681                 "auto_id": auto_id,
682                 "prefix": prefix,
683                 **kwargs,
684             }
685         )
686 
687     def initial_form_count(self):
688         """Return the number of forms that are required in this FormSet."""
689         if not self.is_bound:
690             return len(self.get_queryset())
691         return super().initial_form_count()
692 
693     def _existing_object(self, pk):
694         if not hasattr(self, "_object_dict"):
695             self._object_dict = {o.pk: o for o in self.get_queryset()}
696         return self._object_dict.get(pk)
697 
698     def _get_to_python(self, field):
699         """
700         If the field is a related field, fetch the concrete field's (that
701         is, the ultimate pointed-to field's) to_python.
702         """
703         while field.remote_field is not None:
704             field = field.remote_field.get_related_field()
705         return field.to_python
706 
707     def _construct_form(self, i, **kwargs):
708         pk_required = i < self.initial_form_count()
709         if pk_required:
710             if self.is_bound:
711                 pk_key = "%s-%s" % (self.add_prefix(i), self.model._meta.pk.name)
712                 try:
713                     pk = self.data[pk_key]
714                 except KeyError:
715                     # The primary key is missing. The user may have tampered
716                     # with POST data.
717                     pass
718                 else:
719                     to_python = self._get_to_python(self.model._meta.pk)
720                     try:
721                         pk = to_python(pk)
722                     except ValidationError:
723                         # The primary key exists but is an invalid value. The
724                         # user may have tampered with POST data.
725                         pass
726                     else:
727                         kwargs["instance"] = self._existing_object(pk)
728             else:
729                 kwargs["instance"] = self.get_queryset()[i]
730         elif self.initial_extra:
731             # Set initial values for extra forms
732             try:
733                 kwargs["initial"] = self.initial_extra[i - self.initial_form_count()]
734             except IndexError:
735                 pass
736         form = super()._construct_form(i, **kwargs)
737         if pk_required:
738             form.fields[self.model._meta.pk.name].required = True
739         return form
740 
741     def get_queryset(self):
742         if not hasattr(self, "_queryset"):
743             if self.queryset is not None:
744                 qs = self.queryset
745             else:
746                 qs = self.model._default_manager.get_queryset()
747 
748             # If the queryset isn't already ordered we need to add an
749             # artificial ordering here to make sure that all formsets
750             # constructed from this queryset have the same form order.
751             if not qs.ordered:
752                 qs = qs.order_by(self.model._meta.pk.name)
753 
754             # Removed queryset limiting here. As per discussion re: #13023
755             # on django-dev, max_num should not prevent existing
756             # related objects/inlines from being displayed.
757             self._queryset = qs
758         return self._queryset
759 
760     def save_new(self, form, commit=True):
761         """Save and return a new model instance for the given form."""
762         return form.save(commit=commit)
763 
764     def save_existing(self, form, instance, commit=True):
765         """Save and return an existing model instance for the given form."""
766         return form.save(commit=commit)
767 
768     def delete_existing(self, obj, commit=True):
769         """Deletes an existing model instance."""
770         if commit:
771             obj.delete()
772 
773     def save(self, commit=True):
774         """
775         Save model instances for every form, adding and changing instances
776         as necessary, and return the list of instances.
777         """
778         if not commit:
779             self.saved_forms = []
780 
781             def save_m2m():
782                 for form in self.saved_forms:
783                     form.save_m2m()
784 
785             self.save_m2m = save_m2m
786         if self.edit_only:
787             return self.save_existing_objects(commit)
788         else:
789             return self.save_existing_objects(commit) + self.save_new_objects(commit)
790 
791     save.alters_data = True
792 
793     def clean(self):
794         self.validate_unique()
795 
796     def validate_unique(self):
797         # Collect unique_checks and date_checks to run from all the forms.
798         all_unique_checks = set()
799         all_date_checks = set()
800         forms_to_delete = self.deleted_forms
801         valid_forms = [
802             form
803             for form in self.forms
804             if form.is_valid() and form not in forms_to_delete
805         ]
806         for form in valid_forms:
807             exclude = form._get_validation_exclusions()
808             unique_checks, date_checks = form.instance._get_unique_checks(
809                 exclude=exclude,
810                 include_meta_constraints=True,
811             )
812             all_unique_checks.update(unique_checks)
813             all_date_checks.update(date_checks)
814 
815         errors = []
816         # Do each of the unique checks (unique and unique_together)
817         for uclass, unique_check in all_unique_checks:
818             seen_data = set()
819             for form in valid_forms:
820                 # Get the data for the set of fields that must be unique among
821                 # the forms.
822                 row_data = (
823                     field if field in self.unique_fields else form.cleaned_data[field]
824                     for field in unique_check
825                     if field in form.cleaned_data
826                 )
827                 # Reduce Model instances to their primary key values
828                 row_data = tuple(
829                     d._get_pk_val() if hasattr(d, "_get_pk_val")
830                     # Prevent "unhashable type: list" errors later on.
831                     else tuple(d) if isinstance(d, list) else d
832                     for d in row_data
833                 )
834                 if row_data and None not in row_data:
835                     # if we've already seen it then we have a uniqueness failure
836                     if row_data in seen_data:
837                         # poke error messages into the right places and mark
838                         # the form as invalid
839                         errors.append(self.get_unique_error_message(unique_check))
840                         form._errors[NON_FIELD_ERRORS] = self.error_class(
841                             [self.get_form_error()],
842                             renderer=self.renderer,
843                         )
844                         # Remove the data from the cleaned_data dict since it
845                         # was invalid.
846                         for field in unique_check:
847                             if field in form.cleaned_data:
848                                 del form.cleaned_data[field]
849                     # mark the data as seen
850                     seen_data.add(row_data)
851         # iterate over each of the date checks now
852         for date_check in all_date_checks:
853             seen_data = set()
854             uclass, lookup, field, unique_for = date_check
855             for form in valid_forms:
856                 # see if we have data for both fields
857                 if (
858                     form.cleaned_data
859                     and form.cleaned_data[field] is not None
860                     and form.cleaned_data[unique_for] is not None
861                 ):
862                     # if it's a date lookup we need to get the data for all the fields
863                     if lookup == "date":
864                         date = form.cleaned_data[unique_for]
865                         date_data = (date.year, date.month, date.day)
866                     # otherwise it's just the attribute on the date/datetime
867                     # object
868                     else:
869                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)
870                     data = (form.cleaned_data[field],) + date_data
871                     # if we've already seen it then we have a uniqueness failure
872                     if data in seen_data:
873                         # poke error messages into the right places and mark
874                         # the form as invalid
875                         errors.append(self.get_date_error_message(date_check))
876                         form._errors[NON_FIELD_ERRORS] = self.error_class(
877                             [self.get_form_error()],
878                             renderer=self.renderer,
879                         )
880                         # Remove the data from the cleaned_data dict since it
881                         # was invalid.
882                         del form.cleaned_data[field]
883                     # mark the data as seen
884                     seen_data.add(data)
885 
886         if errors:
887             raise ValidationError(errors)
888 
889     def get_unique_error_message(self, unique_check):
890         if len(unique_check) == 1:
891             return gettext("Please correct the duplicate data for %(field)s.") % {
892                 "field": unique_check[0],
893             }
894         else:
895             return gettext(
896                 "Please correct the duplicate data for %(field)s, which must be unique."
897             ) % {
898                 "field": get_text_list(unique_check, _("and")),
899             }
900 
901     def get_date_error_message(self, date_check):
902         return gettext(
903             "Please correct the duplicate data for %(field_name)s "
904             "which must be unique for the %(lookup)s in %(date_field)s."
905         ) % {
906             "field_name": date_check[2],
907             "date_field": date_check[3],
908             "lookup": str(date_check[1]),
909         }
910 
911     def get_form_error(self):
912         return gettext("Please correct the duplicate values below.")
913 
914     def save_existing_objects(self, commit=True):
915         self.changed_objects = []
916         self.deleted_objects = []
917         if not self.initial_forms:
918             return []
919 
920         saved_instances = []
921         forms_to_delete = self.deleted_forms
922         for form in self.initial_forms:
923             obj = form.instance
924             # If the pk is None, it means either:
925             # 1. The object is an unexpected empty model, created by invalid
926             #    POST data such as an object outside the formset's queryset.
927             # 2. The object was already deleted from the database.
928             if obj.pk is None:
929                 continue
930             if form in forms_to_delete:
931                 self.deleted_objects.append(obj)
932                 self.delete_existing(obj, commit=commit)
933             elif form.has_changed():
934                 self.changed_objects.append((obj, form.changed_data))
935                 saved_instances.append(self.save_existing(form, obj, commit=commit))
936                 if not commit:
937                     self.saved_forms.append(form)
938         return saved_instances
939 
940     def save_new_objects(self, commit=True):
941         self.new_objects = []
942         for form in self.extra_forms:
943             if not form.has_changed():
944                 continue
945             # If someone has marked an add form for deletion, don't save the
946             # object.
947             if self.can_delete and self._should_delete_form(form):
948                 continue
949             self.new_objects.append(self.save_new(form, commit=commit))
950             if not commit:
951                 self.saved_forms.append(form)
952         return self.new_objects
953 
954     def add_fields(self, form, index):
955         """Add a hidden field for the object's primary key."""
956         from django.db.models import AutoField, ForeignKey, OneToOneField
957 
958         self._pk_field = pk = self.model._meta.pk
959         # If a pk isn't editable, then it won't be on the form, so we need to
960         # add it here so we can tell which object is which when we get the
961         # data back. Generally, pk.editable should be false, but for some
962         # reason, auto_created pk fields and AutoField's editable attribute is
963         # True, so check for that as well.
964 
965         def pk_is_not_editable(pk):
966             return (
967                 (not pk.editable)
968                 or (pk.auto_created or isinstance(pk, AutoField))
969                 or (
970                     pk.remote_field
971                     and pk.remote_field.parent_link
972                     and pk_is_not_editable(pk.remote_field.model._meta.pk)
973                 )
974             )
975 
976         if pk_is_not_editable(pk) or pk.name not in form.fields:
977             if form.is_bound:
978                 # If we're adding the related instance, ignore its primary key
979                 # as it could be an auto-generated default which isn't actually
980                 # in the database.
981                 pk_value = None if form.instance._state.adding else form.instance.pk
982             else:
983                 try:
984                     if index is not None:
985                         pk_value = self.get_queryset()[index].pk
986                     else:
987                         pk_value = None
988                 except IndexError:
989                     pk_value = None
990             if isinstance(pk, (ForeignKey, OneToOneField)):
991                 qs = pk.remote_field.model._default_manager.get_queryset()
992             else:
993                 qs = self.model._default_manager.get_queryset()
994             qs = qs.using(form.instance._state.db)
995             if form._meta.widgets:
996                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)
997             else:
998                 widget = HiddenInput
999             form.fields[self._pk_field.name] = ModelChoiceField(
1000                 qs, initial=pk_value, required=False, widget=widget
1001             )
1002         super().add_fields(form, index)
1003 
1004 
1005 def modelformset_factory(
1006     model,
1007     form=ModelForm,
1008     formfield_callback=None,
1009     formset=BaseModelFormSet,
1010     extra=1,
1011     can_delete=False,
1012     can_order=False,
1013     max_num=None,
1014     fields=None,
1015     exclude=None,
1016     widgets=None,
1017     validate_max=False,
1018     localized_fields=None,
1019     labels=None,
1020     help_texts=None,
1021     error_messages=None,
1022     min_num=None,
1023     validate_min=False,
1024     field_classes=None,
1025     absolute_max=None,
1026     can_delete_extra=True,
1027     renderer=None,
1028     edit_only=False,
1029 ):
1030     """Return a FormSet class for the given Django model class."""
1031     meta = getattr(form, "Meta", None)
1032     if (
1033         getattr(meta, "fields", fields) is None
1034         and getattr(meta, "exclude", exclude) is None
1035     ):
1036         raise ImproperlyConfigured(
1037             "Calling modelformset_factory without defining 'fields' or "
1038             "'exclude' explicitly is prohibited."
1039         )
1040 
1041     form = modelform_factory(
1042         model,
1043         form=form,
1044         fields=fields,
1045         exclude=exclude,
1046         formfield_callback=formfield_callback,
1047         widgets=widgets,
1048         localized_fields=localized_fields,
1049         labels=labels,
1050         help_texts=help_texts,
1051         error_messages=error_messages,
1052         field_classes=field_classes,
1053     )
1054     FormSet = formset_factory(
1055         form,
1056         formset,
1057         extra=extra,
1058         min_num=min_num,
1059         max_num=max_num,
1060         can_order=can_order,
1061         can_delete=can_delete,
1062         validate_min=validate_min,
1063         validate_max=validate_max,
1064         absolute_max=absolute_max,
1065         can_delete_extra=can_delete_extra,
1066         renderer=renderer,
1067     )
1068     FormSet.model = model
1069     FormSet.edit_only = edit_only
1070     return FormSet
1071 
1072 
1073 # InlineFormSets #############################################################
1074 
1075 
1076 class BaseInlineFormSet(BaseModelFormSet):
1077     """A formset for child objects related to a parent."""
1078 
1079     def __init__(
1080         self,
1081         data=None,
1082         files=None,
1083         instance=None,
1084         save_as_new=False,
1085         prefix=None,
1086         queryset=None,
1087         **kwargs,
1088     ):
1089         if instance is None:
1090             self.instance = self.fk.remote_field.model()
1091         else:
1092             self.instance = instance
1093         self.save_as_new = save_as_new
1094         if queryset is None:
1095             queryset = self.model._default_manager
1096         if self.instance.pk is not None:
1097             qs = queryset.filter(**{self.fk.name: self.instance})
1098         else:
1099             qs = queryset.none()
1100         self.unique_fields = {self.fk.name}
1101         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)
1102 
1103         # Add the generated field to form._meta.fields if it's defined to make
1104         # sure validation isn't skipped on that field.
1105         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:
1106             if isinstance(self.form._meta.fields, tuple):
1107                 self.form._meta.fields = list(self.form._meta.fields)
1108             self.form._meta.fields.append(self.fk.name)
1109 
1110     def initial_form_count(self):
1111         if self.save_as_new:
1112             return 0
1113         return super().initial_form_count()
1114 
1115     def _construct_form(self, i, **kwargs):
1116         form = super()._construct_form(i, **kwargs)
1117         if self.save_as_new:
1118             mutable = getattr(form.data, "_mutable", None)
1119             # Allow modifying an immutable QueryDict.
1120             if mutable is not None:
1121                 form.data._mutable = True
1122             # Remove the primary key from the form's data, we are only
1123             # creating new instances
1124             form.data[form.add_prefix(self._pk_field.name)] = None
1125             # Remove the foreign key from the form's data
1126             form.data[form.add_prefix(self.fk.name)] = None
1127             if mutable is not None:
1128                 form.data._mutable = mutable
1129 
1130         # Set the fk value here so that the form can do its validation.
1131         fk_value = self.instance.pk
1132         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1133             fk_value = getattr(self.instance, self.fk.remote_field.field_name)
1134             fk_value = getattr(fk_value, "pk", fk_value)
1135         setattr(form.instance, self.fk.get_attname(), fk_value)
1136         return form
1137 
1138     @classmethod
1139     def get_default_prefix(cls):
1140         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace("+", "")
1141 
1142     def save_new(self, form, commit=True):
1143         # Ensure the latest copy of the related instance is present on each
1144         # form (it may have been saved after the formset was originally
1145         # instantiated).
1146         setattr(form.instance, self.fk.name, self.instance)
1147         return super().save_new(form, commit=commit)
1148 
1149     def add_fields(self, form, index):
1150         super().add_fields(form, index)
1151         if self._pk_field == self.fk:
1152             name = self._pk_field.name
1153             kwargs = {"pk_field": True}
1154         else:
1155             # The foreign key field might not be on the form, so we poke at the
1156             # Model field to get the label, since we need that for error messages.
1157             name = self.fk.name
1158             kwargs = {
1159                 "label": getattr(
1160                     form.fields.get(name), "label", capfirst(self.fk.verbose_name)
1161                 )
1162             }
1163 
1164         # The InlineForeignKeyField assumes that the foreign key relation is
1165         # based on the parent model's pk. If this isn't the case, set to_field
1166         # to correctly resolve the initial form value.
1167         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1168             kwargs["to_field"] = self.fk.remote_field.field_name
1169 
1170         # If we're adding a new object, ignore a parent's auto-generated key
1171         # as it will be regenerated on the save request.
1172         if self.instance._state.adding:
1173             if kwargs.get("to_field") is not None:
1174                 to_field = self.instance._meta.get_field(kwargs["to_field"])
1175             else:
1176                 to_field = self.instance._meta.pk
1177             if to_field.has_default():
1178                 setattr(self.instance, to_field.attname, None)
1179 
1180         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)
1181 
1182     def get_unique_error_message(self, unique_check):
1183         unique_check = [field for field in unique_check if field != self.fk.name]
1184         return super().get_unique_error_message(unique_check)
1185 
1186 
1187 def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):
1188     """
1189     Find and return the ForeignKey from model to parent if there is one
1190     (return None if can_fail is True and no such field exists). If fk_name is
1191     provided, assume it is the name of the ForeignKey field. Unless can_fail is
1192     True, raise an exception if there isn't a ForeignKey from model to
1193     parent_model.
1194     """
1195     # avoid circular import
1196     from django.db.models import ForeignKey
1197 
1198     opts = model._meta
1199     if fk_name:
1200         fks_to_parent = [f for f in opts.fields if f.name == fk_name]
1201         if len(fks_to_parent) == 1:
1202             fk = fks_to_parent[0]
1203             parent_list = parent_model._meta.get_parent_list()
1204             if (
1205                 not isinstance(fk, ForeignKey)
1206                 or (
1207                     # ForeignKey to proxy models.
1208                     fk.remote_field.model._meta.proxy
1209                     and fk.remote_field.model._meta.proxy_for_model not in parent_list
1210                 )
1211                 or (
1212                     # ForeignKey to concrete models.
1213                     not fk.remote_field.model._meta.proxy
1214                     and fk.remote_field.model != parent_model
1215                     and fk.remote_field.model not in parent_list
1216                 )
1217             ):
1218                 raise ValueError(
1219                     "fk_name '%s' is not a ForeignKey to '%s'."
1220                     % (fk_name, parent_model._meta.label)
1221                 )
1222         elif not fks_to_parent:
1223             raise ValueError(
1224                 "'%s' has no field named '%s'." % (model._meta.label, fk_name)
1225             )
1226     else:
1227         # Try to discover what the ForeignKey from model to parent_model is
1228         parent_list = parent_model._meta.get_parent_list()
1229         fks_to_parent = [
1230             f
1231             for f in opts.fields
1232             if isinstance(f, ForeignKey)
1233             and (
1234                 f.remote_field.model == parent_model
1235                 or f.remote_field.model in parent_list
1236                 or (
1237                     f.remote_field.model._meta.proxy
1238                     and f.remote_field.model._meta.proxy_for_model in parent_list
1239                 )
1240             )
1241         ]
1242         if len(fks_to_parent) == 1:
1243             fk = fks_to_parent[0]
1244         elif not fks_to_parent:
1245             if can_fail:
1246                 return
1247             raise ValueError(
1248                 "'%s' has no ForeignKey to '%s'."
1249                 % (
1250                     model._meta.label,
1251                     parent_model._meta.label,
1252                 )
1253             )
1254         else:
1255             raise ValueError(
1256                 "'%s' has more than one ForeignKey to '%s'. You must specify "
1257                 "a 'fk_name' attribute."
1258                 % (
1259                     model._meta.label,
1260                     parent_model._meta.label,
1261                 )
1262             )
1263     return fk
1264 
1265 
1266 def inlineformset_factory(
1267     parent_model,
1268     model,
1269     form=ModelForm,
1270     formset=BaseInlineFormSet,
1271     fk_name=None,
1272     fields=None,
1273     exclude=None,
1274     extra=3,
1275     can_order=False,
1276     can_delete=True,
1277     max_num=None,
1278     formfield_callback=None,
1279     widgets=None,
1280     validate_max=False,
1281     localized_fields=None,
1282     labels=None,
1283     help_texts=None,
1284     error_messages=None,
1285     min_num=None,
1286     validate_min=False,
1287     field_classes=None,
1288     absolute_max=None,
1289     can_delete_extra=True,
1290     renderer=None,
1291     edit_only=False,
1292 ):
1293     """
1294     Return an ``InlineFormSet`` for the given kwargs.
1295 
1296     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``
1297     to ``parent_model``.
1298     """
1299     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
1300     # enforce a max_num=1 when the foreign key to the parent model is unique.
1301     if fk.unique:
1302         max_num = 1
1303     kwargs = {
1304         "form": form,
1305         "formfield_callback": formfield_callback,
1306         "formset": formset,
1307         "extra": extra,
1308         "can_delete": can_delete,
1309         "can_order": can_order,
1310         "fields": fields,
1311         "exclude": exclude,
1312         "min_num": min_num,
1313         "max_num": max_num,
1314         "widgets": widgets,
1315         "validate_min": validate_min,
1316         "validate_max": validate_max,
1317         "localized_fields": localized_fields,
1318         "labels": labels,
1319         "help_texts": help_texts,
1320         "error_messages": error_messages,
1321         "field_classes": field_classes,
1322         "absolute_max": absolute_max,
1323         "can_delete_extra": can_delete_extra,
1324         "renderer": renderer,
1325         "edit_only": edit_only,
1326     }
1327     FormSet = modelformset_factory(model, **kwargs)
1328     FormSet.fk = fk
1329     return FormSet
1330 
1331 
1332 # Fields #####################################################################
1333 
1334 
1335 class InlineForeignKeyField(Field):
1336     """
1337     A basic integer field that deals with validating the given value to a
1338     given parent instance in an inline.
1339     """
1340 
1341     widget = HiddenInput
1342     default_error_messages = {
1343         "invalid_choice": _("The inline value did not match the parent instance."),
1344     }
1345 
1346     def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):
1347         self.parent_instance = parent_instance
1348         self.pk_field = pk_field
1349         self.to_field = to_field
1350         if self.parent_instance is not None:
1351             if self.to_field:
1352                 kwargs["initial"] = getattr(self.parent_instance, self.to_field)
1353             else:
1354                 kwargs["initial"] = self.parent_instance.pk
1355         kwargs["required"] = False
1356         super().__init__(*args, **kwargs)
1357 
1358     def clean(self, value):
1359         if value in self.empty_values:
1360             if self.pk_field:
1361                 return None
1362             # if there is no value act as we did before.
1363             return self.parent_instance
1364         # ensure the we compare the values as equal types.
1365         if self.to_field:
1366             orig = getattr(self.parent_instance, self.to_field)
1367         else:
1368             orig = self.parent_instance.pk
1369         if str(value) != str(orig):
1370             raise ValidationError(
1371                 self.error_messages["invalid_choice"], code="invalid_choice"
1372             )
1373         return self.parent_instance
1374 
1375     def has_changed(self, initial, data):
1376         return False
1377 
1378 
1379 class ModelChoiceIteratorValue:
1380     def __init__(self, value, instance):
1381         self.value = value
1382         self.instance = instance
1383 
1384     def __str__(self):
1385         return str(self.value)
1386 
1387     def __hash__(self):
1388         return hash(self.value)
1389 
1390     def __eq__(self, other):
1391         if isinstance(other, ModelChoiceIteratorValue):
1392             other = other.value
1393         return self.value == other
1394 
1395 
1396 class ModelChoiceIterator:
1397     def __init__(self, field):
1398         self.field = field
1399         self.queryset = field.queryset
1400 
1401     def __iter__(self):
1402         if self.field.empty_label is not None:
1403             yield ("", self.field.empty_label)
1404         queryset = self.queryset
1405         # Can't use iterator() when queryset uses prefetch_related()
1406         if not queryset._prefetch_related_lookups:
1407             queryset = queryset.iterator()
1408         for obj in queryset:
1409             yield self.choice(obj)
1410 
1411     def __len__(self):
1412         # count() adds a query but uses less memory since the QuerySet results
1413         # won't be cached. In most cases, the choices will only be iterated on,
1414         # and __len__() won't be called.
1415         return self.queryset.count() + (1 if self.field.empty_label is not None else 0)
1416 
1417     def __bool__(self):
1418         return self.field.empty_label is not None or self.queryset.exists()
1419 
1420     def choice(self, obj):
1421         return (
1422             ModelChoiceIteratorValue(self.field.prepare_value(obj), obj),
1423             self.field.label_from_instance(obj),
1424         )
1425 
1426 
1427 class ModelChoiceField(ChoiceField):
1428     """A ChoiceField whose choices are a model QuerySet."""
1429 
1430     # This class is a subclass of ChoiceField for purity, but it doesn't
1431     # actually use any of ChoiceField's implementation.
1432     default_error_messages = {
1433         "invalid_choice": _(
1434             "Select a valid choice. That choice is not one of the available choices."
1435         ),
1436     }
1437     iterator = ModelChoiceIterator
1438 
1439     def __init__(
1440         self,
1441         queryset,
1442         *,
1443         empty_label="---------",
1444         required=True,
1445         widget=None,
1446         label=None,
1447         initial=None,
1448         help_text="",
1449         to_field_name=None,
1450         limit_choices_to=None,
1451         blank=False,
1452         **kwargs,
1453     ):
1454         # Call Field instead of ChoiceField __init__() because we don't need
1455         # ChoiceField.__init__().
1456         Field.__init__(
1457             self,
1458             required=required,
1459             widget=widget,
1460             label=label,
1461             initial=initial,
1462             help_text=help_text,
1463             **kwargs,
1464         )
1465         if (required and initial is not None) or (
1466             isinstance(self.widget, RadioSelect) and not blank
1467         ):
1468             self.empty_label = None
1469         else:
1470             self.empty_label = empty_label
1471         self.queryset = queryset
1472         self.limit_choices_to = limit_choices_to  # limit the queryset later.
1473         self.to_field_name = to_field_name
1474 
1475     def get_limit_choices_to(self):
1476         """
1477         Return ``limit_choices_to`` for this form field.
1478 
1479         If it is a callable, invoke it and return the result.
1480         """
1481         if callable(self.limit_choices_to):
1482             return self.limit_choices_to()
1483         return self.limit_choices_to
1484 
1485     def __deepcopy__(self, memo):
1486         result = super(ChoiceField, self).__deepcopy__(memo)
1487         # Need to force a new ModelChoiceIterator to be created, bug #11183
1488         if self.queryset is not None:
1489             result.queryset = self.queryset.all()
1490         return result
1491 
1492     def _get_queryset(self):
1493         return self._queryset
1494 
1495     def _set_queryset(self, queryset):
1496         self._queryset = None if queryset is None else queryset.all()
1497         self.widget.choices = self.choices
1498 
1499     queryset = property(_get_queryset, _set_queryset)
1500 
1501     # this method will be used to create object labels by the QuerySetIterator.
1502     # Override it to customize the label.
1503     def label_from_instance(self, obj):
1504         """
1505         Convert objects into strings and generate the labels for the choices
1506         presented by this object. Subclasses can override this method to
1507         customize the display of the choices.
1508         """
1509         return str(obj)
1510 
1511     def _get_choices(self):
1512         # If self._choices is set, then somebody must have manually set
1513         # the property self.choices. In this case, just return self._choices.
1514         if hasattr(self, "_choices"):
1515             return self._choices
1516 
1517         # Otherwise, execute the QuerySet in self.queryset to determine the
1518         # choices dynamically. Return a fresh ModelChoiceIterator that has not been
1519         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*
1520         # time _get_choices() is called (and, thus, each time self.choices is
1521         # accessed) so that we can ensure the QuerySet has not been consumed. This
1522         # construct might look complicated but it allows for lazy evaluation of
1523         # the queryset.
1524         return self.iterator(self)
1525 
1526     choices = property(_get_choices, ChoiceField._set_choices)
1527 
1528     def prepare_value(self, value):
1529         if hasattr(value, "_meta"):
1530             if self.to_field_name:
1531                 return value.serializable_value(self.to_field_name)
1532             else:
1533                 return value.pk
1534         return super().prepare_value(value)
1535 
1536     def to_python(self, value):
1537         if value in self.empty_values:
1538             return None
1539         try:
1540             key = self.to_field_name or "pk"
1541             if isinstance(value, self.queryset.model):
1542                 value = getattr(value, key)
1543             value = self.queryset.get(**{key: value})
1544         except (ValueError, TypeError, self.queryset.model.DoesNotExist):
1545             raise ValidationError(
1546                 self.error_messages["invalid_choice"],
1547                 code="invalid_choice",
1548                 params={"value": value},
1549             )
1550         return value
1551 
1552     def validate(self, value):
1553         return Field.validate(self, value)
1554 
1555     def has_changed(self, initial, data):
1556         if self.disabled:
1557             return False
1558         initial_value = initial if initial is not None else ""
1559         data_value = data if data is not None else ""
1560         return str(self.prepare_value(initial_value)) != str(data_value)
1561 
1562 
1563 class ModelMultipleChoiceField(ModelChoiceField):
1564     """A MultipleChoiceField whose choices are a model QuerySet."""
1565 
1566     widget = SelectMultiple
1567     hidden_widget = MultipleHiddenInput
1568     default_error_messages = {
1569         "invalid_list": _("Enter a list of values."),
1570         "invalid_choice": _(
1571             "Select a valid choice. %(value)s is not one of the available choices."
1572         ),
1573         "invalid_pk_value": _("%(pk)s is not a valid value."),
1574     }
1575 
1576     def __init__(self, queryset, **kwargs):
1577         super().__init__(queryset, empty_label=None, **kwargs)
1578 
1579     def to_python(self, value):
1580         if not value:
1581             return []
1582         return list(self._check_values(value))
1583 
1584     def clean(self, value):
1585         value = self.prepare_value(value)
1586         if self.required and not value:
1587             raise ValidationError(self.error_messages["required"], code="required")
1588         elif not self.required and not value:
1589             return self.queryset.none()
1590         if not isinstance(value, (list, tuple)):
1591             raise ValidationError(
1592                 self.error_messages["invalid_list"],
1593                 code="invalid_list",
1594             )
1595         qs = self._check_values(value)
1596         # Since this overrides the inherited ModelChoiceField.clean
1597         # we run custom validators here
1598         self.run_validators(value)
1599         return qs
1600 
1601     def _check_values(self, value):
1602         """
1603         Given a list of possible PK values, return a QuerySet of the
1604         corresponding objects. Raise a ValidationError if a given value is
1605         invalid (not a valid PK, not in the queryset, etc.)
1606         """
1607         key = self.to_field_name or "pk"
1608         # deduplicate given values to avoid creating many querysets or
1609         # requiring the database backend deduplicate efficiently.
1610         try:
1611             value = frozenset(value)
1612         except TypeError:
1613             # list of lists isn't hashable, for example
1614             raise ValidationError(
1615                 self.error_messages["invalid_list"],
1616                 code="invalid_list",
1617             )
1618         for pk in value:
1619             try:
1620                 self.queryset.filter(**{key: pk})
1621             except (ValueError, TypeError):
1622                 raise ValidationError(
1623                     self.error_messages["invalid_pk_value"],
1624                     code="invalid_pk_value",
1625                     params={"pk": pk},
1626                 )
1627         qs = self.queryset.filter(**{"%s__in" % key: value})
1628         pks = {str(getattr(o, key)) for o in qs}
1629         for val in value:
1630             if str(val) not in pks:
1631                 raise ValidationError(
1632                     self.error_messages["invalid_choice"],
1633                     code="invalid_choice",
1634                     params={"value": val},
1635                 )
1636         return qs
1637 
1638     def prepare_value(self, value):
1639         if (
1640             hasattr(value, "__iter__")
1641             and not isinstance(value, str)
1642             and not hasattr(value, "_meta")
1643         ):
1644             prepare_value = super().prepare_value
1645             return [prepare_value(v) for v in value]
1646         return super().prepare_value(value)
1647 
1648     def has_changed(self, initial, data):
1649         if self.disabled:
1650             return False
1651         if initial is None:
1652             initial = []
1653         if data is None:
1654             data = []
1655         if len(initial) != len(data):
1656             return True
1657         initial_set = {str(value) for value in self.prepare_value(initial)}
1658         data_set = {str(value) for value in data}
1659         return data_set != initial_set
1660 
1661 
1662 def modelform_defines_fields(form_class):
1663     return hasattr(form_class, "_meta") and (
1664         form_class._meta.fields is not None or form_class._meta.exclude is not None
1665     )

</code><intended_behavior>Before initiating migrations that would change field types or relationships significantly, ensuring that constraints like `unique_together` are reviewed and, if necessary, programmatically addressed (either through model Meta options or direct migration operations) to match the new model relationships and structures being implemented.</intended_behavior>]
2025-10-18 13:07:52.189 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 13:07:52.189 | INFO     | Search-only: skipping patch selection
2025-10-18 13:07:52.346 | INFO     | Task django__django-15738 completed successfully.
2025-10-18 13:07:52.347 | INFO     | No patch generated. You can try running ACR again.
