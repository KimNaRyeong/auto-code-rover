[
    {
        "rel_file_path": "django/forms/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/models.py",
        "start": 1,
        "end": 1665,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Helper functions for creating Form classes from Django models\n3 and database field objects.\n4 \"\"\"\n5 from itertools import chain\n6 \n7 from django.core.exceptions import (\n8     NON_FIELD_ERRORS,\n9     FieldError,\n10     ImproperlyConfigured,\n11     ValidationError,\n12 )\n13 from django.forms.fields import ChoiceField, Field\n14 from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n15 from django.forms.formsets import BaseFormSet, formset_factory\n16 from django.forms.utils import ErrorList\n17 from django.forms.widgets import (\n18     HiddenInput,\n19     MultipleHiddenInput,\n20     RadioSelect,\n21     SelectMultiple,\n22 )\n23 from django.utils.text import capfirst, get_text_list\n24 from django.utils.translation import gettext\n25 from django.utils.translation import gettext_lazy as _\n26 \n27 __all__ = (\n28     \"ModelForm\",\n29     \"BaseModelForm\",\n30     \"model_to_dict\",\n31     \"fields_for_model\",\n32     \"ModelChoiceField\",\n33     \"ModelMultipleChoiceField\",\n34     \"ALL_FIELDS\",\n35     \"BaseModelFormSet\",\n36     \"modelformset_factory\",\n37     \"BaseInlineFormSet\",\n38     \"inlineformset_factory\",\n39     \"modelform_factory\",\n40 )\n41 \n42 ALL_FIELDS = \"__all__\"\n43 \n44 \n45 def construct_instance(form, instance, fields=None, exclude=None):\n46     \"\"\"\n47     Construct and return a model instance from the bound ``form``'s\n48     ``cleaned_data``, but do not save the returned instance to the database.\n49     \"\"\"\n50     from django.db import models\n51 \n52     opts = instance._meta\n53 \n54     cleaned_data = form.cleaned_data\n55     file_field_list = []\n56     for f in opts.fields:\n57         if (\n58             not f.editable\n59             or isinstance(f, models.AutoField)\n60             or f.name not in cleaned_data\n61         ):\n62             continue\n63         if fields is not None and f.name not in fields:\n64             continue\n65         if exclude and f.name in exclude:\n66             continue\n67         # Leave defaults for fields that aren't in POST data, except for\n68         # checkbox inputs because they don't appear in POST data if not checked.\n69         if (\n70             f.has_default()\n71             and form[f.name].field.widget.value_omitted_from_data(\n72                 form.data, form.files, form.add_prefix(f.name)\n73             )\n74             and cleaned_data.get(f.name) in form[f.name].field.empty_values\n75         ):\n76             continue\n77         # Defer saving file-type fields until after the other fields, so a\n78         # callable upload_to can use the values from other fields.\n79         if isinstance(f, models.FileField):\n80             file_field_list.append(f)\n81         else:\n82             f.save_form_data(instance, cleaned_data[f.name])\n83 \n84     for f in file_field_list:\n85         f.save_form_data(instance, cleaned_data[f.name])\n86 \n87     return instance\n88 \n89 \n90 # ModelForms #################################################################\n91 \n92 \n93 def model_to_dict(instance, fields=None, exclude=None):\n94     \"\"\"\n95     Return a dict containing the data in ``instance`` suitable for passing as\n96     a Form's ``initial`` keyword argument.\n97 \n98     ``fields`` is an optional list of field names. If provided, return only the\n99     named.\n100 \n101     ``exclude`` is an optional list of field names. If provided, exclude the\n102     named from the returned dict, even if they are listed in the ``fields``\n103     argument.\n104     \"\"\"\n105     opts = instance._meta\n106     data = {}\n107     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):\n108         if not getattr(f, \"editable\", False):\n109             continue\n110         if fields is not None and f.name not in fields:\n111             continue\n112         if exclude and f.name in exclude:\n113             continue\n114         data[f.name] = f.value_from_object(instance)\n115     return data\n116 \n117 \n118 def apply_limit_choices_to_to_formfield(formfield):\n119     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n120     from django.db.models import Exists, OuterRef, Q\n121 \n122     if hasattr(formfield, \"queryset\") and hasattr(formfield, \"get_limit_choices_to\"):\n123         limit_choices_to = formfield.get_limit_choices_to()\n124         if limit_choices_to:\n125             complex_filter = limit_choices_to\n126             if not isinstance(complex_filter, Q):\n127                 complex_filter = Q(**limit_choices_to)\n128             complex_filter &= Q(pk=OuterRef(\"pk\"))\n129             # Use Exists() to avoid potential duplicates.\n130             formfield.queryset = formfield.queryset.filter(\n131                 Exists(formfield.queryset.model._base_manager.filter(complex_filter)),\n132             )\n133 \n134 \n135 def fields_for_model(\n136     model,\n137     fields=None,\n138     exclude=None,\n139     widgets=None,\n140     formfield_callback=None,\n141     localized_fields=None,\n142     labels=None,\n143     help_texts=None,\n144     error_messages=None,\n145     field_classes=None,\n146     *,\n147     apply_limit_choices_to=True,\n148 ):\n149     \"\"\"\n150     Return a dictionary containing form fields for the given model.\n151 \n152     ``fields`` is an optional list of field names. If provided, return only the\n153     named fields.\n154 \n155     ``exclude`` is an optional list of field names. If provided, exclude the\n156     named fields from the returned fields, even if they are listed in the\n157     ``fields`` argument.\n158 \n159     ``widgets`` is a dictionary of model field names mapped to a widget.\n160 \n161     ``formfield_callback`` is a callable that takes a model field and returns\n162     a form field.\n163 \n164     ``localized_fields`` is a list of names of fields which should be localized.\n165 \n166     ``labels`` is a dictionary of model field names mapped to a label.\n167 \n168     ``help_texts`` is a dictionary of model field names mapped to a help text.\n169 \n170     ``error_messages`` is a dictionary of model field names mapped to a\n171     dictionary of error messages.\n172 \n173     ``field_classes`` is a dictionary of model field names mapped to a form\n174     field class.\n175 \n176     ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to\n177     should be applied to a field's queryset.\n178     \"\"\"\n179     field_dict = {}\n180     ignored = []\n181     opts = model._meta\n182     # Avoid circular import\n183     from django.db.models import Field as ModelField\n184 \n185     sortable_private_fields = [\n186         f for f in opts.private_fields if isinstance(f, ModelField)\n187     ]\n188     for f in sorted(\n189         chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)\n190     ):\n191         if not getattr(f, \"editable\", False):\n192             if (\n193                 fields is not None\n194                 and f.name in fields\n195                 and (exclude is None or f.name not in exclude)\n196             ):\n197                 raise FieldError(\n198                     \"'%s' cannot be specified for %s model form as it is a \"\n199                     \"non-editable field\" % (f.name, model.__name__)\n200                 )\n201             continue\n202         if fields is not None and f.name not in fields:\n203             continue\n204         if exclude and f.name in exclude:\n205             continue\n206 \n207         kwargs = {}\n208         if widgets and f.name in widgets:\n209             kwargs[\"widget\"] = widgets[f.name]\n210         if localized_fields == ALL_FIELDS or (\n211             localized_fields and f.name in localized_fields\n212         ):\n213             kwargs[\"localize\"] = True\n214         if labels and f.name in labels:\n215             kwargs[\"label\"] = labels[f.name]\n216         if help_texts and f.name in help_texts:\n217             kwargs[\"help_text\"] = help_texts[f.name]\n218         if error_messages and f.name in error_messages:\n219             kwargs[\"error_messages\"] = error_messages[f.name]\n220         if field_classes and f.name in field_classes:\n221             kwargs[\"form_class\"] = field_classes[f.name]\n222 \n223         if formfield_callback is None:\n224             formfield = f.formfield(**kwargs)\n225         elif not callable(formfield_callback):\n226             raise TypeError(\"formfield_callback must be a function or callable\")\n227         else:\n228             formfield = formfield_callback(f, **kwargs)\n229 \n230         if formfield:\n231             if apply_limit_choices_to:\n232                 apply_limit_choices_to_to_formfield(formfield)\n233             field_dict[f.name] = formfield\n234         else:\n235             ignored.append(f.name)\n236     if fields:\n237         field_dict = {\n238             f: field_dict.get(f)\n239             for f in fields\n240             if (not exclude or f not in exclude) and f not in ignored\n241         }\n242     return field_dict\n243 \n244 \n245 class ModelFormOptions:\n246     def __init__(self, options=None):\n247         self.model = getattr(options, \"model\", None)\n248         self.fields = getattr(options, \"fields\", None)\n249         self.exclude = getattr(options, \"exclude\", None)\n250         self.widgets = getattr(options, \"widgets\", None)\n251         self.localized_fields = getattr(options, \"localized_fields\", None)\n252         self.labels = getattr(options, \"labels\", None)\n253         self.help_texts = getattr(options, \"help_texts\", None)\n254         self.error_messages = getattr(options, \"error_messages\", None)\n255         self.field_classes = getattr(options, \"field_classes\", None)\n256 \n257 \n258 class ModelFormMetaclass(DeclarativeFieldsMetaclass):\n259     def __new__(mcs, name, bases, attrs):\n260         base_formfield_callback = None\n261         for b in bases:\n262             if hasattr(b, \"Meta\") and hasattr(b.Meta, \"formfield_callback\"):\n263                 base_formfield_callback = b.Meta.formfield_callback\n264                 break\n265 \n266         formfield_callback = attrs.pop(\"formfield_callback\", base_formfield_callback)\n267 \n268         new_class = super().__new__(mcs, name, bases, attrs)\n269 \n270         if bases == (BaseModelForm,):\n271             return new_class\n272 \n273         opts = new_class._meta = ModelFormOptions(getattr(new_class, \"Meta\", None))\n274 \n275         # We check if a string was passed to `fields` or `exclude`,\n276         # which is likely to be a mistake where the user typed ('foo') instead\n277         # of ('foo',)\n278         for opt in [\"fields\", \"exclude\", \"localized_fields\"]:\n279             value = getattr(opts, opt)\n280             if isinstance(value, str) and value != ALL_FIELDS:\n281                 msg = (\n282                     \"%(model)s.Meta.%(opt)s cannot be a string. \"\n283                     \"Did you mean to type: ('%(value)s',)?\"\n284                     % {\n285                         \"model\": new_class.__name__,\n286                         \"opt\": opt,\n287                         \"value\": value,\n288                     }\n289                 )\n290                 raise TypeError(msg)\n291 \n292         if opts.model:\n293             # If a model is defined, extract form fields from it.\n294             if opts.fields is None and opts.exclude is None:\n295                 raise ImproperlyConfigured(\n296                     \"Creating a ModelForm without either the 'fields' attribute \"\n297                     \"or the 'exclude' attribute is prohibited; form %s \"\n298                     \"needs updating.\" % name\n299                 )\n300 \n301             if opts.fields == ALL_FIELDS:\n302                 # Sentinel for fields_for_model to indicate \"get the list of\n303                 # fields from the model\"\n304                 opts.fields = None\n305 \n306             fields = fields_for_model(\n307                 opts.model,\n308                 opts.fields,\n309                 opts.exclude,\n310                 opts.widgets,\n311                 formfield_callback,\n312                 opts.localized_fields,\n313                 opts.labels,\n314                 opts.help_texts,\n315                 opts.error_messages,\n316                 opts.field_classes,\n317                 # limit_choices_to will be applied during ModelForm.__init__().\n318                 apply_limit_choices_to=False,\n319             )\n320 \n321             # make sure opts.fields doesn't specify an invalid field\n322             none_model_fields = {k for k, v in fields.items() if not v}\n323             missing_fields = none_model_fields.difference(new_class.declared_fields)\n324             if missing_fields:\n325                 message = \"Unknown field(s) (%s) specified for %s\"\n326                 message = message % (\", \".join(missing_fields), opts.model.__name__)\n327                 raise FieldError(message)\n328             # Override default model fields with any custom declared ones\n329             # (plus, include all the other declared fields).\n330             fields.update(new_class.declared_fields)\n331         else:\n332             fields = new_class.declared_fields\n333 \n334         new_class.base_fields = fields\n335 \n336         return new_class\n337 \n338 \n339 class BaseModelForm(BaseForm):\n340     def __init__(\n341         self,\n342         data=None,\n343         files=None,\n344         auto_id=\"id_%s\",\n345         prefix=None,\n346         initial=None,\n347         error_class=ErrorList,\n348         label_suffix=None,\n349         empty_permitted=False,\n350         instance=None,\n351         use_required_attribute=None,\n352         renderer=None,\n353     ):\n354         opts = self._meta\n355         if opts.model is None:\n356             raise ValueError(\"ModelForm has no model class specified.\")\n357         if instance is None:\n358             # if we didn't get an instance, instantiate a new one\n359             self.instance = opts.model()\n360             object_data = {}\n361         else:\n362             self.instance = instance\n363             object_data = model_to_dict(instance, opts.fields, opts.exclude)\n364         # if initial was provided, it should override the values from instance\n365         if initial is not None:\n366             object_data.update(initial)\n367         # self._validate_unique will be set to True by BaseModelForm.clean().\n368         # It is False by default so overriding self.clean() and failing to call\n369         # super will stop validate_unique from being called.\n370         self._validate_unique = False\n371         super().__init__(\n372             data,\n373             files,\n374             auto_id,\n375             prefix,\n376             object_data,\n377             error_class,\n378             label_suffix,\n379             empty_permitted,\n380             use_required_attribute=use_required_attribute,\n381             renderer=renderer,\n382         )\n383         for formfield in self.fields.values():\n384             apply_limit_choices_to_to_formfield(formfield)\n385 \n386     def _get_validation_exclusions(self):\n387         \"\"\"\n388         For backwards-compatibility, exclude several types of fields from model\n389         validation. See tickets #12507, #12521, #12553.\n390         \"\"\"\n391         exclude = set()\n392         # Build up a list of fields that should be excluded from model field\n393         # validation and unique checks.\n394         for f in self.instance._meta.fields:\n395             field = f.name\n396             # Exclude fields that aren't on the form. The developer may be\n397             # adding these values to the model after form validation.\n398             if field not in self.fields:\n399                 exclude.add(f.name)\n400 \n401             # Don't perform model validation on fields that were defined\n402             # manually on the form and excluded via the ModelForm's Meta\n403             # class. See #12901.\n404             elif self._meta.fields and field not in self._meta.fields:\n405                 exclude.add(f.name)\n406             elif self._meta.exclude and field in self._meta.exclude:\n407                 exclude.add(f.name)\n408 \n409             # Exclude fields that failed form validation. There's no need for\n410             # the model fields to validate them as well.\n411             elif field in self._errors:\n412                 exclude.add(f.name)\n413 \n414             # Exclude empty fields that are not required by the form, if the\n415             # underlying model field is required. This keeps the model field\n416             # from raising a required error. Note: don't exclude the field from\n417             # validation if the model field allows blanks. If it does, the blank\n418             # value may be included in a unique check, so cannot be excluded\n419             # from validation.\n420             else:\n421                 form_field = self.fields[field]\n422                 field_value = self.cleaned_data.get(field)\n423                 if (\n424                     not f.blank\n425                     and not form_field.required\n426                     and field_value in form_field.empty_values\n427                 ):\n428                     exclude.add(f.name)\n429         return exclude\n430 \n431     def clean(self):\n432         self._validate_unique = True\n433         return self.cleaned_data\n434 \n435     def _update_errors(self, errors):\n436         # Override any validation error messages defined at the model level\n437         # with those defined at the form level.\n438         opts = self._meta\n439 \n440         # Allow the model generated by construct_instance() to raise\n441         # ValidationError and have them handled in the same way as others.\n442         if hasattr(errors, \"error_dict\"):\n443             error_dict = errors.error_dict\n444         else:\n445             error_dict = {NON_FIELD_ERRORS: errors}\n446 \n447         for field, messages in error_dict.items():\n448             if (\n449                 field == NON_FIELD_ERRORS\n450                 and opts.error_messages\n451                 and NON_FIELD_ERRORS in opts.error_messages\n452             ):\n453                 error_messages = opts.error_messages[NON_FIELD_ERRORS]\n454             elif field in self.fields:\n455                 error_messages = self.fields[field].error_messages\n456             else:\n457                 continue\n458 \n459             for message in messages:\n460                 if (\n461                     isinstance(message, ValidationError)\n462                     and message.code in error_messages\n463                 ):\n464                     message.message = error_messages[message.code]\n465 \n466         self.add_error(None, errors)\n467 \n468     def _post_clean(self):\n469         opts = self._meta\n470 \n471         exclude = self._get_validation_exclusions()\n472 \n473         # Foreign Keys being used to represent inline relationships\n474         # are excluded from basic field value validation. This is for two\n475         # reasons: firstly, the value may not be supplied (#12507; the\n476         # case of providing new values to the admin); secondly the\n477         # object being referred to may not yet fully exist (#12749).\n478         # However, these fields *must* be included in uniqueness checks,\n479         # so this can't be part of _get_validation_exclusions().\n480         for name, field in self.fields.items():\n481             if isinstance(field, InlineForeignKeyField):\n482                 exclude.add(name)\n483 \n484         try:\n485             self.instance = construct_instance(\n486                 self, self.instance, opts.fields, opts.exclude\n487             )\n488         except ValidationError as e:\n489             self._update_errors(e)\n490 \n491         try:\n492             self.instance.full_clean(exclude=exclude, validate_unique=False)\n493         except ValidationError as e:\n494             self._update_errors(e)\n495 \n496         # Validate uniqueness if needed.\n497         if self._validate_unique:\n498             self.validate_unique()\n499 \n500     def validate_unique(self):\n501         \"\"\"\n502         Call the instance's validate_unique() method and update the form's\n503         validation errors if any were raised.\n504         \"\"\"\n505         exclude = self._get_validation_exclusions()\n506         try:\n507             self.instance.validate_unique(exclude=exclude)\n508         except ValidationError as e:\n509             self._update_errors(e)\n510 \n511     def _save_m2m(self):\n512         \"\"\"\n513         Save the many-to-many fields and generic relations for this form.\n514         \"\"\"\n515         cleaned_data = self.cleaned_data\n516         exclude = self._meta.exclude\n517         fields = self._meta.fields\n518         opts = self.instance._meta\n519         # Note that for historical reasons we want to include also\n520         # private_fields here. (GenericRelation was previously a fake\n521         # m2m field).\n522         for f in chain(opts.many_to_many, opts.private_fields):\n523             if not hasattr(f, \"save_form_data\"):\n524                 continue\n525             if fields and f.name not in fields:\n526                 continue\n527             if exclude and f.name in exclude:\n528                 continue\n529             if f.name in cleaned_data:\n530                 f.save_form_data(self.instance, cleaned_data[f.name])\n531 \n532     def save(self, commit=True):\n533         \"\"\"\n534         Save this form's self.instance object if commit=True. Otherwise, add\n535         a save_m2m() method to the form which can be called after the instance\n536         is saved manually at a later time. Return the model instance.\n537         \"\"\"\n538         if self.errors:\n539             raise ValueError(\n540                 \"The %s could not be %s because the data didn't validate.\"\n541                 % (\n542                     self.instance._meta.object_name,\n543                     \"created\" if self.instance._state.adding else \"changed\",\n544                 )\n545             )\n546         if commit:\n547             # If committing, save the instance and the m2m data immediately.\n548             self.instance.save()\n549             self._save_m2m()\n550         else:\n551             # If not committing, add a method to the form to allow deferred\n552             # saving of m2m data.\n553             self.save_m2m = self._save_m2m\n554         return self.instance\n555 \n556     save.alters_data = True\n557 \n558 \n559 class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):\n560     pass\n561 \n562 \n563 def modelform_factory(\n564     model,\n565     form=ModelForm,\n566     fields=None,\n567     exclude=None,\n568     formfield_callback=None,\n569     widgets=None,\n570     localized_fields=None,\n571     labels=None,\n572     help_texts=None,\n573     error_messages=None,\n574     field_classes=None,\n575 ):\n576     \"\"\"\n577     Return a ModelForm containing form fields for the given model. You can\n578     optionally pass a `form` argument to use as a starting point for\n579     constructing the ModelForm.\n580 \n581     ``fields`` is an optional list of field names. If provided, include only\n582     the named fields in the returned fields. If omitted or '__all__', use all\n583     fields.\n584 \n585     ``exclude`` is an optional list of field names. If provided, exclude the\n586     named fields from the returned fields, even if they are listed in the\n587     ``fields`` argument.\n588 \n589     ``widgets`` is a dictionary of model field names mapped to a widget.\n590 \n591     ``localized_fields`` is a list of names of fields which should be localized.\n592 \n593     ``formfield_callback`` is a callable that takes a model field and returns\n594     a form field.\n595 \n596     ``labels`` is a dictionary of model field names mapped to a label.\n597 \n598     ``help_texts`` is a dictionary of model field names mapped to a help text.\n599 \n600     ``error_messages`` is a dictionary of model field names mapped to a\n601     dictionary of error messages.\n602 \n603     ``field_classes`` is a dictionary of model field names mapped to a form\n604     field class.\n605     \"\"\"\n606     # Create the inner Meta class. FIXME: ideally, we should be able to\n607     # construct a ModelForm without creating and passing in a temporary\n608     # inner class.\n609 \n610     # Build up a list of attributes that the Meta object will have.\n611     attrs = {\"model\": model}\n612     if fields is not None:\n613         attrs[\"fields\"] = fields\n614     if exclude is not None:\n615         attrs[\"exclude\"] = exclude\n616     if widgets is not None:\n617         attrs[\"widgets\"] = widgets\n618     if localized_fields is not None:\n619         attrs[\"localized_fields\"] = localized_fields\n620     if labels is not None:\n621         attrs[\"labels\"] = labels\n622     if help_texts is not None:\n623         attrs[\"help_texts\"] = help_texts\n624     if error_messages is not None:\n625         attrs[\"error_messages\"] = error_messages\n626     if field_classes is not None:\n627         attrs[\"field_classes\"] = field_classes\n628 \n629     # If parent form class already has an inner Meta, the Meta we're\n630     # creating needs to inherit from the parent's inner meta.\n631     bases = (form.Meta,) if hasattr(form, \"Meta\") else ()\n632     Meta = type(\"Meta\", bases, attrs)\n633     if formfield_callback:\n634         Meta.formfield_callback = staticmethod(formfield_callback)\n635     # Give this new form class a reasonable name.\n636     class_name = model.__name__ + \"Form\"\n637 \n638     # Class attributes for the new form class.\n639     form_class_attrs = {\"Meta\": Meta, \"formfield_callback\": formfield_callback}\n640 \n641     if getattr(Meta, \"fields\", None) is None and getattr(Meta, \"exclude\", None) is None:\n642         raise ImproperlyConfigured(\n643             \"Calling modelform_factory without defining 'fields' or \"\n644             \"'exclude' explicitly is prohibited.\"\n645         )\n646 \n647     # Instantiate type(form) in order to use the same metaclass as form.\n648     return type(form)(class_name, (form,), form_class_attrs)\n649 \n650 \n651 # ModelFormSets ##############################################################\n652 \n653 \n654 class BaseModelFormSet(BaseFormSet):\n655     \"\"\"\n656     A ``FormSet`` for editing a queryset and/or adding new objects to it.\n657     \"\"\"\n658 \n659     model = None\n660 \n661     # Set of fields that must be unique among forms of this set.\n662     unique_fields = set()\n663 \n664     def __init__(\n665         self,\n666         data=None,\n667         files=None,\n668         auto_id=\"id_%s\",\n669         prefix=None,\n670         queryset=None,\n671         *,\n672         initial=None,\n673         **kwargs,\n674     ):\n675         self.queryset = queryset\n676         self.initial_extra = initial\n677         super().__init__(\n678             **{\n679                 \"data\": data,\n680                 \"files\": files,\n681                 \"auto_id\": auto_id,\n682                 \"prefix\": prefix,\n683                 **kwargs,\n684             }\n685         )\n686 \n687     def initial_form_count(self):\n688         \"\"\"Return the number of forms that are required in this FormSet.\"\"\"\n689         if not self.is_bound:\n690             return len(self.get_queryset())\n691         return super().initial_form_count()\n692 \n693     def _existing_object(self, pk):\n694         if not hasattr(self, \"_object_dict\"):\n695             self._object_dict = {o.pk: o for o in self.get_queryset()}\n696         return self._object_dict.get(pk)\n697 \n698     def _get_to_python(self, field):\n699         \"\"\"\n700         If the field is a related field, fetch the concrete field's (that\n701         is, the ultimate pointed-to field's) to_python.\n702         \"\"\"\n703         while field.remote_field is not None:\n704             field = field.remote_field.get_related_field()\n705         return field.to_python\n706 \n707     def _construct_form(self, i, **kwargs):\n708         pk_required = i < self.initial_form_count()\n709         if pk_required:\n710             if self.is_bound:\n711                 pk_key = \"%s-%s\" % (self.add_prefix(i), self.model._meta.pk.name)\n712                 try:\n713                     pk = self.data[pk_key]\n714                 except KeyError:\n715                     # The primary key is missing. The user may have tampered\n716                     # with POST data.\n717                     pass\n718                 else:\n719                     to_python = self._get_to_python(self.model._meta.pk)\n720                     try:\n721                         pk = to_python(pk)\n722                     except ValidationError:\n723                         # The primary key exists but is an invalid value. The\n724                         # user may have tampered with POST data.\n725                         pass\n726                     else:\n727                         kwargs[\"instance\"] = self._existing_object(pk)\n728             else:\n729                 kwargs[\"instance\"] = self.get_queryset()[i]\n730         elif self.initial_extra:\n731             # Set initial values for extra forms\n732             try:\n733                 kwargs[\"initial\"] = self.initial_extra[i - self.initial_form_count()]\n734             except IndexError:\n735                 pass\n736         form = super()._construct_form(i, **kwargs)\n737         if pk_required:\n738             form.fields[self.model._meta.pk.name].required = True\n739         return form\n740 \n741     def get_queryset(self):\n742         if not hasattr(self, \"_queryset\"):\n743             if self.queryset is not None:\n744                 qs = self.queryset\n745             else:\n746                 qs = self.model._default_manager.get_queryset()\n747 \n748             # If the queryset isn't already ordered we need to add an\n749             # artificial ordering here to make sure that all formsets\n750             # constructed from this queryset have the same form order.\n751             if not qs.ordered:\n752                 qs = qs.order_by(self.model._meta.pk.name)\n753 \n754             # Removed queryset limiting here. As per discussion re: #13023\n755             # on django-dev, max_num should not prevent existing\n756             # related objects/inlines from being displayed.\n757             self._queryset = qs\n758         return self._queryset\n759 \n760     def save_new(self, form, commit=True):\n761         \"\"\"Save and return a new model instance for the given form.\"\"\"\n762         return form.save(commit=commit)\n763 \n764     def save_existing(self, form, instance, commit=True):\n765         \"\"\"Save and return an existing model instance for the given form.\"\"\"\n766         return form.save(commit=commit)\n767 \n768     def delete_existing(self, obj, commit=True):\n769         \"\"\"Deletes an existing model instance.\"\"\"\n770         if commit:\n771             obj.delete()\n772 \n773     def save(self, commit=True):\n774         \"\"\"\n775         Save model instances for every form, adding and changing instances\n776         as necessary, and return the list of instances.\n777         \"\"\"\n778         if not commit:\n779             self.saved_forms = []\n780 \n781             def save_m2m():\n782                 for form in self.saved_forms:\n783                     form.save_m2m()\n784 \n785             self.save_m2m = save_m2m\n786         if self.edit_only:\n787             return self.save_existing_objects(commit)\n788         else:\n789             return self.save_existing_objects(commit) + self.save_new_objects(commit)\n790 \n791     save.alters_data = True\n792 \n793     def clean(self):\n794         self.validate_unique()\n795 \n796     def validate_unique(self):\n797         # Collect unique_checks and date_checks to run from all the forms.\n798         all_unique_checks = set()\n799         all_date_checks = set()\n800         forms_to_delete = self.deleted_forms\n801         valid_forms = [\n802             form\n803             for form in self.forms\n804             if form.is_valid() and form not in forms_to_delete\n805         ]\n806         for form in valid_forms:\n807             exclude = form._get_validation_exclusions()\n808             unique_checks, date_checks = form.instance._get_unique_checks(\n809                 exclude=exclude,\n810                 include_meta_constraints=True,\n811             )\n812             all_unique_checks.update(unique_checks)\n813             all_date_checks.update(date_checks)\n814 \n815         errors = []\n816         # Do each of the unique checks (unique and unique_together)\n817         for uclass, unique_check in all_unique_checks:\n818             seen_data = set()\n819             for form in valid_forms:\n820                 # Get the data for the set of fields that must be unique among\n821                 # the forms.\n822                 row_data = (\n823                     field if field in self.unique_fields else form.cleaned_data[field]\n824                     for field in unique_check\n825                     if field in form.cleaned_data\n826                 )\n827                 # Reduce Model instances to their primary key values\n828                 row_data = tuple(\n829                     d._get_pk_val() if hasattr(d, \"_get_pk_val\")\n830                     # Prevent \"unhashable type: list\" errors later on.\n831                     else tuple(d) if isinstance(d, list) else d\n832                     for d in row_data\n833                 )\n834                 if row_data and None not in row_data:\n835                     # if we've already seen it then we have a uniqueness failure\n836                     if row_data in seen_data:\n837                         # poke error messages into the right places and mark\n838                         # the form as invalid\n839                         errors.append(self.get_unique_error_message(unique_check))\n840                         form._errors[NON_FIELD_ERRORS] = self.error_class(\n841                             [self.get_form_error()],\n842                             renderer=self.renderer,\n843                         )\n844                         # Remove the data from the cleaned_data dict since it\n845                         # was invalid.\n846                         for field in unique_check:\n847                             if field in form.cleaned_data:\n848                                 del form.cleaned_data[field]\n849                     # mark the data as seen\n850                     seen_data.add(row_data)\n851         # iterate over each of the date checks now\n852         for date_check in all_date_checks:\n853             seen_data = set()\n854             uclass, lookup, field, unique_for = date_check\n855             for form in valid_forms:\n856                 # see if we have data for both fields\n857                 if (\n858                     form.cleaned_data\n859                     and form.cleaned_data[field] is not None\n860                     and form.cleaned_data[unique_for] is not None\n861                 ):\n862                     # if it's a date lookup we need to get the data for all the fields\n863                     if lookup == \"date\":\n864                         date = form.cleaned_data[unique_for]\n865                         date_data = (date.year, date.month, date.day)\n866                     # otherwise it's just the attribute on the date/datetime\n867                     # object\n868                     else:\n869                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)\n870                     data = (form.cleaned_data[field],) + date_data\n871                     # if we've already seen it then we have a uniqueness failure\n872                     if data in seen_data:\n873                         # poke error messages into the right places and mark\n874                         # the form as invalid\n875                         errors.append(self.get_date_error_message(date_check))\n876                         form._errors[NON_FIELD_ERRORS] = self.error_class(\n877                             [self.get_form_error()],\n878                             renderer=self.renderer,\n879                         )\n880                         # Remove the data from the cleaned_data dict since it\n881                         # was invalid.\n882                         del form.cleaned_data[field]\n883                     # mark the data as seen\n884                     seen_data.add(data)\n885 \n886         if errors:\n887             raise ValidationError(errors)\n888 \n889     def get_unique_error_message(self, unique_check):\n890         if len(unique_check) == 1:\n891             return gettext(\"Please correct the duplicate data for %(field)s.\") % {\n892                 \"field\": unique_check[0],\n893             }\n894         else:\n895             return gettext(\n896                 \"Please correct the duplicate data for %(field)s, which must be unique.\"\n897             ) % {\n898                 \"field\": get_text_list(unique_check, _(\"and\")),\n899             }\n900 \n901     def get_date_error_message(self, date_check):\n902         return gettext(\n903             \"Please correct the duplicate data for %(field_name)s \"\n904             \"which must be unique for the %(lookup)s in %(date_field)s.\"\n905         ) % {\n906             \"field_name\": date_check[2],\n907             \"date_field\": date_check[3],\n908             \"lookup\": str(date_check[1]),\n909         }\n910 \n911     def get_form_error(self):\n912         return gettext(\"Please correct the duplicate values below.\")\n913 \n914     def save_existing_objects(self, commit=True):\n915         self.changed_objects = []\n916         self.deleted_objects = []\n917         if not self.initial_forms:\n918             return []\n919 \n920         saved_instances = []\n921         forms_to_delete = self.deleted_forms\n922         for form in self.initial_forms:\n923             obj = form.instance\n924             # If the pk is None, it means either:\n925             # 1. The object is an unexpected empty model, created by invalid\n926             #    POST data such as an object outside the formset's queryset.\n927             # 2. The object was already deleted from the database.\n928             if obj.pk is None:\n929                 continue\n930             if form in forms_to_delete:\n931                 self.deleted_objects.append(obj)\n932                 self.delete_existing(obj, commit=commit)\n933             elif form.has_changed():\n934                 self.changed_objects.append((obj, form.changed_data))\n935                 saved_instances.append(self.save_existing(form, obj, commit=commit))\n936                 if not commit:\n937                     self.saved_forms.append(form)\n938         return saved_instances\n939 \n940     def save_new_objects(self, commit=True):\n941         self.new_objects = []\n942         for form in self.extra_forms:\n943             if not form.has_changed():\n944                 continue\n945             # If someone has marked an add form for deletion, don't save the\n946             # object.\n947             if self.can_delete and self._should_delete_form(form):\n948                 continue\n949             self.new_objects.append(self.save_new(form, commit=commit))\n950             if not commit:\n951                 self.saved_forms.append(form)\n952         return self.new_objects\n953 \n954     def add_fields(self, form, index):\n955         \"\"\"Add a hidden field for the object's primary key.\"\"\"\n956         from django.db.models import AutoField, ForeignKey, OneToOneField\n957 \n958         self._pk_field = pk = self.model._meta.pk\n959         # If a pk isn't editable, then it won't be on the form, so we need to\n960         # add it here so we can tell which object is which when we get the\n961         # data back. Generally, pk.editable should be false, but for some\n962         # reason, auto_created pk fields and AutoField's editable attribute is\n963         # True, so check for that as well.\n964 \n965         def pk_is_not_editable(pk):\n966             return (\n967                 (not pk.editable)\n968                 or (pk.auto_created or isinstance(pk, AutoField))\n969                 or (\n970                     pk.remote_field\n971                     and pk.remote_field.parent_link\n972                     and pk_is_not_editable(pk.remote_field.model._meta.pk)\n973                 )\n974             )\n975 \n976         if pk_is_not_editable(pk) or pk.name not in form.fields:\n977             if form.is_bound:\n978                 # If we're adding the related instance, ignore its primary key\n979                 # as it could be an auto-generated default which isn't actually\n980                 # in the database.\n981                 pk_value = None if form.instance._state.adding else form.instance.pk\n982             else:\n983                 try:\n984                     if index is not None:\n985                         pk_value = self.get_queryset()[index].pk\n986                     else:\n987                         pk_value = None\n988                 except IndexError:\n989                     pk_value = None\n990             if isinstance(pk, (ForeignKey, OneToOneField)):\n991                 qs = pk.remote_field.model._default_manager.get_queryset()\n992             else:\n993                 qs = self.model._default_manager.get_queryset()\n994             qs = qs.using(form.instance._state.db)\n995             if form._meta.widgets:\n996                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)\n997             else:\n998                 widget = HiddenInput\n999             form.fields[self._pk_field.name] = ModelChoiceField(\n1000                 qs, initial=pk_value, required=False, widget=widget\n1001             )\n1002         super().add_fields(form, index)\n1003 \n1004 \n1005 def modelformset_factory(\n1006     model,\n1007     form=ModelForm,\n1008     formfield_callback=None,\n1009     formset=BaseModelFormSet,\n1010     extra=1,\n1011     can_delete=False,\n1012     can_order=False,\n1013     max_num=None,\n1014     fields=None,\n1015     exclude=None,\n1016     widgets=None,\n1017     validate_max=False,\n1018     localized_fields=None,\n1019     labels=None,\n1020     help_texts=None,\n1021     error_messages=None,\n1022     min_num=None,\n1023     validate_min=False,\n1024     field_classes=None,\n1025     absolute_max=None,\n1026     can_delete_extra=True,\n1027     renderer=None,\n1028     edit_only=False,\n1029 ):\n1030     \"\"\"Return a FormSet class for the given Django model class.\"\"\"\n1031     meta = getattr(form, \"Meta\", None)\n1032     if (\n1033         getattr(meta, \"fields\", fields) is None\n1034         and getattr(meta, \"exclude\", exclude) is None\n1035     ):\n1036         raise ImproperlyConfigured(\n1037             \"Calling modelformset_factory without defining 'fields' or \"\n1038             \"'exclude' explicitly is prohibited.\"\n1039         )\n1040 \n1041     form = modelform_factory(\n1042         model,\n1043         form=form,\n1044         fields=fields,\n1045         exclude=exclude,\n1046         formfield_callback=formfield_callback,\n1047         widgets=widgets,\n1048         localized_fields=localized_fields,\n1049         labels=labels,\n1050         help_texts=help_texts,\n1051         error_messages=error_messages,\n1052         field_classes=field_classes,\n1053     )\n1054     FormSet = formset_factory(\n1055         form,\n1056         formset,\n1057         extra=extra,\n1058         min_num=min_num,\n1059         max_num=max_num,\n1060         can_order=can_order,\n1061         can_delete=can_delete,\n1062         validate_min=validate_min,\n1063         validate_max=validate_max,\n1064         absolute_max=absolute_max,\n1065         can_delete_extra=can_delete_extra,\n1066         renderer=renderer,\n1067     )\n1068     FormSet.model = model\n1069     FormSet.edit_only = edit_only\n1070     return FormSet\n1071 \n1072 \n1073 # InlineFormSets #############################################################\n1074 \n1075 \n1076 class BaseInlineFormSet(BaseModelFormSet):\n1077     \"\"\"A formset for child objects related to a parent.\"\"\"\n1078 \n1079     def __init__(\n1080         self,\n1081         data=None,\n1082         files=None,\n1083         instance=None,\n1084         save_as_new=False,\n1085         prefix=None,\n1086         queryset=None,\n1087         **kwargs,\n1088     ):\n1089         if instance is None:\n1090             self.instance = self.fk.remote_field.model()\n1091         else:\n1092             self.instance = instance\n1093         self.save_as_new = save_as_new\n1094         if queryset is None:\n1095             queryset = self.model._default_manager\n1096         if self.instance.pk is not None:\n1097             qs = queryset.filter(**{self.fk.name: self.instance})\n1098         else:\n1099             qs = queryset.none()\n1100         self.unique_fields = {self.fk.name}\n1101         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n1102 \n1103         # Add the generated field to form._meta.fields if it's defined to make\n1104         # sure validation isn't skipped on that field.\n1105         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:\n1106             if isinstance(self.form._meta.fields, tuple):\n1107                 self.form._meta.fields = list(self.form._meta.fields)\n1108             self.form._meta.fields.append(self.fk.name)\n1109 \n1110     def initial_form_count(self):\n1111         if self.save_as_new:\n1112             return 0\n1113         return super().initial_form_count()\n1114 \n1115     def _construct_form(self, i, **kwargs):\n1116         form = super()._construct_form(i, **kwargs)\n1117         if self.save_as_new:\n1118             mutable = getattr(form.data, \"_mutable\", None)\n1119             # Allow modifying an immutable QueryDict.\n1120             if mutable is not None:\n1121                 form.data._mutable = True\n1122             # Remove the primary key from the form's data, we are only\n1123             # creating new instances\n1124             form.data[form.add_prefix(self._pk_field.name)] = None\n1125             # Remove the foreign key from the form's data\n1126             form.data[form.add_prefix(self.fk.name)] = None\n1127             if mutable is not None:\n1128                 form.data._mutable = mutable\n1129 \n1130         # Set the fk value here so that the form can do its validation.\n1131         fk_value = self.instance.pk\n1132         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n1133             fk_value = getattr(self.instance, self.fk.remote_field.field_name)\n1134             fk_value = getattr(fk_value, \"pk\", fk_value)\n1135         setattr(form.instance, self.fk.get_attname(), fk_value)\n1136         return form\n1137 \n1138     @classmethod\n1139     def get_default_prefix(cls):\n1140         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace(\"+\", \"\")\n1141 \n1142     def save_new(self, form, commit=True):\n1143         # Ensure the latest copy of the related instance is present on each\n1144         # form (it may have been saved after the formset was originally\n1145         # instantiated).\n1146         setattr(form.instance, self.fk.name, self.instance)\n1147         return super().save_new(form, commit=commit)\n1148 \n1149     def add_fields(self, form, index):\n1150         super().add_fields(form, index)\n1151         if self._pk_field == self.fk:\n1152             name = self._pk_field.name\n1153             kwargs = {\"pk_field\": True}\n1154         else:\n1155             # The foreign key field might not be on the form, so we poke at the\n1156             # Model field to get the label, since we need that for error messages.\n1157             name = self.fk.name\n1158             kwargs = {\n1159                 \"label\": getattr(\n1160                     form.fields.get(name), \"label\", capfirst(self.fk.verbose_name)\n1161                 )\n1162             }\n1163 \n1164         # The InlineForeignKeyField assumes that the foreign key relation is\n1165         # based on the parent model's pk. If this isn't the case, set to_field\n1166         # to correctly resolve the initial form value.\n1167         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n1168             kwargs[\"to_field\"] = self.fk.remote_field.field_name\n1169 \n1170         # If we're adding a new object, ignore a parent's auto-generated key\n1171         # as it will be regenerated on the save request.\n1172         if self.instance._state.adding:\n1173             if kwargs.get(\"to_field\") is not None:\n1174                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n1175             else:\n1176                 to_field = self.instance._meta.pk\n1177             if to_field.has_default():\n1178                 setattr(self.instance, to_field.attname, None)\n1179 \n1180         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n1181 \n1182     def get_unique_error_message(self, unique_check):\n1183         unique_check = [field for field in unique_check if field != self.fk.name]\n1184         return super().get_unique_error_message(unique_check)\n1185 \n1186 \n1187 def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\n1188     \"\"\"\n1189     Find and return the ForeignKey from model to parent if there is one\n1190     (return None if can_fail is True and no such field exists). If fk_name is\n1191     provided, assume it is the name of the ForeignKey field. Unless can_fail is\n1192     True, raise an exception if there isn't a ForeignKey from model to\n1193     parent_model.\n1194     \"\"\"\n1195     # avoid circular import\n1196     from django.db.models import ForeignKey\n1197 \n1198     opts = model._meta\n1199     if fk_name:\n1200         fks_to_parent = [f for f in opts.fields if f.name == fk_name]\n1201         if len(fks_to_parent) == 1:\n1202             fk = fks_to_parent[0]\n1203             parent_list = parent_model._meta.get_parent_list()\n1204             if (\n1205                 not isinstance(fk, ForeignKey)\n1206                 or (\n1207                     # ForeignKey to proxy models.\n1208                     fk.remote_field.model._meta.proxy\n1209                     and fk.remote_field.model._meta.proxy_for_model not in parent_list\n1210                 )\n1211                 or (\n1212                     # ForeignKey to concrete models.\n1213                     not fk.remote_field.model._meta.proxy\n1214                     and fk.remote_field.model != parent_model\n1215                     and fk.remote_field.model not in parent_list\n1216                 )\n1217             ):\n1218                 raise ValueError(\n1219                     \"fk_name '%s' is not a ForeignKey to '%s'.\"\n1220                     % (fk_name, parent_model._meta.label)\n1221                 )\n1222         elif not fks_to_parent:\n1223             raise ValueError(\n1224                 \"'%s' has no field named '%s'.\" % (model._meta.label, fk_name)\n1225             )\n1226     else:\n1227         # Try to discover what the ForeignKey from model to parent_model is\n1228         parent_list = parent_model._meta.get_parent_list()\n1229         fks_to_parent = [\n1230             f\n1231             for f in opts.fields\n1232             if isinstance(f, ForeignKey)\n1233             and (\n1234                 f.remote_field.model == parent_model\n1235                 or f.remote_field.model in parent_list\n1236                 or (\n1237                     f.remote_field.model._meta.proxy\n1238                     and f.remote_field.model._meta.proxy_for_model in parent_list\n1239                 )\n1240             )\n1241         ]\n1242         if len(fks_to_parent) == 1:\n1243             fk = fks_to_parent[0]\n1244         elif not fks_to_parent:\n1245             if can_fail:\n1246                 return\n1247             raise ValueError(\n1248                 \"'%s' has no ForeignKey to '%s'.\"\n1249                 % (\n1250                     model._meta.label,\n1251                     parent_model._meta.label,\n1252                 )\n1253             )\n1254         else:\n1255             raise ValueError(\n1256                 \"'%s' has more than one ForeignKey to '%s'. You must specify \"\n1257                 \"a 'fk_name' attribute.\"\n1258                 % (\n1259                     model._meta.label,\n1260                     parent_model._meta.label,\n1261                 )\n1262             )\n1263     return fk\n1264 \n1265 \n1266 def inlineformset_factory(\n1267     parent_model,\n1268     model,\n1269     form=ModelForm,\n1270     formset=BaseInlineFormSet,\n1271     fk_name=None,\n1272     fields=None,\n1273     exclude=None,\n1274     extra=3,\n1275     can_order=False,\n1276     can_delete=True,\n1277     max_num=None,\n1278     formfield_callback=None,\n1279     widgets=None,\n1280     validate_max=False,\n1281     localized_fields=None,\n1282     labels=None,\n1283     help_texts=None,\n1284     error_messages=None,\n1285     min_num=None,\n1286     validate_min=False,\n1287     field_classes=None,\n1288     absolute_max=None,\n1289     can_delete_extra=True,\n1290     renderer=None,\n1291     edit_only=False,\n1292 ):\n1293     \"\"\"\n1294     Return an ``InlineFormSet`` for the given kwargs.\n1295 \n1296     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``\n1297     to ``parent_model``.\n1298     \"\"\"\n1299     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)\n1300     # enforce a max_num=1 when the foreign key to the parent model is unique.\n1301     if fk.unique:\n1302         max_num = 1\n1303     kwargs = {\n1304         \"form\": form,\n1305         \"formfield_callback\": formfield_callback,\n1306         \"formset\": formset,\n1307         \"extra\": extra,\n1308         \"can_delete\": can_delete,\n1309         \"can_order\": can_order,\n1310         \"fields\": fields,\n1311         \"exclude\": exclude,\n1312         \"min_num\": min_num,\n1313         \"max_num\": max_num,\n1314         \"widgets\": widgets,\n1315         \"validate_min\": validate_min,\n1316         \"validate_max\": validate_max,\n1317         \"localized_fields\": localized_fields,\n1318         \"labels\": labels,\n1319         \"help_texts\": help_texts,\n1320         \"error_messages\": error_messages,\n1321         \"field_classes\": field_classes,\n1322         \"absolute_max\": absolute_max,\n1323         \"can_delete_extra\": can_delete_extra,\n1324         \"renderer\": renderer,\n1325         \"edit_only\": edit_only,\n1326     }\n1327     FormSet = modelformset_factory(model, **kwargs)\n1328     FormSet.fk = fk\n1329     return FormSet\n1330 \n1331 \n1332 # Fields #####################################################################\n1333 \n1334 \n1335 class InlineForeignKeyField(Field):\n1336     \"\"\"\n1337     A basic integer field that deals with validating the given value to a\n1338     given parent instance in an inline.\n1339     \"\"\"\n1340 \n1341     widget = HiddenInput\n1342     default_error_messages = {\n1343         \"invalid_choice\": _(\"The inline value did not match the parent instance.\"),\n1344     }\n1345 \n1346     def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):\n1347         self.parent_instance = parent_instance\n1348         self.pk_field = pk_field\n1349         self.to_field = to_field\n1350         if self.parent_instance is not None:\n1351             if self.to_field:\n1352                 kwargs[\"initial\"] = getattr(self.parent_instance, self.to_field)\n1353             else:\n1354                 kwargs[\"initial\"] = self.parent_instance.pk\n1355         kwargs[\"required\"] = False\n1356         super().__init__(*args, **kwargs)\n1357 \n1358     def clean(self, value):\n1359         if value in self.empty_values:\n1360             if self.pk_field:\n1361                 return None\n1362             # if there is no value act as we did before.\n1363             return self.parent_instance\n1364         # ensure the we compare the values as equal types.\n1365         if self.to_field:\n1366             orig = getattr(self.parent_instance, self.to_field)\n1367         else:\n1368             orig = self.parent_instance.pk\n1369         if str(value) != str(orig):\n1370             raise ValidationError(\n1371                 self.error_messages[\"invalid_choice\"], code=\"invalid_choice\"\n1372             )\n1373         return self.parent_instance\n1374 \n1375     def has_changed(self, initial, data):\n1376         return False\n1377 \n1378 \n1379 class ModelChoiceIteratorValue:\n1380     def __init__(self, value, instance):\n1381         self.value = value\n1382         self.instance = instance\n1383 \n1384     def __str__(self):\n1385         return str(self.value)\n1386 \n1387     def __hash__(self):\n1388         return hash(self.value)\n1389 \n1390     def __eq__(self, other):\n1391         if isinstance(other, ModelChoiceIteratorValue):\n1392             other = other.value\n1393         return self.value == other\n1394 \n1395 \n1396 class ModelChoiceIterator:\n1397     def __init__(self, field):\n1398         self.field = field\n1399         self.queryset = field.queryset\n1400 \n1401     def __iter__(self):\n1402         if self.field.empty_label is not None:\n1403             yield (\"\", self.field.empty_label)\n1404         queryset = self.queryset\n1405         # Can't use iterator() when queryset uses prefetch_related()\n1406         if not queryset._prefetch_related_lookups:\n1407             queryset = queryset.iterator()\n1408         for obj in queryset:\n1409             yield self.choice(obj)\n1410 \n1411     def __len__(self):\n1412         # count() adds a query but uses less memory since the QuerySet results\n1413         # won't be cached. In most cases, the choices will only be iterated on,\n1414         # and __len__() won't be called.\n1415         return self.queryset.count() + (1 if self.field.empty_label is not None else 0)\n1416 \n1417     def __bool__(self):\n1418         return self.field.empty_label is not None or self.queryset.exists()\n1419 \n1420     def choice(self, obj):\n1421         return (\n1422             ModelChoiceIteratorValue(self.field.prepare_value(obj), obj),\n1423             self.field.label_from_instance(obj),\n1424         )\n1425 \n1426 \n1427 class ModelChoiceField(ChoiceField):\n1428     \"\"\"A ChoiceField whose choices are a model QuerySet.\"\"\"\n1429 \n1430     # This class is a subclass of ChoiceField for purity, but it doesn't\n1431     # actually use any of ChoiceField's implementation.\n1432     default_error_messages = {\n1433         \"invalid_choice\": _(\n1434             \"Select a valid choice. That choice is not one of the available choices.\"\n1435         ),\n1436     }\n1437     iterator = ModelChoiceIterator\n1438 \n1439     def __init__(\n1440         self,\n1441         queryset,\n1442         *,\n1443         empty_label=\"---------\",\n1444         required=True,\n1445         widget=None,\n1446         label=None,\n1447         initial=None,\n1448         help_text=\"\",\n1449         to_field_name=None,\n1450         limit_choices_to=None,\n1451         blank=False,\n1452         **kwargs,\n1453     ):\n1454         # Call Field instead of ChoiceField __init__() because we don't need\n1455         # ChoiceField.__init__().\n1456         Field.__init__(\n1457             self,\n1458             required=required,\n1459             widget=widget,\n1460             label=label,\n1461             initial=initial,\n1462             help_text=help_text,\n1463             **kwargs,\n1464         )\n1465         if (required and initial is not None) or (\n1466             isinstance(self.widget, RadioSelect) and not blank\n1467         ):\n1468             self.empty_label = None\n1469         else:\n1470             self.empty_label = empty_label\n1471         self.queryset = queryset\n1472         self.limit_choices_to = limit_choices_to  # limit the queryset later.\n1473         self.to_field_name = to_field_name\n1474 \n1475     def get_limit_choices_to(self):\n1476         \"\"\"\n1477         Return ``limit_choices_to`` for this form field.\n1478 \n1479         If it is a callable, invoke it and return the result.\n1480         \"\"\"\n1481         if callable(self.limit_choices_to):\n1482             return self.limit_choices_to()\n1483         return self.limit_choices_to\n1484 \n1485     def __deepcopy__(self, memo):\n1486         result = super(ChoiceField, self).__deepcopy__(memo)\n1487         # Need to force a new ModelChoiceIterator to be created, bug #11183\n1488         if self.queryset is not None:\n1489             result.queryset = self.queryset.all()\n1490         return result\n1491 \n1492     def _get_queryset(self):\n1493         return self._queryset\n1494 \n1495     def _set_queryset(self, queryset):\n1496         self._queryset = None if queryset is None else queryset.all()\n1497         self.widget.choices = self.choices\n1498 \n1499     queryset = property(_get_queryset, _set_queryset)\n1500 \n1501     # this method will be used to create object labels by the QuerySetIterator.\n1502     # Override it to customize the label.\n1503     def label_from_instance(self, obj):\n1504         \"\"\"\n1505         Convert objects into strings and generate the labels for the choices\n1506         presented by this object. Subclasses can override this method to\n1507         customize the display of the choices.\n1508         \"\"\"\n1509         return str(obj)\n1510 \n1511     def _get_choices(self):\n1512         # If self._choices is set, then somebody must have manually set\n1513         # the property self.choices. In this case, just return self._choices.\n1514         if hasattr(self, \"_choices\"):\n1515             return self._choices\n1516 \n1517         # Otherwise, execute the QuerySet in self.queryset to determine the\n1518         # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n1519         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n1520         # time _get_choices() is called (and, thus, each time self.choices is\n1521         # accessed) so that we can ensure the QuerySet has not been consumed. This\n1522         # construct might look complicated but it allows for lazy evaluation of\n1523         # the queryset.\n1524         return self.iterator(self)\n1525 \n1526     choices = property(_get_choices, ChoiceField._set_choices)\n1527 \n1528     def prepare_value(self, value):\n1529         if hasattr(value, \"_meta\"):\n1530             if self.to_field_name:\n1531                 return value.serializable_value(self.to_field_name)\n1532             else:\n1533                 return value.pk\n1534         return super().prepare_value(value)\n1535 \n1536     def to_python(self, value):\n1537         if value in self.empty_values:\n1538             return None\n1539         try:\n1540             key = self.to_field_name or \"pk\"\n1541             if isinstance(value, self.queryset.model):\n1542                 value = getattr(value, key)\n1543             value = self.queryset.get(**{key: value})\n1544         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n1545             raise ValidationError(\n1546                 self.error_messages[\"invalid_choice\"],\n1547                 code=\"invalid_choice\",\n1548                 params={\"value\": value},\n1549             )\n1550         return value\n1551 \n1552     def validate(self, value):\n1553         return Field.validate(self, value)\n1554 \n1555     def has_changed(self, initial, data):\n1556         if self.disabled:\n1557             return False\n1558         initial_value = initial if initial is not None else \"\"\n1559         data_value = data if data is not None else \"\"\n1560         return str(self.prepare_value(initial_value)) != str(data_value)\n1561 \n1562 \n1563 class ModelMultipleChoiceField(ModelChoiceField):\n1564     \"\"\"A MultipleChoiceField whose choices are a model QuerySet.\"\"\"\n1565 \n1566     widget = SelectMultiple\n1567     hidden_widget = MultipleHiddenInput\n1568     default_error_messages = {\n1569         \"invalid_list\": _(\"Enter a list of values.\"),\n1570         \"invalid_choice\": _(\n1571             \"Select a valid choice. %(value)s is not one of the available choices.\"\n1572         ),\n1573         \"invalid_pk_value\": _(\"\u201c%(pk)s\u201d is not a valid value.\"),\n1574     }\n1575 \n1576     def __init__(self, queryset, **kwargs):\n1577         super().__init__(queryset, empty_label=None, **kwargs)\n1578 \n1579     def to_python(self, value):\n1580         if not value:\n1581             return []\n1582         return list(self._check_values(value))\n1583 \n1584     def clean(self, value):\n1585         value = self.prepare_value(value)\n1586         if self.required and not value:\n1587             raise ValidationError(self.error_messages[\"required\"], code=\"required\")\n1588         elif not self.required and not value:\n1589             return self.queryset.none()\n1590         if not isinstance(value, (list, tuple)):\n1591             raise ValidationError(\n1592                 self.error_messages[\"invalid_list\"],\n1593                 code=\"invalid_list\",\n1594             )\n1595         qs = self._check_values(value)\n1596         # Since this overrides the inherited ModelChoiceField.clean\n1597         # we run custom validators here\n1598         self.run_validators(value)\n1599         return qs\n1600 \n1601     def _check_values(self, value):\n1602         \"\"\"\n1603         Given a list of possible PK values, return a QuerySet of the\n1604         corresponding objects. Raise a ValidationError if a given value is\n1605         invalid (not a valid PK, not in the queryset, etc.)\n1606         \"\"\"\n1607         key = self.to_field_name or \"pk\"\n1608         # deduplicate given values to avoid creating many querysets or\n1609         # requiring the database backend deduplicate efficiently.\n1610         try:\n1611             value = frozenset(value)\n1612         except TypeError:\n1613             # list of lists isn't hashable, for example\n1614             raise ValidationError(\n1615                 self.error_messages[\"invalid_list\"],\n1616                 code=\"invalid_list\",\n1617             )\n1618         for pk in value:\n1619             try:\n1620                 self.queryset.filter(**{key: pk})\n1621             except (ValueError, TypeError):\n1622                 raise ValidationError(\n1623                     self.error_messages[\"invalid_pk_value\"],\n1624                     code=\"invalid_pk_value\",\n1625                     params={\"pk\": pk},\n1626                 )\n1627         qs = self.queryset.filter(**{\"%s__in\" % key: value})\n1628         pks = {str(getattr(o, key)) for o in qs}\n1629         for val in value:\n1630             if str(val) not in pks:\n1631                 raise ValidationError(\n1632                     self.error_messages[\"invalid_choice\"],\n1633                     code=\"invalid_choice\",\n1634                     params={\"value\": val},\n1635                 )\n1636         return qs\n1637 \n1638     def prepare_value(self, value):\n1639         if (\n1640             hasattr(value, \"__iter__\")\n1641             and not isinstance(value, str)\n1642             and not hasattr(value, \"_meta\")\n1643         ):\n1644             prepare_value = super().prepare_value\n1645             return [prepare_value(v) for v in value]\n1646         return super().prepare_value(value)\n1647 \n1648     def has_changed(self, initial, data):\n1649         if self.disabled:\n1650             return False\n1651         if initial is None:\n1652             initial = []\n1653         if data is None:\n1654             data = []\n1655         if len(initial) != len(data):\n1656             return True\n1657         initial_set = {str(value) for value in self.prepare_value(initial)}\n1658         data_set = {str(value) for value in data}\n1659         return data_set != initial_set\n1660 \n1661 \n1662 def modelform_defines_fields(form_class):\n1663     return hasattr(form_class, \"_meta\") and (\n1664         form_class._meta.fields is not None or form_class._meta.exclude is not None\n1665     )\n",
        "intended_behavior": "Before initiating migrations that would change field types or relationships significantly, ensuring that constraints like `unique_together` are reviewed and, if necessary, programmatically addressed (either through model Meta options or direct migration operations) to match the new model relationships and structures being implemented."
    }
]