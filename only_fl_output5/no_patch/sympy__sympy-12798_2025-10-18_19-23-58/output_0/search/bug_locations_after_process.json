[
    {
        "rel_file_path": "sympy/functions/combinatorial/factorials.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/combinatorial/factorials.py",
        "start": 1,
        "end": 873,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.core import S, sympify, Dummy, Mod\n4 from sympy.core.function import Function, ArgumentIndexError\n5 from sympy.core.logic import fuzzy_and\n6 from sympy.core.numbers import Integer, pi\n7 from sympy.core.relational import Eq\n8 \n9 from sympy.ntheory import sieve\n10 \n11 from math import sqrt as _sqrt\n12 \n13 from sympy.core.compatibility import reduce, range, HAS_GMPY\n14 from sympy.core.cache import cacheit\n15 \n16 from sympy.polys.polytools import poly_from_expr\n17 from sympy.polys.polyerrors import PolificationFailed\n18 \n19 \n20 class CombinatorialFunction(Function):\n21     \"\"\"Base class for combinatorial functions. \"\"\"\n22 \n23     def _eval_simplify(self, ratio, measure):\n24         from sympy.simplify.simplify import combsimp\n25         expr = combsimp(self)\n26         if measure(expr) <= ratio*measure(self):\n27             return expr\n28         return self\n29 \n30 ###############################################################################\n31 ######################## FACTORIAL and MULTI-FACTORIAL ########################\n32 ###############################################################################\n33 \n34 \n35 class factorial(CombinatorialFunction):\n36     \"\"\"Implementation of factorial function over nonnegative integers.\n37        By convention (consistent with the gamma function and the binomial\n38        coefficients), factorial of a negative integer is complex infinity.\n39 \n40        The factorial is very important in combinatorics where it gives\n41        the number of ways in which `n` objects can be permuted. It also\n42        arises in calculus, probability, number theory, etc.\n43 \n44        There is strict relation of factorial with gamma function. In\n45        fact n! = gamma(n+1) for nonnegative integers. Rewrite of this\n46        kind is very useful in case of combinatorial simplification.\n47 \n48        Computation of the factorial is done using two algorithms. For\n49        small arguments a precomputed look up table is used. However for bigger\n50        input algorithm Prime-Swing is used. It is the fastest algorithm\n51        known and computes n! via prime factorization of special class\n52        of numbers, called here the 'Swing Numbers'.\n53 \n54        Examples\n55        ========\n56 \n57        >>> from sympy import Symbol, factorial, S\n58        >>> n = Symbol('n', integer=True)\n59 \n60        >>> factorial(0)\n61        1\n62 \n63        >>> factorial(7)\n64        5040\n65 \n66        >>> factorial(-2)\n67        zoo\n68 \n69        >>> factorial(n)\n70        factorial(n)\n71 \n72        >>> factorial(2*n)\n73        factorial(2*n)\n74 \n75        >>> factorial(S(1)/2)\n76        factorial(1/2)\n77 \n78        See Also\n79        ========\n80 \n81        factorial2, RisingFactorial, FallingFactorial\n82     \"\"\"\n83 \n84     def fdiff(self, argindex=1):\n85         from sympy import gamma, polygamma\n86         if argindex == 1:\n87             return gamma(self.args[0] + 1)*polygamma(0, self.args[0] + 1)\n88         else:\n89             raise ArgumentIndexError(self, argindex)\n90 \n91     _small_swing = [\n92         1, 1, 1, 3, 3, 15, 5, 35, 35, 315, 63, 693, 231, 3003, 429, 6435, 6435, 109395,\n93         12155, 230945, 46189, 969969, 88179, 2028117, 676039, 16900975, 1300075,\n94         35102025, 5014575, 145422675, 9694845, 300540195, 300540195\n95     ]\n96 \n97     _small_factorials = []\n98 \n99     @classmethod\n100     def _swing(cls, n):\n101         if n < 33:\n102             return cls._small_swing[n]\n103         else:\n104             N, primes = int(_sqrt(n)), []\n105 \n106             for prime in sieve.primerange(3, N + 1):\n107                 p, q = 1, n\n108 \n109                 while True:\n110                     q //= prime\n111 \n112                     if q > 0:\n113                         if q & 1 == 1:\n114                             p *= prime\n115                     else:\n116                         break\n117 \n118                 if p > 1:\n119                     primes.append(p)\n120 \n121             for prime in sieve.primerange(N + 1, n//3 + 1):\n122                 if (n // prime) & 1 == 1:\n123                     primes.append(prime)\n124 \n125             L_product = R_product = 1\n126 \n127             for prime in sieve.primerange(n//2 + 1, n + 1):\n128                 L_product *= prime\n129 \n130             for prime in primes:\n131                 R_product *= prime\n132 \n133             return L_product*R_product\n134 \n135     @classmethod\n136     def _recursive(cls, n):\n137         if n < 2:\n138             return 1\n139         else:\n140             return (cls._recursive(n//2)**2)*cls._swing(n)\n141 \n142     @classmethod\n143     def eval(cls, n):\n144         n = sympify(n)\n145 \n146         if n.is_Number:\n147             if n is S.Zero:\n148                 return S.One\n149             elif n is S.Infinity:\n150                 return S.Infinity\n151             elif n.is_Integer:\n152                 if n.is_negative:\n153                     return S.ComplexInfinity\n154                 else:\n155                     n = n.p\n156 \n157                     if n < 20:\n158                         if not cls._small_factorials:\n159                             result = 1\n160                             for i in range(1, 20):\n161                                 result *= i\n162                                 cls._small_factorials.append(result)\n163                         result = cls._small_factorials[n-1]\n164 \n165                     # GMPY factorial is faster, use it when available\n166                     elif HAS_GMPY:\n167                         from sympy.core.compatibility import gmpy\n168                         result = gmpy.fac(n)\n169 \n170                     else:\n171                         bits = bin(n).count('1')\n172                         result = cls._recursive(n)*2**(n - bits)\n173 \n174                     return Integer(result)\n175 \n176     def _eval_rewrite_as_gamma(self, n):\n177         from sympy import gamma\n178         return gamma(n + 1)\n179 \n180     def _eval_rewrite_as_Product(self, n):\n181         from sympy import Product\n182         if n.is_nonnegative and n.is_integer:\n183             i = Dummy('i', integer=True)\n184             return Product(i, (i, 1, n))\n185 \n186     def _eval_is_integer(self):\n187         if self.args[0].is_integer and self.args[0].is_nonnegative:\n188             return True\n189 \n190     def _eval_is_positive(self):\n191         if self.args[0].is_integer and self.args[0].is_nonnegative:\n192             return True\n193 \n194     def _eval_is_composite(self):\n195         x = self.args[0]\n196         if x.is_integer:\n197             return (x - 3).is_nonnegative\n198 \n199     def _eval_is_real(self):\n200         x = self.args[0]\n201         if x.is_nonnegative or x.is_noninteger:\n202             return True\n203 \n204 \n205 class MultiFactorial(CombinatorialFunction):\n206     pass\n207 \n208 \n209 class subfactorial(CombinatorialFunction):\n210     r\"\"\"The subfactorial counts the derangements of n items and is\n211     defined for non-negative integers as::\n212 \n213               ,\n214              |  1                             for n = 0\n215         !n = {  0                             for n = 1\n216              |  (n - 1)*(!(n - 1) + !(n - 2)) for n > 1\n217               `\n218 \n219     It can also be written as int(round(n!/exp(1))) but the recursive\n220     definition with caching is implemented for this function.\n221 \n222     An interesting analytic expression is the following [2]_\n223 \n224     .. math:: !x = \\Gamma(x + 1, -1)/e\n225 \n226     which is valid for non-negative integers x. The above formula\n227     is not very useful incase of non-integers. :math:`\\Gamma(x + 1, -1)` is\n228     single-valued only for integral arguments x, elsewhere on the positive real\n229     axis it has an infinite number of branches none of which are real.\n230 \n231     References\n232     ==========\n233 \n234     .. [1] http://en.wikipedia.org/wiki/Subfactorial\n235     .. [2] http://mathworld.wolfram.com/Subfactorial.html\n236 \n237     Examples\n238     ========\n239 \n240     >>> from sympy import subfactorial\n241     >>> from sympy.abc import n\n242     >>> subfactorial(n + 1)\n243     subfactorial(n + 1)\n244     >>> subfactorial(5)\n245     44\n246 \n247     See Also\n248     ========\n249 \n250     sympy.functions.combinatorial.factorials.factorial,\n251     sympy.utilities.iterables.generate_derangements,\n252     sympy.functions.special.gamma_functions.uppergamma\n253     \"\"\"\n254 \n255     @classmethod\n256     @cacheit\n257     def _eval(self, n):\n258         if not n:\n259             return S.One\n260         elif n == 1:\n261             return S.Zero\n262         return (n - 1)*(self._eval(n - 1) + self._eval(n - 2))\n263 \n264     @classmethod\n265     def eval(cls, arg):\n266         if arg.is_Number:\n267             if arg.is_Integer and arg.is_nonnegative:\n268                 return cls._eval(arg)\n269             elif arg is S.NaN:\n270                 return S.NaN\n271             elif arg is S.Infinity:\n272                 return S.Infinity\n273 \n274     def _eval_is_even(self):\n275         if self.args[0].is_odd and self.args[0].is_nonnegative:\n276             return True\n277 \n278     def _eval_is_integer(self):\n279         if self.args[0].is_integer and self.args[0].is_nonnegative:\n280             return True\n281 \n282     def _eval_rewrite_as_uppergamma(self, arg):\n283         from sympy import uppergamma\n284         return uppergamma(arg + 1, -1)/S.Exp1\n285 \n286     def _eval_is_nonnegative(self):\n287         if self.args[0].is_integer and self.args[0].is_nonnegative:\n288             return True\n289 \n290     def _eval_is_odd(self):\n291         if self.args[0].is_even and self.args[0].is_nonnegative:\n292             return True\n293 \n294 \n295 class factorial2(CombinatorialFunction):\n296     \"\"\"The double factorial n!!, not to be confused with (n!)!\n297 \n298     The double factorial is defined for nonnegative integers and for odd\n299     negative integers as::\n300 \n301                ,\n302               |  n*(n - 2)*(n - 4)* ... * 1    for n positive odd\n303         n!! = {  n*(n - 2)*(n - 4)* ... * 2    for n positive even\n304               |  1                             for n = 0\n305               |  (n+2)!! / (n+2)               for n negative odd\n306                `\n307 \n308     References\n309     ==========\n310     .. [1] https://en.wikipedia.org/wiki/Double_factorial\n311 \n312     Examples\n313     ========\n314 \n315     >>> from sympy import factorial2, var\n316     >>> var('n')\n317     n\n318     >>> factorial2(n + 1)\n319     factorial2(n + 1)\n320     >>> factorial2(5)\n321     15\n322     >>> factorial2(-1)\n323     1\n324     >>> factorial2(-5)\n325     1/3\n326 \n327     See Also\n328     ========\n329 \n330     factorial, RisingFactorial, FallingFactorial\n331     \"\"\"\n332 \n333     @classmethod\n334     def eval(cls, arg):\n335         # TODO: extend this to complex numbers?\n336 \n337         if arg.is_Number:\n338             if not arg.is_Integer:\n339                 raise ValueError(\"argument must be nonnegative integer or negative odd integer\")\n340 \n341             # This implementation is faster than the recursive one\n342             # It also avoids \"maximum recursion depth exceeded\" runtime error\n343             if arg.is_nonnegative:\n344                 if arg.is_even:\n345                     k = arg / 2\n346                     return 2 ** k * factorial(k)\n347                 return factorial(arg) / factorial2(arg - 1)\n348 \n349 \n350             if arg.is_odd:\n351                 return arg * (S.NegativeOne) ** ((1 - arg) / 2) / factorial2(-arg)\n352             raise ValueError(\"argument must be nonnegative integer or negative odd integer\")\n353 \n354 \n355     def _eval_is_even(self):\n356         # Double factorial is even for every positive even input\n357         n = self.args[0]\n358         if n.is_integer:\n359             if n.is_odd:\n360                 return False\n361             if n.is_even:\n362                 if n.is_positive:\n363                     return True\n364                 if n.is_zero:\n365                     return False\n366 \n367     def _eval_is_integer(self):\n368         # Double factorial is an integer for every nonnegative input, and for\n369         # -1 and -3\n370         n = self.args[0]\n371         if n.is_integer:\n372             if (n + 1).is_nonnegative:\n373                 return True\n374             if n.is_odd:\n375                 return (n + 3).is_nonnegative\n376 \n377     def _eval_is_odd(self):\n378         # Double factorial is odd for every odd input not smaller than -3, and\n379         # for 0\n380         n = self.args[0]\n381         if n.is_odd:\n382             return (n + 3).is_nonnegative\n383         if n.is_even:\n384             if n.is_positive:\n385                 return False\n386             if n.is_zero:\n387                 return True\n388 \n389     def _eval_is_positive(self):\n390         # Double factorial is positive for every nonnegative input, and for\n391         # every odd negative input which is of the form -1-4k for an\n392         # nonnegative integer k\n393         n = self.args[0]\n394         if n.is_integer:\n395             if (n + 1).is_nonnegative:\n396                 return True\n397             if n.is_odd:\n398                 return ((n + 1) / 2).is_even\n399 \n400     def _eval_rewrite_as_gamma(self, n):\n401         from sympy import gamma, Piecewise, sqrt\n402         return 2**(n/2)*gamma(n/2 + 1) * Piecewise((1, Eq(Mod(n, 2), 0)), (sqrt(2/pi), Eq(Mod(n, 2), 1)))\n403 \n404 \n405 ###############################################################################\n406 ######################## RISING and FALLING FACTORIALS ########################\n407 ###############################################################################\n408 \n409 \n410 class RisingFactorial(CombinatorialFunction):\n411     \"\"\"Rising factorial (also called Pochhammer symbol) is a double valued\n412     function arising in concrete mathematics, hypergeometric functions\n413     and series expansions. It is defined by:\n414 \n415                 rf(x, k) = x * (x + 1) * ... * (x + k - 1)\n416 \n417     where 'x' can be arbitrary expression and 'k' is an integer. For\n418     more information check \"Concrete mathematics\" by Graham, pp. 66\n419     or visit http://mathworld.wolfram.com/RisingFactorial.html page.\n420 \n421     When x is a polynomial f of a single variable y of order >= 1,\n422     rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in\n423     Peter Paule, \"Greatest Factorial Factorization and Symbolic Summation\",\n424     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.\n425 \n426     Examples\n427     ========\n428 \n429     >>> from sympy import rf, symbols, factorial, ff, binomial\n430     >>> from sympy.abc import x\n431     >>> n, k = symbols('n k', integer=True)\n432     >>> rf(x, 0)\n433     1\n434     >>> rf(1, 5)\n435     120\n436     >>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)\n437     True\n438     >>> rf(x**3, 2)\n439     Poly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')\n440 \n441     Rewrite\n442 \n443     >>> rf(x, k).rewrite(ff)\n444     FallingFactorial(k + x - 1, k)\n445     >>> rf(x, k).rewrite(binomial)\n446     binomial(k + x - 1, k)*factorial(k)\n447     >>> rf(n, k).rewrite(factorial)\n448     factorial(k + n - 1)/factorial(n - 1)\n449 \n450     See Also\n451     ========\n452 \n453     factorial, factorial2, FallingFactorial\n454 \n455     References\n456     ==========\n457 \n458     .. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol\n459     \"\"\"\n460 \n461     @classmethod\n462     def eval(cls, x, k):\n463         x = sympify(x)\n464         k = sympify(k)\n465 \n466         if x is S.NaN or k is S.NaN:\n467             return S.NaN\n468         elif x is S.One:\n469             return factorial(k)\n470         elif k.is_Integer:\n471             if k is S.Zero:\n472                 return S.One\n473             else:\n474                 if k.is_positive:\n475                     if x is S.Infinity:\n476                         return S.Infinity\n477                     elif x is S.NegativeInfinity:\n478                         if k.is_odd:\n479                             return S.NegativeInfinity\n480                         else:\n481                             return S.Infinity\n482                     else:\n483                         try:\n484                             F, opt = poly_from_expr(x)\n485                         except PolificationFailed:\n486                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)\n487                         if len(opt.gens) > 1 or F.degree() <= 1:\n488                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)\n489                         else:\n490                             v = opt.gens[0]\n491                             return reduce(lambda r, i:\n492                                           r*(F.subs(v, v + i).expand()),\n493                                           range(0, int(k)), 1)\n494                 else:\n495                     if x is S.Infinity:\n496                         return S.Infinity\n497                     elif x is S.NegativeInfinity:\n498                         return S.Infinity\n499                     else:\n500                         try:\n501                             F, opt = poly_from_expr(x)\n502                         except PolificationFailed:\n503                             return 1/reduce(lambda r, i:\n504                                             r*(x - i),\n505                                             range(1, abs(int(k)) + 1), 1)\n506                         if len(opt.gens) > 1 or F.degree() <= 1:\n507                             return 1/reduce(lambda r, i:\n508                                             r*(x - i),\n509                                             range(1, abs(int(k)) + 1), 1)\n510                         else:\n511                             v = opt.gens[0]\n512                             return 1/reduce(lambda r, i:\n513                                             r*(F.subs(v, v - i).expand()),\n514                                             range(1, abs(int(k)) + 1), 1)\n515 \n516     def _eval_rewrite_as_gamma(self, x, k):\n517         from sympy import gamma\n518         return gamma(x + k) / gamma(x)\n519 \n520     def _eval_rewrite_as_FallingFactorial(self, x, k):\n521         return FallingFactorial(x + k - 1, k)\n522 \n523     def _eval_rewrite_as_factorial(self, x, k):\n524         if x.is_integer and k.is_integer:\n525             return factorial(k + x - 1) / factorial(x - 1)\n526 \n527     def _eval_rewrite_as_binomial(self, x, k):\n528         if k.is_integer:\n529             return factorial(k) * binomial(x + k - 1, k)\n530 \n531     def _eval_is_integer(self):\n532         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,\n533                           self.args[1].is_nonnegative))\n534 \n535     def _sage_(self):\n536         import sage.all as sage\n537         return sage.rising_factorial(self.args[0]._sage_(), self.args[1]._sage_())\n538 \n539 \n540 class FallingFactorial(CombinatorialFunction):\n541     \"\"\"Falling factorial (related to rising factorial) is a double valued\n542     function arising in concrete mathematics, hypergeometric functions\n543     and series expansions. It is defined by\n544 \n545                 ff(x, k) = x * (x-1) * ... * (x - k+1)\n546 \n547     where 'x' can be arbitrary expression and 'k' is an integer. For\n548     more information check \"Concrete mathematics\" by Graham, pp. 66\n549     or visit http://mathworld.wolfram.com/FallingFactorial.html page.\n550 \n551     When x is a polynomial f of a single variable y of order >= 1,\n552     ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in\n553     Peter Paule, \"Greatest Factorial Factorization and Symbolic Summation\",\n554     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.\n555 \n556     >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols\n557     >>> from sympy.abc import x, k\n558     >>> n, m = symbols('n m', integer=True)\n559     >>> ff(x, 0)\n560     1\n561     >>> ff(5, 5)\n562     120\n563     >>> ff(x, 5) == x*(x-1)*(x-2)*(x-3)*(x-4)\n564     True\n565     >>> ff(x**2, 2)\n566     Poly(x**4 - 2*x**3 + x**2, x, domain='ZZ')\n567     >>> ff(n, n)\n568     factorial(n)\n569 \n570     Rewrite\n571 \n572     >>> ff(x, k).rewrite(gamma)\n573     (-1)**k*gamma(k - x)/gamma(-x)\n574     >>> ff(x, k).rewrite(rf)\n575     RisingFactorial(-k + x + 1, k)\n576     >>> ff(x, m).rewrite(binomial)\n577     binomial(x, m)*factorial(m)\n578     >>> ff(n, m).rewrite(factorial)\n579     factorial(n)/factorial(-m + n)\n580 \n581     See Also\n582     ========\n583 \n584     factorial, factorial2, RisingFactorial\n585 \n586     References\n587     ==========\n588 \n589     .. [1] http://mathworld.wolfram.com/FallingFactorial.html\n590     \"\"\"\n591 \n592     @classmethod\n593     def eval(cls, x, k):\n594         x = sympify(x)\n595         k = sympify(k)\n596 \n597         if x is S.NaN or k is S.NaN:\n598             return S.NaN\n599         elif k.is_integer and x == k:\n600             return factorial(x)\n601         elif k.is_Integer:\n602             if k is S.Zero:\n603                 return S.One\n604             else:\n605                 if k.is_positive:\n606                     if x is S.Infinity:\n607                         return S.Infinity\n608                     elif x is S.NegativeInfinity:\n609                         if k.is_odd:\n610                             return S.NegativeInfinity\n611                         else:\n612                             return S.Infinity\n613                     else:\n614                         try:\n615                             F, opt = poly_from_expr(x)\n616                         except PolificationFailed:\n617                             return reduce(lambda r, i: r*(x - i),\n618                                           range(0, int(k)), 1)\n619                         if len(opt.gens) > 1 or F.degree() <= 1:\n620                             return reduce(lambda r, i: r*(x - i),\n621                                           range(0, int(k)), 1)\n622                         else:\n623                             v = opt.gens[0]\n624                             return reduce(lambda r, i:\n625                                           r*(F.subs(v, v - i).expand()),\n626                                           range(0, int(k)), 1)\n627                 else:\n628                     if x is S.Infinity:\n629                         return S.Infinity\n630                     elif x is S.NegativeInfinity:\n631                         return S.Infinity\n632                     else:\n633                         try:\n634                             F, opt = poly_from_expr(x)\n635                         except PolificationFailed:\n636                             return 1/reduce(lambda r, i: r*(x + i),\n637                                             range(1, abs(int(k)) + 1), 1)\n638                         if len(opt.gens) > 1 or F.degree() <= 1:\n639                             return 1/reduce(lambda r, i: r*(x + i),\n640                                             range(1, abs(int(k)) + 1), 1)\n641                         else:\n642                             v = opt.gens[0]\n643                             return 1/reduce(lambda r, i:\n644                                             r*(F.subs(v, v + i).expand()),\n645                                             range(1, abs(int(k)) + 1), 1)\n646 \n647     def _eval_rewrite_as_gamma(self, x, k):\n648         from sympy import gamma\n649         return (-1)**k*gamma(k - x) / gamma(-x)\n650 \n651     def _eval_rewrite_as_RisingFactorial(self, x, k):\n652         return rf(x - k + 1, k)\n653 \n654     def _eval_rewrite_as_binomial(self, x, k):\n655         if k.is_integer:\n656             return factorial(k) * binomial(x, k)\n657 \n658     def _eval_rewrite_as_factorial(self, x, k):\n659         if x.is_integer and k.is_integer:\n660             return factorial(x) / factorial(x - k)\n661 \n662     def _eval_is_integer(self):\n663         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,\n664                           self.args[1].is_nonnegative))\n665 \n666     def _sage_(self):\n667         import sage.all as sage\n668         return sage.falling_factorial(self.args[0]._sage_(),\n669                                       self.args[1]._sage_())\n670 \n671 \n672 rf = RisingFactorial\n673 ff = FallingFactorial\n674 \n675 ###############################################################################\n676 ########################### BINOMIAL COEFFICIENTS #############################\n677 ###############################################################################\n678 \n679 \n680 class binomial(CombinatorialFunction):\n681     \"\"\"Implementation of the binomial coefficient. It can be defined\n682     in two ways depending on its desired interpretation:\n683 \n684         C(n,k) = n!/(k!(n-k)!)   or   C(n, k) = ff(n, k)/k!\n685 \n686     First, in a strict combinatorial sense it defines the\n687     number of ways we can choose 'k' elements from a set of\n688     'n' elements. In this case both arguments are nonnegative\n689     integers and binomial is computed using an efficient\n690     algorithm based on prime factorization.\n691 \n692     The other definition is generalization for arbitrary 'n',\n693     however 'k' must also be nonnegative. This case is very\n694     useful when evaluating summations.\n695 \n696     For the sake of convenience for negative 'k' this function\n697     will return zero no matter what valued is the other argument.\n698 \n699     To expand the binomial when n is a symbol, use either\n700     expand_func() or expand(func=True). The former will keep the\n701     polynomial in factored form while the latter will expand the\n702     polynomial itself. See examples for details.\n703 \n704     Examples\n705     ========\n706 \n707     >>> from sympy import Symbol, Rational, binomial, expand_func\n708     >>> n = Symbol('n', integer=True, positive=True)\n709 \n710     >>> binomial(15, 8)\n711     6435\n712 \n713     >>> binomial(n, -1)\n714     0\n715 \n716     Rows of Pascal's triangle can be generated with the binomial function:\n717 \n718     >>> for N in range(8):\n719     ...     print([ binomial(N, i) for i in range(N + 1)])\n720     ...\n721     [1]\n722     [1, 1]\n723     [1, 2, 1]\n724     [1, 3, 3, 1]\n725     [1, 4, 6, 4, 1]\n726     [1, 5, 10, 10, 5, 1]\n727     [1, 6, 15, 20, 15, 6, 1]\n728     [1, 7, 21, 35, 35, 21, 7, 1]\n729 \n730     As can a given diagonal, e.g. the 4th diagonal:\n731 \n732     >>> N = -4\n733     >>> [ binomial(N, i) for i in range(1 - N)]\n734     [1, -4, 10, -20, 35]\n735 \n736     >>> binomial(Rational(5, 4), 3)\n737     -5/128\n738     >>> binomial(Rational(-5, 4), 3)\n739     -195/128\n740 \n741     >>> binomial(n, 3)\n742     binomial(n, 3)\n743 \n744     >>> binomial(n, 3).expand(func=True)\n745     n**3/6 - n**2/2 + n/3\n746 \n747     >>> expand_func(binomial(n, 3))\n748     n*(n - 2)*(n - 1)/6\n749 \n750     \"\"\"\n751 \n752     def fdiff(self, argindex=1):\n753         from sympy import polygamma\n754         if argindex == 1:\n755             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/01/\n756             n, k = self.args\n757             return binomial(n, k)*(polygamma(0, n + 1) - \\\n758                 polygamma(0, n - k + 1))\n759         elif argindex == 2:\n760             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/02/\n761             n, k = self.args\n762             return binomial(n, k)*(polygamma(0, n - k + 1) - \\\n763                 polygamma(0, k + 1))\n764         else:\n765             raise ArgumentIndexError(self, argindex)\n766 \n767     @classmethod\n768     def _eval(self, n, k):\n769         # n.is_Number and k.is_Integer and k != 1 and n != k\n770         if k.is_Integer:\n771             if n.is_Integer and n >= 0:\n772                 n, k = int(n), int(k)\n773 \n774                 if k > n:\n775                     return S.Zero\n776                 elif k > n // 2:\n777                     k = n - k\n778 \n779                 M, result = int(_sqrt(n)), 1\n780 \n781                 for prime in sieve.primerange(2, n + 1):\n782                     if prime > n - k:\n783                         result *= prime\n784                     elif prime > n // 2:\n785                         continue\n786                     elif prime > M:\n787                         if n % prime < k % prime:\n788                             result *= prime\n789                     else:\n790                         N, K = n, k\n791                         exp = a = 0\n792 \n793                         while N > 0:\n794                             a = int((N % prime) < (K % prime + a))\n795                             N, K = N // prime, K // prime\n796                             exp = a + exp\n797 \n798                         if exp > 0:\n799                             result *= prime**exp\n800                 return Integer(result)\n801             else:\n802                 d = result = n - k + 1\n803                 for i in range(2, k + 1):\n804                     d += 1\n805                     result *= d\n806                     result /= i\n807                 return result\n808 \n809     @classmethod\n810     def eval(cls, n, k):\n811         n, k = map(sympify, (n, k))\n812         d = n - k\n813         if d.is_zero or k.is_zero:\n814             return S.One\n815         elif d.is_zero is False:\n816             if (k - 1).is_zero:\n817                 return n\n818             elif k.is_negative:\n819                 return S.Zero\n820             elif n.is_integer and n.is_nonnegative and d.is_negative:\n821                 return S.Zero\n822         if k.is_Integer and k > 0 and n.is_Number:\n823             return cls._eval(n, k)\n824 \n825     def _eval_expand_func(self, **hints):\n826         \"\"\"\n827         Function to expand binomial(n,k) when m is positive integer\n828         Also,\n829         n is self.args[0] and k is self.args[1] while using binomial(n, k)\n830         \"\"\"\n831         n = self.args[0]\n832         if n.is_Number:\n833             return binomial(*self.args)\n834 \n835         k = self.args[1]\n836         if k.is_Add and n in k.args:\n837             k = n - k\n838 \n839         if k.is_Integer:\n840             if k == S.Zero:\n841                 return S.One\n842             elif k < 0:\n843                 return S.Zero\n844             else:\n845                 n = self.args[0]\n846                 result = n - k + 1\n847                 for i in range(2, k + 1):\n848                     result *= n - k + i\n849                     result /= i\n850                 return result\n851         else:\n852             return binomial(*self.args)\n853 \n854     def _eval_rewrite_as_factorial(self, n, k):\n855         return factorial(n)/(factorial(k)*factorial(n - k))\n856 \n857     def _eval_rewrite_as_gamma(self, n, k):\n858         from sympy import gamma\n859         return gamma(n + 1)/(gamma(k + 1)*gamma(n - k + 1))\n860 \n861     def _eval_rewrite_as_tractable(self, n, k):\n862         return self._eval_rewrite_as_gamma(n, k).rewrite('tractable')\n863 \n864     def _eval_rewrite_as_FallingFactorial(self, n, k):\n865         if k.is_integer:\n866             return ff(n, k) / factorial(k)\n867 \n868     def _eval_is_integer(self):\n869         n, k = self.args\n870         if n.is_integer and k.is_integer:\n871             return True\n872         elif k.is_integer is False:\n873             return False\n",
        "intended_behavior": "To ensure that `ff` accurately implements the mathematical computation of a falling factorial, which calculates `n! / (n - k)!` for given `n` and `k`. The behavior should match the pre-change logic, maintaining mathematical accuracy and compatibility with dependent functions."
    },
    {
        "rel_file_path": "sympy/functions/combinatorial/numbers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/combinatorial/numbers.py",
        "start": 1,
        "end": 1578,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 This module implements some special functions that commonly appear in\n3 combinatorial contexts (e.g. in power series); in particular,\n4 sequences of rational numbers such as Bernoulli and Fibonacci numbers.\n5 \n6 Factorials, binomial coefficients and related functions are located in\n7 the separate 'factorials' module.\n8 \"\"\"\n9 \n10 from __future__ import print_function, division\n11 \n12 from sympy.core import S, Symbol, Rational, Integer, Add, Dummy\n13 from sympy.core.compatibility import as_int, SYMPY_INTS, range\n14 from sympy.core.cache import cacheit\n15 from sympy.core.function import Function, expand_mul\n16 from sympy.core.numbers import E, pi\n17 from sympy.core.relational import LessThan, StrictGreaterThan\n18 from sympy.functions.combinatorial.factorials import binomial, factorial\n19 from sympy.functions.elementary.exponential import log\n20 from sympy.functions.elementary.integers import floor\n21 from sympy.functions.elementary.trigonometric import sin, cos, cot\n22 from sympy.functions.elementary.miscellaneous import sqrt\n23 from sympy.utilities.memoization import recurrence_memo\n24 \n25 from mpmath import bernfrac, workprec\n26 from mpmath.libmp import ifib as _ifib\n27 \n28 \n29 def _product(a, b):\n30     p = 1\n31     for k in range(a, b + 1):\n32         p *= k\n33     return p\n34 \n35 \n36 \n37 # Dummy symbol used for computing polynomial sequences\n38 _sym = Symbol('x')\n39 _symbols = Function('x')\n40 \n41 \n42 #----------------------------------------------------------------------------#\n43 #                                                                            #\n44 #                           Fibonacci numbers                                #\n45 #                                                                            #\n46 #----------------------------------------------------------------------------#\n47 \n48 class fibonacci(Function):\n49     r\"\"\"\n50     Fibonacci numbers / Fibonacci polynomials\n51 \n52     The Fibonacci numbers are the integer sequence defined by the\n53     initial terms F_0 = 0, F_1 = 1 and the two-term recurrence\n54     relation F_n = F_{n-1} + F_{n-2}.  This definition\n55     extended to arbitrary real and complex arguments using\n56     the formula\n57 \n58     .. math :: F_z = \\frac{\\phi^z - \\cos(\\pi z) \\phi^{-z}}{\\sqrt 5}\n59 \n60     The Fibonacci polynomials are defined by F_1(x) = 1,\n61     F_2(x) = x, and F_n(x) = x*F_{n-1}(x) + F_{n-2}(x) for n > 2.\n62     For all positive integers n, F_n(1) = F_n.\n63 \n64     * fibonacci(n) gives the nth Fibonacci number, F_n\n65     * fibonacci(n, x) gives the nth Fibonacci polynomial in x, F_n(x)\n66 \n67     Examples\n68     ========\n69 \n70     >>> from sympy import fibonacci, Symbol\n71 \n72     >>> [fibonacci(x) for x in range(11)]\n73     [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n74     >>> fibonacci(5, Symbol('t'))\n75     t**4 + 3*t**2 + 1\n76 \n77     References\n78     ==========\n79 \n80     .. [1] http://en.wikipedia.org/wiki/Fibonacci_number\n81     .. [2] http://mathworld.wolfram.com/FibonacciNumber.html\n82 \n83     See Also\n84     ========\n85 \n86     bell, bernoulli, catalan, euler, harmonic, lucas\n87     \"\"\"\n88 \n89     @staticmethod\n90     def _fib(n):\n91         return _ifib(n)\n92 \n93     @staticmethod\n94     @recurrence_memo([None, S.One, _sym])\n95     def _fibpoly(n, prev):\n96         return (prev[-2] + _sym*prev[-1]).expand()\n97 \n98     @classmethod\n99     def eval(cls, n, sym=None):\n100         if n is S.Infinity:\n101             return S.Infinity\n102 \n103         if n.is_Integer:\n104             n = int(n)\n105             if n < 0:\n106                 return S.NegativeOne**(n + 1) * fibonacci(-n)\n107             if sym is None:\n108                 return Integer(cls._fib(n))\n109             else:\n110                 if n < 1:\n111                     raise ValueError(\"Fibonacci polynomials are defined \"\n112                        \"only for positive integer indices.\")\n113                 return cls._fibpoly(n).subs(_sym, sym)\n114 \n115     def _eval_rewrite_as_sqrt(self, n):\n116         return 2**(-n)*sqrt(5)*((1 + sqrt(5))**n - (-sqrt(5) + 1)**n) / 5\n117 \n118     def _eval_rewrite_as_GoldenRatio(self,n):\n119         return (S.GoldenRatio**n - 1/(-S.GoldenRatio)**n)/(2*S.GoldenRatio-1)\n120 \n121 \n122 class lucas(Function):\n123     \"\"\"\n124     Lucas numbers\n125 \n126     Lucas numbers satisfy a recurrence relation similar to that of\n127     the Fibonacci sequence, in which each term is the sum of the\n128     preceding two. They are generated by choosing the initial\n129     values L_0 = 2 and L_1 = 1.\n130 \n131     * lucas(n) gives the nth Lucas number\n132 \n133     Examples\n134     ========\n135 \n136     >>> from sympy import lucas\n137 \n138     >>> [lucas(x) for x in range(11)]\n139     [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123]\n140 \n141     References\n142     ==========\n143 \n144     .. [1] http://en.wikipedia.org/wiki/Lucas_number\n145     .. [2] http://mathworld.wolfram.com/LucasNumber.html\n146 \n147     See Also\n148     ========\n149 \n150     bell, bernoulli, catalan, euler, fibonacci, harmonic\n151     \"\"\"\n152 \n153     @classmethod\n154     def eval(cls, n):\n155         if n is S.Infinity:\n156             return S.Infinity\n157 \n158         if n.is_Integer:\n159             return fibonacci(n + 1) + fibonacci(n - 1)\n160 \n161     def _eval_rewrite_as_sqrt(self, n):\n162         return 2**(-n)*((1 + sqrt(5))**n + (-sqrt(5) + 1)**n)\n163 \n164 #----------------------------------------------------------------------------#\n165 #                                                                            #\n166 #                           Bernoulli numbers                                #\n167 #                                                                            #\n168 #----------------------------------------------------------------------------#\n169 \n170 \n171 class bernoulli(Function):\n172     r\"\"\"\n173     Bernoulli numbers / Bernoulli polynomials\n174 \n175     The Bernoulli numbers are a sequence of rational numbers\n176     defined by B_0 = 1 and the recursive relation (n > 0)::\n177 \n178                 n\n179                ___\n180               \\      / n + 1 \\\n181           0 =  )     |       | * B .\n182               /___   \\   k   /    k\n183               k = 0\n184 \n185     They are also commonly defined by their exponential generating\n186     function, which is x/(exp(x) - 1). For odd indices > 1, the\n187     Bernoulli numbers are zero.\n188 \n189     The Bernoulli polynomials satisfy the analogous formula::\n190 \n191                     n\n192                    ___\n193                   \\      / n \\         n-k\n194           B (x) =  )     |   | * B  * x   .\n195            n      /___   \\ k /    k\n196                   k = 0\n197 \n198     Bernoulli numbers and Bernoulli polynomials are related as\n199     B_n(0) = B_n.\n200 \n201     We compute Bernoulli numbers using Ramanujan's formula::\n202 \n203                                    / n + 3 \\\n204           B   =  (A(n) - S(n))  /  |       |\n205            n                       \\   n   /\n206 \n207     where A(n) = (n+3)/3 when n = 0 or 2 (mod 6), A(n) = -(n+3)/6\n208     when n = 4 (mod 6), and::\n209 \n210                  [n/6]\n211                   ___\n212                  \\      /  n + 3  \\\n213           S(n) =  )     |         | * B\n214                  /___   \\ n - 6*k /    n-6*k\n215                  k = 1\n216 \n217     This formula is similar to the sum given in the definition, but\n218     cuts 2/3 of the terms. For Bernoulli polynomials, we use the\n219     formula in the definition.\n220 \n221     * bernoulli(n) gives the nth Bernoulli number, B_n\n222     * bernoulli(n, x) gives the nth Bernoulli polynomial in x, B_n(x)\n223 \n224     Examples\n225     ========\n226 \n227     >>> from sympy import bernoulli\n228 \n229     >>> [bernoulli(n) for n in range(11)]\n230     [1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]\n231     >>> bernoulli(1000001)\n232     0\n233 \n234     References\n235     ==========\n236 \n237     .. [1] http://en.wikipedia.org/wiki/Bernoulli_number\n238     .. [2] http://en.wikipedia.org/wiki/Bernoulli_polynomial\n239     .. [3] http://mathworld.wolfram.com/BernoulliNumber.html\n240     .. [4] http://mathworld.wolfram.com/BernoulliPolynomial.html\n241 \n242     See Also\n243     ========\n244 \n245     bell, catalan, euler, fibonacci, harmonic, lucas\n246     \"\"\"\n247 \n248     # Calculates B_n for positive even n\n249     @staticmethod\n250     def _calc_bernoulli(n):\n251         s = 0\n252         a = int(binomial(n + 3, n - 6))\n253         for j in range(1, n//6 + 1):\n254             s += a * bernoulli(n - 6*j)\n255             # Avoid computing each binomial coefficient from scratch\n256             a *= _product(n - 6 - 6*j + 1, n - 6*j)\n257             a //= _product(6*j + 4, 6*j + 9)\n258         if n % 6 == 4:\n259             s = -Rational(n + 3, 6) - s\n260         else:\n261             s = Rational(n + 3, 3) - s\n262         return s / binomial(n + 3, n)\n263 \n264     # We implement a specialized memoization scheme to handle each\n265     # case modulo 6 separately\n266     _cache = {0: S.One, 2: Rational(1, 6), 4: Rational(-1, 30)}\n267     _highest = {0: 0, 2: 2, 4: 4}\n268 \n269     @classmethod\n270     def eval(cls, n, sym=None):\n271         if n.is_Number:\n272             if n.is_Integer and n.is_nonnegative:\n273                 if n is S.Zero:\n274                     return S.One\n275                 elif n is S.One:\n276                     if sym is None:\n277                         return -S.Half\n278                     else:\n279                         return sym - S.Half\n280                 # Bernoulli numbers\n281                 elif sym is None:\n282                     if n.is_odd:\n283                         return S.Zero\n284                     n = int(n)\n285                     # Use mpmath for enormous Bernoulli numbers\n286                     if n > 500:\n287                         p, q = bernfrac(n)\n288                         return Rational(int(p), int(q))\n289                     case = n % 6\n290                     highest_cached = cls._highest[case]\n291                     if n <= highest_cached:\n292                         return cls._cache[n]\n293                     # To avoid excessive recursion when, say, bernoulli(1000) is\n294                     # requested, calculate and cache the entire sequence ... B_988,\n295                     # B_994, B_1000 in increasing order\n296                     for i in range(highest_cached + 6, n + 6, 6):\n297                         b = cls._calc_bernoulli(i)\n298                         cls._cache[i] = b\n299                         cls._highest[case] = i\n300                     return b\n301                 # Bernoulli polynomials\n302                 else:\n303                     n, result = int(n), []\n304                     for k in range(n + 1):\n305                         result.append(binomial(n, k)*cls(k)*sym**(n - k))\n306                     return Add(*result)\n307             else:\n308                 raise ValueError(\"Bernoulli numbers are defined only\"\n309                                  \" for nonnegative integer indices.\")\n310 \n311         if sym is None:\n312             if n.is_odd and (n - 1).is_positive:\n313                 return S.Zero\n314 \n315 \n316 #----------------------------------------------------------------------------#\n317 #                                                                            #\n318 #                             Bell numbers                                   #\n319 #                                                                            #\n320 #----------------------------------------------------------------------------#\n321 \n322 class bell(Function):\n323     r\"\"\"\n324     Bell numbers / Bell polynomials\n325 \n326     The Bell numbers satisfy `B_0 = 1` and\n327 \n328     .. math:: B_n = \\sum_{k=0}^{n-1} \\binom{n-1}{k} B_k.\n329 \n330     They are also given by:\n331 \n332     .. math:: B_n = \\frac{1}{e} \\sum_{k=0}^{\\infty} \\frac{k^n}{k!}.\n333 \n334     The Bell polynomials are given by `B_0(x) = 1` and\n335 \n336     .. math:: B_n(x) = x \\sum_{k=1}^{n-1} \\binom{n-1}{k-1} B_{k-1}(x).\n337 \n338     The second kind of Bell polynomials (are sometimes called \"partial\" Bell\n339     polynomials or incomplete Bell polynomials) are defined as\n340 \n341     .. math:: B_{n,k}(x_1, x_2,\\dotsc x_{n-k+1}) =\n342             \\sum_{j_1+j_2+j_2+\\dotsb=k \\atop j_1+2j_2+3j_2+\\dotsb=n}\n343                 \\frac{n!}{j_1!j_2!\\dotsb j_{n-k+1}!}\n344                 \\left(\\frac{x_1}{1!} \\right)^{j_1}\n345                 \\left(\\frac{x_2}{2!} \\right)^{j_2} \\dotsb\n346                 \\left(\\frac{x_{n-k+1}}{(n-k+1)!} \\right) ^{j_{n-k+1}}.\n347 \n348     * bell(n) gives the `n^{th}` Bell number, `B_n`.\n349     * bell(n, x) gives the `n^{th}` Bell polynomial, `B_n(x)`.\n350     * bell(n, k, (x1, x2, ...)) gives Bell polynomials of the second kind,\n351       `B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1})`.\n352 \n353     Notes\n354     =====\n355 \n356     Not to be confused with Bernoulli numbers and Bernoulli polynomials,\n357     which use the same notation.\n358 \n359     Examples\n360     ========\n361 \n362     >>> from sympy import bell, Symbol, symbols\n363 \n364     >>> [bell(n) for n in range(11)]\n365     [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975]\n366     >>> bell(30)\n367     846749014511809332450147\n368     >>> bell(4, Symbol('t'))\n369     t**4 + 6*t**3 + 7*t**2 + t\n370     >>> bell(6, 2, symbols('x:6')[1:])\n371     6*x1*x5 + 15*x2*x4 + 10*x3**2\n372 \n373     References\n374     ==========\n375 \n376     .. [1] http://en.wikipedia.org/wiki/Bell_number\n377     .. [2] http://mathworld.wolfram.com/BellNumber.html\n378     .. [3] http://mathworld.wolfram.com/BellPolynomial.html\n379 \n380     See Also\n381     ========\n382 \n383     bernoulli, catalan, euler, fibonacci, harmonic, lucas\n384     \"\"\"\n385 \n386     @staticmethod\n387     @recurrence_memo([1, 1])\n388     def _bell(n, prev):\n389         s = 1\n390         a = 1\n391         for k in range(1, n):\n392             a = a * (n - k) // k\n393             s += a * prev[k]\n394         return s\n395 \n396     @staticmethod\n397     @recurrence_memo([S.One, _sym])\n398     def _bell_poly(n, prev):\n399         s = 1\n400         a = 1\n401         for k in range(2, n + 1):\n402             a = a * (n - k + 1) // (k - 1)\n403             s += a * prev[k - 1]\n404         return expand_mul(_sym * s)\n405 \n406     @staticmethod\n407     def _bell_incomplete_poly(n, k, symbols):\n408         r\"\"\"\n409         The second kind of Bell polynomials (incomplete Bell polynomials).\n410 \n411         Calculated by recurrence formula:\n412 \n413         .. math:: B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1}) =\n414                 \\sum_{m=1}^{n-k+1}\n415                 \\x_m \\binom{n-1}{m-1} B_{n-m,k-1}(x_1, x_2, \\dotsc, x_{n-m-k})\n416 \n417         where\n418             B_{0,0} = 1;\n419             B_{n,0} = 0; for n>=1\n420             B_{0,k} = 0; for k>=1\n421 \n422         \"\"\"\n423         if (n == 0) and (k == 0):\n424             return S.One\n425         elif (n == 0) or (k == 0):\n426             return S.Zero\n427         s = S.Zero\n428         a = S.One\n429         for m in range(1, n - k + 2):\n430             s += a * bell._bell_incomplete_poly(\n431                 n - m, k - 1, symbols) * symbols[m - 1]\n432             a = a * (n - m) / m\n433         return expand_mul(s)\n434 \n435     @classmethod\n436     def eval(cls, n, k_sym=None, symbols=None):\n437         if n.is_Integer and n.is_nonnegative:\n438             if k_sym is None:\n439                 return Integer(cls._bell(int(n)))\n440             elif symbols is None:\n441                 return cls._bell_poly(int(n)).subs(_sym, k_sym)\n442             else:\n443                 r = cls._bell_incomplete_poly(int(n), int(k_sym), symbols)\n444                 return r\n445 \n446     def _eval_rewrite_as_Sum(self, n, k_sym=None, symbols=None):\n447         from sympy import Sum\n448         if (k_sym is not None) or (symbols is not None):\n449             return self\n450 \n451         # Dobinski's formula\n452         if not n.is_nonnegative:\n453             return self\n454         k = Dummy('k', integer=True, nonnegative=True)\n455         return 1 / E * Sum(k**n / factorial(k), (k, 0, S.Infinity))\n456 \n457 #----------------------------------------------------------------------------#\n458 #                                                                            #\n459 #                           Harmonic numbers                                 #\n460 #                                                                            #\n461 #----------------------------------------------------------------------------#\n462 \n463 \n464 class harmonic(Function):\n465     r\"\"\"\n466     Harmonic numbers\n467 \n468     The nth harmonic number is given by `\\operatorname{H}_{n} =\n469     1 + \\frac{1}{2} + \\frac{1}{3} + \\ldots + \\frac{1}{n}`.\n470 \n471     More generally:\n472 \n473     .. math:: \\operatorname{H}_{n,m} = \\sum_{k=1}^{n} \\frac{1}{k^m}\n474 \n475     As `n \\rightarrow \\infty`, `\\operatorname{H}_{n,m} \\rightarrow \\zeta(m)`,\n476     the Riemann zeta function.\n477 \n478     * ``harmonic(n)`` gives the nth harmonic number, `\\operatorname{H}_n`\n479 \n480     * ``harmonic(n, m)`` gives the nth generalized harmonic number\n481       of order `m`, `\\operatorname{H}_{n,m}`, where\n482       ``harmonic(n) == harmonic(n, 1)``\n483 \n484     Examples\n485     ========\n486 \n487     >>> from sympy import harmonic, oo\n488 \n489     >>> [harmonic(n) for n in range(6)]\n490     [0, 1, 3/2, 11/6, 25/12, 137/60]\n491     >>> [harmonic(n, 2) for n in range(6)]\n492     [0, 1, 5/4, 49/36, 205/144, 5269/3600]\n493     >>> harmonic(oo, 2)\n494     pi**2/6\n495 \n496     >>> from sympy import Symbol, Sum\n497     >>> n = Symbol(\"n\")\n498 \n499     >>> harmonic(n).rewrite(Sum)\n500     Sum(1/_k, (_k, 1, n))\n501 \n502     We can evaluate harmonic numbers for all integral and positive\n503     rational arguments:\n504 \n505     >>> from sympy import S, expand_func, simplify\n506     >>> harmonic(8)\n507     761/280\n508     >>> harmonic(11)\n509     83711/27720\n510 \n511     >>> H = harmonic(1/S(3))\n512     >>> H\n513     harmonic(1/3)\n514     >>> He = expand_func(H)\n515     >>> He\n516     -log(6) - sqrt(3)*pi/6 + 2*Sum(log(sin(_k*pi/3))*cos(2*_k*pi/3), (_k, 1, 1))\n517                            + 3*Sum(1/(3*_k + 1), (_k, 0, 0))\n518     >>> He.doit()\n519     -log(6) - sqrt(3)*pi/6 - log(sqrt(3)/2) + 3\n520     >>> H = harmonic(25/S(7))\n521     >>> He = simplify(expand_func(H).doit())\n522     >>> He\n523     log(sin(pi/7)**(-2*cos(pi/7))*sin(2*pi/7)**(2*cos(16*pi/7))*cos(pi/14)**(-2*sin(pi/14))/14)\n524     + pi*tan(pi/14)/2 + 30247/9900\n525     >>> He.n(40)\n526     1.983697455232980674869851942390639915940\n527     >>> harmonic(25/S(7)).n(40)\n528     1.983697455232980674869851942390639915940\n529 \n530     We can rewrite harmonic numbers in terms of polygamma functions:\n531 \n532     >>> from sympy import digamma, polygamma\n533     >>> m = Symbol(\"m\")\n534 \n535     >>> harmonic(n).rewrite(digamma)\n536     polygamma(0, n + 1) + EulerGamma\n537 \n538     >>> harmonic(n).rewrite(polygamma)\n539     polygamma(0, n + 1) + EulerGamma\n540 \n541     >>> harmonic(n,3).rewrite(polygamma)\n542     polygamma(2, n + 1)/2 - polygamma(2, 1)/2\n543 \n544     >>> harmonic(n,m).rewrite(polygamma)\n545     (-1)**m*(polygamma(m - 1, 1) - polygamma(m - 1, n + 1))/factorial(m - 1)\n546 \n547     Integer offsets in the argument can be pulled out:\n548 \n549     >>> from sympy import expand_func\n550 \n551     >>> expand_func(harmonic(n+4))\n552     harmonic(n) + 1/(n + 4) + 1/(n + 3) + 1/(n + 2) + 1/(n + 1)\n553 \n554     >>> expand_func(harmonic(n-4))\n555     harmonic(n) - 1/(n - 1) - 1/(n - 2) - 1/(n - 3) - 1/n\n556 \n557     Some limits can be computed as well:\n558 \n559     >>> from sympy import limit, oo\n560 \n561     >>> limit(harmonic(n), n, oo)\n562     oo\n563 \n564     >>> limit(harmonic(n, 2), n, oo)\n565     pi**2/6\n566 \n567     >>> limit(harmonic(n, 3), n, oo)\n568     -polygamma(2, 1)/2\n569 \n570     However we can not compute the general relation yet:\n571 \n572     >>> limit(harmonic(n, m), n, oo)\n573     harmonic(oo, m)\n574 \n575     which equals ``zeta(m)`` for ``m > 1``.\n576 \n577     References\n578     ==========\n579 \n580     .. [1] http://en.wikipedia.org/wiki/Harmonic_number\n581     .. [2] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber/\n582     .. [3] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber2/\n583 \n584     See Also\n585     ========\n586 \n587     bell, bernoulli, catalan, euler, fibonacci, lucas\n588     \"\"\"\n589 \n590     # Generate one memoized Harmonic number-generating function for each\n591     # order and store it in a dictionary\n592     _functions = {}\n593 \n594     @classmethod\n595     def eval(cls, n, m=None):\n596         from sympy import zeta\n597         if m is S.One:\n598             return cls(n)\n599         if m is None:\n600             m = S.One\n601 \n602         if m.is_zero:\n603             return n\n604 \n605         if n is S.Infinity and m.is_Number:\n606             # TODO: Fix for symbolic values of m\n607             if m.is_negative:\n608                 return S.NaN\n609             elif LessThan(m, S.One):\n610                 return S.Infinity\n611             elif StrictGreaterThan(m, S.One):\n612                 return zeta(m)\n613             else:\n614                 return cls\n615 \n616         if n.is_Integer and n.is_nonnegative and m.is_Integer:\n617             if n == 0:\n618                 return S.Zero\n619             if not m in cls._functions:\n620                 @recurrence_memo([0])\n621                 def f(n, prev):\n622                     return prev[-1] + S.One / n**m\n623                 cls._functions[m] = f\n624             return cls._functions[m](int(n))\n625 \n626     def _eval_rewrite_as_polygamma(self, n, m=1):\n627         from sympy.functions.special.gamma_functions import polygamma\n628         return S.NegativeOne**m/factorial(m - 1) * (polygamma(m - 1, 1) - polygamma(m - 1, n + 1))\n629 \n630     def _eval_rewrite_as_digamma(self, n, m=1):\n631         from sympy.functions.special.gamma_functions import polygamma\n632         return self.rewrite(polygamma)\n633 \n634     def _eval_rewrite_as_trigamma(self, n, m=1):\n635         from sympy.functions.special.gamma_functions import polygamma\n636         return self.rewrite(polygamma)\n637 \n638     def _eval_rewrite_as_Sum(self, n, m=None):\n639         from sympy import Sum\n640         k = Dummy(\"k\", integer=True)\n641         if m is None:\n642             m = S.One\n643         return Sum(k**(-m), (k, 1, n))\n644 \n645     def _eval_expand_func(self, **hints):\n646         from sympy import Sum\n647         n = self.args[0]\n648         m = self.args[1] if len(self.args) == 2 else 1\n649 \n650         if m == S.One:\n651             if n.is_Add:\n652                 off = n.args[0]\n653                 nnew = n - off\n654                 if off.is_Integer and off.is_positive:\n655                     result = [S.One/(nnew + i) for i in range(off, 0, -1)] + [harmonic(nnew)]\n656                     return Add(*result)\n657                 elif off.is_Integer and off.is_negative:\n658                     result = [-S.One/(nnew + i) for i in range(0, off, -1)] + [harmonic(nnew)]\n659                     return Add(*result)\n660 \n661             if n.is_Rational:\n662                 # Expansions for harmonic numbers at general rational arguments (u + p/q)\n663                 # Split n as u + p/q with p < q\n664                 p, q = n.as_numer_denom()\n665                 u = p // q\n666                 p = p - u * q\n667                 if u.is_nonnegative and p.is_positive and q.is_positive and p < q:\n668                     k = Dummy(\"k\")\n669                     t1 = q * Sum(1 / (q * k + p), (k, 0, u))\n670                     t2 = 2 * Sum(cos((2 * pi * p * k) / S(q)) *\n671                                    log(sin((pi * k) / S(q))),\n672                                    (k, 1, floor((q - 1) / S(2))))\n673                     t3 = (pi / 2) * cot((pi * p) / q) + log(2 * q)\n674                     return t1 + t2 - t3\n675 \n676         return self\n677 \n678     def _eval_rewrite_as_tractable(self, n, m=1):\n679         from sympy import polygamma\n680         return self.rewrite(polygamma).rewrite(\"tractable\", deep=True)\n681 \n682     def _eval_evalf(self, prec):\n683         from sympy import polygamma\n684         if all(i.is_number for i in self.args):\n685             return self.rewrite(polygamma)._eval_evalf(prec)\n686 \n687 \n688 #----------------------------------------------------------------------------#\n689 #                                                                            #\n690 #                           Euler numbers                                    #\n691 #                                                                            #\n692 #----------------------------------------------------------------------------#\n693 \n694 \n695 class euler(Function):\n696     r\"\"\"\n697     Euler numbers\n698 \n699     The euler numbers are given by::\n700 \n701                   2*n+1   k\n702                    ___   ___            j          2*n+1\n703                   \\     \\     / k \\ (-1)  * (k-2*j)\n704           E   = I  )     )    |   | --------------------\n705            2n     /___  /___  \\ j /      k    k\n706                   k = 1 j = 0           2  * I  * k\n707 \n708           E     = 0\n709            2n+1\n710 \n711     * euler(n) gives the n-th Euler number, E_n\n712 \n713     Examples\n714     ========\n715 \n716     >>> from sympy import Symbol\n717     >>> from sympy.functions import euler\n718     >>> [euler(n) for n in range(10)]\n719     [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0]\n720     >>> n = Symbol(\"n\")\n721     >>> euler(n+2*n)\n722     euler(3*n)\n723 \n724     References\n725     ==========\n726 \n727     .. [1] http://en.wikipedia.org/wiki/Euler_numbers\n728     .. [2] http://mathworld.wolfram.com/EulerNumber.html\n729     .. [3] http://en.wikipedia.org/wiki/Alternating_permutation\n730     .. [4] http://mathworld.wolfram.com/AlternatingPermutation.html\n731 \n732     See Also\n733     ========\n734 \n735     bell, bernoulli, catalan, fibonacci, harmonic, lucas\n736     \"\"\"\n737 \n738     @classmethod\n739     def eval(cls, m):\n740         if m.is_odd:\n741             return S.Zero\n742         if m.is_Integer and m.is_nonnegative:\n743             from mpmath import mp\n744             m = m._to_mpmath(mp.prec)\n745             res = mp.eulernum(m, exact=True)\n746             return Integer(res)\n747 \n748     def _eval_rewrite_as_Sum(self, arg):\n749         from sympy import Sum\n750         if arg.is_even:\n751             k = Dummy(\"k\", integer=True)\n752             j = Dummy(\"j\", integer=True)\n753             n = self.args[0] / 2\n754             Em = (S.ImaginaryUnit * Sum(Sum(binomial(k, j) * ((-1)**j * (k - 2*j)**(2*n + 1)) /\n755                   (2**k*S.ImaginaryUnit**k * k), (j, 0, k)), (k, 1, 2*n + 1)))\n756 \n757             return Em\n758 \n759     def _eval_evalf(self, prec):\n760         m = self.args[0]\n761 \n762         if m.is_Integer and m.is_nonnegative:\n763             from mpmath import mp\n764             from sympy import Expr\n765             m = m._to_mpmath(prec)\n766             with workprec(prec):\n767                 res = mp.eulernum(m)\n768             return Expr._from_mpmath(res, prec)\n769 \n770 #----------------------------------------------------------------------------#\n771 #                                                                            #\n772 #                           Catalan numbers                                  #\n773 #                                                                            #\n774 #----------------------------------------------------------------------------#\n775 \n776 \n777 class catalan(Function):\n778     r\"\"\"\n779     Catalan numbers\n780 \n781     The n-th catalan number is given by::\n782 \n783                  1   / 2*n \\\n784           C  = ----- |     |\n785            n   n + 1 \\  n  /\n786 \n787     * catalan(n) gives the n-th Catalan number, C_n\n788 \n789     Examples\n790     ========\n791 \n792     >>> from sympy import (Symbol, binomial, gamma, hyper, polygamma,\n793     ...             catalan, diff, combsimp, Rational, I)\n794 \n795     >>> [ catalan(i) for i in range(1,10) ]\n796     [1, 2, 5, 14, 42, 132, 429, 1430, 4862]\n797 \n798     >>> n = Symbol(\"n\", integer=True)\n799 \n800     >>> catalan(n)\n801     catalan(n)\n802 \n803     Catalan numbers can be transformed into several other, identical\n804     expressions involving other mathematical functions\n805 \n806     >>> catalan(n).rewrite(binomial)\n807     binomial(2*n, n)/(n + 1)\n808 \n809     >>> catalan(n).rewrite(gamma)\n810     4**n*gamma(n + 1/2)/(sqrt(pi)*gamma(n + 2))\n811 \n812     >>> catalan(n).rewrite(hyper)\n813     hyper((-n + 1, -n), (2,), 1)\n814 \n815     For some non-integer values of n we can get closed form\n816     expressions by rewriting in terms of gamma functions:\n817 \n818     >>> catalan(Rational(1,2)).rewrite(gamma)\n819     8/(3*pi)\n820 \n821     We can differentiate the Catalan numbers C(n) interpreted as a\n822     continuous real funtion in n:\n823 \n824     >>> diff(catalan(n), n)\n825     (polygamma(0, n + 1/2) - polygamma(0, n + 2) + log(4))*catalan(n)\n826 \n827     As a more advanced example consider the following ratio\n828     between consecutive numbers:\n829 \n830     >>> combsimp((catalan(n + 1)/catalan(n)).rewrite(binomial))\n831     2*(2*n + 1)/(n + 2)\n832 \n833     The Catalan numbers can be generalized to complex numbers:\n834 \n835     >>> catalan(I).rewrite(gamma)\n836     4**I*gamma(1/2 + I)/(sqrt(pi)*gamma(2 + I))\n837 \n838     and evaluated with arbitrary precision:\n839 \n840     >>> catalan(I).evalf(20)\n841     0.39764993382373624267 - 0.020884341620842555705*I\n842 \n843     References\n844     ==========\n845 \n846     .. [1] http://en.wikipedia.org/wiki/Catalan_number\n847     .. [2] http://mathworld.wolfram.com/CatalanNumber.html\n848     .. [3] http://functions.wolfram.com/GammaBetaErf/CatalanNumber/\n849     .. [4] http://geometer.org/mathcircles/catalan.pdf\n850 \n851     See Also\n852     ========\n853 \n854     bell, bernoulli, euler, fibonacci, harmonic, lucas\n855     sympy.functions.combinatorial.factorials.binomial\n856     \"\"\"\n857 \n858     @classmethod\n859     def eval(cls, n):\n860         from sympy import gamma\n861         if (n.is_Integer and n.is_nonnegative) or \\\n862            (n.is_noninteger and n.is_negative):\n863             return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))\n864 \n865         if (n.is_integer and n.is_negative):\n866             if (n + 1).is_negative:\n867                 return S.Zero\n868             if (n + 1).is_zero:\n869                 return -S.Half\n870 \n871     def fdiff(self, argindex=1):\n872         from sympy import polygamma, log\n873         n = self.args[0]\n874         return catalan(n)*(polygamma(0, n + Rational(1, 2)) - polygamma(0, n + 2) + log(4))\n875 \n876     def _eval_rewrite_as_binomial(self, n):\n877         return binomial(2*n, n)/(n + 1)\n878 \n879     def _eval_rewrite_as_factorial(self, n):\n880         return factorial(2*n) / (factorial(n+1) * factorial(n))\n881 \n882     def _eval_rewrite_as_gamma(self, n):\n883         from sympy import gamma\n884         # The gamma function allows to generalize Catalan numbers to complex n\n885         return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))\n886 \n887     def _eval_rewrite_as_hyper(self, n):\n888         from sympy import hyper\n889         return hyper([1 - n, -n], [2], 1)\n890 \n891     def _eval_rewrite_as_Product(self, n):\n892         from sympy import Product\n893         if not (n.is_integer and n.is_nonnegative):\n894             return self\n895         k = Dummy('k', integer=True, positive=True)\n896         return Product((n + k) / k, (k, 2, n))\n897 \n898     def _eval_evalf(self, prec):\n899         from sympy import gamma\n900         if self.args[0].is_number:\n901             return self.rewrite(gamma)._eval_evalf(prec)\n902 \n903 \n904 #----------------------------------------------------------------------------#\n905 #                                                                            #\n906 #                           Genocchi numbers                                 #\n907 #                                                                            #\n908 #----------------------------------------------------------------------------#\n909 \n910 \n911 class genocchi(Function):\n912     r\"\"\"\n913     Genocchi numbers\n914 \n915     The Genocchi numbers are a sequence of integers G_n that satisfy the\n916     relation::\n917 \n918                            oo\n919                          ____\n920                          \\   `\n921                  2*t      \\         n\n922                 ------ =   \\   G_n*t\n923                  t         /   ------\n924                 e  + 1    /      n!\n925                          /___,\n926                          n = 1\n927 \n928     Examples\n929     ========\n930 \n931     >>> from sympy import Symbol\n932     >>> from sympy.functions import genocchi\n933     >>> [genocchi(n) for n in range(1, 9)]\n934     [1, -1, 0, 1, 0, -3, 0, 17]\n935     >>> n = Symbol('n', integer=True, positive=True)\n936     >>> genocchi(2 * n + 1)\n937     0\n938 \n939     References\n940     ==========\n941 \n942     .. [1] https://en.wikipedia.org/wiki/Genocchi_number\n943     .. [2] http://mathworld.wolfram.com/GenocchiNumber.html\n944 \n945     See Also\n946     ========\n947 \n948     bell, bernoulli, catalan, euler, fibonacci, harmonic, lucas\n949     \"\"\"\n950 \n951     @classmethod\n952     def eval(cls, n):\n953         if n.is_Number:\n954             if (not n.is_Integer) or n.is_nonpositive:\n955                 raise ValueError(\"Genocchi numbers are defined only for \" +\n956                                  \"positive integers\")\n957             return 2 * (1 - S(2) ** n) * bernoulli(n)\n958 \n959         if n.is_odd and (n - 1).is_positive:\n960             return S.Zero\n961 \n962         if (n - 1).is_zero:\n963             return S.One\n964 \n965     def _eval_rewrite_as_bernoulli(self, n):\n966         if n.is_integer and n.is_nonnegative:\n967             return (1 - S(2) ** n) * bernoulli(n) * 2\n968 \n969     def _eval_is_integer(self):\n970         if self.args[0].is_integer and self.args[0].is_positive:\n971             return True\n972 \n973     def _eval_is_negative(self):\n974         n = self.args[0]\n975         if n.is_integer and n.is_positive:\n976             if n.is_odd:\n977                 return False\n978             return (n / 2).is_odd\n979 \n980     def _eval_is_positive(self):\n981         n = self.args[0]\n982         if n.is_integer and n.is_positive:\n983             if n.is_odd:\n984                 return fuzzy_not((n - 1).is_positive)\n985             return (n / 2).is_even\n986 \n987     def _eval_is_even(self):\n988         n = self.args[0]\n989         if n.is_integer and n.is_positive:\n990             if n.is_even:\n991                 return False\n992             return (n - 1).is_positive\n993 \n994     def _eval_is_odd(self):\n995         n = self.args[0]\n996         if n.is_integer and n.is_positive:\n997             if n.is_even:\n998                 return True\n999             return fuzzy_not((n - 1).is_positive)\n1000 \n1001     def _eval_is_prime(self):\n1002         n = self.args[0]\n1003         # only G_6 = -3 and G_8 = 17 are prime,\n1004         # but SymPy does not consider negatives as prime\n1005         # so only n=8 is tested\n1006         return (n - 8).is_zero\n1007 \n1008 \n1009 #######################################################################\n1010 ###\n1011 ### Functions for enumerating partitions, permutations and combinations\n1012 ###\n1013 #######################################################################\n1014 \n1015 \n1016 class _MultisetHistogram(tuple):\n1017     pass\n1018 \n1019 \n1020 _N = -1\n1021 _ITEMS = -2\n1022 _M = slice(None, _ITEMS)\n1023 \n1024 \n1025 def _multiset_histogram(n):\n1026     \"\"\"Return tuple used in permutation and combination counting. Input\n1027     is a dictionary giving items with counts as values or a sequence of\n1028     items (which need not be sorted).\n1029 \n1030     The data is stored in a class deriving from tuple so it is easily\n1031     recognized and so it can be converted easily to a list.\n1032     \"\"\"\n1033     if type(n) is dict:  # item: count\n1034         if not all(isinstance(v, int) and v >= 0 for v in n.values()):\n1035             raise ValueError\n1036         tot = sum(n.values())\n1037         items = sum(1 for k in n if n[k] > 0)\n1038         return _MultisetHistogram([n[k] for k in n if n[k] > 0] + [items, tot])\n1039     else:\n1040         n = list(n)\n1041         s = set(n)\n1042         if len(s) == len(n):\n1043             n = [1]*len(n)\n1044             n.extend([len(n), len(n)])\n1045             return _MultisetHistogram(n)\n1046         m = dict(zip(s, range(len(s))))\n1047         d = dict(zip(range(len(s)), [0]*len(s)))\n1048         for i in n:\n1049             d[m[i]] += 1\n1050         return _multiset_histogram(d)\n1051 \n1052 \n1053 def nP(n, k=None, replacement=False):\n1054     \"\"\"Return the number of permutations of ``n`` items taken ``k`` at a time.\n1055 \n1056     Possible values for ``n``::\n1057         integer - set of length ``n``\n1058         sequence - converted to a multiset internally\n1059         multiset - {element: multiplicity}\n1060 \n1061     If ``k`` is None then the total of all permutations of length 0\n1062     through the number of items represented by ``n`` will be returned.\n1063 \n1064     If ``replacement`` is True then a given item can appear more than once\n1065     in the ``k`` items. (For example, for 'ab' permutations of 2 would\n1066     include 'aa', 'ab', 'ba' and 'bb'.) The multiplicity of elements in\n1067     ``n`` is ignored when ``replacement`` is True but the total number\n1068     of elements is considered since no element can appear more times than\n1069     the number of elements in ``n``.\n1070 \n1071     Examples\n1072     ========\n1073 \n1074     >>> from sympy.functions.combinatorial.numbers import nP\n1075     >>> from sympy.utilities.iterables import multiset_permutations, multiset\n1076     >>> nP(3, 2)\n1077     6\n1078     >>> nP('abc', 2) == nP(multiset('abc'), 2) == 6\n1079     True\n1080     >>> nP('aab', 2)\n1081     3\n1082     >>> nP([1, 2, 2], 2)\n1083     3\n1084     >>> [nP(3, i) for i in range(4)]\n1085     [1, 3, 6, 6]\n1086     >>> nP(3) == sum(_)\n1087     True\n1088 \n1089     When ``replacement`` is True, each item can have multiplicity\n1090     equal to the length represented by ``n``:\n1091 \n1092     >>> nP('aabc', replacement=True)\n1093     121\n1094     >>> [len(list(multiset_permutations('aaaabbbbcccc', i))) for i in range(5)]\n1095     [1, 3, 9, 27, 81]\n1096     >>> sum(_)\n1097     121\n1098 \n1099     References\n1100     ==========\n1101 \n1102     .. [1] http://en.wikipedia.org/wiki/Permutation\n1103 \n1104     See Also\n1105     ========\n1106     sympy.utilities.iterables.multiset_permutations\n1107 \n1108     \"\"\"\n1109     try:\n1110         n = as_int(n)\n1111     except ValueError:\n1112         return Integer(_nP(_multiset_histogram(n), k, replacement))\n1113     return Integer(_nP(n, k, replacement))\n1114 \n1115 \n1116 @cacheit\n1117 def _nP(n, k=None, replacement=False):\n1118     from sympy.functions.combinatorial.factorials import factorial\n1119     from sympy.core.mul import prod\n1120 \n1121     if k == 0:\n1122         return 1\n1123     if isinstance(n, SYMPY_INTS):  # n different items\n1124         # assert n >= 0\n1125         if k is None:\n1126             return sum(_nP(n, i, replacement) for i in range(n + 1))\n1127         elif replacement:\n1128             return n**k\n1129         elif k > n:\n1130             return 0\n1131         elif k == n:\n1132             return factorial(k)\n1133         elif k == 1:\n1134             return n\n1135         else:\n1136             # assert k >= 0\n1137             return _product(n - k + 1, n)\n1138     elif isinstance(n, _MultisetHistogram):\n1139         if k is None:\n1140             return sum(_nP(n, i, replacement) for i in range(n[_N] + 1))\n1141         elif replacement:\n1142             return n[_ITEMS]**k\n1143         elif k == n[_N]:\n1144             return factorial(k)/prod([factorial(i) for i in n[_M] if i > 1])\n1145         elif k > n[_N]:\n1146             return 0\n1147         elif k == 1:\n1148             return n[_ITEMS]\n1149         else:\n1150             # assert k >= 0\n1151             tot = 0\n1152             n = list(n)\n1153             for i in range(len(n[_M])):\n1154                 if not n[i]:\n1155                     continue\n1156                 n[_N] -= 1\n1157                 if n[i] == 1:\n1158                     n[i] = 0\n1159                     n[_ITEMS] -= 1\n1160                     tot += _nP(_MultisetHistogram(n), k - 1)\n1161                     n[_ITEMS] += 1\n1162                     n[i] = 1\n1163                 else:\n1164                     n[i] -= 1\n1165                     tot += _nP(_MultisetHistogram(n), k - 1)\n1166                     n[i] += 1\n1167                 n[_N] += 1\n1168             return tot\n1169 \n1170 \n1171 @cacheit\n1172 def _AOP_product(n):\n1173     \"\"\"for n = (m1, m2, .., mk) return the coefficients of the polynomial,\n1174     prod(sum(x**i for i in range(nj + 1)) for nj in n); i.e. the coefficients\n1175     of the product of AOPs (all-one polynomials) or order given in n.  The\n1176     resulting coefficient corresponding to x**r is the number of r-length\n1177     combinations of sum(n) elements with multiplicities given in n.\n1178     The coefficients are given as a default dictionary (so if a query is made\n1179     for a key that is not present, 0 will be returned).\n1180 \n1181     Examples\n1182     ========\n1183 \n1184     >>> from sympy.functions.combinatorial.numbers import _AOP_product\n1185     >>> from sympy.abc import x\n1186     >>> n = (2, 2, 3)  # e.g. aabbccc\n1187     >>> prod = ((x**2 + x + 1)*(x**2 + x + 1)*(x**3 + x**2 + x + 1)).expand()\n1188     >>> c = _AOP_product(n); dict(c)\n1189     {0: 1, 1: 3, 2: 6, 3: 8, 4: 8, 5: 6, 6: 3, 7: 1}\n1190     >>> [c[i] for i in range(8)] == [prod.coeff(x, i) for i in range(8)]\n1191     True\n1192 \n1193     The generating poly used here is the same as that listed in\n1194     http://tinyurl.com/cep849r, but in a refactored form.\n1195 \n1196     \"\"\"\n1197     from collections import defaultdict\n1198 \n1199     n = list(n)\n1200     ord = sum(n)\n1201     need = (ord + 2)//2\n1202     rv = [1]*(n.pop() + 1)\n1203     rv.extend([0]*(need - len(rv)))\n1204     rv = rv[:need]\n1205     while n:\n1206         ni = n.pop()\n1207         N = ni + 1\n1208         was = rv[:]\n1209         for i in range(1, min(N, len(rv))):\n1210             rv[i] += rv[i - 1]\n1211         for i in range(N, need):\n1212             rv[i] += rv[i - 1] - was[i - N]\n1213     rev = list(reversed(rv))\n1214     if ord % 2:\n1215         rv = rv + rev\n1216     else:\n1217         rv[-1:] = rev\n1218     d = defaultdict(int)\n1219     for i in range(len(rv)):\n1220         d[i] = rv[i]\n1221     return d\n1222 \n1223 \n1224 def nC(n, k=None, replacement=False):\n1225     \"\"\"Return the number of combinations of ``n`` items taken ``k`` at a time.\n1226 \n1227     Possible values for ``n``::\n1228         integer - set of length ``n``\n1229         sequence - converted to a multiset internally\n1230         multiset - {element: multiplicity}\n1231 \n1232     If ``k`` is None then the total of all combinations of length 0\n1233     through the number of items represented in ``n`` will be returned.\n1234 \n1235     If ``replacement`` is True then a given item can appear more than once\n1236     in the ``k`` items. (For example, for 'ab' sets of 2 would include 'aa',\n1237     'ab', and 'bb'.) The multiplicity of elements in ``n`` is ignored when\n1238     ``replacement`` is True but the total number of elements is considered\n1239     since no element can appear more times than the number of elements in\n1240     ``n``.\n1241 \n1242     Examples\n1243     ========\n1244 \n1245     >>> from sympy.functions.combinatorial.numbers import nC\n1246     >>> from sympy.utilities.iterables import multiset_combinations\n1247     >>> nC(3, 2)\n1248     3\n1249     >>> nC('abc', 2)\n1250     3\n1251     >>> nC('aab', 2)\n1252     2\n1253 \n1254     When ``replacement`` is True, each item can have multiplicity\n1255     equal to the length represented by ``n``:\n1256 \n1257     >>> nC('aabc', replacement=True)\n1258     35\n1259     >>> [len(list(multiset_combinations('aaaabbbbcccc', i))) for i in range(5)]\n1260     [1, 3, 6, 10, 15]\n1261     >>> sum(_)\n1262     35\n1263 \n1264     If there are ``k`` items with multiplicities ``m_1, m_2, ..., m_k``\n1265     then the total of all combinations of length 0 hrough ``k`` is the\n1266     product, ``(m_1 + 1)*(m_2 + 1)*...*(m_k + 1)``. When the multiplicity\n1267     of each item is 1 (i.e., k unique items) then there are 2**k\n1268     combinations. For example, if there are 4 unique items, the total number\n1269     of combinations is 16:\n1270 \n1271     >>> sum(nC(4, i) for i in range(5))\n1272     16\n1273 \n1274     References\n1275     ==========\n1276 \n1277     .. [1] http://en.wikipedia.org/wiki/Combination\n1278     .. [2] http://tinyurl.com/cep849r\n1279 \n1280     See Also\n1281     ========\n1282     sympy.utilities.iterables.multiset_combinations\n1283     \"\"\"\n1284     from sympy.functions.combinatorial.factorials import binomial\n1285     from sympy.core.mul import prod\n1286 \n1287     if isinstance(n, SYMPY_INTS):\n1288         if k is None:\n1289             if not replacement:\n1290                 return 2**n\n1291             return sum(nC(n, i, replacement) for i in range(n + 1))\n1292         if k < 0:\n1293             raise ValueError(\"k cannot be negative\")\n1294         if replacement:\n1295             return binomial(n + k - 1, k)\n1296         return binomial(n, k)\n1297     if isinstance(n, _MultisetHistogram):\n1298         N = n[_N]\n1299         if k is None:\n1300             if not replacement:\n1301                 return prod(m + 1 for m in n[_M])\n1302             return sum(nC(n, i, replacement) for i in range(N + 1))\n1303         elif replacement:\n1304             return nC(n[_ITEMS], k, replacement)\n1305         # assert k >= 0\n1306         elif k in (1, N - 1):\n1307             return n[_ITEMS]\n1308         elif k in (0, N):\n1309             return 1\n1310         return _AOP_product(tuple(n[_M]))[k]\n1311     else:\n1312         return nC(_multiset_histogram(n), k, replacement)\n1313 \n1314 \n1315 @cacheit\n1316 def _stirling1(n, k):\n1317     if n == k == 0:\n1318         return S.One\n1319     if 0 in (n, k):\n1320         return S.Zero\n1321     n1 = n - 1\n1322 \n1323     # some special values\n1324     if n == k:\n1325         return S.One\n1326     elif k == 1:\n1327         return factorial(n1)\n1328     elif k == n1:\n1329         return binomial(n, 2)\n1330     elif k == n - 2:\n1331         return (3*n - 1)*binomial(n, 3)/4\n1332     elif k == n - 3:\n1333         return binomial(n, 2)*binomial(n, 4)\n1334 \n1335     # general recurrence\n1336     return n1*_stirling1(n1, k) + _stirling1(n1, k - 1)\n1337 \n1338 \n1339 @cacheit\n1340 def _stirling2(n, k):\n1341     if n == k == 0:\n1342         return S.One\n1343     if 0 in (n, k):\n1344         return S.Zero\n1345     n1 = n - 1\n1346 \n1347     # some special values\n1348     if k == n1:\n1349         return binomial(n, 2)\n1350     elif k == 2:\n1351         return 2**n1 - 1\n1352 \n1353     # general recurrence\n1354     return k*_stirling2(n1, k) + _stirling2(n1, k - 1)\n1355 \n1356 \n1357 def stirling(n, k, d=None, kind=2, signed=False):\n1358     \"\"\"Return Stirling number S(n, k) of the first or second (default) kind.\n1359 \n1360     The sum of all Stirling numbers of the second kind for k = 1\n1361     through n is bell(n). The recurrence relationship for these numbers\n1362     is::\n1363 \n1364     {0}       {n}   {0}      {n + 1}     {n}   {  n  }\n1365     { } = 1;  { } = { } = 0; {     } = j*{ } + {     }\n1366     {0}       {0}   {k}      {  k  }     {k}   {k - 1}\n1367 \n1368     where ``j`` is::\n1369         ``n`` for Stirling numbers of the first kind\n1370         ``-n`` for signed Stirling numbers of the first kind\n1371         ``k`` for Stirling numbers of the second kind\n1372 \n1373     The first kind of Stirling number counts the number of permutations of\n1374     ``n`` distinct items that have ``k`` cycles; the second kind counts the\n1375     ways in which ``n`` distinct items can be partitioned into ``k`` parts.\n1376     If ``d`` is given, the \"reduced Stirling number of the second kind\" is\n1377     returned: ``S^{d}(n, k) = S(n - d + 1, k - d + 1)`` with ``n >= k >= d``.\n1378     (This counts the ways to partition ``n`` consecutive integers into\n1379     ``k`` groups with no pairwise difference less than ``d``. See example\n1380     below.)\n1381 \n1382     To obtain the signed Stirling numbers of the first kind, use keyword\n1383     ``signed=True``. Using this keyword automatically sets ``kind`` to 1.\n1384 \n1385     Examples\n1386     ========\n1387 \n1388     >>> from sympy.functions.combinatorial.numbers import stirling, bell\n1389     >>> from sympy.combinatorics import Permutation\n1390     >>> from sympy.utilities.iterables import multiset_partitions, permutations\n1391 \n1392     First kind (unsigned by default):\n1393 \n1394     >>> [stirling(6, i, kind=1) for i in range(7)]\n1395     [0, 120, 274, 225, 85, 15, 1]\n1396     >>> perms = list(permutations(range(4)))\n1397     >>> [sum(Permutation(p).cycles == i for p in perms) for i in range(5)]\n1398     [0, 6, 11, 6, 1]\n1399     >>> [stirling(4, i, kind=1) for i in range(5)]\n1400     [0, 6, 11, 6, 1]\n1401 \n1402     First kind (signed):\n1403 \n1404     >>> [stirling(4, i, signed=True) for i in range(5)]\n1405     [0, -6, 11, -6, 1]\n1406 \n1407     Second kind:\n1408 \n1409     >>> [stirling(10, i) for i in range(12)]\n1410     [0, 1, 511, 9330, 34105, 42525, 22827, 5880, 750, 45, 1, 0]\n1411     >>> sum(_) == bell(10)\n1412     True\n1413     >>> len(list(multiset_partitions(range(4), 2))) == stirling(4, 2)\n1414     True\n1415 \n1416     Reduced second kind:\n1417 \n1418     >>> from sympy import subsets, oo\n1419     >>> def delta(p):\n1420     ...    if len(p) == 1:\n1421     ...        return oo\n1422     ...    return min(abs(i[0] - i[1]) for i in subsets(p, 2))\n1423     >>> parts = multiset_partitions(range(5), 3)\n1424     >>> d = 2\n1425     >>> sum(1 for p in parts if all(delta(i) >= d for i in p))\n1426     7\n1427     >>> stirling(5, 3, 2)\n1428     7\n1429 \n1430     References\n1431     ==========\n1432 \n1433     .. [1] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind\n1434     .. [2] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n1435 \n1436     See Also\n1437     ========\n1438     sympy.utilities.iterables.multiset_partitions\n1439 \n1440     \"\"\"\n1441     # TODO: make this a class like bell()\n1442 \n1443     n = as_int(n)\n1444     k = as_int(k)\n1445     if n < 0:\n1446         raise ValueError('n must be nonnegative')\n1447     if k > n:\n1448         return S.Zero\n1449     if d:\n1450         # assert k >= d\n1451         # kind is ignored -- only kind=2 is supported\n1452         return _stirling2(n - d + 1, k - d + 1)\n1453     elif signed:\n1454         # kind is ignored -- only kind=1 is supported\n1455         return (-1)**(n - k)*_stirling1(n, k)\n1456 \n1457     if kind == 1:\n1458         return _stirling1(n, k)\n1459     elif kind == 2:\n1460         return _stirling2(n, k)\n1461     else:\n1462         raise ValueError('kind must be 1 or 2, not %s' % k)\n1463 \n1464 \n1465 @cacheit\n1466 def _nT(n, k):\n1467     \"\"\"Return the partitions of ``n`` items into ``k`` parts. This\n1468     is used by ``nT`` for the case when ``n`` is an integer.\"\"\"\n1469     if k == 0:\n1470         return 1 if k == n else 0\n1471     return sum(_nT(n - k, j) for j in range(min(k, n - k) + 1))\n1472 \n1473 \n1474 def nT(n, k=None):\n1475     \"\"\"Return the number of ``k``-sized partitions of ``n`` items.\n1476 \n1477     Possible values for ``n``::\n1478         integer - ``n`` identical items\n1479         sequence - converted to a multiset internally\n1480         multiset - {element: multiplicity}\n1481 \n1482     Note: the convention for ``nT`` is different than that of ``nC`` and\n1483     ``nP`` in that\n1484     here an integer indicates ``n`` *identical* items instead of a set of\n1485     length ``n``; this is in keeping with the ``partitions`` function which\n1486     treats its integer-``n`` input like a list of ``n`` 1s. One can use\n1487     ``range(n)`` for ``n`` to indicate ``n`` distinct items.\n1488 \n1489     If ``k`` is None then the total number of ways to partition the elements\n1490     represented in ``n`` will be returned.\n1491 \n1492     Examples\n1493     ========\n1494 \n1495     >>> from sympy.functions.combinatorial.numbers import nT\n1496 \n1497     Partitions of the given multiset:\n1498 \n1499     >>> [nT('aabbc', i) for i in range(1, 7)]\n1500     [1, 8, 11, 5, 1, 0]\n1501     >>> nT('aabbc') == sum(_)\n1502     True\n1503 \n1504     >>> [nT(\"mississippi\", i) for i in range(1, 12)]\n1505     [1, 74, 609, 1521, 1768, 1224, 579, 197, 50, 9, 1]\n1506 \n1507     Partitions when all items are identical:\n1508 \n1509     >>> [nT(5, i) for i in range(1, 6)]\n1510     [1, 2, 2, 1, 1]\n1511     >>> nT('1'*5) == sum(_)\n1512     True\n1513 \n1514     When all items are different:\n1515 \n1516     >>> [nT(range(5), i) for i in range(1, 6)]\n1517     [1, 15, 25, 10, 1]\n1518     >>> nT(range(5)) == sum(_)\n1519     True\n1520 \n1521     References\n1522     ==========\n1523 \n1524     .. [1] http://undergraduate.csse.uwa.edu.au/units/CITS7209/partition.pdf\n1525 \n1526     See Also\n1527     ========\n1528     sympy.utilities.iterables.partitions\n1529     sympy.utilities.iterables.multiset_partitions\n1530 \n1531     \"\"\"\n1532     from sympy.utilities.enumerative import MultisetPartitionTraverser\n1533 \n1534     if isinstance(n, SYMPY_INTS):\n1535         # assert n >= 0\n1536         # all the same\n1537         if k is None:\n1538             return sum(_nT(n, k) for k in range(1, n + 1))\n1539         return _nT(n, k)\n1540     if not isinstance(n, _MultisetHistogram):\n1541         try:\n1542             # if n contains hashable items there is some\n1543             # quick handling that can be done\n1544             u = len(set(n))\n1545             if u == 1:\n1546                 return nT(len(n), k)\n1547             elif u == len(n):\n1548                 n = range(u)\n1549             raise TypeError\n1550         except TypeError:\n1551             n = _multiset_histogram(n)\n1552     N = n[_N]\n1553     if k is None and N == 1:\n1554         return 1\n1555     if k in (1, N):\n1556         return 1\n1557     if k == 2 or N == 2 and k is None:\n1558         m, r = divmod(N, 2)\n1559         rv = sum(nC(n, i) for i in range(1, m + 1))\n1560         if not r:\n1561             rv -= nC(n, m)//2\n1562         if k is None:\n1563             rv += 1  # for k == 1\n1564         return rv\n1565     if N == n[_ITEMS]:\n1566         # all distinct\n1567         if k is None:\n1568             return bell(N)\n1569         return stirling(N, k)\n1570     m = MultisetPartitionTraverser()\n1571     if k is None:\n1572         return m.count_partitions(n[_M])\n1573     # MultisetPartitionTraverser does not have a range-limited count\n1574     # method, so need to enumerate and count\n1575     tot = 0\n1576     for discard in m.enum_range(n[_M], k-1, k):\n1577         tot += 1\n1578     return tot\n",
        "intended_behavior": "For `rf`, the expected mathematical behavior should calculate `n * (n + 1) * ... * (n + k - 1)` for `n` and `k`. Reverting changes should aim to realign the implementation with this mathematical formulation, ensuring any logic introducing deviations is corrected to adhere to previous, presumably correct, definitions."
    }
]