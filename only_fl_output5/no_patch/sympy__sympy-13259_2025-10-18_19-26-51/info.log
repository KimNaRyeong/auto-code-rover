2025-10-18 19:26:51.718 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 19:27:02.559 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=409, output_tokens=12, cost=0.004450
2025-10-18 19:27:12.181 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=589, output_tokens=375, cost=0.017140
2025-10-18 19:27:13.790 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:27:20.937 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=717, output_tokens=320, cost=0.016770
2025-10-18 19:27:20.944 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:27:24.353 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=674, output_tokens=81, cost=0.009170
2025-10-18 19:27:24.355 | DEBUG    | Extracted a valid json.
2025-10-18 19:27:24.355 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"simplify\")",
        "search_class(\"I\")",
        "search_method(\"cos\")",
        "search_method(\"cosh\")",
        "search_code(\"cos(pi/6 - I*asinh\")",
        "search_code(\"cosh(pi/6 + asinh\")"
    ],
    "bug_locations": []
}
2025-10-18 19:27:24.433 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 19:27:24.434 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 19:27:37.514 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2068, output_tokens=642, cost=0.039940
2025-10-18 19:27:37.524 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:27:49.015 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2926, output_tokens=468, cost=0.043300
2025-10-18 19:27:49.024 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:27:54.480 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=822, output_tokens=152, cost=0.012780
2025-10-18 19:27:54.481 | DEBUG    | Extracted a valid json.
2025-10-18 19:27:54.481 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/simplify/simplify.py",
            "class": "",
            "method": "",
            "intended_behavior": "The simplification logic should carefully handle trigonometric functions with complex arguments, ensuring that transformations between cos and cosh (or other trigonometric functions) respect the mathematical properties of complex numbers."
        },
        {
            "file": "sympy/core/expr.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that the expression handling and manipulation logic properly recognizes and preserves the subtleties of trigonometric functions with complex arguments during simplification."
        }
    ]
}
2025-10-18 19:27:54.491 | DEBUG    | Bug location extracted successfully: [<file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core import (Basic, S, Add, Mul, Pow,
6     Symbol, sympify, expand_mul, expand_func,
7     Function, Dummy, Expr, factor_terms,
8     symbols, expand_power_exp)
9 from sympy.core.compatibility import (iterable,
10     ordered, range, as_int)
11 from sympy.core.numbers import Float, I, pi, Rational, Integer
12 from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg, nfloat
13 from sympy.core.rules import Transform
14 from sympy.core.evaluate import global_evaluate
15 from sympy.functions import (
16     gamma, exp, sqrt, log, exp_polar, piecewise_fold)
17 from sympy.core.sympify import _sympify
18 from sympy.functions.elementary.exponential import ExpBase
19 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
20 from sympy.functions.elementary.integers import ceiling
21 from sympy.functions.elementary.complexes import unpolarify
22 from sympy.functions.elementary.trigonometric import TrigonometricFunction
23 from sympy.functions.combinatorial.factorials import CombinatorialFunction
24 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely
25 
26 from sympy.utilities.iterables import has_variety
27 
28 from sympy.simplify.radsimp import radsimp, fraction
29 from sympy.simplify.trigsimp import trigsimp, exptrigsimp
30 from sympy.simplify.powsimp import powsimp
31 from sympy.simplify.cse_opts import sub_pre, sub_post
32 from sympy.simplify.sqrtdenest import sqrtdenest
33 from sympy.simplify.combsimp import combsimp
34 
35 from sympy.polys import (together, cancel, factor)
36 
37 
38 import mpmath
39 
40 
41 
42 def separatevars(expr, symbols=[], dict=False, force=False):
43     """
44     Separates variables in an expression, if possible.  By
45     default, it separates with respect to all symbols in an
46     expression and collects constant coefficients that are
47     independent of symbols.
48 
49     If dict=True then the separated terms will be returned
50     in a dictionary keyed to their corresponding symbols.
51     By default, all symbols in the expression will appear as
52     keys; if symbols are provided, then all those symbols will
53     be used as keys, and any terms in the expression containing
54     other symbols or non-symbols will be returned keyed to the
55     string 'coeff'. (Passing None for symbols will return the
56     expression in a dictionary keyed to 'coeff'.)
57 
58     If force=True, then bases of powers will be separated regardless
59     of assumptions on the symbols involved.
60 
61     Notes
62     =====
63     The order of the factors is determined by Mul, so that the
64     separated expressions may not necessarily be grouped together.
65 
66     Although factoring is necessary to separate variables in some
67     expressions, it is not necessary in all cases, so one should not
68     count on the returned factors being factored.
69 
70     Examples
71     ========
72 
73     >>> from sympy.abc import x, y, z, alpha
74     >>> from sympy import separatevars, sin
75     >>> separatevars((x*y)**y)
76     (x*y)**y
77     >>> separatevars((x*y)**y, force=True)
78     x**y*y**y
79 
80     >>> e = 2*x**2*z*sin(y)+2*z*x**2
81     >>> separatevars(e)
82     2*x**2*z*(sin(y) + 1)
83     >>> separatevars(e, symbols=(x, y), dict=True)
84     {'coeff': 2*z, x: x**2, y: sin(y) + 1}
85     >>> separatevars(e, [x, y, alpha], dict=True)
86     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}
87 
88     If the expression is not really separable, or is only partially
89     separable, separatevars will do the best it can to separate it
90     by using factoring.
91 
92     >>> separatevars(x + x*y - 3*x**2)
93     -x*(3*x - y - 1)
94 
95     If the expression is not separable then expr is returned unchanged
96     or (if dict=True) then None is returned.
97 
98     >>> eq = 2*x + y*sin(x)
99     >>> separatevars(eq) == eq
100     True
101     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None
102     True
103 
104     """
105     expr = sympify(expr)
106     if dict:
107         return _separatevars_dict(_separatevars(expr, force), symbols)
108     else:
109         return _separatevars(expr, force)
110 
111 
112 def _separatevars(expr, force):
113     if len(expr.free_symbols) == 1:
114         return expr
115     # don't destroy a Mul since much of the work may already be done
116     if expr.is_Mul:
117         args = list(expr.args)
118         changed = False
119         for i, a in enumerate(args):
120             args[i] = separatevars(a, force)
121             changed = changed or args[i] != a
122         if changed:
123             expr = expr.func(*args)
124         return expr
125 
126     # get a Pow ready for expansion
127     if expr.is_Pow:
128         expr = Pow(separatevars(expr.base, force=force), expr.exp)
129 
130     # First try other expansion methods
131     expr = expr.expand(mul=False, multinomial=False, force=force)
132 
133     _expr, reps = posify(expr) if force else (expr, {})
134     expr = factor(_expr).subs(reps)
135 
136     if not expr.is_Add:
137         return expr
138 
139     # Find any common coefficients to pull out
140     args = list(expr.args)
141     commonc = args[0].args_cnc(cset=True, warn=False)[0]
142     for i in args[1:]:
143         commonc &= i.args_cnc(cset=True, warn=False)[0]
144     commonc = Mul(*commonc)
145     commonc = commonc.as_coeff_Mul()[1]  # ignore constants
146     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]
147 
148     # remove them
149     for i, a in enumerate(args):
150         c, nc = a.args_cnc(cset=True, warn=False)
151         c = c - commonc_set
152         args[i] = Mul(*c)*Mul(*nc)
153     nonsepar = Add(*args)
154 
155     if len(nonsepar.free_symbols) > 1:
156         _expr = nonsepar
157         _expr, reps = posify(_expr) if force else (_expr, {})
158         _expr = (factor(_expr)).subs(reps)
159 
160         if not _expr.is_Add:
161             nonsepar = _expr
162 
163     return commonc*nonsepar
164 
165 
166 def _separatevars_dict(expr, symbols):
167     if symbols:
168         if not all((t.is_Atom for t in symbols)):
169             raise ValueError("symbols must be Atoms.")
170         symbols = list(symbols)
171     elif symbols is None:
172         return {'coeff': expr}
173     else:
174         symbols = list(expr.free_symbols)
175         if not symbols:
176             return None
177 
178     ret = dict(((i, []) for i in symbols + ['coeff']))
179 
180     for i in Mul.make_args(expr):
181         expsym = i.free_symbols
182         intersection = set(symbols).intersection(expsym)
183         if len(intersection) > 1:
184             return None
185         if len(intersection) == 0:
186             # There are no symbols, so it is part of the coefficient
187             ret['coeff'].append(i)
188         else:
189             ret[intersection.pop()].append(i)
190 
191     # rebuild
192     for k, v in ret.items():
193         ret[k] = Mul(*v)
194 
195     return ret
196 
197 
198 def _is_sum_surds(p):
199     args = p.args if p.is_Add else [p]
200     for y in args:
201         if not ((y**2).is_Rational and y.is_real):
202             return False
203     return True
204 
205 
206 def posify(eq):
207     """Return eq (with generic symbols made positive) and a
208     dictionary containing the mapping between the old and new
209     symbols.
210 
211     Any symbol that has positive=None will be replaced with a positive dummy
212     symbol having the same name. This replacement will allow more symbolic
213     processing of expressions, especially those involving powers and
214     logarithms.
215 
216     A dictionary that can be sent to subs to restore eq to its original
217     symbols is also returned.
218 
219     >>> from sympy import posify, Symbol, log, solve
220     >>> from sympy.abc import x
221     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))
222     (_x + n + p, {_x: x})
223 
224     >>> eq = 1/x
225     >>> log(eq).expand()
226     log(1/x)
227     >>> log(posify(eq)[0]).expand()
228     -log(_x)
229     >>> p, rep = posify(eq)
230     >>> log(p).expand().subs(rep)
231     -log(x)
232 
233     It is possible to apply the same transformations to an iterable
234     of expressions:
235 
236     >>> eq = x**2 - 4
237     >>> solve(eq, x)
238     [-2, 2]
239     >>> eq_x, reps = posify([eq, x]); eq_x
240     [_x**2 - 4, _x]
241     >>> solve(*eq_x)
242     [2]
243     """
244     eq = sympify(eq)
245     if iterable(eq):
246         f = type(eq)
247         eq = list(eq)
248         syms = set()
249         for e in eq:
250             syms = syms.union(e.atoms(Symbol))
251         reps = {}
252         for s in syms:
253             reps.update(dict((v, k) for k, v in posify(s)[1].items()))
254         for i, e in enumerate(eq):
255             eq[i] = e.subs(reps)
256         return f(eq), {r: s for s, r in reps.items()}
257 
258     reps = dict([(s, Dummy(s.name, positive=True))
259                  for s in eq.free_symbols if s.is_positive is None])
260     eq = eq.subs(reps)
261     return eq, {r: s for s, r in reps.items()}
262 
263 
264 def hypersimp(f, k):
265     """Given combinatorial term f(k) simplify its consecutive term ratio
266        i.e. f(k+1)/f(k).  The input term can be composed of functions and
267        integer sequences which have equivalent representation in terms
268        of gamma special function.
269 
270        The algorithm performs three basic steps:
271 
272        1. Rewrite all functions in terms of gamma, if possible.
273 
274        2. Rewrite all occurrences of gamma in terms of products
275           of gamma and rising factorial with integer,  absolute
276           constant exponent.
277 
278        3. Perform simplification of nested fractions, powers
279           and if the resulting expression is a quotient of
280           polynomials, reduce their total degree.
281 
282        If f(k) is hypergeometric then as result we arrive with a
283        quotient of polynomials of minimal degree. Otherwise None
284        is returned.
285 
286        For more information on the implemented algorithm refer to:
287 
288        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,
289           Journal of Symbolic Computation (1995) 20, 399-417
290     """
291     f = sympify(f)
292 
293     g = f.subs(k, k + 1) / f
294 
295     g = g.rewrite(gamma)
296     g = expand_func(g)
297     g = powsimp(g, deep=True, combine='exp')
298 
299     if g.is_rational_function(k):
300         return simplify(g, ratio=S.Infinity)
301     else:
302         return None
303 
304 
305 def hypersimilar(f, g, k):
306     """Returns True if 'f' and 'g' are hyper-similar.
307 
308        Similarity in hypergeometric sense means that a quotient of
309        f(k) and g(k) is a rational function in k.  This procedure
310        is useful in solving recurrence relations.
311 
312        For more information see hypersimp().
313 
314     """
315     f, g = list(map(sympify, (f, g)))
316 
317     h = (f/g).rewrite(gamma)
318     h = h.expand(func=True, basic=False)
319 
320     return h.is_rational_function(k)
321 
322 
323 def signsimp(expr, evaluate=None):
324     """Make all Add sub-expressions canonical wrt sign.
325 
326     If an Add subexpression, ``a``, can have a sign extracted,
327     as determined by could_extract_minus_sign, it is replaced
328     with Mul(-1, a, evaluate=False). This allows signs to be
329     extracted from powers and products.
330 
331     Examples
332     ========
333 
334     >>> from sympy import signsimp, exp, symbols
335     >>> from sympy.abc import x, y
336     >>> i = symbols('i', odd=True)
337     >>> n = -1 + 1/x
338     >>> n/x/(-n)**2 - 1/n/x
339     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
340     >>> signsimp(_)
341     0
342     >>> x*n + x*-n
343     x*(-1 + 1/x) + x*(1 - 1/x)
344     >>> signsimp(_)
345     0
346 
347     Since powers automatically handle leading signs
348 
349     >>> (-2)**i
350     -2**i
351 
352     signsimp can be used to put the base of a power with an integer
353     exponent into canonical form:
354 
355     >>> n**i
356     (-1 + 1/x)**i
357 
358     By default, signsimp doesn't leave behind any hollow simplification:
359     if making an Add canonical wrt sign didn't change the expression, the
360     original Add is restored. If this is not desired then the keyword
361     ``evaluate`` can be set to False:
362 
363     >>> e = exp(y - x)
364     >>> signsimp(e) == e
365     True
366     >>> signsimp(e, evaluate=False)
367     exp(-(x - y))
368 
369     """
370     if evaluate is None:
371         evaluate = global_evaluate[0]
372     expr = sympify(expr)
373     if not isinstance(expr, Expr) or expr.is_Atom:
374         return expr
375     e = sub_post(sub_pre(expr))
376     if not isinstance(e, Expr) or e.is_Atom:
377         return e
378     if e.is_Add:
379         return e.func(*[signsimp(a, evaluate) for a in e.args])
380     if evaluate:
381         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})
382     return e
383 
384 
385 def simplify(expr, ratio=1.7, measure=count_ops, rational=False):
386     # type: (object, object, object, object) -> object
387     """
388     Simplifies the given expression.
389 
390     Simplification is not a well defined term and the exact strategies
391     this function tries can change in the future versions of SymPy. If
392     your algorithm relies on "simplification" (whatever it is), try to
393     determine what you need exactly  -  is it powsimp()?, radsimp()?,
394     together()?, logcombine()?, or something else? And use this particular
395     function directly, because those are well defined and thus your algorithm
396     will be robust.
397 
398     Nonetheless, especially for interactive use, or when you don't know
399     anything about the structure of the expression, simplify() tries to apply
400     intelligent heuristics to make the input expression "simpler".  For
401     example:
402 
403     >>> from sympy import simplify, cos, sin
404     >>> from sympy.abc import x, y
405     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
406     >>> a
407     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
408     >>> simplify(a)
409     x + 1
410 
411     Note that we could have obtained the same result by using specific
412     simplification functions:
413 
414     >>> from sympy import trigsimp, cancel
415     >>> trigsimp(a)
416     (x**2 + x)/x
417     >>> cancel(_)
418     x + 1
419 
420     In some cases, applying :func:`simplify` may actually result in some more
421     complicated expression. The default ``ratio=1.7`` prevents more extreme
422     cases: if (result length)/(input length) > ratio, then input is returned
423     unmodified.  The ``measure`` parameter lets you specify the function used
424     to determine how complex an expression is.  The function should take a
425     single argument as an expression and return a number such that if
426     expression ``a`` is more complex than expression ``b``, then
427     ``measure(a) > measure(b)``.  The default measure function is
428     :func:`count_ops`, which returns the total number of operations in the
429     expression.
430 
431     For example, if ``ratio=1``, ``simplify`` output can't be longer
432     than input.
433 
434     ::
435 
436         >>> from sympy import sqrt, simplify, count_ops, oo
437         >>> root = 1/(sqrt(2)+3)
438 
439     Since ``simplify(root)`` would result in a slightly longer expression,
440     root is returned unchanged instead::
441 
442        >>> simplify(root, ratio=1) == root
443        True
444 
445     If ``ratio=oo``, simplify will be applied anyway::
446 
447         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
448         True
449 
450     Note that the shortest expression is not necessary the simplest, so
451     setting ``ratio`` to 1 may not be a good idea.
452     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
453     choice.
454 
455     You can easily define your own measure function based on what you feel
456     should represent the "size" or "complexity" of the input expression.  Note
457     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
458     good metrics, but have other problems (in this case, the measure function
459     may slow down simplify too much for very large expressions).  If you don't
460     know what a good metric would be, the default, ``count_ops``, is a good
461     one.
462 
463     For example:
464 
465     >>> from sympy import symbols, log
466     >>> a, b = symbols('a b', positive=True)
467     >>> g = log(a) + log(b) + log(a)*log(1/b)
468     >>> h = simplify(g)
469     >>> h
470     log(a*b**(-log(a) + 1))
471     >>> count_ops(g)
472     8
473     >>> count_ops(h)
474     5
475 
476     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
477     However, we may not like how ``simplify`` (in this case, using
478     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
479     to reduce this would be to give more weight to powers as operations in
480     ``count_ops``.  We can do this by using the ``visual=True`` option:
481 
482     >>> print(count_ops(g, visual=True))
483     2*ADD + DIV + 4*LOG + MUL
484     >>> print(count_ops(h, visual=True))
485     2*LOG + MUL + POW + SUB
486 
487     >>> from sympy import Symbol, S
488     >>> def my_measure(expr):
489     ...     POW = Symbol('POW')
490     ...     # Discourage powers by giving POW a weight of 10
491     ...     count = count_ops(expr, visual=True).subs(POW, 10)
492     ...     # Every other operation gets a weight of 1 (the default)
493     ...     count = count.replace(Symbol, type(S.One))
494     ...     return count
495     >>> my_measure(g)
496     8
497     >>> my_measure(h)
498     14
499     >>> 15./8 > 1.7 # 1.7 is the default ratio
500     True
501     >>> simplify(g, measure=my_measure)
502     -log(a)*log(b) + log(a) + log(b)
503 
504     Note that because ``simplify()`` internally tries many different
505     simplification strategies and then compares them using the measure
506     function, we get a completely different result that is still different
507     from the input expression by doing this.
508 
509     If rational=True, Floats will be recast as Rationals before simplification.
510     If rational=None, Floats will be recast as Rationals but the result will
511     be recast as Floats. If rational=False(default) then nothing will be done
512     to the Floats.
513     """
514     expr = sympify(expr)
515 
516     try:
517         return expr._eval_simplify(ratio=ratio, measure=measure)
518     except AttributeError:
519         pass
520 
521     original_expr = expr = signsimp(expr)
522 
523     from sympy.simplify.hyperexpand import hyperexpand
524     from sympy.functions.special.bessel import BesselBase
525     from sympy import Sum, Product
526 
527     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
528         return expr
529 
530     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):
531         if isinstance(expr, Function) and hasattr(expr, "inverse"):
532             if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \
533                isinstance(expr.args[0], expr.inverse(argindex=1)):
534                 return simplify(expr.args[0].args[0], ratio=ratio,
535                                 measure=measure, rational=rational)
536         return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)
537                          for x in expr.args])
538 
539     # TODO: Apply different strategies, considering expression pattern:
540     # is it a purely rational function? Is there any trigonometric function?...
541     # See also https://github.com/sympy/sympy/pull/185.
542 
543     def shorter(*choices):
544         '''Return the choice that has the fewest ops. In case of a tie,
545         the expression listed first is selected.'''
546         if not has_variety(choices):
547             return choices[0]
548         return min(choices, key=measure)
549 
550     # rationalize Floats
551     floats = False
552     if rational is not False and expr.has(Float):
553         floats = True
554         expr = nsimplify(expr, rational=True)
555 
556     expr = bottom_up(expr, lambda w: w.normal())
557     expr = Mul(*powsimp(expr).as_content_primitive())
558     _e = cancel(expr)
559     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
560     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
561 
562     if ratio is S.Infinity:
563         expr = expr2
564     else:
565         expr = shorter(expr2, expr1, expr)
566     if not isinstance(expr, Basic):  # XXX: temporary hack
567         return expr
568 
569     expr = factor_terms(expr, sign=False)
570 
571     # hyperexpand automatically only works on hypergeometric terms
572     expr = hyperexpand(expr)
573 
574     expr = piecewise_fold(expr)
575 
576     if expr.has(BesselBase):
577         expr = besselsimp(expr)
578 
579     if expr.has(TrigonometricFunction, HyperbolicFunction):
580         expr = trigsimp(expr, deep=True)
581 
582     if expr.has(log):
583         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
584 
585     if expr.has(CombinatorialFunction, gamma):
586         # expression with gamma functions or non-integer arguments is
587         # automatically passed to gammasimp
588         expr = combsimp(expr)
589 
590     if expr.has(Sum):
591         expr = sum_simplify(expr)
592 
593     if expr.has(Product):
594         expr = product_simplify(expr)
595 
596     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
597     short = shorter(short, cancel(short))
598     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
599     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
600         short = exptrigsimp(short)
601 
602     # get rid of hollow 2-arg Mul factorization
603     hollow_mul = Transform(
604         lambda x: Mul(*x.args),
605         lambda x:
606         x.is_Mul and
607         len(x.args) == 2 and
608         x.args[0].is_Number and
609         x.args[1].is_Add and
610         x.is_commutative)
611     expr = short.xreplace(hollow_mul)
612 
613     numer, denom = expr.as_numer_denom()
614     if denom.is_Add:
615         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
616         if n is not S.One:
617             expr = (numer*n).expand()/d
618 
619     if expr.could_extract_minus_sign():
620         n, d = fraction(expr)
621         if d != 0:
622             expr = signsimp(-n/(-d))
623 
624     if measure(expr) > ratio*measure(original_expr):
625         expr = original_expr
626 
627     # restore floats
628     if floats and rational is None:
629         expr = nfloat(expr, exponent=False)
630 
631     return expr
632 
633 
634 def sum_simplify(s):
635     """Main function for Sum simplification"""
636     from sympy.concrete.summations import Sum
637     from sympy.core.function import expand
638 
639     terms = Add.make_args(expand(s))
640     s_t = [] # Sum Terms
641     o_t = [] # Other Terms
642 
643     for term in terms:
644         if isinstance(term, Mul):
645             other = 1
646             sum_terms = []
647 
648             if not term.has(Sum):
649                 o_t.append(term)
650                 continue
651 
652             mul_terms = Mul.make_args(term)
653             for mul_term in mul_terms:
654                 if isinstance(mul_term, Sum):
655                     r = mul_term._eval_simplify()
656                     sum_terms.extend(Add.make_args(r))
657                 else:
658                     other = other * mul_term
659             if len(sum_terms):
660                 #some simplification may have happened
661                 #use if so
662                 s_t.append(Mul(*sum_terms) * other)
663             else:
664                 o_t.append(other)
665         elif isinstance(term, Sum):
666             #as above, we need to turn this into an add list
667             r = term._eval_simplify()
668             s_t.extend(Add.make_args(r))
669         else:
670             o_t.append(term)
671 
672 
673     result = Add(sum_combine(s_t), *o_t)
674 
675     return result
676 
677 def sum_combine(s_t):
678     """Helper function for Sum simplification
679 
680        Attempts to simplify a list of sums, by combining limits / sum function's
681        returns the simplified sum
682     """
683     from sympy.concrete.summations import Sum
684 
685 
686     used = [False] * len(s_t)
687 
688     for method in range(2):
689         for i, s_term1 in enumerate(s_t):
690             if not used[i]:
691                 for j, s_term2 in enumerate(s_t):
692                     if not used[j] and i != j:
693                         temp = sum_add(s_term1, s_term2, method)
694                         if isinstance(temp, Sum) or isinstance(temp, Mul):
695                             s_t[i] = temp
696                             s_term1 = s_t[i]
697                             used[j] = True
698 
699     result = S.Zero
700     for i, s_term in enumerate(s_t):
701         if not used[i]:
702             result = Add(result, s_term)
703 
704     return result
705 
706 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):
707     """Helper function for Sum simplification
708 
709        if limits is specified, "self" is the inner part of a sum
710 
711        Returns the sum with constant factors brought outside
712     """
713     from sympy.core.exprtools import factor_terms
714     from sympy.concrete.summations import Sum
715 
716     result = self.function if limits is None else self
717     limits = self.limits if limits is None else limits
718     #avoid any confusion w/ as_independent
719     if result == 0:
720         return S.Zero
721 
722     #get the summation variables
723     sum_vars = set([limit.args[0] for limit in limits])
724 
725     #finally we try to factor out any common terms
726     #and remove the from the sum if independent
727     retv = factor_terms(result, radical=radical, clear=clear, fraction=fraction, sign=sign)
728     #avoid doing anything bad
729     if not result.is_commutative:
730         return Sum(result, *limits)
731 
732     i, d = retv.as_independent(*sum_vars)
733     if isinstance(retv, Add):
734         return i * Sum(1, *limits) + Sum(d, *limits)
735     else:
736         return i * Sum(d, *limits)
737 
738 def sum_add(self, other, method=0):
739     """Helper function for Sum simplification"""
740     from sympy.concrete.summations import Sum
741     from sympy import Mul
742 
743     #we know this is something in terms of a constant * a sum
744     #so we temporarily put the constants inside for simplification
745     #then simplify the result
746     def __refactor(val):
747         args = Mul.make_args(val)
748         sumv = next(x for x in args if isinstance(x, Sum))
749         constant = Mul(*[x for x in args if x != sumv])
750         return Sum(constant * sumv.function, *sumv.limits)
751 
752     if isinstance(self, Mul):
753         rself = __refactor(self)
754     else:
755         rself = self
756 
757     if isinstance(other, Mul):
758         rother = __refactor(other)
759     else:
760         rother = other
761 
762     if type(rself) == type(rother):
763         if method == 0:
764             if rself.limits == rother.limits:
765                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))
766         elif method == 1:
767             if simplify(rself.function - rother.function) == 0:
768                 if len(rself.limits) == len(rother.limits) == 1:
769                     i = rself.limits[0][0]
770                     x1 = rself.limits[0][1]
771                     y1 = rself.limits[0][2]
772                     j = rother.limits[0][0]
773                     x2 = rother.limits[0][1]
774                     y2 = rother.limits[0][2]
775 
776                     if i == j:
777                         if x2 == y1 + 1:
778                             return factor_sum(Sum(rself.function, (i, x1, y2)))
779                         elif x1 == y2 + 1:
780                             return factor_sum(Sum(rself.function, (i, x2, y1)))
781 
782     return Add(self, other)
783 
784 
785 def product_simplify(s):
786     """Main function for Product simplification"""
787     from sympy.concrete.products import Product
788 
789     terms = Mul.make_args(s)
790     p_t = [] # Product Terms
791     o_t = [] # Other Terms
792 
793     for term in terms:
794         if isinstance(term, Product):
795             p_t.append(term)
796         else:
797             o_t.append(term)
798 
799     used = [False] * len(p_t)
800 
801     for method in range(2):
802         for i, p_term1 in enumerate(p_t):
803             if not used[i]:
804                 for j, p_term2 in enumerate(p_t):
805                     if not used[j] and i != j:
806                         if isinstance(product_mul(p_term1, p_term2, method), Product):
807                             p_t[i] = product_mul(p_term1, p_term2, method)
808                             used[j] = True
809 
810     result = Mul(*o_t)
811 
812     for i, p_term in enumerate(p_t):
813         if not used[i]:
814             result = Mul(result, p_term)
815 
816     return result
817 
818 
819 def product_mul(self, other, method=0):
820     """Helper function for Product simplification"""
821     from sympy.concrete.products import Product
822 
823     if type(self) == type(other):
824         if method == 0:
825             if self.limits == other.limits:
826                 return Product(self.function * other.function, *self.limits)
827         elif method == 1:
828             if simplify(self.function - other.function) == 0:
829                 if len(self.limits) == len(other.limits) == 1:
830                     i = self.limits[0][0]
831                     x1 = self.limits[0][1]
832                     y1 = self.limits[0][2]
833                     j = other.limits[0][0]
834                     x2 = other.limits[0][1]
835                     y2 = other.limits[0][2]
836 
837                     if i == j:
838                         if x2 == y1 + 1:
839                             return Product(self.function, (i, x1, y2))
840                         elif x1 == y2 + 1:
841                             return Product(self.function, (i, x2, y1))
842 
843     return Mul(self, other)
844 
845 
846 def _nthroot_solve(p, n, prec):
847     """
848      helper function for ``nthroot``
849      It denests ``p**Rational(1, n)`` using its minimal polynomial
850     """
851     from sympy.polys.numberfields import _minimal_polynomial_sq
852     from sympy.solvers import solve
853     while n % 2 == 0:
854         p = sqrtdenest(sqrt(p))
855         n = n // 2
856     if n == 1:
857         return p
858     pn = p**Rational(1, n)
859     x = Symbol('x')
860     f = _minimal_polynomial_sq(p, n, x)
861     if f is None:
862         return None
863     sols = solve(f, x)
864     for sol in sols:
865         if abs(sol - pn).n() < 1./10**prec:
866             sol = sqrtdenest(sol)
867             if _mexpand(sol**n) == p:
868                 return sol
869 
870 
871 def logcombine(expr, force=False):
872     """
873     Takes logarithms and combines them using the following rules:
874 
875     - log(x) + log(y) == log(x*y) if both are not negative
876     - a*log(x) == log(x**a) if x is positive and a is real
877 
878     If ``force`` is True then the assumptions above will be assumed to hold if
879     there is no assumption already in place on a quantity. For example, if
880     ``a`` is imaginary or the argument negative, force will not perform a
881     combination but if ``a`` is a symbol with no assumptions the change will
882     take place.
883 
884     Examples
885     ========
886 
887     >>> from sympy import Symbol, symbols, log, logcombine, I
888     >>> from sympy.abc import a, x, y, z
889     >>> logcombine(a*log(x) + log(y) - log(z))
890     a*log(x) + log(y) - log(z)
891     >>> logcombine(a*log(x) + log(y) - log(z), force=True)
892     log(x**a*y/z)
893     >>> x,y,z = symbols('x,y,z', positive=True)
894     >>> a = Symbol('a', real=True)
895     >>> logcombine(a*log(x) + log(y) - log(z))
896     log(x**a*y/z)
897 
898     The transformation is limited to factors and/or terms that
899     contain logs, so the result depends on the initial state of
900     expansion:
901 
902     >>> eq = (2 + 3*I)*log(x)
903     >>> logcombine(eq, force=True) == eq
904     True
905     >>> logcombine(eq.expand(), force=True)
906     log(x**2) + I*log(x**3)
907 
908     See Also
909     ========
910     posify: replace all symbols with symbols having positive assumptions
911 
912     """
913 
914     def f(rv):
915         if not (rv.is_Add or rv.is_Mul):
916             return rv
917 
918         def gooda(a):
919             # bool to tell whether the leading ``a`` in ``a*log(x)``
920             # could appear as log(x**a)
921             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow
922                 (a.is_real or force and a.is_real is not False))
923 
924         def goodlog(l):
925             # bool to tell whether log ``l``'s argument can combine with others
926             a = l.args[0]
927             return a.is_positive or force and a.is_nonpositive is not False
928 
929         other = []
930         logs = []
931         log1 = defaultdict(list)
932         for a in Add.make_args(rv):
933             if a.func is log and goodlog(a):
934                 log1[()].append(([], a))
935             elif not a.is_Mul:
936                 other.append(a)
937             else:
938                 ot = []
939                 co = []
940                 lo = []
941                 for ai in a.args:
942                     if ai.is_Rational and ai < 0:
943                         ot.append(S.NegativeOne)
944                         co.append(-ai)
945                     elif ai.func is log and goodlog(ai):
946                         lo.append(ai)
947                     elif gooda(ai):
948                         co.append(ai)
949                     else:
950                         ot.append(ai)
951                 if len(lo) > 1:
952                     logs.append((ot, co, lo))
953                 elif lo:
954                     log1[tuple(ot)].append((co, lo[0]))
955                 else:
956                     other.append(a)
957 
958         # if there is only one log at each coefficient and none have
959         # an exponent to place inside the log then there is nothing to do
960         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):
961             return rv
962 
963         # collapse multi-logs as far as possible in a canonical way
964         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?
965         # -- in this case, it's unambiguous, but if it were were a log(c) in
966         # each term then it's arbitrary whether they are grouped by log(a) or
967         # by log(c). So for now, just leave this alone; it's probably better to
968         # let the user decide
969         for o, e, l in logs:
970             l = list(ordered(l))
971             e = log(l.pop(0).args[0]**Mul(*e))
972             while l:
973                 li = l.pop(0)
974                 e = log(li.args[0]**e)
975             c, l = Mul(*o), e
976             if l.func is log:  # it should be, but check to be sure
977                 log1[(c,)].append(([], l))
978             else:
979                 other.append(c*l)
980 
981         # logs that have the same coefficient can multiply
982         for k in list(log1.keys()):
983             log1[Mul(*k)] = log(logcombine(Mul(*[
984                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),
985                 force=force))
986 
987         # logs that have oppositely signed coefficients can divide
988         for k in ordered(list(log1.keys())):
989             if not k in log1:  # already popped as -k
990                 continue
991             if -k in log1:
992                 # figure out which has the minus sign; the one with
993                 # more op counts should be the one
994                 num, den = k, -k
995                 if num.count_ops() > den.count_ops():
996                     num, den = den, num
997                 other.append(num*log(log1.pop(num).args[0]/log1.pop(den).args[0]))
998             else:
999                 other.append(k*log1.pop(k))
1000 
1001         return Add(*other)
1002 
1003     return bottom_up(expr, f)
1004 
1005 
1006 def bottom_up(rv, F, atoms=False, nonbasic=False):
1007     """Apply ``F`` to all expressions in an expression tree from the
1008     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;
1009     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.
1010     """
1011     try:
1012         if rv.args:
1013             args = tuple([bottom_up(a, F, atoms, nonbasic)
1014                 for a in rv.args])
1015             if args != rv.args:
1016                 rv = rv.func(*args)
1017             rv = F(rv)
1018         elif atoms:
1019             rv = F(rv)
1020     except AttributeError:
1021         if nonbasic:
1022             try:
1023                 rv = F(rv)
1024             except TypeError:
1025                 pass
1026 
1027     return rv
1028 
1029 
1030 def besselsimp(expr):
1031     """
1032     Simplify bessel-type functions.
1033 
1034     This routine tries to simplify bessel-type functions. Currently it only
1035     works on the Bessel J and I functions, however. It works by looking at all
1036     such functions in turn, and eliminating factors of "I" and "-1" (actually
1037     their polar equivalents) in front of the argument. Then, functions of
1038     half-integer order are rewritten using strigonometric functions and
1039     functions of integer order (> 1) are rewritten using functions
1040     of low order.  Finally, if the expression was changed, compute
1041     factorization of the result with factor().
1042 
1043     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S
1044     >>> from sympy.abc import z, nu
1045     >>> besselsimp(besselj(nu, z*polar_lift(-1)))
1046     exp(I*pi*nu)*besselj(nu, z)
1047     >>> besselsimp(besseli(nu, z*polar_lift(-I)))
1048     exp(-I*pi*nu/2)*besselj(nu, z)
1049     >>> besselsimp(besseli(S(-1)/2, z))
1050     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))
1051     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))
1052     3*z*besseli(0, z)/2
1053     """
1054     # TODO
1055     # - better algorithm?
1056     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...
1057     # - use contiguity relations?
1058 
1059     def replacer(fro, to, factors):
1060         factors = set(factors)
1061 
1062         def repl(nu, z):
1063             if factors.intersection(Mul.make_args(z)):
1064                 return to(nu, z)
1065             return fro(nu, z)
1066         return repl
1067 
1068     def torewrite(fro, to):
1069         def tofunc(nu, z):
1070             return fro(nu, z).rewrite(to)
1071         return tofunc
1072 
1073     def tominus(fro):
1074         def tofunc(nu, z):
1075             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)
1076         return tofunc
1077 
1078     orig_expr = expr
1079 
1080     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]
1081     expr = expr.replace(
1082         besselj, replacer(besselj,
1083         torewrite(besselj, besseli), ifactors))
1084     expr = expr.replace(
1085         besseli, replacer(besseli,
1086         torewrite(besseli, besselj), ifactors))
1087 
1088     minusfactors = [-1, exp_polar(I*pi)]
1089     expr = expr.replace(
1090         besselj, replacer(besselj, tominus(besselj), minusfactors))
1091     expr = expr.replace(
1092         besseli, replacer(besseli, tominus(besseli), minusfactors))
1093 
1094     z0 = Dummy('z')
1095 
1096     def expander(fro):
1097         def repl(nu, z):
1098             if (nu % 1) == S(1)/2:
1099                 return simplify(trigsimp(unpolarify(
1100                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(
1101                             func=True)).subs(z0, z)))
1102             elif nu.is_Integer and nu > 1:
1103                 return fro(nu, z).expand(func=True)
1104             return fro(nu, z)
1105         return repl
1106 
1107     expr = expr.replace(besselj, expander(besselj))
1108     expr = expr.replace(bessely, expander(bessely))
1109     expr = expr.replace(besseli, expander(besseli))
1110     expr = expr.replace(besselk, expander(besselk))
1111 
1112     if expr != orig_expr:
1113         expr = expr.factor()
1114 
1115     return expr
1116 
1117 
1118 def nthroot(expr, n, max_len=4, prec=15):
1119     """
1120     compute a real nth-root of a sum of surds
1121 
1122     Parameters
1123     ==========
1124 
1125     expr : sum of surds
1126     n : integer
1127     max_len : maximum number of surds passed as constants to ``nsimplify``
1128 
1129     Algorithm
1130     =========
1131 
1132     First ``nsimplify`` is used to get a candidate root; if it is not a
1133     root the minimal polynomial is computed; the answer is one of its
1134     roots.
1135 
1136     Examples
1137     ========
1138 
1139     >>> from sympy.simplify.simplify import nthroot
1140     >>> from sympy import Rational, sqrt
1141     >>> nthroot(90 + 34*sqrt(7), 3)
1142     sqrt(7) + 3
1143 
1144     """
1145     expr = sympify(expr)
1146     n = sympify(n)
1147     p = expr**Rational(1, n)
1148     if not n.is_integer:
1149         return p
1150     if not _is_sum_surds(expr):
1151         return p
1152     surds = []
1153     coeff_muls = [x.as_coeff_Mul() for x in expr.args]
1154     for x, y in coeff_muls:
1155         if not x.is_rational:
1156             return p
1157         if y is S.One:
1158             continue
1159         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):
1160             return p
1161         surds.append(y)
1162     surds.sort()
1163     surds = surds[:max_len]
1164     if expr < 0 and n % 2 == 1:
1165         p = (-expr)**Rational(1, n)
1166         a = nsimplify(p, constants=surds)
1167         res = a if _mexpand(a**n) == _mexpand(-expr) else p
1168         return -res
1169     a = nsimplify(p, constants=surds)
1170     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):
1171         return _mexpand(a)
1172     expr = _nthroot_solve(expr, n, prec)
1173     if expr is None:
1174         return p
1175     return expr
1176 
1177 
1178 def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,
1179     rational_conversion='base10'):
1180     """
1181     Find a simple representation for a number or, if there are free symbols or
1182     if rational=True, then replace Floats with their Rational equivalents. If
1183     no change is made and rational is not False then Floats will at least be
1184     converted to Rationals.
1185 
1186     For numerical expressions, a simple formula that numerically matches the
1187     given numerical expression is sought (and the input should be possible
1188     to evalf to a precision of at least 30 digits).
1189 
1190     Optionally, a list of (rationally independent) constants to
1191     include in the formula may be given.
1192 
1193     A lower tolerance may be set to find less exact matches. If no tolerance
1194     is given then the least precise value will set the tolerance (e.g. Floats
1195     default to 15 digits of precision, so would be tolerance=10**-15).
1196 
1197     With full=True, a more extensive search is performed
1198     (this is useful to find simpler numbers when the tolerance
1199     is set low).
1200 
1201     When converting to rational, if rational_conversion='base10' (the default), then
1202     convert floats to rationals using their base-10 (string) representation.
1203     When rational_conversion='exact' it uses the exact, base-2 representation.
1204 
1205     Examples
1206     ========
1207 
1208     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi
1209     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])
1210     -2 + 2*GoldenRatio
1211     >>> nsimplify((1/(exp(3*pi*I/5)+1)))
1212     1/2 - I*sqrt(sqrt(5)/10 + 1/4)
1213     >>> nsimplify(I**I, [pi])
1214     exp(-pi/2)
1215     >>> nsimplify(pi, tolerance=0.01)
1216     22/7
1217 
1218     >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')
1219     6004799503160655/18014398509481984
1220     >>> nsimplify(0.333333333333333, rational=True)
1221     1/3
1222 
1223     See Also
1224     ========
1225     sympy.core.function.nfloat
1226 
1227     """
1228     try:
1229         return sympify(as_int(expr))
1230     except (TypeError, ValueError):
1231         pass
1232     expr = sympify(expr).xreplace({
1233         Float('inf'): S.Infinity,
1234         Float('-inf'): S.NegativeInfinity,
1235         })
1236     if expr is S.Infinity or expr is S.NegativeInfinity:
1237         return expr
1238     if rational or expr.free_symbols:
1239         return _real_to_rational(expr, tolerance, rational_conversion)
1240 
1241     # SymPy's default tolerance for Rationals is 15; other numbers may have
1242     # lower tolerances set, so use them to pick the largest tolerance if None
1243     # was given
1244     if tolerance is None:
1245         tolerance = 10**-min([15] +
1246              [mpmath.libmp.libmpf.prec_to_dps(n._prec)
1247              for n in expr.atoms(Float)])
1248     # XXX should prec be set independent of tolerance or should it be computed
1249     # from tolerance?
1250     prec = 30
1251     bprec = int(prec*3.33)
1252 
1253     constants_dict = {}
1254     for constant in constants:
1255         constant = sympify(constant)
1256         v = constant.evalf(prec)
1257         if not v.is_Float:
1258             raise ValueError("constants must be real-valued")
1259         constants_dict[str(constant)] = v._to_mpmath(bprec)
1260 
1261     exprval = expr.evalf(prec, chop=True)
1262     re, im = exprval.as_real_imag()
1263 
1264     # safety check to make sure that this evaluated to a number
1265     if not (re.is_Number and im.is_Number):
1266         return expr
1267 
1268     def nsimplify_real(x):
1269         orig = mpmath.mp.dps
1270         xv = x._to_mpmath(bprec)
1271         try:
1272             # We'll be happy with low precision if a simple fraction
1273             if not (tolerance or full):
1274                 mpmath.mp.dps = 15
1275                 rat = mpmath.pslq([xv, 1])
1276                 if rat is not None:
1277                     return Rational(-int(rat[1]), int(rat[0]))
1278             mpmath.mp.dps = prec
1279             newexpr = mpmath.identify(xv, constants=constants_dict,
1280                 tol=tolerance, full=full)
1281             if not newexpr:
1282                 raise ValueError
1283             if full:
1284                 newexpr = newexpr[0]
1285             expr = sympify(newexpr)
1286             if x and not expr:  # don't let x become 0
1287                 raise ValueError
1288             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:
1289                 raise ValueError
1290             return expr
1291         finally:
1292             # even though there are returns above, this is executed
1293             # before leaving
1294             mpmath.mp.dps = orig
1295     try:
1296         if re:
1297             re = nsimplify_real(re)
1298         if im:
1299             im = nsimplify_real(im)
1300     except ValueError:
1301         if rational is None:
1302             return _real_to_rational(expr, rational_conversion=rational_conversion)
1303         return expr
1304 
1305     rv = re + im*S.ImaginaryUnit
1306     # if there was a change or rational is explicitly not wanted
1307     # return the value, else return the Rational representation
1308     if rv != expr or rational is False:
1309         return rv
1310     return _real_to_rational(expr, rational_conversion=rational_conversion)
1311 
1312 
1313 def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):
1314     """
1315     Replace all reals in expr with rationals.
1316 
1317     >>> from sympy import Rational
1318     >>> from sympy.simplify.simplify import _real_to_rational
1319     >>> from sympy.abc import x
1320 
1321     >>> _real_to_rational(.76 + .1*x**.5)
1322     sqrt(x)/10 + 19/25
1323 
1324     If rational_conversion='base10', this uses the base-10 string. If
1325     rational_conversion='exact', the exact, base-2 representation is used.
1326 
1327     >>> _real_to_rational(0.333333333333333, rational_conversion='exact')
1328     6004799503160655/18014398509481984
1329     >>> _real_to_rational(0.333333333333333)
1330     1/3
1331 
1332     """
1333     expr = _sympify(expr)
1334     inf = Float('inf')
1335     p = expr
1336     reps = {}
1337     reduce_num = None
1338     if tolerance is not None and tolerance < 1:
1339         reduce_num = ceiling(1/tolerance)
1340     for fl in p.atoms(Float):
1341         key = fl
1342         if reduce_num is not None:
1343             r = Rational(fl).limit_denominator(reduce_num)
1344         elif (tolerance is not None and tolerance >= 1 and
1345                 fl.is_Integer is False):
1346             r = Rational(tolerance*round(fl/tolerance)
1347                 ).limit_denominator(int(tolerance))
1348         else:
1349             if rational_conversion == 'exact':
1350                 r = Rational(fl)
1351                 reps[key] = r
1352                 continue
1353             elif rational_conversion != 'base10':
1354                 raise ValueError("rational_conversion must be 'base10' or 'exact'")
1355 
1356             r = nsimplify(fl, rational=False)
1357             # e.g. log(3).n() -> log(3) instead of a Rational
1358             if fl and not r:
1359                 r = Rational(fl)
1360             elif not r.is_Rational:
1361                 if fl == inf or fl == -inf:
1362                     r = S.ComplexInfinity
1363                 elif fl < 0:
1364                     fl = -fl
1365                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1366                     r = -Rational(str(fl/d))*d
1367                 elif fl > 0:
1368                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1369                     r = Rational(str(fl/d))*d
1370                 else:
1371                     r = Integer(0)
1372         reps[key] = r
1373     return p.subs(reps, simultaneous=True)
1374 
1375 
1376 def clear_coefficients(expr, rhs=S.Zero):
1377     """Return `p, r` where `p` is the expression obtained when Rational
1378     additive and multiplicative coefficients of `expr` have been stripped
1379     away in a naive fashion (i.e. without simplification). The operations
1380     needed to remove the coefficients will be applied to `rhs` and returned
1381     as `r`.
1382 
1383     Examples
1384     ========
1385 
1386     >>> from sympy.simplify.simplify import clear_coefficients
1387     >>> from sympy.abc import x, y
1388     >>> from sympy import Dummy
1389     >>> expr = 4*y*(6*x + 3)
1390     >>> clear_coefficients(expr - 2)
1391     (y*(2*x + 1), 1/6)
1392 
1393     When solving 2 or more expressions like `expr = a`,
1394     `expr = b`, etc..., it is advantageous to provide a Dummy symbol
1395     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.
1396 
1397     >>> rhs = Dummy('rhs')
1398     >>> clear_coefficients(expr, rhs)
1399     (y*(2*x + 1), _rhs/12)
1400     >>> _[1].subs(rhs, 2)
1401     1/6
1402     """
1403     was = None
1404     free = expr.free_symbols
1405     if expr.is_Rational:
1406         return (S.Zero, rhs - expr)
1407     while expr and was != expr:
1408         was = expr
1409         m, expr = (
1410             expr.as_content_primitive()
1411             if free else
1412             factor_terms(expr).as_coeff_Mul(rational=True))
1413         rhs /= m
1414         c, expr = expr.as_coeff_Add(rational=True)
1415         rhs -= c
1416     expr = signsimp(expr, evaluate = False)
1417     if _coeff_isneg(expr):
1418         expr = -expr
1419         rhs = -rhs
1420     return expr, rhs

</code><intended_behavior>The simplification logic should carefully handle trigonometric functions with complex arguments, ensuring that transformations between cos and cosh (or other trigonometric functions) respect the mathematical properties of complex numbers.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from .sympify import sympify, _sympify, SympifyError
4 from .basic import Basic, Atom
5 from .singleton import S
6 from .evalf import EvalfMixin, pure_complex
7 from .decorators import _sympifyit, call_highest_priority
8 from .cache import cacheit
9 from .compatibility import reduce, as_int, default_sort_key, range
10 from mpmath.libmp import mpf_log, prec_to_dps
11 
12 from collections import defaultdict
13 
14 class Expr(Basic, EvalfMixin):
15     """
16     Base class for algebraic expressions.
17 
18     Everything that requires arithmetic operations to be defined
19     should subclass this class, instead of Basic (which should be
20     used only for argument storage and expression manipulation, i.e.
21     pattern matching, substitutions, etc).
22 
23     See Also
24     ========
25 
26     sympy.core.basic.Basic
27     """
28 
29     __slots__ = []
30 
31     @property
32     def _diff_wrt(self):
33         """Is it allowed to take derivative wrt to this instance.
34 
35         This determines if it is allowed to take derivatives wrt this object.
36         Subclasses such as Symbol, Function and Derivative should return True
37         to enable derivatives wrt them. The implementation in Derivative
38         separates the Symbol and non-Symbol _diff_wrt=True variables and
39         temporarily converts the non-Symbol vars in Symbols when performing
40         the differentiation.
41 
42         Note, see the docstring of Derivative for how this should work
43         mathematically. In particular, note that expr.subs(yourclass, Symbol)
44         should be well-defined on a structural level, or this will lead to
45         inconsistent results.
46 
47         Examples
48         ========
49 
50         >>> from sympy import Expr
51         >>> e = Expr()
52         >>> e._diff_wrt
53         False
54         >>> class MyClass(Expr):
55         ...     _diff_wrt = True
56         ...
57         >>> (2*MyClass()).diff(MyClass())
58         2
59         """
60         return False
61 
62     @cacheit
63     def sort_key(self, order=None):
64 
65         coeff, expr = self.as_coeff_Mul()
66 
67         if expr.is_Pow:
68             expr, exp = expr.args
69         else:
70             expr, exp = expr, S.One
71 
72         if expr.is_Dummy:
73             args = (expr.sort_key(),)
74         elif expr.is_Atom:
75             args = (str(expr),)
76         else:
77             if expr.is_Add:
78                 args = expr.as_ordered_terms(order=order)
79             elif expr.is_Mul:
80                 args = expr.as_ordered_factors(order=order)
81             else:
82                 args = expr.args
83 
84             args = tuple(
85                 [ default_sort_key(arg, order=order) for arg in args ])
86 
87         args = (len(args), tuple(args))
88         exp = exp.sort_key(order=order)
89 
90         return expr.class_key(), args, exp, coeff
91 
92     # ***************
93     # * Arithmetics *
94     # ***************
95     # Expr and its sublcasses use _op_priority to determine which object
96     # passed to a binary special method (__mul__, etc.) will handle the
97     # operation. In general, the 'call_highest_priority' decorator will choose
98     # the object with the highest _op_priority to handle the call.
99     # Custom subclasses that want to define their own binary special methods
100     # should set an _op_priority value that is higher than the default.
101     #
102     # **NOTE**:
103     # This is a temporary fix, and will eventually be replaced with
104     # something better and more powerful.  See issue 5510.
105     _op_priority = 10.0
106 
107     def __pos__(self):
108         return self
109 
110     def __neg__(self):
111         return Mul(S.NegativeOne, self)
112 
113     def __abs__(self):
114         from sympy import Abs
115         return Abs(self)
116 
117     @_sympifyit('other', NotImplemented)
118     @call_highest_priority('__radd__')
119     def __add__(self, other):
120         return Add(self, other)
121 
122     @_sympifyit('other', NotImplemented)
123     @call_highest_priority('__add__')
124     def __radd__(self, other):
125         return Add(other, self)
126 
127     @_sympifyit('other', NotImplemented)
128     @call_highest_priority('__rsub__')
129     def __sub__(self, other):
130         return Add(self, -other)
131 
132     @_sympifyit('other', NotImplemented)
133     @call_highest_priority('__sub__')
134     def __rsub__(self, other):
135         return Add(other, -self)
136 
137     @_sympifyit('other', NotImplemented)
138     @call_highest_priority('__rmul__')
139     def __mul__(self, other):
140         return Mul(self, other)
141 
142     @_sympifyit('other', NotImplemented)
143     @call_highest_priority('__mul__')
144     def __rmul__(self, other):
145         return Mul(other, self)
146 
147     @_sympifyit('other', NotImplemented)
148     @call_highest_priority('__rpow__')
149     def __pow__(self, other):
150         return Pow(self, other)
151 
152     @_sympifyit('other', NotImplemented)
153     @call_highest_priority('__pow__')
154     def __rpow__(self, other):
155         return Pow(other, self)
156 
157     @_sympifyit('other', NotImplemented)
158     @call_highest_priority('__rdiv__')
159     def __div__(self, other):
160         return Mul(self, Pow(other, S.NegativeOne))
161 
162     @_sympifyit('other', NotImplemented)
163     @call_highest_priority('__div__')
164     def __rdiv__(self, other):
165         return Mul(other, Pow(self, S.NegativeOne))
166 
167     __truediv__ = __div__
168     __rtruediv__ = __rdiv__
169 
170     @_sympifyit('other', NotImplemented)
171     @call_highest_priority('__rmod__')
172     def __mod__(self, other):
173         return Mod(self, other)
174 
175     @_sympifyit('other', NotImplemented)
176     @call_highest_priority('__mod__')
177     def __rmod__(self, other):
178         return Mod(other, self)
179 
180     @_sympifyit('other', NotImplemented)
181     @call_highest_priority('__rfloordiv__')
182     def __floordiv__(self, other):
183         from sympy.functions.elementary.integers import floor
184         return floor(self / other)
185 
186     @_sympifyit('other', NotImplemented)
187     @call_highest_priority('__floordiv__')
188     def __rfloordiv__(self, other):
189         from sympy.functions.elementary.integers import floor
190         return floor(self / other)
191 
192     def __int__(self):
193         # Although we only need to round to the units position, we'll
194         # get one more digit so the extra testing below can be avoided
195         # unless the rounded value rounded to an integer, e.g. if an
196         # expression were equal to 1.9 and we rounded to the unit position
197         # we would get a 2 and would not know if this rounded up or not
198         # without doing a test (as done below). But if we keep an extra
199         # digit we know that 1.9 is not the same as 1 and there is no
200         # need for further testing: our int value is correct. If the value
201         # were 1.99, however, this would round to 2.0 and our int value is
202         # off by one. So...if our round value is the same as the int value
203         # (regardless of how much extra work we do to calculate extra decimal
204         # places) we need to test whether we are off by one.
205         from sympy import Dummy
206         if not self.is_number:
207             raise TypeError("can't convert symbols to int")
208         r = self.round(2)
209         if not r.is_Number:
210             raise TypeError("can't convert complex to int")
211         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
212             raise TypeError("can't convert %s to int" % r)
213         i = int(r)
214         if not i:
215             return 0
216         # off-by-one check
217         if i == r and not (self - i).equals(0):
218             isign = 1 if i > 0 else -1
219             x = Dummy()
220             # in the following (self - i).evalf(2) will not always work while
221             # (self - r).evalf(2) and the use of subs does; if the test that
222             # was added when this comment was added passes, it might be safe
223             # to simply use sign to compute this rather than doing this by hand:
224             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
225             if diff_sign != isign:
226                 i -= isign
227         return i
228     __long__ = __int__
229 
230     def __float__(self):
231         # Don't bother testing if it's a number; if it's not this is going
232         # to fail, and if it is we still need to check that it evalf'ed to
233         # a number.
234         result = self.evalf()
235         if result.is_Number:
236             return float(result)
237         if result.is_number and result.as_real_imag()[1]:
238             raise TypeError("can't convert complex to float")
239         raise TypeError("can't convert expression to float")
240 
241     def __complex__(self):
242         result = self.evalf()
243         re, im = result.as_real_imag()
244         return complex(float(re), float(im))
245 
246     def __ge__(self, other):
247         from sympy import GreaterThan
248         try:
249             other = _sympify(other)
250         except SympifyError:
251             raise TypeError("Invalid comparison %s >= %s" % (self, other))
252         for me in (self, other):
253             if (me.is_complex and me.is_real is False) or \
254                     me.has(S.ComplexInfinity):
255                 raise TypeError("Invalid comparison of complex %s" % me)
256             if me is S.NaN:
257                 raise TypeError("Invalid NaN comparison")
258         n2 = _n2(self, other)
259         if n2 is not None:
260             return _sympify(n2 >= 0)
261         if self.is_real or other.is_real:
262             dif = self - other
263             if dif.is_nonnegative is not None and \
264                     dif.is_nonnegative is not dif.is_negative:
265                 return sympify(dif.is_nonnegative)
266         return GreaterThan(self, other, evaluate=False)
267 
268     def __le__(self, other):
269         from sympy import LessThan
270         try:
271             other = _sympify(other)
272         except SympifyError:
273             raise TypeError("Invalid comparison %s <= %s" % (self, other))
274         for me in (self, other):
275             if (me.is_complex and me.is_real is False) or \
276                     me.has(S.ComplexInfinity):
277                 raise TypeError("Invalid comparison of complex %s" % me)
278             if me is S.NaN:
279                 raise TypeError("Invalid NaN comparison")
280         n2 = _n2(self, other)
281         if n2 is not None:
282             return _sympify(n2 <= 0)
283         if self.is_real or other.is_real:
284             dif = self - other
285             if dif.is_nonpositive is not None and \
286                     dif.is_nonpositive is not dif.is_positive:
287                 return sympify(dif.is_nonpositive)
288         return LessThan(self, other, evaluate=False)
289 
290     def __gt__(self, other):
291         from sympy import StrictGreaterThan
292         try:
293             other = _sympify(other)
294         except SympifyError:
295             raise TypeError("Invalid comparison %s > %s" % (self, other))
296         for me in (self, other):
297             if (me.is_complex and me.is_real is False) or \
298                     me.has(S.ComplexInfinity):
299                 raise TypeError("Invalid comparison of complex %s" % me)
300             if me is S.NaN:
301                 raise TypeError("Invalid NaN comparison")
302         n2 = _n2(self, other)
303         if n2 is not None:
304             return _sympify(n2 > 0)
305         if self.is_real or other.is_real:
306             dif = self - other
307             if dif.is_positive is not None and \
308                     dif.is_positive is not dif.is_nonpositive:
309                 return sympify(dif.is_positive)
310         return StrictGreaterThan(self, other, evaluate=False)
311 
312     def __lt__(self, other):
313         from sympy import StrictLessThan
314         try:
315             other = _sympify(other)
316         except SympifyError:
317             raise TypeError("Invalid comparison %s < %s" % (self, other))
318         for me in (self, other):
319             if (me.is_complex and me.is_real is False) or \
320                     me.has(S.ComplexInfinity):
321                 raise TypeError("Invalid comparison of complex %s" % me)
322             if me is S.NaN:
323                 raise TypeError("Invalid NaN comparison")
324         n2 = _n2(self, other)
325         if n2 is not None:
326             return _sympify(n2 < 0)
327         if self.is_real or other.is_real:
328             dif = self - other
329             if dif.is_negative is not None and \
330                     dif.is_negative is not dif.is_nonnegative:
331                 return sympify(dif.is_negative)
332         return StrictLessThan(self, other, evaluate=False)
333 
334     @staticmethod
335     def _from_mpmath(x, prec):
336         from sympy import Float
337         if hasattr(x, "_mpf_"):
338             return Float._new(x._mpf_, prec)
339         elif hasattr(x, "_mpc_"):
340             re, im = x._mpc_
341             re = Float._new(re, prec)
342             im = Float._new(im, prec)*S.ImaginaryUnit
343             return re + im
344         else:
345             raise TypeError("expected mpmath number (mpf or mpc)")
346 
347     @property
348     def is_number(self):
349         """Returns True if ``self`` has no free symbols.
350         It will be faster than ``if not self.free_symbols``, however, since
351         ``is_number`` will fail as soon as it hits a free symbol.
352 
353         Examples
354         ========
355 
356         >>> from sympy import log, Integral
357         >>> from sympy.abc import x
358 
359         >>> x.is_number
360         False
361         >>> (2*x).is_number
362         False
363         >>> (2 + log(2)).is_number
364         True
365         >>> (2 + Integral(2, x)).is_number
366         False
367         >>> (2 + Integral(2, (x, 1, 2))).is_number
368         True
369 
370         """
371         return all(obj.is_number for obj in self.args)
372 
373     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
374         """Return self evaluated, if possible, replacing free symbols with
375         random complex values, if necessary.
376 
377         The random complex value for each free symbol is generated
378         by the random_complex_number routine giving real and imaginary
379         parts in the range given by the re_min, re_max, im_min, and im_max
380         values. The returned value is evaluated to a precision of n
381         (if given) else the maximum of 15 and the precision needed
382         to get more than 1 digit of precision. If the expression
383         could not be evaluated to a number, or could not be evaluated
384         to more than 1 digit of precision, then None is returned.
385 
386         Examples
387         ========
388 
389         >>> from sympy import sqrt
390         >>> from sympy.abc import x, y
391         >>> x._random()                         # doctest: +SKIP
392         0.0392918155679172 + 0.916050214307199*I
393         >>> x._random(2)                        # doctest: +SKIP
394         -0.77 - 0.87*I
395         >>> (x + y/2)._random(2)                # doctest: +SKIP
396         -0.57 + 0.16*I
397         >>> sqrt(2)._random(2)
398         1.4
399 
400         See Also
401         ========
402 
403         sympy.utilities.randtest.random_complex_number
404         """
405 
406         free = self.free_symbols
407         prec = 1
408         if free:
409             from sympy.utilities.randtest import random_complex_number
410             a, c, b, d = re_min, re_max, im_min, im_max
411             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
412                            for zi in free])))
413             try:
414                 nmag = abs(self.evalf(2, subs=reps))
415             except (ValueError, TypeError):
416                 # if an out of range value resulted in evalf problems
417                 # then return None -- XXX is there a way to know how to
418                 # select a good random number for a given expression?
419                 # e.g. when calculating n! negative values for n should not
420                 # be used
421                 return None
422         else:
423             reps = {}
424             nmag = abs(self.evalf(2))
425 
426         if not hasattr(nmag, '_prec'):
427             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
428             return None
429 
430         if nmag._prec == 1:
431             # increase the precision up to the default maximum
432             # precision to see if we can get any significance
433 
434             from mpmath.libmp.libintmath import giant_steps
435             from sympy.core.evalf import DEFAULT_MAXPREC as target
436 
437             # evaluate
438             for prec in giant_steps(2, target):
439                 nmag = abs(self.evalf(prec, subs=reps))
440                 if nmag._prec != 1:
441                     break
442 
443         if nmag._prec != 1:
444             if n is None:
445                 n = max(prec, 15)
446             return self.evalf(n, subs=reps)
447 
448         # never got any significance
449         return None
450 
451     def is_constant(self, *wrt, **flags):
452         """Return True if self is constant, False if not, or None if
453         the constancy could not be determined conclusively.
454 
455         If an expression has no free symbols then it is a constant. If
456         there are free symbols it is possible that the expression is a
457         constant, perhaps (but not necessarily) zero. To test such
458         expressions, two strategies are tried:
459 
460         1) numerical evaluation at two random points. If two such evaluations
461         give two different values and the values have a precision greater than
462         1 then self is not constant. If the evaluations agree or could not be
463         obtained with any precision, no decision is made. The numerical testing
464         is done only if ``wrt`` is different than the free symbols.
465 
466         2) differentiation with respect to variables in 'wrt' (or all free
467         symbols if omitted) to see if the expression is constant or not. This
468         will not always lead to an expression that is zero even though an
469         expression is constant (see added test in test_expr.py). If
470         all derivatives are zero then self is constant with respect to the
471         given symbols.
472 
473         If neither evaluation nor differentiation can prove the expression is
474         constant, None is returned unless two numerical values happened to be
475         the same and the flag ``failing_number`` is True -- in that case the
476         numerical value will be returned.
477 
478         If flag simplify=False is passed, self will not be simplified;
479         the default is True since self should be simplified before testing.
480 
481         Examples
482         ========
483 
484         >>> from sympy import cos, sin, Sum, S, pi
485         >>> from sympy.abc import a, n, x, y
486         >>> x.is_constant()
487         False
488         >>> S(2).is_constant()
489         True
490         >>> Sum(x, (x, 1, 10)).is_constant()
491         True
492         >>> Sum(x, (x, 1, n)).is_constant()
493         False
494         >>> Sum(x, (x, 1, n)).is_constant(y)
495         True
496         >>> Sum(x, (x, 1, n)).is_constant(n)
497         False
498         >>> Sum(x, (x, 1, n)).is_constant(x)
499         True
500         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
501         >>> eq.is_constant()
502         True
503         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
504         True
505 
506         >>> (0**x).is_constant()
507         False
508         >>> x.is_constant()
509         False
510         >>> (x**x).is_constant()
511         False
512         >>> one = cos(x)**2 + sin(x)**2
513         >>> one.is_constant()
514         True
515         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
516         True
517         """
518 
519         simplify = flags.get('simplify', True)
520 
521         # Except for expressions that contain units, only one of these should
522         # be necessary since if something is
523         # known to be a number it should also know that there are no
524         # free symbols. But is_number quits as soon as it hits a non-number
525         # whereas free_symbols goes until all free symbols have been collected,
526         # thus is_number should be faster. But a double check on free symbols
527         # is made just in case there is a discrepancy between the two.
528         free = self.free_symbols
529         if self.is_number or not free:
530             # if the following assertion fails then that object's free_symbols
531             # method needs attention: if an expression is a number it cannot
532             # have free symbols
533             assert not free
534             return True
535 
536         # if we are only interested in some symbols and they are not in the
537         # free symbols then this expression is constant wrt those symbols
538         wrt = set(wrt)
539         if wrt and not wrt & free:
540             return True
541         wrt = wrt or free
542 
543         # simplify unless this has already been done
544         expr = self
545         if simplify:
546             expr = expr.simplify()
547 
548         # is_zero should be a quick assumptions check; it can be wrong for
549         # numbers (see test_is_not_constant test), giving False when it
550         # shouldn't, but hopefully it will never give True unless it is sure.
551         if expr.is_zero:
552             return True
553 
554         # try numerical evaluation to see if we get two different values
555         failing_number = None
556         if wrt == free:
557             # try 0 (for a) and 1 (for b)
558             try:
559                 a = expr.subs(list(zip(free, [0]*len(free))),
560                     simultaneous=True)
561                 if a is S.NaN:
562                     # evaluation may succeed when substitution fails
563                     a = expr._random(None, 0, 0, 0, 0)
564             except ZeroDivisionError:
565                 a = None
566             if a is not None and a is not S.NaN:
567                 try:
568                     b = expr.subs(list(zip(free, [1]*len(free))),
569                         simultaneous=True)
570                     if b is S.NaN:
571                         # evaluation may succeed when substitution fails
572                         b = expr._random(None, 1, 0, 1, 0)
573                 except ZeroDivisionError:
574                     b = None
575                 if b is not None and b is not S.NaN and b.equals(a) is False:
576                     return False
577                 # try random real
578                 b = expr._random(None, -1, 0, 1, 0)
579                 if b is not None and b is not S.NaN and b.equals(a) is False:
580                     return False
581                 # try random complex
582                 b = expr._random()
583                 if b is not None and b is not S.NaN:
584                     if b.equals(a) is False:
585                         return False
586                     failing_number = a if a.is_number else b
587 
588         # now we will test each wrt symbol (or all free symbols) to see if the
589         # expression depends on them or not using differentiation. This is
590         # not sufficient for all expressions, however, so we don't return
591         # False if we get a derivative other than 0 with free symbols.
592         for w in wrt:
593             deriv = expr.diff(w)
594             if simplify:
595                 deriv = deriv.simplify()
596             if deriv != 0:
597                 if not (pure_complex(deriv, or_real=True)):
598                     if flags.get('failing_number', False):
599                         return failing_number
600                     elif deriv.free_symbols:
601                         # dead line provided _random returns None in such cases
602                         return None
603                 return False
604         return True
605 
606     def equals(self, other, failing_expression=False):
607         """Return True if self == other, False if it doesn't, or None. If
608         failing_expression is True then the expression which did not simplify
609         to a 0 will be returned instead of None.
610 
611         If ``self`` is a Number (or complex number) that is not zero, then
612         the result is False.
613 
614         If ``self`` is a number and has not evaluated to zero, evalf will be
615         used to test whether the expression evaluates to zero. If it does so
616         and the result has significance (i.e. the precision is either -1, for
617         a Rational result, or is greater than 1) then the evalf value will be
618         used to return True or False.
619 
620         """
621         from sympy.simplify.simplify import nsimplify, simplify
622         from sympy.solvers.solveset import solveset
623         from sympy.polys.polyerrors import NotAlgebraic
624         from sympy.polys.numberfields import minimal_polynomial
625 
626         other = sympify(other)
627         if self == other:
628             return True
629 
630         # they aren't the same so see if we can make the difference 0;
631         # don't worry about doing simplification steps one at a time
632         # because if the expression ever goes to 0 then the subsequent
633         # simplification steps that are done will be very fast.
634         diff = factor_terms(simplify(self - other), radical=True)
635 
636         if not diff:
637             return True
638 
639         if not diff.has(Add, Mod):
640             # if there is no expanding to be done after simplifying
641             # then this can't be a zero
642             return False
643 
644         constant = diff.is_constant(simplify=False, failing_number=True)
645 
646         if constant is False:
647             return False
648 
649         if constant is None and (diff.free_symbols or not diff.is_number):
650             # e.g. unless the right simplification is done, a symbolic
651             # zero is possible (see expression of issue 6829: without
652             # simplification constant will be None).
653             return
654 
655         if constant is True:
656             ndiff = diff._random()
657             if ndiff:
658                 return False
659 
660         # sometimes we can use a simplified result to give a clue as to
661         # what the expression should be; if the expression is *not* zero
662         # then we should have been able to compute that and so now
663         # we can just consider the cases where the approximation appears
664         # to be zero -- we try to prove it via minimal_polynomial.
665         if diff.is_number:
666             approx = diff.nsimplify()
667             if not approx:
668                 # try to prove via self-consistency
669                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
670                 # it seems to work better to try big ones first
671                 surds.sort(key=lambda x: -x.args[0])
672                 for s in surds:
673                     try:
674                         # simplify is False here -- this expression has already
675                         # been identified as being hard to identify as zero;
676                         # we will handle the checking ourselves using nsimplify
677                         # to see if we are in the right ballpark or not and if so
678                         # *then* the simplification will be attempted.
679                         if s.is_Symbol:
680                             sol = list(solveset(diff, s))
681                         else:
682                             sol = [s]
683                         if sol:
684                             if s in sol:
685                                 return True
686                             if s.is_real:
687                                 if any(nsimplify(si, [s]) == s and simplify(si) == s
688                                         for si in sol):
689                                     return True
690                     except NotImplementedError:
691                         pass
692 
693                 # try to prove with minimal_polynomial but know when
694                 # *not* to use this or else it can take a long time. e.g. issue 8354
695                 if True:  # change True to condition that assures non-hang
696                     try:
697                         mp = minimal_polynomial(diff)
698                         if mp.is_Symbol:
699                             return True
700                         return False
701                     except (NotAlgebraic, NotImplementedError):
702                         pass
703 
704         # diff has not simplified to zero; constant is either None, True
705         # or the number with significance (prec != 1) that was randomly
706         # calculated twice as the same value.
707         if constant not in (True, None) and constant != 0:
708             return False
709 
710         if failing_expression:
711             return diff
712         return None
713 
714     def _eval_is_positive(self):
715         from sympy.polys.numberfields import minimal_polynomial
716         from sympy.polys.polyerrors import NotAlgebraic
717         if self.is_number:
718             if self.is_real is False:
719                 return False
720             try:
721                 # check to see that we can get a value
722                 n2 = self._eval_evalf(2)
723                 if n2 is None:
724                     raise AttributeError
725                 if n2._prec == 1:  # no significance
726                     raise AttributeError
727                 if n2 == S.NaN:
728                     raise AttributeError
729             except (AttributeError, ValueError):
730                 return None
731             n, i = self.evalf(2).as_real_imag()
732             if not i.is_Number or not n.is_Number:
733                 return False
734             if n._prec != 1 and i._prec != 1:
735                 return bool(not i and n > 0)
736             elif n._prec == 1 and (not i or i._prec == 1) and \
737                     self.is_algebraic and not self.has(Function):
738                 try:
739                     if minimal_polynomial(self).is_Symbol:
740                         return False
741                 except (NotAlgebraic, NotImplementedError):
742                     pass
743 
744     def _eval_is_negative(self):
745         from sympy.polys.numberfields import minimal_polynomial
746         from sympy.polys.polyerrors import NotAlgebraic
747         if self.is_number:
748             if self.is_real is False:
749                 return False
750             try:
751                 # check to see that we can get a value
752                 n2 = self._eval_evalf(2)
753                 if n2 is None:
754                     raise AttributeError
755                 if n2._prec == 1:  # no significance
756                     raise AttributeError
757                 if n2 == S.NaN:
758                     raise AttributeError
759             except (AttributeError, ValueError):
760                 return None
761             n, i = self.evalf(2).as_real_imag()
762             if not i.is_Number or not n.is_Number:
763                 return False
764             if n._prec != 1 and i._prec != 1:
765                 return bool(not i and n < 0)
766             elif n._prec == 1 and (not i or i._prec == 1) and \
767                     self.is_algebraic and not self.has(Function):
768                 try:
769                     if minimal_polynomial(self).is_Symbol:
770                         return False
771                 except (NotAlgebraic, NotImplementedError):
772                     pass
773 
774     def _eval_interval(self, x, a, b):
775         """
776         Returns evaluation over an interval.  For most functions this is:
777 
778         self.subs(x, b) - self.subs(x, a),
779 
780         possibly using limit() if NaN is returned from subs.
781 
782         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
783         respectively.
784 
785         """
786         from sympy.series import limit, Limit
787         from sympy.solvers.solveset import solveset
788         from sympy.sets.sets import Interval
789 
790         if (a is None and b is None):
791             raise ValueError('Both interval ends cannot be None.')
792 
793         if a == b:
794             return 0
795 
796         if a is None:
797             A = 0
798         else:
799             A = self.subs(x, a)
800             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
801                 if (a < b) != False:
802                     A = limit(self, x, a,"+")
803                 else:
804                     A = limit(self, x, a,"-")
805 
806                 if A is S.NaN:
807                     return A
808                 if isinstance(A, Limit):
809                     raise NotImplementedError("Could not compute limit")
810 
811         if b is None:
812             B = 0
813         else:
814             B = self.subs(x, b)
815             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
816                 if (a < b) != False:
817                     B = limit(self, x, b,"-")
818                 else:
819                     B = limit(self, x, b,"+")
820 
821                 if isinstance(B, Limit):
822                     raise NotImplementedError("Could not compute limit")
823 
824         if (a and b) is None:
825             return B - A
826 
827         value = B - A
828 
829         if a.is_comparable and b.is_comparable:
830             if a < b:
831                 domain = Interval(a, b)
832             else:
833                 domain = Interval(b, a)
834             singularities = list(solveset(self.cancel().as_numer_denom()[1], x, domain = domain))
835             for s in singularities:
836                 if a < s < b:
837                     value += -limit(self, x, s, "+") + limit(self, x, s, "-")
838                 elif b < s < a:
839                     value += limit(self, x, s, "+") - limit(self, x, s, "-")
840 
841         return value
842 
843     def _eval_power(self, other):
844         # subclass to compute self**other for cases when
845         # other is not NaN, 0, or 1
846         return None
847 
848     def _eval_conjugate(self):
849         if self.is_real:
850             return self
851         elif self.is_imaginary:
852             return -self
853 
854     def conjugate(self):
855         from sympy.functions.elementary.complexes import conjugate as c
856         return c(self)
857 
858     def _eval_transpose(self):
859         from sympy.functions.elementary.complexes import conjugate
860         if self.is_complex:
861             return self
862         elif self.is_hermitian:
863             return conjugate(self)
864         elif self.is_antihermitian:
865             return -conjugate(self)
866 
867     def transpose(self):
868         from sympy.functions.elementary.complexes import transpose
869         return transpose(self)
870 
871     def _eval_adjoint(self):
872         from sympy.functions.elementary.complexes import conjugate, transpose
873         if self.is_hermitian:
874             return self
875         elif self.is_antihermitian:
876             return -self
877         obj = self._eval_conjugate()
878         if obj is not None:
879             return transpose(obj)
880         obj = self._eval_transpose()
881         if obj is not None:
882             return conjugate(obj)
883 
884     def adjoint(self):
885         from sympy.functions.elementary.complexes import adjoint
886         return adjoint(self)
887 
888     @classmethod
889     def _parse_order(cls, order):
890         """Parse and configure the ordering of terms. """
891         from sympy.polys.orderings import monomial_key
892 
893         try:
894             reverse = order.startswith('rev-')
895         except AttributeError:
896             reverse = False
897         else:
898             if reverse:
899                 order = order[4:]
900 
901         monom_key = monomial_key(order)
902 
903         def neg(monom):
904             result = []
905 
906             for m in monom:
907                 if isinstance(m, tuple):
908                     result.append(neg(m))
909                 else:
910                     result.append(-m)
911 
912             return tuple(result)
913 
914         def key(term):
915             _, ((re, im), monom, ncpart) = term
916 
917             monom = neg(monom_key(monom))
918             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
919             coeff = ((bool(im), im), (re, im))
920 
921             return monom, ncpart, coeff
922 
923         return key, reverse
924 
925     def as_ordered_factors(self, order=None):
926         """Return list of ordered factors (if Mul) else [self]."""
927         return [self]
928 
929     def as_ordered_terms(self, order=None, data=False):
930         """
931         Transform an expression to an ordered list of terms.
932 
933         Examples
934         ========
935 
936         >>> from sympy import sin, cos
937         >>> from sympy.abc import x
938 
939         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
940         [sin(x)**2*cos(x), sin(x)**2, 1]
941 
942         """
943         key, reverse = self._parse_order(order)
944         terms, gens = self.as_terms()
945 
946         if not any(term.is_Order for term, _ in terms):
947             ordered = sorted(terms, key=key, reverse=reverse)
948         else:
949             _terms, _order = [], []
950 
951             for term, repr in terms:
952                 if not term.is_Order:
953                     _terms.append((term, repr))
954                 else:
955                     _order.append((term, repr))
956 
957             ordered = sorted(_terms, key=key, reverse=True) \
958                 + sorted(_order, key=key, reverse=True)
959 
960         if data:
961             return ordered, gens
962         else:
963             return [term for term, _ in ordered]
964 
965     def as_terms(self):
966         """Transform an expression to a list of terms. """
967         from .add import Add
968         from .mul import Mul
969         from .exprtools import decompose_power
970 
971         gens, terms = set([]), []
972 
973         for term in Add.make_args(self):
974             coeff, _term = term.as_coeff_Mul()
975 
976             coeff = complex(coeff)
977             cpart, ncpart = {}, []
978 
979             if _term is not S.One:
980                 for factor in Mul.make_args(_term):
981                     if factor.is_number:
982                         try:
983                             coeff *= complex(factor)
984                         except TypeError:
985                             pass
986                         else:
987                             continue
988 
989                     if factor.is_commutative:
990                         base, exp = decompose_power(factor)
991 
992                         cpart[base] = exp
993                         gens.add(base)
994                     else:
995                         ncpart.append(factor)
996 
997             coeff = coeff.real, coeff.imag
998             ncpart = tuple(ncpart)
999 
1000             terms.append((term, (coeff, cpart, ncpart)))
1001 
1002         gens = sorted(gens, key=default_sort_key)
1003 
1004         k, indices = len(gens), {}
1005 
1006         for i, g in enumerate(gens):
1007             indices[g] = i
1008 
1009         result = []
1010 
1011         for term, (coeff, cpart, ncpart) in terms:
1012             monom = [0]*k
1013 
1014             for base, exp in cpart.items():
1015                 monom[indices[base]] = exp
1016 
1017             result.append((term, (coeff, tuple(monom), ncpart)))
1018 
1019         return result, gens
1020 
1021     def removeO(self):
1022         """Removes the additive O(..) symbol if there is one"""
1023         return self
1024 
1025     def getO(self):
1026         """Returns the additive O(..) symbol if there is one, else None."""
1027         return None
1028 
1029     def getn(self):
1030         """
1031         Returns the order of the expression.
1032 
1033         The order is determined either from the O(...) term. If there
1034         is no O(...) term, it returns None.
1035 
1036         Examples
1037         ========
1038 
1039         >>> from sympy import O
1040         >>> from sympy.abc import x
1041         >>> (1 + x + O(x**2)).getn()
1042         2
1043         >>> (1 + x).getn()
1044 
1045         """
1046         from sympy import Dummy, Symbol
1047         o = self.getO()
1048         if o is None:
1049             return None
1050         elif o.is_Order:
1051             o = o.expr
1052             if o is S.One:
1053                 return S.Zero
1054             if o.is_Symbol:
1055                 return S.One
1056             if o.is_Pow:
1057                 return o.args[1]
1058             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1059                 for oi in o.args:
1060                     if oi.is_Symbol:
1061                         return S.One
1062                     if oi.is_Pow:
1063                         syms = oi.atoms(Symbol)
1064                         if len(syms) == 1:
1065                             x = syms.pop()
1066                             oi = oi.subs(x, Dummy('x', positive=True))
1067                             if oi.base.is_Symbol and oi.exp.is_Rational:
1068                                 return abs(oi.exp)
1069 
1070         raise NotImplementedError('not sure of order of %s' % o)
1071 
1072     def count_ops(self, visual=None):
1073         """wrapper for count_ops that returns the operation count."""
1074         from .function import count_ops
1075         return count_ops(self, visual)
1076 
1077     def args_cnc(self, cset=False, warn=True, split_1=True):
1078         """Return [commutative factors, non-commutative factors] of self.
1079 
1080         self is treated as a Mul and the ordering of the factors is maintained.
1081         If ``cset`` is True the commutative factors will be returned in a set.
1082         If there were repeated factors (as may happen with an unevaluated Mul)
1083         then an error will be raised unless it is explicitly supressed by
1084         setting ``warn`` to False.
1085 
1086         Note: -1 is always separated from a Number unless split_1 is False.
1087 
1088         >>> from sympy import symbols, oo
1089         >>> A, B = symbols('A B', commutative=0)
1090         >>> x, y = symbols('x y')
1091         >>> (-2*x*y).args_cnc()
1092         [[-1, 2, x, y], []]
1093         >>> (-2.5*x).args_cnc()
1094         [[-1, 2.5, x], []]
1095         >>> (-2*x*A*B*y).args_cnc()
1096         [[-1, 2, x, y], [A, B]]
1097         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1098         [[-2, x, y], [A, B]]
1099         >>> (-2*x*y).args_cnc(cset=True)
1100         [{-1, 2, x, y}, []]
1101 
1102         The arg is always treated as a Mul:
1103 
1104         >>> (-2 + x + A).args_cnc()
1105         [[], [x - 2 + A]]
1106         >>> (-oo).args_cnc() # -oo is a singleton
1107         [[-1, oo], []]
1108         """
1109 
1110         if self.is_Mul:
1111             args = list(self.args)
1112         else:
1113             args = [self]
1114         for i, mi in enumerate(args):
1115             if not mi.is_commutative:
1116                 c = args[:i]
1117                 nc = args[i:]
1118                 break
1119         else:
1120             c = args
1121             nc = []
1122 
1123         if c and split_1 and (
1124             c[0].is_Number and
1125             c[0].is_negative and
1126                 c[0] is not S.NegativeOne):
1127             c[:1] = [S.NegativeOne, -c[0]]
1128 
1129         if cset:
1130             clen = len(c)
1131             c = set(c)
1132             if clen and warn and len(c) != clen:
1133                 raise ValueError('repeated commutative arguments: %s' %
1134                                  [ci for ci in c if list(self.args).count(ci) > 1])
1135         return [c, nc]
1136 
1137     def coeff(self, x, n=1, right=False):
1138         """
1139         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1140         is zero then all terms independent of ``x`` will be returned.
1141 
1142         When ``x`` is noncommutative, the coefficient to the left (default) or
1143         right of ``x`` can be returned. The keyword 'right' is ignored when
1144         ``x`` is commutative.
1145 
1146         See Also
1147         ========
1148 
1149         as_coefficient: separate the expression into a coefficient and factor
1150         as_coeff_Add: separate the additive constant from an expression
1151         as_coeff_Mul: separate the multiplicative constant from an expression
1152         as_independent: separate x-dependent terms/factors from others
1153         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1154         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1155 
1156         Examples
1157         ========
1158 
1159         >>> from sympy import symbols
1160         >>> from sympy.abc import x, y, z
1161 
1162         You can select terms that have an explicit negative in front of them:
1163 
1164         >>> (-x + 2*y).coeff(-1)
1165         x
1166         >>> (x - 2*y).coeff(-1)
1167         2*y
1168 
1169         You can select terms with no Rational coefficient:
1170 
1171         >>> (x + 2*y).coeff(1)
1172         x
1173         >>> (3 + 2*x + 4*x**2).coeff(1)
1174         0
1175 
1176         You can select terms independent of x by making n=0; in this case
1177         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1178         of None):
1179 
1180         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1181         3
1182         >>> eq = ((x + 1)**3).expand() + 1
1183         >>> eq
1184         x**3 + 3*x**2 + 3*x + 2
1185         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1186         [1, 3, 3, 2]
1187         >>> eq -= 2
1188         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1189         [1, 3, 3, 0]
1190 
1191         You can select terms that have a numerical term in front of them:
1192 
1193         >>> (-x - 2*y).coeff(2)
1194         -y
1195         >>> from sympy import sqrt
1196         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1197         x
1198 
1199         The matching is exact:
1200 
1201         >>> (3 + 2*x + 4*x**2).coeff(x)
1202         2
1203         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1204         4
1205         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1206         0
1207         >>> (z*(x + y)**2).coeff((x + y)**2)
1208         z
1209         >>> (z*(x + y)**2).coeff(x + y)
1210         0
1211 
1212         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1213         from the following:
1214 
1215         >>> (x + z*(x + x*y)).coeff(x)
1216         1
1217 
1218         If such factoring is desired, factor_terms can be used first:
1219 
1220         >>> from sympy import factor_terms
1221         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1222         z*(y + 1) + 1
1223 
1224         >>> n, m, o = symbols('n m o', commutative=False)
1225         >>> n.coeff(n)
1226         1
1227         >>> (3*n).coeff(n)
1228         3
1229         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1230         1 + m
1231         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1232         m
1233 
1234         If there is more than one possible coefficient 0 is returned:
1235 
1236         >>> (n*m + m*n).coeff(n)
1237         0
1238 
1239         If there is only one possible coefficient, it is returned:
1240 
1241         >>> (n*m + x*m*n).coeff(m*n)
1242         x
1243         >>> (n*m + x*m*n).coeff(m*n, right=1)
1244         1
1245 
1246         """
1247         x = sympify(x)
1248         if not isinstance(x, Basic):
1249             return S.Zero
1250 
1251         n = as_int(n)
1252 
1253         if not x:
1254             return S.Zero
1255 
1256         if x == self:
1257             if n == 1:
1258                 return S.One
1259             return S.Zero
1260 
1261         if x is S.One:
1262             co = [a for a in Add.make_args(self)
1263                   if a.as_coeff_Mul()[0] is S.One]
1264             if not co:
1265                 return S.Zero
1266             return Add(*co)
1267 
1268         if n == 0:
1269             if x.is_Add and self.is_Add:
1270                 c = self.coeff(x, right=right)
1271                 if not c:
1272                     return S.Zero
1273                 if not right:
1274                     return self - Add(*[a*x for a in Add.make_args(c)])
1275                 return self - Add(*[x*a for a in Add.make_args(c)])
1276             return self.as_independent(x, as_Add=True)[0]
1277 
1278         # continue with the full method, looking for this power of x:
1279         x = x**n
1280 
1281         def incommon(l1, l2):
1282             if not l1 or not l2:
1283                 return []
1284             n = min(len(l1), len(l2))
1285             for i in range(n):
1286                 if l1[i] != l2[i]:
1287                     return l1[:i]
1288             return l1[:]
1289 
1290         def find(l, sub, first=True):
1291             """ Find where list sub appears in list l. When ``first`` is True
1292             the first occurance from the left is returned, else the last
1293             occurance is returned. Return None if sub is not in l.
1294 
1295             >> l = range(5)*2
1296             >> find(l, [2, 3])
1297             2
1298             >> find(l, [2, 3], first=0)
1299             7
1300             >> find(l, [2, 4])
1301             None
1302 
1303             """
1304             if not sub or not l or len(sub) > len(l):
1305                 return None
1306             n = len(sub)
1307             if not first:
1308                 l.reverse()
1309                 sub.reverse()
1310             for i in range(0, len(l) - n + 1):
1311                 if all(l[i + j] == sub[j] for j in range(n)):
1312                     break
1313             else:
1314                 i = None
1315             if not first:
1316                 l.reverse()
1317                 sub.reverse()
1318             if i is not None and not first:
1319                 i = len(l) - (i + n)
1320             return i
1321 
1322         co = []
1323         args = Add.make_args(self)
1324         self_c = self.is_commutative
1325         x_c = x.is_commutative
1326         if self_c and not x_c:
1327             return S.Zero
1328 
1329         if self_c:
1330             xargs = x.args_cnc(cset=True, warn=False)[0]
1331             for a in args:
1332                 margs = a.args_cnc(cset=True, warn=False)[0]
1333                 if len(xargs) > len(margs):
1334                     continue
1335                 resid = margs.difference(xargs)
1336                 if len(resid) + len(xargs) == len(margs):
1337                     co.append(Mul(*resid))
1338             if co == []:
1339                 return S.Zero
1340             elif co:
1341                 return Add(*co)
1342         elif x_c:
1343             xargs = x.args_cnc(cset=True, warn=False)[0]
1344             for a in args:
1345                 margs, nc = a.args_cnc(cset=True)
1346                 if len(xargs) > len(margs):
1347                     continue
1348                 resid = margs.difference(xargs)
1349                 if len(resid) + len(xargs) == len(margs):
1350                     co.append(Mul(*(list(resid) + nc)))
1351             if co == []:
1352                 return S.Zero
1353             elif co:
1354                 return Add(*co)
1355         else:  # both nc
1356             xargs, nx = x.args_cnc(cset=True)
1357             # find the parts that pass the commutative terms
1358             for a in args:
1359                 margs, nc = a.args_cnc(cset=True)
1360                 if len(xargs) > len(margs):
1361                     continue
1362                 resid = margs.difference(xargs)
1363                 if len(resid) + len(xargs) == len(margs):
1364                     co.append((resid, nc))
1365             # now check the non-comm parts
1366             if not co:
1367                 return S.Zero
1368             if all(n == co[0][1] for r, n in co):
1369                 ii = find(co[0][1], nx, right)
1370                 if ii is not None:
1371                     if not right:
1372                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1373                     else:
1374                         return Mul(*co[0][1][ii + len(nx):])
1375             beg = reduce(incommon, (n[1] for n in co))
1376             if beg:
1377                 ii = find(beg, nx, right)
1378                 if ii is not None:
1379                     if not right:
1380                         gcdc = co[0][0]
1381                         for i in range(1, len(co)):
1382                             gcdc = gcdc.intersection(co[i][0])
1383                             if not gcdc:
1384                                 break
1385                         return Mul(*(list(gcdc) + beg[:ii]))
1386                     else:
1387                         m = ii + len(nx)
1388                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1389             end = list(reversed(
1390                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1391             if end:
1392                 ii = find(end, nx, right)
1393                 if ii is not None:
1394                     if not right:
1395                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1396                     else:
1397                         return Mul(*end[ii + len(nx):])
1398             # look for single match
1399             hit = None
1400             for i, (r, n) in enumerate(co):
1401                 ii = find(n, nx, right)
1402                 if ii is not None:
1403                     if not hit:
1404                         hit = ii, r, n
1405                     else:
1406                         break
1407             else:
1408                 if hit:
1409                     ii, r, n = hit
1410                     if not right:
1411                         return Mul(*(list(r) + n[:ii]))
1412                     else:
1413                         return Mul(*n[ii + len(nx):])
1414 
1415             return S.Zero
1416 
1417     def as_expr(self, *gens):
1418         """
1419         Convert a polynomial to a SymPy expression.
1420 
1421         Examples
1422         ========
1423 
1424         >>> from sympy import sin
1425         >>> from sympy.abc import x, y
1426 
1427         >>> f = (x**2 + x*y).as_poly(x, y)
1428         >>> f.as_expr()
1429         x**2 + x*y
1430 
1431         >>> sin(x).as_expr()
1432         sin(x)
1433 
1434         """
1435         return self
1436 
1437     def as_coefficient(self, expr):
1438         """
1439         Extracts symbolic coefficient at the given expression. In
1440         other words, this functions separates 'self' into the product
1441         of 'expr' and 'expr'-free coefficient. If such separation
1442         is not possible it will return None.
1443 
1444         Examples
1445         ========
1446 
1447         >>> from sympy import E, pi, sin, I, Poly
1448         >>> from sympy.abc import x
1449 
1450         >>> E.as_coefficient(E)
1451         1
1452         >>> (2*E).as_coefficient(E)
1453         2
1454         >>> (2*sin(E)*E).as_coefficient(E)
1455 
1456         Two terms have E in them so a sum is returned. (If one were
1457         desiring the coefficient of the term exactly matching E then
1458         the constant from the returned expression could be selected.
1459         Or, for greater precision, a method of Poly can be used to
1460         indicate the desired term from which the coefficient is
1461         desired.)
1462 
1463         >>> (2*E + x*E).as_coefficient(E)
1464         x + 2
1465         >>> _.args[0]  # just want the exact match
1466         2
1467         >>> p = Poly(2*E + x*E); p
1468         Poly(x*E + 2*E, x, E, domain='ZZ')
1469         >>> p.coeff_monomial(E)
1470         2
1471         >>> p.nth(0, 1)
1472         2
1473 
1474         Since the following cannot be written as a product containing
1475         E as a factor, None is returned. (If the coefficient ``2*x`` is
1476         desired then the ``coeff`` method should be used.)
1477 
1478         >>> (2*E*x + x).as_coefficient(E)
1479         >>> (2*E*x + x).coeff(E)
1480         2*x
1481 
1482         >>> (E*(x + 1) + x).as_coefficient(E)
1483 
1484         >>> (2*pi*I).as_coefficient(pi*I)
1485         2
1486         >>> (2*I).as_coefficient(pi*I)
1487 
1488         See Also
1489         ========
1490 
1491         coeff: return sum of terms have a given factor
1492         as_coeff_Add: separate the additive constant from an expression
1493         as_coeff_Mul: separate the multiplicative constant from an expression
1494         as_independent: separate x-dependent terms/factors from others
1495         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1496         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1497 
1498 
1499         """
1500 
1501         r = self.extract_multiplicatively(expr)
1502         if r and not r.has(expr):
1503             return r
1504 
1505     def as_independent(self, *deps, **hint):
1506         """
1507         A mostly naive separation of a Mul or Add into arguments that are not
1508         are dependent on deps. To obtain as complete a separation of variables
1509         as possible, use a separation method first, e.g.:
1510 
1511         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1512         * .expand(mul=True) to change Add or Mul into Add
1513         * .expand(log=True) to change log expr into an Add
1514 
1515         The only non-naive thing that is done here is to respect noncommutative
1516         ordering of variables and to always return (0, 0) for `self` of zero
1517         regardless of hints.
1518 
1519         For nonzero `self`, the returned tuple (i, d) has the
1520         following interpretation:
1521 
1522         * i will has no variable that appears in deps
1523         * d will be 1 or else have terms that contain variables that are in deps
1524         * if self is an Add then self = i + d
1525         * if self is a Mul then self = i*d
1526         * otherwise (self, S.One) or (S.One, self) is returned.
1527 
1528         To force the expression to be treated as an Add, use the hint as_Add=True
1529 
1530         Examples
1531         ========
1532 
1533         -- self is an Add
1534 
1535         >>> from sympy import sin, cos, exp
1536         >>> from sympy.abc import x, y, z
1537 
1538         >>> (x + x*y).as_independent(x)
1539         (0, x*y + x)
1540         >>> (x + x*y).as_independent(y)
1541         (x, x*y)
1542         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1543         (y + z, 2*x*sin(x) + x)
1544         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1545         (z, 2*x*sin(x) + x + y)
1546 
1547         -- self is a Mul
1548 
1549         >>> (x*sin(x)*cos(y)).as_independent(x)
1550         (cos(y), x*sin(x))
1551 
1552         non-commutative terms cannot always be separated out when self is a Mul
1553 
1554         >>> from sympy import symbols
1555         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1556         >>> (n1 + n1*n2).as_independent(n2)
1557         (n1, n1*n2)
1558         >>> (n2*n1 + n1*n2).as_independent(n2)
1559         (0, n1*n2 + n2*n1)
1560         >>> (n1*n2*n3).as_independent(n1)
1561         (1, n1*n2*n3)
1562         >>> (n1*n2*n3).as_independent(n2)
1563         (n1, n2*n3)
1564         >>> ((x-n1)*(x-y)).as_independent(x)
1565         (1, (x - y)*(x - n1))
1566 
1567         -- self is anything else:
1568 
1569         >>> (sin(x)).as_independent(x)
1570         (1, sin(x))
1571         >>> (sin(x)).as_independent(y)
1572         (sin(x), 1)
1573         >>> exp(x+y).as_independent(x)
1574         (1, exp(x + y))
1575 
1576         -- force self to be treated as an Add:
1577 
1578         >>> (3*x).as_independent(x, as_Add=True)
1579         (0, 3*x)
1580 
1581         -- force self to be treated as a Mul:
1582 
1583         >>> (3+x).as_independent(x, as_Add=False)
1584         (1, x + 3)
1585         >>> (-3+x).as_independent(x, as_Add=False)
1586         (1, x - 3)
1587 
1588         Note how the below differs from the above in making the
1589         constant on the dep term positive.
1590 
1591         >>> (y*(-3+x)).as_independent(x)
1592         (y, x - 3)
1593 
1594         -- use .as_independent() for true independence testing instead
1595            of .has(). The former considers only symbols in the free
1596            symbols while the latter considers all symbols
1597 
1598         >>> from sympy import Integral
1599         >>> I = Integral(x, (x, 1, 2))
1600         >>> I.has(x)
1601         True
1602         >>> x in I.free_symbols
1603         False
1604         >>> I.as_independent(x) == (I, 1)
1605         True
1606         >>> (I + x).as_independent(x) == (I, x)
1607         True
1608 
1609         Note: when trying to get independent terms, a separation method
1610         might need to be used first. In this case, it is important to keep
1611         track of what you send to this routine so you know how to interpret
1612         the returned values
1613 
1614         >>> from sympy import separatevars, log
1615         >>> separatevars(exp(x+y)).as_independent(x)
1616         (exp(y), exp(x))
1617         >>> (x + x*y).as_independent(y)
1618         (x, x*y)
1619         >>> separatevars(x + x*y).as_independent(y)
1620         (x, y + 1)
1621         >>> (x*(1 + y)).as_independent(y)
1622         (x, y + 1)
1623         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1624         (x, x*y)
1625         >>> a, b=symbols('a b', positive=True)
1626         >>> (log(a*b).expand(log=True)).as_independent(b)
1627         (log(a), log(b))
1628 
1629         See Also
1630         ========
1631         .separatevars(), .expand(log=True), Add.as_two_terms(),
1632         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1633         """
1634         from .symbol import Symbol
1635         from .add import _unevaluated_Add
1636         from .mul import _unevaluated_Mul
1637         from sympy.utilities.iterables import sift
1638 
1639         if self.is_zero:
1640             return S.Zero, S.Zero
1641 
1642         func = self.func
1643         if hint.get('as_Add', func is Add):
1644             want = Add
1645         else:
1646             want = Mul
1647 
1648         # sift out deps into symbolic and other and ignore
1649         # all symbols but those that are in the free symbols
1650         sym = set()
1651         other = []
1652         for d in deps:
1653             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1654                 sym.add(d)
1655             else:
1656                 other.append(d)
1657 
1658         def has(e):
1659             """return the standard has() if there are no literal symbols, else
1660             check to see that symbol-deps are in the free symbols."""
1661             has_other = e.has(*other)
1662             if not sym:
1663                 return has_other
1664             return has_other or e.has(*(e.free_symbols & sym))
1665 
1666         if (want is not func or
1667                 func is not Add and func is not Mul):
1668             if has(self):
1669                 return (want.identity, self)
1670             else:
1671                 return (self, want.identity)
1672         else:
1673             if func is Add:
1674                 args = list(self.args)
1675             else:
1676                 args, nc = self.args_cnc()
1677 
1678         d = sift(args, lambda x: has(x))
1679         depend = d[True]
1680         indep = d[False]
1681         if func is Add:  # all terms were treated as commutative
1682             return (Add(*indep), _unevaluated_Add(*depend))
1683         else:  # handle noncommutative by stopping at first dependent term
1684             for i, n in enumerate(nc):
1685                 if has(n):
1686                     depend.extend(nc[i:])
1687                     break
1688                 indep.append(n)
1689             return Mul(*indep), (
1690                 Mul(*depend, evaluate=False) if nc else
1691                 _unevaluated_Mul(*depend))
1692 
1693     def as_real_imag(self, deep=True, **hints):
1694         """Performs complex expansion on 'self' and returns a tuple
1695            containing collected both real and imaginary parts. This
1696            method can't be confused with re() and im() functions,
1697            which does not perform complex expansion at evaluation.
1698 
1699            However it is possible to expand both re() and im()
1700            functions and get exactly the same results as with
1701            a single call to this function.
1702 
1703            >>> from sympy import symbols, I
1704 
1705            >>> x, y = symbols('x,y', real=True)
1706 
1707            >>> (x + y*I).as_real_imag()
1708            (x, y)
1709 
1710            >>> from sympy.abc import z, w
1711 
1712            >>> (z + w*I).as_real_imag()
1713            (re(z) - im(w), re(w) + im(z))
1714 
1715         """
1716         from sympy import im, re
1717         if hints.get('ignore') == self:
1718             return None
1719         else:
1720             return (re(self), im(self))
1721 
1722     def as_powers_dict(self):
1723         """Return self as a dictionary of factors with each factor being
1724         treated as a power. The keys are the bases of the factors and the
1725         values, the corresponding exponents. The resulting dictionary should
1726         be used with caution if the expression is a Mul and contains non-
1727         commutative factors since the order that they appeared will be lost in
1728         the dictionary."""
1729         d = defaultdict(int)
1730         d.update(dict([self.as_base_exp()]))
1731         return d
1732 
1733     def as_coefficients_dict(self):
1734         """Return a dictionary mapping terms to their Rational coefficient.
1735         Since the dictionary is a defaultdict, inquiries about terms which
1736         were not present will return a coefficient of 0. If an expression is
1737         not an Add it is considered to have a single term.
1738 
1739         Examples
1740         ========
1741 
1742         >>> from sympy.abc import a, x
1743         >>> (3*x + a*x + 4).as_coefficients_dict()
1744         {1: 4, x: 3, a*x: 1}
1745         >>> _[a]
1746         0
1747         >>> (3*a*x).as_coefficients_dict()
1748         {a*x: 3}
1749 
1750         """
1751         c, m = self.as_coeff_Mul()
1752         if not c.is_Rational:
1753             c = S.One
1754             m = self
1755         d = defaultdict(int)
1756         d.update({m: c})
1757         return d
1758 
1759     def as_base_exp(self):
1760         # a -> b ** e
1761         return self, S.One
1762 
1763     def as_coeff_mul(self, *deps, **kwargs):
1764         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1765 
1766         c should be a Rational multiplied by any factors of the Mul that are
1767         independent of deps.
1768 
1769         args should be a tuple of all other factors of m; args is empty
1770         if self is a Number or if self is independent of deps (when given).
1771 
1772         This should be used when you don't know if self is a Mul or not but
1773         you want to treat self as a Mul or if you want to process the
1774         individual arguments of the tail of self as a Mul.
1775 
1776         - if you know self is a Mul and want only the head, use self.args[0];
1777         - if you don't want to process the arguments of the tail but need the
1778           tail then use self.as_two_terms() which gives the head and tail;
1779         - if you want to split self into an independent and dependent parts
1780           use ``self.as_independent(*deps)``
1781 
1782         >>> from sympy import S
1783         >>> from sympy.abc import x, y
1784         >>> (S(3)).as_coeff_mul()
1785         (3, ())
1786         >>> (3*x*y).as_coeff_mul()
1787         (3, (x, y))
1788         >>> (3*x*y).as_coeff_mul(x)
1789         (3*y, (x,))
1790         >>> (3*y).as_coeff_mul(x)
1791         (3*y, ())
1792         """
1793         if deps:
1794             if not self.has(*deps):
1795                 return self, tuple()
1796         return S.One, (self,)
1797 
1798     def as_coeff_add(self, *deps):
1799         """Return the tuple (c, args) where self is written as an Add, ``a``.
1800 
1801         c should be a Rational added to any terms of the Add that are
1802         independent of deps.
1803 
1804         args should be a tuple of all other terms of ``a``; args is empty
1805         if self is a Number or if self is independent of deps (when given).
1806 
1807         This should be used when you don't know if self is an Add or not but
1808         you want to treat self as an Add or if you want to process the
1809         individual arguments of the tail of self as an Add.
1810 
1811         - if you know self is an Add and want only the head, use self.args[0];
1812         - if you don't want to process the arguments of the tail but need the
1813           tail then use self.as_two_terms() which gives the head and tail.
1814         - if you want to split self into an independent and dependent parts
1815           use ``self.as_independent(*deps)``
1816 
1817         >>> from sympy import S
1818         >>> from sympy.abc import x, y
1819         >>> (S(3)).as_coeff_add()
1820         (3, ())
1821         >>> (3 + x).as_coeff_add()
1822         (3, (x,))
1823         >>> (3 + x + y).as_coeff_add(x)
1824         (y + 3, (x,))
1825         >>> (3 + y).as_coeff_add(x)
1826         (y + 3, ())
1827 
1828         """
1829         if deps:
1830             if not self.has(*deps):
1831                 return self, tuple()
1832         return S.Zero, (self,)
1833 
1834     def primitive(self):
1835         """Return the positive Rational that can be extracted non-recursively
1836         from every term of self (i.e., self is treated like an Add). This is
1837         like the as_coeff_Mul() method but primitive always extracts a positive
1838         Rational (never a negative or a Float).
1839 
1840         Examples
1841         ========
1842 
1843         >>> from sympy.abc import x
1844         >>> (3*(x + 1)**2).primitive()
1845         (3, (x + 1)**2)
1846         >>> a = (6*x + 2); a.primitive()
1847         (2, 3*x + 1)
1848         >>> b = (x/2 + 3); b.primitive()
1849         (1/2, x + 6)
1850         >>> (a*b).primitive() == (1, a*b)
1851         True
1852         """
1853         if not self:
1854             return S.One, S.Zero
1855         c, r = self.as_coeff_Mul(rational=True)
1856         if c.is_negative:
1857             c, r = -c, -r
1858         return c, r
1859 
1860     def as_content_primitive(self, radical=False, clear=True):
1861         """This method should recursively remove a Rational from all arguments
1862         and return that (content) and the new self (primitive). The content
1863         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
1864         The primitive need not be in canonical form and should try to preserve
1865         the underlying structure if possible (i.e. expand_mul should not be
1866         applied to self).
1867 
1868         Examples
1869         ========
1870 
1871         >>> from sympy import sqrt
1872         >>> from sympy.abc import x, y, z
1873 
1874         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
1875 
1876         The as_content_primitive function is recursive and retains structure:
1877 
1878         >>> eq.as_content_primitive()
1879         (2, x + 3*y*(y + 1) + 1)
1880 
1881         Integer powers will have Rationals extracted from the base:
1882 
1883         >>> ((2 + 6*x)**2).as_content_primitive()
1884         (4, (3*x + 1)**2)
1885         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
1886         (1, (2*(3*x + 1))**(2*y))
1887 
1888         Terms may end up joining once their as_content_primitives are added:
1889 
1890         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1891         (11, x*(y + 1))
1892         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1893         (9, x*(y + 1))
1894         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
1895         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
1896         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
1897         (121, x**2*(y + 1)**2)
1898         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
1899         (1, 121.0*x**2*(y + 1)**2)
1900 
1901         Radical content can also be factored out of the primitive:
1902 
1903         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
1904         (2, sqrt(2)*(1 + 2*sqrt(5)))
1905 
1906         If clear=False (default is True) then content will not be removed
1907         from an Add if it can be distributed to leave one or more
1908         terms with integer coefficients.
1909 
1910         >>> (x/2 + y).as_content_primitive()
1911         (1/2, x + 2*y)
1912         >>> (x/2 + y).as_content_primitive(clear=False)
1913         (1, x/2 + y)
1914         """
1915         return S.One, self
1916 
1917     def as_numer_denom(self):
1918         """ expression -> a/b -> a, b
1919 
1920         This is just a stub that should be defined by
1921         an object's class methods to get anything else.
1922 
1923         See Also
1924         ========
1925         normal: return a/b instead of a, b
1926         """
1927 
1928         return self, S.One
1929 
1930     def normal(self):
1931         from .mul import _unevaluated_Mul
1932         n, d = self.as_numer_denom()
1933         if d is S.One:
1934             return n
1935         if d.is_Number:
1936             if d is S.One:
1937                 return n
1938             else:
1939                 return _unevaluated_Mul(n, 1/d)
1940         else:
1941             return n/d
1942 
1943     def extract_multiplicatively(self, c):
1944         """Return None if it's not possible to make self in the form
1945            c * something in a nice way, i.e. preserving the properties
1946            of arguments of self.
1947 
1948            >>> from sympy import symbols, Rational
1949 
1950            >>> x, y = symbols('x,y', real=True)
1951 
1952            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1953            x*y**2
1954 
1955            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1956 
1957            >>> (2*x).extract_multiplicatively(2)
1958            x
1959 
1960            >>> (2*x).extract_multiplicatively(3)
1961 
1962            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1963            x/6
1964 
1965         """
1966         from .function import _coeff_isneg
1967 
1968         c = sympify(c)
1969         if self is S.NaN:
1970             return None
1971         if c is S.One:
1972             return self
1973         elif c == self:
1974             return S.One
1975 
1976         if c.is_Add:
1977             cc, pc = c.primitive()
1978             if cc is not S.One:
1979                 c = Mul(cc, pc, evaluate=False)
1980 
1981         if c.is_Mul:
1982             a, b = c.as_two_terms()
1983             x = self.extract_multiplicatively(a)
1984             if x is not None:
1985                 return x.extract_multiplicatively(b)
1986 
1987         quotient = self / c
1988         if self.is_Number:
1989             if self is S.Infinity:
1990                 if c.is_positive:
1991                     return S.Infinity
1992             elif self is S.NegativeInfinity:
1993                 if c.is_negative:
1994                     return S.Infinity
1995                 elif c.is_positive:
1996                     return S.NegativeInfinity
1997             elif self is S.ComplexInfinity:
1998                 if not c.is_zero:
1999                     return S.ComplexInfinity
2000             elif self.is_Integer:
2001                 if not quotient.is_Integer:
2002                     return None
2003                 elif self.is_positive and quotient.is_negative:
2004                     return None
2005                 else:
2006                     return quotient
2007             elif self.is_Rational:
2008                 if not quotient.is_Rational:
2009                     return None
2010                 elif self.is_positive and quotient.is_negative:
2011                     return None
2012                 else:
2013                     return quotient
2014             elif self.is_Float:
2015                 if not quotient.is_Float:
2016                     return None
2017                 elif self.is_positive and quotient.is_negative:
2018                     return None
2019                 else:
2020                     return quotient
2021         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2022             if quotient.is_Mul and len(quotient.args) == 2:
2023                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2024                     return quotient
2025             elif quotient.is_Integer and c.is_Number:
2026                 return quotient
2027         elif self.is_Add:
2028             cs, ps = self.primitive()
2029             # assert cs >= 1
2030             if c.is_Number and c is not S.NegativeOne:
2031                 # assert c != 1 (handled at top)
2032                 if cs is not S.One:
2033                     if c.is_negative:
2034                         xc = -(cs.extract_multiplicatively(-c))
2035                     else:
2036                         xc = cs.extract_multiplicatively(c)
2037                     if xc is not None:
2038                         return xc*ps  # rely on 2-arg Mul to restore Add
2039                 return  # |c| != 1 can only be extracted from cs
2040             if c == ps:
2041                 return cs
2042             # check args of ps
2043             newargs = []
2044             for arg in ps.args:
2045                 newarg = arg.extract_multiplicatively(c)
2046                 if newarg is None:
2047                     return  # all or nothing
2048                 newargs.append(newarg)
2049             # args should be in same order so use unevaluated return
2050             if cs is not S.One:
2051                 return Add._from_args([cs*t for t in newargs])
2052             else:
2053                 return Add._from_args(newargs)
2054         elif self.is_Mul:
2055             args = list(self.args)
2056             for i, arg in enumerate(args):
2057                 newarg = arg.extract_multiplicatively(c)
2058                 if newarg is not None:
2059                     args[i] = newarg
2060                     return Mul(*args)
2061         elif self.is_Pow:
2062             if c.is_Pow and c.base == self.base:
2063                 new_exp = self.exp.extract_additively(c.exp)
2064                 if new_exp is not None:
2065                     return self.base ** (new_exp)
2066             elif c == self.base:
2067                 new_exp = self.exp.extract_additively(1)
2068                 if new_exp is not None:
2069                     return self.base ** (new_exp)
2070 
2071     def extract_additively(self, c):
2072         """Return self - c if it's possible to subtract c from self and
2073         make all matching coefficients move towards zero, else return None.
2074 
2075         Examples
2076         ========
2077 
2078         >>> from sympy.abc import x, y
2079         >>> e = 2*x + 3
2080         >>> e.extract_additively(x + 1)
2081         x + 2
2082         >>> e.extract_additively(3*x)
2083         >>> e.extract_additively(4)
2084         >>> (y*(x + 1)).extract_additively(x + 1)
2085         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2086         (x + 1)*(x + 2*y) + 3
2087 
2088         Sometimes auto-expansion will return a less simplified result
2089         than desired; gcd_terms might be used in such cases:
2090 
2091         >>> from sympy import gcd_terms
2092         >>> (4*x*(y + 1) + y).extract_additively(x)
2093         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2094         >>> gcd_terms(_)
2095         x*(4*y + 3) + y
2096 
2097         See Also
2098         ========
2099         extract_multiplicatively
2100         coeff
2101         as_coefficient
2102 
2103         """
2104 
2105         c = sympify(c)
2106         if self is S.NaN:
2107             return None
2108         if c is S.Zero:
2109             return self
2110         elif c == self:
2111             return S.Zero
2112         elif self is S.Zero:
2113             return None
2114 
2115         if self.is_Number:
2116             if not c.is_Number:
2117                 return None
2118             co = self
2119             diff = co - c
2120             # XXX should we match types? i.e should 3 - .1 succeed?
2121             if (co > 0 and diff > 0 and diff < co or
2122                     co < 0 and diff < 0 and diff > co):
2123                 return diff
2124             return None
2125 
2126         if c.is_Number:
2127             co, t = self.as_coeff_Add()
2128             xa = co.extract_additively(c)
2129             if xa is None:
2130                 return None
2131             return xa + t
2132 
2133         # handle the args[0].is_Number case separately
2134         # since we will have trouble looking for the coeff of
2135         # a number.
2136         if c.is_Add and c.args[0].is_Number:
2137             # whole term as a term factor
2138             co = self.coeff(c)
2139             xa0 = (co.extract_additively(1) or 0)*c
2140             if xa0:
2141                 diff = self - co*c
2142                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2143             # term-wise
2144             h, t = c.as_coeff_Add()
2145             sh, st = self.as_coeff_Add()
2146             xa = sh.extract_additively(h)
2147             if xa is None:
2148                 return None
2149             xa2 = st.extract_additively(t)
2150             if xa2 is None:
2151                 return None
2152             return xa + xa2
2153 
2154         # whole term as a term factor
2155         co = self.coeff(c)
2156         xa0 = (co.extract_additively(1) or 0)*c
2157         if xa0:
2158             diff = self - co*c
2159             return (xa0 + (diff.extract_additively(c) or diff)) or None
2160         # term-wise
2161         coeffs = []
2162         for a in Add.make_args(c):
2163             ac, at = a.as_coeff_Mul()
2164             co = self.coeff(at)
2165             if not co:
2166                 return None
2167             coc, cot = co.as_coeff_Add()
2168             xa = coc.extract_additively(ac)
2169             if xa is None:
2170                 return None
2171             self -= co*at
2172             coeffs.append((cot + xa)*at)
2173         coeffs.append(self)
2174         return Add(*coeffs)
2175 
2176     def could_extract_minus_sign(self):
2177         """Return True if self is not in a canonical form with respect
2178         to its sign.
2179 
2180         For most expressions, e, there will be a difference in e and -e.
2181         When there is, True will be returned for one and False for the
2182         other; False will be returned if there is no difference.
2183 
2184         Examples
2185         ========
2186 
2187         >>> from sympy.abc import x, y
2188         >>> e = x - y
2189         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2190         {False, True}
2191 
2192         """
2193         negative_self = -self
2194         if self == negative_self:
2195             return False  # e.g. zoo*x == -zoo*x
2196         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2197         negative_self_has_minus = (
2198             (negative_self).extract_multiplicatively(-1) is not None)
2199         if self_has_minus != negative_self_has_minus:
2200             return self_has_minus
2201         else:
2202             if self.is_Add:
2203                 # We choose the one with less arguments with minus signs
2204                 all_args = len(self.args)
2205                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2206                 positive_args = all_args - negative_args
2207                 if positive_args > negative_args:
2208                     return False
2209                 elif positive_args < negative_args:
2210                     return True
2211             elif self.is_Mul:
2212                 # We choose the one with an odd number of minus signs
2213                 num, den = self.as_numer_denom()
2214                 args = Mul.make_args(num) + Mul.make_args(den)
2215                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2216                 negative_args = list(filter(None, arg_signs))
2217                 return len(negative_args) % 2 == 1
2218 
2219             # As a last resort, we choose the one with greater value of .sort_key()
2220             return bool(self.sort_key() < negative_self.sort_key())
2221 
2222     def extract_branch_factor(self, allow_half=False):
2223         """
2224         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2225         Return (z, n).
2226 
2227         >>> from sympy import exp_polar, I, pi
2228         >>> from sympy.abc import x, y
2229         >>> exp_polar(I*pi).extract_branch_factor()
2230         (exp_polar(I*pi), 0)
2231         >>> exp_polar(2*I*pi).extract_branch_factor()
2232         (1, 1)
2233         >>> exp_polar(-pi*I).extract_branch_factor()
2234         (exp_polar(I*pi), -1)
2235         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2236         (exp_polar(x + I*pi), 1)
2237         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2238         (y*exp_polar(2*pi*x), -1)
2239         >>> exp_polar(-I*pi/2).extract_branch_factor()
2240         (exp_polar(-I*pi/2), 0)
2241 
2242         If allow_half is True, also extract exp_polar(I*pi):
2243 
2244         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2245         (1, 1/2)
2246         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2247         (1, 1)
2248         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2249         (1, 3/2)
2250         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2251         (1, -1/2)
2252         """
2253         from sympy import exp_polar, pi, I, ceiling, Add
2254         n = S(0)
2255         res = S(1)
2256         args = Mul.make_args(self)
2257         exps = []
2258         for arg in args:
2259             if arg.func is exp_polar:
2260                 exps += [arg.exp]
2261             else:
2262                 res *= arg
2263         piimult = S(0)
2264         extras = []
2265         while exps:
2266             exp = exps.pop()
2267             if exp.is_Add:
2268                 exps += exp.args
2269                 continue
2270             if exp.is_Mul:
2271                 coeff = exp.as_coefficient(pi*I)
2272                 if coeff is not None:
2273                     piimult += coeff
2274                     continue
2275             extras += [exp]
2276         if not piimult.free_symbols:
2277             coeff = piimult
2278             tail = ()
2279         else:
2280             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2281         # round down to nearest multiple of 2
2282         branchfact = ceiling(coeff/2 - S(1)/2)*2
2283         n += branchfact/2
2284         c = coeff - branchfact
2285         if allow_half:
2286             nc = c.extract_additively(1)
2287             if nc is not None:
2288                 n += S(1)/2
2289                 c = nc
2290         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2291         if newexp != 0:
2292             res *= exp_polar(newexp)
2293         return res, n
2294 
2295     def _eval_is_polynomial(self, syms):
2296         if self.free_symbols.intersection(syms) == set([]):
2297             return True
2298         return False
2299 
2300     def is_polynomial(self, *syms):
2301         r"""
2302         Return True if self is a polynomial in syms and False otherwise.
2303 
2304         This checks if self is an exact polynomial in syms.  This function
2305         returns False for expressions that are "polynomials" with symbolic
2306         exponents.  Thus, you should be able to apply polynomial algorithms to
2307         expressions for which this returns True, and Poly(expr, \*syms) should
2308         work if and only if expr.is_polynomial(\*syms) returns True. The
2309         polynomial does not have to be in expanded form.  If no symbols are
2310         given, all free symbols in the expression will be used.
2311 
2312         This is not part of the assumptions system.  You cannot do
2313         Symbol('z', polynomial=True).
2314 
2315         Examples
2316         ========
2317 
2318         >>> from sympy import Symbol
2319         >>> x = Symbol('x')
2320         >>> ((x**2 + 1)**4).is_polynomial(x)
2321         True
2322         >>> ((x**2 + 1)**4).is_polynomial()
2323         True
2324         >>> (2**x + 1).is_polynomial(x)
2325         False
2326 
2327 
2328         >>> n = Symbol('n', nonnegative=True, integer=True)
2329         >>> (x**n + 1).is_polynomial(x)
2330         False
2331 
2332         This function does not attempt any nontrivial simplifications that may
2333         result in an expression that does not appear to be a polynomial to
2334         become one.
2335 
2336         >>> from sympy import sqrt, factor, cancel
2337         >>> y = Symbol('y', positive=True)
2338         >>> a = sqrt(y**2 + 2*y + 1)
2339         >>> a.is_polynomial(y)
2340         False
2341         >>> factor(a)
2342         y + 1
2343         >>> factor(a).is_polynomial(y)
2344         True
2345 
2346         >>> b = (y**2 + 2*y + 1)/(y + 1)
2347         >>> b.is_polynomial(y)
2348         False
2349         >>> cancel(b)
2350         y + 1
2351         >>> cancel(b).is_polynomial(y)
2352         True
2353 
2354         See also .is_rational_function()
2355 
2356         """
2357         if syms:
2358             syms = set(map(sympify, syms))
2359         else:
2360             syms = self.free_symbols
2361 
2362         if syms.intersection(self.free_symbols) == set([]):
2363             # constant polynomial
2364             return True
2365         else:
2366             return self._eval_is_polynomial(syms)
2367 
2368     def _eval_is_rational_function(self, syms):
2369         if self.free_symbols.intersection(syms) == set([]):
2370             return True
2371         return False
2372 
2373     def is_rational_function(self, *syms):
2374         """
2375         Test whether function is a ratio of two polynomials in the given
2376         symbols, syms. When syms is not given, all free symbols will be used.
2377         The rational function does not have to be in expanded or in any kind of
2378         canonical form.
2379 
2380         This function returns False for expressions that are "rational
2381         functions" with symbolic exponents.  Thus, you should be able to call
2382         .as_numer_denom() and apply polynomial algorithms to the result for
2383         expressions for which this returns True.
2384 
2385         This is not part of the assumptions system.  You cannot do
2386         Symbol('z', rational_function=True).
2387 
2388         Examples
2389         ========
2390 
2391         >>> from sympy import Symbol, sin
2392         >>> from sympy.abc import x, y
2393 
2394         >>> (x/y).is_rational_function()
2395         True
2396 
2397         >>> (x**2).is_rational_function()
2398         True
2399 
2400         >>> (x/sin(y)).is_rational_function(y)
2401         False
2402 
2403         >>> n = Symbol('n', integer=True)
2404         >>> (x**n + 1).is_rational_function(x)
2405         False
2406 
2407         This function does not attempt any nontrivial simplifications that may
2408         result in an expression that does not appear to be a rational function
2409         to become one.
2410 
2411         >>> from sympy import sqrt, factor
2412         >>> y = Symbol('y', positive=True)
2413         >>> a = sqrt(y**2 + 2*y + 1)/y
2414         >>> a.is_rational_function(y)
2415         False
2416         >>> factor(a)
2417         (y + 1)/y
2418         >>> factor(a).is_rational_function(y)
2419         True
2420 
2421         See also is_algebraic_expr().
2422 
2423         """
2424         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2425             return False
2426 
2427         if syms:
2428             syms = set(map(sympify, syms))
2429         else:
2430             syms = self.free_symbols
2431 
2432         if syms.intersection(self.free_symbols) == set([]):
2433             # constant rational function
2434             return True
2435         else:
2436             return self._eval_is_rational_function(syms)
2437 
2438     def _eval_is_algebraic_expr(self, syms):
2439         if self.free_symbols.intersection(syms) == set([]):
2440             return True
2441         return False
2442 
2443     def is_algebraic_expr(self, *syms):
2444         """
2445         This tests whether a given expression is algebraic or not, in the
2446         given symbols, syms. When syms is not given, all free symbols
2447         will be used. The rational function does not have to be in expanded
2448         or in any kind of canonical form.
2449 
2450         This function returns False for expressions that are "algebraic
2451         expressions" with symbolic exponents. This is a simple extension to the
2452         is_rational_function, including rational exponentiation.
2453 
2454         Examples
2455         ========
2456 
2457         >>> from sympy import Symbol, sqrt
2458         >>> x = Symbol('x', real=True)
2459         >>> sqrt(1 + x).is_rational_function()
2460         False
2461         >>> sqrt(1 + x).is_algebraic_expr()
2462         True
2463 
2464         This function does not attempt any nontrivial simplifications that may
2465         result in an expression that does not appear to be an algebraic
2466         expression to become one.
2467 
2468         >>> from sympy import exp, factor
2469         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2470         >>> a.is_algebraic_expr(x)
2471         False
2472         >>> factor(a).is_algebraic_expr()
2473         True
2474 
2475         See Also
2476         ========
2477         is_rational_function()
2478 
2479         References
2480         ==========
2481 
2482         - http://en.wikipedia.org/wiki/Algebraic_expression
2483 
2484         """
2485         if syms:
2486             syms = set(map(sympify, syms))
2487         else:
2488             syms = self.free_symbols
2489 
2490         if syms.intersection(self.free_symbols) == set([]):
2491             # constant algebraic expression
2492             return True
2493         else:
2494             return self._eval_is_algebraic_expr(syms)
2495 
2496     ###################################################################################
2497     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2498     ###################################################################################
2499 
2500     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2501         """
2502         Series expansion of "self" around ``x = x0`` yielding either terms of
2503         the series one by one (the lazy series given when n=None), else
2504         all the terms at once when n != None.
2505 
2506         Returns the series expansion of "self" around the point ``x = x0``
2507         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2508 
2509         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2510         be supplied, otherwise an error will be raised.
2511 
2512         >>> from sympy import cos, exp
2513         >>> from sympy.abc import x, y
2514         >>> cos(x).series()
2515         1 - x**2/2 + x**4/24 + O(x**6)
2516         >>> cos(x).series(n=4)
2517         1 - x**2/2 + O(x**4)
2518         >>> cos(x).series(x, x0=1, n=2)
2519         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2520         >>> e = cos(x + exp(y))
2521         >>> e.series(y, n=2)
2522         cos(x + 1) - y*sin(x + 1) + O(y**2)
2523         >>> e.series(x, n=2)
2524         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2525 
2526         If ``n=None`` then a generator of the series terms will be returned.
2527 
2528         >>> term=cos(x).series(n=None)
2529         >>> [next(term) for i in range(2)]
2530         [1, -x**2/2]
2531 
2532         For ``dir=+`` (default) the series is calculated from the right and
2533         for ``dir=-`` the series from the left. For smooth functions this
2534         flag will not alter the results.
2535 
2536         >>> abs(x).series(dir="+")
2537         x
2538         >>> abs(x).series(dir="-")
2539         -x
2540 
2541         """
2542         from sympy import collect, Dummy, Order, Rational, Symbol
2543         if x is None:
2544             syms = self.atoms(Symbol)
2545             if not syms:
2546                 return self
2547             elif len(syms) > 1:
2548                 raise ValueError('x must be given for multivariate functions.')
2549             x = syms.pop()
2550 
2551         if not self.has(x):
2552             if n is None:
2553                 return (s for s in [self])
2554             else:
2555                 return self
2556 
2557         if len(dir) != 1 or dir not in '+-':
2558             raise ValueError("Dir must be '+' or '-'")
2559 
2560         if x0 in [S.Infinity, S.NegativeInfinity]:
2561             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]
2562             s = self.subs(x, 1/x).series(x, n=n, dir=dir)
2563             if n is None:
2564                 return (si.subs(x, 1/x) for si in s)
2565             return s.subs(x, 1/x)
2566 
2567         # use rep to shift origin to x0 and change sign (if dir is negative)
2568         # and undo the process with rep2
2569         if x0 or dir == '-':
2570             if dir == '-':
2571                 rep = -x + x0
2572                 rep2 = -x
2573                 rep2b = x0
2574             else:
2575                 rep = x + x0
2576                 rep2 = x
2577                 rep2b = -x0
2578             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2579             if n is None:  # lseries...
2580                 return (si.subs(x, rep2 + rep2b) for si in s)
2581             return s.subs(x, rep2 + rep2b)
2582 
2583         # from here on it's x0=0 and dir='+' handling
2584 
2585         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2586             # replace x with an x that has a positive assumption
2587             xpos = Dummy('x', positive=True, finite=True)
2588             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2589             if n is None:
2590                 return (s.subs(xpos, x) for s in rv)
2591             else:
2592                 return rv.subs(xpos, x)
2593 
2594         if n is not None:  # nseries handling
2595             s1 = self._eval_nseries(x, n=n, logx=logx)
2596             o = s1.getO() or S.Zero
2597             if o:
2598                 # make sure the requested order is returned
2599                 ngot = o.getn()
2600                 if ngot > n:
2601                     # leave o in its current form (e.g. with x*log(x)) so
2602                     # it eats terms properly, then replace it below
2603                     if n != 0:
2604                         s1 += o.subs(x, x**Rational(n, ngot))
2605                     else:
2606                         s1 += Order(1, x)
2607                 elif ngot < n:
2608                     # increase the requested number of terms to get the desired
2609                     # number keep increasing (up to 9) until the received order
2610                     # is different than the original order and then predict how
2611                     # many additional terms are needed
2612                     for more in range(1, 9):
2613                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2614                         newn = s1.getn()
2615                         if newn != ngot:
2616                             ndo = n + (n - ngot)*more/(newn - ngot)
2617                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2618                             while s1.getn() < n:
2619                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2620                                 ndo += 1
2621                             break
2622                     else:
2623                         raise ValueError('Could not calculate %s terms for %s'
2624                                          % (str(n), self))
2625                     s1 += Order(x**n, x)
2626                 o = s1.getO()
2627                 s1 = s1.removeO()
2628             else:
2629                 o = Order(x**n, x)
2630                 s1done = s1.doit()
2631                 if (s1done + o).removeO() == s1done:
2632                     o = S.Zero
2633 
2634             try:
2635                 return collect(s1, x) + o
2636             except NotImplementedError:
2637                 return s1 + o
2638 
2639         else:  # lseries handling
2640             def yield_lseries(s):
2641                 """Return terms of lseries one at a time."""
2642                 for si in s:
2643                     if not si.is_Add:
2644                         yield si
2645                         continue
2646                     # yield terms 1 at a time if possible
2647                     # by increasing order until all the
2648                     # terms have been returned
2649                     yielded = 0
2650                     o = Order(si, x)*x
2651                     ndid = 0
2652                     ndo = len(si.args)
2653                     while 1:
2654                         do = (si - yielded + o).removeO()
2655                         o *= x
2656                         if not do or do.is_Order:
2657                             continue
2658                         if do.is_Add:
2659                             ndid += len(do.args)
2660                         else:
2661                             ndid += 1
2662                         yield do
2663                         if ndid == ndo:
2664                             break
2665                         yielded += do
2666 
2667             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2668 
2669     def taylor_term(self, n, x, *previous_terms):
2670         """General method for the taylor term.
2671 
2672         This method is slow, because it differentiates n-times. Subclasses can
2673         redefine it to make it faster by using the "previous_terms".
2674         """
2675         from sympy import Dummy, factorial
2676         x = sympify(x)
2677         _x = Dummy('x')
2678         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2679 
2680     def lseries(self, x=None, x0=0, dir='+', logx=None):
2681         """
2682         Wrapper for series yielding an iterator of the terms of the series.
2683 
2684         Note: an infinite series will yield an infinite iterator. The following,
2685         for exaxmple, will never terminate. It will just keep printing terms
2686         of the sin(x) series::
2687 
2688           for term in sin(x).lseries(x):
2689               print term
2690 
2691         The advantage of lseries() over nseries() is that many times you are
2692         just interested in the next term in the series (i.e. the first term for
2693         example), but you don't know how many you should ask for in nseries()
2694         using the "n" parameter.
2695 
2696         See also nseries().
2697         """
2698         return self.series(x, x0, n=None, dir=dir, logx=logx)
2699 
2700     def _eval_lseries(self, x, logx=None):
2701         # default implementation of lseries is using nseries(), and adaptively
2702         # increasing the "n". As you can see, it is not very efficient, because
2703         # we are calculating the series over and over again. Subclasses should
2704         # override this method and implement much more efficient yielding of
2705         # terms.
2706         n = 0
2707         series = self._eval_nseries(x, n=n, logx=logx)
2708         if not series.is_Order:
2709             if series.is_Add:
2710                 yield series.removeO()
2711             else:
2712                 yield series
2713             return
2714 
2715         while series.is_Order:
2716             n += 1
2717             series = self._eval_nseries(x, n=n, logx=logx)
2718         e = series.removeO()
2719         yield e
2720         while 1:
2721             while 1:
2722                 n += 1
2723                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2724                 if e != series:
2725                     break
2726             yield series - e
2727             e = series
2728 
2729     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2730         """
2731         Wrapper to _eval_nseries if assumptions allow, else to series.
2732 
2733         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2734         called. This calculates "n" terms in the innermost expressions and
2735         then builds up the final series just by "cross-multiplying" everything
2736         out.
2737 
2738         The optional ``logx`` parameter can be used to replace any log(x) in the
2739         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2740         symbol to use in place of log(x) should be provided.
2741 
2742         Advantage -- it's fast, because we don't have to determine how many
2743         terms we need to calculate in advance.
2744 
2745         Disadvantage -- you may end up with less terms than you may have
2746         expected, but the O(x**n) term appended will always be correct and
2747         so the result, though perhaps shorter, will also be correct.
2748 
2749         If any of those assumptions is not met, this is treated like a
2750         wrapper to series which will try harder to return the correct
2751         number of terms.
2752 
2753         See also lseries().
2754 
2755         Examples
2756         ========
2757 
2758         >>> from sympy import sin, log, Symbol
2759         >>> from sympy.abc import x, y
2760         >>> sin(x).nseries(x, 0, 6)
2761         x - x**3/6 + x**5/120 + O(x**6)
2762         >>> log(x+1).nseries(x, 0, 5)
2763         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2764 
2765         Handling of the ``logx`` parameter --- in the following example the
2766         expansion fails since ``sin`` does not have an asymptotic expansion
2767         at -oo (the limit of log(x) as x approaches 0):
2768 
2769         >>> e = sin(log(x))
2770         >>> e.nseries(x, 0, 6)
2771         Traceback (most recent call last):
2772         ...
2773         PoleError: ...
2774         ...
2775         >>> logx = Symbol('logx')
2776         >>> e.nseries(x, 0, 6, logx=logx)
2777         sin(logx)
2778 
2779         In the following example, the expansion works but gives only an Order term
2780         unless the ``logx`` parameter is used:
2781 
2782         >>> e = x**y
2783         >>> e.nseries(x, 0, 2)
2784         O(log(x)**2)
2785         >>> e.nseries(x, 0, 2, logx=logx)
2786         exp(logx*y)
2787 
2788         """
2789         if x and not x in self.free_symbols:
2790             return self
2791         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2792             return self.series(x, x0, n, dir)
2793         else:
2794             return self._eval_nseries(x, n=n, logx=logx)
2795 
2796     def _eval_nseries(self, x, n, logx):
2797         """
2798         Return terms of series for self up to O(x**n) at x=0
2799         from the positive direction.
2800 
2801         This is a method that should be overridden in subclasses. Users should
2802         never call this method directly (use .nseries() instead), so you don't
2803         have to write docstrings for _eval_nseries().
2804         """
2805         from sympy.utilities.misc import filldedent
2806         raise NotImplementedError(filldedent("""
2807                      The _eval_nseries method should be added to
2808                      %s to give terms up to O(x**n) at x=0
2809                      from the positive direction so it is available when
2810                      nseries calls it.""" % self.func)
2811                      )
2812 
2813     def limit(self, x, xlim, dir='+'):
2814         """ Compute limit x->xlim.
2815         """
2816         from sympy.series.limits import limit
2817         return limit(self, x, xlim, dir)
2818 
2819     def compute_leading_term(self, x, logx=None):
2820         """
2821         as_leading_term is only allowed for results of .series()
2822         This is a wrapper to compute a series first.
2823         """
2824         from sympy import Dummy, log
2825         from sympy.series.gruntz import calculate_series
2826 
2827         if self.removeO() == 0:
2828             return self
2829 
2830         if logx is None:
2831             d = Dummy('logx')
2832             s = calculate_series(self, x, d).subs(d, log(x))
2833         else:
2834             s = calculate_series(self, x, logx)
2835 
2836         return s.as_leading_term(x)
2837 
2838     @cacheit
2839     def as_leading_term(self, *symbols):
2840         """
2841         Returns the leading (nonzero) term of the series expansion of self.
2842 
2843         The _eval_as_leading_term routines are used to do this, and they must
2844         always return a non-zero value.
2845 
2846         Examples
2847         ========
2848 
2849         >>> from sympy.abc import x
2850         >>> (1 + x + x**2).as_leading_term(x)
2851         1
2852         >>> (1/x**2 + x + x**2).as_leading_term(x)
2853         x**(-2)
2854 
2855         """
2856         from sympy import powsimp
2857         if len(symbols) > 1:
2858             c = self
2859             for x in symbols:
2860                 c = c.as_leading_term(x)
2861             return c
2862         elif not symbols:
2863             return self
2864         x = sympify(symbols[0])
2865         if not x.is_Symbol:
2866             raise ValueError('expecting a Symbol but got %s' % x)
2867         if x not in self.free_symbols:
2868             return self
2869         obj = self._eval_as_leading_term(x)
2870         if obj is not None:
2871             return powsimp(obj, deep=True, combine='exp')
2872         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
2873 
2874     def _eval_as_leading_term(self, x):
2875         return self
2876 
2877     def as_coeff_exponent(self, x):
2878         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
2879         """
2880         from sympy import collect
2881         s = collect(self, x)
2882         c, p = s.as_coeff_mul(x)
2883         if len(p) == 1:
2884             b, e = p[0].as_base_exp()
2885             if b == x:
2886                 return c, e
2887         return s, S.Zero
2888 
2889     def leadterm(self, x):
2890         """
2891         Returns the leading term a*x**b as a tuple (a, b).
2892 
2893         Examples
2894         ========
2895 
2896         >>> from sympy.abc import x
2897         >>> (1+x+x**2).leadterm(x)
2898         (1, 0)
2899         >>> (1/x**2+x+x**2).leadterm(x)
2900         (1, -2)
2901 
2902         """
2903         from sympy import Dummy, log
2904         l = self.as_leading_term(x)
2905         d = Dummy('logx')
2906         if l.has(log(x)):
2907             l = l.subs(log(x), d)
2908         c, e = l.as_coeff_exponent(x)
2909         if x in c.free_symbols:
2910             from sympy.utilities.misc import filldedent
2911             raise ValueError(filldedent("""
2912                 cannot compute leadterm(%s, %s). The coefficient
2913                 should have been free of x but got %s""" % (self, x, c)))
2914         c = c.subs(d, log(x))
2915         return c, e
2916 
2917     def as_coeff_Mul(self, rational=False):
2918         """Efficiently extract the coefficient of a product. """
2919         return S.One, self
2920 
2921     def as_coeff_Add(self, rational=False):
2922         """Efficiently extract the coefficient of a summation. """
2923         return S.Zero, self
2924 
2925     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
2926             full=False):
2927         """
2928         Compute formal power power series of self.
2929 
2930         See the docstring of the :func:`fps` function in sympy.series.formal for
2931         more information.
2932         """
2933         from sympy.series.formal import fps
2934 
2935         return fps(self, x, x0, dir, hyper, order, rational, full)
2936 
2937     def fourier_series(self, limits=None):
2938         """Compute fourier sine/cosine series of self.
2939 
2940         See the docstring of the :func:`fourier_series` in sympy.series.fourier
2941         for more information.
2942         """
2943         from sympy.series.fourier import fourier_series
2944 
2945         return fourier_series(self, limits)
2946 
2947     ###################################################################################
2948     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
2949     ###################################################################################
2950 
2951     def diff(self, *symbols, **assumptions):
2952         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z
2953         assumptions.setdefault("evaluate", True)
2954         return Derivative(self, *new_symbols, **assumptions)
2955 
2956     ###########################################################################
2957     ###################### EXPRESSION EXPANSION METHODS #######################
2958     ###########################################################################
2959 
2960     # Relevant subclasses should override _eval_expand_hint() methods.  See
2961     # the docstring of expand() for more info.
2962 
2963     def _eval_expand_complex(self, **hints):
2964         real, imag = self.as_real_imag(**hints)
2965         return real + S.ImaginaryUnit*imag
2966 
2967     @staticmethod
2968     def _expand_hint(expr, hint, deep=True, **hints):
2969         """
2970         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
2971 
2972         Returns ``(expr, hit)``, where expr is the (possibly) expanded
2973         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
2974         ``False`` otherwise.
2975         """
2976         hit = False
2977         # XXX: Hack to support non-Basic args
2978         #              |
2979         #              V
2980         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
2981             sargs = []
2982             for arg in expr.args:
2983                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
2984                 hit |= arghit
2985                 sargs.append(arg)
2986 
2987             if hit:
2988                 expr = expr.func(*sargs)
2989 
2990         if hasattr(expr, hint):
2991             newexpr = getattr(expr, hint)(**hints)
2992             if newexpr != expr:
2993                 return (newexpr, True)
2994 
2995         return (expr, hit)
2996 
2997     @cacheit
2998     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
2999             mul=True, log=True, multinomial=True, basic=True, **hints):
3000         """
3001         Expand an expression using hints.
3002 
3003         See the docstring of the expand() function in sympy.core.function for
3004         more information.
3005 
3006         """
3007         from sympy.simplify.radsimp import fraction
3008 
3009         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3010            log=log, multinomial=multinomial, basic=basic)
3011 
3012         expr = self
3013         if hints.pop('frac', False):
3014             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3015                     for a in fraction(self)]
3016             return n/d
3017         elif hints.pop('denom', False):
3018             n, d = fraction(self)
3019             return n/d.expand(deep=deep, modulus=modulus, **hints)
3020         elif hints.pop('numer', False):
3021             n, d = fraction(self)
3022             return n.expand(deep=deep, modulus=modulus, **hints)/d
3023 
3024         # Although the hints are sorted here, an earlier hint may get applied
3025         # at a given node in the expression tree before another because of how
3026         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3027         # x*z) because while applying log at the top level, log and mul are
3028         # applied at the deeper level in the tree so that when the log at the
3029         # upper level gets applied, the mul has already been applied at the
3030         # lower level.
3031 
3032         # Additionally, because hints are only applied once, the expression
3033         # may not be expanded all the way.   For example, if mul is applied
3034         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3035         # now, we just use a special case to make multinomial run before mul,
3036         # so that at least polynomials will be expanded all the way.  In the
3037         # future, smarter heuristics should be applied.
3038         # TODO: Smarter heuristics
3039 
3040         def _expand_hint_key(hint):
3041             """Make multinomial come before mul"""
3042             if hint == 'mul':
3043                 return 'mulz'
3044             return hint
3045 
3046         for hint in sorted(hints.keys(), key=_expand_hint_key):
3047             use_hint = hints[hint]
3048             if use_hint:
3049                 hint = '_eval_expand_' + hint
3050                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3051 
3052         while True:
3053             was = expr
3054             if hints.get('multinomial', False):
3055                 expr, _ = Expr._expand_hint(
3056                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3057             if hints.get('mul', False):
3058                 expr, _ = Expr._expand_hint(
3059                     expr, '_eval_expand_mul', deep=deep, **hints)
3060             if hints.get('log', False):
3061                 expr, _ = Expr._expand_hint(
3062                     expr, '_eval_expand_log', deep=deep, **hints)
3063             if expr == was:
3064                 break
3065 
3066         if modulus is not None:
3067             modulus = sympify(modulus)
3068 
3069             if not modulus.is_Integer or modulus <= 0:
3070                 raise ValueError(
3071                     "modulus must be a positive integer, got %s" % modulus)
3072 
3073             terms = []
3074 
3075             for term in Add.make_args(expr):
3076                 coeff, tail = term.as_coeff_Mul(rational=True)
3077 
3078                 coeff %= modulus
3079 
3080                 if coeff:
3081                     terms.append(coeff*tail)
3082 
3083             expr = Add(*terms)
3084 
3085         return expr
3086 
3087     ###########################################################################
3088     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3089     ###########################################################################
3090 
3091     def integrate(self, *args, **kwargs):
3092         """See the integrate function in sympy.integrals"""
3093         from sympy.integrals import integrate
3094         return integrate(self, *args, **kwargs)
3095 
3096     def simplify(self, ratio=1.7, measure=None):
3097         """See the simplify function in sympy.simplify"""
3098         from sympy.simplify import simplify
3099         from sympy.core.function import count_ops
3100         measure = measure or count_ops
3101         return simplify(self, ratio, measure)
3102 
3103     def nsimplify(self, constants=[], tolerance=None, full=False):
3104         """See the nsimplify function in sympy.simplify"""
3105         from sympy.simplify import nsimplify
3106         return nsimplify(self, constants, tolerance, full)
3107 
3108     def separate(self, deep=False, force=False):
3109         """See the separate function in sympy.simplify"""
3110         from sympy.core.function import expand_power_base
3111         return expand_power_base(self, deep=deep, force=force)
3112 
3113     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3114         """See the collect function in sympy.simplify"""
3115         from sympy.simplify import collect
3116         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3117 
3118     def together(self, *args, **kwargs):
3119         """See the together function in sympy.polys"""
3120         from sympy.polys import together
3121         return together(self, *args, **kwargs)
3122 
3123     def apart(self, x=None, **args):
3124         """See the apart function in sympy.polys"""
3125         from sympy.polys import apart
3126         return apart(self, x, **args)
3127 
3128     def ratsimp(self):
3129         """See the ratsimp function in sympy.simplify"""
3130         from sympy.simplify import ratsimp
3131         return ratsimp(self)
3132 
3133     def trigsimp(self, **args):
3134         """See the trigsimp function in sympy.simplify"""
3135         from sympy.simplify import trigsimp
3136         return trigsimp(self, **args)
3137 
3138     def radsimp(self, **kwargs):
3139         """See the radsimp function in sympy.simplify"""
3140         from sympy.simplify import radsimp
3141         return radsimp(self, **kwargs)
3142 
3143     def powsimp(self, *args, **kwargs):
3144         """See the powsimp function in sympy.simplify"""
3145         from sympy.simplify import powsimp
3146         return powsimp(self, *args, **kwargs)
3147 
3148     def combsimp(self):
3149         """See the combsimp function in sympy.simplify"""
3150         from sympy.simplify import combsimp
3151         return combsimp(self)
3152 
3153     def gammasimp(self):
3154         """See the gammasimp function in sympy.simplify"""
3155         from sympy.simplify import gammasimp
3156         return gammasimp(self)
3157 
3158     def factor(self, *gens, **args):
3159         """See the factor() function in sympy.polys.polytools"""
3160         from sympy.polys import factor
3161         return factor(self, *gens, **args)
3162 
3163     def refine(self, assumption=True):
3164         """See the refine function in sympy.assumptions"""
3165         from sympy.assumptions import refine
3166         return refine(self, assumption)
3167 
3168     def cancel(self, *gens, **args):
3169         """See the cancel function in sympy.polys"""
3170         from sympy.polys import cancel
3171         return cancel(self, *gens, **args)
3172 
3173     def invert(self, g, *gens, **args):
3174         """Return the multiplicative inverse of ``self`` mod ``g``
3175         where ``self`` (and ``g``) may be symbolic expressions).
3176 
3177         See Also
3178         ========
3179         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3180         """
3181         from sympy.polys.polytools import invert
3182         from sympy.core.numbers import mod_inverse
3183         if self.is_number and getattr(g, 'is_number', True):
3184             return mod_inverse(self, g)
3185         return invert(self, g, *gens, **args)
3186 
3187     def round(self, p=0):
3188         """Return x rounded to the given decimal place.
3189 
3190         If a complex number would results, apply round to the real
3191         and imaginary components of the number.
3192 
3193         Examples
3194         ========
3195 
3196         >>> from sympy import pi, E, I, S, Add, Mul, Number
3197         >>> S(10.5).round()
3198         11.
3199         >>> pi.round()
3200         3.
3201         >>> pi.round(2)
3202         3.14
3203         >>> (2*pi + E*I).round()
3204         6. + 3.*I
3205 
3206         The round method has a chopping effect:
3207 
3208         >>> (2*pi + I/10).round()
3209         6.
3210         >>> (pi/10 + 2*I).round()
3211         2.*I
3212         >>> (pi/10 + E*I).round(2)
3213         0.31 + 2.72*I
3214 
3215         Notes
3216         =====
3217 
3218         Do not confuse the Python builtin function, round, with the
3219         SymPy method of the same name. The former always returns a float
3220         (or raises an error if applied to a complex value) while the
3221         latter returns either a Number or a complex number:
3222 
3223         >>> isinstance(round(S(123), -2), Number)
3224         False
3225         >>> isinstance(S(123).round(-2), Number)
3226         True
3227         >>> isinstance((3*I).round(), Mul)
3228         True
3229         >>> isinstance((1 + 3*I).round(), Add)
3230         True
3231 
3232         """
3233         from sympy import Float
3234         x = self
3235         if not x.is_number:
3236             raise TypeError("can't round symbolic expression")
3237         if not x.is_Atom:
3238             xn = x.n(2)
3239             if not pure_complex(xn, or_real=True):
3240                 raise TypeError('Expected a number but got %s:' %
3241                     getattr(getattr(x,'func', x), '__name__', type(x)))
3242         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3243             return x
3244         if not x.is_real:
3245             i, r = x.as_real_imag()
3246             return i.round(p) + S.ImaginaryUnit*r.round(p)
3247         if not x:
3248             return x
3249         p = int(p)
3250 
3251         precs = [f._prec for f in x.atoms(Float)]
3252         dps = prec_to_dps(max(precs)) if precs else None
3253 
3254         mag_first_dig = _mag(x)
3255         allow = digits_needed = mag_first_dig + p
3256         if dps is not None and allow > dps:
3257             allow = dps
3258         mag = Pow(10, p)  # magnitude needed to bring digit p to units place
3259         xwas = x
3260         x += 1/(2*mag)  # add the half for rounding
3261         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3262         if i10.is_negative:
3263             x = xwas - 1/(2*mag)  # should have gone the other way
3264             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3265             rv = -(Integer(-i10)//10)
3266         else:
3267             rv = Integer(i10)//10
3268         q = 1
3269         if p > 0:
3270             q = mag
3271         elif p < 0:
3272             rv /= mag
3273         rv = Rational(rv, q)
3274         if rv.is_Integer:
3275             # use str or else it won't be a float
3276             return Float(str(rv), digits_needed)
3277         else:
3278             if not allow and rv > self:
3279                 allow += 1
3280             return Float(rv, allow)
3281 
3282 
3283 class AtomicExpr(Atom, Expr):
3284     """
3285     A parent class for object which are both atoms and Exprs.
3286 
3287     For example: Symbol, Number, Rational, Integer, ...
3288     But not: Add, Mul, Pow, ...
3289     """
3290     is_number = False
3291     is_Atom = True
3292 
3293     __slots__ = []
3294 
3295     def _eval_derivative(self, s):
3296         if self == s:
3297             return S.One
3298         return S.Zero
3299 
3300     def _eval_is_polynomial(self, syms):
3301         return True
3302 
3303     def _eval_is_rational_function(self, syms):
3304         return True
3305 
3306     def _eval_is_algebraic_expr(self, syms):
3307         return True
3308 
3309     def _eval_nseries(self, x, n, logx):
3310         return self
3311 
3312 
3313 def _mag(x):
3314     """Return integer ``i`` such that .1 <= x/10**i < 1
3315 
3316     Examples
3317     ========
3318 
3319     >>> from sympy.core.expr import _mag
3320     >>> from sympy import Float
3321     >>> _mag(Float(.1))
3322     0
3323     >>> _mag(Float(.01))
3324     -1
3325     >>> _mag(Float(1234))
3326     4
3327     """
3328     from math import log10, ceil, log
3329     from sympy import Float
3330     xpos = abs(x.n())
3331     if not xpos:
3332         return S.Zero
3333     try:
3334         mag_first_dig = int(ceil(log10(xpos)))
3335     except (ValueError, OverflowError):
3336         mag_first_dig = int(ceil(Float(mpf_log(xpos._mpf_, 53))/log(10)))
3337     # check that we aren't off by 1
3338     if (xpos/10**mag_first_dig) >= 1:
3339         assert 1 <= (xpos/10**mag_first_dig) < 10
3340         mag_first_dig += 1
3341     return mag_first_dig
3342 
3343 
3344 class UnevaluatedExpr(Expr):
3345     """
3346     Expression that is not evaluated unless released.
3347 
3348     Examples
3349     ========
3350 
3351     >>> from sympy import UnevaluatedExpr
3352     >>> from sympy.abc import a, b, x, y
3353     >>> x*(1/x)
3354     1
3355     >>> x*UnevaluatedExpr(1/x)
3356     x*1/x
3357 
3358     """
3359 
3360     def __new__(cls, arg, **kwargs):
3361         arg = _sympify(arg)
3362         obj = Expr.__new__(cls, arg, **kwargs)
3363         return obj
3364 
3365     def doit(self, *args, **kwargs):
3366         if kwargs.get("deep", True):
3367             return self.args[0].doit(*args, **kwargs)
3368         else:
3369             return self.args[0]
3370 
3371 
3372 def _n2(a, b):
3373     """Return (a - b).evalf(2) if it, a and b are comparable, else None.
3374     This should only be used when a and b are already sympified.
3375     """
3376     if not all(i.is_number for i in (a, b)):
3377         return
3378     # /!\ if is very important (see issue 8245) not to
3379     # use a re-evaluated number in the calculation of dif
3380     if a.is_comparable and b.is_comparable:
3381         dif = (a - b).evalf(2)
3382         if dif.is_comparable:
3383             return dif
3384 
3385 
3386 from .mul import Mul
3387 from .add import Add
3388 from .power import Pow
3389 from .function import Derivative, Function
3390 from .mod import Mod
3391 from .exprtools import factor_terms
3392 from .numbers import Integer, Rational

</code><intended_behavior>Ensure that the expression handling and manipulation logic properly recognizes and preserves the subtleties of trigonometric functions with complex arguments during simplification.</intended_behavior>]
2025-10-18 19:27:54.492 | INFO     | Search completed. Bug locations: [<file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core import (Basic, S, Add, Mul, Pow,
6     Symbol, sympify, expand_mul, expand_func,
7     Function, Dummy, Expr, factor_terms,
8     symbols, expand_power_exp)
9 from sympy.core.compatibility import (iterable,
10     ordered, range, as_int)
11 from sympy.core.numbers import Float, I, pi, Rational, Integer
12 from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg, nfloat
13 from sympy.core.rules import Transform
14 from sympy.core.evaluate import global_evaluate
15 from sympy.functions import (
16     gamma, exp, sqrt, log, exp_polar, piecewise_fold)
17 from sympy.core.sympify import _sympify
18 from sympy.functions.elementary.exponential import ExpBase
19 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
20 from sympy.functions.elementary.integers import ceiling
21 from sympy.functions.elementary.complexes import unpolarify
22 from sympy.functions.elementary.trigonometric import TrigonometricFunction
23 from sympy.functions.combinatorial.factorials import CombinatorialFunction
24 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely
25 
26 from sympy.utilities.iterables import has_variety
27 
28 from sympy.simplify.radsimp import radsimp, fraction
29 from sympy.simplify.trigsimp import trigsimp, exptrigsimp
30 from sympy.simplify.powsimp import powsimp
31 from sympy.simplify.cse_opts import sub_pre, sub_post
32 from sympy.simplify.sqrtdenest import sqrtdenest
33 from sympy.simplify.combsimp import combsimp
34 
35 from sympy.polys import (together, cancel, factor)
36 
37 
38 import mpmath
39 
40 
41 
42 def separatevars(expr, symbols=[], dict=False, force=False):
43     """
44     Separates variables in an expression, if possible.  By
45     default, it separates with respect to all symbols in an
46     expression and collects constant coefficients that are
47     independent of symbols.
48 
49     If dict=True then the separated terms will be returned
50     in a dictionary keyed to their corresponding symbols.
51     By default, all symbols in the expression will appear as
52     keys; if symbols are provided, then all those symbols will
53     be used as keys, and any terms in the expression containing
54     other symbols or non-symbols will be returned keyed to the
55     string 'coeff'. (Passing None for symbols will return the
56     expression in a dictionary keyed to 'coeff'.)
57 
58     If force=True, then bases of powers will be separated regardless
59     of assumptions on the symbols involved.
60 
61     Notes
62     =====
63     The order of the factors is determined by Mul, so that the
64     separated expressions may not necessarily be grouped together.
65 
66     Although factoring is necessary to separate variables in some
67     expressions, it is not necessary in all cases, so one should not
68     count on the returned factors being factored.
69 
70     Examples
71     ========
72 
73     >>> from sympy.abc import x, y, z, alpha
74     >>> from sympy import separatevars, sin
75     >>> separatevars((x*y)**y)
76     (x*y)**y
77     >>> separatevars((x*y)**y, force=True)
78     x**y*y**y
79 
80     >>> e = 2*x**2*z*sin(y)+2*z*x**2
81     >>> separatevars(e)
82     2*x**2*z*(sin(y) + 1)
83     >>> separatevars(e, symbols=(x, y), dict=True)
84     {'coeff': 2*z, x: x**2, y: sin(y) + 1}
85     >>> separatevars(e, [x, y, alpha], dict=True)
86     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}
87 
88     If the expression is not really separable, or is only partially
89     separable, separatevars will do the best it can to separate it
90     by using factoring.
91 
92     >>> separatevars(x + x*y - 3*x**2)
93     -x*(3*x - y - 1)
94 
95     If the expression is not separable then expr is returned unchanged
96     or (if dict=True) then None is returned.
97 
98     >>> eq = 2*x + y*sin(x)
99     >>> separatevars(eq) == eq
100     True
101     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None
102     True
103 
104     """
105     expr = sympify(expr)
106     if dict:
107         return _separatevars_dict(_separatevars(expr, force), symbols)
108     else:
109         return _separatevars(expr, force)
110 
111 
112 def _separatevars(expr, force):
113     if len(expr.free_symbols) == 1:
114         return expr
115     # don't destroy a Mul since much of the work may already be done
116     if expr.is_Mul:
117         args = list(expr.args)
118         changed = False
119         for i, a in enumerate(args):
120             args[i] = separatevars(a, force)
121             changed = changed or args[i] != a
122         if changed:
123             expr = expr.func(*args)
124         return expr
125 
126     # get a Pow ready for expansion
127     if expr.is_Pow:
128         expr = Pow(separatevars(expr.base, force=force), expr.exp)
129 
130     # First try other expansion methods
131     expr = expr.expand(mul=False, multinomial=False, force=force)
132 
133     _expr, reps = posify(expr) if force else (expr, {})
134     expr = factor(_expr).subs(reps)
135 
136     if not expr.is_Add:
137         return expr
138 
139     # Find any common coefficients to pull out
140     args = list(expr.args)
141     commonc = args[0].args_cnc(cset=True, warn=False)[0]
142     for i in args[1:]:
143         commonc &= i.args_cnc(cset=True, warn=False)[0]
144     commonc = Mul(*commonc)
145     commonc = commonc.as_coeff_Mul()[1]  # ignore constants
146     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]
147 
148     # remove them
149     for i, a in enumerate(args):
150         c, nc = a.args_cnc(cset=True, warn=False)
151         c = c - commonc_set
152         args[i] = Mul(*c)*Mul(*nc)
153     nonsepar = Add(*args)
154 
155     if len(nonsepar.free_symbols) > 1:
156         _expr = nonsepar
157         _expr, reps = posify(_expr) if force else (_expr, {})
158         _expr = (factor(_expr)).subs(reps)
159 
160         if not _expr.is_Add:
161             nonsepar = _expr
162 
163     return commonc*nonsepar
164 
165 
166 def _separatevars_dict(expr, symbols):
167     if symbols:
168         if not all((t.is_Atom for t in symbols)):
169             raise ValueError("symbols must be Atoms.")
170         symbols = list(symbols)
171     elif symbols is None:
172         return {'coeff': expr}
173     else:
174         symbols = list(expr.free_symbols)
175         if not symbols:
176             return None
177 
178     ret = dict(((i, []) for i in symbols + ['coeff']))
179 
180     for i in Mul.make_args(expr):
181         expsym = i.free_symbols
182         intersection = set(symbols).intersection(expsym)
183         if len(intersection) > 1:
184             return None
185         if len(intersection) == 0:
186             # There are no symbols, so it is part of the coefficient
187             ret['coeff'].append(i)
188         else:
189             ret[intersection.pop()].append(i)
190 
191     # rebuild
192     for k, v in ret.items():
193         ret[k] = Mul(*v)
194 
195     return ret
196 
197 
198 def _is_sum_surds(p):
199     args = p.args if p.is_Add else [p]
200     for y in args:
201         if not ((y**2).is_Rational and y.is_real):
202             return False
203     return True
204 
205 
206 def posify(eq):
207     """Return eq (with generic symbols made positive) and a
208     dictionary containing the mapping between the old and new
209     symbols.
210 
211     Any symbol that has positive=None will be replaced with a positive dummy
212     symbol having the same name. This replacement will allow more symbolic
213     processing of expressions, especially those involving powers and
214     logarithms.
215 
216     A dictionary that can be sent to subs to restore eq to its original
217     symbols is also returned.
218 
219     >>> from sympy import posify, Symbol, log, solve
220     >>> from sympy.abc import x
221     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))
222     (_x + n + p, {_x: x})
223 
224     >>> eq = 1/x
225     >>> log(eq).expand()
226     log(1/x)
227     >>> log(posify(eq)[0]).expand()
228     -log(_x)
229     >>> p, rep = posify(eq)
230     >>> log(p).expand().subs(rep)
231     -log(x)
232 
233     It is possible to apply the same transformations to an iterable
234     of expressions:
235 
236     >>> eq = x**2 - 4
237     >>> solve(eq, x)
238     [-2, 2]
239     >>> eq_x, reps = posify([eq, x]); eq_x
240     [_x**2 - 4, _x]
241     >>> solve(*eq_x)
242     [2]
243     """
244     eq = sympify(eq)
245     if iterable(eq):
246         f = type(eq)
247         eq = list(eq)
248         syms = set()
249         for e in eq:
250             syms = syms.union(e.atoms(Symbol))
251         reps = {}
252         for s in syms:
253             reps.update(dict((v, k) for k, v in posify(s)[1].items()))
254         for i, e in enumerate(eq):
255             eq[i] = e.subs(reps)
256         return f(eq), {r: s for s, r in reps.items()}
257 
258     reps = dict([(s, Dummy(s.name, positive=True))
259                  for s in eq.free_symbols if s.is_positive is None])
260     eq = eq.subs(reps)
261     return eq, {r: s for s, r in reps.items()}
262 
263 
264 def hypersimp(f, k):
265     """Given combinatorial term f(k) simplify its consecutive term ratio
266        i.e. f(k+1)/f(k).  The input term can be composed of functions and
267        integer sequences which have equivalent representation in terms
268        of gamma special function.
269 
270        The algorithm performs three basic steps:
271 
272        1. Rewrite all functions in terms of gamma, if possible.
273 
274        2. Rewrite all occurrences of gamma in terms of products
275           of gamma and rising factorial with integer,  absolute
276           constant exponent.
277 
278        3. Perform simplification of nested fractions, powers
279           and if the resulting expression is a quotient of
280           polynomials, reduce their total degree.
281 
282        If f(k) is hypergeometric then as result we arrive with a
283        quotient of polynomials of minimal degree. Otherwise None
284        is returned.
285 
286        For more information on the implemented algorithm refer to:
287 
288        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,
289           Journal of Symbolic Computation (1995) 20, 399-417
290     """
291     f = sympify(f)
292 
293     g = f.subs(k, k + 1) / f
294 
295     g = g.rewrite(gamma)
296     g = expand_func(g)
297     g = powsimp(g, deep=True, combine='exp')
298 
299     if g.is_rational_function(k):
300         return simplify(g, ratio=S.Infinity)
301     else:
302         return None
303 
304 
305 def hypersimilar(f, g, k):
306     """Returns True if 'f' and 'g' are hyper-similar.
307 
308        Similarity in hypergeometric sense means that a quotient of
309        f(k) and g(k) is a rational function in k.  This procedure
310        is useful in solving recurrence relations.
311 
312        For more information see hypersimp().
313 
314     """
315     f, g = list(map(sympify, (f, g)))
316 
317     h = (f/g).rewrite(gamma)
318     h = h.expand(func=True, basic=False)
319 
320     return h.is_rational_function(k)
321 
322 
323 def signsimp(expr, evaluate=None):
324     """Make all Add sub-expressions canonical wrt sign.
325 
326     If an Add subexpression, ``a``, can have a sign extracted,
327     as determined by could_extract_minus_sign, it is replaced
328     with Mul(-1, a, evaluate=False). This allows signs to be
329     extracted from powers and products.
330 
331     Examples
332     ========
333 
334     >>> from sympy import signsimp, exp, symbols
335     >>> from sympy.abc import x, y
336     >>> i = symbols('i', odd=True)
337     >>> n = -1 + 1/x
338     >>> n/x/(-n)**2 - 1/n/x
339     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
340     >>> signsimp(_)
341     0
342     >>> x*n + x*-n
343     x*(-1 + 1/x) + x*(1 - 1/x)
344     >>> signsimp(_)
345     0
346 
347     Since powers automatically handle leading signs
348 
349     >>> (-2)**i
350     -2**i
351 
352     signsimp can be used to put the base of a power with an integer
353     exponent into canonical form:
354 
355     >>> n**i
356     (-1 + 1/x)**i
357 
358     By default, signsimp doesn't leave behind any hollow simplification:
359     if making an Add canonical wrt sign didn't change the expression, the
360     original Add is restored. If this is not desired then the keyword
361     ``evaluate`` can be set to False:
362 
363     >>> e = exp(y - x)
364     >>> signsimp(e) == e
365     True
366     >>> signsimp(e, evaluate=False)
367     exp(-(x - y))
368 
369     """
370     if evaluate is None:
371         evaluate = global_evaluate[0]
372     expr = sympify(expr)
373     if not isinstance(expr, Expr) or expr.is_Atom:
374         return expr
375     e = sub_post(sub_pre(expr))
376     if not isinstance(e, Expr) or e.is_Atom:
377         return e
378     if e.is_Add:
379         return e.func(*[signsimp(a, evaluate) for a in e.args])
380     if evaluate:
381         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})
382     return e
383 
384 
385 def simplify(expr, ratio=1.7, measure=count_ops, rational=False):
386     # type: (object, object, object, object) -> object
387     """
388     Simplifies the given expression.
389 
390     Simplification is not a well defined term and the exact strategies
391     this function tries can change in the future versions of SymPy. If
392     your algorithm relies on "simplification" (whatever it is), try to
393     determine what you need exactly  -  is it powsimp()?, radsimp()?,
394     together()?, logcombine()?, or something else? And use this particular
395     function directly, because those are well defined and thus your algorithm
396     will be robust.
397 
398     Nonetheless, especially for interactive use, or when you don't know
399     anything about the structure of the expression, simplify() tries to apply
400     intelligent heuristics to make the input expression "simpler".  For
401     example:
402 
403     >>> from sympy import simplify, cos, sin
404     >>> from sympy.abc import x, y
405     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
406     >>> a
407     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
408     >>> simplify(a)
409     x + 1
410 
411     Note that we could have obtained the same result by using specific
412     simplification functions:
413 
414     >>> from sympy import trigsimp, cancel
415     >>> trigsimp(a)
416     (x**2 + x)/x
417     >>> cancel(_)
418     x + 1
419 
420     In some cases, applying :func:`simplify` may actually result in some more
421     complicated expression. The default ``ratio=1.7`` prevents more extreme
422     cases: if (result length)/(input length) > ratio, then input is returned
423     unmodified.  The ``measure`` parameter lets you specify the function used
424     to determine how complex an expression is.  The function should take a
425     single argument as an expression and return a number such that if
426     expression ``a`` is more complex than expression ``b``, then
427     ``measure(a) > measure(b)``.  The default measure function is
428     :func:`count_ops`, which returns the total number of operations in the
429     expression.
430 
431     For example, if ``ratio=1``, ``simplify`` output can't be longer
432     than input.
433 
434     ::
435 
436         >>> from sympy import sqrt, simplify, count_ops, oo
437         >>> root = 1/(sqrt(2)+3)
438 
439     Since ``simplify(root)`` would result in a slightly longer expression,
440     root is returned unchanged instead::
441 
442        >>> simplify(root, ratio=1) == root
443        True
444 
445     If ``ratio=oo``, simplify will be applied anyway::
446 
447         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
448         True
449 
450     Note that the shortest expression is not necessary the simplest, so
451     setting ``ratio`` to 1 may not be a good idea.
452     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
453     choice.
454 
455     You can easily define your own measure function based on what you feel
456     should represent the "size" or "complexity" of the input expression.  Note
457     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
458     good metrics, but have other problems (in this case, the measure function
459     may slow down simplify too much for very large expressions).  If you don't
460     know what a good metric would be, the default, ``count_ops``, is a good
461     one.
462 
463     For example:
464 
465     >>> from sympy import symbols, log
466     >>> a, b = symbols('a b', positive=True)
467     >>> g = log(a) + log(b) + log(a)*log(1/b)
468     >>> h = simplify(g)
469     >>> h
470     log(a*b**(-log(a) + 1))
471     >>> count_ops(g)
472     8
473     >>> count_ops(h)
474     5
475 
476     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
477     However, we may not like how ``simplify`` (in this case, using
478     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
479     to reduce this would be to give more weight to powers as operations in
480     ``count_ops``.  We can do this by using the ``visual=True`` option:
481 
482     >>> print(count_ops(g, visual=True))
483     2*ADD + DIV + 4*LOG + MUL
484     >>> print(count_ops(h, visual=True))
485     2*LOG + MUL + POW + SUB
486 
487     >>> from sympy import Symbol, S
488     >>> def my_measure(expr):
489     ...     POW = Symbol('POW')
490     ...     # Discourage powers by giving POW a weight of 10
491     ...     count = count_ops(expr, visual=True).subs(POW, 10)
492     ...     # Every other operation gets a weight of 1 (the default)
493     ...     count = count.replace(Symbol, type(S.One))
494     ...     return count
495     >>> my_measure(g)
496     8
497     >>> my_measure(h)
498     14
499     >>> 15./8 > 1.7 # 1.7 is the default ratio
500     True
501     >>> simplify(g, measure=my_measure)
502     -log(a)*log(b) + log(a) + log(b)
503 
504     Note that because ``simplify()`` internally tries many different
505     simplification strategies and then compares them using the measure
506     function, we get a completely different result that is still different
507     from the input expression by doing this.
508 
509     If rational=True, Floats will be recast as Rationals before simplification.
510     If rational=None, Floats will be recast as Rationals but the result will
511     be recast as Floats. If rational=False(default) then nothing will be done
512     to the Floats.
513     """
514     expr = sympify(expr)
515 
516     try:
517         return expr._eval_simplify(ratio=ratio, measure=measure)
518     except AttributeError:
519         pass
520 
521     original_expr = expr = signsimp(expr)
522 
523     from sympy.simplify.hyperexpand import hyperexpand
524     from sympy.functions.special.bessel import BesselBase
525     from sympy import Sum, Product
526 
527     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
528         return expr
529 
530     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):
531         if isinstance(expr, Function) and hasattr(expr, "inverse"):
532             if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \
533                isinstance(expr.args[0], expr.inverse(argindex=1)):
534                 return simplify(expr.args[0].args[0], ratio=ratio,
535                                 measure=measure, rational=rational)
536         return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)
537                          for x in expr.args])
538 
539     # TODO: Apply different strategies, considering expression pattern:
540     # is it a purely rational function? Is there any trigonometric function?...
541     # See also https://github.com/sympy/sympy/pull/185.
542 
543     def shorter(*choices):
544         '''Return the choice that has the fewest ops. In case of a tie,
545         the expression listed first is selected.'''
546         if not has_variety(choices):
547             return choices[0]
548         return min(choices, key=measure)
549 
550     # rationalize Floats
551     floats = False
552     if rational is not False and expr.has(Float):
553         floats = True
554         expr = nsimplify(expr, rational=True)
555 
556     expr = bottom_up(expr, lambda w: w.normal())
557     expr = Mul(*powsimp(expr).as_content_primitive())
558     _e = cancel(expr)
559     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
560     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
561 
562     if ratio is S.Infinity:
563         expr = expr2
564     else:
565         expr = shorter(expr2, expr1, expr)
566     if not isinstance(expr, Basic):  # XXX: temporary hack
567         return expr
568 
569     expr = factor_terms(expr, sign=False)
570 
571     # hyperexpand automatically only works on hypergeometric terms
572     expr = hyperexpand(expr)
573 
574     expr = piecewise_fold(expr)
575 
576     if expr.has(BesselBase):
577         expr = besselsimp(expr)
578 
579     if expr.has(TrigonometricFunction, HyperbolicFunction):
580         expr = trigsimp(expr, deep=True)
581 
582     if expr.has(log):
583         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
584 
585     if expr.has(CombinatorialFunction, gamma):
586         # expression with gamma functions or non-integer arguments is
587         # automatically passed to gammasimp
588         expr = combsimp(expr)
589 
590     if expr.has(Sum):
591         expr = sum_simplify(expr)
592 
593     if expr.has(Product):
594         expr = product_simplify(expr)
595 
596     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
597     short = shorter(short, cancel(short))
598     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
599     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
600         short = exptrigsimp(short)
601 
602     # get rid of hollow 2-arg Mul factorization
603     hollow_mul = Transform(
604         lambda x: Mul(*x.args),
605         lambda x:
606         x.is_Mul and
607         len(x.args) == 2 and
608         x.args[0].is_Number and
609         x.args[1].is_Add and
610         x.is_commutative)
611     expr = short.xreplace(hollow_mul)
612 
613     numer, denom = expr.as_numer_denom()
614     if denom.is_Add:
615         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
616         if n is not S.One:
617             expr = (numer*n).expand()/d
618 
619     if expr.could_extract_minus_sign():
620         n, d = fraction(expr)
621         if d != 0:
622             expr = signsimp(-n/(-d))
623 
624     if measure(expr) > ratio*measure(original_expr):
625         expr = original_expr
626 
627     # restore floats
628     if floats and rational is None:
629         expr = nfloat(expr, exponent=False)
630 
631     return expr
632 
633 
634 def sum_simplify(s):
635     """Main function for Sum simplification"""
636     from sympy.concrete.summations import Sum
637     from sympy.core.function import expand
638 
639     terms = Add.make_args(expand(s))
640     s_t = [] # Sum Terms
641     o_t = [] # Other Terms
642 
643     for term in terms:
644         if isinstance(term, Mul):
645             other = 1
646             sum_terms = []
647 
648             if not term.has(Sum):
649                 o_t.append(term)
650                 continue
651 
652             mul_terms = Mul.make_args(term)
653             for mul_term in mul_terms:
654                 if isinstance(mul_term, Sum):
655                     r = mul_term._eval_simplify()
656                     sum_terms.extend(Add.make_args(r))
657                 else:
658                     other = other * mul_term
659             if len(sum_terms):
660                 #some simplification may have happened
661                 #use if so
662                 s_t.append(Mul(*sum_terms) * other)
663             else:
664                 o_t.append(other)
665         elif isinstance(term, Sum):
666             #as above, we need to turn this into an add list
667             r = term._eval_simplify()
668             s_t.extend(Add.make_args(r))
669         else:
670             o_t.append(term)
671 
672 
673     result = Add(sum_combine(s_t), *o_t)
674 
675     return result
676 
677 def sum_combine(s_t):
678     """Helper function for Sum simplification
679 
680        Attempts to simplify a list of sums, by combining limits / sum function's
681        returns the simplified sum
682     """
683     from sympy.concrete.summations import Sum
684 
685 
686     used = [False] * len(s_t)
687 
688     for method in range(2):
689         for i, s_term1 in enumerate(s_t):
690             if not used[i]:
691                 for j, s_term2 in enumerate(s_t):
692                     if not used[j] and i != j:
693                         temp = sum_add(s_term1, s_term2, method)
694                         if isinstance(temp, Sum) or isinstance(temp, Mul):
695                             s_t[i] = temp
696                             s_term1 = s_t[i]
697                             used[j] = True
698 
699     result = S.Zero
700     for i, s_term in enumerate(s_t):
701         if not used[i]:
702             result = Add(result, s_term)
703 
704     return result
705 
706 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):
707     """Helper function for Sum simplification
708 
709        if limits is specified, "self" is the inner part of a sum
710 
711        Returns the sum with constant factors brought outside
712     """
713     from sympy.core.exprtools import factor_terms
714     from sympy.concrete.summations import Sum
715 
716     result = self.function if limits is None else self
717     limits = self.limits if limits is None else limits
718     #avoid any confusion w/ as_independent
719     if result == 0:
720         return S.Zero
721 
722     #get the summation variables
723     sum_vars = set([limit.args[0] for limit in limits])
724 
725     #finally we try to factor out any common terms
726     #and remove the from the sum if independent
727     retv = factor_terms(result, radical=radical, clear=clear, fraction=fraction, sign=sign)
728     #avoid doing anything bad
729     if not result.is_commutative:
730         return Sum(result, *limits)
731 
732     i, d = retv.as_independent(*sum_vars)
733     if isinstance(retv, Add):
734         return i * Sum(1, *limits) + Sum(d, *limits)
735     else:
736         return i * Sum(d, *limits)
737 
738 def sum_add(self, other, method=0):
739     """Helper function for Sum simplification"""
740     from sympy.concrete.summations import Sum
741     from sympy import Mul
742 
743     #we know this is something in terms of a constant * a sum
744     #so we temporarily put the constants inside for simplification
745     #then simplify the result
746     def __refactor(val):
747         args = Mul.make_args(val)
748         sumv = next(x for x in args if isinstance(x, Sum))
749         constant = Mul(*[x for x in args if x != sumv])
750         return Sum(constant * sumv.function, *sumv.limits)
751 
752     if isinstance(self, Mul):
753         rself = __refactor(self)
754     else:
755         rself = self
756 
757     if isinstance(other, Mul):
758         rother = __refactor(other)
759     else:
760         rother = other
761 
762     if type(rself) == type(rother):
763         if method == 0:
764             if rself.limits == rother.limits:
765                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))
766         elif method == 1:
767             if simplify(rself.function - rother.function) == 0:
768                 if len(rself.limits) == len(rother.limits) == 1:
769                     i = rself.limits[0][0]
770                     x1 = rself.limits[0][1]
771                     y1 = rself.limits[0][2]
772                     j = rother.limits[0][0]
773                     x2 = rother.limits[0][1]
774                     y2 = rother.limits[0][2]
775 
776                     if i == j:
777                         if x2 == y1 + 1:
778                             return factor_sum(Sum(rself.function, (i, x1, y2)))
779                         elif x1 == y2 + 1:
780                             return factor_sum(Sum(rself.function, (i, x2, y1)))
781 
782     return Add(self, other)
783 
784 
785 def product_simplify(s):
786     """Main function for Product simplification"""
787     from sympy.concrete.products import Product
788 
789     terms = Mul.make_args(s)
790     p_t = [] # Product Terms
791     o_t = [] # Other Terms
792 
793     for term in terms:
794         if isinstance(term, Product):
795             p_t.append(term)
796         else:
797             o_t.append(term)
798 
799     used = [False] * len(p_t)
800 
801     for method in range(2):
802         for i, p_term1 in enumerate(p_t):
803             if not used[i]:
804                 for j, p_term2 in enumerate(p_t):
805                     if not used[j] and i != j:
806                         if isinstance(product_mul(p_term1, p_term2, method), Product):
807                             p_t[i] = product_mul(p_term1, p_term2, method)
808                             used[j] = True
809 
810     result = Mul(*o_t)
811 
812     for i, p_term in enumerate(p_t):
813         if not used[i]:
814             result = Mul(result, p_term)
815 
816     return result
817 
818 
819 def product_mul(self, other, method=0):
820     """Helper function for Product simplification"""
821     from sympy.concrete.products import Product
822 
823     if type(self) == type(other):
824         if method == 0:
825             if self.limits == other.limits:
826                 return Product(self.function * other.function, *self.limits)
827         elif method == 1:
828             if simplify(self.function - other.function) == 0:
829                 if len(self.limits) == len(other.limits) == 1:
830                     i = self.limits[0][0]
831                     x1 = self.limits[0][1]
832                     y1 = self.limits[0][2]
833                     j = other.limits[0][0]
834                     x2 = other.limits[0][1]
835                     y2 = other.limits[0][2]
836 
837                     if i == j:
838                         if x2 == y1 + 1:
839                             return Product(self.function, (i, x1, y2))
840                         elif x1 == y2 + 1:
841                             return Product(self.function, (i, x2, y1))
842 
843     return Mul(self, other)
844 
845 
846 def _nthroot_solve(p, n, prec):
847     """
848      helper function for ``nthroot``
849      It denests ``p**Rational(1, n)`` using its minimal polynomial
850     """
851     from sympy.polys.numberfields import _minimal_polynomial_sq
852     from sympy.solvers import solve
853     while n % 2 == 0:
854         p = sqrtdenest(sqrt(p))
855         n = n // 2
856     if n == 1:
857         return p
858     pn = p**Rational(1, n)
859     x = Symbol('x')
860     f = _minimal_polynomial_sq(p, n, x)
861     if f is None:
862         return None
863     sols = solve(f, x)
864     for sol in sols:
865         if abs(sol - pn).n() < 1./10**prec:
866             sol = sqrtdenest(sol)
867             if _mexpand(sol**n) == p:
868                 return sol
869 
870 
871 def logcombine(expr, force=False):
872     """
873     Takes logarithms and combines them using the following rules:
874 
875     - log(x) + log(y) == log(x*y) if both are not negative
876     - a*log(x) == log(x**a) if x is positive and a is real
877 
878     If ``force`` is True then the assumptions above will be assumed to hold if
879     there is no assumption already in place on a quantity. For example, if
880     ``a`` is imaginary or the argument negative, force will not perform a
881     combination but if ``a`` is a symbol with no assumptions the change will
882     take place.
883 
884     Examples
885     ========
886 
887     >>> from sympy import Symbol, symbols, log, logcombine, I
888     >>> from sympy.abc import a, x, y, z
889     >>> logcombine(a*log(x) + log(y) - log(z))
890     a*log(x) + log(y) - log(z)
891     >>> logcombine(a*log(x) + log(y) - log(z), force=True)
892     log(x**a*y/z)
893     >>> x,y,z = symbols('x,y,z', positive=True)
894     >>> a = Symbol('a', real=True)
895     >>> logcombine(a*log(x) + log(y) - log(z))
896     log(x**a*y/z)
897 
898     The transformation is limited to factors and/or terms that
899     contain logs, so the result depends on the initial state of
900     expansion:
901 
902     >>> eq = (2 + 3*I)*log(x)
903     >>> logcombine(eq, force=True) == eq
904     True
905     >>> logcombine(eq.expand(), force=True)
906     log(x**2) + I*log(x**3)
907 
908     See Also
909     ========
910     posify: replace all symbols with symbols having positive assumptions
911 
912     """
913 
914     def f(rv):
915         if not (rv.is_Add or rv.is_Mul):
916             return rv
917 
918         def gooda(a):
919             # bool to tell whether the leading ``a`` in ``a*log(x)``
920             # could appear as log(x**a)
921             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow
922                 (a.is_real or force and a.is_real is not False))
923 
924         def goodlog(l):
925             # bool to tell whether log ``l``'s argument can combine with others
926             a = l.args[0]
927             return a.is_positive or force and a.is_nonpositive is not False
928 
929         other = []
930         logs = []
931         log1 = defaultdict(list)
932         for a in Add.make_args(rv):
933             if a.func is log and goodlog(a):
934                 log1[()].append(([], a))
935             elif not a.is_Mul:
936                 other.append(a)
937             else:
938                 ot = []
939                 co = []
940                 lo = []
941                 for ai in a.args:
942                     if ai.is_Rational and ai < 0:
943                         ot.append(S.NegativeOne)
944                         co.append(-ai)
945                     elif ai.func is log and goodlog(ai):
946                         lo.append(ai)
947                     elif gooda(ai):
948                         co.append(ai)
949                     else:
950                         ot.append(ai)
951                 if len(lo) > 1:
952                     logs.append((ot, co, lo))
953                 elif lo:
954                     log1[tuple(ot)].append((co, lo[0]))
955                 else:
956                     other.append(a)
957 
958         # if there is only one log at each coefficient and none have
959         # an exponent to place inside the log then there is nothing to do
960         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):
961             return rv
962 
963         # collapse multi-logs as far as possible in a canonical way
964         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?
965         # -- in this case, it's unambiguous, but if it were were a log(c) in
966         # each term then it's arbitrary whether they are grouped by log(a) or
967         # by log(c). So for now, just leave this alone; it's probably better to
968         # let the user decide
969         for o, e, l in logs:
970             l = list(ordered(l))
971             e = log(l.pop(0).args[0]**Mul(*e))
972             while l:
973                 li = l.pop(0)
974                 e = log(li.args[0]**e)
975             c, l = Mul(*o), e
976             if l.func is log:  # it should be, but check to be sure
977                 log1[(c,)].append(([], l))
978             else:
979                 other.append(c*l)
980 
981         # logs that have the same coefficient can multiply
982         for k in list(log1.keys()):
983             log1[Mul(*k)] = log(logcombine(Mul(*[
984                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),
985                 force=force))
986 
987         # logs that have oppositely signed coefficients can divide
988         for k in ordered(list(log1.keys())):
989             if not k in log1:  # already popped as -k
990                 continue
991             if -k in log1:
992                 # figure out which has the minus sign; the one with
993                 # more op counts should be the one
994                 num, den = k, -k
995                 if num.count_ops() > den.count_ops():
996                     num, den = den, num
997                 other.append(num*log(log1.pop(num).args[0]/log1.pop(den).args[0]))
998             else:
999                 other.append(k*log1.pop(k))
1000 
1001         return Add(*other)
1002 
1003     return bottom_up(expr, f)
1004 
1005 
1006 def bottom_up(rv, F, atoms=False, nonbasic=False):
1007     """Apply ``F`` to all expressions in an expression tree from the
1008     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;
1009     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.
1010     """
1011     try:
1012         if rv.args:
1013             args = tuple([bottom_up(a, F, atoms, nonbasic)
1014                 for a in rv.args])
1015             if args != rv.args:
1016                 rv = rv.func(*args)
1017             rv = F(rv)
1018         elif atoms:
1019             rv = F(rv)
1020     except AttributeError:
1021         if nonbasic:
1022             try:
1023                 rv = F(rv)
1024             except TypeError:
1025                 pass
1026 
1027     return rv
1028 
1029 
1030 def besselsimp(expr):
1031     """
1032     Simplify bessel-type functions.
1033 
1034     This routine tries to simplify bessel-type functions. Currently it only
1035     works on the Bessel J and I functions, however. It works by looking at all
1036     such functions in turn, and eliminating factors of "I" and "-1" (actually
1037     their polar equivalents) in front of the argument. Then, functions of
1038     half-integer order are rewritten using strigonometric functions and
1039     functions of integer order (> 1) are rewritten using functions
1040     of low order.  Finally, if the expression was changed, compute
1041     factorization of the result with factor().
1042 
1043     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S
1044     >>> from sympy.abc import z, nu
1045     >>> besselsimp(besselj(nu, z*polar_lift(-1)))
1046     exp(I*pi*nu)*besselj(nu, z)
1047     >>> besselsimp(besseli(nu, z*polar_lift(-I)))
1048     exp(-I*pi*nu/2)*besselj(nu, z)
1049     >>> besselsimp(besseli(S(-1)/2, z))
1050     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))
1051     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))
1052     3*z*besseli(0, z)/2
1053     """
1054     # TODO
1055     # - better algorithm?
1056     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...
1057     # - use contiguity relations?
1058 
1059     def replacer(fro, to, factors):
1060         factors = set(factors)
1061 
1062         def repl(nu, z):
1063             if factors.intersection(Mul.make_args(z)):
1064                 return to(nu, z)
1065             return fro(nu, z)
1066         return repl
1067 
1068     def torewrite(fro, to):
1069         def tofunc(nu, z):
1070             return fro(nu, z).rewrite(to)
1071         return tofunc
1072 
1073     def tominus(fro):
1074         def tofunc(nu, z):
1075             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)
1076         return tofunc
1077 
1078     orig_expr = expr
1079 
1080     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]
1081     expr = expr.replace(
1082         besselj, replacer(besselj,
1083         torewrite(besselj, besseli), ifactors))
1084     expr = expr.replace(
1085         besseli, replacer(besseli,
1086         torewrite(besseli, besselj), ifactors))
1087 
1088     minusfactors = [-1, exp_polar(I*pi)]
1089     expr = expr.replace(
1090         besselj, replacer(besselj, tominus(besselj), minusfactors))
1091     expr = expr.replace(
1092         besseli, replacer(besseli, tominus(besseli), minusfactors))
1093 
1094     z0 = Dummy('z')
1095 
1096     def expander(fro):
1097         def repl(nu, z):
1098             if (nu % 1) == S(1)/2:
1099                 return simplify(trigsimp(unpolarify(
1100                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(
1101                             func=True)).subs(z0, z)))
1102             elif nu.is_Integer and nu > 1:
1103                 return fro(nu, z).expand(func=True)
1104             return fro(nu, z)
1105         return repl
1106 
1107     expr = expr.replace(besselj, expander(besselj))
1108     expr = expr.replace(bessely, expander(bessely))
1109     expr = expr.replace(besseli, expander(besseli))
1110     expr = expr.replace(besselk, expander(besselk))
1111 
1112     if expr != orig_expr:
1113         expr = expr.factor()
1114 
1115     return expr
1116 
1117 
1118 def nthroot(expr, n, max_len=4, prec=15):
1119     """
1120     compute a real nth-root of a sum of surds
1121 
1122     Parameters
1123     ==========
1124 
1125     expr : sum of surds
1126     n : integer
1127     max_len : maximum number of surds passed as constants to ``nsimplify``
1128 
1129     Algorithm
1130     =========
1131 
1132     First ``nsimplify`` is used to get a candidate root; if it is not a
1133     root the minimal polynomial is computed; the answer is one of its
1134     roots.
1135 
1136     Examples
1137     ========
1138 
1139     >>> from sympy.simplify.simplify import nthroot
1140     >>> from sympy import Rational, sqrt
1141     >>> nthroot(90 + 34*sqrt(7), 3)
1142     sqrt(7) + 3
1143 
1144     """
1145     expr = sympify(expr)
1146     n = sympify(n)
1147     p = expr**Rational(1, n)
1148     if not n.is_integer:
1149         return p
1150     if not _is_sum_surds(expr):
1151         return p
1152     surds = []
1153     coeff_muls = [x.as_coeff_Mul() for x in expr.args]
1154     for x, y in coeff_muls:
1155         if not x.is_rational:
1156             return p
1157         if y is S.One:
1158             continue
1159         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):
1160             return p
1161         surds.append(y)
1162     surds.sort()
1163     surds = surds[:max_len]
1164     if expr < 0 and n % 2 == 1:
1165         p = (-expr)**Rational(1, n)
1166         a = nsimplify(p, constants=surds)
1167         res = a if _mexpand(a**n) == _mexpand(-expr) else p
1168         return -res
1169     a = nsimplify(p, constants=surds)
1170     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):
1171         return _mexpand(a)
1172     expr = _nthroot_solve(expr, n, prec)
1173     if expr is None:
1174         return p
1175     return expr
1176 
1177 
1178 def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,
1179     rational_conversion='base10'):
1180     """
1181     Find a simple representation for a number or, if there are free symbols or
1182     if rational=True, then replace Floats with their Rational equivalents. If
1183     no change is made and rational is not False then Floats will at least be
1184     converted to Rationals.
1185 
1186     For numerical expressions, a simple formula that numerically matches the
1187     given numerical expression is sought (and the input should be possible
1188     to evalf to a precision of at least 30 digits).
1189 
1190     Optionally, a list of (rationally independent) constants to
1191     include in the formula may be given.
1192 
1193     A lower tolerance may be set to find less exact matches. If no tolerance
1194     is given then the least precise value will set the tolerance (e.g. Floats
1195     default to 15 digits of precision, so would be tolerance=10**-15).
1196 
1197     With full=True, a more extensive search is performed
1198     (this is useful to find simpler numbers when the tolerance
1199     is set low).
1200 
1201     When converting to rational, if rational_conversion='base10' (the default), then
1202     convert floats to rationals using their base-10 (string) representation.
1203     When rational_conversion='exact' it uses the exact, base-2 representation.
1204 
1205     Examples
1206     ========
1207 
1208     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi
1209     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])
1210     -2 + 2*GoldenRatio
1211     >>> nsimplify((1/(exp(3*pi*I/5)+1)))
1212     1/2 - I*sqrt(sqrt(5)/10 + 1/4)
1213     >>> nsimplify(I**I, [pi])
1214     exp(-pi/2)
1215     >>> nsimplify(pi, tolerance=0.01)
1216     22/7
1217 
1218     >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')
1219     6004799503160655/18014398509481984
1220     >>> nsimplify(0.333333333333333, rational=True)
1221     1/3
1222 
1223     See Also
1224     ========
1225     sympy.core.function.nfloat
1226 
1227     """
1228     try:
1229         return sympify(as_int(expr))
1230     except (TypeError, ValueError):
1231         pass
1232     expr = sympify(expr).xreplace({
1233         Float('inf'): S.Infinity,
1234         Float('-inf'): S.NegativeInfinity,
1235         })
1236     if expr is S.Infinity or expr is S.NegativeInfinity:
1237         return expr
1238     if rational or expr.free_symbols:
1239         return _real_to_rational(expr, tolerance, rational_conversion)
1240 
1241     # SymPy's default tolerance for Rationals is 15; other numbers may have
1242     # lower tolerances set, so use them to pick the largest tolerance if None
1243     # was given
1244     if tolerance is None:
1245         tolerance = 10**-min([15] +
1246              [mpmath.libmp.libmpf.prec_to_dps(n._prec)
1247              for n in expr.atoms(Float)])
1248     # XXX should prec be set independent of tolerance or should it be computed
1249     # from tolerance?
1250     prec = 30
1251     bprec = int(prec*3.33)
1252 
1253     constants_dict = {}
1254     for constant in constants:
1255         constant = sympify(constant)
1256         v = constant.evalf(prec)
1257         if not v.is_Float:
1258             raise ValueError("constants must be real-valued")
1259         constants_dict[str(constant)] = v._to_mpmath(bprec)
1260 
1261     exprval = expr.evalf(prec, chop=True)
1262     re, im = exprval.as_real_imag()
1263 
1264     # safety check to make sure that this evaluated to a number
1265     if not (re.is_Number and im.is_Number):
1266         return expr
1267 
1268     def nsimplify_real(x):
1269         orig = mpmath.mp.dps
1270         xv = x._to_mpmath(bprec)
1271         try:
1272             # We'll be happy with low precision if a simple fraction
1273             if not (tolerance or full):
1274                 mpmath.mp.dps = 15
1275                 rat = mpmath.pslq([xv, 1])
1276                 if rat is not None:
1277                     return Rational(-int(rat[1]), int(rat[0]))
1278             mpmath.mp.dps = prec
1279             newexpr = mpmath.identify(xv, constants=constants_dict,
1280                 tol=tolerance, full=full)
1281             if not newexpr:
1282                 raise ValueError
1283             if full:
1284                 newexpr = newexpr[0]
1285             expr = sympify(newexpr)
1286             if x and not expr:  # don't let x become 0
1287                 raise ValueError
1288             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:
1289                 raise ValueError
1290             return expr
1291         finally:
1292             # even though there are returns above, this is executed
1293             # before leaving
1294             mpmath.mp.dps = orig
1295     try:
1296         if re:
1297             re = nsimplify_real(re)
1298         if im:
1299             im = nsimplify_real(im)
1300     except ValueError:
1301         if rational is None:
1302             return _real_to_rational(expr, rational_conversion=rational_conversion)
1303         return expr
1304 
1305     rv = re + im*S.ImaginaryUnit
1306     # if there was a change or rational is explicitly not wanted
1307     # return the value, else return the Rational representation
1308     if rv != expr or rational is False:
1309         return rv
1310     return _real_to_rational(expr, rational_conversion=rational_conversion)
1311 
1312 
1313 def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):
1314     """
1315     Replace all reals in expr with rationals.
1316 
1317     >>> from sympy import Rational
1318     >>> from sympy.simplify.simplify import _real_to_rational
1319     >>> from sympy.abc import x
1320 
1321     >>> _real_to_rational(.76 + .1*x**.5)
1322     sqrt(x)/10 + 19/25
1323 
1324     If rational_conversion='base10', this uses the base-10 string. If
1325     rational_conversion='exact', the exact, base-2 representation is used.
1326 
1327     >>> _real_to_rational(0.333333333333333, rational_conversion='exact')
1328     6004799503160655/18014398509481984
1329     >>> _real_to_rational(0.333333333333333)
1330     1/3
1331 
1332     """
1333     expr = _sympify(expr)
1334     inf = Float('inf')
1335     p = expr
1336     reps = {}
1337     reduce_num = None
1338     if tolerance is not None and tolerance < 1:
1339         reduce_num = ceiling(1/tolerance)
1340     for fl in p.atoms(Float):
1341         key = fl
1342         if reduce_num is not None:
1343             r = Rational(fl).limit_denominator(reduce_num)
1344         elif (tolerance is not None and tolerance >= 1 and
1345                 fl.is_Integer is False):
1346             r = Rational(tolerance*round(fl/tolerance)
1347                 ).limit_denominator(int(tolerance))
1348         else:
1349             if rational_conversion == 'exact':
1350                 r = Rational(fl)
1351                 reps[key] = r
1352                 continue
1353             elif rational_conversion != 'base10':
1354                 raise ValueError("rational_conversion must be 'base10' or 'exact'")
1355 
1356             r = nsimplify(fl, rational=False)
1357             # e.g. log(3).n() -> log(3) instead of a Rational
1358             if fl and not r:
1359                 r = Rational(fl)
1360             elif not r.is_Rational:
1361                 if fl == inf or fl == -inf:
1362                     r = S.ComplexInfinity
1363                 elif fl < 0:
1364                     fl = -fl
1365                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1366                     r = -Rational(str(fl/d))*d
1367                 elif fl > 0:
1368                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1369                     r = Rational(str(fl/d))*d
1370                 else:
1371                     r = Integer(0)
1372         reps[key] = r
1373     return p.subs(reps, simultaneous=True)
1374 
1375 
1376 def clear_coefficients(expr, rhs=S.Zero):
1377     """Return `p, r` where `p` is the expression obtained when Rational
1378     additive and multiplicative coefficients of `expr` have been stripped
1379     away in a naive fashion (i.e. without simplification). The operations
1380     needed to remove the coefficients will be applied to `rhs` and returned
1381     as `r`.
1382 
1383     Examples
1384     ========
1385 
1386     >>> from sympy.simplify.simplify import clear_coefficients
1387     >>> from sympy.abc import x, y
1388     >>> from sympy import Dummy
1389     >>> expr = 4*y*(6*x + 3)
1390     >>> clear_coefficients(expr - 2)
1391     (y*(2*x + 1), 1/6)
1392 
1393     When solving 2 or more expressions like `expr = a`,
1394     `expr = b`, etc..., it is advantageous to provide a Dummy symbol
1395     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.
1396 
1397     >>> rhs = Dummy('rhs')
1398     >>> clear_coefficients(expr, rhs)
1399     (y*(2*x + 1), _rhs/12)
1400     >>> _[1].subs(rhs, 2)
1401     1/6
1402     """
1403     was = None
1404     free = expr.free_symbols
1405     if expr.is_Rational:
1406         return (S.Zero, rhs - expr)
1407     while expr and was != expr:
1408         was = expr
1409         m, expr = (
1410             expr.as_content_primitive()
1411             if free else
1412             factor_terms(expr).as_coeff_Mul(rational=True))
1413         rhs /= m
1414         c, expr = expr.as_coeff_Add(rational=True)
1415         rhs -= c
1416     expr = signsimp(expr, evaluate = False)
1417     if _coeff_isneg(expr):
1418         expr = -expr
1419         rhs = -rhs
1420     return expr, rhs

</code><intended_behavior>The simplification logic should carefully handle trigonometric functions with complex arguments, ensuring that transformations between cos and cosh (or other trigonometric functions) respect the mathematical properties of complex numbers.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from .sympify import sympify, _sympify, SympifyError
4 from .basic import Basic, Atom
5 from .singleton import S
6 from .evalf import EvalfMixin, pure_complex
7 from .decorators import _sympifyit, call_highest_priority
8 from .cache import cacheit
9 from .compatibility import reduce, as_int, default_sort_key, range
10 from mpmath.libmp import mpf_log, prec_to_dps
11 
12 from collections import defaultdict
13 
14 class Expr(Basic, EvalfMixin):
15     """
16     Base class for algebraic expressions.
17 
18     Everything that requires arithmetic operations to be defined
19     should subclass this class, instead of Basic (which should be
20     used only for argument storage and expression manipulation, i.e.
21     pattern matching, substitutions, etc).
22 
23     See Also
24     ========
25 
26     sympy.core.basic.Basic
27     """
28 
29     __slots__ = []
30 
31     @property
32     def _diff_wrt(self):
33         """Is it allowed to take derivative wrt to this instance.
34 
35         This determines if it is allowed to take derivatives wrt this object.
36         Subclasses such as Symbol, Function and Derivative should return True
37         to enable derivatives wrt them. The implementation in Derivative
38         separates the Symbol and non-Symbol _diff_wrt=True variables and
39         temporarily converts the non-Symbol vars in Symbols when performing
40         the differentiation.
41 
42         Note, see the docstring of Derivative for how this should work
43         mathematically. In particular, note that expr.subs(yourclass, Symbol)
44         should be well-defined on a structural level, or this will lead to
45         inconsistent results.
46 
47         Examples
48         ========
49 
50         >>> from sympy import Expr
51         >>> e = Expr()
52         >>> e._diff_wrt
53         False
54         >>> class MyClass(Expr):
55         ...     _diff_wrt = True
56         ...
57         >>> (2*MyClass()).diff(MyClass())
58         2
59         """
60         return False
61 
62     @cacheit
63     def sort_key(self, order=None):
64 
65         coeff, expr = self.as_coeff_Mul()
66 
67         if expr.is_Pow:
68             expr, exp = expr.args
69         else:
70             expr, exp = expr, S.One
71 
72         if expr.is_Dummy:
73             args = (expr.sort_key(),)
74         elif expr.is_Atom:
75             args = (str(expr),)
76         else:
77             if expr.is_Add:
78                 args = expr.as_ordered_terms(order=order)
79             elif expr.is_Mul:
80                 args = expr.as_ordered_factors(order=order)
81             else:
82                 args = expr.args
83 
84             args = tuple(
85                 [ default_sort_key(arg, order=order) for arg in args ])
86 
87         args = (len(args), tuple(args))
88         exp = exp.sort_key(order=order)
89 
90         return expr.class_key(), args, exp, coeff
91 
92     # ***************
93     # * Arithmetics *
94     # ***************
95     # Expr and its sublcasses use _op_priority to determine which object
96     # passed to a binary special method (__mul__, etc.) will handle the
97     # operation. In general, the 'call_highest_priority' decorator will choose
98     # the object with the highest _op_priority to handle the call.
99     # Custom subclasses that want to define their own binary special methods
100     # should set an _op_priority value that is higher than the default.
101     #
102     # **NOTE**:
103     # This is a temporary fix, and will eventually be replaced with
104     # something better and more powerful.  See issue 5510.
105     _op_priority = 10.0
106 
107     def __pos__(self):
108         return self
109 
110     def __neg__(self):
111         return Mul(S.NegativeOne, self)
112 
113     def __abs__(self):
114         from sympy import Abs
115         return Abs(self)
116 
117     @_sympifyit('other', NotImplemented)
118     @call_highest_priority('__radd__')
119     def __add__(self, other):
120         return Add(self, other)
121 
122     @_sympifyit('other', NotImplemented)
123     @call_highest_priority('__add__')
124     def __radd__(self, other):
125         return Add(other, self)
126 
127     @_sympifyit('other', NotImplemented)
128     @call_highest_priority('__rsub__')
129     def __sub__(self, other):
130         return Add(self, -other)
131 
132     @_sympifyit('other', NotImplemented)
133     @call_highest_priority('__sub__')
134     def __rsub__(self, other):
135         return Add(other, -self)
136 
137     @_sympifyit('other', NotImplemented)
138     @call_highest_priority('__rmul__')
139     def __mul__(self, other):
140         return Mul(self, other)
141 
142     @_sympifyit('other', NotImplemented)
143     @call_highest_priority('__mul__')
144     def __rmul__(self, other):
145         return Mul(other, self)
146 
147     @_sympifyit('other', NotImplemented)
148     @call_highest_priority('__rpow__')
149     def __pow__(self, other):
150         return Pow(self, other)
151 
152     @_sympifyit('other', NotImplemented)
153     @call_highest_priority('__pow__')
154     def __rpow__(self, other):
155         return Pow(other, self)
156 
157     @_sympifyit('other', NotImplemented)
158     @call_highest_priority('__rdiv__')
159     def __div__(self, other):
160         return Mul(self, Pow(other, S.NegativeOne))
161 
162     @_sympifyit('other', NotImplemented)
163     @call_highest_priority('__div__')
164     def __rdiv__(self, other):
165         return Mul(other, Pow(self, S.NegativeOne))
166 
167     __truediv__ = __div__
168     __rtruediv__ = __rdiv__
169 
170     @_sympifyit('other', NotImplemented)
171     @call_highest_priority('__rmod__')
172     def __mod__(self, other):
173         return Mod(self, other)
174 
175     @_sympifyit('other', NotImplemented)
176     @call_highest_priority('__mod__')
177     def __rmod__(self, other):
178         return Mod(other, self)
179 
180     @_sympifyit('other', NotImplemented)
181     @call_highest_priority('__rfloordiv__')
182     def __floordiv__(self, other):
183         from sympy.functions.elementary.integers import floor
184         return floor(self / other)
185 
186     @_sympifyit('other', NotImplemented)
187     @call_highest_priority('__floordiv__')
188     def __rfloordiv__(self, other):
189         from sympy.functions.elementary.integers import floor
190         return floor(self / other)
191 
192     def __int__(self):
193         # Although we only need to round to the units position, we'll
194         # get one more digit so the extra testing below can be avoided
195         # unless the rounded value rounded to an integer, e.g. if an
196         # expression were equal to 1.9 and we rounded to the unit position
197         # we would get a 2 and would not know if this rounded up or not
198         # without doing a test (as done below). But if we keep an extra
199         # digit we know that 1.9 is not the same as 1 and there is no
200         # need for further testing: our int value is correct. If the value
201         # were 1.99, however, this would round to 2.0 and our int value is
202         # off by one. So...if our round value is the same as the int value
203         # (regardless of how much extra work we do to calculate extra decimal
204         # places) we need to test whether we are off by one.
205         from sympy import Dummy
206         if not self.is_number:
207             raise TypeError("can't convert symbols to int")
208         r = self.round(2)
209         if not r.is_Number:
210             raise TypeError("can't convert complex to int")
211         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
212             raise TypeError("can't convert %s to int" % r)
213         i = int(r)
214         if not i:
215             return 0
216         # off-by-one check
217         if i == r and not (self - i).equals(0):
218             isign = 1 if i > 0 else -1
219             x = Dummy()
220             # in the following (self - i).evalf(2) will not always work while
221             # (self - r).evalf(2) and the use of subs does; if the test that
222             # was added when this comment was added passes, it might be safe
223             # to simply use sign to compute this rather than doing this by hand:
224             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
225             if diff_sign != isign:
226                 i -= isign
227         return i
228     __long__ = __int__
229 
230     def __float__(self):
231         # Don't bother testing if it's a number; if it's not this is going
232         # to fail, and if it is we still need to check that it evalf'ed to
233         # a number.
234         result = self.evalf()
235         if result.is_Number:
236             return float(result)
237         if result.is_number and result.as_real_imag()[1]:
238             raise TypeError("can't convert complex to float")
239         raise TypeError("can't convert expression to float")
240 
241     def __complex__(self):
242         result = self.evalf()
243         re, im = result.as_real_imag()
244         return complex(float(re), float(im))
245 
246     def __ge__(self, other):
247         from sympy import GreaterThan
248         try:
249             other = _sympify(other)
250         except SympifyError:
251             raise TypeError("Invalid comparison %s >= %s" % (self, other))
252         for me in (self, other):
253             if (me.is_complex and me.is_real is False) or \
254                     me.has(S.ComplexInfinity):
255                 raise TypeError("Invalid comparison of complex %s" % me)
256             if me is S.NaN:
257                 raise TypeError("Invalid NaN comparison")
258         n2 = _n2(self, other)
259         if n2 is not None:
260             return _sympify(n2 >= 0)
261         if self.is_real or other.is_real:
262             dif = self - other
263             if dif.is_nonnegative is not None and \
264                     dif.is_nonnegative is not dif.is_negative:
265                 return sympify(dif.is_nonnegative)
266         return GreaterThan(self, other, evaluate=False)
267 
268     def __le__(self, other):
269         from sympy import LessThan
270         try:
271             other = _sympify(other)
272         except SympifyError:
273             raise TypeError("Invalid comparison %s <= %s" % (self, other))
274         for me in (self, other):
275             if (me.is_complex and me.is_real is False) or \
276                     me.has(S.ComplexInfinity):
277                 raise TypeError("Invalid comparison of complex %s" % me)
278             if me is S.NaN:
279                 raise TypeError("Invalid NaN comparison")
280         n2 = _n2(self, other)
281         if n2 is not None:
282             return _sympify(n2 <= 0)
283         if self.is_real or other.is_real:
284             dif = self - other
285             if dif.is_nonpositive is not None and \
286                     dif.is_nonpositive is not dif.is_positive:
287                 return sympify(dif.is_nonpositive)
288         return LessThan(self, other, evaluate=False)
289 
290     def __gt__(self, other):
291         from sympy import StrictGreaterThan
292         try:
293             other = _sympify(other)
294         except SympifyError:
295             raise TypeError("Invalid comparison %s > %s" % (self, other))
296         for me in (self, other):
297             if (me.is_complex and me.is_real is False) or \
298                     me.has(S.ComplexInfinity):
299                 raise TypeError("Invalid comparison of complex %s" % me)
300             if me is S.NaN:
301                 raise TypeError("Invalid NaN comparison")
302         n2 = _n2(self, other)
303         if n2 is not None:
304             return _sympify(n2 > 0)
305         if self.is_real or other.is_real:
306             dif = self - other
307             if dif.is_positive is not None and \
308                     dif.is_positive is not dif.is_nonpositive:
309                 return sympify(dif.is_positive)
310         return StrictGreaterThan(self, other, evaluate=False)
311 
312     def __lt__(self, other):
313         from sympy import StrictLessThan
314         try:
315             other = _sympify(other)
316         except SympifyError:
317             raise TypeError("Invalid comparison %s < %s" % (self, other))
318         for me in (self, other):
319             if (me.is_complex and me.is_real is False) or \
320                     me.has(S.ComplexInfinity):
321                 raise TypeError("Invalid comparison of complex %s" % me)
322             if me is S.NaN:
323                 raise TypeError("Invalid NaN comparison")
324         n2 = _n2(self, other)
325         if n2 is not None:
326             return _sympify(n2 < 0)
327         if self.is_real or other.is_real:
328             dif = self - other
329             if dif.is_negative is not None and \
330                     dif.is_negative is not dif.is_nonnegative:
331                 return sympify(dif.is_negative)
332         return StrictLessThan(self, other, evaluate=False)
333 
334     @staticmethod
335     def _from_mpmath(x, prec):
336         from sympy import Float
337         if hasattr(x, "_mpf_"):
338             return Float._new(x._mpf_, prec)
339         elif hasattr(x, "_mpc_"):
340             re, im = x._mpc_
341             re = Float._new(re, prec)
342             im = Float._new(im, prec)*S.ImaginaryUnit
343             return re + im
344         else:
345             raise TypeError("expected mpmath number (mpf or mpc)")
346 
347     @property
348     def is_number(self):
349         """Returns True if ``self`` has no free symbols.
350         It will be faster than ``if not self.free_symbols``, however, since
351         ``is_number`` will fail as soon as it hits a free symbol.
352 
353         Examples
354         ========
355 
356         >>> from sympy import log, Integral
357         >>> from sympy.abc import x
358 
359         >>> x.is_number
360         False
361         >>> (2*x).is_number
362         False
363         >>> (2 + log(2)).is_number
364         True
365         >>> (2 + Integral(2, x)).is_number
366         False
367         >>> (2 + Integral(2, (x, 1, 2))).is_number
368         True
369 
370         """
371         return all(obj.is_number for obj in self.args)
372 
373     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
374         """Return self evaluated, if possible, replacing free symbols with
375         random complex values, if necessary.
376 
377         The random complex value for each free symbol is generated
378         by the random_complex_number routine giving real and imaginary
379         parts in the range given by the re_min, re_max, im_min, and im_max
380         values. The returned value is evaluated to a precision of n
381         (if given) else the maximum of 15 and the precision needed
382         to get more than 1 digit of precision. If the expression
383         could not be evaluated to a number, or could not be evaluated
384         to more than 1 digit of precision, then None is returned.
385 
386         Examples
387         ========
388 
389         >>> from sympy import sqrt
390         >>> from sympy.abc import x, y
391         >>> x._random()                         # doctest: +SKIP
392         0.0392918155679172 + 0.916050214307199*I
393         >>> x._random(2)                        # doctest: +SKIP
394         -0.77 - 0.87*I
395         >>> (x + y/2)._random(2)                # doctest: +SKIP
396         -0.57 + 0.16*I
397         >>> sqrt(2)._random(2)
398         1.4
399 
400         See Also
401         ========
402 
403         sympy.utilities.randtest.random_complex_number
404         """
405 
406         free = self.free_symbols
407         prec = 1
408         if free:
409             from sympy.utilities.randtest import random_complex_number
410             a, c, b, d = re_min, re_max, im_min, im_max
411             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
412                            for zi in free])))
413             try:
414                 nmag = abs(self.evalf(2, subs=reps))
415             except (ValueError, TypeError):
416                 # if an out of range value resulted in evalf problems
417                 # then return None -- XXX is there a way to know how to
418                 # select a good random number for a given expression?
419                 # e.g. when calculating n! negative values for n should not
420                 # be used
421                 return None
422         else:
423             reps = {}
424             nmag = abs(self.evalf(2))
425 
426         if not hasattr(nmag, '_prec'):
427             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
428             return None
429 
430         if nmag._prec == 1:
431             # increase the precision up to the default maximum
432             # precision to see if we can get any significance
433 
434             from mpmath.libmp.libintmath import giant_steps
435             from sympy.core.evalf import DEFAULT_MAXPREC as target
436 
437             # evaluate
438             for prec in giant_steps(2, target):
439                 nmag = abs(self.evalf(prec, subs=reps))
440                 if nmag._prec != 1:
441                     break
442 
443         if nmag._prec != 1:
444             if n is None:
445                 n = max(prec, 15)
446             return self.evalf(n, subs=reps)
447 
448         # never got any significance
449         return None
450 
451     def is_constant(self, *wrt, **flags):
452         """Return True if self is constant, False if not, or None if
453         the constancy could not be determined conclusively.
454 
455         If an expression has no free symbols then it is a constant. If
456         there are free symbols it is possible that the expression is a
457         constant, perhaps (but not necessarily) zero. To test such
458         expressions, two strategies are tried:
459 
460         1) numerical evaluation at two random points. If two such evaluations
461         give two different values and the values have a precision greater than
462         1 then self is not constant. If the evaluations agree or could not be
463         obtained with any precision, no decision is made. The numerical testing
464         is done only if ``wrt`` is different than the free symbols.
465 
466         2) differentiation with respect to variables in 'wrt' (or all free
467         symbols if omitted) to see if the expression is constant or not. This
468         will not always lead to an expression that is zero even though an
469         expression is constant (see added test in test_expr.py). If
470         all derivatives are zero then self is constant with respect to the
471         given symbols.
472 
473         If neither evaluation nor differentiation can prove the expression is
474         constant, None is returned unless two numerical values happened to be
475         the same and the flag ``failing_number`` is True -- in that case the
476         numerical value will be returned.
477 
478         If flag simplify=False is passed, self will not be simplified;
479         the default is True since self should be simplified before testing.
480 
481         Examples
482         ========
483 
484         >>> from sympy import cos, sin, Sum, S, pi
485         >>> from sympy.abc import a, n, x, y
486         >>> x.is_constant()
487         False
488         >>> S(2).is_constant()
489         True
490         >>> Sum(x, (x, 1, 10)).is_constant()
491         True
492         >>> Sum(x, (x, 1, n)).is_constant()
493         False
494         >>> Sum(x, (x, 1, n)).is_constant(y)
495         True
496         >>> Sum(x, (x, 1, n)).is_constant(n)
497         False
498         >>> Sum(x, (x, 1, n)).is_constant(x)
499         True
500         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
501         >>> eq.is_constant()
502         True
503         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
504         True
505 
506         >>> (0**x).is_constant()
507         False
508         >>> x.is_constant()
509         False
510         >>> (x**x).is_constant()
511         False
512         >>> one = cos(x)**2 + sin(x)**2
513         >>> one.is_constant()
514         True
515         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
516         True
517         """
518 
519         simplify = flags.get('simplify', True)
520 
521         # Except for expressions that contain units, only one of these should
522         # be necessary since if something is
523         # known to be a number it should also know that there are no
524         # free symbols. But is_number quits as soon as it hits a non-number
525         # whereas free_symbols goes until all free symbols have been collected,
526         # thus is_number should be faster. But a double check on free symbols
527         # is made just in case there is a discrepancy between the two.
528         free = self.free_symbols
529         if self.is_number or not free:
530             # if the following assertion fails then that object's free_symbols
531             # method needs attention: if an expression is a number it cannot
532             # have free symbols
533             assert not free
534             return True
535 
536         # if we are only interested in some symbols and they are not in the
537         # free symbols then this expression is constant wrt those symbols
538         wrt = set(wrt)
539         if wrt and not wrt & free:
540             return True
541         wrt = wrt or free
542 
543         # simplify unless this has already been done
544         expr = self
545         if simplify:
546             expr = expr.simplify()
547 
548         # is_zero should be a quick assumptions check; it can be wrong for
549         # numbers (see test_is_not_constant test), giving False when it
550         # shouldn't, but hopefully it will never give True unless it is sure.
551         if expr.is_zero:
552             return True
553 
554         # try numerical evaluation to see if we get two different values
555         failing_number = None
556         if wrt == free:
557             # try 0 (for a) and 1 (for b)
558             try:
559                 a = expr.subs(list(zip(free, [0]*len(free))),
560                     simultaneous=True)
561                 if a is S.NaN:
562                     # evaluation may succeed when substitution fails
563                     a = expr._random(None, 0, 0, 0, 0)
564             except ZeroDivisionError:
565                 a = None
566             if a is not None and a is not S.NaN:
567                 try:
568                     b = expr.subs(list(zip(free, [1]*len(free))),
569                         simultaneous=True)
570                     if b is S.NaN:
571                         # evaluation may succeed when substitution fails
572                         b = expr._random(None, 1, 0, 1, 0)
573                 except ZeroDivisionError:
574                     b = None
575                 if b is not None and b is not S.NaN and b.equals(a) is False:
576                     return False
577                 # try random real
578                 b = expr._random(None, -1, 0, 1, 0)
579                 if b is not None and b is not S.NaN and b.equals(a) is False:
580                     return False
581                 # try random complex
582                 b = expr._random()
583                 if b is not None and b is not S.NaN:
584                     if b.equals(a) is False:
585                         return False
586                     failing_number = a if a.is_number else b
587 
588         # now we will test each wrt symbol (or all free symbols) to see if the
589         # expression depends on them or not using differentiation. This is
590         # not sufficient for all expressions, however, so we don't return
591         # False if we get a derivative other than 0 with free symbols.
592         for w in wrt:
593             deriv = expr.diff(w)
594             if simplify:
595                 deriv = deriv.simplify()
596             if deriv != 0:
597                 if not (pure_complex(deriv, or_real=True)):
598                     if flags.get('failing_number', False):
599                         return failing_number
600                     elif deriv.free_symbols:
601                         # dead line provided _random returns None in such cases
602                         return None
603                 return False
604         return True
605 
606     def equals(self, other, failing_expression=False):
607         """Return True if self == other, False if it doesn't, or None. If
608         failing_expression is True then the expression which did not simplify
609         to a 0 will be returned instead of None.
610 
611         If ``self`` is a Number (or complex number) that is not zero, then
612         the result is False.
613 
614         If ``self`` is a number and has not evaluated to zero, evalf will be
615         used to test whether the expression evaluates to zero. If it does so
616         and the result has significance (i.e. the precision is either -1, for
617         a Rational result, or is greater than 1) then the evalf value will be
618         used to return True or False.
619 
620         """
621         from sympy.simplify.simplify import nsimplify, simplify
622         from sympy.solvers.solveset import solveset
623         from sympy.polys.polyerrors import NotAlgebraic
624         from sympy.polys.numberfields import minimal_polynomial
625 
626         other = sympify(other)
627         if self == other:
628             return True
629 
630         # they aren't the same so see if we can make the difference 0;
631         # don't worry about doing simplification steps one at a time
632         # because if the expression ever goes to 0 then the subsequent
633         # simplification steps that are done will be very fast.
634         diff = factor_terms(simplify(self - other), radical=True)
635 
636         if not diff:
637             return True
638 
639         if not diff.has(Add, Mod):
640             # if there is no expanding to be done after simplifying
641             # then this can't be a zero
642             return False
643 
644         constant = diff.is_constant(simplify=False, failing_number=True)
645 
646         if constant is False:
647             return False
648 
649         if constant is None and (diff.free_symbols or not diff.is_number):
650             # e.g. unless the right simplification is done, a symbolic
651             # zero is possible (see expression of issue 6829: without
652             # simplification constant will be None).
653             return
654 
655         if constant is True:
656             ndiff = diff._random()
657             if ndiff:
658                 return False
659 
660         # sometimes we can use a simplified result to give a clue as to
661         # what the expression should be; if the expression is *not* zero
662         # then we should have been able to compute that and so now
663         # we can just consider the cases where the approximation appears
664         # to be zero -- we try to prove it via minimal_polynomial.
665         if diff.is_number:
666             approx = diff.nsimplify()
667             if not approx:
668                 # try to prove via self-consistency
669                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
670                 # it seems to work better to try big ones first
671                 surds.sort(key=lambda x: -x.args[0])
672                 for s in surds:
673                     try:
674                         # simplify is False here -- this expression has already
675                         # been identified as being hard to identify as zero;
676                         # we will handle the checking ourselves using nsimplify
677                         # to see if we are in the right ballpark or not and if so
678                         # *then* the simplification will be attempted.
679                         if s.is_Symbol:
680                             sol = list(solveset(diff, s))
681                         else:
682                             sol = [s]
683                         if sol:
684                             if s in sol:
685                                 return True
686                             if s.is_real:
687                                 if any(nsimplify(si, [s]) == s and simplify(si) == s
688                                         for si in sol):
689                                     return True
690                     except NotImplementedError:
691                         pass
692 
693                 # try to prove with minimal_polynomial but know when
694                 # *not* to use this or else it can take a long time. e.g. issue 8354
695                 if True:  # change True to condition that assures non-hang
696                     try:
697                         mp = minimal_polynomial(diff)
698                         if mp.is_Symbol:
699                             return True
700                         return False
701                     except (NotAlgebraic, NotImplementedError):
702                         pass
703 
704         # diff has not simplified to zero; constant is either None, True
705         # or the number with significance (prec != 1) that was randomly
706         # calculated twice as the same value.
707         if constant not in (True, None) and constant != 0:
708             return False
709 
710         if failing_expression:
711             return diff
712         return None
713 
714     def _eval_is_positive(self):
715         from sympy.polys.numberfields import minimal_polynomial
716         from sympy.polys.polyerrors import NotAlgebraic
717         if self.is_number:
718             if self.is_real is False:
719                 return False
720             try:
721                 # check to see that we can get a value
722                 n2 = self._eval_evalf(2)
723                 if n2 is None:
724                     raise AttributeError
725                 if n2._prec == 1:  # no significance
726                     raise AttributeError
727                 if n2 == S.NaN:
728                     raise AttributeError
729             except (AttributeError, ValueError):
730                 return None
731             n, i = self.evalf(2).as_real_imag()
732             if not i.is_Number or not n.is_Number:
733                 return False
734             if n._prec != 1 and i._prec != 1:
735                 return bool(not i and n > 0)
736             elif n._prec == 1 and (not i or i._prec == 1) and \
737                     self.is_algebraic and not self.has(Function):
738                 try:
739                     if minimal_polynomial(self).is_Symbol:
740                         return False
741                 except (NotAlgebraic, NotImplementedError):
742                     pass
743 
744     def _eval_is_negative(self):
745         from sympy.polys.numberfields import minimal_polynomial
746         from sympy.polys.polyerrors import NotAlgebraic
747         if self.is_number:
748             if self.is_real is False:
749                 return False
750             try:
751                 # check to see that we can get a value
752                 n2 = self._eval_evalf(2)
753                 if n2 is None:
754                     raise AttributeError
755                 if n2._prec == 1:  # no significance
756                     raise AttributeError
757                 if n2 == S.NaN:
758                     raise AttributeError
759             except (AttributeError, ValueError):
760                 return None
761             n, i = self.evalf(2).as_real_imag()
762             if not i.is_Number or not n.is_Number:
763                 return False
764             if n._prec != 1 and i._prec != 1:
765                 return bool(not i and n < 0)
766             elif n._prec == 1 and (not i or i._prec == 1) and \
767                     self.is_algebraic and not self.has(Function):
768                 try:
769                     if minimal_polynomial(self).is_Symbol:
770                         return False
771                 except (NotAlgebraic, NotImplementedError):
772                     pass
773 
774     def _eval_interval(self, x, a, b):
775         """
776         Returns evaluation over an interval.  For most functions this is:
777 
778         self.subs(x, b) - self.subs(x, a),
779 
780         possibly using limit() if NaN is returned from subs.
781 
782         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
783         respectively.
784 
785         """
786         from sympy.series import limit, Limit
787         from sympy.solvers.solveset import solveset
788         from sympy.sets.sets import Interval
789 
790         if (a is None and b is None):
791             raise ValueError('Both interval ends cannot be None.')
792 
793         if a == b:
794             return 0
795 
796         if a is None:
797             A = 0
798         else:
799             A = self.subs(x, a)
800             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
801                 if (a < b) != False:
802                     A = limit(self, x, a,"+")
803                 else:
804                     A = limit(self, x, a,"-")
805 
806                 if A is S.NaN:
807                     return A
808                 if isinstance(A, Limit):
809                     raise NotImplementedError("Could not compute limit")
810 
811         if b is None:
812             B = 0
813         else:
814             B = self.subs(x, b)
815             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
816                 if (a < b) != False:
817                     B = limit(self, x, b,"-")
818                 else:
819                     B = limit(self, x, b,"+")
820 
821                 if isinstance(B, Limit):
822                     raise NotImplementedError("Could not compute limit")
823 
824         if (a and b) is None:
825             return B - A
826 
827         value = B - A
828 
829         if a.is_comparable and b.is_comparable:
830             if a < b:
831                 domain = Interval(a, b)
832             else:
833                 domain = Interval(b, a)
834             singularities = list(solveset(self.cancel().as_numer_denom()[1], x, domain = domain))
835             for s in singularities:
836                 if a < s < b:
837                     value += -limit(self, x, s, "+") + limit(self, x, s, "-")
838                 elif b < s < a:
839                     value += limit(self, x, s, "+") - limit(self, x, s, "-")
840 
841         return value
842 
843     def _eval_power(self, other):
844         # subclass to compute self**other for cases when
845         # other is not NaN, 0, or 1
846         return None
847 
848     def _eval_conjugate(self):
849         if self.is_real:
850             return self
851         elif self.is_imaginary:
852             return -self
853 
854     def conjugate(self):
855         from sympy.functions.elementary.complexes import conjugate as c
856         return c(self)
857 
858     def _eval_transpose(self):
859         from sympy.functions.elementary.complexes import conjugate
860         if self.is_complex:
861             return self
862         elif self.is_hermitian:
863             return conjugate(self)
864         elif self.is_antihermitian:
865             return -conjugate(self)
866 
867     def transpose(self):
868         from sympy.functions.elementary.complexes import transpose
869         return transpose(self)
870 
871     def _eval_adjoint(self):
872         from sympy.functions.elementary.complexes import conjugate, transpose
873         if self.is_hermitian:
874             return self
875         elif self.is_antihermitian:
876             return -self
877         obj = self._eval_conjugate()
878         if obj is not None:
879             return transpose(obj)
880         obj = self._eval_transpose()
881         if obj is not None:
882             return conjugate(obj)
883 
884     def adjoint(self):
885         from sympy.functions.elementary.complexes import adjoint
886         return adjoint(self)
887 
888     @classmethod
889     def _parse_order(cls, order):
890         """Parse and configure the ordering of terms. """
891         from sympy.polys.orderings import monomial_key
892 
893         try:
894             reverse = order.startswith('rev-')
895         except AttributeError:
896             reverse = False
897         else:
898             if reverse:
899                 order = order[4:]
900 
901         monom_key = monomial_key(order)
902 
903         def neg(monom):
904             result = []
905 
906             for m in monom:
907                 if isinstance(m, tuple):
908                     result.append(neg(m))
909                 else:
910                     result.append(-m)
911 
912             return tuple(result)
913 
914         def key(term):
915             _, ((re, im), monom, ncpart) = term
916 
917             monom = neg(monom_key(monom))
918             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
919             coeff = ((bool(im), im), (re, im))
920 
921             return monom, ncpart, coeff
922 
923         return key, reverse
924 
925     def as_ordered_factors(self, order=None):
926         """Return list of ordered factors (if Mul) else [self]."""
927         return [self]
928 
929     def as_ordered_terms(self, order=None, data=False):
930         """
931         Transform an expression to an ordered list of terms.
932 
933         Examples
934         ========
935 
936         >>> from sympy import sin, cos
937         >>> from sympy.abc import x
938 
939         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
940         [sin(x)**2*cos(x), sin(x)**2, 1]
941 
942         """
943         key, reverse = self._parse_order(order)
944         terms, gens = self.as_terms()
945 
946         if not any(term.is_Order for term, _ in terms):
947             ordered = sorted(terms, key=key, reverse=reverse)
948         else:
949             _terms, _order = [], []
950 
951             for term, repr in terms:
952                 if not term.is_Order:
953                     _terms.append((term, repr))
954                 else:
955                     _order.append((term, repr))
956 
957             ordered = sorted(_terms, key=key, reverse=True) \
958                 + sorted(_order, key=key, reverse=True)
959 
960         if data:
961             return ordered, gens
962         else:
963             return [term for term, _ in ordered]
964 
965     def as_terms(self):
966         """Transform an expression to a list of terms. """
967         from .add import Add
968         from .mul import Mul
969         from .exprtools import decompose_power
970 
971         gens, terms = set([]), []
972 
973         for term in Add.make_args(self):
974             coeff, _term = term.as_coeff_Mul()
975 
976             coeff = complex(coeff)
977             cpart, ncpart = {}, []
978 
979             if _term is not S.One:
980                 for factor in Mul.make_args(_term):
981                     if factor.is_number:
982                         try:
983                             coeff *= complex(factor)
984                         except TypeError:
985                             pass
986                         else:
987                             continue
988 
989                     if factor.is_commutative:
990                         base, exp = decompose_power(factor)
991 
992                         cpart[base] = exp
993                         gens.add(base)
994                     else:
995                         ncpart.append(factor)
996 
997             coeff = coeff.real, coeff.imag
998             ncpart = tuple(ncpart)
999 
1000             terms.append((term, (coeff, cpart, ncpart)))
1001 
1002         gens = sorted(gens, key=default_sort_key)
1003 
1004         k, indices = len(gens), {}
1005 
1006         for i, g in enumerate(gens):
1007             indices[g] = i
1008 
1009         result = []
1010 
1011         for term, (coeff, cpart, ncpart) in terms:
1012             monom = [0]*k
1013 
1014             for base, exp in cpart.items():
1015                 monom[indices[base]] = exp
1016 
1017             result.append((term, (coeff, tuple(monom), ncpart)))
1018 
1019         return result, gens
1020 
1021     def removeO(self):
1022         """Removes the additive O(..) symbol if there is one"""
1023         return self
1024 
1025     def getO(self):
1026         """Returns the additive O(..) symbol if there is one, else None."""
1027         return None
1028 
1029     def getn(self):
1030         """
1031         Returns the order of the expression.
1032 
1033         The order is determined either from the O(...) term. If there
1034         is no O(...) term, it returns None.
1035 
1036         Examples
1037         ========
1038 
1039         >>> from sympy import O
1040         >>> from sympy.abc import x
1041         >>> (1 + x + O(x**2)).getn()
1042         2
1043         >>> (1 + x).getn()
1044 
1045         """
1046         from sympy import Dummy, Symbol
1047         o = self.getO()
1048         if o is None:
1049             return None
1050         elif o.is_Order:
1051             o = o.expr
1052             if o is S.One:
1053                 return S.Zero
1054             if o.is_Symbol:
1055                 return S.One
1056             if o.is_Pow:
1057                 return o.args[1]
1058             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1059                 for oi in o.args:
1060                     if oi.is_Symbol:
1061                         return S.One
1062                     if oi.is_Pow:
1063                         syms = oi.atoms(Symbol)
1064                         if len(syms) == 1:
1065                             x = syms.pop()
1066                             oi = oi.subs(x, Dummy('x', positive=True))
1067                             if oi.base.is_Symbol and oi.exp.is_Rational:
1068                                 return abs(oi.exp)
1069 
1070         raise NotImplementedError('not sure of order of %s' % o)
1071 
1072     def count_ops(self, visual=None):
1073         """wrapper for count_ops that returns the operation count."""
1074         from .function import count_ops
1075         return count_ops(self, visual)
1076 
1077     def args_cnc(self, cset=False, warn=True, split_1=True):
1078         """Return [commutative factors, non-commutative factors] of self.
1079 
1080         self is treated as a Mul and the ordering of the factors is maintained.
1081         If ``cset`` is True the commutative factors will be returned in a set.
1082         If there were repeated factors (as may happen with an unevaluated Mul)
1083         then an error will be raised unless it is explicitly supressed by
1084         setting ``warn`` to False.
1085 
1086         Note: -1 is always separated from a Number unless split_1 is False.
1087 
1088         >>> from sympy import symbols, oo
1089         >>> A, B = symbols('A B', commutative=0)
1090         >>> x, y = symbols('x y')
1091         >>> (-2*x*y).args_cnc()
1092         [[-1, 2, x, y], []]
1093         >>> (-2.5*x).args_cnc()
1094         [[-1, 2.5, x], []]
1095         >>> (-2*x*A*B*y).args_cnc()
1096         [[-1, 2, x, y], [A, B]]
1097         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1098         [[-2, x, y], [A, B]]
1099         >>> (-2*x*y).args_cnc(cset=True)
1100         [{-1, 2, x, y}, []]
1101 
1102         The arg is always treated as a Mul:
1103 
1104         >>> (-2 + x + A).args_cnc()
1105         [[], [x - 2 + A]]
1106         >>> (-oo).args_cnc() # -oo is a singleton
1107         [[-1, oo], []]
1108         """
1109 
1110         if self.is_Mul:
1111             args = list(self.args)
1112         else:
1113             args = [self]
1114         for i, mi in enumerate(args):
1115             if not mi.is_commutative:
1116                 c = args[:i]
1117                 nc = args[i:]
1118                 break
1119         else:
1120             c = args
1121             nc = []
1122 
1123         if c and split_1 and (
1124             c[0].is_Number and
1125             c[0].is_negative and
1126                 c[0] is not S.NegativeOne):
1127             c[:1] = [S.NegativeOne, -c[0]]
1128 
1129         if cset:
1130             clen = len(c)
1131             c = set(c)
1132             if clen and warn and len(c) != clen:
1133                 raise ValueError('repeated commutative arguments: %s' %
1134                                  [ci for ci in c if list(self.args).count(ci) > 1])
1135         return [c, nc]
1136 
1137     def coeff(self, x, n=1, right=False):
1138         """
1139         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1140         is zero then all terms independent of ``x`` will be returned.
1141 
1142         When ``x`` is noncommutative, the coefficient to the left (default) or
1143         right of ``x`` can be returned. The keyword 'right' is ignored when
1144         ``x`` is commutative.
1145 
1146         See Also
1147         ========
1148 
1149         as_coefficient: separate the expression into a coefficient and factor
1150         as_coeff_Add: separate the additive constant from an expression
1151         as_coeff_Mul: separate the multiplicative constant from an expression
1152         as_independent: separate x-dependent terms/factors from others
1153         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1154         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1155 
1156         Examples
1157         ========
1158 
1159         >>> from sympy import symbols
1160         >>> from sympy.abc import x, y, z
1161 
1162         You can select terms that have an explicit negative in front of them:
1163 
1164         >>> (-x + 2*y).coeff(-1)
1165         x
1166         >>> (x - 2*y).coeff(-1)
1167         2*y
1168 
1169         You can select terms with no Rational coefficient:
1170 
1171         >>> (x + 2*y).coeff(1)
1172         x
1173         >>> (3 + 2*x + 4*x**2).coeff(1)
1174         0
1175 
1176         You can select terms independent of x by making n=0; in this case
1177         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1178         of None):
1179 
1180         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1181         3
1182         >>> eq = ((x + 1)**3).expand() + 1
1183         >>> eq
1184         x**3 + 3*x**2 + 3*x + 2
1185         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1186         [1, 3, 3, 2]
1187         >>> eq -= 2
1188         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1189         [1, 3, 3, 0]
1190 
1191         You can select terms that have a numerical term in front of them:
1192 
1193         >>> (-x - 2*y).coeff(2)
1194         -y
1195         >>> from sympy import sqrt
1196         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1197         x
1198 
1199         The matching is exact:
1200 
1201         >>> (3 + 2*x + 4*x**2).coeff(x)
1202         2
1203         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1204         4
1205         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1206         0
1207         >>> (z*(x + y)**2).coeff((x + y)**2)
1208         z
1209         >>> (z*(x + y)**2).coeff(x + y)
1210         0
1211 
1212         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1213         from the following:
1214 
1215         >>> (x + z*(x + x*y)).coeff(x)
1216         1
1217 
1218         If such factoring is desired, factor_terms can be used first:
1219 
1220         >>> from sympy import factor_terms
1221         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1222         z*(y + 1) + 1
1223 
1224         >>> n, m, o = symbols('n m o', commutative=False)
1225         >>> n.coeff(n)
1226         1
1227         >>> (3*n).coeff(n)
1228         3
1229         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1230         1 + m
1231         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1232         m
1233 
1234         If there is more than one possible coefficient 0 is returned:
1235 
1236         >>> (n*m + m*n).coeff(n)
1237         0
1238 
1239         If there is only one possible coefficient, it is returned:
1240 
1241         >>> (n*m + x*m*n).coeff(m*n)
1242         x
1243         >>> (n*m + x*m*n).coeff(m*n, right=1)
1244         1
1245 
1246         """
1247         x = sympify(x)
1248         if not isinstance(x, Basic):
1249             return S.Zero
1250 
1251         n = as_int(n)
1252 
1253         if not x:
1254             return S.Zero
1255 
1256         if x == self:
1257             if n == 1:
1258                 return S.One
1259             return S.Zero
1260 
1261         if x is S.One:
1262             co = [a for a in Add.make_args(self)
1263                   if a.as_coeff_Mul()[0] is S.One]
1264             if not co:
1265                 return S.Zero
1266             return Add(*co)
1267 
1268         if n == 0:
1269             if x.is_Add and self.is_Add:
1270                 c = self.coeff(x, right=right)
1271                 if not c:
1272                     return S.Zero
1273                 if not right:
1274                     return self - Add(*[a*x for a in Add.make_args(c)])
1275                 return self - Add(*[x*a for a in Add.make_args(c)])
1276             return self.as_independent(x, as_Add=True)[0]
1277 
1278         # continue with the full method, looking for this power of x:
1279         x = x**n
1280 
1281         def incommon(l1, l2):
1282             if not l1 or not l2:
1283                 return []
1284             n = min(len(l1), len(l2))
1285             for i in range(n):
1286                 if l1[i] != l2[i]:
1287                     return l1[:i]
1288             return l1[:]
1289 
1290         def find(l, sub, first=True):
1291             """ Find where list sub appears in list l. When ``first`` is True
1292             the first occurance from the left is returned, else the last
1293             occurance is returned. Return None if sub is not in l.
1294 
1295             >> l = range(5)*2
1296             >> find(l, [2, 3])
1297             2
1298             >> find(l, [2, 3], first=0)
1299             7
1300             >> find(l, [2, 4])
1301             None
1302 
1303             """
1304             if not sub or not l or len(sub) > len(l):
1305                 return None
1306             n = len(sub)
1307             if not first:
1308                 l.reverse()
1309                 sub.reverse()
1310             for i in range(0, len(l) - n + 1):
1311                 if all(l[i + j] == sub[j] for j in range(n)):
1312                     break
1313             else:
1314                 i = None
1315             if not first:
1316                 l.reverse()
1317                 sub.reverse()
1318             if i is not None and not first:
1319                 i = len(l) - (i + n)
1320             return i
1321 
1322         co = []
1323         args = Add.make_args(self)
1324         self_c = self.is_commutative
1325         x_c = x.is_commutative
1326         if self_c and not x_c:
1327             return S.Zero
1328 
1329         if self_c:
1330             xargs = x.args_cnc(cset=True, warn=False)[0]
1331             for a in args:
1332                 margs = a.args_cnc(cset=True, warn=False)[0]
1333                 if len(xargs) > len(margs):
1334                     continue
1335                 resid = margs.difference(xargs)
1336                 if len(resid) + len(xargs) == len(margs):
1337                     co.append(Mul(*resid))
1338             if co == []:
1339                 return S.Zero
1340             elif co:
1341                 return Add(*co)
1342         elif x_c:
1343             xargs = x.args_cnc(cset=True, warn=False)[0]
1344             for a in args:
1345                 margs, nc = a.args_cnc(cset=True)
1346                 if len(xargs) > len(margs):
1347                     continue
1348                 resid = margs.difference(xargs)
1349                 if len(resid) + len(xargs) == len(margs):
1350                     co.append(Mul(*(list(resid) + nc)))
1351             if co == []:
1352                 return S.Zero
1353             elif co:
1354                 return Add(*co)
1355         else:  # both nc
1356             xargs, nx = x.args_cnc(cset=True)
1357             # find the parts that pass the commutative terms
1358             for a in args:
1359                 margs, nc = a.args_cnc(cset=True)
1360                 if len(xargs) > len(margs):
1361                     continue
1362                 resid = margs.difference(xargs)
1363                 if len(resid) + len(xargs) == len(margs):
1364                     co.append((resid, nc))
1365             # now check the non-comm parts
1366             if not co:
1367                 return S.Zero
1368             if all(n == co[0][1] for r, n in co):
1369                 ii = find(co[0][1], nx, right)
1370                 if ii is not None:
1371                     if not right:
1372                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1373                     else:
1374                         return Mul(*co[0][1][ii + len(nx):])
1375             beg = reduce(incommon, (n[1] for n in co))
1376             if beg:
1377                 ii = find(beg, nx, right)
1378                 if ii is not None:
1379                     if not right:
1380                         gcdc = co[0][0]
1381                         for i in range(1, len(co)):
1382                             gcdc = gcdc.intersection(co[i][0])
1383                             if not gcdc:
1384                                 break
1385                         return Mul(*(list(gcdc) + beg[:ii]))
1386                     else:
1387                         m = ii + len(nx)
1388                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1389             end = list(reversed(
1390                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1391             if end:
1392                 ii = find(end, nx, right)
1393                 if ii is not None:
1394                     if not right:
1395                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1396                     else:
1397                         return Mul(*end[ii + len(nx):])
1398             # look for single match
1399             hit = None
1400             for i, (r, n) in enumerate(co):
1401                 ii = find(n, nx, right)
1402                 if ii is not None:
1403                     if not hit:
1404                         hit = ii, r, n
1405                     else:
1406                         break
1407             else:
1408                 if hit:
1409                     ii, r, n = hit
1410                     if not right:
1411                         return Mul(*(list(r) + n[:ii]))
1412                     else:
1413                         return Mul(*n[ii + len(nx):])
1414 
1415             return S.Zero
1416 
1417     def as_expr(self, *gens):
1418         """
1419         Convert a polynomial to a SymPy expression.
1420 
1421         Examples
1422         ========
1423 
1424         >>> from sympy import sin
1425         >>> from sympy.abc import x, y
1426 
1427         >>> f = (x**2 + x*y).as_poly(x, y)
1428         >>> f.as_expr()
1429         x**2 + x*y
1430 
1431         >>> sin(x).as_expr()
1432         sin(x)
1433 
1434         """
1435         return self
1436 
1437     def as_coefficient(self, expr):
1438         """
1439         Extracts symbolic coefficient at the given expression. In
1440         other words, this functions separates 'self' into the product
1441         of 'expr' and 'expr'-free coefficient. If such separation
1442         is not possible it will return None.
1443 
1444         Examples
1445         ========
1446 
1447         >>> from sympy import E, pi, sin, I, Poly
1448         >>> from sympy.abc import x
1449 
1450         >>> E.as_coefficient(E)
1451         1
1452         >>> (2*E).as_coefficient(E)
1453         2
1454         >>> (2*sin(E)*E).as_coefficient(E)
1455 
1456         Two terms have E in them so a sum is returned. (If one were
1457         desiring the coefficient of the term exactly matching E then
1458         the constant from the returned expression could be selected.
1459         Or, for greater precision, a method of Poly can be used to
1460         indicate the desired term from which the coefficient is
1461         desired.)
1462 
1463         >>> (2*E + x*E).as_coefficient(E)
1464         x + 2
1465         >>> _.args[0]  # just want the exact match
1466         2
1467         >>> p = Poly(2*E + x*E); p
1468         Poly(x*E + 2*E, x, E, domain='ZZ')
1469         >>> p.coeff_monomial(E)
1470         2
1471         >>> p.nth(0, 1)
1472         2
1473 
1474         Since the following cannot be written as a product containing
1475         E as a factor, None is returned. (If the coefficient ``2*x`` is
1476         desired then the ``coeff`` method should be used.)
1477 
1478         >>> (2*E*x + x).as_coefficient(E)
1479         >>> (2*E*x + x).coeff(E)
1480         2*x
1481 
1482         >>> (E*(x + 1) + x).as_coefficient(E)
1483 
1484         >>> (2*pi*I).as_coefficient(pi*I)
1485         2
1486         >>> (2*I).as_coefficient(pi*I)
1487 
1488         See Also
1489         ========
1490 
1491         coeff: return sum of terms have a given factor
1492         as_coeff_Add: separate the additive constant from an expression
1493         as_coeff_Mul: separate the multiplicative constant from an expression
1494         as_independent: separate x-dependent terms/factors from others
1495         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1496         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1497 
1498 
1499         """
1500 
1501         r = self.extract_multiplicatively(expr)
1502         if r and not r.has(expr):
1503             return r
1504 
1505     def as_independent(self, *deps, **hint):
1506         """
1507         A mostly naive separation of a Mul or Add into arguments that are not
1508         are dependent on deps. To obtain as complete a separation of variables
1509         as possible, use a separation method first, e.g.:
1510 
1511         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1512         * .expand(mul=True) to change Add or Mul into Add
1513         * .expand(log=True) to change log expr into an Add
1514 
1515         The only non-naive thing that is done here is to respect noncommutative
1516         ordering of variables and to always return (0, 0) for `self` of zero
1517         regardless of hints.
1518 
1519         For nonzero `self`, the returned tuple (i, d) has the
1520         following interpretation:
1521 
1522         * i will has no variable that appears in deps
1523         * d will be 1 or else have terms that contain variables that are in deps
1524         * if self is an Add then self = i + d
1525         * if self is a Mul then self = i*d
1526         * otherwise (self, S.One) or (S.One, self) is returned.
1527 
1528         To force the expression to be treated as an Add, use the hint as_Add=True
1529 
1530         Examples
1531         ========
1532 
1533         -- self is an Add
1534 
1535         >>> from sympy import sin, cos, exp
1536         >>> from sympy.abc import x, y, z
1537 
1538         >>> (x + x*y).as_independent(x)
1539         (0, x*y + x)
1540         >>> (x + x*y).as_independent(y)
1541         (x, x*y)
1542         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1543         (y + z, 2*x*sin(x) + x)
1544         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1545         (z, 2*x*sin(x) + x + y)
1546 
1547         -- self is a Mul
1548 
1549         >>> (x*sin(x)*cos(y)).as_independent(x)
1550         (cos(y), x*sin(x))
1551 
1552         non-commutative terms cannot always be separated out when self is a Mul
1553 
1554         >>> from sympy import symbols
1555         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1556         >>> (n1 + n1*n2).as_independent(n2)
1557         (n1, n1*n2)
1558         >>> (n2*n1 + n1*n2).as_independent(n2)
1559         (0, n1*n2 + n2*n1)
1560         >>> (n1*n2*n3).as_independent(n1)
1561         (1, n1*n2*n3)
1562         >>> (n1*n2*n3).as_independent(n2)
1563         (n1, n2*n3)
1564         >>> ((x-n1)*(x-y)).as_independent(x)
1565         (1, (x - y)*(x - n1))
1566 
1567         -- self is anything else:
1568 
1569         >>> (sin(x)).as_independent(x)
1570         (1, sin(x))
1571         >>> (sin(x)).as_independent(y)
1572         (sin(x), 1)
1573         >>> exp(x+y).as_independent(x)
1574         (1, exp(x + y))
1575 
1576         -- force self to be treated as an Add:
1577 
1578         >>> (3*x).as_independent(x, as_Add=True)
1579         (0, 3*x)
1580 
1581         -- force self to be treated as a Mul:
1582 
1583         >>> (3+x).as_independent(x, as_Add=False)
1584         (1, x + 3)
1585         >>> (-3+x).as_independent(x, as_Add=False)
1586         (1, x - 3)
1587 
1588         Note how the below differs from the above in making the
1589         constant on the dep term positive.
1590 
1591         >>> (y*(-3+x)).as_independent(x)
1592         (y, x - 3)
1593 
1594         -- use .as_independent() for true independence testing instead
1595            of .has(). The former considers only symbols in the free
1596            symbols while the latter considers all symbols
1597 
1598         >>> from sympy import Integral
1599         >>> I = Integral(x, (x, 1, 2))
1600         >>> I.has(x)
1601         True
1602         >>> x in I.free_symbols
1603         False
1604         >>> I.as_independent(x) == (I, 1)
1605         True
1606         >>> (I + x).as_independent(x) == (I, x)
1607         True
1608 
1609         Note: when trying to get independent terms, a separation method
1610         might need to be used first. In this case, it is important to keep
1611         track of what you send to this routine so you know how to interpret
1612         the returned values
1613 
1614         >>> from sympy import separatevars, log
1615         >>> separatevars(exp(x+y)).as_independent(x)
1616         (exp(y), exp(x))
1617         >>> (x + x*y).as_independent(y)
1618         (x, x*y)
1619         >>> separatevars(x + x*y).as_independent(y)
1620         (x, y + 1)
1621         >>> (x*(1 + y)).as_independent(y)
1622         (x, y + 1)
1623         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1624         (x, x*y)
1625         >>> a, b=symbols('a b', positive=True)
1626         >>> (log(a*b).expand(log=True)).as_independent(b)
1627         (log(a), log(b))
1628 
1629         See Also
1630         ========
1631         .separatevars(), .expand(log=True), Add.as_two_terms(),
1632         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1633         """
1634         from .symbol import Symbol
1635         from .add import _unevaluated_Add
1636         from .mul import _unevaluated_Mul
1637         from sympy.utilities.iterables import sift
1638 
1639         if self.is_zero:
1640             return S.Zero, S.Zero
1641 
1642         func = self.func
1643         if hint.get('as_Add', func is Add):
1644             want = Add
1645         else:
1646             want = Mul
1647 
1648         # sift out deps into symbolic and other and ignore
1649         # all symbols but those that are in the free symbols
1650         sym = set()
1651         other = []
1652         for d in deps:
1653             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1654                 sym.add(d)
1655             else:
1656                 other.append(d)
1657 
1658         def has(e):
1659             """return the standard has() if there are no literal symbols, else
1660             check to see that symbol-deps are in the free symbols."""
1661             has_other = e.has(*other)
1662             if not sym:
1663                 return has_other
1664             return has_other or e.has(*(e.free_symbols & sym))
1665 
1666         if (want is not func or
1667                 func is not Add and func is not Mul):
1668             if has(self):
1669                 return (want.identity, self)
1670             else:
1671                 return (self, want.identity)
1672         else:
1673             if func is Add:
1674                 args = list(self.args)
1675             else:
1676                 args, nc = self.args_cnc()
1677 
1678         d = sift(args, lambda x: has(x))
1679         depend = d[True]
1680         indep = d[False]
1681         if func is Add:  # all terms were treated as commutative
1682             return (Add(*indep), _unevaluated_Add(*depend))
1683         else:  # handle noncommutative by stopping at first dependent term
1684             for i, n in enumerate(nc):
1685                 if has(n):
1686                     depend.extend(nc[i:])
1687                     break
1688                 indep.append(n)
1689             return Mul(*indep), (
1690                 Mul(*depend, evaluate=False) if nc else
1691                 _unevaluated_Mul(*depend))
1692 
1693     def as_real_imag(self, deep=True, **hints):
1694         """Performs complex expansion on 'self' and returns a tuple
1695            containing collected both real and imaginary parts. This
1696            method can't be confused with re() and im() functions,
1697            which does not perform complex expansion at evaluation.
1698 
1699            However it is possible to expand both re() and im()
1700            functions and get exactly the same results as with
1701            a single call to this function.
1702 
1703            >>> from sympy import symbols, I
1704 
1705            >>> x, y = symbols('x,y', real=True)
1706 
1707            >>> (x + y*I).as_real_imag()
1708            (x, y)
1709 
1710            >>> from sympy.abc import z, w
1711 
1712            >>> (z + w*I).as_real_imag()
1713            (re(z) - im(w), re(w) + im(z))
1714 
1715         """
1716         from sympy import im, re
1717         if hints.get('ignore') == self:
1718             return None
1719         else:
1720             return (re(self), im(self))
1721 
1722     def as_powers_dict(self):
1723         """Return self as a dictionary of factors with each factor being
1724         treated as a power. The keys are the bases of the factors and the
1725         values, the corresponding exponents. The resulting dictionary should
1726         be used with caution if the expression is a Mul and contains non-
1727         commutative factors since the order that they appeared will be lost in
1728         the dictionary."""
1729         d = defaultdict(int)
1730         d.update(dict([self.as_base_exp()]))
1731         return d
1732 
1733     def as_coefficients_dict(self):
1734         """Return a dictionary mapping terms to their Rational coefficient.
1735         Since the dictionary is a defaultdict, inquiries about terms which
1736         were not present will return a coefficient of 0. If an expression is
1737         not an Add it is considered to have a single term.
1738 
1739         Examples
1740         ========
1741 
1742         >>> from sympy.abc import a, x
1743         >>> (3*x + a*x + 4).as_coefficients_dict()
1744         {1: 4, x: 3, a*x: 1}
1745         >>> _[a]
1746         0
1747         >>> (3*a*x).as_coefficients_dict()
1748         {a*x: 3}
1749 
1750         """
1751         c, m = self.as_coeff_Mul()
1752         if not c.is_Rational:
1753             c = S.One
1754             m = self
1755         d = defaultdict(int)
1756         d.update({m: c})
1757         return d
1758 
1759     def as_base_exp(self):
1760         # a -> b ** e
1761         return self, S.One
1762 
1763     def as_coeff_mul(self, *deps, **kwargs):
1764         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1765 
1766         c should be a Rational multiplied by any factors of the Mul that are
1767         independent of deps.
1768 
1769         args should be a tuple of all other factors of m; args is empty
1770         if self is a Number or if self is independent of deps (when given).
1771 
1772         This should be used when you don't know if self is a Mul or not but
1773         you want to treat self as a Mul or if you want to process the
1774         individual arguments of the tail of self as a Mul.
1775 
1776         - if you know self is a Mul and want only the head, use self.args[0];
1777         - if you don't want to process the arguments of the tail but need the
1778           tail then use self.as_two_terms() which gives the head and tail;
1779         - if you want to split self into an independent and dependent parts
1780           use ``self.as_independent(*deps)``
1781 
1782         >>> from sympy import S
1783         >>> from sympy.abc import x, y
1784         >>> (S(3)).as_coeff_mul()
1785         (3, ())
1786         >>> (3*x*y).as_coeff_mul()
1787         (3, (x, y))
1788         >>> (3*x*y).as_coeff_mul(x)
1789         (3*y, (x,))
1790         >>> (3*y).as_coeff_mul(x)
1791         (3*y, ())
1792         """
1793         if deps:
1794             if not self.has(*deps):
1795                 return self, tuple()
1796         return S.One, (self,)
1797 
1798     def as_coeff_add(self, *deps):
1799         """Return the tuple (c, args) where self is written as an Add, ``a``.
1800 
1801         c should be a Rational added to any terms of the Add that are
1802         independent of deps.
1803 
1804         args should be a tuple of all other terms of ``a``; args is empty
1805         if self is a Number or if self is independent of deps (when given).
1806 
1807         This should be used when you don't know if self is an Add or not but
1808         you want to treat self as an Add or if you want to process the
1809         individual arguments of the tail of self as an Add.
1810 
1811         - if you know self is an Add and want only the head, use self.args[0];
1812         - if you don't want to process the arguments of the tail but need the
1813           tail then use self.as_two_terms() which gives the head and tail.
1814         - if you want to split self into an independent and dependent parts
1815           use ``self.as_independent(*deps)``
1816 
1817         >>> from sympy import S
1818         >>> from sympy.abc import x, y
1819         >>> (S(3)).as_coeff_add()
1820         (3, ())
1821         >>> (3 + x).as_coeff_add()
1822         (3, (x,))
1823         >>> (3 + x + y).as_coeff_add(x)
1824         (y + 3, (x,))
1825         >>> (3 + y).as_coeff_add(x)
1826         (y + 3, ())
1827 
1828         """
1829         if deps:
1830             if not self.has(*deps):
1831                 return self, tuple()
1832         return S.Zero, (self,)
1833 
1834     def primitive(self):
1835         """Return the positive Rational that can be extracted non-recursively
1836         from every term of self (i.e., self is treated like an Add). This is
1837         like the as_coeff_Mul() method but primitive always extracts a positive
1838         Rational (never a negative or a Float).
1839 
1840         Examples
1841         ========
1842 
1843         >>> from sympy.abc import x
1844         >>> (3*(x + 1)**2).primitive()
1845         (3, (x + 1)**2)
1846         >>> a = (6*x + 2); a.primitive()
1847         (2, 3*x + 1)
1848         >>> b = (x/2 + 3); b.primitive()
1849         (1/2, x + 6)
1850         >>> (a*b).primitive() == (1, a*b)
1851         True
1852         """
1853         if not self:
1854             return S.One, S.Zero
1855         c, r = self.as_coeff_Mul(rational=True)
1856         if c.is_negative:
1857             c, r = -c, -r
1858         return c, r
1859 
1860     def as_content_primitive(self, radical=False, clear=True):
1861         """This method should recursively remove a Rational from all arguments
1862         and return that (content) and the new self (primitive). The content
1863         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
1864         The primitive need not be in canonical form and should try to preserve
1865         the underlying structure if possible (i.e. expand_mul should not be
1866         applied to self).
1867 
1868         Examples
1869         ========
1870 
1871         >>> from sympy import sqrt
1872         >>> from sympy.abc import x, y, z
1873 
1874         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
1875 
1876         The as_content_primitive function is recursive and retains structure:
1877 
1878         >>> eq.as_content_primitive()
1879         (2, x + 3*y*(y + 1) + 1)
1880 
1881         Integer powers will have Rationals extracted from the base:
1882 
1883         >>> ((2 + 6*x)**2).as_content_primitive()
1884         (4, (3*x + 1)**2)
1885         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
1886         (1, (2*(3*x + 1))**(2*y))
1887 
1888         Terms may end up joining once their as_content_primitives are added:
1889 
1890         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1891         (11, x*(y + 1))
1892         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1893         (9, x*(y + 1))
1894         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
1895         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
1896         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
1897         (121, x**2*(y + 1)**2)
1898         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
1899         (1, 121.0*x**2*(y + 1)**2)
1900 
1901         Radical content can also be factored out of the primitive:
1902 
1903         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
1904         (2, sqrt(2)*(1 + 2*sqrt(5)))
1905 
1906         If clear=False (default is True) then content will not be removed
1907         from an Add if it can be distributed to leave one or more
1908         terms with integer coefficients.
1909 
1910         >>> (x/2 + y).as_content_primitive()
1911         (1/2, x + 2*y)
1912         >>> (x/2 + y).as_content_primitive(clear=False)
1913         (1, x/2 + y)
1914         """
1915         return S.One, self
1916 
1917     def as_numer_denom(self):
1918         """ expression -> a/b -> a, b
1919 
1920         This is just a stub that should be defined by
1921         an object's class methods to get anything else.
1922 
1923         See Also
1924         ========
1925         normal: return a/b instead of a, b
1926         """
1927 
1928         return self, S.One
1929 
1930     def normal(self):
1931         from .mul import _unevaluated_Mul
1932         n, d = self.as_numer_denom()
1933         if d is S.One:
1934             return n
1935         if d.is_Number:
1936             if d is S.One:
1937                 return n
1938             else:
1939                 return _unevaluated_Mul(n, 1/d)
1940         else:
1941             return n/d
1942 
1943     def extract_multiplicatively(self, c):
1944         """Return None if it's not possible to make self in the form
1945            c * something in a nice way, i.e. preserving the properties
1946            of arguments of self.
1947 
1948            >>> from sympy import symbols, Rational
1949 
1950            >>> x, y = symbols('x,y', real=True)
1951 
1952            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1953            x*y**2
1954 
1955            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1956 
1957            >>> (2*x).extract_multiplicatively(2)
1958            x
1959 
1960            >>> (2*x).extract_multiplicatively(3)
1961 
1962            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1963            x/6
1964 
1965         """
1966         from .function import _coeff_isneg
1967 
1968         c = sympify(c)
1969         if self is S.NaN:
1970             return None
1971         if c is S.One:
1972             return self
1973         elif c == self:
1974             return S.One
1975 
1976         if c.is_Add:
1977             cc, pc = c.primitive()
1978             if cc is not S.One:
1979                 c = Mul(cc, pc, evaluate=False)
1980 
1981         if c.is_Mul:
1982             a, b = c.as_two_terms()
1983             x = self.extract_multiplicatively(a)
1984             if x is not None:
1985                 return x.extract_multiplicatively(b)
1986 
1987         quotient = self / c
1988         if self.is_Number:
1989             if self is S.Infinity:
1990                 if c.is_positive:
1991                     return S.Infinity
1992             elif self is S.NegativeInfinity:
1993                 if c.is_negative:
1994                     return S.Infinity
1995                 elif c.is_positive:
1996                     return S.NegativeInfinity
1997             elif self is S.ComplexInfinity:
1998                 if not c.is_zero:
1999                     return S.ComplexInfinity
2000             elif self.is_Integer:
2001                 if not quotient.is_Integer:
2002                     return None
2003                 elif self.is_positive and quotient.is_negative:
2004                     return None
2005                 else:
2006                     return quotient
2007             elif self.is_Rational:
2008                 if not quotient.is_Rational:
2009                     return None
2010                 elif self.is_positive and quotient.is_negative:
2011                     return None
2012                 else:
2013                     return quotient
2014             elif self.is_Float:
2015                 if not quotient.is_Float:
2016                     return None
2017                 elif self.is_positive and quotient.is_negative:
2018                     return None
2019                 else:
2020                     return quotient
2021         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2022             if quotient.is_Mul and len(quotient.args) == 2:
2023                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2024                     return quotient
2025             elif quotient.is_Integer and c.is_Number:
2026                 return quotient
2027         elif self.is_Add:
2028             cs, ps = self.primitive()
2029             # assert cs >= 1
2030             if c.is_Number and c is not S.NegativeOne:
2031                 # assert c != 1 (handled at top)
2032                 if cs is not S.One:
2033                     if c.is_negative:
2034                         xc = -(cs.extract_multiplicatively(-c))
2035                     else:
2036                         xc = cs.extract_multiplicatively(c)
2037                     if xc is not None:
2038                         return xc*ps  # rely on 2-arg Mul to restore Add
2039                 return  # |c| != 1 can only be extracted from cs
2040             if c == ps:
2041                 return cs
2042             # check args of ps
2043             newargs = []
2044             for arg in ps.args:
2045                 newarg = arg.extract_multiplicatively(c)
2046                 if newarg is None:
2047                     return  # all or nothing
2048                 newargs.append(newarg)
2049             # args should be in same order so use unevaluated return
2050             if cs is not S.One:
2051                 return Add._from_args([cs*t for t in newargs])
2052             else:
2053                 return Add._from_args(newargs)
2054         elif self.is_Mul:
2055             args = list(self.args)
2056             for i, arg in enumerate(args):
2057                 newarg = arg.extract_multiplicatively(c)
2058                 if newarg is not None:
2059                     args[i] = newarg
2060                     return Mul(*args)
2061         elif self.is_Pow:
2062             if c.is_Pow and c.base == self.base:
2063                 new_exp = self.exp.extract_additively(c.exp)
2064                 if new_exp is not None:
2065                     return self.base ** (new_exp)
2066             elif c == self.base:
2067                 new_exp = self.exp.extract_additively(1)
2068                 if new_exp is not None:
2069                     return self.base ** (new_exp)
2070 
2071     def extract_additively(self, c):
2072         """Return self - c if it's possible to subtract c from self and
2073         make all matching coefficients move towards zero, else return None.
2074 
2075         Examples
2076         ========
2077 
2078         >>> from sympy.abc import x, y
2079         >>> e = 2*x + 3
2080         >>> e.extract_additively(x + 1)
2081         x + 2
2082         >>> e.extract_additively(3*x)
2083         >>> e.extract_additively(4)
2084         >>> (y*(x + 1)).extract_additively(x + 1)
2085         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2086         (x + 1)*(x + 2*y) + 3
2087 
2088         Sometimes auto-expansion will return a less simplified result
2089         than desired; gcd_terms might be used in such cases:
2090 
2091         >>> from sympy import gcd_terms
2092         >>> (4*x*(y + 1) + y).extract_additively(x)
2093         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2094         >>> gcd_terms(_)
2095         x*(4*y + 3) + y
2096 
2097         See Also
2098         ========
2099         extract_multiplicatively
2100         coeff
2101         as_coefficient
2102 
2103         """
2104 
2105         c = sympify(c)
2106         if self is S.NaN:
2107             return None
2108         if c is S.Zero:
2109             return self
2110         elif c == self:
2111             return S.Zero
2112         elif self is S.Zero:
2113             return None
2114 
2115         if self.is_Number:
2116             if not c.is_Number:
2117                 return None
2118             co = self
2119             diff = co - c
2120             # XXX should we match types? i.e should 3 - .1 succeed?
2121             if (co > 0 and diff > 0 and diff < co or
2122                     co < 0 and diff < 0 and diff > co):
2123                 return diff
2124             return None
2125 
2126         if c.is_Number:
2127             co, t = self.as_coeff_Add()
2128             xa = co.extract_additively(c)
2129             if xa is None:
2130                 return None
2131             return xa + t
2132 
2133         # handle the args[0].is_Number case separately
2134         # since we will have trouble looking for the coeff of
2135         # a number.
2136         if c.is_Add and c.args[0].is_Number:
2137             # whole term as a term factor
2138             co = self.coeff(c)
2139             xa0 = (co.extract_additively(1) or 0)*c
2140             if xa0:
2141                 diff = self - co*c
2142                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2143             # term-wise
2144             h, t = c.as_coeff_Add()
2145             sh, st = self.as_coeff_Add()
2146             xa = sh.extract_additively(h)
2147             if xa is None:
2148                 return None
2149             xa2 = st.extract_additively(t)
2150             if xa2 is None:
2151                 return None
2152             return xa + xa2
2153 
2154         # whole term as a term factor
2155         co = self.coeff(c)
2156         xa0 = (co.extract_additively(1) or 0)*c
2157         if xa0:
2158             diff = self - co*c
2159             return (xa0 + (diff.extract_additively(c) or diff)) or None
2160         # term-wise
2161         coeffs = []
2162         for a in Add.make_args(c):
2163             ac, at = a.as_coeff_Mul()
2164             co = self.coeff(at)
2165             if not co:
2166                 return None
2167             coc, cot = co.as_coeff_Add()
2168             xa = coc.extract_additively(ac)
2169             if xa is None:
2170                 return None
2171             self -= co*at
2172             coeffs.append((cot + xa)*at)
2173         coeffs.append(self)
2174         return Add(*coeffs)
2175 
2176     def could_extract_minus_sign(self):
2177         """Return True if self is not in a canonical form with respect
2178         to its sign.
2179 
2180         For most expressions, e, there will be a difference in e and -e.
2181         When there is, True will be returned for one and False for the
2182         other; False will be returned if there is no difference.
2183 
2184         Examples
2185         ========
2186 
2187         >>> from sympy.abc import x, y
2188         >>> e = x - y
2189         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2190         {False, True}
2191 
2192         """
2193         negative_self = -self
2194         if self == negative_self:
2195             return False  # e.g. zoo*x == -zoo*x
2196         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2197         negative_self_has_minus = (
2198             (negative_self).extract_multiplicatively(-1) is not None)
2199         if self_has_minus != negative_self_has_minus:
2200             return self_has_minus
2201         else:
2202             if self.is_Add:
2203                 # We choose the one with less arguments with minus signs
2204                 all_args = len(self.args)
2205                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2206                 positive_args = all_args - negative_args
2207                 if positive_args > negative_args:
2208                     return False
2209                 elif positive_args < negative_args:
2210                     return True
2211             elif self.is_Mul:
2212                 # We choose the one with an odd number of minus signs
2213                 num, den = self.as_numer_denom()
2214                 args = Mul.make_args(num) + Mul.make_args(den)
2215                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2216                 negative_args = list(filter(None, arg_signs))
2217                 return len(negative_args) % 2 == 1
2218 
2219             # As a last resort, we choose the one with greater value of .sort_key()
2220             return bool(self.sort_key() < negative_self.sort_key())
2221 
2222     def extract_branch_factor(self, allow_half=False):
2223         """
2224         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2225         Return (z, n).
2226 
2227         >>> from sympy import exp_polar, I, pi
2228         >>> from sympy.abc import x, y
2229         >>> exp_polar(I*pi).extract_branch_factor()
2230         (exp_polar(I*pi), 0)
2231         >>> exp_polar(2*I*pi).extract_branch_factor()
2232         (1, 1)
2233         >>> exp_polar(-pi*I).extract_branch_factor()
2234         (exp_polar(I*pi), -1)
2235         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2236         (exp_polar(x + I*pi), 1)
2237         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2238         (y*exp_polar(2*pi*x), -1)
2239         >>> exp_polar(-I*pi/2).extract_branch_factor()
2240         (exp_polar(-I*pi/2), 0)
2241 
2242         If allow_half is True, also extract exp_polar(I*pi):
2243 
2244         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2245         (1, 1/2)
2246         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2247         (1, 1)
2248         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2249         (1, 3/2)
2250         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2251         (1, -1/2)
2252         """
2253         from sympy import exp_polar, pi, I, ceiling, Add
2254         n = S(0)
2255         res = S(1)
2256         args = Mul.make_args(self)
2257         exps = []
2258         for arg in args:
2259             if arg.func is exp_polar:
2260                 exps += [arg.exp]
2261             else:
2262                 res *= arg
2263         piimult = S(0)
2264         extras = []
2265         while exps:
2266             exp = exps.pop()
2267             if exp.is_Add:
2268                 exps += exp.args
2269                 continue
2270             if exp.is_Mul:
2271                 coeff = exp.as_coefficient(pi*I)
2272                 if coeff is not None:
2273                     piimult += coeff
2274                     continue
2275             extras += [exp]
2276         if not piimult.free_symbols:
2277             coeff = piimult
2278             tail = ()
2279         else:
2280             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2281         # round down to nearest multiple of 2
2282         branchfact = ceiling(coeff/2 - S(1)/2)*2
2283         n += branchfact/2
2284         c = coeff - branchfact
2285         if allow_half:
2286             nc = c.extract_additively(1)
2287             if nc is not None:
2288                 n += S(1)/2
2289                 c = nc
2290         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2291         if newexp != 0:
2292             res *= exp_polar(newexp)
2293         return res, n
2294 
2295     def _eval_is_polynomial(self, syms):
2296         if self.free_symbols.intersection(syms) == set([]):
2297             return True
2298         return False
2299 
2300     def is_polynomial(self, *syms):
2301         r"""
2302         Return True if self is a polynomial in syms and False otherwise.
2303 
2304         This checks if self is an exact polynomial in syms.  This function
2305         returns False for expressions that are "polynomials" with symbolic
2306         exponents.  Thus, you should be able to apply polynomial algorithms to
2307         expressions for which this returns True, and Poly(expr, \*syms) should
2308         work if and only if expr.is_polynomial(\*syms) returns True. The
2309         polynomial does not have to be in expanded form.  If no symbols are
2310         given, all free symbols in the expression will be used.
2311 
2312         This is not part of the assumptions system.  You cannot do
2313         Symbol('z', polynomial=True).
2314 
2315         Examples
2316         ========
2317 
2318         >>> from sympy import Symbol
2319         >>> x = Symbol('x')
2320         >>> ((x**2 + 1)**4).is_polynomial(x)
2321         True
2322         >>> ((x**2 + 1)**4).is_polynomial()
2323         True
2324         >>> (2**x + 1).is_polynomial(x)
2325         False
2326 
2327 
2328         >>> n = Symbol('n', nonnegative=True, integer=True)
2329         >>> (x**n + 1).is_polynomial(x)
2330         False
2331 
2332         This function does not attempt any nontrivial simplifications that may
2333         result in an expression that does not appear to be a polynomial to
2334         become one.
2335 
2336         >>> from sympy import sqrt, factor, cancel
2337         >>> y = Symbol('y', positive=True)
2338         >>> a = sqrt(y**2 + 2*y + 1)
2339         >>> a.is_polynomial(y)
2340         False
2341         >>> factor(a)
2342         y + 1
2343         >>> factor(a).is_polynomial(y)
2344         True
2345 
2346         >>> b = (y**2 + 2*y + 1)/(y + 1)
2347         >>> b.is_polynomial(y)
2348         False
2349         >>> cancel(b)
2350         y + 1
2351         >>> cancel(b).is_polynomial(y)
2352         True
2353 
2354         See also .is_rational_function()
2355 
2356         """
2357         if syms:
2358             syms = set(map(sympify, syms))
2359         else:
2360             syms = self.free_symbols
2361 
2362         if syms.intersection(self.free_symbols) == set([]):
2363             # constant polynomial
2364             return True
2365         else:
2366             return self._eval_is_polynomial(syms)
2367 
2368     def _eval_is_rational_function(self, syms):
2369         if self.free_symbols.intersection(syms) == set([]):
2370             return True
2371         return False
2372 
2373     def is_rational_function(self, *syms):
2374         """
2375         Test whether function is a ratio of two polynomials in the given
2376         symbols, syms. When syms is not given, all free symbols will be used.
2377         The rational function does not have to be in expanded or in any kind of
2378         canonical form.
2379 
2380         This function returns False for expressions that are "rational
2381         functions" with symbolic exponents.  Thus, you should be able to call
2382         .as_numer_denom() and apply polynomial algorithms to the result for
2383         expressions for which this returns True.
2384 
2385         This is not part of the assumptions system.  You cannot do
2386         Symbol('z', rational_function=True).
2387 
2388         Examples
2389         ========
2390 
2391         >>> from sympy import Symbol, sin
2392         >>> from sympy.abc import x, y
2393 
2394         >>> (x/y).is_rational_function()
2395         True
2396 
2397         >>> (x**2).is_rational_function()
2398         True
2399 
2400         >>> (x/sin(y)).is_rational_function(y)
2401         False
2402 
2403         >>> n = Symbol('n', integer=True)
2404         >>> (x**n + 1).is_rational_function(x)
2405         False
2406 
2407         This function does not attempt any nontrivial simplifications that may
2408         result in an expression that does not appear to be a rational function
2409         to become one.
2410 
2411         >>> from sympy import sqrt, factor
2412         >>> y = Symbol('y', positive=True)
2413         >>> a = sqrt(y**2 + 2*y + 1)/y
2414         >>> a.is_rational_function(y)
2415         False
2416         >>> factor(a)
2417         (y + 1)/y
2418         >>> factor(a).is_rational_function(y)
2419         True
2420 
2421         See also is_algebraic_expr().
2422 
2423         """
2424         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2425             return False
2426 
2427         if syms:
2428             syms = set(map(sympify, syms))
2429         else:
2430             syms = self.free_symbols
2431 
2432         if syms.intersection(self.free_symbols) == set([]):
2433             # constant rational function
2434             return True
2435         else:
2436             return self._eval_is_rational_function(syms)
2437 
2438     def _eval_is_algebraic_expr(self, syms):
2439         if self.free_symbols.intersection(syms) == set([]):
2440             return True
2441         return False
2442 
2443     def is_algebraic_expr(self, *syms):
2444         """
2445         This tests whether a given expression is algebraic or not, in the
2446         given symbols, syms. When syms is not given, all free symbols
2447         will be used. The rational function does not have to be in expanded
2448         or in any kind of canonical form.
2449 
2450         This function returns False for expressions that are "algebraic
2451         expressions" with symbolic exponents. This is a simple extension to the
2452         is_rational_function, including rational exponentiation.
2453 
2454         Examples
2455         ========
2456 
2457         >>> from sympy import Symbol, sqrt
2458         >>> x = Symbol('x', real=True)
2459         >>> sqrt(1 + x).is_rational_function()
2460         False
2461         >>> sqrt(1 + x).is_algebraic_expr()
2462         True
2463 
2464         This function does not attempt any nontrivial simplifications that may
2465         result in an expression that does not appear to be an algebraic
2466         expression to become one.
2467 
2468         >>> from sympy import exp, factor
2469         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2470         >>> a.is_algebraic_expr(x)
2471         False
2472         >>> factor(a).is_algebraic_expr()
2473         True
2474 
2475         See Also
2476         ========
2477         is_rational_function()
2478 
2479         References
2480         ==========
2481 
2482         - http://en.wikipedia.org/wiki/Algebraic_expression
2483 
2484         """
2485         if syms:
2486             syms = set(map(sympify, syms))
2487         else:
2488             syms = self.free_symbols
2489 
2490         if syms.intersection(self.free_symbols) == set([]):
2491             # constant algebraic expression
2492             return True
2493         else:
2494             return self._eval_is_algebraic_expr(syms)
2495 
2496     ###################################################################################
2497     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2498     ###################################################################################
2499 
2500     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2501         """
2502         Series expansion of "self" around ``x = x0`` yielding either terms of
2503         the series one by one (the lazy series given when n=None), else
2504         all the terms at once when n != None.
2505 
2506         Returns the series expansion of "self" around the point ``x = x0``
2507         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2508 
2509         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2510         be supplied, otherwise an error will be raised.
2511 
2512         >>> from sympy import cos, exp
2513         >>> from sympy.abc import x, y
2514         >>> cos(x).series()
2515         1 - x**2/2 + x**4/24 + O(x**6)
2516         >>> cos(x).series(n=4)
2517         1 - x**2/2 + O(x**4)
2518         >>> cos(x).series(x, x0=1, n=2)
2519         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2520         >>> e = cos(x + exp(y))
2521         >>> e.series(y, n=2)
2522         cos(x + 1) - y*sin(x + 1) + O(y**2)
2523         >>> e.series(x, n=2)
2524         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2525 
2526         If ``n=None`` then a generator of the series terms will be returned.
2527 
2528         >>> term=cos(x).series(n=None)
2529         >>> [next(term) for i in range(2)]
2530         [1, -x**2/2]
2531 
2532         For ``dir=+`` (default) the series is calculated from the right and
2533         for ``dir=-`` the series from the left. For smooth functions this
2534         flag will not alter the results.
2535 
2536         >>> abs(x).series(dir="+")
2537         x
2538         >>> abs(x).series(dir="-")
2539         -x
2540 
2541         """
2542         from sympy import collect, Dummy, Order, Rational, Symbol
2543         if x is None:
2544             syms = self.atoms(Symbol)
2545             if not syms:
2546                 return self
2547             elif len(syms) > 1:
2548                 raise ValueError('x must be given for multivariate functions.')
2549             x = syms.pop()
2550 
2551         if not self.has(x):
2552             if n is None:
2553                 return (s for s in [self])
2554             else:
2555                 return self
2556 
2557         if len(dir) != 1 or dir not in '+-':
2558             raise ValueError("Dir must be '+' or '-'")
2559 
2560         if x0 in [S.Infinity, S.NegativeInfinity]:
2561             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]
2562             s = self.subs(x, 1/x).series(x, n=n, dir=dir)
2563             if n is None:
2564                 return (si.subs(x, 1/x) for si in s)
2565             return s.subs(x, 1/x)
2566 
2567         # use rep to shift origin to x0 and change sign (if dir is negative)
2568         # and undo the process with rep2
2569         if x0 or dir == '-':
2570             if dir == '-':
2571                 rep = -x + x0
2572                 rep2 = -x
2573                 rep2b = x0
2574             else:
2575                 rep = x + x0
2576                 rep2 = x
2577                 rep2b = -x0
2578             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2579             if n is None:  # lseries...
2580                 return (si.subs(x, rep2 + rep2b) for si in s)
2581             return s.subs(x, rep2 + rep2b)
2582 
2583         # from here on it's x0=0 and dir='+' handling
2584 
2585         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2586             # replace x with an x that has a positive assumption
2587             xpos = Dummy('x', positive=True, finite=True)
2588             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2589             if n is None:
2590                 return (s.subs(xpos, x) for s in rv)
2591             else:
2592                 return rv.subs(xpos, x)
2593 
2594         if n is not None:  # nseries handling
2595             s1 = self._eval_nseries(x, n=n, logx=logx)
2596             o = s1.getO() or S.Zero
2597             if o:
2598                 # make sure the requested order is returned
2599                 ngot = o.getn()
2600                 if ngot > n:
2601                     # leave o in its current form (e.g. with x*log(x)) so
2602                     # it eats terms properly, then replace it below
2603                     if n != 0:
2604                         s1 += o.subs(x, x**Rational(n, ngot))
2605                     else:
2606                         s1 += Order(1, x)
2607                 elif ngot < n:
2608                     # increase the requested number of terms to get the desired
2609                     # number keep increasing (up to 9) until the received order
2610                     # is different than the original order and then predict how
2611                     # many additional terms are needed
2612                     for more in range(1, 9):
2613                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2614                         newn = s1.getn()
2615                         if newn != ngot:
2616                             ndo = n + (n - ngot)*more/(newn - ngot)
2617                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2618                             while s1.getn() < n:
2619                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2620                                 ndo += 1
2621                             break
2622                     else:
2623                         raise ValueError('Could not calculate %s terms for %s'
2624                                          % (str(n), self))
2625                     s1 += Order(x**n, x)
2626                 o = s1.getO()
2627                 s1 = s1.removeO()
2628             else:
2629                 o = Order(x**n, x)
2630                 s1done = s1.doit()
2631                 if (s1done + o).removeO() == s1done:
2632                     o = S.Zero
2633 
2634             try:
2635                 return collect(s1, x) + o
2636             except NotImplementedError:
2637                 return s1 + o
2638 
2639         else:  # lseries handling
2640             def yield_lseries(s):
2641                 """Return terms of lseries one at a time."""
2642                 for si in s:
2643                     if not si.is_Add:
2644                         yield si
2645                         continue
2646                     # yield terms 1 at a time if possible
2647                     # by increasing order until all the
2648                     # terms have been returned
2649                     yielded = 0
2650                     o = Order(si, x)*x
2651                     ndid = 0
2652                     ndo = len(si.args)
2653                     while 1:
2654                         do = (si - yielded + o).removeO()
2655                         o *= x
2656                         if not do or do.is_Order:
2657                             continue
2658                         if do.is_Add:
2659                             ndid += len(do.args)
2660                         else:
2661                             ndid += 1
2662                         yield do
2663                         if ndid == ndo:
2664                             break
2665                         yielded += do
2666 
2667             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2668 
2669     def taylor_term(self, n, x, *previous_terms):
2670         """General method for the taylor term.
2671 
2672         This method is slow, because it differentiates n-times. Subclasses can
2673         redefine it to make it faster by using the "previous_terms".
2674         """
2675         from sympy import Dummy, factorial
2676         x = sympify(x)
2677         _x = Dummy('x')
2678         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2679 
2680     def lseries(self, x=None, x0=0, dir='+', logx=None):
2681         """
2682         Wrapper for series yielding an iterator of the terms of the series.
2683 
2684         Note: an infinite series will yield an infinite iterator. The following,
2685         for exaxmple, will never terminate. It will just keep printing terms
2686         of the sin(x) series::
2687 
2688           for term in sin(x).lseries(x):
2689               print term
2690 
2691         The advantage of lseries() over nseries() is that many times you are
2692         just interested in the next term in the series (i.e. the first term for
2693         example), but you don't know how many you should ask for in nseries()
2694         using the "n" parameter.
2695 
2696         See also nseries().
2697         """
2698         return self.series(x, x0, n=None, dir=dir, logx=logx)
2699 
2700     def _eval_lseries(self, x, logx=None):
2701         # default implementation of lseries is using nseries(), and adaptively
2702         # increasing the "n". As you can see, it is not very efficient, because
2703         # we are calculating the series over and over again. Subclasses should
2704         # override this method and implement much more efficient yielding of
2705         # terms.
2706         n = 0
2707         series = self._eval_nseries(x, n=n, logx=logx)
2708         if not series.is_Order:
2709             if series.is_Add:
2710                 yield series.removeO()
2711             else:
2712                 yield series
2713             return
2714 
2715         while series.is_Order:
2716             n += 1
2717             series = self._eval_nseries(x, n=n, logx=logx)
2718         e = series.removeO()
2719         yield e
2720         while 1:
2721             while 1:
2722                 n += 1
2723                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2724                 if e != series:
2725                     break
2726             yield series - e
2727             e = series
2728 
2729     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2730         """
2731         Wrapper to _eval_nseries if assumptions allow, else to series.
2732 
2733         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2734         called. This calculates "n" terms in the innermost expressions and
2735         then builds up the final series just by "cross-multiplying" everything
2736         out.
2737 
2738         The optional ``logx`` parameter can be used to replace any log(x) in the
2739         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2740         symbol to use in place of log(x) should be provided.
2741 
2742         Advantage -- it's fast, because we don't have to determine how many
2743         terms we need to calculate in advance.
2744 
2745         Disadvantage -- you may end up with less terms than you may have
2746         expected, but the O(x**n) term appended will always be correct and
2747         so the result, though perhaps shorter, will also be correct.
2748 
2749         If any of those assumptions is not met, this is treated like a
2750         wrapper to series which will try harder to return the correct
2751         number of terms.
2752 
2753         See also lseries().
2754 
2755         Examples
2756         ========
2757 
2758         >>> from sympy import sin, log, Symbol
2759         >>> from sympy.abc import x, y
2760         >>> sin(x).nseries(x, 0, 6)
2761         x - x**3/6 + x**5/120 + O(x**6)
2762         >>> log(x+1).nseries(x, 0, 5)
2763         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2764 
2765         Handling of the ``logx`` parameter --- in the following example the
2766         expansion fails since ``sin`` does not have an asymptotic expansion
2767         at -oo (the limit of log(x) as x approaches 0):
2768 
2769         >>> e = sin(log(x))
2770         >>> e.nseries(x, 0, 6)
2771         Traceback (most recent call last):
2772         ...
2773         PoleError: ...
2774         ...
2775         >>> logx = Symbol('logx')
2776         >>> e.nseries(x, 0, 6, logx=logx)
2777         sin(logx)
2778 
2779         In the following example, the expansion works but gives only an Order term
2780         unless the ``logx`` parameter is used:
2781 
2782         >>> e = x**y
2783         >>> e.nseries(x, 0, 2)
2784         O(log(x)**2)
2785         >>> e.nseries(x, 0, 2, logx=logx)
2786         exp(logx*y)
2787 
2788         """
2789         if x and not x in self.free_symbols:
2790             return self
2791         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2792             return self.series(x, x0, n, dir)
2793         else:
2794             return self._eval_nseries(x, n=n, logx=logx)
2795 
2796     def _eval_nseries(self, x, n, logx):
2797         """
2798         Return terms of series for self up to O(x**n) at x=0
2799         from the positive direction.
2800 
2801         This is a method that should be overridden in subclasses. Users should
2802         never call this method directly (use .nseries() instead), so you don't
2803         have to write docstrings for _eval_nseries().
2804         """
2805         from sympy.utilities.misc import filldedent
2806         raise NotImplementedError(filldedent("""
2807                      The _eval_nseries method should be added to
2808                      %s to give terms up to O(x**n) at x=0
2809                      from the positive direction so it is available when
2810                      nseries calls it.""" % self.func)
2811                      )
2812 
2813     def limit(self, x, xlim, dir='+'):
2814         """ Compute limit x->xlim.
2815         """
2816         from sympy.series.limits import limit
2817         return limit(self, x, xlim, dir)
2818 
2819     def compute_leading_term(self, x, logx=None):
2820         """
2821         as_leading_term is only allowed for results of .series()
2822         This is a wrapper to compute a series first.
2823         """
2824         from sympy import Dummy, log
2825         from sympy.series.gruntz import calculate_series
2826 
2827         if self.removeO() == 0:
2828             return self
2829 
2830         if logx is None:
2831             d = Dummy('logx')
2832             s = calculate_series(self, x, d).subs(d, log(x))
2833         else:
2834             s = calculate_series(self, x, logx)
2835 
2836         return s.as_leading_term(x)
2837 
2838     @cacheit
2839     def as_leading_term(self, *symbols):
2840         """
2841         Returns the leading (nonzero) term of the series expansion of self.
2842 
2843         The _eval_as_leading_term routines are used to do this, and they must
2844         always return a non-zero value.
2845 
2846         Examples
2847         ========
2848 
2849         >>> from sympy.abc import x
2850         >>> (1 + x + x**2).as_leading_term(x)
2851         1
2852         >>> (1/x**2 + x + x**2).as_leading_term(x)
2853         x**(-2)
2854 
2855         """
2856         from sympy import powsimp
2857         if len(symbols) > 1:
2858             c = self
2859             for x in symbols:
2860                 c = c.as_leading_term(x)
2861             return c
2862         elif not symbols:
2863             return self
2864         x = sympify(symbols[0])
2865         if not x.is_Symbol:
2866             raise ValueError('expecting a Symbol but got %s' % x)
2867         if x not in self.free_symbols:
2868             return self
2869         obj = self._eval_as_leading_term(x)
2870         if obj is not None:
2871             return powsimp(obj, deep=True, combine='exp')
2872         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
2873 
2874     def _eval_as_leading_term(self, x):
2875         return self
2876 
2877     def as_coeff_exponent(self, x):
2878         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
2879         """
2880         from sympy import collect
2881         s = collect(self, x)
2882         c, p = s.as_coeff_mul(x)
2883         if len(p) == 1:
2884             b, e = p[0].as_base_exp()
2885             if b == x:
2886                 return c, e
2887         return s, S.Zero
2888 
2889     def leadterm(self, x):
2890         """
2891         Returns the leading term a*x**b as a tuple (a, b).
2892 
2893         Examples
2894         ========
2895 
2896         >>> from sympy.abc import x
2897         >>> (1+x+x**2).leadterm(x)
2898         (1, 0)
2899         >>> (1/x**2+x+x**2).leadterm(x)
2900         (1, -2)
2901 
2902         """
2903         from sympy import Dummy, log
2904         l = self.as_leading_term(x)
2905         d = Dummy('logx')
2906         if l.has(log(x)):
2907             l = l.subs(log(x), d)
2908         c, e = l.as_coeff_exponent(x)
2909         if x in c.free_symbols:
2910             from sympy.utilities.misc import filldedent
2911             raise ValueError(filldedent("""
2912                 cannot compute leadterm(%s, %s). The coefficient
2913                 should have been free of x but got %s""" % (self, x, c)))
2914         c = c.subs(d, log(x))
2915         return c, e
2916 
2917     def as_coeff_Mul(self, rational=False):
2918         """Efficiently extract the coefficient of a product. """
2919         return S.One, self
2920 
2921     def as_coeff_Add(self, rational=False):
2922         """Efficiently extract the coefficient of a summation. """
2923         return S.Zero, self
2924 
2925     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
2926             full=False):
2927         """
2928         Compute formal power power series of self.
2929 
2930         See the docstring of the :func:`fps` function in sympy.series.formal for
2931         more information.
2932         """
2933         from sympy.series.formal import fps
2934 
2935         return fps(self, x, x0, dir, hyper, order, rational, full)
2936 
2937     def fourier_series(self, limits=None):
2938         """Compute fourier sine/cosine series of self.
2939 
2940         See the docstring of the :func:`fourier_series` in sympy.series.fourier
2941         for more information.
2942         """
2943         from sympy.series.fourier import fourier_series
2944 
2945         return fourier_series(self, limits)
2946 
2947     ###################################################################################
2948     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
2949     ###################################################################################
2950 
2951     def diff(self, *symbols, **assumptions):
2952         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z
2953         assumptions.setdefault("evaluate", True)
2954         return Derivative(self, *new_symbols, **assumptions)
2955 
2956     ###########################################################################
2957     ###################### EXPRESSION EXPANSION METHODS #######################
2958     ###########################################################################
2959 
2960     # Relevant subclasses should override _eval_expand_hint() methods.  See
2961     # the docstring of expand() for more info.
2962 
2963     def _eval_expand_complex(self, **hints):
2964         real, imag = self.as_real_imag(**hints)
2965         return real + S.ImaginaryUnit*imag
2966 
2967     @staticmethod
2968     def _expand_hint(expr, hint, deep=True, **hints):
2969         """
2970         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
2971 
2972         Returns ``(expr, hit)``, where expr is the (possibly) expanded
2973         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
2974         ``False`` otherwise.
2975         """
2976         hit = False
2977         # XXX: Hack to support non-Basic args
2978         #              |
2979         #              V
2980         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
2981             sargs = []
2982             for arg in expr.args:
2983                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
2984                 hit |= arghit
2985                 sargs.append(arg)
2986 
2987             if hit:
2988                 expr = expr.func(*sargs)
2989 
2990         if hasattr(expr, hint):
2991             newexpr = getattr(expr, hint)(**hints)
2992             if newexpr != expr:
2993                 return (newexpr, True)
2994 
2995         return (expr, hit)
2996 
2997     @cacheit
2998     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
2999             mul=True, log=True, multinomial=True, basic=True, **hints):
3000         """
3001         Expand an expression using hints.
3002 
3003         See the docstring of the expand() function in sympy.core.function for
3004         more information.
3005 
3006         """
3007         from sympy.simplify.radsimp import fraction
3008 
3009         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3010            log=log, multinomial=multinomial, basic=basic)
3011 
3012         expr = self
3013         if hints.pop('frac', False):
3014             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3015                     for a in fraction(self)]
3016             return n/d
3017         elif hints.pop('denom', False):
3018             n, d = fraction(self)
3019             return n/d.expand(deep=deep, modulus=modulus, **hints)
3020         elif hints.pop('numer', False):
3021             n, d = fraction(self)
3022             return n.expand(deep=deep, modulus=modulus, **hints)/d
3023 
3024         # Although the hints are sorted here, an earlier hint may get applied
3025         # at a given node in the expression tree before another because of how
3026         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3027         # x*z) because while applying log at the top level, log and mul are
3028         # applied at the deeper level in the tree so that when the log at the
3029         # upper level gets applied, the mul has already been applied at the
3030         # lower level.
3031 
3032         # Additionally, because hints are only applied once, the expression
3033         # may not be expanded all the way.   For example, if mul is applied
3034         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3035         # now, we just use a special case to make multinomial run before mul,
3036         # so that at least polynomials will be expanded all the way.  In the
3037         # future, smarter heuristics should be applied.
3038         # TODO: Smarter heuristics
3039 
3040         def _expand_hint_key(hint):
3041             """Make multinomial come before mul"""
3042             if hint == 'mul':
3043                 return 'mulz'
3044             return hint
3045 
3046         for hint in sorted(hints.keys(), key=_expand_hint_key):
3047             use_hint = hints[hint]
3048             if use_hint:
3049                 hint = '_eval_expand_' + hint
3050                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3051 
3052         while True:
3053             was = expr
3054             if hints.get('multinomial', False):
3055                 expr, _ = Expr._expand_hint(
3056                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3057             if hints.get('mul', False):
3058                 expr, _ = Expr._expand_hint(
3059                     expr, '_eval_expand_mul', deep=deep, **hints)
3060             if hints.get('log', False):
3061                 expr, _ = Expr._expand_hint(
3062                     expr, '_eval_expand_log', deep=deep, **hints)
3063             if expr == was:
3064                 break
3065 
3066         if modulus is not None:
3067             modulus = sympify(modulus)
3068 
3069             if not modulus.is_Integer or modulus <= 0:
3070                 raise ValueError(
3071                     "modulus must be a positive integer, got %s" % modulus)
3072 
3073             terms = []
3074 
3075             for term in Add.make_args(expr):
3076                 coeff, tail = term.as_coeff_Mul(rational=True)
3077 
3078                 coeff %= modulus
3079 
3080                 if coeff:
3081                     terms.append(coeff*tail)
3082 
3083             expr = Add(*terms)
3084 
3085         return expr
3086 
3087     ###########################################################################
3088     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3089     ###########################################################################
3090 
3091     def integrate(self, *args, **kwargs):
3092         """See the integrate function in sympy.integrals"""
3093         from sympy.integrals import integrate
3094         return integrate(self, *args, **kwargs)
3095 
3096     def simplify(self, ratio=1.7, measure=None):
3097         """See the simplify function in sympy.simplify"""
3098         from sympy.simplify import simplify
3099         from sympy.core.function import count_ops
3100         measure = measure or count_ops
3101         return simplify(self, ratio, measure)
3102 
3103     def nsimplify(self, constants=[], tolerance=None, full=False):
3104         """See the nsimplify function in sympy.simplify"""
3105         from sympy.simplify import nsimplify
3106         return nsimplify(self, constants, tolerance, full)
3107 
3108     def separate(self, deep=False, force=False):
3109         """See the separate function in sympy.simplify"""
3110         from sympy.core.function import expand_power_base
3111         return expand_power_base(self, deep=deep, force=force)
3112 
3113     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3114         """See the collect function in sympy.simplify"""
3115         from sympy.simplify import collect
3116         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3117 
3118     def together(self, *args, **kwargs):
3119         """See the together function in sympy.polys"""
3120         from sympy.polys import together
3121         return together(self, *args, **kwargs)
3122 
3123     def apart(self, x=None, **args):
3124         """See the apart function in sympy.polys"""
3125         from sympy.polys import apart
3126         return apart(self, x, **args)
3127 
3128     def ratsimp(self):
3129         """See the ratsimp function in sympy.simplify"""
3130         from sympy.simplify import ratsimp
3131         return ratsimp(self)
3132 
3133     def trigsimp(self, **args):
3134         """See the trigsimp function in sympy.simplify"""
3135         from sympy.simplify import trigsimp
3136         return trigsimp(self, **args)
3137 
3138     def radsimp(self, **kwargs):
3139         """See the radsimp function in sympy.simplify"""
3140         from sympy.simplify import radsimp
3141         return radsimp(self, **kwargs)
3142 
3143     def powsimp(self, *args, **kwargs):
3144         """See the powsimp function in sympy.simplify"""
3145         from sympy.simplify import powsimp
3146         return powsimp(self, *args, **kwargs)
3147 
3148     def combsimp(self):
3149         """See the combsimp function in sympy.simplify"""
3150         from sympy.simplify import combsimp
3151         return combsimp(self)
3152 
3153     def gammasimp(self):
3154         """See the gammasimp function in sympy.simplify"""
3155         from sympy.simplify import gammasimp
3156         return gammasimp(self)
3157 
3158     def factor(self, *gens, **args):
3159         """See the factor() function in sympy.polys.polytools"""
3160         from sympy.polys import factor
3161         return factor(self, *gens, **args)
3162 
3163     def refine(self, assumption=True):
3164         """See the refine function in sympy.assumptions"""
3165         from sympy.assumptions import refine
3166         return refine(self, assumption)
3167 
3168     def cancel(self, *gens, **args):
3169         """See the cancel function in sympy.polys"""
3170         from sympy.polys import cancel
3171         return cancel(self, *gens, **args)
3172 
3173     def invert(self, g, *gens, **args):
3174         """Return the multiplicative inverse of ``self`` mod ``g``
3175         where ``self`` (and ``g``) may be symbolic expressions).
3176 
3177         See Also
3178         ========
3179         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3180         """
3181         from sympy.polys.polytools import invert
3182         from sympy.core.numbers import mod_inverse
3183         if self.is_number and getattr(g, 'is_number', True):
3184             return mod_inverse(self, g)
3185         return invert(self, g, *gens, **args)
3186 
3187     def round(self, p=0):
3188         """Return x rounded to the given decimal place.
3189 
3190         If a complex number would results, apply round to the real
3191         and imaginary components of the number.
3192 
3193         Examples
3194         ========
3195 
3196         >>> from sympy import pi, E, I, S, Add, Mul, Number
3197         >>> S(10.5).round()
3198         11.
3199         >>> pi.round()
3200         3.
3201         >>> pi.round(2)
3202         3.14
3203         >>> (2*pi + E*I).round()
3204         6. + 3.*I
3205 
3206         The round method has a chopping effect:
3207 
3208         >>> (2*pi + I/10).round()
3209         6.
3210         >>> (pi/10 + 2*I).round()
3211         2.*I
3212         >>> (pi/10 + E*I).round(2)
3213         0.31 + 2.72*I
3214 
3215         Notes
3216         =====
3217 
3218         Do not confuse the Python builtin function, round, with the
3219         SymPy method of the same name. The former always returns a float
3220         (or raises an error if applied to a complex value) while the
3221         latter returns either a Number or a complex number:
3222 
3223         >>> isinstance(round(S(123), -2), Number)
3224         False
3225         >>> isinstance(S(123).round(-2), Number)
3226         True
3227         >>> isinstance((3*I).round(), Mul)
3228         True
3229         >>> isinstance((1 + 3*I).round(), Add)
3230         True
3231 
3232         """
3233         from sympy import Float
3234         x = self
3235         if not x.is_number:
3236             raise TypeError("can't round symbolic expression")
3237         if not x.is_Atom:
3238             xn = x.n(2)
3239             if not pure_complex(xn, or_real=True):
3240                 raise TypeError('Expected a number but got %s:' %
3241                     getattr(getattr(x,'func', x), '__name__', type(x)))
3242         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3243             return x
3244         if not x.is_real:
3245             i, r = x.as_real_imag()
3246             return i.round(p) + S.ImaginaryUnit*r.round(p)
3247         if not x:
3248             return x
3249         p = int(p)
3250 
3251         precs = [f._prec for f in x.atoms(Float)]
3252         dps = prec_to_dps(max(precs)) if precs else None
3253 
3254         mag_first_dig = _mag(x)
3255         allow = digits_needed = mag_first_dig + p
3256         if dps is not None and allow > dps:
3257             allow = dps
3258         mag = Pow(10, p)  # magnitude needed to bring digit p to units place
3259         xwas = x
3260         x += 1/(2*mag)  # add the half for rounding
3261         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3262         if i10.is_negative:
3263             x = xwas - 1/(2*mag)  # should have gone the other way
3264             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3265             rv = -(Integer(-i10)//10)
3266         else:
3267             rv = Integer(i10)//10
3268         q = 1
3269         if p > 0:
3270             q = mag
3271         elif p < 0:
3272             rv /= mag
3273         rv = Rational(rv, q)
3274         if rv.is_Integer:
3275             # use str or else it won't be a float
3276             return Float(str(rv), digits_needed)
3277         else:
3278             if not allow and rv > self:
3279                 allow += 1
3280             return Float(rv, allow)
3281 
3282 
3283 class AtomicExpr(Atom, Expr):
3284     """
3285     A parent class for object which are both atoms and Exprs.
3286 
3287     For example: Symbol, Number, Rational, Integer, ...
3288     But not: Add, Mul, Pow, ...
3289     """
3290     is_number = False
3291     is_Atom = True
3292 
3293     __slots__ = []
3294 
3295     def _eval_derivative(self, s):
3296         if self == s:
3297             return S.One
3298         return S.Zero
3299 
3300     def _eval_is_polynomial(self, syms):
3301         return True
3302 
3303     def _eval_is_rational_function(self, syms):
3304         return True
3305 
3306     def _eval_is_algebraic_expr(self, syms):
3307         return True
3308 
3309     def _eval_nseries(self, x, n, logx):
3310         return self
3311 
3312 
3313 def _mag(x):
3314     """Return integer ``i`` such that .1 <= x/10**i < 1
3315 
3316     Examples
3317     ========
3318 
3319     >>> from sympy.core.expr import _mag
3320     >>> from sympy import Float
3321     >>> _mag(Float(.1))
3322     0
3323     >>> _mag(Float(.01))
3324     -1
3325     >>> _mag(Float(1234))
3326     4
3327     """
3328     from math import log10, ceil, log
3329     from sympy import Float
3330     xpos = abs(x.n())
3331     if not xpos:
3332         return S.Zero
3333     try:
3334         mag_first_dig = int(ceil(log10(xpos)))
3335     except (ValueError, OverflowError):
3336         mag_first_dig = int(ceil(Float(mpf_log(xpos._mpf_, 53))/log(10)))
3337     # check that we aren't off by 1
3338     if (xpos/10**mag_first_dig) >= 1:
3339         assert 1 <= (xpos/10**mag_first_dig) < 10
3340         mag_first_dig += 1
3341     return mag_first_dig
3342 
3343 
3344 class UnevaluatedExpr(Expr):
3345     """
3346     Expression that is not evaluated unless released.
3347 
3348     Examples
3349     ========
3350 
3351     >>> from sympy import UnevaluatedExpr
3352     >>> from sympy.abc import a, b, x, y
3353     >>> x*(1/x)
3354     1
3355     >>> x*UnevaluatedExpr(1/x)
3356     x*1/x
3357 
3358     """
3359 
3360     def __new__(cls, arg, **kwargs):
3361         arg = _sympify(arg)
3362         obj = Expr.__new__(cls, arg, **kwargs)
3363         return obj
3364 
3365     def doit(self, *args, **kwargs):
3366         if kwargs.get("deep", True):
3367             return self.args[0].doit(*args, **kwargs)
3368         else:
3369             return self.args[0]
3370 
3371 
3372 def _n2(a, b):
3373     """Return (a - b).evalf(2) if it, a and b are comparable, else None.
3374     This should only be used when a and b are already sympified.
3375     """
3376     if not all(i.is_number for i in (a, b)):
3377         return
3378     # /!\ if is very important (see issue 8245) not to
3379     # use a re-evaluated number in the calculation of dif
3380     if a.is_comparable and b.is_comparable:
3381         dif = (a - b).evalf(2)
3382         if dif.is_comparable:
3383             return dif
3384 
3385 
3386 from .mul import Mul
3387 from .add import Add
3388 from .power import Pow
3389 from .function import Derivative, Function
3390 from .mod import Mod
3391 from .exprtools import factor_terms
3392 from .numbers import Integer, Rational

</code><intended_behavior>Ensure that the expression handling and manipulation logic properly recognizes and preserves the subtleties of trigonometric functions with complex arguments during simplification.</intended_behavior>]
2025-10-18 19:27:54.493 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 19:27:54.493 | INFO     | Search-only: skipping patch selection
2025-10-18 19:27:54.606 | INFO     | Task sympy__sympy-13259 completed successfully.
2025-10-18 19:27:54.607 | INFO     | No patch generated. You can try running ACR again.
