2025-10-18 21:13:45.995 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 21:13:53.164 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=546, output_tokens=12, cost=0.005820
2025-10-18 21:14:04.286 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=726, output_tokens=525, cost=0.023010
2025-10-18 21:14:05.924 | INFO     | registered non reproducing test 0
2025-10-18 21:14:19.202 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1673, output_tokens=597, cost=0.034640
2025-10-18 21:14:20.767 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:14:27.260 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=827, output_tokens=295, cost=0.017120
2025-10-18 21:14:27.267 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:14:29.842 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=649, output_tokens=49, cost=0.007960
2025-10-18 21:14:29.843 | DEBUG    | Extracted a valid json.
2025-10-18 21:14:29.844 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"MatrixNormal\")", "search_method_in_class(\"density\", \"MatrixNormal\")", "search_method_in_class(\"__init__\", \"MatrixNormal\")"],
    "bug_locations": []
}
2025-10-18 21:14:29.849 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 21:14:29.850 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 21:14:39.433 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1304, output_tokens=381, cost=0.024470
2025-10-18 21:14:39.442 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:14:40.645 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1901, output_tokens=24, cost=0.019730
2025-10-18 21:14:40.652 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:14:43.984 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=378, output_tokens=29, cost=0.004650
2025-10-18 21:14:43.985 | DEBUG    | Extracted a valid json.
2025-10-18 21:14:43.985 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"density\")", "search_code(\"probability density function\")"],
    "bug_locations": []
}
2025-10-18 21:14:44.055 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 21:14:44.055 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 21:14:58.276 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2360, output_tokens=554, cost=0.040220
2025-10-18 21:14:58.288 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:14:59.701 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3130, output_tokens=27, cost=0.032110
2025-10-18 21:14:59.704 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:15:01.608 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=381, output_tokens=33, cost=0.004800
2025-10-18 21:15:01.609 | DEBUG    | Extracted a valid json.
2025-10-18 21:15:01.609 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code_in_file(\"MatrixNormal\", \"sympy/stats/random_matrix_models.py\")"],
    "bug_locations": []
}
2025-10-18 21:15:01.613 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 21:15:01.614 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 21:15:14.755 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3305, output_tokens=497, cost=0.047960
2025-10-18 21:15:14.767 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:15:25.388 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4018, output_tokens=364, cost=0.051100
2025-10-18 21:15:25.395 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:15:31.529 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=160, cost=0.011980
2025-10-18 21:15:31.530 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-18 21:15:31.530 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 21:15:32.529 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=14, cost=0.007600
2025-10-18 21:15:32.530 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:32.531 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 21:15:34.098 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=14, cost=0.007600
2025-10-18 21:15:34.099 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:34.100 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 21:15:35.404 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=14, cost=0.007600
2025-10-18 21:15:35.405 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:35.406 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 21:15:36.975 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=14, cost=0.007600
2025-10-18 21:15:36.976 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:36.976 | DEBUG    | Agent proxy return the following json: None
2025-10-18 21:15:36.977 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 21:15:36.978 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 21:15:36.978 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:15:43.121 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4409, output_tokens=212, cost=0.050450
2025-10-18 21:15:43.126 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:15:44.326 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=566, output_tokens=14, cost=0.006080
2025-10-18 21:15:44.327 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:44.327 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 21:15:46.666 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=566, output_tokens=14, cost=0.006080
2025-10-18 21:15:46.667 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:46.667 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 21:15:49.735 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=566, output_tokens=14, cost=0.006080
2025-10-18 21:15:49.736 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:49.736 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 21:15:50.819 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=566, output_tokens=14, cost=0.006080
2025-10-18 21:15:50.820 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:50.820 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 21:15:53.866 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=566, output_tokens=14, cost=0.006080
2025-10-18 21:15:53.867 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:15:53.868 | DEBUG    | Agent proxy return the following json: None
2025-10-18 21:15:53.868 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 21:15:53.869 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 21:15:53.869 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:16:02.960 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4648, output_tokens=353, cost=0.057070
2025-10-18 21:16:02.965 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:16:04.500 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=14, cost=0.007490
2025-10-18 21:16:04.501 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:16:04.501 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 21:16:06.484 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=14, cost=0.007490
2025-10-18 21:16:06.485 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:16:06.486 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 21:16:07.645 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=14, cost=0.007490
2025-10-18 21:16:07.646 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:16:07.646 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 21:16:08.672 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=14, cost=0.007490
2025-10-18 21:16:08.673 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:16:08.679 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 21:16:10.496 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=14, cost=0.007490
2025-10-18 21:16:10.497 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 21:16:10.497 | DEBUG    | Agent proxy return the following json: None
2025-10-18 21:16:10.498 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 21:16:10.499 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 21:16:10.499 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:16:17.680 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5028, output_tokens=253, cost=0.057870
2025-10-18 21:16:17.685 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:16:19.321 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=607, output_tokens=34, cost=0.007090
2025-10-18 21:16:19.322 | DEBUG    | Extracted a valid json.
2025-10-18 21:16:19.322 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MatrixDistribution\")",
        "search_code(\"MatrixNormal\")"
    ],
    "bug_locations": []
}
2025-10-18 21:16:19.400 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 21:16:19.400 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 21:16:36.236 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5576, output_tokens=634, cost=0.074780
2025-10-18 21:16:36.249 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 21:16:47.224 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6426, output_tokens=399, cost=0.076230
2025-10-18 21:16:47.232 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 21:16:56.047 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=293, cost=0.016320
2025-10-18 21:16:56.048 | DEBUG    | Extracted a valid json.
2025-10-18 21:16:56.048 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/stats/matrix_distributions.py",
            "class": "MatrixNormal",
            "method": "",
            "intended_behavior": "The method in the `MatrixNormal` class that calculates the PDF should be corrected to ensure that the constant term in the formula aligns with the mathematical standard for the Matrix Normal Distribution. Specifically, the corrected implementation should ensure that the constant term is calculated as per the formula given in the issue description, which is `\\frac{1}{(2\\pi)^{nk/2}}` for a matrix of dimension `n x k`, rather than any incorrect variation of this term. This includes careful handling of the determinant of the covariance matrix in the denominator and the trace operation in the exponent of the e-function within the PDF formula. The correction should be applied in a way that does not negatively impact other functionalities provided by the `MatrixNormal` class, ensuring that the class remains fully functional for other uses, such as sampling and parameter checks. This means preserving the overall structure and logic of the PDF computation while adjusting the specific part of the formula that is incorrect. In addition to the PDF formula correction, tests or validations should be reviewed or added to confirm that the PDF calculation now matches the expected mathematical definition, thus ensuring the bug is resolved and similar issues are prevented in the future."
        }
    ]
}
2025-10-18 21:16:56.054 | DEBUG    | Bug location extracted successfully: [<file>sympy/stats/matrix_distributions.py</file>
<class>None</class>
<method>None</method>
<code>
1 from math import prod
2 
3 from sympy.core.basic import Basic
4 from sympy.core.numbers import pi
5 from sympy.core.singleton import S
6 from sympy.functions.elementary.exponential import exp
7 from sympy.functions.special.gamma_functions import multigamma
8 from sympy.core.sympify import sympify, _sympify
9 from sympy.matrices import (ImmutableMatrix, Inverse, Trace, Determinant,
10                             MatrixSymbol, MatrixBase, Transpose, MatrixSet,
11                             matrix2numpy)
12 from sympy.stats.rv import (_value_check, RandomMatrixSymbol, NamedArgsMixin, PSpace,
13                             _symbol_converter, MatrixDomain, Distribution)
14 from sympy.external import import_module
15 
16 
17 ################################################################################
18 #------------------------Matrix Probability Space------------------------------#
19 ################################################################################
20 class MatrixPSpace(PSpace):
21     """
22     Represents probability space for
23     Matrix Distributions.
24     """
25     def __new__(cls, sym, distribution, dim_n, dim_m):
26         sym = _symbol_converter(sym)
27         dim_n, dim_m = _sympify(dim_n), _sympify(dim_m)
28         if not (dim_n.is_integer and dim_m.is_integer):
29             raise ValueError("Dimensions should be integers")
30         return Basic.__new__(cls, sym, distribution, dim_n, dim_m)
31 
32     distribution = property(lambda self: self.args[1])
33     symbol = property(lambda self: self.args[0])
34 
35     @property
36     def domain(self):
37         return MatrixDomain(self.symbol, self.distribution.set)
38 
39     @property
40     def value(self):
41         return RandomMatrixSymbol(self.symbol, self.args[2], self.args[3], self)
42 
43     @property
44     def values(self):
45         return {self.value}
46 
47     def compute_density(self, expr, *args):
48         rms = expr.atoms(RandomMatrixSymbol)
49         if len(rms) > 1 or (not isinstance(expr, RandomMatrixSymbol)):
50             raise NotImplementedError("Currently, no algorithm has been "
51                     "implemented to handle general expressions containing "
52                     "multiple matrix distributions.")
53         return self.distribution.pdf(expr)
54 
55     def sample(self, size=(), library='scipy', seed=None):
56         """
57         Internal sample method
58 
59         Returns dictionary mapping RandomMatrixSymbol to realization value.
60         """
61         return {self.value: self.distribution.sample(size, library=library, seed=seed)}
62 
63 
64 def rv(symbol, cls, args):
65     args = list(map(sympify, args))
66     dist = cls(*args)
67     dist.check(*args)
68     dim = dist.dimension
69     pspace = MatrixPSpace(symbol, dist, dim[0], dim[1])
70     return pspace.value
71 
72 
73 class SampleMatrixScipy:
74     """Returns the sample from scipy of the given distribution"""
75     def __new__(cls, dist, size, seed=None):
76         return cls._sample_scipy(dist, size, seed)
77 
78     @classmethod
79     def _sample_scipy(cls, dist, size, seed):
80         """Sample from SciPy."""
81 
82         from scipy import stats as scipy_stats
83         import numpy
84         scipy_rv_map = {
85             'WishartDistribution': lambda dist, size, rand_state: scipy_stats.wishart.rvs(
86                 df=int(dist.n), scale=matrix2numpy(dist.scale_matrix, float), size=size),
87             'MatrixNormalDistribution': lambda dist, size, rand_state: scipy_stats.matrix_normal.rvs(
88                 mean=matrix2numpy(dist.location_matrix, float),
89                 rowcov=matrix2numpy(dist.scale_matrix_1, float),
90                 colcov=matrix2numpy(dist.scale_matrix_2, float), size=size, random_state=rand_state)
91         }
92 
93         sample_shape = {
94             'WishartDistribution': lambda dist: dist.scale_matrix.shape,
95             'MatrixNormalDistribution' : lambda dist: dist.location_matrix.shape
96         }
97 
98         dist_list = scipy_rv_map.keys()
99 
100         if dist.__class__.__name__ not in dist_list:
101             return None
102 
103         if seed is None or isinstance(seed, int):
104             rand_state = numpy.random.default_rng(seed=seed)
105         else:
106             rand_state = seed
107         samp = scipy_rv_map[dist.__class__.__name__](dist, prod(size), rand_state)
108         return samp.reshape(size + sample_shape[dist.__class__.__name__](dist))
109 
110 
111 class SampleMatrixNumpy:
112     """Returns the sample from numpy of the given distribution"""
113 
114     ### TODO: Add tests after adding matrix distributions in numpy_rv_map
115     def __new__(cls, dist, size, seed=None):
116         return cls._sample_numpy(dist, size, seed)
117 
118     @classmethod
119     def _sample_numpy(cls, dist, size, seed):
120         """Sample from NumPy."""
121 
122         numpy_rv_map = {
123         }
124 
125         sample_shape = {
126         }
127 
128         dist_list = numpy_rv_map.keys()
129 
130         if dist.__class__.__name__ not in dist_list:
131             return None
132 
133         import numpy
134         if seed is None or isinstance(seed, int):
135             rand_state = numpy.random.default_rng(seed=seed)
136         else:
137             rand_state = seed
138         samp = numpy_rv_map[dist.__class__.__name__](dist, prod(size), rand_state)
139         return samp.reshape(size + sample_shape[dist.__class__.__name__](dist))
140 
141 
142 class SampleMatrixPymc:
143     """Returns the sample from pymc of the given distribution"""
144 
145     def __new__(cls, dist, size, seed=None):
146         return cls._sample_pymc(dist, size, seed)
147 
148     @classmethod
149     def _sample_pymc(cls, dist, size, seed):
150         """Sample from PyMC."""
151 
152         try:
153             import pymc
154         except ImportError:
155             import pymc3 as pymc
156         pymc_rv_map = {
157             'MatrixNormalDistribution': lambda dist: pymc.MatrixNormal('X',
158                 mu=matrix2numpy(dist.location_matrix, float),
159                 rowcov=matrix2numpy(dist.scale_matrix_1, float),
160                 colcov=matrix2numpy(dist.scale_matrix_2, float),
161                 shape=dist.location_matrix.shape),
162             'WishartDistribution': lambda dist: pymc.WishartBartlett('X',
163                 nu=int(dist.n), S=matrix2numpy(dist.scale_matrix, float))
164         }
165 
166         sample_shape = {
167             'WishartDistribution': lambda dist: dist.scale_matrix.shape,
168             'MatrixNormalDistribution' : lambda dist: dist.location_matrix.shape
169         }
170 
171         dist_list = pymc_rv_map.keys()
172 
173         if dist.__class__.__name__ not in dist_list:
174             return None
175         import logging
176         logging.getLogger("pymc").setLevel(logging.ERROR)
177         with pymc.Model():
178             pymc_rv_map[dist.__class__.__name__](dist)
179             samps = pymc.sample(draws=prod(size), chains=1, progressbar=False, random_seed=seed, return_inferencedata=False, compute_convergence_checks=False)['X']
180         return samps.reshape(size + sample_shape[dist.__class__.__name__](dist))
181 
182 _get_sample_class_matrixrv = {
183     'scipy': SampleMatrixScipy,
184     'pymc3': SampleMatrixPymc,
185     'pymc': SampleMatrixPymc,
186     'numpy': SampleMatrixNumpy
187 }
188 
189 ################################################################################
190 #-------------------------Matrix Distribution----------------------------------#
191 ################################################################################
192 
193 class MatrixDistribution(Distribution, NamedArgsMixin):
194     """
195     Abstract class for Matrix Distribution.
196     """
197     def __new__(cls, *args):
198         args = [ImmutableMatrix(arg) if isinstance(arg, list)
199                 else _sympify(arg) for arg in args]
200         return Basic.__new__(cls, *args)
201 
202     @staticmethod
203     def check(*args):
204         pass
205 
206     def __call__(self, expr):
207         if isinstance(expr, list):
208             expr = ImmutableMatrix(expr)
209         return self.pdf(expr)
210 
211     def sample(self, size=(), library='scipy', seed=None):
212         """
213         Internal sample method
214 
215         Returns dictionary mapping RandomSymbol to realization value.
216         """
217 
218         libraries = ['scipy', 'numpy', 'pymc3', 'pymc']
219         if library not in libraries:
220             raise NotImplementedError("Sampling from %s is not supported yet."
221                                         % str(library))
222         if not import_module(library):
223             raise ValueError("Failed to import %s" % library)
224 
225         samps = _get_sample_class_matrixrv[library](self, size, seed)
226 
227         if samps is not None:
228             return samps
229         raise NotImplementedError(
230                 "Sampling for %s is not currently implemented from %s"
231                 % (self.__class__.__name__, library)
232                 )
233 
234 ################################################################################
235 #------------------------Matrix Distribution Types-----------------------------#
236 ################################################################################
237 
238 #-------------------------------------------------------------------------------
239 # Matrix Gamma distribution ----------------------------------------------------
240 
241 class MatrixGammaDistribution(MatrixDistribution):
242 
243     _argnames = ('alpha', 'beta', 'scale_matrix')
244 
245     @staticmethod
246     def check(alpha, beta, scale_matrix):
247         if not isinstance(scale_matrix, MatrixSymbol):
248             _value_check(scale_matrix.is_positive_definite, "The shape "
249                 "matrix must be positive definite.")
250         _value_check(scale_matrix.is_square, "Should "
251         "be square matrix")
252         _value_check(alpha.is_positive, "Shape parameter should be positive.")
253         _value_check(beta.is_positive, "Scale parameter should be positive.")
254 
255     @property
256     def set(self):
257         k = self.scale_matrix.shape[0]
258         return MatrixSet(k, k, S.Reals)
259 
260     @property
261     def dimension(self):
262         return self.scale_matrix.shape
263 
264     def pdf(self, x):
265         alpha, beta, scale_matrix = self.alpha, self.beta, self.scale_matrix
266         p = scale_matrix.shape[0]
267         if isinstance(x, list):
268             x = ImmutableMatrix(x)
269         if not isinstance(x, (MatrixBase, MatrixSymbol)):
270             raise ValueError("%s should be an isinstance of Matrix "
271                     "or MatrixSymbol" % str(x))
272         sigma_inv_x = - Inverse(scale_matrix)*x / beta
273         term1 = exp(Trace(sigma_inv_x))/((beta**(p*alpha)) * multigamma(alpha, p))
274         term2 = (Determinant(scale_matrix))**(-alpha)
275         term3 = (Determinant(x))**(alpha - S(p + 1)/2)
276         return term1 * term2 * term3
277 
278 def MatrixGamma(symbol, alpha, beta, scale_matrix):
279     """
280     Creates a random variable with Matrix Gamma Distribution.
281 
282     The density of the said distribution can be found at [1].
283 
284     Parameters
285     ==========
286 
287     alpha: Positive Real number
288         Shape Parameter
289     beta: Positive Real number
290         Scale Parameter
291     scale_matrix: Positive definite real square matrix
292         Scale Matrix
293 
294     Returns
295     =======
296 
297     RandomSymbol
298 
299     Examples
300     ========
301 
302     >>> from sympy.stats import density, MatrixGamma
303     >>> from sympy import MatrixSymbol, symbols
304     >>> a, b = symbols('a b', positive=True)
305     >>> M = MatrixGamma('M', a, b, [[2, 1], [1, 2]])
306     >>> X = MatrixSymbol('X', 2, 2)
307     >>> density(M)(X).doit()
308     exp(Trace(Matrix([
309     [-2/3,  1/3],
310     [ 1/3, -2/3]])*X)/b)*Determinant(X)**(a - 3/2)/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))
311     >>> density(M)([[1, 0], [0, 1]]).doit()
312     exp(-4/(3*b))/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))
313 
314 
315     References
316     ==========
317 
318     .. [1] https://en.wikipedia.org/wiki/Matrix_gamma_distribution
319 
320     """
321     if isinstance(scale_matrix, list):
322         scale_matrix = ImmutableMatrix(scale_matrix)
323     return rv(symbol, MatrixGammaDistribution, (alpha, beta, scale_matrix))
324 
325 #-------------------------------------------------------------------------------
326 # Wishart Distribution ---------------------------------------------------------
327 
328 class WishartDistribution(MatrixDistribution):
329 
330     _argnames = ('n', 'scale_matrix')
331 
332     @staticmethod
333     def check(n, scale_matrix):
334         if not isinstance(scale_matrix, MatrixSymbol):
335             _value_check(scale_matrix.is_positive_definite, "The shape "
336                 "matrix must be positive definite.")
337         _value_check(scale_matrix.is_square, "Should "
338         "be square matrix")
339         _value_check(n.is_positive, "Shape parameter should be positive.")
340 
341     @property
342     def set(self):
343         k = self.scale_matrix.shape[0]
344         return MatrixSet(k, k, S.Reals)
345 
346     @property
347     def dimension(self):
348         return self.scale_matrix.shape
349 
350     def pdf(self, x):
351         n, scale_matrix = self.n, self.scale_matrix
352         p = scale_matrix.shape[0]
353         if isinstance(x, list):
354             x = ImmutableMatrix(x)
355         if not isinstance(x, (MatrixBase, MatrixSymbol)):
356             raise ValueError("%s should be an isinstance of Matrix "
357                     "or MatrixSymbol" % str(x))
358         sigma_inv_x = - Inverse(scale_matrix)*x / S(2)
359         term1 = exp(Trace(sigma_inv_x))/((2**(p*n/S(2))) * multigamma(n/S(2), p))
360         term2 = (Determinant(scale_matrix))**(-n/S(2))
361         term3 = (Determinant(x))**(S(n - p - 1)/2)
362         return term1 * term2 * term3
363 
364 def Wishart(symbol, n, scale_matrix):
365     """
366     Creates a random variable with Wishart Distribution.
367 
368     The density of the said distribution can be found at [1].
369 
370     Parameters
371     ==========
372 
373     n: Positive Real number
374         Represents degrees of freedom
375     scale_matrix: Positive definite real square matrix
376         Scale Matrix
377 
378     Returns
379     =======
380 
381     RandomSymbol
382 
383     Examples
384     ========
385 
386     >>> from sympy.stats import density, Wishart
387     >>> from sympy import MatrixSymbol, symbols
388     >>> n = symbols('n', positive=True)
389     >>> W = Wishart('W', n, [[2, 1], [1, 2]])
390     >>> X = MatrixSymbol('X', 2, 2)
391     >>> density(W)(X).doit()
392     exp(Trace(Matrix([
393     [-1/3,  1/6],
394     [ 1/6, -1/3]])*X))*Determinant(X)**(n/2 - 3/2)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))
395     >>> density(W)([[1, 0], [0, 1]]).doit()
396     exp(-2/3)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))
397 
398     References
399     ==========
400 
401     .. [1] https://en.wikipedia.org/wiki/Wishart_distribution
402 
403     """
404     if isinstance(scale_matrix, list):
405         scale_matrix = ImmutableMatrix(scale_matrix)
406     return rv(symbol, WishartDistribution, (n, scale_matrix))
407 
408 #-------------------------------------------------------------------------------
409 # Matrix Normal distribution ---------------------------------------------------
410 
411 class MatrixNormalDistribution(MatrixDistribution):
412 
413     _argnames = ('location_matrix', 'scale_matrix_1', 'scale_matrix_2')
414 
415     @staticmethod
416     def check(location_matrix, scale_matrix_1, scale_matrix_2):
417         if not isinstance(scale_matrix_1, MatrixSymbol):
418             _value_check(scale_matrix_1.is_positive_definite, "The shape "
419                 "matrix must be positive definite.")
420         if not isinstance(scale_matrix_2, MatrixSymbol):
421             _value_check(scale_matrix_2.is_positive_definite, "The shape "
422                 "matrix must be positive definite.")
423         _value_check(scale_matrix_1.is_square, "Scale matrix 1 should be "
424         "be square matrix")
425         _value_check(scale_matrix_2.is_square, "Scale matrix 2 should be "
426         "be square matrix")
427         n = location_matrix.shape[0]
428         p = location_matrix.shape[1]
429         _value_check(scale_matrix_1.shape[0] == n, "Scale matrix 1 should be"
430         " of shape %s x %s"% (str(n), str(n)))
431         _value_check(scale_matrix_2.shape[0] == p, "Scale matrix 2 should be"
432         " of shape %s x %s"% (str(p), str(p)))
433 
434     @property
435     def set(self):
436         n, p = self.location_matrix.shape
437         return MatrixSet(n, p, S.Reals)
438 
439     @property
440     def dimension(self):
441         return self.location_matrix.shape
442 
443     def pdf(self, x):
444         M, U, V = self.location_matrix, self.scale_matrix_1, self.scale_matrix_2
445         n, p = M.shape
446         if isinstance(x, list):
447             x = ImmutableMatrix(x)
448         if not isinstance(x, (MatrixBase, MatrixSymbol)):
449             raise ValueError("%s should be an isinstance of Matrix "
450                     "or MatrixSymbol" % str(x))
451         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)
452         num = exp(-Trace(term1)/S(2))
453         den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2
454         return num/den
455 
456 def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):
457     """
458     Creates a random variable with Matrix Normal Distribution.
459 
460     The density of the said distribution can be found at [1].
461 
462     Parameters
463     ==========
464 
465     location_matrix: Real ``n x p`` matrix
466         Represents degrees of freedom
467     scale_matrix_1: Positive definite matrix
468         Scale Matrix of shape ``n x n``
469     scale_matrix_2: Positive definite matrix
470         Scale Matrix of shape ``p x p``
471 
472     Returns
473     =======
474 
475     RandomSymbol
476 
477     Examples
478     ========
479 
480     >>> from sympy import MatrixSymbol
481     >>> from sympy.stats import density, MatrixNormal
482     >>> M = MatrixNormal('M', [[1, 2]], [1], [[1, 0], [0, 1]])
483     >>> X = MatrixSymbol('X', 1, 2)
484     >>> density(M)(X).doit()
485     2*exp(-Trace((Matrix([
486     [-1],
487     [-2]]) + X.T)*(Matrix([[-1, -2]]) + X))/2)/pi
488     >>> density(M)([[3, 4]]).doit()
489     2*exp(-4)/pi
490 
491     References
492     ==========
493 
494     .. [1] https://en.wikipedia.org/wiki/Matrix_normal_distribution
495 
496     """
497     if isinstance(location_matrix, list):
498         location_matrix = ImmutableMatrix(location_matrix)
499     if isinstance(scale_matrix_1, list):
500         scale_matrix_1 = ImmutableMatrix(scale_matrix_1)
501     if isinstance(scale_matrix_2, list):
502         scale_matrix_2 = ImmutableMatrix(scale_matrix_2)
503     args = (location_matrix, scale_matrix_1, scale_matrix_2)
504     return rv(symbol, MatrixNormalDistribution, args)
505 
506 #-------------------------------------------------------------------------------
507 # Matrix Student's T distribution ---------------------------------------------------
508 
509 class MatrixStudentTDistribution(MatrixDistribution):
510 
511     _argnames = ('nu', 'location_matrix', 'scale_matrix_1', 'scale_matrix_2')
512 
513     @staticmethod
514     def check(nu, location_matrix, scale_matrix_1, scale_matrix_2):
515         if not isinstance(scale_matrix_1, MatrixSymbol):
516             _value_check(scale_matrix_1.is_positive_definite != False, "The shape "
517                                                               "matrix must be positive definite.")
518         if not isinstance(scale_matrix_2, MatrixSymbol):
519             _value_check(scale_matrix_2.is_positive_definite != False, "The shape "
520                                                               "matrix must be positive definite.")
521         _value_check(scale_matrix_1.is_square != False, "Scale matrix 1 should be "
522                                                "be square matrix")
523         _value_check(scale_matrix_2.is_square != False, "Scale matrix 2 should be "
524                                                "be square matrix")
525         n = location_matrix.shape[0]
526         p = location_matrix.shape[1]
527         _value_check(scale_matrix_1.shape[0] == p, "Scale matrix 1 should be"
528                                                    " of shape %s x %s" % (str(p), str(p)))
529         _value_check(scale_matrix_2.shape[0] == n, "Scale matrix 2 should be"
530                                                    " of shape %s x %s" % (str(n), str(n)))
531         _value_check(nu.is_positive != False, "Degrees of freedom must be positive")
532 
533     @property
534     def set(self):
535         n, p = self.location_matrix.shape
536         return MatrixSet(n, p, S.Reals)
537 
538     @property
539     def dimension(self):
540         return self.location_matrix.shape
541 
542     def pdf(self, x):
543         from sympy.matrices.dense import eye
544         if isinstance(x, list):
545             x = ImmutableMatrix(x)
546         if not isinstance(x, (MatrixBase, MatrixSymbol)):
547             raise ValueError("%s should be an isinstance of Matrix "
548                              "or MatrixSymbol" % str(x))
549         nu, M, Omega, Sigma = self.nu, self.location_matrix, self.scale_matrix_1, self.scale_matrix_2
550         n, p = M.shape
551 
552         K = multigamma((nu + n + p - 1)/2, p) * Determinant(Omega)**(-n/2) * Determinant(Sigma)**(-p/2) \
553             / ((pi)**(n*p/2) * multigamma((nu + p - 1)/2, p))
554         return K * (Determinant(eye(n) + Inverse(Sigma)*(x - M)*Inverse(Omega)*Transpose(x - M))) \
555                **(-(nu + n + p -1)/2)
556 
557 
558 
559 def MatrixStudentT(symbol, nu, location_matrix, scale_matrix_1, scale_matrix_2):
560     """
561     Creates a random variable with Matrix Gamma Distribution.
562 
563     The density of the said distribution can be found at [1].
564 
565     Parameters
566     ==========
567 
568     nu: Positive Real number
569         degrees of freedom
570     location_matrix: Positive definite real square matrix
571         Location Matrix of shape ``n x p``
572     scale_matrix_1: Positive definite real square matrix
573         Scale Matrix of shape ``p x p``
574     scale_matrix_2: Positive definite real square matrix
575         Scale Matrix of shape ``n x n``
576 
577     Returns
578     =======
579 
580     RandomSymbol
581 
582     Examples
583     ========
584 
585     >>> from sympy import MatrixSymbol,symbols
586     >>> from sympy.stats import density, MatrixStudentT
587     >>> v = symbols('v',positive=True)
588     >>> M = MatrixStudentT('M', v, [[1, 2]], [[1, 0], [0, 1]], [1])
589     >>> X = MatrixSymbol('X', 1, 2)
590     >>> density(M)(X)
591     gamma(v/2 + 1)*Determinant((Matrix([[-1, -2]]) + X)*(Matrix([
592     [-1],
593     [-2]]) + X.T) + Matrix([[1]]))**(-v/2 - 1)/(pi**1.0*gamma(v/2)*Determinant(Matrix([[1]]))**1.0*Determinant(Matrix([
594     [1, 0],
595     [0, 1]]))**0.5)
596 
597     References
598     ==========
599 
600     .. [1] https://en.wikipedia.org/wiki/Matrix_t-distribution
601 
602     """
603     if isinstance(location_matrix, list):
604         location_matrix = ImmutableMatrix(location_matrix)
605     if isinstance(scale_matrix_1, list):
606         scale_matrix_1 = ImmutableMatrix(scale_matrix_1)
607     if isinstance(scale_matrix_2, list):
608         scale_matrix_2 = ImmutableMatrix(scale_matrix_2)
609     args = (nu, location_matrix, scale_matrix_1, scale_matrix_2)
610     return rv(symbol, MatrixStudentTDistribution, args)

</code><intended_behavior>The method in the `MatrixNormal` class that calculates the PDF should be corrected to ensure that the constant term in the formula aligns with the mathematical standard for the Matrix Normal Distribution. Specifically, the corrected implementation should ensure that the constant term is calculated as per the formula given in the issue description, which is `\frac{1}{(2\pi)^{nk/2}}` for a matrix of dimension `n x k`, rather than any incorrect variation of this term. This includes careful handling of the determinant of the covariance matrix in the denominator and the trace operation in the exponent of the e-function within the PDF formula. The correction should be applied in a way that does not negatively impact other functionalities provided by the `MatrixNormal` class, ensuring that the class remains fully functional for other uses, such as sampling and parameter checks. This means preserving the overall structure and logic of the PDF computation while adjusting the specific part of the formula that is incorrect. In addition to the PDF formula correction, tests or validations should be reviewed or added to confirm that the PDF calculation now matches the expected mathematical definition, thus ensuring the bug is resolved and similar issues are prevented in the future.</intended_behavior>]
2025-10-18 21:16:56.054 | INFO     | Search completed. Bug locations: [<file>sympy/stats/matrix_distributions.py</file>
<class>None</class>
<method>None</method>
<code>
1 from math import prod
2 
3 from sympy.core.basic import Basic
4 from sympy.core.numbers import pi
5 from sympy.core.singleton import S
6 from sympy.functions.elementary.exponential import exp
7 from sympy.functions.special.gamma_functions import multigamma
8 from sympy.core.sympify import sympify, _sympify
9 from sympy.matrices import (ImmutableMatrix, Inverse, Trace, Determinant,
10                             MatrixSymbol, MatrixBase, Transpose, MatrixSet,
11                             matrix2numpy)
12 from sympy.stats.rv import (_value_check, RandomMatrixSymbol, NamedArgsMixin, PSpace,
13                             _symbol_converter, MatrixDomain, Distribution)
14 from sympy.external import import_module
15 
16 
17 ################################################################################
18 #------------------------Matrix Probability Space------------------------------#
19 ################################################################################
20 class MatrixPSpace(PSpace):
21     """
22     Represents probability space for
23     Matrix Distributions.
24     """
25     def __new__(cls, sym, distribution, dim_n, dim_m):
26         sym = _symbol_converter(sym)
27         dim_n, dim_m = _sympify(dim_n), _sympify(dim_m)
28         if not (dim_n.is_integer and dim_m.is_integer):
29             raise ValueError("Dimensions should be integers")
30         return Basic.__new__(cls, sym, distribution, dim_n, dim_m)
31 
32     distribution = property(lambda self: self.args[1])
33     symbol = property(lambda self: self.args[0])
34 
35     @property
36     def domain(self):
37         return MatrixDomain(self.symbol, self.distribution.set)
38 
39     @property
40     def value(self):
41         return RandomMatrixSymbol(self.symbol, self.args[2], self.args[3], self)
42 
43     @property
44     def values(self):
45         return {self.value}
46 
47     def compute_density(self, expr, *args):
48         rms = expr.atoms(RandomMatrixSymbol)
49         if len(rms) > 1 or (not isinstance(expr, RandomMatrixSymbol)):
50             raise NotImplementedError("Currently, no algorithm has been "
51                     "implemented to handle general expressions containing "
52                     "multiple matrix distributions.")
53         return self.distribution.pdf(expr)
54 
55     def sample(self, size=(), library='scipy', seed=None):
56         """
57         Internal sample method
58 
59         Returns dictionary mapping RandomMatrixSymbol to realization value.
60         """
61         return {self.value: self.distribution.sample(size, library=library, seed=seed)}
62 
63 
64 def rv(symbol, cls, args):
65     args = list(map(sympify, args))
66     dist = cls(*args)
67     dist.check(*args)
68     dim = dist.dimension
69     pspace = MatrixPSpace(symbol, dist, dim[0], dim[1])
70     return pspace.value
71 
72 
73 class SampleMatrixScipy:
74     """Returns the sample from scipy of the given distribution"""
75     def __new__(cls, dist, size, seed=None):
76         return cls._sample_scipy(dist, size, seed)
77 
78     @classmethod
79     def _sample_scipy(cls, dist, size, seed):
80         """Sample from SciPy."""
81 
82         from scipy import stats as scipy_stats
83         import numpy
84         scipy_rv_map = {
85             'WishartDistribution': lambda dist, size, rand_state: scipy_stats.wishart.rvs(
86                 df=int(dist.n), scale=matrix2numpy(dist.scale_matrix, float), size=size),
87             'MatrixNormalDistribution': lambda dist, size, rand_state: scipy_stats.matrix_normal.rvs(
88                 mean=matrix2numpy(dist.location_matrix, float),
89                 rowcov=matrix2numpy(dist.scale_matrix_1, float),
90                 colcov=matrix2numpy(dist.scale_matrix_2, float), size=size, random_state=rand_state)
91         }
92 
93         sample_shape = {
94             'WishartDistribution': lambda dist: dist.scale_matrix.shape,
95             'MatrixNormalDistribution' : lambda dist: dist.location_matrix.shape
96         }
97 
98         dist_list = scipy_rv_map.keys()
99 
100         if dist.__class__.__name__ not in dist_list:
101             return None
102 
103         if seed is None or isinstance(seed, int):
104             rand_state = numpy.random.default_rng(seed=seed)
105         else:
106             rand_state = seed
107         samp = scipy_rv_map[dist.__class__.__name__](dist, prod(size), rand_state)
108         return samp.reshape(size + sample_shape[dist.__class__.__name__](dist))
109 
110 
111 class SampleMatrixNumpy:
112     """Returns the sample from numpy of the given distribution"""
113 
114     ### TODO: Add tests after adding matrix distributions in numpy_rv_map
115     def __new__(cls, dist, size, seed=None):
116         return cls._sample_numpy(dist, size, seed)
117 
118     @classmethod
119     def _sample_numpy(cls, dist, size, seed):
120         """Sample from NumPy."""
121 
122         numpy_rv_map = {
123         }
124 
125         sample_shape = {
126         }
127 
128         dist_list = numpy_rv_map.keys()
129 
130         if dist.__class__.__name__ not in dist_list:
131             return None
132 
133         import numpy
134         if seed is None or isinstance(seed, int):
135             rand_state = numpy.random.default_rng(seed=seed)
136         else:
137             rand_state = seed
138         samp = numpy_rv_map[dist.__class__.__name__](dist, prod(size), rand_state)
139         return samp.reshape(size + sample_shape[dist.__class__.__name__](dist))
140 
141 
142 class SampleMatrixPymc:
143     """Returns the sample from pymc of the given distribution"""
144 
145     def __new__(cls, dist, size, seed=None):
146         return cls._sample_pymc(dist, size, seed)
147 
148     @classmethod
149     def _sample_pymc(cls, dist, size, seed):
150         """Sample from PyMC."""
151 
152         try:
153             import pymc
154         except ImportError:
155             import pymc3 as pymc
156         pymc_rv_map = {
157             'MatrixNormalDistribution': lambda dist: pymc.MatrixNormal('X',
158                 mu=matrix2numpy(dist.location_matrix, float),
159                 rowcov=matrix2numpy(dist.scale_matrix_1, float),
160                 colcov=matrix2numpy(dist.scale_matrix_2, float),
161                 shape=dist.location_matrix.shape),
162             'WishartDistribution': lambda dist: pymc.WishartBartlett('X',
163                 nu=int(dist.n), S=matrix2numpy(dist.scale_matrix, float))
164         }
165 
166         sample_shape = {
167             'WishartDistribution': lambda dist: dist.scale_matrix.shape,
168             'MatrixNormalDistribution' : lambda dist: dist.location_matrix.shape
169         }
170 
171         dist_list = pymc_rv_map.keys()
172 
173         if dist.__class__.__name__ not in dist_list:
174             return None
175         import logging
176         logging.getLogger("pymc").setLevel(logging.ERROR)
177         with pymc.Model():
178             pymc_rv_map[dist.__class__.__name__](dist)
179             samps = pymc.sample(draws=prod(size), chains=1, progressbar=False, random_seed=seed, return_inferencedata=False, compute_convergence_checks=False)['X']
180         return samps.reshape(size + sample_shape[dist.__class__.__name__](dist))
181 
182 _get_sample_class_matrixrv = {
183     'scipy': SampleMatrixScipy,
184     'pymc3': SampleMatrixPymc,
185     'pymc': SampleMatrixPymc,
186     'numpy': SampleMatrixNumpy
187 }
188 
189 ################################################################################
190 #-------------------------Matrix Distribution----------------------------------#
191 ################################################################################
192 
193 class MatrixDistribution(Distribution, NamedArgsMixin):
194     """
195     Abstract class for Matrix Distribution.
196     """
197     def __new__(cls, *args):
198         args = [ImmutableMatrix(arg) if isinstance(arg, list)
199                 else _sympify(arg) for arg in args]
200         return Basic.__new__(cls, *args)
201 
202     @staticmethod
203     def check(*args):
204         pass
205 
206     def __call__(self, expr):
207         if isinstance(expr, list):
208             expr = ImmutableMatrix(expr)
209         return self.pdf(expr)
210 
211     def sample(self, size=(), library='scipy', seed=None):
212         """
213         Internal sample method
214 
215         Returns dictionary mapping RandomSymbol to realization value.
216         """
217 
218         libraries = ['scipy', 'numpy', 'pymc3', 'pymc']
219         if library not in libraries:
220             raise NotImplementedError("Sampling from %s is not supported yet."
221                                         % str(library))
222         if not import_module(library):
223             raise ValueError("Failed to import %s" % library)
224 
225         samps = _get_sample_class_matrixrv[library](self, size, seed)
226 
227         if samps is not None:
228             return samps
229         raise NotImplementedError(
230                 "Sampling for %s is not currently implemented from %s"
231                 % (self.__class__.__name__, library)
232                 )
233 
234 ################################################################################
235 #------------------------Matrix Distribution Types-----------------------------#
236 ################################################################################
237 
238 #-------------------------------------------------------------------------------
239 # Matrix Gamma distribution ----------------------------------------------------
240 
241 class MatrixGammaDistribution(MatrixDistribution):
242 
243     _argnames = ('alpha', 'beta', 'scale_matrix')
244 
245     @staticmethod
246     def check(alpha, beta, scale_matrix):
247         if not isinstance(scale_matrix, MatrixSymbol):
248             _value_check(scale_matrix.is_positive_definite, "The shape "
249                 "matrix must be positive definite.")
250         _value_check(scale_matrix.is_square, "Should "
251         "be square matrix")
252         _value_check(alpha.is_positive, "Shape parameter should be positive.")
253         _value_check(beta.is_positive, "Scale parameter should be positive.")
254 
255     @property
256     def set(self):
257         k = self.scale_matrix.shape[0]
258         return MatrixSet(k, k, S.Reals)
259 
260     @property
261     def dimension(self):
262         return self.scale_matrix.shape
263 
264     def pdf(self, x):
265         alpha, beta, scale_matrix = self.alpha, self.beta, self.scale_matrix
266         p = scale_matrix.shape[0]
267         if isinstance(x, list):
268             x = ImmutableMatrix(x)
269         if not isinstance(x, (MatrixBase, MatrixSymbol)):
270             raise ValueError("%s should be an isinstance of Matrix "
271                     "or MatrixSymbol" % str(x))
272         sigma_inv_x = - Inverse(scale_matrix)*x / beta
273         term1 = exp(Trace(sigma_inv_x))/((beta**(p*alpha)) * multigamma(alpha, p))
274         term2 = (Determinant(scale_matrix))**(-alpha)
275         term3 = (Determinant(x))**(alpha - S(p + 1)/2)
276         return term1 * term2 * term3
277 
278 def MatrixGamma(symbol, alpha, beta, scale_matrix):
279     """
280     Creates a random variable with Matrix Gamma Distribution.
281 
282     The density of the said distribution can be found at [1].
283 
284     Parameters
285     ==========
286 
287     alpha: Positive Real number
288         Shape Parameter
289     beta: Positive Real number
290         Scale Parameter
291     scale_matrix: Positive definite real square matrix
292         Scale Matrix
293 
294     Returns
295     =======
296 
297     RandomSymbol
298 
299     Examples
300     ========
301 
302     >>> from sympy.stats import density, MatrixGamma
303     >>> from sympy import MatrixSymbol, symbols
304     >>> a, b = symbols('a b', positive=True)
305     >>> M = MatrixGamma('M', a, b, [[2, 1], [1, 2]])
306     >>> X = MatrixSymbol('X', 2, 2)
307     >>> density(M)(X).doit()
308     exp(Trace(Matrix([
309     [-2/3,  1/3],
310     [ 1/3, -2/3]])*X)/b)*Determinant(X)**(a - 3/2)/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))
311     >>> density(M)([[1, 0], [0, 1]]).doit()
312     exp(-4/(3*b))/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))
313 
314 
315     References
316     ==========
317 
318     .. [1] https://en.wikipedia.org/wiki/Matrix_gamma_distribution
319 
320     """
321     if isinstance(scale_matrix, list):
322         scale_matrix = ImmutableMatrix(scale_matrix)
323     return rv(symbol, MatrixGammaDistribution, (alpha, beta, scale_matrix))
324 
325 #-------------------------------------------------------------------------------
326 # Wishart Distribution ---------------------------------------------------------
327 
328 class WishartDistribution(MatrixDistribution):
329 
330     _argnames = ('n', 'scale_matrix')
331 
332     @staticmethod
333     def check(n, scale_matrix):
334         if not isinstance(scale_matrix, MatrixSymbol):
335             _value_check(scale_matrix.is_positive_definite, "The shape "
336                 "matrix must be positive definite.")
337         _value_check(scale_matrix.is_square, "Should "
338         "be square matrix")
339         _value_check(n.is_positive, "Shape parameter should be positive.")
340 
341     @property
342     def set(self):
343         k = self.scale_matrix.shape[0]
344         return MatrixSet(k, k, S.Reals)
345 
346     @property
347     def dimension(self):
348         return self.scale_matrix.shape
349 
350     def pdf(self, x):
351         n, scale_matrix = self.n, self.scale_matrix
352         p = scale_matrix.shape[0]
353         if isinstance(x, list):
354             x = ImmutableMatrix(x)
355         if not isinstance(x, (MatrixBase, MatrixSymbol)):
356             raise ValueError("%s should be an isinstance of Matrix "
357                     "or MatrixSymbol" % str(x))
358         sigma_inv_x = - Inverse(scale_matrix)*x / S(2)
359         term1 = exp(Trace(sigma_inv_x))/((2**(p*n/S(2))) * multigamma(n/S(2), p))
360         term2 = (Determinant(scale_matrix))**(-n/S(2))
361         term3 = (Determinant(x))**(S(n - p - 1)/2)
362         return term1 * term2 * term3
363 
364 def Wishart(symbol, n, scale_matrix):
365     """
366     Creates a random variable with Wishart Distribution.
367 
368     The density of the said distribution can be found at [1].
369 
370     Parameters
371     ==========
372 
373     n: Positive Real number
374         Represents degrees of freedom
375     scale_matrix: Positive definite real square matrix
376         Scale Matrix
377 
378     Returns
379     =======
380 
381     RandomSymbol
382 
383     Examples
384     ========
385 
386     >>> from sympy.stats import density, Wishart
387     >>> from sympy import MatrixSymbol, symbols
388     >>> n = symbols('n', positive=True)
389     >>> W = Wishart('W', n, [[2, 1], [1, 2]])
390     >>> X = MatrixSymbol('X', 2, 2)
391     >>> density(W)(X).doit()
392     exp(Trace(Matrix([
393     [-1/3,  1/6],
394     [ 1/6, -1/3]])*X))*Determinant(X)**(n/2 - 3/2)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))
395     >>> density(W)([[1, 0], [0, 1]]).doit()
396     exp(-2/3)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))
397 
398     References
399     ==========
400 
401     .. [1] https://en.wikipedia.org/wiki/Wishart_distribution
402 
403     """
404     if isinstance(scale_matrix, list):
405         scale_matrix = ImmutableMatrix(scale_matrix)
406     return rv(symbol, WishartDistribution, (n, scale_matrix))
407 
408 #-------------------------------------------------------------------------------
409 # Matrix Normal distribution ---------------------------------------------------
410 
411 class MatrixNormalDistribution(MatrixDistribution):
412 
413     _argnames = ('location_matrix', 'scale_matrix_1', 'scale_matrix_2')
414 
415     @staticmethod
416     def check(location_matrix, scale_matrix_1, scale_matrix_2):
417         if not isinstance(scale_matrix_1, MatrixSymbol):
418             _value_check(scale_matrix_1.is_positive_definite, "The shape "
419                 "matrix must be positive definite.")
420         if not isinstance(scale_matrix_2, MatrixSymbol):
421             _value_check(scale_matrix_2.is_positive_definite, "The shape "
422                 "matrix must be positive definite.")
423         _value_check(scale_matrix_1.is_square, "Scale matrix 1 should be "
424         "be square matrix")
425         _value_check(scale_matrix_2.is_square, "Scale matrix 2 should be "
426         "be square matrix")
427         n = location_matrix.shape[0]
428         p = location_matrix.shape[1]
429         _value_check(scale_matrix_1.shape[0] == n, "Scale matrix 1 should be"
430         " of shape %s x %s"% (str(n), str(n)))
431         _value_check(scale_matrix_2.shape[0] == p, "Scale matrix 2 should be"
432         " of shape %s x %s"% (str(p), str(p)))
433 
434     @property
435     def set(self):
436         n, p = self.location_matrix.shape
437         return MatrixSet(n, p, S.Reals)
438 
439     @property
440     def dimension(self):
441         return self.location_matrix.shape
442 
443     def pdf(self, x):
444         M, U, V = self.location_matrix, self.scale_matrix_1, self.scale_matrix_2
445         n, p = M.shape
446         if isinstance(x, list):
447             x = ImmutableMatrix(x)
448         if not isinstance(x, (MatrixBase, MatrixSymbol)):
449             raise ValueError("%s should be an isinstance of Matrix "
450                     "or MatrixSymbol" % str(x))
451         term1 = Inverse(V)*Transpose(x - M)*Inverse(U)*(x - M)
452         num = exp(-Trace(term1)/S(2))
453         den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2
454         return num/den
455 
456 def MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2):
457     """
458     Creates a random variable with Matrix Normal Distribution.
459 
460     The density of the said distribution can be found at [1].
461 
462     Parameters
463     ==========
464 
465     location_matrix: Real ``n x p`` matrix
466         Represents degrees of freedom
467     scale_matrix_1: Positive definite matrix
468         Scale Matrix of shape ``n x n``
469     scale_matrix_2: Positive definite matrix
470         Scale Matrix of shape ``p x p``
471 
472     Returns
473     =======
474 
475     RandomSymbol
476 
477     Examples
478     ========
479 
480     >>> from sympy import MatrixSymbol
481     >>> from sympy.stats import density, MatrixNormal
482     >>> M = MatrixNormal('M', [[1, 2]], [1], [[1, 0], [0, 1]])
483     >>> X = MatrixSymbol('X', 1, 2)
484     >>> density(M)(X).doit()
485     2*exp(-Trace((Matrix([
486     [-1],
487     [-2]]) + X.T)*(Matrix([[-1, -2]]) + X))/2)/pi
488     >>> density(M)([[3, 4]]).doit()
489     2*exp(-4)/pi
490 
491     References
492     ==========
493 
494     .. [1] https://en.wikipedia.org/wiki/Matrix_normal_distribution
495 
496     """
497     if isinstance(location_matrix, list):
498         location_matrix = ImmutableMatrix(location_matrix)
499     if isinstance(scale_matrix_1, list):
500         scale_matrix_1 = ImmutableMatrix(scale_matrix_1)
501     if isinstance(scale_matrix_2, list):
502         scale_matrix_2 = ImmutableMatrix(scale_matrix_2)
503     args = (location_matrix, scale_matrix_1, scale_matrix_2)
504     return rv(symbol, MatrixNormalDistribution, args)
505 
506 #-------------------------------------------------------------------------------
507 # Matrix Student's T distribution ---------------------------------------------------
508 
509 class MatrixStudentTDistribution(MatrixDistribution):
510 
511     _argnames = ('nu', 'location_matrix', 'scale_matrix_1', 'scale_matrix_2')
512 
513     @staticmethod
514     def check(nu, location_matrix, scale_matrix_1, scale_matrix_2):
515         if not isinstance(scale_matrix_1, MatrixSymbol):
516             _value_check(scale_matrix_1.is_positive_definite != False, "The shape "
517                                                               "matrix must be positive definite.")
518         if not isinstance(scale_matrix_2, MatrixSymbol):
519             _value_check(scale_matrix_2.is_positive_definite != False, "The shape "
520                                                               "matrix must be positive definite.")
521         _value_check(scale_matrix_1.is_square != False, "Scale matrix 1 should be "
522                                                "be square matrix")
523         _value_check(scale_matrix_2.is_square != False, "Scale matrix 2 should be "
524                                                "be square matrix")
525         n = location_matrix.shape[0]
526         p = location_matrix.shape[1]
527         _value_check(scale_matrix_1.shape[0] == p, "Scale matrix 1 should be"
528                                                    " of shape %s x %s" % (str(p), str(p)))
529         _value_check(scale_matrix_2.shape[0] == n, "Scale matrix 2 should be"
530                                                    " of shape %s x %s" % (str(n), str(n)))
531         _value_check(nu.is_positive != False, "Degrees of freedom must be positive")
532 
533     @property
534     def set(self):
535         n, p = self.location_matrix.shape
536         return MatrixSet(n, p, S.Reals)
537 
538     @property
539     def dimension(self):
540         return self.location_matrix.shape
541 
542     def pdf(self, x):
543         from sympy.matrices.dense import eye
544         if isinstance(x, list):
545             x = ImmutableMatrix(x)
546         if not isinstance(x, (MatrixBase, MatrixSymbol)):
547             raise ValueError("%s should be an isinstance of Matrix "
548                              "or MatrixSymbol" % str(x))
549         nu, M, Omega, Sigma = self.nu, self.location_matrix, self.scale_matrix_1, self.scale_matrix_2
550         n, p = M.shape
551 
552         K = multigamma((nu + n + p - 1)/2, p) * Determinant(Omega)**(-n/2) * Determinant(Sigma)**(-p/2) \
553             / ((pi)**(n*p/2) * multigamma((nu + p - 1)/2, p))
554         return K * (Determinant(eye(n) + Inverse(Sigma)*(x - M)*Inverse(Omega)*Transpose(x - M))) \
555                **(-(nu + n + p -1)/2)
556 
557 
558 
559 def MatrixStudentT(symbol, nu, location_matrix, scale_matrix_1, scale_matrix_2):
560     """
561     Creates a random variable with Matrix Gamma Distribution.
562 
563     The density of the said distribution can be found at [1].
564 
565     Parameters
566     ==========
567 
568     nu: Positive Real number
569         degrees of freedom
570     location_matrix: Positive definite real square matrix
571         Location Matrix of shape ``n x p``
572     scale_matrix_1: Positive definite real square matrix
573         Scale Matrix of shape ``p x p``
574     scale_matrix_2: Positive definite real square matrix
575         Scale Matrix of shape ``n x n``
576 
577     Returns
578     =======
579 
580     RandomSymbol
581 
582     Examples
583     ========
584 
585     >>> from sympy import MatrixSymbol,symbols
586     >>> from sympy.stats import density, MatrixStudentT
587     >>> v = symbols('v',positive=True)
588     >>> M = MatrixStudentT('M', v, [[1, 2]], [[1, 0], [0, 1]], [1])
589     >>> X = MatrixSymbol('X', 1, 2)
590     >>> density(M)(X)
591     gamma(v/2 + 1)*Determinant((Matrix([[-1, -2]]) + X)*(Matrix([
592     [-1],
593     [-2]]) + X.T) + Matrix([[1]]))**(-v/2 - 1)/(pi**1.0*gamma(v/2)*Determinant(Matrix([[1]]))**1.0*Determinant(Matrix([
594     [1, 0],
595     [0, 1]]))**0.5)
596 
597     References
598     ==========
599 
600     .. [1] https://en.wikipedia.org/wiki/Matrix_t-distribution
601 
602     """
603     if isinstance(location_matrix, list):
604         location_matrix = ImmutableMatrix(location_matrix)
605     if isinstance(scale_matrix_1, list):
606         scale_matrix_1 = ImmutableMatrix(scale_matrix_1)
607     if isinstance(scale_matrix_2, list):
608         scale_matrix_2 = ImmutableMatrix(scale_matrix_2)
609     args = (nu, location_matrix, scale_matrix_1, scale_matrix_2)
610     return rv(symbol, MatrixStudentTDistribution, args)

</code><intended_behavior>The method in the `MatrixNormal` class that calculates the PDF should be corrected to ensure that the constant term in the formula aligns with the mathematical standard for the Matrix Normal Distribution. Specifically, the corrected implementation should ensure that the constant term is calculated as per the formula given in the issue description, which is `\frac{1}{(2\pi)^{nk/2}}` for a matrix of dimension `n x k`, rather than any incorrect variation of this term. This includes careful handling of the determinant of the covariance matrix in the denominator and the trace operation in the exponent of the e-function within the PDF formula. The correction should be applied in a way that does not negatively impact other functionalities provided by the `MatrixNormal` class, ensuring that the class remains fully functional for other uses, such as sampling and parameter checks. This means preserving the overall structure and logic of the PDF computation while adjusting the specific part of the formula that is incorrect. In addition to the PDF formula correction, tests or validations should be reviewed or added to confirm that the PDF calculation now matches the expected mathematical definition, thus ensuring the bug is resolved and similar issues are prevented in the future.</intended_behavior>]
2025-10-18 21:16:56.054 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 21:16:56.054 | INFO     | Search-only: skipping patch selection
2025-10-18 21:16:56.183 | INFO     | Task sympy__sympy-24723 completed successfully.
2025-10-18 21:16:56.184 | INFO     | No patch generated. You can try running ACR again.
