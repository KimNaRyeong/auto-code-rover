[
    {
        "rel_file_path": "django/core/management/commands/makemigrations.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/management/commands/makemigrations.py",
        "start": 23,
        "end": 310,
        "class_name": "Command",
        "method_name": null,
        "code": "23 class Command(BaseCommand):\n24     help = \"Creates new migration(s) for apps.\"\n25 \n26     def add_arguments(self, parser):\n27         parser.add_argument(\n28             'args', metavar='app_label', nargs='*',\n29             help='Specify the app label(s) to create migrations for.',\n30         )\n31         parser.add_argument(\n32             '--dry-run', action='store_true',\n33             help=\"Just show what migrations would be made; don't actually write them.\",\n34         )\n35         parser.add_argument(\n36             '--merge', action='store_true',\n37             help=\"Enable fixing of migration conflicts.\",\n38         )\n39         parser.add_argument(\n40             '--empty', action='store_true',\n41             help=\"Create an empty migration.\",\n42         )\n43         parser.add_argument(\n44             '--noinput', '--no-input', action='store_false', dest='interactive',\n45             help='Tells Django to NOT prompt the user for input of any kind.',\n46         )\n47         parser.add_argument(\n48             '-n', '--name',\n49             help=\"Use this name for migration file(s).\",\n50         )\n51         parser.add_argument(\n52             '--no-header', action='store_false', dest='include_header',\n53             help='Do not add header comments to new migration file(s).',\n54         )\n55         parser.add_argument(\n56             '--check', action='store_true', dest='check_changes',\n57             help='Exit with a non-zero status if model changes are missing migrations.',\n58         )\n59 \n60     @no_translations\n61     def handle(self, *app_labels, **options):\n62         self.verbosity = options['verbosity']\n63         self.interactive = options['interactive']\n64         self.dry_run = options['dry_run']\n65         self.merge = options['merge']\n66         self.empty = options['empty']\n67         self.migration_name = options['name']\n68         if self.migration_name and not self.migration_name.isidentifier():\n69             raise CommandError('The migration name must be a valid Python identifier.')\n70         self.include_header = options['include_header']\n71         check_changes = options['check_changes']\n72 \n73         # Make sure the app they asked for exists\n74         app_labels = set(app_labels)\n75         has_bad_labels = False\n76         for app_label in app_labels:\n77             try:\n78                 apps.get_app_config(app_label)\n79             except LookupError as err:\n80                 self.stderr.write(str(err))\n81                 has_bad_labels = True\n82         if has_bad_labels:\n83             sys.exit(2)\n84 \n85         # Load the current graph state. Pass in None for the connection so\n86         # the loader doesn't try to resolve replaced migrations from DB.\n87         loader = MigrationLoader(None, ignore_no_migrations=True)\n88 \n89         # Raise an error if any migrations are applied before their dependencies.\n90         consistency_check_labels = {config.label for config in apps.get_app_configs()}\n91         # Non-default databases are only checked if database routers used.\n92         aliases_to_check = connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS]\n93         for alias in sorted(aliases_to_check):\n94             connection = connections[alias]\n95             if (connection.settings_dict['ENGINE'] != 'django.db.backends.dummy' and any(\n96                     # At least one model must be migrated to the database.\n97                     router.allow_migrate(connection.alias, app_label, model_name=model._meta.object_name)\n98                     for app_label in consistency_check_labels\n99                     for model in apps.get_app_config(app_label).get_models()\n100             )):\n101                 loader.check_consistent_history(connection)\n102 \n103         # Before anything else, see if there's conflicting apps and drop out\n104         # hard if there are any and they don't want to merge\n105         conflicts = loader.detect_conflicts()\n106 \n107         # If app_labels is specified, filter out conflicting migrations for unspecified apps\n108         if app_labels:\n109             conflicts = {\n110                 app_label: conflict for app_label, conflict in conflicts.items()\n111                 if app_label in app_labels\n112             }\n113 \n114         if conflicts and not self.merge:\n115             name_str = \"; \".join(\n116                 \"%s in %s\" % (\", \".join(names), app)\n117                 for app, names in conflicts.items()\n118             )\n119             raise CommandError(\n120                 \"Conflicting migrations detected; multiple leaf nodes in the \"\n121                 \"migration graph: (%s).\\nTo fix them run \"\n122                 \"'python manage.py makemigrations --merge'\" % name_str\n123             )\n124 \n125         # If they want to merge and there's nothing to merge, then politely exit\n126         if self.merge and not conflicts:\n127             self.stdout.write(\"No conflicts detected to merge.\")\n128             return\n129 \n130         # If they want to merge and there is something to merge, then\n131         # divert into the merge code\n132         if self.merge and conflicts:\n133             return self.handle_merge(loader, conflicts)\n134 \n135         if self.interactive:\n136             questioner = InteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run)\n137         else:\n138             questioner = NonInteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run)\n139         # Set up autodetector\n140         autodetector = MigrationAutodetector(\n141             loader.project_state(),\n142             ProjectState.from_apps(apps),\n143             questioner,\n144         )\n145 \n146         # If they want to make an empty migration, make one for each app\n147         if self.empty:\n148             if not app_labels:\n149                 raise CommandError(\"You must supply at least one app label when using --empty.\")\n150             # Make a fake changes() result we can pass to arrange_for_graph\n151             changes = {\n152                 app: [Migration(\"custom\", app)]\n153                 for app in app_labels\n154             }\n155             changes = autodetector.arrange_for_graph(\n156                 changes=changes,\n157                 graph=loader.graph,\n158                 migration_name=self.migration_name,\n159             )\n160             self.write_migration_files(changes)\n161             return\n162 \n163         # Detect changes\n164         changes = autodetector.changes(\n165             graph=loader.graph,\n166             trim_to_apps=app_labels or None,\n167             convert_apps=app_labels or None,\n168             migration_name=self.migration_name,\n169         )\n170 \n171         if not changes:\n172             # No changes? Tell them.\n173             if self.verbosity >= 1:\n174                 if app_labels:\n175                     if len(app_labels) == 1:\n176                         self.stdout.write(\"No changes detected in app '%s'\" % app_labels.pop())\n177                     else:\n178                         self.stdout.write(\"No changes detected in apps '%s'\" % (\"', '\".join(app_labels)))\n179                 else:\n180                     self.stdout.write(\"No changes detected\")\n181         else:\n182             self.write_migration_files(changes)\n183             if check_changes:\n184                 sys.exit(1)\n185 \n186     def write_migration_files(self, changes):\n187         \"\"\"\n188         Take a changes dict and write them out as migration files.\n189         \"\"\"\n190         directory_created = {}\n191         for app_label, app_migrations in changes.items():\n192             if self.verbosity >= 1:\n193                 self.stdout.write(self.style.MIGRATE_HEADING(\"Migrations for '%s':\" % app_label))\n194             for migration in app_migrations:\n195                 # Describe the migration\n196                 writer = MigrationWriter(migration, self.include_header)\n197                 if self.verbosity >= 1:\n198                     # Display a relative path if it's below the current working\n199                     # directory, or an absolute path otherwise.\n200                     try:\n201                         migration_string = os.path.relpath(writer.path)\n202                     except ValueError:\n203                         migration_string = writer.path\n204                     if migration_string.startswith('..'):\n205                         migration_string = writer.path\n206                     self.stdout.write('  %s\\n' % self.style.MIGRATE_LABEL(migration_string))\n207                     for operation in migration.operations:\n208                         self.stdout.write('    - %s' % operation.describe())\n209                 if not self.dry_run:\n210                     # Write the migrations file to the disk.\n211                     migrations_directory = os.path.dirname(writer.path)\n212                     if not directory_created.get(app_label):\n213                         os.makedirs(migrations_directory, exist_ok=True)\n214                         init_path = os.path.join(migrations_directory, \"__init__.py\")\n215                         if not os.path.isfile(init_path):\n216                             open(init_path, \"w\").close()\n217                         # We just do this once per app\n218                         directory_created[app_label] = True\n219                     migration_string = writer.as_string()\n220                     with open(writer.path, \"w\", encoding='utf-8') as fh:\n221                         fh.write(migration_string)\n222                 elif self.verbosity == 3:\n223                     # Alternatively, makemigrations --dry-run --verbosity 3\n224                     # will output the migrations to stdout rather than saving\n225                     # the file to the disk.\n226                     self.stdout.write(self.style.MIGRATE_HEADING(\n227                         \"Full migrations file '%s':\" % writer.filename\n228                     ))\n229                     self.stdout.write(writer.as_string())\n230 \n231     def handle_merge(self, loader, conflicts):\n232         \"\"\"\n233         Handles merging together conflicted migrations interactively,\n234         if it's safe; otherwise, advises on how to fix it.\n235         \"\"\"\n236         if self.interactive:\n237             questioner = InteractiveMigrationQuestioner()\n238         else:\n239             questioner = MigrationQuestioner(defaults={'ask_merge': True})\n240 \n241         for app_label, migration_names in conflicts.items():\n242             # Grab out the migrations in question, and work out their\n243             # common ancestor.\n244             merge_migrations = []\n245             for migration_name in migration_names:\n246                 migration = loader.get_migration(app_label, migration_name)\n247                 migration.ancestry = [\n248                     mig for mig in loader.graph.forwards_plan((app_label, migration_name))\n249                     if mig[0] == migration.app_label\n250                 ]\n251                 merge_migrations.append(migration)\n252 \n253             def all_items_equal(seq):\n254                 return all(item == seq[0] for item in seq[1:])\n255 \n256             merge_migrations_generations = zip(*(m.ancestry for m in merge_migrations))\n257             common_ancestor_count = sum(1 for common_ancestor_generation\n258                                         in takewhile(all_items_equal, merge_migrations_generations))\n259             if not common_ancestor_count:\n260                 raise ValueError(\"Could not find common ancestor of %s\" % migration_names)\n261             # Now work out the operations along each divergent branch\n262             for migration in merge_migrations:\n263                 migration.branch = migration.ancestry[common_ancestor_count:]\n264                 migrations_ops = (loader.get_migration(node_app, node_name).operations\n265                                   for node_app, node_name in migration.branch)\n266                 migration.merged_operations = sum(migrations_ops, [])\n267             # In future, this could use some of the Optimizer code\n268             # (can_optimize_through) to automatically see if they're\n269             # mergeable. For now, we always just prompt the user.\n270             if self.verbosity > 0:\n271                 self.stdout.write(self.style.MIGRATE_HEADING(\"Merging %s\" % app_label))\n272                 for migration in merge_migrations:\n273                     self.stdout.write(self.style.MIGRATE_LABEL(\"  Branch %s\" % migration.name))\n274                     for operation in migration.merged_operations:\n275                         self.stdout.write('    - %s' % operation.describe())\n276             if questioner.ask_merge(app_label):\n277                 # If they still want to merge it, then write out an empty\n278                 # file depending on the migrations needing merging.\n279                 numbers = [\n280                     MigrationAutodetector.parse_number(migration.name)\n281                     for migration in merge_migrations\n282                 ]\n283                 try:\n284                     biggest_number = max(x for x in numbers if x is not None)\n285                 except ValueError:\n286                     biggest_number = 1\n287                 subclass = type(\"Migration\", (Migration,), {\n288                     \"dependencies\": [(app_label, migration.name) for migration in merge_migrations],\n289                 })\n290                 migration_name = \"%04i_%s\" % (\n291                     biggest_number + 1,\n292                     self.migration_name or (\"merge_%s\" % get_migration_name_timestamp())\n293                 )\n294                 new_migration = subclass(migration_name, app_label)\n295                 writer = MigrationWriter(new_migration, self.include_header)\n296 \n297                 if not self.dry_run:\n298                     # Write the merge migrations file to the disk\n299                     with open(writer.path, \"w\", encoding='utf-8') as fh:\n300                         fh.write(writer.as_string())\n301                     if self.verbosity > 0:\n302                         self.stdout.write(\"\\nCreated new merge migration %s\" % writer.path)\n303                 elif self.verbosity == 3:\n304                     # Alternatively, makemigrations --merge --dry-run --verbosity 3\n305                     # will output the merge migrations to stdout rather than saving\n306                     # the file to the disk.\n307                     self.stdout.write(self.style.MIGRATE_HEADING(\n308                         \"Full merge migrations file '%s':\" % writer.filename\n309                     ))\n310                     self.stdout.write(writer.as_string())\n",
        "intended_behavior": "Introduce a new command-line flag (e.g., '--skip-checks' or '--no-database-check') that, when used, prevents the execution of 'loader.check_consistent_history(connection)'. This flag should be processed in the command's argument parsing section, and its state evaluated before the 'for alias in sorted(aliases_to_check):' loop. If the flag is active, the code should bypass the block of code that includes the call to 'check_consistent_history(connection)'. This keeps the default behavior intact while providing an escape hatch for cases where database consistency checks are not feasible or desired."
    }
]