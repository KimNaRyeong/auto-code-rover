2025-10-18 12:18:26.668 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 12:18:30.329 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=196, output_tokens=12, cost=0.002320
2025-10-18 12:18:30.330 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 12:18:30.334 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:18:38.779 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=501, output_tokens=348, cost=0.015450
2025-10-18 12:18:38.827 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:18:41.469 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=702, output_tokens=42, cost=0.008280
2025-10-18 12:18:41.470 | DEBUG    | Extracted a valid json.
2025-10-18 12:18:41.470 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"JSONField\")",
        "search_class(\"Admin\")",
        "search_code(\"json.dumps\")"
    ],
    "bug_locations": []
}
2025-10-18 12:18:41.543 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 12:18:41.543 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 12:18:55.957 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1453, output_tokens=676, cost=0.034810
2025-10-18 12:18:55.966 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:19:02.386 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2345, output_tokens=267, cost=0.031460
2025-10-18 12:19:02.392 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:19:11.413 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=621, output_tokens=284, cost=0.014730
2025-10-18 12:19:11.414 | DEBUG    | Extracted a valid json.
2025-10-18 12:19:11.414 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/models/fields/json.py",
            "class": "JSONField",
            "method": "",
            "intended_behavior": "The `JSONField` class in this file should ensure that when it serializes model field data to JSON for storage or for display (including in the Django admin), it does so in a way that preserves non-ASCII characters like Chinese in their original form. This might involve modifying serialization logic to include `json.dumps` with `ensure_ascii=False`. This change must be done in a way that does not interfere with the existing functionality of storing and retrieving JSON data, including compatibility with databases and the Django ORM's expectations."
        },
        {
            "file": "django/contrib/admin/widgets.py",
            "class": "",
            "method": "",
            "intended_behavior": "In any method or function within this file where `json.dumps` is used to prepare `JSONField` data for display in the admin interface, the function call should be modified to use `json.dumps(ensure_ascii=False)`. This ensures that Unicode characters are correctly displayed in their original form within the Django admin. The rest of the admin interface's functionality, including any validation, storage, and retrieval of `JSONField` data, should remain unaffected by this change."
        }
    ]
}
2025-10-18 12:19:11.420 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/json.py</file>
<class>JSONField</class>
<method>None</method>
<code>
16 class JSONField(CheckFieldDefaultMixin, Field):
17     empty_strings_allowed = False
18     description = _('A JSON object')
19     default_error_messages = {
20         'invalid': _('Value must be valid JSON.'),
21     }
22     _default_hint = ('dict', '{}')
23 
24     def __init__(
25         self, verbose_name=None, name=None, encoder=None, decoder=None,
26         **kwargs,
27     ):
28         if encoder and not callable(encoder):
29             raise ValueError('The encoder parameter must be a callable object.')
30         if decoder and not callable(decoder):
31             raise ValueError('The decoder parameter must be a callable object.')
32         self.encoder = encoder
33         self.decoder = decoder
34         super().__init__(verbose_name, name, **kwargs)
35 
36     def check(self, **kwargs):
37         errors = super().check(**kwargs)
38         databases = kwargs.get('databases') or []
39         errors.extend(self._check_supported(databases))
40         return errors
41 
42     def _check_supported(self, databases):
43         errors = []
44         for db in databases:
45             if not router.allow_migrate_model(db, self.model):
46                 continue
47             connection = connections[db]
48             if not (
49                 'supports_json_field' in self.model._meta.required_db_features or
50                 connection.features.supports_json_field
51             ):
52                 errors.append(
53                     checks.Error(
54                         '%s does not support JSONFields.'
55                         % connection.display_name,
56                         obj=self.model,
57                         id='fields.E180',
58                     )
59                 )
60         return errors
61 
62     def deconstruct(self):
63         name, path, args, kwargs = super().deconstruct()
64         if self.encoder is not None:
65             kwargs['encoder'] = self.encoder
66         if self.decoder is not None:
67             kwargs['decoder'] = self.decoder
68         return name, path, args, kwargs
69 
70     def from_db_value(self, value, expression, connection):
71         if value is None:
72             return value
73         try:
74             return json.loads(value, cls=self.decoder)
75         except json.JSONDecodeError:
76             return value
77 
78     def get_internal_type(self):
79         return 'JSONField'
80 
81     def get_prep_value(self, value):
82         if value is None:
83             return value
84         return json.dumps(value, cls=self.encoder)
85 
86     def get_transform(self, name):
87         transform = super().get_transform(name)
88         if transform:
89             return transform
90         return KeyTransformFactory(name)
91 
92     def validate(self, value, model_instance):
93         super().validate(value, model_instance)
94         try:
95             json.dumps(value, cls=self.encoder)
96         except TypeError:
97             raise exceptions.ValidationError(
98                 self.error_messages['invalid'],
99                 code='invalid',
100                 params={'value': value},
101             )
102 
103     def value_to_string(self, obj):
104         return self.value_from_object(obj)
105 
106     def formfield(self, **kwargs):
107         return super().formfield(**{
108             'form_class': forms.JSONField,
109             'encoder': self.encoder,
110             'decoder': self.decoder,
111             **kwargs,
112         })

</code><intended_behavior>The `JSONField` class in this file should ensure that when it serializes model field data to JSON for storage or for display (including in the Django admin), it does so in a way that preserves non-ASCII characters like Chinese in their original form. This might involve modifying serialization logic to include `json.dumps` with `ensure_ascii=False`. This change must be done in a way that does not interfere with the existing functionality of storing and retrieving JSON data, including compatibility with databases and the Django ORM's expectations.</intended_behavior>, <file>django/contrib/admin/widgets.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Form Widget classes specific to the Django admin site.
3 """
4 import copy
5 import json
6 
7 from django import forms
8 from django.conf import settings
9 from django.core.exceptions import ValidationError
10 from django.core.validators import URLValidator
11 from django.db.models import CASCADE
12 from django.urls import reverse
13 from django.urls.exceptions import NoReverseMatch
14 from django.utils.html import smart_urlquote
15 from django.utils.http import urlencode
16 from django.utils.text import Truncator
17 from django.utils.translation import get_language, gettext as _
18 
19 
20 class FilteredSelectMultiple(forms.SelectMultiple):
21     """
22     A SelectMultiple with a JavaScript filter interface.
23 
24     Note that the resulting JavaScript assumes that the jsi18n
25     catalog has been loaded in the page
26     """
27     class Media:
28         js = [
29             'admin/js/core.js',
30             'admin/js/SelectBox.js',
31             'admin/js/SelectFilter2.js',
32         ]
33 
34     def __init__(self, verbose_name, is_stacked, attrs=None, choices=()):
35         self.verbose_name = verbose_name
36         self.is_stacked = is_stacked
37         super().__init__(attrs, choices)
38 
39     def get_context(self, name, value, attrs):
40         context = super().get_context(name, value, attrs)
41         context['widget']['attrs']['class'] = 'selectfilter'
42         if self.is_stacked:
43             context['widget']['attrs']['class'] += 'stacked'
44         context['widget']['attrs']['data-field-name'] = self.verbose_name
45         context['widget']['attrs']['data-is-stacked'] = int(self.is_stacked)
46         return context
47 
48 
49 class AdminDateWidget(forms.DateInput):
50     class Media:
51         js = [
52             'admin/js/calendar.js',
53             'admin/js/admin/DateTimeShortcuts.js',
54         ]
55 
56     def __init__(self, attrs=None, format=None):
57         attrs = {'class': 'vDateField', 'size': '10', **(attrs or {})}
58         super().__init__(attrs=attrs, format=format)
59 
60 
61 class AdminTimeWidget(forms.TimeInput):
62     class Media:
63         js = [
64             'admin/js/calendar.js',
65             'admin/js/admin/DateTimeShortcuts.js',
66         ]
67 
68     def __init__(self, attrs=None, format=None):
69         attrs = {'class': 'vTimeField', 'size': '8', **(attrs or {})}
70         super().__init__(attrs=attrs, format=format)
71 
72 
73 class AdminSplitDateTime(forms.SplitDateTimeWidget):
74     """
75     A SplitDateTime Widget that has some admin-specific styling.
76     """
77     template_name = 'admin/widgets/split_datetime.html'
78 
79     def __init__(self, attrs=None):
80         widgets = [AdminDateWidget, AdminTimeWidget]
81         # Note that we're calling MultiWidget, not SplitDateTimeWidget, because
82         # we want to define widgets.
83         forms.MultiWidget.__init__(self, widgets, attrs)
84 
85     def get_context(self, name, value, attrs):
86         context = super().get_context(name, value, attrs)
87         context['date_label'] = _('Date:')
88         context['time_label'] = _('Time:')
89         return context
90 
91 
92 class AdminRadioSelect(forms.RadioSelect):
93     template_name = 'admin/widgets/radio.html'
94 
95 
96 class AdminFileWidget(forms.ClearableFileInput):
97     template_name = 'admin/widgets/clearable_file_input.html'
98 
99 
100 def url_params_from_lookup_dict(lookups):
101     """
102     Convert the type of lookups specified in a ForeignKey limit_choices_to
103     attribute to a dictionary of query parameters
104     """
105     params = {}
106     if lookups and hasattr(lookups, 'items'):
107         for k, v in lookups.items():
108             if callable(v):
109                 v = v()
110             if isinstance(v, (tuple, list)):
111                 v = ','.join(str(x) for x in v)
112             elif isinstance(v, bool):
113                 v = ('0', '1')[v]
114             else:
115                 v = str(v)
116             params[k] = v
117     return params
118 
119 
120 class ForeignKeyRawIdWidget(forms.TextInput):
121     """
122     A Widget for displaying ForeignKeys in the "raw_id" interface rather than
123     in a <select> box.
124     """
125     template_name = 'admin/widgets/foreign_key_raw_id.html'
126 
127     def __init__(self, rel, admin_site, attrs=None, using=None):
128         self.rel = rel
129         self.admin_site = admin_site
130         self.db = using
131         super().__init__(attrs)
132 
133     def get_context(self, name, value, attrs):
134         context = super().get_context(name, value, attrs)
135         rel_to = self.rel.model
136         if rel_to in self.admin_site._registry:
137             # The related object is registered with the same AdminSite
138             related_url = reverse(
139                 'admin:%s_%s_changelist' % (
140                     rel_to._meta.app_label,
141                     rel_to._meta.model_name,
142                 ),
143                 current_app=self.admin_site.name,
144             )
145 
146             params = self.url_parameters()
147             if params:
148                 related_url += '?' + urlencode(params)
149             context['related_url'] = related_url
150             context['link_title'] = _('Lookup')
151             # The JavaScript code looks for this class.
152             context['widget']['attrs'].setdefault('class', 'vForeignKeyRawIdAdminField')
153         else:
154             context['related_url'] = None
155         if context['widget']['value']:
156             context['link_label'], context['link_url'] = self.label_and_url_for_value(value)
157         else:
158             context['link_label'] = None
159         return context
160 
161     def base_url_parameters(self):
162         limit_choices_to = self.rel.limit_choices_to
163         if callable(limit_choices_to):
164             limit_choices_to = limit_choices_to()
165         return url_params_from_lookup_dict(limit_choices_to)
166 
167     def url_parameters(self):
168         from django.contrib.admin.views.main import TO_FIELD_VAR
169         params = self.base_url_parameters()
170         params.update({TO_FIELD_VAR: self.rel.get_related_field().name})
171         return params
172 
173     def label_and_url_for_value(self, value):
174         key = self.rel.get_related_field().name
175         try:
176             obj = self.rel.model._default_manager.using(self.db).get(**{key: value})
177         except (ValueError, self.rel.model.DoesNotExist, ValidationError):
178             return '', ''
179 
180         try:
181             url = reverse(
182                 '%s:%s_%s_change' % (
183                     self.admin_site.name,
184                     obj._meta.app_label,
185                     obj._meta.object_name.lower(),
186                 ),
187                 args=(obj.pk,)
188             )
189         except NoReverseMatch:
190             url = ''  # Admin not registered for target model.
191 
192         return Truncator(obj).words(14), url
193 
194 
195 class ManyToManyRawIdWidget(ForeignKeyRawIdWidget):
196     """
197     A Widget for displaying ManyToMany ids in the "raw_id" interface rather than
198     in a <select multiple> box.
199     """
200     template_name = 'admin/widgets/many_to_many_raw_id.html'
201 
202     def get_context(self, name, value, attrs):
203         context = super().get_context(name, value, attrs)
204         if self.rel.model in self.admin_site._registry:
205             # The related object is registered with the same AdminSite
206             context['widget']['attrs']['class'] = 'vManyToManyRawIdAdminField'
207         return context
208 
209     def url_parameters(self):
210         return self.base_url_parameters()
211 
212     def label_and_url_for_value(self, value):
213         return '', ''
214 
215     def value_from_datadict(self, data, files, name):
216         value = data.get(name)
217         if value:
218             return value.split(',')
219 
220     def format_value(self, value):
221         return ','.join(str(v) for v in value) if value else ''
222 
223 
224 class RelatedFieldWidgetWrapper(forms.Widget):
225     """
226     This class is a wrapper to a given widget to add the add icon for the
227     admin interface.
228     """
229     template_name = 'admin/widgets/related_widget_wrapper.html'
230 
231     def __init__(self, widget, rel, admin_site, can_add_related=None,
232                  can_change_related=False, can_delete_related=False,
233                  can_view_related=False):
234         self.needs_multipart_form = widget.needs_multipart_form
235         self.attrs = widget.attrs
236         self.choices = widget.choices
237         self.widget = widget
238         self.rel = rel
239         # Backwards compatible check for whether a user can add related
240         # objects.
241         if can_add_related is None:
242             can_add_related = rel.model in admin_site._registry
243         self.can_add_related = can_add_related
244         # XXX: The UX does not support multiple selected values.
245         multiple = getattr(widget, 'allow_multiple_selected', False)
246         self.can_change_related = not multiple and can_change_related
247         # XXX: The deletion UX can be confusing when dealing with cascading deletion.
248         cascade = getattr(rel, 'on_delete', None) is CASCADE
249         self.can_delete_related = not multiple and not cascade and can_delete_related
250         self.can_view_related = not multiple and can_view_related
251         # so we can check if the related object is registered with this AdminSite
252         self.admin_site = admin_site
253 
254     def __deepcopy__(self, memo):
255         obj = copy.copy(self)
256         obj.widget = copy.deepcopy(self.widget, memo)
257         obj.attrs = self.widget.attrs
258         memo[id(self)] = obj
259         return obj
260 
261     @property
262     def is_hidden(self):
263         return self.widget.is_hidden
264 
265     @property
266     def media(self):
267         return self.widget.media
268 
269     def get_related_url(self, info, action, *args):
270         return reverse("admin:%s_%s_%s" % (info + (action,)),
271                        current_app=self.admin_site.name, args=args)
272 
273     def get_context(self, name, value, attrs):
274         from django.contrib.admin.views.main import IS_POPUP_VAR, TO_FIELD_VAR
275         rel_opts = self.rel.model._meta
276         info = (rel_opts.app_label, rel_opts.model_name)
277         self.widget.choices = self.choices
278         url_params = '&'.join("%s=%s" % param for param in [
279             (TO_FIELD_VAR, self.rel.get_related_field().name),
280             (IS_POPUP_VAR, 1),
281         ])
282         context = {
283             'rendered_widget': self.widget.render(name, value, attrs),
284             'is_hidden': self.is_hidden,
285             'name': name,
286             'url_params': url_params,
287             'model': rel_opts.verbose_name,
288             'can_add_related': self.can_add_related,
289             'can_change_related': self.can_change_related,
290             'can_delete_related': self.can_delete_related,
291             'can_view_related': self.can_view_related,
292         }
293         if self.can_add_related:
294             context['add_related_url'] = self.get_related_url(info, 'add')
295         if self.can_delete_related:
296             context['delete_related_template_url'] = self.get_related_url(info, 'delete', '__fk__')
297         if self.can_view_related or self.can_change_related:
298             context['change_related_template_url'] = self.get_related_url(info, 'change', '__fk__')
299         return context
300 
301     def value_from_datadict(self, data, files, name):
302         return self.widget.value_from_datadict(data, files, name)
303 
304     def value_omitted_from_data(self, data, files, name):
305         return self.widget.value_omitted_from_data(data, files, name)
306 
307     def id_for_label(self, id_):
308         return self.widget.id_for_label(id_)
309 
310 
311 class AdminTextareaWidget(forms.Textarea):
312     def __init__(self, attrs=None):
313         super().__init__(attrs={'class': 'vLargeTextField', **(attrs or {})})
314 
315 
316 class AdminTextInputWidget(forms.TextInput):
317     def __init__(self, attrs=None):
318         super().__init__(attrs={'class': 'vTextField', **(attrs or {})})
319 
320 
321 class AdminEmailInputWidget(forms.EmailInput):
322     def __init__(self, attrs=None):
323         super().__init__(attrs={'class': 'vTextField', **(attrs or {})})
324 
325 
326 class AdminURLFieldWidget(forms.URLInput):
327     template_name = 'admin/widgets/url.html'
328 
329     def __init__(self, attrs=None, validator_class=URLValidator):
330         super().__init__(attrs={'class': 'vURLField', **(attrs or {})})
331         self.validator = validator_class()
332 
333     def get_context(self, name, value, attrs):
334         try:
335             self.validator(value if value else '')
336             url_valid = True
337         except ValidationError:
338             url_valid = False
339         context = super().get_context(name, value, attrs)
340         context['current_label'] = _('Currently:')
341         context['change_label'] = _('Change:')
342         context['widget']['href'] = smart_urlquote(context['widget']['value']) if value else ''
343         context['url_valid'] = url_valid
344         return context
345 
346 
347 class AdminIntegerFieldWidget(forms.NumberInput):
348     class_name = 'vIntegerField'
349 
350     def __init__(self, attrs=None):
351         super().__init__(attrs={'class': self.class_name, **(attrs or {})})
352 
353 
354 class AdminBigIntegerFieldWidget(AdminIntegerFieldWidget):
355     class_name = 'vBigIntegerField'
356 
357 
358 class AdminUUIDInputWidget(forms.TextInput):
359     def __init__(self, attrs=None):
360         super().__init__(attrs={'class': 'vUUIDField', **(attrs or {})})
361 
362 
363 # Mapping of lowercase language codes [returned by Django's get_language()] to
364 # language codes supported by select2.
365 # See django/contrib/admin/static/admin/js/vendor/select2/i18n/*
366 SELECT2_TRANSLATIONS = {x.lower(): x for x in [
367     'ar', 'az', 'bg', 'ca', 'cs', 'da', 'de', 'el', 'en', 'es', 'et',
368     'eu', 'fa', 'fi', 'fr', 'gl', 'he', 'hi', 'hr', 'hu', 'id', 'is',
369     'it', 'ja', 'km', 'ko', 'lt', 'lv', 'mk', 'ms', 'nb', 'nl', 'pl',
370     'pt-BR', 'pt', 'ro', 'ru', 'sk', 'sr-Cyrl', 'sr', 'sv', 'th',
371     'tr', 'uk', 'vi',
372 ]}
373 SELECT2_TRANSLATIONS.update({'zh-hans': 'zh-CN', 'zh-hant': 'zh-TW'})
374 
375 
376 class AutocompleteMixin:
377     """
378     Select widget mixin that loads options from AutocompleteJsonView via AJAX.
379 
380     Renders the necessary data attributes for select2 and adds the static form
381     media.
382     """
383     url_name = '%s:%s_%s_autocomplete'
384 
385     def __init__(self, rel, admin_site, attrs=None, choices=(), using=None):
386         self.rel = rel
387         self.admin_site = admin_site
388         self.db = using
389         self.choices = choices
390         self.attrs = {} if attrs is None else attrs.copy()
391 
392     def get_url(self):
393         model = self.rel.model
394         return reverse(self.url_name % (self.admin_site.name, model._meta.app_label, model._meta.model_name))
395 
396     def build_attrs(self, base_attrs, extra_attrs=None):
397         """
398         Set select2's AJAX attributes.
399 
400         Attributes can be set using the html5 data attribute.
401         Nested attributes require a double dash as per
402         https://select2.org/configuration/data-attributes#nested-subkey-options
403         """
404         attrs = super().build_attrs(base_attrs, extra_attrs=extra_attrs)
405         attrs.setdefault('class', '')
406         attrs.update({
407             'data-ajax--cache': 'true',
408             'data-ajax--delay': 250,
409             'data-ajax--type': 'GET',
410             'data-ajax--url': self.get_url(),
411             'data-theme': 'admin-autocomplete',
412             'data-allow-clear': json.dumps(not self.is_required),
413             'data-placeholder': '',  # Allows clearing of the input.
414             'class': attrs['class'] + (' ' if attrs['class'] else '') + 'admin-autocomplete',
415         })
416         return attrs
417 
418     def optgroups(self, name, value, attr=None):
419         """Return selected options based on the ModelChoiceIterator."""
420         default = (None, [], 0)
421         groups = [default]
422         has_selected = False
423         selected_choices = {
424             str(v) for v in value
425             if str(v) not in self.choices.field.empty_values
426         }
427         if not self.is_required and not self.allow_multiple_selected:
428             default[1].append(self.create_option(name, '', '', False, 0))
429         choices = (
430             (obj.pk, self.choices.field.label_from_instance(obj))
431             for obj in self.choices.queryset.using(self.db).filter(pk__in=selected_choices)
432         )
433         for option_value, option_label in choices:
434             selected = (
435                 str(option_value) in value and
436                 (has_selected is False or self.allow_multiple_selected)
437             )
438             has_selected |= selected
439             index = len(default[1])
440             subgroup = default[1]
441             subgroup.append(self.create_option(name, option_value, option_label, selected_choices, index))
442         return groups
443 
444     @property
445     def media(self):
446         extra = '' if settings.DEBUG else '.min'
447         i18n_name = SELECT2_TRANSLATIONS.get(get_language())
448         i18n_file = ('admin/js/vendor/select2/i18n/%s.js' % i18n_name,) if i18n_name else ()
449         return forms.Media(
450             js=(
451                 'admin/js/vendor/jquery/jquery%s.js' % extra,
452                 'admin/js/vendor/select2/select2.full%s.js' % extra,
453             ) + i18n_file + (
454                 'admin/js/jquery.init.js',
455                 'admin/js/autocomplete.js',
456             ),
457             css={
458                 'screen': (
459                     'admin/css/vendor/select2/select2%s.css' % extra,
460                     'admin/css/autocomplete.css',
461                 ),
462             },
463         )
464 
465 
466 class AutocompleteSelect(AutocompleteMixin, forms.Select):
467     pass
468 
469 
470 class AutocompleteSelectMultiple(AutocompleteMixin, forms.SelectMultiple):
471     pass

</code><intended_behavior>In any method or function within this file where `json.dumps` is used to prepare `JSONField` data for display in the admin interface, the function call should be modified to use `json.dumps(ensure_ascii=False)`. This ensures that Unicode characters are correctly displayed in their original form within the Django admin. The rest of the admin interface's functionality, including any validation, storage, and retrieval of `JSONField` data, should remain unaffected by this change.</intended_behavior>]
2025-10-18 12:19:11.421 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/json.py</file>
<class>JSONField</class>
<method>None</method>
<code>
16 class JSONField(CheckFieldDefaultMixin, Field):
17     empty_strings_allowed = False
18     description = _('A JSON object')
19     default_error_messages = {
20         'invalid': _('Value must be valid JSON.'),
21     }
22     _default_hint = ('dict', '{}')
23 
24     def __init__(
25         self, verbose_name=None, name=None, encoder=None, decoder=None,
26         **kwargs,
27     ):
28         if encoder and not callable(encoder):
29             raise ValueError('The encoder parameter must be a callable object.')
30         if decoder and not callable(decoder):
31             raise ValueError('The decoder parameter must be a callable object.')
32         self.encoder = encoder
33         self.decoder = decoder
34         super().__init__(verbose_name, name, **kwargs)
35 
36     def check(self, **kwargs):
37         errors = super().check(**kwargs)
38         databases = kwargs.get('databases') or []
39         errors.extend(self._check_supported(databases))
40         return errors
41 
42     def _check_supported(self, databases):
43         errors = []
44         for db in databases:
45             if not router.allow_migrate_model(db, self.model):
46                 continue
47             connection = connections[db]
48             if not (
49                 'supports_json_field' in self.model._meta.required_db_features or
50                 connection.features.supports_json_field
51             ):
52                 errors.append(
53                     checks.Error(
54                         '%s does not support JSONFields.'
55                         % connection.display_name,
56                         obj=self.model,
57                         id='fields.E180',
58                     )
59                 )
60         return errors
61 
62     def deconstruct(self):
63         name, path, args, kwargs = super().deconstruct()
64         if self.encoder is not None:
65             kwargs['encoder'] = self.encoder
66         if self.decoder is not None:
67             kwargs['decoder'] = self.decoder
68         return name, path, args, kwargs
69 
70     def from_db_value(self, value, expression, connection):
71         if value is None:
72             return value
73         try:
74             return json.loads(value, cls=self.decoder)
75         except json.JSONDecodeError:
76             return value
77 
78     def get_internal_type(self):
79         return 'JSONField'
80 
81     def get_prep_value(self, value):
82         if value is None:
83             return value
84         return json.dumps(value, cls=self.encoder)
85 
86     def get_transform(self, name):
87         transform = super().get_transform(name)
88         if transform:
89             return transform
90         return KeyTransformFactory(name)
91 
92     def validate(self, value, model_instance):
93         super().validate(value, model_instance)
94         try:
95             json.dumps(value, cls=self.encoder)
96         except TypeError:
97             raise exceptions.ValidationError(
98                 self.error_messages['invalid'],
99                 code='invalid',
100                 params={'value': value},
101             )
102 
103     def value_to_string(self, obj):
104         return self.value_from_object(obj)
105 
106     def formfield(self, **kwargs):
107         return super().formfield(**{
108             'form_class': forms.JSONField,
109             'encoder': self.encoder,
110             'decoder': self.decoder,
111             **kwargs,
112         })

</code><intended_behavior>The `JSONField` class in this file should ensure that when it serializes model field data to JSON for storage or for display (including in the Django admin), it does so in a way that preserves non-ASCII characters like Chinese in their original form. This might involve modifying serialization logic to include `json.dumps` with `ensure_ascii=False`. This change must be done in a way that does not interfere with the existing functionality of storing and retrieving JSON data, including compatibility with databases and the Django ORM's expectations.</intended_behavior>, <file>django/contrib/admin/widgets.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Form Widget classes specific to the Django admin site.
3 """
4 import copy
5 import json
6 
7 from django import forms
8 from django.conf import settings
9 from django.core.exceptions import ValidationError
10 from django.core.validators import URLValidator
11 from django.db.models import CASCADE
12 from django.urls import reverse
13 from django.urls.exceptions import NoReverseMatch
14 from django.utils.html import smart_urlquote
15 from django.utils.http import urlencode
16 from django.utils.text import Truncator
17 from django.utils.translation import get_language, gettext as _
18 
19 
20 class FilteredSelectMultiple(forms.SelectMultiple):
21     """
22     A SelectMultiple with a JavaScript filter interface.
23 
24     Note that the resulting JavaScript assumes that the jsi18n
25     catalog has been loaded in the page
26     """
27     class Media:
28         js = [
29             'admin/js/core.js',
30             'admin/js/SelectBox.js',
31             'admin/js/SelectFilter2.js',
32         ]
33 
34     def __init__(self, verbose_name, is_stacked, attrs=None, choices=()):
35         self.verbose_name = verbose_name
36         self.is_stacked = is_stacked
37         super().__init__(attrs, choices)
38 
39     def get_context(self, name, value, attrs):
40         context = super().get_context(name, value, attrs)
41         context['widget']['attrs']['class'] = 'selectfilter'
42         if self.is_stacked:
43             context['widget']['attrs']['class'] += 'stacked'
44         context['widget']['attrs']['data-field-name'] = self.verbose_name
45         context['widget']['attrs']['data-is-stacked'] = int(self.is_stacked)
46         return context
47 
48 
49 class AdminDateWidget(forms.DateInput):
50     class Media:
51         js = [
52             'admin/js/calendar.js',
53             'admin/js/admin/DateTimeShortcuts.js',
54         ]
55 
56     def __init__(self, attrs=None, format=None):
57         attrs = {'class': 'vDateField', 'size': '10', **(attrs or {})}
58         super().__init__(attrs=attrs, format=format)
59 
60 
61 class AdminTimeWidget(forms.TimeInput):
62     class Media:
63         js = [
64             'admin/js/calendar.js',
65             'admin/js/admin/DateTimeShortcuts.js',
66         ]
67 
68     def __init__(self, attrs=None, format=None):
69         attrs = {'class': 'vTimeField', 'size': '8', **(attrs or {})}
70         super().__init__(attrs=attrs, format=format)
71 
72 
73 class AdminSplitDateTime(forms.SplitDateTimeWidget):
74     """
75     A SplitDateTime Widget that has some admin-specific styling.
76     """
77     template_name = 'admin/widgets/split_datetime.html'
78 
79     def __init__(self, attrs=None):
80         widgets = [AdminDateWidget, AdminTimeWidget]
81         # Note that we're calling MultiWidget, not SplitDateTimeWidget, because
82         # we want to define widgets.
83         forms.MultiWidget.__init__(self, widgets, attrs)
84 
85     def get_context(self, name, value, attrs):
86         context = super().get_context(name, value, attrs)
87         context['date_label'] = _('Date:')
88         context['time_label'] = _('Time:')
89         return context
90 
91 
92 class AdminRadioSelect(forms.RadioSelect):
93     template_name = 'admin/widgets/radio.html'
94 
95 
96 class AdminFileWidget(forms.ClearableFileInput):
97     template_name = 'admin/widgets/clearable_file_input.html'
98 
99 
100 def url_params_from_lookup_dict(lookups):
101     """
102     Convert the type of lookups specified in a ForeignKey limit_choices_to
103     attribute to a dictionary of query parameters
104     """
105     params = {}
106     if lookups and hasattr(lookups, 'items'):
107         for k, v in lookups.items():
108             if callable(v):
109                 v = v()
110             if isinstance(v, (tuple, list)):
111                 v = ','.join(str(x) for x in v)
112             elif isinstance(v, bool):
113                 v = ('0', '1')[v]
114             else:
115                 v = str(v)
116             params[k] = v
117     return params
118 
119 
120 class ForeignKeyRawIdWidget(forms.TextInput):
121     """
122     A Widget for displaying ForeignKeys in the "raw_id" interface rather than
123     in a <select> box.
124     """
125     template_name = 'admin/widgets/foreign_key_raw_id.html'
126 
127     def __init__(self, rel, admin_site, attrs=None, using=None):
128         self.rel = rel
129         self.admin_site = admin_site
130         self.db = using
131         super().__init__(attrs)
132 
133     def get_context(self, name, value, attrs):
134         context = super().get_context(name, value, attrs)
135         rel_to = self.rel.model
136         if rel_to in self.admin_site._registry:
137             # The related object is registered with the same AdminSite
138             related_url = reverse(
139                 'admin:%s_%s_changelist' % (
140                     rel_to._meta.app_label,
141                     rel_to._meta.model_name,
142                 ),
143                 current_app=self.admin_site.name,
144             )
145 
146             params = self.url_parameters()
147             if params:
148                 related_url += '?' + urlencode(params)
149             context['related_url'] = related_url
150             context['link_title'] = _('Lookup')
151             # The JavaScript code looks for this class.
152             context['widget']['attrs'].setdefault('class', 'vForeignKeyRawIdAdminField')
153         else:
154             context['related_url'] = None
155         if context['widget']['value']:
156             context['link_label'], context['link_url'] = self.label_and_url_for_value(value)
157         else:
158             context['link_label'] = None
159         return context
160 
161     def base_url_parameters(self):
162         limit_choices_to = self.rel.limit_choices_to
163         if callable(limit_choices_to):
164             limit_choices_to = limit_choices_to()
165         return url_params_from_lookup_dict(limit_choices_to)
166 
167     def url_parameters(self):
168         from django.contrib.admin.views.main import TO_FIELD_VAR
169         params = self.base_url_parameters()
170         params.update({TO_FIELD_VAR: self.rel.get_related_field().name})
171         return params
172 
173     def label_and_url_for_value(self, value):
174         key = self.rel.get_related_field().name
175         try:
176             obj = self.rel.model._default_manager.using(self.db).get(**{key: value})
177         except (ValueError, self.rel.model.DoesNotExist, ValidationError):
178             return '', ''
179 
180         try:
181             url = reverse(
182                 '%s:%s_%s_change' % (
183                     self.admin_site.name,
184                     obj._meta.app_label,
185                     obj._meta.object_name.lower(),
186                 ),
187                 args=(obj.pk,)
188             )
189         except NoReverseMatch:
190             url = ''  # Admin not registered for target model.
191 
192         return Truncator(obj).words(14), url
193 
194 
195 class ManyToManyRawIdWidget(ForeignKeyRawIdWidget):
196     """
197     A Widget for displaying ManyToMany ids in the "raw_id" interface rather than
198     in a <select multiple> box.
199     """
200     template_name = 'admin/widgets/many_to_many_raw_id.html'
201 
202     def get_context(self, name, value, attrs):
203         context = super().get_context(name, value, attrs)
204         if self.rel.model in self.admin_site._registry:
205             # The related object is registered with the same AdminSite
206             context['widget']['attrs']['class'] = 'vManyToManyRawIdAdminField'
207         return context
208 
209     def url_parameters(self):
210         return self.base_url_parameters()
211 
212     def label_and_url_for_value(self, value):
213         return '', ''
214 
215     def value_from_datadict(self, data, files, name):
216         value = data.get(name)
217         if value:
218             return value.split(',')
219 
220     def format_value(self, value):
221         return ','.join(str(v) for v in value) if value else ''
222 
223 
224 class RelatedFieldWidgetWrapper(forms.Widget):
225     """
226     This class is a wrapper to a given widget to add the add icon for the
227     admin interface.
228     """
229     template_name = 'admin/widgets/related_widget_wrapper.html'
230 
231     def __init__(self, widget, rel, admin_site, can_add_related=None,
232                  can_change_related=False, can_delete_related=False,
233                  can_view_related=False):
234         self.needs_multipart_form = widget.needs_multipart_form
235         self.attrs = widget.attrs
236         self.choices = widget.choices
237         self.widget = widget
238         self.rel = rel
239         # Backwards compatible check for whether a user can add related
240         # objects.
241         if can_add_related is None:
242             can_add_related = rel.model in admin_site._registry
243         self.can_add_related = can_add_related
244         # XXX: The UX does not support multiple selected values.
245         multiple = getattr(widget, 'allow_multiple_selected', False)
246         self.can_change_related = not multiple and can_change_related
247         # XXX: The deletion UX can be confusing when dealing with cascading deletion.
248         cascade = getattr(rel, 'on_delete', None) is CASCADE
249         self.can_delete_related = not multiple and not cascade and can_delete_related
250         self.can_view_related = not multiple and can_view_related
251         # so we can check if the related object is registered with this AdminSite
252         self.admin_site = admin_site
253 
254     def __deepcopy__(self, memo):
255         obj = copy.copy(self)
256         obj.widget = copy.deepcopy(self.widget, memo)
257         obj.attrs = self.widget.attrs
258         memo[id(self)] = obj
259         return obj
260 
261     @property
262     def is_hidden(self):
263         return self.widget.is_hidden
264 
265     @property
266     def media(self):
267         return self.widget.media
268 
269     def get_related_url(self, info, action, *args):
270         return reverse("admin:%s_%s_%s" % (info + (action,)),
271                        current_app=self.admin_site.name, args=args)
272 
273     def get_context(self, name, value, attrs):
274         from django.contrib.admin.views.main import IS_POPUP_VAR, TO_FIELD_VAR
275         rel_opts = self.rel.model._meta
276         info = (rel_opts.app_label, rel_opts.model_name)
277         self.widget.choices = self.choices
278         url_params = '&'.join("%s=%s" % param for param in [
279             (TO_FIELD_VAR, self.rel.get_related_field().name),
280             (IS_POPUP_VAR, 1),
281         ])
282         context = {
283             'rendered_widget': self.widget.render(name, value, attrs),
284             'is_hidden': self.is_hidden,
285             'name': name,
286             'url_params': url_params,
287             'model': rel_opts.verbose_name,
288             'can_add_related': self.can_add_related,
289             'can_change_related': self.can_change_related,
290             'can_delete_related': self.can_delete_related,
291             'can_view_related': self.can_view_related,
292         }
293         if self.can_add_related:
294             context['add_related_url'] = self.get_related_url(info, 'add')
295         if self.can_delete_related:
296             context['delete_related_template_url'] = self.get_related_url(info, 'delete', '__fk__')
297         if self.can_view_related or self.can_change_related:
298             context['change_related_template_url'] = self.get_related_url(info, 'change', '__fk__')
299         return context
300 
301     def value_from_datadict(self, data, files, name):
302         return self.widget.value_from_datadict(data, files, name)
303 
304     def value_omitted_from_data(self, data, files, name):
305         return self.widget.value_omitted_from_data(data, files, name)
306 
307     def id_for_label(self, id_):
308         return self.widget.id_for_label(id_)
309 
310 
311 class AdminTextareaWidget(forms.Textarea):
312     def __init__(self, attrs=None):
313         super().__init__(attrs={'class': 'vLargeTextField', **(attrs or {})})
314 
315 
316 class AdminTextInputWidget(forms.TextInput):
317     def __init__(self, attrs=None):
318         super().__init__(attrs={'class': 'vTextField', **(attrs or {})})
319 
320 
321 class AdminEmailInputWidget(forms.EmailInput):
322     def __init__(self, attrs=None):
323         super().__init__(attrs={'class': 'vTextField', **(attrs or {})})
324 
325 
326 class AdminURLFieldWidget(forms.URLInput):
327     template_name = 'admin/widgets/url.html'
328 
329     def __init__(self, attrs=None, validator_class=URLValidator):
330         super().__init__(attrs={'class': 'vURLField', **(attrs or {})})
331         self.validator = validator_class()
332 
333     def get_context(self, name, value, attrs):
334         try:
335             self.validator(value if value else '')
336             url_valid = True
337         except ValidationError:
338             url_valid = False
339         context = super().get_context(name, value, attrs)
340         context['current_label'] = _('Currently:')
341         context['change_label'] = _('Change:')
342         context['widget']['href'] = smart_urlquote(context['widget']['value']) if value else ''
343         context['url_valid'] = url_valid
344         return context
345 
346 
347 class AdminIntegerFieldWidget(forms.NumberInput):
348     class_name = 'vIntegerField'
349 
350     def __init__(self, attrs=None):
351         super().__init__(attrs={'class': self.class_name, **(attrs or {})})
352 
353 
354 class AdminBigIntegerFieldWidget(AdminIntegerFieldWidget):
355     class_name = 'vBigIntegerField'
356 
357 
358 class AdminUUIDInputWidget(forms.TextInput):
359     def __init__(self, attrs=None):
360         super().__init__(attrs={'class': 'vUUIDField', **(attrs or {})})
361 
362 
363 # Mapping of lowercase language codes [returned by Django's get_language()] to
364 # language codes supported by select2.
365 # See django/contrib/admin/static/admin/js/vendor/select2/i18n/*
366 SELECT2_TRANSLATIONS = {x.lower(): x for x in [
367     'ar', 'az', 'bg', 'ca', 'cs', 'da', 'de', 'el', 'en', 'es', 'et',
368     'eu', 'fa', 'fi', 'fr', 'gl', 'he', 'hi', 'hr', 'hu', 'id', 'is',
369     'it', 'ja', 'km', 'ko', 'lt', 'lv', 'mk', 'ms', 'nb', 'nl', 'pl',
370     'pt-BR', 'pt', 'ro', 'ru', 'sk', 'sr-Cyrl', 'sr', 'sv', 'th',
371     'tr', 'uk', 'vi',
372 ]}
373 SELECT2_TRANSLATIONS.update({'zh-hans': 'zh-CN', 'zh-hant': 'zh-TW'})
374 
375 
376 class AutocompleteMixin:
377     """
378     Select widget mixin that loads options from AutocompleteJsonView via AJAX.
379 
380     Renders the necessary data attributes for select2 and adds the static form
381     media.
382     """
383     url_name = '%s:%s_%s_autocomplete'
384 
385     def __init__(self, rel, admin_site, attrs=None, choices=(), using=None):
386         self.rel = rel
387         self.admin_site = admin_site
388         self.db = using
389         self.choices = choices
390         self.attrs = {} if attrs is None else attrs.copy()
391 
392     def get_url(self):
393         model = self.rel.model
394         return reverse(self.url_name % (self.admin_site.name, model._meta.app_label, model._meta.model_name))
395 
396     def build_attrs(self, base_attrs, extra_attrs=None):
397         """
398         Set select2's AJAX attributes.
399 
400         Attributes can be set using the html5 data attribute.
401         Nested attributes require a double dash as per
402         https://select2.org/configuration/data-attributes#nested-subkey-options
403         """
404         attrs = super().build_attrs(base_attrs, extra_attrs=extra_attrs)
405         attrs.setdefault('class', '')
406         attrs.update({
407             'data-ajax--cache': 'true',
408             'data-ajax--delay': 250,
409             'data-ajax--type': 'GET',
410             'data-ajax--url': self.get_url(),
411             'data-theme': 'admin-autocomplete',
412             'data-allow-clear': json.dumps(not self.is_required),
413             'data-placeholder': '',  # Allows clearing of the input.
414             'class': attrs['class'] + (' ' if attrs['class'] else '') + 'admin-autocomplete',
415         })
416         return attrs
417 
418     def optgroups(self, name, value, attr=None):
419         """Return selected options based on the ModelChoiceIterator."""
420         default = (None, [], 0)
421         groups = [default]
422         has_selected = False
423         selected_choices = {
424             str(v) for v in value
425             if str(v) not in self.choices.field.empty_values
426         }
427         if not self.is_required and not self.allow_multiple_selected:
428             default[1].append(self.create_option(name, '', '', False, 0))
429         choices = (
430             (obj.pk, self.choices.field.label_from_instance(obj))
431             for obj in self.choices.queryset.using(self.db).filter(pk__in=selected_choices)
432         )
433         for option_value, option_label in choices:
434             selected = (
435                 str(option_value) in value and
436                 (has_selected is False or self.allow_multiple_selected)
437             )
438             has_selected |= selected
439             index = len(default[1])
440             subgroup = default[1]
441             subgroup.append(self.create_option(name, option_value, option_label, selected_choices, index))
442         return groups
443 
444     @property
445     def media(self):
446         extra = '' if settings.DEBUG else '.min'
447         i18n_name = SELECT2_TRANSLATIONS.get(get_language())
448         i18n_file = ('admin/js/vendor/select2/i18n/%s.js' % i18n_name,) if i18n_name else ()
449         return forms.Media(
450             js=(
451                 'admin/js/vendor/jquery/jquery%s.js' % extra,
452                 'admin/js/vendor/select2/select2.full%s.js' % extra,
453             ) + i18n_file + (
454                 'admin/js/jquery.init.js',
455                 'admin/js/autocomplete.js',
456             ),
457             css={
458                 'screen': (
459                     'admin/css/vendor/select2/select2%s.css' % extra,
460                     'admin/css/autocomplete.css',
461                 ),
462             },
463         )
464 
465 
466 class AutocompleteSelect(AutocompleteMixin, forms.Select):
467     pass
468 
469 
470 class AutocompleteSelectMultiple(AutocompleteMixin, forms.SelectMultiple):
471     pass

</code><intended_behavior>In any method or function within this file where `json.dumps` is used to prepare `JSONField` data for display in the admin interface, the function call should be modified to use `json.dumps(ensure_ascii=False)`. This ensures that Unicode characters are correctly displayed in their original form within the Django admin. The rest of the admin interface's functionality, including any validation, storage, and retrieval of `JSONField` data, should remain unaffected by this change.</intended_behavior>]
2025-10-18 12:19:11.421 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 12:19:11.421 | INFO     | Search-only: skipping patch selection
2025-10-18 12:19:11.580 | INFO     | Task django__django-13512 completed successfully.
2025-10-18 12:19:11.581 | INFO     | No patch generated. You can try running ACR again.
