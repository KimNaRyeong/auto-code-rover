2025-10-18 10:31:29.326 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 10:31:32.095 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=973, output_tokens=12, cost=0.010090
2025-10-18 10:31:32.096 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 10:31:32.100 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:31:42.038 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1274, output_tokens=411, cost=0.025070
2025-10-18 10:31:42.044 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:31:45.206 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=765, output_tokens=99, cost=0.010620
2025-10-18 10:31:45.207 | DEBUG    | Extracted a valid json.
2025-10-18 10:31:45.208 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MigrationExecutor\")",
        "search_method(\"apply_migration\")",
        "search_class_in_file(\"SchemaEditor\", \"django/db/backends/sqlite3/schema.py\")",
        "search_method_in_class(\"_remake_table\", \"SchemaEditor\")",
        "search_method_in_class(\"create_model\", \"SchemaEditor\")",
        "search_code(\"'CREATE TABLE '\")"
    ],
    "bug_locations": []
}
2025-10-18 10:31:45.262 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 10:31:45.263 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 10:32:02.091 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2664, output_tokens=744, cost=0.048960
2025-10-18 10:32:02.106 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:32:08.753 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3624, output_tokens=252, cost=0.043800
2025-10-18 10:32:08.759 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:32:10.774 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=606, output_tokens=57, cost=0.007770
2025-10-18 10:32:10.775 | DEBUG    | Extracted a valid json.
2025-10-18 10:32:10.775 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"SchemaEditor\")",
        "search_code(\"OperationalError\")",
        "search_code_in_file(\"CREATE TABLE\", \"django/db/backends/sqlite3/schema.py\")"
    ],
    "bug_locations": []
}
2025-10-18 10:32:10.825 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 10:32:10.826 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 10:32:26.500 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4166, output_tokens=753, cost=0.064250
2025-10-18 10:32:26.514 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:32:35.631 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5135, output_tokens=415, cost=0.063800
2025-10-18 10:32:35.638 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:32:37.650 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=769, output_tokens=14, cost=0.008110
2025-10-18 10:32:37.651 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 10:32:37.651 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 10:32:42.493 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=769, output_tokens=150, cost=0.012190
2025-10-18 10:32:42.494 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-18 10:32:42.494 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 10:32:47.121 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=769, output_tokens=148, cost=0.012130
2025-10-18 10:32:47.122 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-18 10:32:47.122 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 10:32:48.610 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=769, output_tokens=14, cost=0.008110
2025-10-18 10:32:48.611 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 10:32:48.611 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 10:32:49.458 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=769, output_tokens=14, cost=0.008110
2025-10-18 10:32:49.459 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 10:32:49.459 | DEBUG    | Agent proxy return the following json: None
2025-10-18 10:32:49.460 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 10:32:49.461 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 10:32:49.461 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:32:59.784 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5577, output_tokens=353, cost=0.066360
2025-10-18 10:32:59.791 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:33:05.067 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=161, cost=0.011900
2025-10-18 10:33:05.068 | DEBUG    | Extracted a valid json.
2025-10-18 10:33:05.068 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/backends/sqlite3/schema.py",
            "class": "",
            "method": "",
            "intended_behavior": "Look for how table creation commands are generated and executed."
        },
        {
            "file": "django/db/migrations/executor.py",
            "class": "",
            "method": "apply_migration",
            "intended_behavior": "Investigate methods for invoking schema changes in SQLite."
        },
        {
            "file": "django/db/models/options.py",
            "class": "",
            "method": "",
            "intended_behavior": "Examine how migration system handles quoted names, especially where model `_meta` options are processed."
        }
    ]
}
2025-10-18 10:33:05.077 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/sqlite3/schema.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from decimal import Decimal
3 
4 from django.apps.registry import Apps
5 from django.db.backends.base.schema import BaseDatabaseSchemaEditor
6 from django.db.backends.ddl_references import Statement
7 from django.db.models import UniqueConstraint
8 from django.db.transaction import atomic
9 from django.db.utils import NotSupportedError
10 
11 
12 class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
13 
14     sql_delete_table = "DROP TABLE %(table)s"
15     sql_create_fk = None
16     sql_create_inline_fk = "REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED"
17     sql_create_unique = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)"
18     sql_delete_unique = "DROP INDEX %(name)s"
19 
20     def __enter__(self):
21         # Some SQLite schema alterations need foreign key constraints to be
22         # disabled. Enforce it here for the duration of the schema edition.
23         if not self.connection.disable_constraint_checking():
24             raise NotSupportedError(
25                 'SQLite schema editor cannot be used while foreign key '
26                 'constraint checks are enabled. Make sure to disable them '
27                 'before entering a transaction.atomic() context because '
28                 'SQLite does not support disabling them in the middle of '
29                 'a multi-statement transaction.'
30             )
31         return super().__enter__()
32 
33     def __exit__(self, exc_type, exc_value, traceback):
34         self.connection.check_constraints()
35         super().__exit__(exc_type, exc_value, traceback)
36         self.connection.enable_constraint_checking()
37 
38     def quote_value(self, value):
39         # The backend "mostly works" without this function and there are use
40         # cases for compiling Python without the sqlite3 libraries (e.g.
41         # security hardening).
42         try:
43             import sqlite3
44             value = sqlite3.adapt(value)
45         except ImportError:
46             pass
47         except sqlite3.ProgrammingError:
48             pass
49         # Manual emulation of SQLite parameter quoting
50         if isinstance(value, bool):
51             return str(int(value))
52         elif isinstance(value, (Decimal, float, int)):
53             return str(value)
54         elif isinstance(value, str):
55             return "'%s'" % value.replace("\'", "\'\'")
56         elif value is None:
57             return "NULL"
58         elif isinstance(value, (bytes, bytearray, memoryview)):
59             # Bytes are only allowed for BLOB fields, encoded as string
60             # literals containing hexadecimal data and preceded by a single "X"
61             # character.
62             return "X'%s'" % value.hex()
63         else:
64             raise ValueError("Cannot quote parameter value %r of type %s" % (value, type(value)))
65 
66     def _is_referenced_by_fk_constraint(self, table_name, column_name=None, ignore_self=False):
67         """
68         Return whether or not the provided table name is referenced by another
69         one. If `column_name` is specified, only references pointing to that
70         column are considered. If `ignore_self` is True, self-referential
71         constraints are ignored.
72         """
73         with self.connection.cursor() as cursor:
74             for other_table in self.connection.introspection.get_table_list(cursor):
75                 if ignore_self and other_table.name == table_name:
76                     continue
77                 constraints = self.connection.introspection._get_foreign_key_constraints(cursor, other_table.name)
78                 for constraint in constraints.values():
79                     constraint_table, constraint_column = constraint['foreign_key']
80                     if (constraint_table == table_name and
81                             (column_name is None or constraint_column == column_name)):
82                         return True
83         return False
84 
85     def alter_db_table(self, model, old_db_table, new_db_table, disable_constraints=True):
86         if (not self.connection.features.supports_atomic_references_rename and
87                 disable_constraints and self._is_referenced_by_fk_constraint(old_db_table)):
88             if self.connection.in_atomic_block:
89                 raise NotSupportedError((
90                     'Renaming the %r table while in a transaction is not '
91                     'supported on SQLite < 3.26 because it would break referential '
92                     'integrity. Try adding `atomic = False` to the Migration class.'
93                 ) % old_db_table)
94             self.connection.enable_constraint_checking()
95             super().alter_db_table(model, old_db_table, new_db_table)
96             self.connection.disable_constraint_checking()
97         else:
98             super().alter_db_table(model, old_db_table, new_db_table)
99 
100     def alter_field(self, model, old_field, new_field, strict=False):
101         old_field_name = old_field.name
102         table_name = model._meta.db_table
103         _, old_column_name = old_field.get_attname_column()
104         if (new_field.name != old_field_name and
105                 not self.connection.features.supports_atomic_references_rename and
106                 self._is_referenced_by_fk_constraint(table_name, old_column_name, ignore_self=True)):
107             if self.connection.in_atomic_block:
108                 raise NotSupportedError((
109                     'Renaming the %r.%r column while in a transaction is not '
110                     'supported on SQLite < 3.26 because it would break referential '
111                     'integrity. Try adding `atomic = False` to the Migration class.'
112                 ) % (model._meta.db_table, old_field_name))
113             with atomic(self.connection.alias):
114                 super().alter_field(model, old_field, new_field, strict=strict)
115                 # Follow SQLite's documented procedure for performing changes
116                 # that don't affect the on-disk content.
117                 # https://sqlite.org/lang_altertable.html#otheralter
118                 with self.connection.cursor() as cursor:
119                     schema_version = cursor.execute('PRAGMA schema_version').fetchone()[0]
120                     cursor.execute('PRAGMA writable_schema = 1')
121                     references_template = ' REFERENCES "%s" ("%%s") ' % table_name
122                     new_column_name = new_field.get_attname_column()[1]
123                     search = references_template % old_column_name
124                     replacement = references_template % new_column_name
125                     cursor.execute('UPDATE sqlite_master SET sql = replace(sql, %s, %s)', (search, replacement))
126                     cursor.execute('PRAGMA schema_version = %d' % (schema_version + 1))
127                     cursor.execute('PRAGMA writable_schema = 0')
128                     # The integrity check will raise an exception and rollback
129                     # the transaction if the sqlite_master updates corrupt the
130                     # database.
131                     cursor.execute('PRAGMA integrity_check')
132             # Perform a VACUUM to refresh the database representation from
133             # the sqlite_master table.
134             with self.connection.cursor() as cursor:
135                 cursor.execute('VACUUM')
136         else:
137             super().alter_field(model, old_field, new_field, strict=strict)
138 
139     def _remake_table(self, model, create_field=None, delete_field=None, alter_field=None):
140         """
141         Shortcut to transform a model from old_model into new_model
142 
143         This follows the correct procedure to perform non-rename or column
144         addition operations based on SQLite's documentation
145 
146         https://www.sqlite.org/lang_altertable.html#caution
147 
148         The essential steps are:
149           1. Create a table with the updated definition called "new__app_model"
150           2. Copy the data from the existing "app_model" table to the new table
151           3. Drop the "app_model" table
152           4. Rename the "new__app_model" table to "app_model"
153           5. Restore any index of the previous "app_model" table.
154         """
155         # Self-referential fields must be recreated rather than copied from
156         # the old model to ensure their remote_field.field_name doesn't refer
157         # to an altered field.
158         def is_self_referential(f):
159             return f.is_relation and f.remote_field.model is model
160         # Work out the new fields dict / mapping
161         body = {
162             f.name: f.clone() if is_self_referential(f) else f
163             for f in model._meta.local_concrete_fields
164         }
165         # Since mapping might mix column names and default values,
166         # its values must be already quoted.
167         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}
168         # This maps field names (not columns) for things like unique_together
169         rename_mapping = {}
170         # If any of the new or altered fields is introducing a new PK,
171         # remove the old one
172         restore_pk_field = None
173         if getattr(create_field, 'primary_key', False) or (
174                 alter_field and getattr(alter_field[1], 'primary_key', False)):
175             for name, field in list(body.items()):
176                 if field.primary_key:
177                     field.primary_key = False
178                     restore_pk_field = field
179                     if field.auto_created:
180                         del body[name]
181                         del mapping[field.column]
182         # Add in any created fields
183         if create_field:
184             body[create_field.name] = create_field
185             # Choose a default and insert it into the copy map
186             if not create_field.many_to_many and create_field.concrete:
187                 mapping[create_field.column] = self.quote_value(
188                     self.effective_default(create_field)
189                 )
190         # Add in any altered fields
191         if alter_field:
192             old_field, new_field = alter_field
193             body.pop(old_field.name, None)
194             mapping.pop(old_field.column, None)
195             body[new_field.name] = new_field
196             if old_field.null and not new_field.null:
197                 case_sql = "coalesce(%(col)s, %(default)s)" % {
198                     'col': self.quote_name(old_field.column),
199                     'default': self.quote_value(self.effective_default(new_field))
200                 }
201                 mapping[new_field.column] = case_sql
202             else:
203                 mapping[new_field.column] = self.quote_name(old_field.column)
204             rename_mapping[old_field.name] = new_field.name
205         # Remove any deleted fields
206         if delete_field:
207             del body[delete_field.name]
208             del mapping[delete_field.column]
209             # Remove any implicit M2M tables
210             if delete_field.many_to_many and delete_field.remote_field.through._meta.auto_created:
211                 return self.delete_model(delete_field.remote_field.through)
212         # Work inside a new app registry
213         apps = Apps()
214 
215         # Work out the new value of unique_together, taking renames into
216         # account
217         unique_together = [
218             [rename_mapping.get(n, n) for n in unique]
219             for unique in model._meta.unique_together
220         ]
221 
222         # Work out the new value for index_together, taking renames into
223         # account
224         index_together = [
225             [rename_mapping.get(n, n) for n in index]
226             for index in model._meta.index_together
227         ]
228 
229         indexes = model._meta.indexes
230         if delete_field:
231             indexes = [
232                 index for index in indexes
233                 if delete_field.name not in index.fields
234             ]
235 
236         constraints = list(model._meta.constraints)
237 
238         # Provide isolated instances of the fields to the new model body so
239         # that the existing model's internals aren't interfered with when
240         # the dummy model is constructed.
241         body_copy = copy.deepcopy(body)
242 
243         # Construct a new model with the new fields to allow self referential
244         # primary key to resolve to. This model won't ever be materialized as a
245         # table and solely exists for foreign key reference resolution purposes.
246         # This wouldn't be required if the schema editor was operating on model
247         # states instead of rendered models.
248         meta_contents = {
249             'app_label': model._meta.app_label,
250             'db_table': model._meta.db_table,
251             'unique_together': unique_together,
252             'index_together': index_together,
253             'indexes': indexes,
254             'constraints': constraints,
255             'apps': apps,
256         }
257         meta = type("Meta", (), meta_contents)
258         body_copy['Meta'] = meta
259         body_copy['__module__'] = model.__module__
260         type(model._meta.object_name, model.__bases__, body_copy)
261 
262         # Construct a model with a renamed table name.
263         body_copy = copy.deepcopy(body)
264         meta_contents = {
265             'app_label': model._meta.app_label,
266             'db_table': 'new__%s' % model._meta.db_table,
267             'unique_together': unique_together,
268             'index_together': index_together,
269             'indexes': indexes,
270             'constraints': constraints,
271             'apps': apps,
272         }
273         meta = type("Meta", (), meta_contents)
274         body_copy['Meta'] = meta
275         body_copy['__module__'] = model.__module__
276         new_model = type('New%s' % model._meta.object_name, model.__bases__, body_copy)
277 
278         # Create a new table with the updated schema.
279         self.create_model(new_model)
280 
281         # Copy data from the old table into the new table
282         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
283             self.quote_name(new_model._meta.db_table),
284             ', '.join(self.quote_name(x) for x in mapping),
285             ', '.join(mapping.values()),
286             self.quote_name(model._meta.db_table),
287         ))
288 
289         # Delete the old table to make way for the new
290         self.delete_model(model, handle_autom2m=False)
291 
292         # Rename the new table to take way for the old
293         self.alter_db_table(
294             new_model, new_model._meta.db_table, model._meta.db_table,
295             disable_constraints=False,
296         )
297 
298         # Run deferred SQL on correct table
299         for sql in self.deferred_sql:
300             self.execute(sql)
301         self.deferred_sql = []
302         # Fix any PK-removed field
303         if restore_pk_field:
304             restore_pk_field.primary_key = True
305 
306     def delete_model(self, model, handle_autom2m=True):
307         if handle_autom2m:
308             super().delete_model(model)
309         else:
310             # Delete the table (and only that)
311             self.execute(self.sql_delete_table % {
312                 "table": self.quote_name(model._meta.db_table),
313             })
314             # Remove all deferred statements referencing the deleted table.
315             for sql in list(self.deferred_sql):
316                 if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
317                     self.deferred_sql.remove(sql)
318 
319     def add_field(self, model, field):
320         """
321         Create a field on a model. Usually involves adding a column, but may
322         involve adding a table instead (for M2M fields).
323         """
324         # Special-case implicit M2M tables
325         if field.many_to_many and field.remote_field.through._meta.auto_created:
326             return self.create_model(field.remote_field.through)
327         self._remake_table(model, create_field=field)
328 
329     def remove_field(self, model, field):
330         """
331         Remove a field from a model. Usually involves deleting a column,
332         but for M2Ms may involve deleting a table.
333         """
334         # M2M fields are a special case
335         if field.many_to_many:
336             # For implicit M2M tables, delete the auto-created table
337             if field.remote_field.through._meta.auto_created:
338                 self.delete_model(field.remote_field.through)
339             # For explicit "through" M2M fields, do nothing
340         # For everything else, remake.
341         else:
342             # It might not actually have a column behind it
343             if field.db_parameters(connection=self.connection)['type'] is None:
344                 return
345             self._remake_table(model, delete_field=field)
346 
347     def _alter_field(self, model, old_field, new_field, old_type, new_type,
348                      old_db_params, new_db_params, strict=False):
349         """Perform a "physical" (non-ManyToMany) field update."""
350         # Use "ALTER TABLE ... RENAME COLUMN" if only the column name
351         # changed and there aren't any constraints.
352         if (self.connection.features.can_alter_table_rename_column and
353             old_field.column != new_field.column and
354             self.column_sql(model, old_field) == self.column_sql(model, new_field) and
355             not (old_field.remote_field and old_field.db_constraint or
356                  new_field.remote_field and new_field.db_constraint)):
357             return self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
358         # Alter by remaking table
359         self._remake_table(model, alter_field=(old_field, new_field))
360         # Rebuild tables with FKs pointing to this field if the PK type changed.
361         if old_field.primary_key and new_field.primary_key and old_type != new_type:
362             for rel in new_field.model._meta.related_objects:
363                 if not rel.many_to_many:
364                     self._remake_table(rel.related_model)
365 
366     def _alter_many_to_many(self, model, old_field, new_field, strict):
367         """Alter M2Ms to repoint their to= endpoints."""
368         if old_field.remote_field.through._meta.db_table == new_field.remote_field.through._meta.db_table:
369             # The field name didn't change, but some options did; we have to propagate this altering.
370             self._remake_table(
371                 old_field.remote_field.through,
372                 alter_field=(
373                     # We need the field that points to the target model, so we can tell alter_field to change it -
374                     # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
375                     old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
376                     new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
377                 ),
378             )
379             return
380 
381         # Make a new through table
382         self.create_model(new_field.remote_field.through)
383         # Copy the data across
384         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
385             self.quote_name(new_field.remote_field.through._meta.db_table),
386             ', '.join([
387                 "id",
388                 new_field.m2m_column_name(),
389                 new_field.m2m_reverse_name(),
390             ]),
391             ', '.join([
392                 "id",
393                 old_field.m2m_column_name(),
394                 old_field.m2m_reverse_name(),
395             ]),
396             self.quote_name(old_field.remote_field.through._meta.db_table),
397         ))
398         # Delete the old through table
399         self.delete_model(old_field.remote_field.through)
400 
401     def add_constraint(self, model, constraint):
402         if isinstance(constraint, UniqueConstraint) and constraint.condition:
403             super().add_constraint(model, constraint)
404         else:
405             self._remake_table(model)
406 
407     def remove_constraint(self, model, constraint):
408         if isinstance(constraint, UniqueConstraint) and constraint.condition:
409             super().remove_constraint(model, constraint)
410         else:
411             self._remake_table(model)

</code><intended_behavior>Look for how table creation commands are generated and executed.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>None</class>
<method>apply_migration</method>
<code>
231     def apply_migration(self, state, migration, fake=False, fake_initial=False):
232         """Run a migration forwards."""
233         migration_recorded = False
234         if self.progress_callback:
235             self.progress_callback("apply_start", migration, fake)
236         if not fake:
237             if fake_initial:
238                 # Test to see if this is an already-applied initial migration
239                 applied, state = self.detect_soft_applied(state, migration)
240                 if applied:
241                     fake = True
242             if not fake:
243                 # Alright, do it normally
244                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
245                     state = migration.apply(state, schema_editor)
246                     self.record_migration(migration)
247                     migration_recorded = True
248         if not migration_recorded:
249             self.record_migration(migration)
250         # Report progress
251         if self.progress_callback:
252             self.progress_callback("apply_success", migration, fake)
253         return state

</code><intended_behavior>Investigate methods for invoking schema changes in SQLite.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>apply_migration</method>
<code>
231     def apply_migration(self, state, migration, fake=False, fake_initial=False):
232         """Run a migration forwards."""
233         migration_recorded = False
234         if self.progress_callback:
235             self.progress_callback("apply_start", migration, fake)
236         if not fake:
237             if fake_initial:
238                 # Test to see if this is an already-applied initial migration
239                 applied, state = self.detect_soft_applied(state, migration)
240                 if applied:
241                     fake = True
242             if not fake:
243                 # Alright, do it normally
244                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
245                     state = migration.apply(state, schema_editor)
246                     self.record_migration(migration)
247                     migration_recorded = True
248         if not migration_recorded:
249             self.record_migration(migration)
250         # Report progress
251         if self.progress_callback:
252             self.progress_callback("apply_success", migration, fake)
253         return state

</code><intended_behavior>Investigate methods for invoking schema changes in SQLite.</intended_behavior>, <file>django/db/models/options.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import inspect
3 from bisect import bisect
4 from collections import defaultdict
5 
6 from django.apps import apps
7 from django.conf import settings
8 from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured
9 from django.db import connections
10 from django.db.models import Manager
11 from django.db.models.fields import AutoField
12 from django.db.models.fields.proxy import OrderWrt
13 from django.db.models.query_utils import PathInfo
14 from django.utils.datastructures import ImmutableList, OrderedSet
15 from django.utils.functional import cached_property
16 from django.utils.text import camel_case_to_spaces, format_lazy
17 from django.utils.translation import override
18 
19 PROXY_PARENTS = object()
20 
21 EMPTY_RELATION_TREE = ()
22 
23 IMMUTABLE_WARNING = (
24     "The return type of '%s' should never be mutated. If you want to manipulate this list "
25     "for your own use, make a copy first."
26 )
27 
28 DEFAULT_NAMES = (
29     'verbose_name', 'verbose_name_plural', 'db_table', 'ordering',
30     'unique_together', 'permissions', 'get_latest_by', 'order_with_respect_to',
31     'app_label', 'db_tablespace', 'abstract', 'managed', 'proxy', 'swappable',
32     'auto_created', 'index_together', 'apps', 'default_permissions',
33     'select_on_save', 'default_related_name', 'required_db_features',
34     'required_db_vendor', 'base_manager_name', 'default_manager_name',
35     'indexes', 'constraints',
36 )
37 
38 
39 def normalize_together(option_together):
40     """
41     option_together can be either a tuple of tuples, or a single
42     tuple of two strings. Normalize it to a tuple of tuples, so that
43     calling code can uniformly expect that.
44     """
45     try:
46         if not option_together:
47             return ()
48         if not isinstance(option_together, (tuple, list)):
49             raise TypeError
50         first_element = option_together[0]
51         if not isinstance(first_element, (tuple, list)):
52             option_together = (option_together,)
53         # Normalize everything to tuples
54         return tuple(tuple(ot) for ot in option_together)
55     except TypeError:
56         # If the value of option_together isn't valid, return it
57         # verbatim; this will be picked up by the check framework later.
58         return option_together
59 
60 
61 def make_immutable_fields_list(name, data):
62     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
63 
64 
65 class Options:
66     FORWARD_PROPERTIES = {
67         'fields', 'many_to_many', 'concrete_fields', 'local_concrete_fields',
68         '_forward_fields_map', 'managers', 'managers_map', 'base_manager',
69         'default_manager',
70     }
71     REVERSE_PROPERTIES = {'related_objects', 'fields_map', '_relation_tree'}
72 
73     default_apps = apps
74 
75     def __init__(self, meta, app_label=None):
76         self._get_fields_cache = {}
77         self.local_fields = []
78         self.local_many_to_many = []
79         self.private_fields = []
80         self.local_managers = []
81         self.base_manager_name = None
82         self.default_manager_name = None
83         self.model_name = None
84         self.verbose_name = None
85         self.verbose_name_plural = None
86         self.db_table = ''
87         self.ordering = []
88         self._ordering_clash = False
89         self.indexes = []
90         self.constraints = []
91         self.unique_together = []
92         self.index_together = []
93         self.select_on_save = False
94         self.default_permissions = ('add', 'change', 'delete', 'view')
95         self.permissions = []
96         self.object_name = None
97         self.app_label = app_label
98         self.get_latest_by = None
99         self.order_with_respect_to = None
100         self.db_tablespace = settings.DEFAULT_TABLESPACE
101         self.required_db_features = []
102         self.required_db_vendor = None
103         self.meta = meta
104         self.pk = None
105         self.auto_field = None
106         self.abstract = False
107         self.managed = True
108         self.proxy = False
109         # For any class that is a proxy (including automatically created
110         # classes for deferred object loading), proxy_for_model tells us
111         # which class this model is proxying. Note that proxy_for_model
112         # can create a chain of proxy models. For non-proxy models, the
113         # variable is always None.
114         self.proxy_for_model = None
115         # For any non-abstract class, the concrete class is the model
116         # in the end of the proxy_for_model chain. In particular, for
117         # concrete models, the concrete_model is always the class itself.
118         self.concrete_model = None
119         self.swappable = None
120         self.parents = {}
121         self.auto_created = False
122 
123         # List of all lookups defined in ForeignKey 'limit_choices_to' options
124         # from *other* models. Needed for some admin checks. Internal use only.
125         self.related_fkey_lookups = []
126 
127         # A custom app registry to use, if you're making a separate model set.
128         self.apps = self.default_apps
129 
130         self.default_related_name = None
131 
132     @property
133     def label(self):
134         return '%s.%s' % (self.app_label, self.object_name)
135 
136     @property
137     def label_lower(self):
138         return '%s.%s' % (self.app_label, self.model_name)
139 
140     @property
141     def app_config(self):
142         # Don't go through get_app_config to avoid triggering imports.
143         return self.apps.app_configs.get(self.app_label)
144 
145     @property
146     def installed(self):
147         return self.app_config is not None
148 
149     def contribute_to_class(self, cls, name):
150         from django.db import connection
151         from django.db.backends.utils import truncate_name
152 
153         cls._meta = self
154         self.model = cls
155         # First, construct the default values for these options.
156         self.object_name = cls.__name__
157         self.model_name = self.object_name.lower()
158         self.verbose_name = camel_case_to_spaces(self.object_name)
159 
160         # Store the original user-defined values for each option,
161         # for use when serializing the model definition
162         self.original_attrs = {}
163 
164         # Next, apply any overridden values from 'class Meta'.
165         if self.meta:
166             meta_attrs = self.meta.__dict__.copy()
167             for name in self.meta.__dict__:
168                 # Ignore any private attributes that Django doesn't care about.
169                 # NOTE: We can't modify a dictionary's contents while looping
170                 # over it, so we loop over the *original* dictionary instead.
171                 if name.startswith('_'):
172                     del meta_attrs[name]
173             for attr_name in DEFAULT_NAMES:
174                 if attr_name in meta_attrs:
175                     setattr(self, attr_name, meta_attrs.pop(attr_name))
176                     self.original_attrs[attr_name] = getattr(self, attr_name)
177                 elif hasattr(self.meta, attr_name):
178                     setattr(self, attr_name, getattr(self.meta, attr_name))
179                     self.original_attrs[attr_name] = getattr(self, attr_name)
180 
181             self.unique_together = normalize_together(self.unique_together)
182             self.index_together = normalize_together(self.index_together)
183             # App label/class name interpolation for names of constraints and
184             # indexes.
185             if not getattr(cls._meta, 'abstract', False):
186                 for attr_name in {'constraints', 'indexes'}:
187                     objs = getattr(self, attr_name, [])
188                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
189 
190             # verbose_name_plural is a special case because it uses a 's'
191             # by default.
192             if self.verbose_name_plural is None:
193                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
194 
195             # order_with_respect_and ordering are mutually exclusive.
196             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
197 
198             # Any leftover attributes must be invalid.
199             if meta_attrs != {}:
200                 raise TypeError("'class Meta' got invalid attribute(s): %s" % ','.join(meta_attrs))
201         else:
202             self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
203         del self.meta
204 
205         # If the db_table wasn't provided, use the app_label + model_name.
206         if not self.db_table:
207             self.db_table = "%s_%s" % (self.app_label, self.model_name)
208             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
209 
210     def _format_names_with_class(self, cls, objs):
211         """App label/class name interpolation for object names."""
212         new_objs = []
213         for obj in objs:
214             obj = obj.clone()
215             obj.name = obj.name % {
216                 'app_label': cls._meta.app_label.lower(),
217                 'class': cls.__name__.lower(),
218             }
219             new_objs.append(obj)
220         return new_objs
221 
222     def _prepare(self, model):
223         if self.order_with_respect_to:
224             # The app registry will not be ready at this point, so we cannot
225             # use get_field().
226             query = self.order_with_respect_to
227             try:
228                 self.order_with_respect_to = next(
229                     f for f in self._get_fields(reverse=False)
230                     if f.name == query or f.attname == query
231                 )
232             except StopIteration:
233                 raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, query))
234 
235             self.ordering = ('_order',)
236             if not any(isinstance(field, OrderWrt) for field in model._meta.local_fields):
237                 model.add_to_class('_order', OrderWrt())
238         else:
239             self.order_with_respect_to = None
240 
241         if self.pk is None:
242             if self.parents:
243                 # Promote the first parent link in lieu of adding yet another
244                 # field.
245                 field = next(iter(self.parents.values()))
246                 # Look for a local field with the same name as the
247                 # first parent link. If a local field has already been
248                 # created, use it instead of promoting the parent
249                 already_created = [fld for fld in self.local_fields if fld.name == field.name]
250                 if already_created:
251                     field = already_created[0]
252                 field.primary_key = True
253                 self.setup_pk(field)
254                 if not field.remote_field.parent_link:
255                     raise ImproperlyConfigured(
256                         'Add parent_link=True to %s.' % field,
257                     )
258             else:
259                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
260                 model.add_to_class('id', auto)
261 
262     def add_manager(self, manager):
263         self.local_managers.append(manager)
264         self._expire_cache()
265 
266     def add_field(self, field, private=False):
267         # Insert the given field in the order in which it was created, using
268         # the "creation_counter" attribute of the field.
269         # Move many-to-many related fields from self.fields into
270         # self.many_to_many.
271         if private:
272             self.private_fields.append(field)
273         elif field.is_relation and field.many_to_many:
274             self.local_many_to_many.insert(bisect(self.local_many_to_many, field), field)
275         else:
276             self.local_fields.insert(bisect(self.local_fields, field), field)
277             self.setup_pk(field)
278 
279         # If the field being added is a relation to another known field,
280         # expire the cache on this field and the forward cache on the field
281         # being referenced, because there will be new relationships in the
282         # cache. Otherwise, expire the cache of references *to* this field.
283         # The mechanism for getting at the related model is slightly odd -
284         # ideally, we'd just ask for field.related_model. However, related_model
285         # is a cached property, and all the models haven't been loaded yet, so
286         # we need to make sure we don't cache a string reference.
287         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
288             try:
289                 field.remote_field.model._meta._expire_cache(forward=False)
290             except AttributeError:
291                 pass
292             self._expire_cache()
293         else:
294             self._expire_cache(reverse=False)
295 
296     def setup_pk(self, field):
297         if not self.pk and field.primary_key:
298             self.pk = field
299             field.serialize = False
300 
301     def setup_proxy(self, target):
302         """
303         Do the internal setup so that the current model is a proxy for
304         "target".
305         """
306         self.pk = target._meta.pk
307         self.proxy_for_model = target
308         self.db_table = target._meta.db_table
309 
310     def __repr__(self):
311         return '<Options for %s>' % self.object_name
312 
313     def __str__(self):
314         return "%s.%s" % (self.app_label, self.model_name)
315 
316     def can_migrate(self, connection):
317         """
318         Return True if the model can/should be migrated on the `connection`.
319         `connection` can be either a real connection or a connection alias.
320         """
321         if self.proxy or self.swapped or not self.managed:
322             return False
323         if isinstance(connection, str):
324             connection = connections[connection]
325         if self.required_db_vendor:
326             return self.required_db_vendor == connection.vendor
327         if self.required_db_features:
328             return all(getattr(connection.features, feat, False)
329                        for feat in self.required_db_features)
330         return True
331 
332     @property
333     def verbose_name_raw(self):
334         """Return the untranslated verbose name."""
335         with override(None):
336             return str(self.verbose_name)
337 
338     @property
339     def swapped(self):
340         """
341         Has this model been swapped out for another? If so, return the model
342         name of the replacement; otherwise, return None.
343 
344         For historical reasons, model name lookups using get_model() are
345         case insensitive, so we make sure we are case insensitive here.
346         """
347         if self.swappable:
348             swapped_for = getattr(settings, self.swappable, None)
349             if swapped_for:
350                 try:
351                     swapped_label, swapped_object = swapped_for.split('.')
352                 except ValueError:
353                     # setting not in the format app_label.model_name
354                     # raising ImproperlyConfigured here causes problems with
355                     # test cleanup code - instead it is raised in get_user_model
356                     # or as part of validation.
357                     return swapped_for
358 
359                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
360                     return swapped_for
361         return None
362 
363     @cached_property
364     def managers(self):
365         managers = []
366         seen_managers = set()
367         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
368         for depth, base in enumerate(bases):
369             for manager in base._meta.local_managers:
370                 if manager.name in seen_managers:
371                     continue
372 
373                 manager = copy.copy(manager)
374                 manager.model = self.model
375                 seen_managers.add(manager.name)
376                 managers.append((depth, manager.creation_counter, manager))
377 
378         return make_immutable_fields_list(
379             "managers",
380             (m[2] for m in sorted(managers)),
381         )
382 
383     @cached_property
384     def managers_map(self):
385         return {manager.name: manager for manager in self.managers}
386 
387     @cached_property
388     def base_manager(self):
389         base_manager_name = self.base_manager_name
390         if not base_manager_name:
391             # Get the first parent's base_manager_name if there's one.
392             for parent in self.model.mro()[1:]:
393                 if hasattr(parent, '_meta'):
394                     if parent._base_manager.name != '_base_manager':
395                         base_manager_name = parent._base_manager.name
396                     break
397 
398         if base_manager_name:
399             try:
400                 return self.managers_map[base_manager_name]
401             except KeyError:
402                 raise ValueError(
403                     "%s has no manager named %r" % (
404                         self.object_name,
405                         base_manager_name,
406                     )
407                 )
408 
409         manager = Manager()
410         manager.name = '_base_manager'
411         manager.model = self.model
412         manager.auto_created = True
413         return manager
414 
415     @cached_property
416     def default_manager(self):
417         default_manager_name = self.default_manager_name
418         if not default_manager_name and not self.local_managers:
419             # Get the first parent's default_manager_name if there's one.
420             for parent in self.model.mro()[1:]:
421                 if hasattr(parent, '_meta'):
422                     default_manager_name = parent._meta.default_manager_name
423                     break
424 
425         if default_manager_name:
426             try:
427                 return self.managers_map[default_manager_name]
428             except KeyError:
429                 raise ValueError(
430                     "%s has no manager named %r" % (
431                         self.object_name,
432                         default_manager_name,
433                     )
434                 )
435 
436         if self.managers:
437             return self.managers[0]
438 
439     @cached_property
440     def fields(self):
441         """
442         Return a list of all forward fields on the model and its parents,
443         excluding ManyToManyFields.
444 
445         Private API intended only to be used by Django itself; get_fields()
446         combined with filtering of field properties is the public API for
447         obtaining this field list.
448         """
449         # For legacy reasons, the fields property should only contain forward
450         # fields that are not private or with a m2m cardinality. Therefore we
451         # pass these three filters as filters to the generator.
452         # The third lambda is a longwinded way of checking f.related_model - we don't
453         # use that property directly because related_model is a cached property,
454         # and all the models may not have been loaded yet; we don't want to cache
455         # the string reference to the related_model.
456         def is_not_an_m2m_field(f):
457             return not (f.is_relation and f.many_to_many)
458 
459         def is_not_a_generic_relation(f):
460             return not (f.is_relation and f.one_to_many)
461 
462         def is_not_a_generic_foreign_key(f):
463             return not (
464                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
465             )
466 
467         return make_immutable_fields_list(
468             "fields",
469             (f for f in self._get_fields(reverse=False)
470              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
471         )
472 
473     @cached_property
474     def concrete_fields(self):
475         """
476         Return a list of all concrete fields on the model and its parents.
477 
478         Private API intended only to be used by Django itself; get_fields()
479         combined with filtering of field properties is the public API for
480         obtaining this field list.
481         """
482         return make_immutable_fields_list(
483             "concrete_fields", (f for f in self.fields if f.concrete)
484         )
485 
486     @cached_property
487     def local_concrete_fields(self):
488         """
489         Return a list of all concrete fields on the model.
490 
491         Private API intended only to be used by Django itself; get_fields()
492         combined with filtering of field properties is the public API for
493         obtaining this field list.
494         """
495         return make_immutable_fields_list(
496             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
497         )
498 
499     @cached_property
500     def many_to_many(self):
501         """
502         Return a list of all many to many fields on the model and its parents.
503 
504         Private API intended only to be used by Django itself; get_fields()
505         combined with filtering of field properties is the public API for
506         obtaining this list.
507         """
508         return make_immutable_fields_list(
509             "many_to_many",
510             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
511         )
512 
513     @cached_property
514     def related_objects(self):
515         """
516         Return all related objects pointing to the current model. The related
517         objects can come from a one-to-one, one-to-many, or many-to-many field
518         relation type.
519 
520         Private API intended only to be used by Django itself; get_fields()
521         combined with filtering of field properties is the public API for
522         obtaining this field list.
523         """
524         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
525         return make_immutable_fields_list(
526             "related_objects",
527             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
528         )
529 
530     @cached_property
531     def _forward_fields_map(self):
532         res = {}
533         fields = self._get_fields(reverse=False)
534         for field in fields:
535             res[field.name] = field
536             # Due to the way Django's internals work, get_field() should also
537             # be able to fetch a field by attname. In the case of a concrete
538             # field with relation, includes the *_id name too
539             try:
540                 res[field.attname] = field
541             except AttributeError:
542                 pass
543         return res
544 
545     @cached_property
546     def fields_map(self):
547         res = {}
548         fields = self._get_fields(forward=False, include_hidden=True)
549         for field in fields:
550             res[field.name] = field
551             # Due to the way Django's internals work, get_field() should also
552             # be able to fetch a field by attname. In the case of a concrete
553             # field with relation, includes the *_id name too
554             try:
555                 res[field.attname] = field
556             except AttributeError:
557                 pass
558         return res
559 
560     def get_field(self, field_name):
561         """
562         Return a field instance given the name of a forward or reverse field.
563         """
564         try:
565             # In order to avoid premature loading of the relation tree
566             # (expensive) we prefer checking if the field is a forward field.
567             return self._forward_fields_map[field_name]
568         except KeyError:
569             # If the app registry is not ready, reverse fields are
570             # unavailable, therefore we throw a FieldDoesNotExist exception.
571             if not self.apps.models_ready:
572                 raise FieldDoesNotExist(
573                     "%s has no field named '%s'. The app cache isn't ready yet, "
574                     "so if this is an auto-created related field, it won't "
575                     "be available yet." % (self.object_name, field_name)
576                 )
577 
578         try:
579             # Retrieve field instance by name from cached or just-computed
580             # field map.
581             return self.fields_map[field_name]
582         except KeyError:
583             raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, field_name))
584 
585     def get_base_chain(self, model):
586         """
587         Return a list of parent classes leading to `model` (ordered from
588         closest to most distant ancestor). This has to handle the case where
589         `model` is a grandparent or even more distant relation.
590         """
591         if not self.parents:
592             return []
593         if model in self.parents:
594             return [model]
595         for parent in self.parents:
596             res = parent._meta.get_base_chain(model)
597             if res:
598                 res.insert(0, parent)
599                 return res
600         return []
601 
602     def get_parent_list(self):
603         """
604         Return all the ancestors of this model as a list ordered by MRO.
605         Useful for determining if something is an ancestor, regardless of lineage.
606         """
607         result = OrderedSet(self.parents)
608         for parent in self.parents:
609             for ancestor in parent._meta.get_parent_list():
610                 result.add(ancestor)
611         return list(result)
612 
613     def get_ancestor_link(self, ancestor):
614         """
615         Return the field on the current model which points to the given
616         "ancestor". This is possible an indirect link (a pointer to a parent
617         model, which points, eventually, to the ancestor). Used when
618         constructing table joins for model inheritance.
619 
620         Return None if the model isn't an ancestor of this one.
621         """
622         if ancestor in self.parents:
623             return self.parents[ancestor]
624         for parent in self.parents:
625             # Tries to get a link field from the immediate parent
626             parent_link = parent._meta.get_ancestor_link(ancestor)
627             if parent_link:
628                 # In case of a proxied model, the first link
629                 # of the chain to the ancestor is that parent
630                 # links
631                 return self.parents[parent] or parent_link
632 
633     def get_path_to_parent(self, parent):
634         """
635         Return a list of PathInfos containing the path from the current
636         model to the parent model, or an empty list if parent is not a
637         parent of the current model.
638         """
639         if self.model is parent:
640             return []
641         # Skip the chain of proxy to the concrete proxied model.
642         proxied_model = self.concrete_model
643         path = []
644         opts = self
645         for int_model in self.get_base_chain(parent):
646             if int_model is proxied_model:
647                 opts = int_model._meta
648             else:
649                 final_field = opts.parents[int_model]
650                 targets = (final_field.remote_field.get_related_field(),)
651                 opts = int_model._meta
652                 path.append(PathInfo(
653                     from_opts=final_field.model._meta,
654                     to_opts=opts,
655                     target_fields=targets,
656                     join_field=final_field,
657                     m2m=False,
658                     direct=True,
659                     filtered_relation=None,
660                 ))
661         return path
662 
663     def get_path_from_parent(self, parent):
664         """
665         Return a list of PathInfos containing the path from the parent
666         model to the current model, or an empty list if parent is not a
667         parent of the current model.
668         """
669         if self.model is parent:
670             return []
671         model = self.concrete_model
672         # Get a reversed base chain including both the current and parent
673         # models.
674         chain = model._meta.get_base_chain(parent)
675         chain.reverse()
676         chain.append(model)
677         # Construct a list of the PathInfos between models in chain.
678         path = []
679         for i, ancestor in enumerate(chain[:-1]):
680             child = chain[i + 1]
681             link = child._meta.get_ancestor_link(ancestor)
682             path.extend(link.get_reverse_path_info())
683         return path
684 
685     def _populate_directed_relation_graph(self):
686         """
687         This method is used by each model to find its reverse objects. As this
688         method is very expensive and is accessed frequently (it looks up every
689         field in a model, in every app), it is computed on first access and then
690         is set as a property on every model.
691         """
692         related_objects_graph = defaultdict(list)
693 
694         all_models = self.apps.get_models(include_auto_created=True)
695         for model in all_models:
696             opts = model._meta
697             # Abstract model's fields are copied to child models, hence we will
698             # see the fields from the child models.
699             if opts.abstract:
700                 continue
701             fields_with_relations = (
702                 f for f in opts._get_fields(reverse=False, include_parents=False)
703                 if f.is_relation and f.related_model is not None
704             )
705             for f in fields_with_relations:
706                 if not isinstance(f.remote_field.model, str):
707                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
708 
709         for model in all_models:
710             # Set the relation_tree using the internal __dict__. In this way
711             # we avoid calling the cached property. In attribute lookup,
712             # __dict__ takes precedence over a data descriptor (such as
713             # @cached_property). This means that the _meta._relation_tree is
714             # only called if related_objects is not in __dict__.
715             related_objects = related_objects_graph[model._meta.concrete_model._meta]
716             model._meta.__dict__['_relation_tree'] = related_objects
717         # It seems it is possible that self is not in all_models, so guard
718         # against that with default for get().
719         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
720 
721     @cached_property
722     def _relation_tree(self):
723         return self._populate_directed_relation_graph()
724 
725     def _expire_cache(self, forward=True, reverse=True):
726         # This method is usually called by apps.cache_clear(), when the
727         # registry is finalized, or when a new field is added.
728         if forward:
729             for cache_key in self.FORWARD_PROPERTIES:
730                 if cache_key in self.__dict__:
731                     delattr(self, cache_key)
732         if reverse and not self.abstract:
733             for cache_key in self.REVERSE_PROPERTIES:
734                 if cache_key in self.__dict__:
735                     delattr(self, cache_key)
736         self._get_fields_cache = {}
737 
738     def get_fields(self, include_parents=True, include_hidden=False):
739         """
740         Return a list of fields associated to the model. By default, include
741         forward and reverse fields, fields derived from inheritance, but not
742         hidden fields. The returned fields can be changed using the parameters:
743 
744         - include_parents: include fields derived from inheritance
745         - include_hidden:  include fields that have a related_name that
746                            starts with a "+"
747         """
748         if include_parents is False:
749             include_parents = PROXY_PARENTS
750         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
751 
752     def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False,
753                     seen_models=None):
754         """
755         Internal helper function to return fields of the model.
756         * If forward=True, then fields defined on this model are returned.
757         * If reverse=True, then relations pointing to this model are returned.
758         * If include_hidden=True, then fields with is_hidden=True are returned.
759         * The include_parents argument toggles if fields from parent models
760           should be included. It has three values: True, False, and
761           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all
762           fields defined for the current model or any of its parents in the
763           parent chain to the model's concrete model.
764         """
765         if include_parents not in (True, False, PROXY_PARENTS):
766             raise TypeError("Invalid argument for include_parents: %s" % (include_parents,))
767         # This helper function is used to allow recursion in ``get_fields()``
768         # implementation and to provide a fast way for Django's internals to
769         # access specific subsets of fields.
770 
771         # We must keep track of which models we have already seen. Otherwise we
772         # could include the same field multiple times from different models.
773         topmost_call = seen_models is None
774         if topmost_call:
775             seen_models = set()
776         seen_models.add(self.model)
777 
778         # Creates a cache key composed of all arguments
779         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
780 
781         try:
782             # In order to avoid list manipulation. Always return a shallow copy
783             # of the results.
784             return self._get_fields_cache[cache_key]
785         except KeyError:
786             pass
787 
788         fields = []
789         # Recursively call _get_fields() on each parent, with the same
790         # options provided in this call.
791         if include_parents is not False:
792             for parent in self.parents:
793                 # In diamond inheritance it is possible that we see the same
794                 # model from two different routes. In that case, avoid adding
795                 # fields from the same parent again.
796                 if parent in seen_models:
797                     continue
798                 if (parent._meta.concrete_model != self.concrete_model and
799                         include_parents == PROXY_PARENTS):
800                     continue
801                 for obj in parent._meta._get_fields(
802                         forward=forward, reverse=reverse, include_parents=include_parents,
803                         include_hidden=include_hidden, seen_models=seen_models):
804                     if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:
805                         fields.append(obj)
806         if reverse and not self.proxy:
807             # Tree is computed once and cached until the app cache is expired.
808             # It is composed of a list of fields pointing to the current model
809             # from other models.
810             all_fields = self._relation_tree
811             for field in all_fields:
812                 # If hidden fields should be included or the relation is not
813                 # intentionally hidden, add to the fields dict.
814                 if include_hidden or not field.remote_field.hidden:
815                     fields.append(field.remote_field)
816 
817         if forward:
818             fields += self.local_fields
819             fields += self.local_many_to_many
820             # Private fields are recopied to each child model, and they get a
821             # different model as field.model in each child. Hence we have to
822             # add the private fields separately from the topmost call. If we
823             # did this recursively similar to local_fields, we would get field
824             # instances with field.model != self.model.
825             if topmost_call:
826                 fields += self.private_fields
827 
828         # In order to avoid list manipulation. Always
829         # return a shallow copy of the results
830         fields = make_immutable_fields_list("get_fields()", fields)
831 
832         # Store result into cache for later access
833         self._get_fields_cache[cache_key] = fields
834         return fields
835 
836     @cached_property
837     def _property_names(self):
838         """Return a set of the names of the properties defined on the model."""
839         names = []
840         for name in dir(self.model):
841             attr = inspect.getattr_static(self.model, name)
842             if isinstance(attr, property):
843                 names.append(name)
844         return frozenset(names)

</code><intended_behavior>Examine how migration system handles quoted names, especially where model `_meta` options are processed.</intended_behavior>]
2025-10-18 10:33:05.077 | INFO     | Search completed. Bug locations: [<file>django/db/backends/sqlite3/schema.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from decimal import Decimal
3 
4 from django.apps.registry import Apps
5 from django.db.backends.base.schema import BaseDatabaseSchemaEditor
6 from django.db.backends.ddl_references import Statement
7 from django.db.models import UniqueConstraint
8 from django.db.transaction import atomic
9 from django.db.utils import NotSupportedError
10 
11 
12 class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
13 
14     sql_delete_table = "DROP TABLE %(table)s"
15     sql_create_fk = None
16     sql_create_inline_fk = "REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED"
17     sql_create_unique = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)"
18     sql_delete_unique = "DROP INDEX %(name)s"
19 
20     def __enter__(self):
21         # Some SQLite schema alterations need foreign key constraints to be
22         # disabled. Enforce it here for the duration of the schema edition.
23         if not self.connection.disable_constraint_checking():
24             raise NotSupportedError(
25                 'SQLite schema editor cannot be used while foreign key '
26                 'constraint checks are enabled. Make sure to disable them '
27                 'before entering a transaction.atomic() context because '
28                 'SQLite does not support disabling them in the middle of '
29                 'a multi-statement transaction.'
30             )
31         return super().__enter__()
32 
33     def __exit__(self, exc_type, exc_value, traceback):
34         self.connection.check_constraints()
35         super().__exit__(exc_type, exc_value, traceback)
36         self.connection.enable_constraint_checking()
37 
38     def quote_value(self, value):
39         # The backend "mostly works" without this function and there are use
40         # cases for compiling Python without the sqlite3 libraries (e.g.
41         # security hardening).
42         try:
43             import sqlite3
44             value = sqlite3.adapt(value)
45         except ImportError:
46             pass
47         except sqlite3.ProgrammingError:
48             pass
49         # Manual emulation of SQLite parameter quoting
50         if isinstance(value, bool):
51             return str(int(value))
52         elif isinstance(value, (Decimal, float, int)):
53             return str(value)
54         elif isinstance(value, str):
55             return "'%s'" % value.replace("\'", "\'\'")
56         elif value is None:
57             return "NULL"
58         elif isinstance(value, (bytes, bytearray, memoryview)):
59             # Bytes are only allowed for BLOB fields, encoded as string
60             # literals containing hexadecimal data and preceded by a single "X"
61             # character.
62             return "X'%s'" % value.hex()
63         else:
64             raise ValueError("Cannot quote parameter value %r of type %s" % (value, type(value)))
65 
66     def _is_referenced_by_fk_constraint(self, table_name, column_name=None, ignore_self=False):
67         """
68         Return whether or not the provided table name is referenced by another
69         one. If `column_name` is specified, only references pointing to that
70         column are considered. If `ignore_self` is True, self-referential
71         constraints are ignored.
72         """
73         with self.connection.cursor() as cursor:
74             for other_table in self.connection.introspection.get_table_list(cursor):
75                 if ignore_self and other_table.name == table_name:
76                     continue
77                 constraints = self.connection.introspection._get_foreign_key_constraints(cursor, other_table.name)
78                 for constraint in constraints.values():
79                     constraint_table, constraint_column = constraint['foreign_key']
80                     if (constraint_table == table_name and
81                             (column_name is None or constraint_column == column_name)):
82                         return True
83         return False
84 
85     def alter_db_table(self, model, old_db_table, new_db_table, disable_constraints=True):
86         if (not self.connection.features.supports_atomic_references_rename and
87                 disable_constraints and self._is_referenced_by_fk_constraint(old_db_table)):
88             if self.connection.in_atomic_block:
89                 raise NotSupportedError((
90                     'Renaming the %r table while in a transaction is not '
91                     'supported on SQLite < 3.26 because it would break referential '
92                     'integrity. Try adding `atomic = False` to the Migration class.'
93                 ) % old_db_table)
94             self.connection.enable_constraint_checking()
95             super().alter_db_table(model, old_db_table, new_db_table)
96             self.connection.disable_constraint_checking()
97         else:
98             super().alter_db_table(model, old_db_table, new_db_table)
99 
100     def alter_field(self, model, old_field, new_field, strict=False):
101         old_field_name = old_field.name
102         table_name = model._meta.db_table
103         _, old_column_name = old_field.get_attname_column()
104         if (new_field.name != old_field_name and
105                 not self.connection.features.supports_atomic_references_rename and
106                 self._is_referenced_by_fk_constraint(table_name, old_column_name, ignore_self=True)):
107             if self.connection.in_atomic_block:
108                 raise NotSupportedError((
109                     'Renaming the %r.%r column while in a transaction is not '
110                     'supported on SQLite < 3.26 because it would break referential '
111                     'integrity. Try adding `atomic = False` to the Migration class.'
112                 ) % (model._meta.db_table, old_field_name))
113             with atomic(self.connection.alias):
114                 super().alter_field(model, old_field, new_field, strict=strict)
115                 # Follow SQLite's documented procedure for performing changes
116                 # that don't affect the on-disk content.
117                 # https://sqlite.org/lang_altertable.html#otheralter
118                 with self.connection.cursor() as cursor:
119                     schema_version = cursor.execute('PRAGMA schema_version').fetchone()[0]
120                     cursor.execute('PRAGMA writable_schema = 1')
121                     references_template = ' REFERENCES "%s" ("%%s") ' % table_name
122                     new_column_name = new_field.get_attname_column()[1]
123                     search = references_template % old_column_name
124                     replacement = references_template % new_column_name
125                     cursor.execute('UPDATE sqlite_master SET sql = replace(sql, %s, %s)', (search, replacement))
126                     cursor.execute('PRAGMA schema_version = %d' % (schema_version + 1))
127                     cursor.execute('PRAGMA writable_schema = 0')
128                     # The integrity check will raise an exception and rollback
129                     # the transaction if the sqlite_master updates corrupt the
130                     # database.
131                     cursor.execute('PRAGMA integrity_check')
132             # Perform a VACUUM to refresh the database representation from
133             # the sqlite_master table.
134             with self.connection.cursor() as cursor:
135                 cursor.execute('VACUUM')
136         else:
137             super().alter_field(model, old_field, new_field, strict=strict)
138 
139     def _remake_table(self, model, create_field=None, delete_field=None, alter_field=None):
140         """
141         Shortcut to transform a model from old_model into new_model
142 
143         This follows the correct procedure to perform non-rename or column
144         addition operations based on SQLite's documentation
145 
146         https://www.sqlite.org/lang_altertable.html#caution
147 
148         The essential steps are:
149           1. Create a table with the updated definition called "new__app_model"
150           2. Copy the data from the existing "app_model" table to the new table
151           3. Drop the "app_model" table
152           4. Rename the "new__app_model" table to "app_model"
153           5. Restore any index of the previous "app_model" table.
154         """
155         # Self-referential fields must be recreated rather than copied from
156         # the old model to ensure their remote_field.field_name doesn't refer
157         # to an altered field.
158         def is_self_referential(f):
159             return f.is_relation and f.remote_field.model is model
160         # Work out the new fields dict / mapping
161         body = {
162             f.name: f.clone() if is_self_referential(f) else f
163             for f in model._meta.local_concrete_fields
164         }
165         # Since mapping might mix column names and default values,
166         # its values must be already quoted.
167         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}
168         # This maps field names (not columns) for things like unique_together
169         rename_mapping = {}
170         # If any of the new or altered fields is introducing a new PK,
171         # remove the old one
172         restore_pk_field = None
173         if getattr(create_field, 'primary_key', False) or (
174                 alter_field and getattr(alter_field[1], 'primary_key', False)):
175             for name, field in list(body.items()):
176                 if field.primary_key:
177                     field.primary_key = False
178                     restore_pk_field = field
179                     if field.auto_created:
180                         del body[name]
181                         del mapping[field.column]
182         # Add in any created fields
183         if create_field:
184             body[create_field.name] = create_field
185             # Choose a default and insert it into the copy map
186             if not create_field.many_to_many and create_field.concrete:
187                 mapping[create_field.column] = self.quote_value(
188                     self.effective_default(create_field)
189                 )
190         # Add in any altered fields
191         if alter_field:
192             old_field, new_field = alter_field
193             body.pop(old_field.name, None)
194             mapping.pop(old_field.column, None)
195             body[new_field.name] = new_field
196             if old_field.null and not new_field.null:
197                 case_sql = "coalesce(%(col)s, %(default)s)" % {
198                     'col': self.quote_name(old_field.column),
199                     'default': self.quote_value(self.effective_default(new_field))
200                 }
201                 mapping[new_field.column] = case_sql
202             else:
203                 mapping[new_field.column] = self.quote_name(old_field.column)
204             rename_mapping[old_field.name] = new_field.name
205         # Remove any deleted fields
206         if delete_field:
207             del body[delete_field.name]
208             del mapping[delete_field.column]
209             # Remove any implicit M2M tables
210             if delete_field.many_to_many and delete_field.remote_field.through._meta.auto_created:
211                 return self.delete_model(delete_field.remote_field.through)
212         # Work inside a new app registry
213         apps = Apps()
214 
215         # Work out the new value of unique_together, taking renames into
216         # account
217         unique_together = [
218             [rename_mapping.get(n, n) for n in unique]
219             for unique in model._meta.unique_together
220         ]
221 
222         # Work out the new value for index_together, taking renames into
223         # account
224         index_together = [
225             [rename_mapping.get(n, n) for n in index]
226             for index in model._meta.index_together
227         ]
228 
229         indexes = model._meta.indexes
230         if delete_field:
231             indexes = [
232                 index for index in indexes
233                 if delete_field.name not in index.fields
234             ]
235 
236         constraints = list(model._meta.constraints)
237 
238         # Provide isolated instances of the fields to the new model body so
239         # that the existing model's internals aren't interfered with when
240         # the dummy model is constructed.
241         body_copy = copy.deepcopy(body)
242 
243         # Construct a new model with the new fields to allow self referential
244         # primary key to resolve to. This model won't ever be materialized as a
245         # table and solely exists for foreign key reference resolution purposes.
246         # This wouldn't be required if the schema editor was operating on model
247         # states instead of rendered models.
248         meta_contents = {
249             'app_label': model._meta.app_label,
250             'db_table': model._meta.db_table,
251             'unique_together': unique_together,
252             'index_together': index_together,
253             'indexes': indexes,
254             'constraints': constraints,
255             'apps': apps,
256         }
257         meta = type("Meta", (), meta_contents)
258         body_copy['Meta'] = meta
259         body_copy['__module__'] = model.__module__
260         type(model._meta.object_name, model.__bases__, body_copy)
261 
262         # Construct a model with a renamed table name.
263         body_copy = copy.deepcopy(body)
264         meta_contents = {
265             'app_label': model._meta.app_label,
266             'db_table': 'new__%s' % model._meta.db_table,
267             'unique_together': unique_together,
268             'index_together': index_together,
269             'indexes': indexes,
270             'constraints': constraints,
271             'apps': apps,
272         }
273         meta = type("Meta", (), meta_contents)
274         body_copy['Meta'] = meta
275         body_copy['__module__'] = model.__module__
276         new_model = type('New%s' % model._meta.object_name, model.__bases__, body_copy)
277 
278         # Create a new table with the updated schema.
279         self.create_model(new_model)
280 
281         # Copy data from the old table into the new table
282         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
283             self.quote_name(new_model._meta.db_table),
284             ', '.join(self.quote_name(x) for x in mapping),
285             ', '.join(mapping.values()),
286             self.quote_name(model._meta.db_table),
287         ))
288 
289         # Delete the old table to make way for the new
290         self.delete_model(model, handle_autom2m=False)
291 
292         # Rename the new table to take way for the old
293         self.alter_db_table(
294             new_model, new_model._meta.db_table, model._meta.db_table,
295             disable_constraints=False,
296         )
297 
298         # Run deferred SQL on correct table
299         for sql in self.deferred_sql:
300             self.execute(sql)
301         self.deferred_sql = []
302         # Fix any PK-removed field
303         if restore_pk_field:
304             restore_pk_field.primary_key = True
305 
306     def delete_model(self, model, handle_autom2m=True):
307         if handle_autom2m:
308             super().delete_model(model)
309         else:
310             # Delete the table (and only that)
311             self.execute(self.sql_delete_table % {
312                 "table": self.quote_name(model._meta.db_table),
313             })
314             # Remove all deferred statements referencing the deleted table.
315             for sql in list(self.deferred_sql):
316                 if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
317                     self.deferred_sql.remove(sql)
318 
319     def add_field(self, model, field):
320         """
321         Create a field on a model. Usually involves adding a column, but may
322         involve adding a table instead (for M2M fields).
323         """
324         # Special-case implicit M2M tables
325         if field.many_to_many and field.remote_field.through._meta.auto_created:
326             return self.create_model(field.remote_field.through)
327         self._remake_table(model, create_field=field)
328 
329     def remove_field(self, model, field):
330         """
331         Remove a field from a model. Usually involves deleting a column,
332         but for M2Ms may involve deleting a table.
333         """
334         # M2M fields are a special case
335         if field.many_to_many:
336             # For implicit M2M tables, delete the auto-created table
337             if field.remote_field.through._meta.auto_created:
338                 self.delete_model(field.remote_field.through)
339             # For explicit "through" M2M fields, do nothing
340         # For everything else, remake.
341         else:
342             # It might not actually have a column behind it
343             if field.db_parameters(connection=self.connection)['type'] is None:
344                 return
345             self._remake_table(model, delete_field=field)
346 
347     def _alter_field(self, model, old_field, new_field, old_type, new_type,
348                      old_db_params, new_db_params, strict=False):
349         """Perform a "physical" (non-ManyToMany) field update."""
350         # Use "ALTER TABLE ... RENAME COLUMN" if only the column name
351         # changed and there aren't any constraints.
352         if (self.connection.features.can_alter_table_rename_column and
353             old_field.column != new_field.column and
354             self.column_sql(model, old_field) == self.column_sql(model, new_field) and
355             not (old_field.remote_field and old_field.db_constraint or
356                  new_field.remote_field and new_field.db_constraint)):
357             return self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
358         # Alter by remaking table
359         self._remake_table(model, alter_field=(old_field, new_field))
360         # Rebuild tables with FKs pointing to this field if the PK type changed.
361         if old_field.primary_key and new_field.primary_key and old_type != new_type:
362             for rel in new_field.model._meta.related_objects:
363                 if not rel.many_to_many:
364                     self._remake_table(rel.related_model)
365 
366     def _alter_many_to_many(self, model, old_field, new_field, strict):
367         """Alter M2Ms to repoint their to= endpoints."""
368         if old_field.remote_field.through._meta.db_table == new_field.remote_field.through._meta.db_table:
369             # The field name didn't change, but some options did; we have to propagate this altering.
370             self._remake_table(
371                 old_field.remote_field.through,
372                 alter_field=(
373                     # We need the field that points to the target model, so we can tell alter_field to change it -
374                     # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
375                     old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
376                     new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
377                 ),
378             )
379             return
380 
381         # Make a new through table
382         self.create_model(new_field.remote_field.through)
383         # Copy the data across
384         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
385             self.quote_name(new_field.remote_field.through._meta.db_table),
386             ', '.join([
387                 "id",
388                 new_field.m2m_column_name(),
389                 new_field.m2m_reverse_name(),
390             ]),
391             ', '.join([
392                 "id",
393                 old_field.m2m_column_name(),
394                 old_field.m2m_reverse_name(),
395             ]),
396             self.quote_name(old_field.remote_field.through._meta.db_table),
397         ))
398         # Delete the old through table
399         self.delete_model(old_field.remote_field.through)
400 
401     def add_constraint(self, model, constraint):
402         if isinstance(constraint, UniqueConstraint) and constraint.condition:
403             super().add_constraint(model, constraint)
404         else:
405             self._remake_table(model)
406 
407     def remove_constraint(self, model, constraint):
408         if isinstance(constraint, UniqueConstraint) and constraint.condition:
409             super().remove_constraint(model, constraint)
410         else:
411             self._remake_table(model)

</code><intended_behavior>Look for how table creation commands are generated and executed.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>None</class>
<method>apply_migration</method>
<code>
231     def apply_migration(self, state, migration, fake=False, fake_initial=False):
232         """Run a migration forwards."""
233         migration_recorded = False
234         if self.progress_callback:
235             self.progress_callback("apply_start", migration, fake)
236         if not fake:
237             if fake_initial:
238                 # Test to see if this is an already-applied initial migration
239                 applied, state = self.detect_soft_applied(state, migration)
240                 if applied:
241                     fake = True
242             if not fake:
243                 # Alright, do it normally
244                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
245                     state = migration.apply(state, schema_editor)
246                     self.record_migration(migration)
247                     migration_recorded = True
248         if not migration_recorded:
249             self.record_migration(migration)
250         # Report progress
251         if self.progress_callback:
252             self.progress_callback("apply_success", migration, fake)
253         return state

</code><intended_behavior>Investigate methods for invoking schema changes in SQLite.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>apply_migration</method>
<code>
231     def apply_migration(self, state, migration, fake=False, fake_initial=False):
232         """Run a migration forwards."""
233         migration_recorded = False
234         if self.progress_callback:
235             self.progress_callback("apply_start", migration, fake)
236         if not fake:
237             if fake_initial:
238                 # Test to see if this is an already-applied initial migration
239                 applied, state = self.detect_soft_applied(state, migration)
240                 if applied:
241                     fake = True
242             if not fake:
243                 # Alright, do it normally
244                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
245                     state = migration.apply(state, schema_editor)
246                     self.record_migration(migration)
247                     migration_recorded = True
248         if not migration_recorded:
249             self.record_migration(migration)
250         # Report progress
251         if self.progress_callback:
252             self.progress_callback("apply_success", migration, fake)
253         return state

</code><intended_behavior>Investigate methods for invoking schema changes in SQLite.</intended_behavior>, <file>django/db/models/options.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import inspect
3 from bisect import bisect
4 from collections import defaultdict
5 
6 from django.apps import apps
7 from django.conf import settings
8 from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured
9 from django.db import connections
10 from django.db.models import Manager
11 from django.db.models.fields import AutoField
12 from django.db.models.fields.proxy import OrderWrt
13 from django.db.models.query_utils import PathInfo
14 from django.utils.datastructures import ImmutableList, OrderedSet
15 from django.utils.functional import cached_property
16 from django.utils.text import camel_case_to_spaces, format_lazy
17 from django.utils.translation import override
18 
19 PROXY_PARENTS = object()
20 
21 EMPTY_RELATION_TREE = ()
22 
23 IMMUTABLE_WARNING = (
24     "The return type of '%s' should never be mutated. If you want to manipulate this list "
25     "for your own use, make a copy first."
26 )
27 
28 DEFAULT_NAMES = (
29     'verbose_name', 'verbose_name_plural', 'db_table', 'ordering',
30     'unique_together', 'permissions', 'get_latest_by', 'order_with_respect_to',
31     'app_label', 'db_tablespace', 'abstract', 'managed', 'proxy', 'swappable',
32     'auto_created', 'index_together', 'apps', 'default_permissions',
33     'select_on_save', 'default_related_name', 'required_db_features',
34     'required_db_vendor', 'base_manager_name', 'default_manager_name',
35     'indexes', 'constraints',
36 )
37 
38 
39 def normalize_together(option_together):
40     """
41     option_together can be either a tuple of tuples, or a single
42     tuple of two strings. Normalize it to a tuple of tuples, so that
43     calling code can uniformly expect that.
44     """
45     try:
46         if not option_together:
47             return ()
48         if not isinstance(option_together, (tuple, list)):
49             raise TypeError
50         first_element = option_together[0]
51         if not isinstance(first_element, (tuple, list)):
52             option_together = (option_together,)
53         # Normalize everything to tuples
54         return tuple(tuple(ot) for ot in option_together)
55     except TypeError:
56         # If the value of option_together isn't valid, return it
57         # verbatim; this will be picked up by the check framework later.
58         return option_together
59 
60 
61 def make_immutable_fields_list(name, data):
62     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
63 
64 
65 class Options:
66     FORWARD_PROPERTIES = {
67         'fields', 'many_to_many', 'concrete_fields', 'local_concrete_fields',
68         '_forward_fields_map', 'managers', 'managers_map', 'base_manager',
69         'default_manager',
70     }
71     REVERSE_PROPERTIES = {'related_objects', 'fields_map', '_relation_tree'}
72 
73     default_apps = apps
74 
75     def __init__(self, meta, app_label=None):
76         self._get_fields_cache = {}
77         self.local_fields = []
78         self.local_many_to_many = []
79         self.private_fields = []
80         self.local_managers = []
81         self.base_manager_name = None
82         self.default_manager_name = None
83         self.model_name = None
84         self.verbose_name = None
85         self.verbose_name_plural = None
86         self.db_table = ''
87         self.ordering = []
88         self._ordering_clash = False
89         self.indexes = []
90         self.constraints = []
91         self.unique_together = []
92         self.index_together = []
93         self.select_on_save = False
94         self.default_permissions = ('add', 'change', 'delete', 'view')
95         self.permissions = []
96         self.object_name = None
97         self.app_label = app_label
98         self.get_latest_by = None
99         self.order_with_respect_to = None
100         self.db_tablespace = settings.DEFAULT_TABLESPACE
101         self.required_db_features = []
102         self.required_db_vendor = None
103         self.meta = meta
104         self.pk = None
105         self.auto_field = None
106         self.abstract = False
107         self.managed = True
108         self.proxy = False
109         # For any class that is a proxy (including automatically created
110         # classes for deferred object loading), proxy_for_model tells us
111         # which class this model is proxying. Note that proxy_for_model
112         # can create a chain of proxy models. For non-proxy models, the
113         # variable is always None.
114         self.proxy_for_model = None
115         # For any non-abstract class, the concrete class is the model
116         # in the end of the proxy_for_model chain. In particular, for
117         # concrete models, the concrete_model is always the class itself.
118         self.concrete_model = None
119         self.swappable = None
120         self.parents = {}
121         self.auto_created = False
122 
123         # List of all lookups defined in ForeignKey 'limit_choices_to' options
124         # from *other* models. Needed for some admin checks. Internal use only.
125         self.related_fkey_lookups = []
126 
127         # A custom app registry to use, if you're making a separate model set.
128         self.apps = self.default_apps
129 
130         self.default_related_name = None
131 
132     @property
133     def label(self):
134         return '%s.%s' % (self.app_label, self.object_name)
135 
136     @property
137     def label_lower(self):
138         return '%s.%s' % (self.app_label, self.model_name)
139 
140     @property
141     def app_config(self):
142         # Don't go through get_app_config to avoid triggering imports.
143         return self.apps.app_configs.get(self.app_label)
144 
145     @property
146     def installed(self):
147         return self.app_config is not None
148 
149     def contribute_to_class(self, cls, name):
150         from django.db import connection
151         from django.db.backends.utils import truncate_name
152 
153         cls._meta = self
154         self.model = cls
155         # First, construct the default values for these options.
156         self.object_name = cls.__name__
157         self.model_name = self.object_name.lower()
158         self.verbose_name = camel_case_to_spaces(self.object_name)
159 
160         # Store the original user-defined values for each option,
161         # for use when serializing the model definition
162         self.original_attrs = {}
163 
164         # Next, apply any overridden values from 'class Meta'.
165         if self.meta:
166             meta_attrs = self.meta.__dict__.copy()
167             for name in self.meta.__dict__:
168                 # Ignore any private attributes that Django doesn't care about.
169                 # NOTE: We can't modify a dictionary's contents while looping
170                 # over it, so we loop over the *original* dictionary instead.
171                 if name.startswith('_'):
172                     del meta_attrs[name]
173             for attr_name in DEFAULT_NAMES:
174                 if attr_name in meta_attrs:
175                     setattr(self, attr_name, meta_attrs.pop(attr_name))
176                     self.original_attrs[attr_name] = getattr(self, attr_name)
177                 elif hasattr(self.meta, attr_name):
178                     setattr(self, attr_name, getattr(self.meta, attr_name))
179                     self.original_attrs[attr_name] = getattr(self, attr_name)
180 
181             self.unique_together = normalize_together(self.unique_together)
182             self.index_together = normalize_together(self.index_together)
183             # App label/class name interpolation for names of constraints and
184             # indexes.
185             if not getattr(cls._meta, 'abstract', False):
186                 for attr_name in {'constraints', 'indexes'}:
187                     objs = getattr(self, attr_name, [])
188                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
189 
190             # verbose_name_plural is a special case because it uses a 's'
191             # by default.
192             if self.verbose_name_plural is None:
193                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
194 
195             # order_with_respect_and ordering are mutually exclusive.
196             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
197 
198             # Any leftover attributes must be invalid.
199             if meta_attrs != {}:
200                 raise TypeError("'class Meta' got invalid attribute(s): %s" % ','.join(meta_attrs))
201         else:
202             self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
203         del self.meta
204 
205         # If the db_table wasn't provided, use the app_label + model_name.
206         if not self.db_table:
207             self.db_table = "%s_%s" % (self.app_label, self.model_name)
208             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
209 
210     def _format_names_with_class(self, cls, objs):
211         """App label/class name interpolation for object names."""
212         new_objs = []
213         for obj in objs:
214             obj = obj.clone()
215             obj.name = obj.name % {
216                 'app_label': cls._meta.app_label.lower(),
217                 'class': cls.__name__.lower(),
218             }
219             new_objs.append(obj)
220         return new_objs
221 
222     def _prepare(self, model):
223         if self.order_with_respect_to:
224             # The app registry will not be ready at this point, so we cannot
225             # use get_field().
226             query = self.order_with_respect_to
227             try:
228                 self.order_with_respect_to = next(
229                     f for f in self._get_fields(reverse=False)
230                     if f.name == query or f.attname == query
231                 )
232             except StopIteration:
233                 raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, query))
234 
235             self.ordering = ('_order',)
236             if not any(isinstance(field, OrderWrt) for field in model._meta.local_fields):
237                 model.add_to_class('_order', OrderWrt())
238         else:
239             self.order_with_respect_to = None
240 
241         if self.pk is None:
242             if self.parents:
243                 # Promote the first parent link in lieu of adding yet another
244                 # field.
245                 field = next(iter(self.parents.values()))
246                 # Look for a local field with the same name as the
247                 # first parent link. If a local field has already been
248                 # created, use it instead of promoting the parent
249                 already_created = [fld for fld in self.local_fields if fld.name == field.name]
250                 if already_created:
251                     field = already_created[0]
252                 field.primary_key = True
253                 self.setup_pk(field)
254                 if not field.remote_field.parent_link:
255                     raise ImproperlyConfigured(
256                         'Add parent_link=True to %s.' % field,
257                     )
258             else:
259                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
260                 model.add_to_class('id', auto)
261 
262     def add_manager(self, manager):
263         self.local_managers.append(manager)
264         self._expire_cache()
265 
266     def add_field(self, field, private=False):
267         # Insert the given field in the order in which it was created, using
268         # the "creation_counter" attribute of the field.
269         # Move many-to-many related fields from self.fields into
270         # self.many_to_many.
271         if private:
272             self.private_fields.append(field)
273         elif field.is_relation and field.many_to_many:
274             self.local_many_to_many.insert(bisect(self.local_many_to_many, field), field)
275         else:
276             self.local_fields.insert(bisect(self.local_fields, field), field)
277             self.setup_pk(field)
278 
279         # If the field being added is a relation to another known field,
280         # expire the cache on this field and the forward cache on the field
281         # being referenced, because there will be new relationships in the
282         # cache. Otherwise, expire the cache of references *to* this field.
283         # The mechanism for getting at the related model is slightly odd -
284         # ideally, we'd just ask for field.related_model. However, related_model
285         # is a cached property, and all the models haven't been loaded yet, so
286         # we need to make sure we don't cache a string reference.
287         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
288             try:
289                 field.remote_field.model._meta._expire_cache(forward=False)
290             except AttributeError:
291                 pass
292             self._expire_cache()
293         else:
294             self._expire_cache(reverse=False)
295 
296     def setup_pk(self, field):
297         if not self.pk and field.primary_key:
298             self.pk = field
299             field.serialize = False
300 
301     def setup_proxy(self, target):
302         """
303         Do the internal setup so that the current model is a proxy for
304         "target".
305         """
306         self.pk = target._meta.pk
307         self.proxy_for_model = target
308         self.db_table = target._meta.db_table
309 
310     def __repr__(self):
311         return '<Options for %s>' % self.object_name
312 
313     def __str__(self):
314         return "%s.%s" % (self.app_label, self.model_name)
315 
316     def can_migrate(self, connection):
317         """
318         Return True if the model can/should be migrated on the `connection`.
319         `connection` can be either a real connection or a connection alias.
320         """
321         if self.proxy or self.swapped or not self.managed:
322             return False
323         if isinstance(connection, str):
324             connection = connections[connection]
325         if self.required_db_vendor:
326             return self.required_db_vendor == connection.vendor
327         if self.required_db_features:
328             return all(getattr(connection.features, feat, False)
329                        for feat in self.required_db_features)
330         return True
331 
332     @property
333     def verbose_name_raw(self):
334         """Return the untranslated verbose name."""
335         with override(None):
336             return str(self.verbose_name)
337 
338     @property
339     def swapped(self):
340         """
341         Has this model been swapped out for another? If so, return the model
342         name of the replacement; otherwise, return None.
343 
344         For historical reasons, model name lookups using get_model() are
345         case insensitive, so we make sure we are case insensitive here.
346         """
347         if self.swappable:
348             swapped_for = getattr(settings, self.swappable, None)
349             if swapped_for:
350                 try:
351                     swapped_label, swapped_object = swapped_for.split('.')
352                 except ValueError:
353                     # setting not in the format app_label.model_name
354                     # raising ImproperlyConfigured here causes problems with
355                     # test cleanup code - instead it is raised in get_user_model
356                     # or as part of validation.
357                     return swapped_for
358 
359                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
360                     return swapped_for
361         return None
362 
363     @cached_property
364     def managers(self):
365         managers = []
366         seen_managers = set()
367         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
368         for depth, base in enumerate(bases):
369             for manager in base._meta.local_managers:
370                 if manager.name in seen_managers:
371                     continue
372 
373                 manager = copy.copy(manager)
374                 manager.model = self.model
375                 seen_managers.add(manager.name)
376                 managers.append((depth, manager.creation_counter, manager))
377 
378         return make_immutable_fields_list(
379             "managers",
380             (m[2] for m in sorted(managers)),
381         )
382 
383     @cached_property
384     def managers_map(self):
385         return {manager.name: manager for manager in self.managers}
386 
387     @cached_property
388     def base_manager(self):
389         base_manager_name = self.base_manager_name
390         if not base_manager_name:
391             # Get the first parent's base_manager_name if there's one.
392             for parent in self.model.mro()[1:]:
393                 if hasattr(parent, '_meta'):
394                     if parent._base_manager.name != '_base_manager':
395                         base_manager_name = parent._base_manager.name
396                     break
397 
398         if base_manager_name:
399             try:
400                 return self.managers_map[base_manager_name]
401             except KeyError:
402                 raise ValueError(
403                     "%s has no manager named %r" % (
404                         self.object_name,
405                         base_manager_name,
406                     )
407                 )
408 
409         manager = Manager()
410         manager.name = '_base_manager'
411         manager.model = self.model
412         manager.auto_created = True
413         return manager
414 
415     @cached_property
416     def default_manager(self):
417         default_manager_name = self.default_manager_name
418         if not default_manager_name and not self.local_managers:
419             # Get the first parent's default_manager_name if there's one.
420             for parent in self.model.mro()[1:]:
421                 if hasattr(parent, '_meta'):
422                     default_manager_name = parent._meta.default_manager_name
423                     break
424 
425         if default_manager_name:
426             try:
427                 return self.managers_map[default_manager_name]
428             except KeyError:
429                 raise ValueError(
430                     "%s has no manager named %r" % (
431                         self.object_name,
432                         default_manager_name,
433                     )
434                 )
435 
436         if self.managers:
437             return self.managers[0]
438 
439     @cached_property
440     def fields(self):
441         """
442         Return a list of all forward fields on the model and its parents,
443         excluding ManyToManyFields.
444 
445         Private API intended only to be used by Django itself; get_fields()
446         combined with filtering of field properties is the public API for
447         obtaining this field list.
448         """
449         # For legacy reasons, the fields property should only contain forward
450         # fields that are not private or with a m2m cardinality. Therefore we
451         # pass these three filters as filters to the generator.
452         # The third lambda is a longwinded way of checking f.related_model - we don't
453         # use that property directly because related_model is a cached property,
454         # and all the models may not have been loaded yet; we don't want to cache
455         # the string reference to the related_model.
456         def is_not_an_m2m_field(f):
457             return not (f.is_relation and f.many_to_many)
458 
459         def is_not_a_generic_relation(f):
460             return not (f.is_relation and f.one_to_many)
461 
462         def is_not_a_generic_foreign_key(f):
463             return not (
464                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
465             )
466 
467         return make_immutable_fields_list(
468             "fields",
469             (f for f in self._get_fields(reverse=False)
470              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
471         )
472 
473     @cached_property
474     def concrete_fields(self):
475         """
476         Return a list of all concrete fields on the model and its parents.
477 
478         Private API intended only to be used by Django itself; get_fields()
479         combined with filtering of field properties is the public API for
480         obtaining this field list.
481         """
482         return make_immutable_fields_list(
483             "concrete_fields", (f for f in self.fields if f.concrete)
484         )
485 
486     @cached_property
487     def local_concrete_fields(self):
488         """
489         Return a list of all concrete fields on the model.
490 
491         Private API intended only to be used by Django itself; get_fields()
492         combined with filtering of field properties is the public API for
493         obtaining this field list.
494         """
495         return make_immutable_fields_list(
496             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
497         )
498 
499     @cached_property
500     def many_to_many(self):
501         """
502         Return a list of all many to many fields on the model and its parents.
503 
504         Private API intended only to be used by Django itself; get_fields()
505         combined with filtering of field properties is the public API for
506         obtaining this list.
507         """
508         return make_immutable_fields_list(
509             "many_to_many",
510             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
511         )
512 
513     @cached_property
514     def related_objects(self):
515         """
516         Return all related objects pointing to the current model. The related
517         objects can come from a one-to-one, one-to-many, or many-to-many field
518         relation type.
519 
520         Private API intended only to be used by Django itself; get_fields()
521         combined with filtering of field properties is the public API for
522         obtaining this field list.
523         """
524         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
525         return make_immutable_fields_list(
526             "related_objects",
527             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
528         )
529 
530     @cached_property
531     def _forward_fields_map(self):
532         res = {}
533         fields = self._get_fields(reverse=False)
534         for field in fields:
535             res[field.name] = field
536             # Due to the way Django's internals work, get_field() should also
537             # be able to fetch a field by attname. In the case of a concrete
538             # field with relation, includes the *_id name too
539             try:
540                 res[field.attname] = field
541             except AttributeError:
542                 pass
543         return res
544 
545     @cached_property
546     def fields_map(self):
547         res = {}
548         fields = self._get_fields(forward=False, include_hidden=True)
549         for field in fields:
550             res[field.name] = field
551             # Due to the way Django's internals work, get_field() should also
552             # be able to fetch a field by attname. In the case of a concrete
553             # field with relation, includes the *_id name too
554             try:
555                 res[field.attname] = field
556             except AttributeError:
557                 pass
558         return res
559 
560     def get_field(self, field_name):
561         """
562         Return a field instance given the name of a forward or reverse field.
563         """
564         try:
565             # In order to avoid premature loading of the relation tree
566             # (expensive) we prefer checking if the field is a forward field.
567             return self._forward_fields_map[field_name]
568         except KeyError:
569             # If the app registry is not ready, reverse fields are
570             # unavailable, therefore we throw a FieldDoesNotExist exception.
571             if not self.apps.models_ready:
572                 raise FieldDoesNotExist(
573                     "%s has no field named '%s'. The app cache isn't ready yet, "
574                     "so if this is an auto-created related field, it won't "
575                     "be available yet." % (self.object_name, field_name)
576                 )
577 
578         try:
579             # Retrieve field instance by name from cached or just-computed
580             # field map.
581             return self.fields_map[field_name]
582         except KeyError:
583             raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, field_name))
584 
585     def get_base_chain(self, model):
586         """
587         Return a list of parent classes leading to `model` (ordered from
588         closest to most distant ancestor). This has to handle the case where
589         `model` is a grandparent or even more distant relation.
590         """
591         if not self.parents:
592             return []
593         if model in self.parents:
594             return [model]
595         for parent in self.parents:
596             res = parent._meta.get_base_chain(model)
597             if res:
598                 res.insert(0, parent)
599                 return res
600         return []
601 
602     def get_parent_list(self):
603         """
604         Return all the ancestors of this model as a list ordered by MRO.
605         Useful for determining if something is an ancestor, regardless of lineage.
606         """
607         result = OrderedSet(self.parents)
608         for parent in self.parents:
609             for ancestor in parent._meta.get_parent_list():
610                 result.add(ancestor)
611         return list(result)
612 
613     def get_ancestor_link(self, ancestor):
614         """
615         Return the field on the current model which points to the given
616         "ancestor". This is possible an indirect link (a pointer to a parent
617         model, which points, eventually, to the ancestor). Used when
618         constructing table joins for model inheritance.
619 
620         Return None if the model isn't an ancestor of this one.
621         """
622         if ancestor in self.parents:
623             return self.parents[ancestor]
624         for parent in self.parents:
625             # Tries to get a link field from the immediate parent
626             parent_link = parent._meta.get_ancestor_link(ancestor)
627             if parent_link:
628                 # In case of a proxied model, the first link
629                 # of the chain to the ancestor is that parent
630                 # links
631                 return self.parents[parent] or parent_link
632 
633     def get_path_to_parent(self, parent):
634         """
635         Return a list of PathInfos containing the path from the current
636         model to the parent model, or an empty list if parent is not a
637         parent of the current model.
638         """
639         if self.model is parent:
640             return []
641         # Skip the chain of proxy to the concrete proxied model.
642         proxied_model = self.concrete_model
643         path = []
644         opts = self
645         for int_model in self.get_base_chain(parent):
646             if int_model is proxied_model:
647                 opts = int_model._meta
648             else:
649                 final_field = opts.parents[int_model]
650                 targets = (final_field.remote_field.get_related_field(),)
651                 opts = int_model._meta
652                 path.append(PathInfo(
653                     from_opts=final_field.model._meta,
654                     to_opts=opts,
655                     target_fields=targets,
656                     join_field=final_field,
657                     m2m=False,
658                     direct=True,
659                     filtered_relation=None,
660                 ))
661         return path
662 
663     def get_path_from_parent(self, parent):
664         """
665         Return a list of PathInfos containing the path from the parent
666         model to the current model, or an empty list if parent is not a
667         parent of the current model.
668         """
669         if self.model is parent:
670             return []
671         model = self.concrete_model
672         # Get a reversed base chain including both the current and parent
673         # models.
674         chain = model._meta.get_base_chain(parent)
675         chain.reverse()
676         chain.append(model)
677         # Construct a list of the PathInfos between models in chain.
678         path = []
679         for i, ancestor in enumerate(chain[:-1]):
680             child = chain[i + 1]
681             link = child._meta.get_ancestor_link(ancestor)
682             path.extend(link.get_reverse_path_info())
683         return path
684 
685     def _populate_directed_relation_graph(self):
686         """
687         This method is used by each model to find its reverse objects. As this
688         method is very expensive and is accessed frequently (it looks up every
689         field in a model, in every app), it is computed on first access and then
690         is set as a property on every model.
691         """
692         related_objects_graph = defaultdict(list)
693 
694         all_models = self.apps.get_models(include_auto_created=True)
695         for model in all_models:
696             opts = model._meta
697             # Abstract model's fields are copied to child models, hence we will
698             # see the fields from the child models.
699             if opts.abstract:
700                 continue
701             fields_with_relations = (
702                 f for f in opts._get_fields(reverse=False, include_parents=False)
703                 if f.is_relation and f.related_model is not None
704             )
705             for f in fields_with_relations:
706                 if not isinstance(f.remote_field.model, str):
707                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
708 
709         for model in all_models:
710             # Set the relation_tree using the internal __dict__. In this way
711             # we avoid calling the cached property. In attribute lookup,
712             # __dict__ takes precedence over a data descriptor (such as
713             # @cached_property). This means that the _meta._relation_tree is
714             # only called if related_objects is not in __dict__.
715             related_objects = related_objects_graph[model._meta.concrete_model._meta]
716             model._meta.__dict__['_relation_tree'] = related_objects
717         # It seems it is possible that self is not in all_models, so guard
718         # against that with default for get().
719         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
720 
721     @cached_property
722     def _relation_tree(self):
723         return self._populate_directed_relation_graph()
724 
725     def _expire_cache(self, forward=True, reverse=True):
726         # This method is usually called by apps.cache_clear(), when the
727         # registry is finalized, or when a new field is added.
728         if forward:
729             for cache_key in self.FORWARD_PROPERTIES:
730                 if cache_key in self.__dict__:
731                     delattr(self, cache_key)
732         if reverse and not self.abstract:
733             for cache_key in self.REVERSE_PROPERTIES:
734                 if cache_key in self.__dict__:
735                     delattr(self, cache_key)
736         self._get_fields_cache = {}
737 
738     def get_fields(self, include_parents=True, include_hidden=False):
739         """
740         Return a list of fields associated to the model. By default, include
741         forward and reverse fields, fields derived from inheritance, but not
742         hidden fields. The returned fields can be changed using the parameters:
743 
744         - include_parents: include fields derived from inheritance
745         - include_hidden:  include fields that have a related_name that
746                            starts with a "+"
747         """
748         if include_parents is False:
749             include_parents = PROXY_PARENTS
750         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
751 
752     def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False,
753                     seen_models=None):
754         """
755         Internal helper function to return fields of the model.
756         * If forward=True, then fields defined on this model are returned.
757         * If reverse=True, then relations pointing to this model are returned.
758         * If include_hidden=True, then fields with is_hidden=True are returned.
759         * The include_parents argument toggles if fields from parent models
760           should be included. It has three values: True, False, and
761           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all
762           fields defined for the current model or any of its parents in the
763           parent chain to the model's concrete model.
764         """
765         if include_parents not in (True, False, PROXY_PARENTS):
766             raise TypeError("Invalid argument for include_parents: %s" % (include_parents,))
767         # This helper function is used to allow recursion in ``get_fields()``
768         # implementation and to provide a fast way for Django's internals to
769         # access specific subsets of fields.
770 
771         # We must keep track of which models we have already seen. Otherwise we
772         # could include the same field multiple times from different models.
773         topmost_call = seen_models is None
774         if topmost_call:
775             seen_models = set()
776         seen_models.add(self.model)
777 
778         # Creates a cache key composed of all arguments
779         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
780 
781         try:
782             # In order to avoid list manipulation. Always return a shallow copy
783             # of the results.
784             return self._get_fields_cache[cache_key]
785         except KeyError:
786             pass
787 
788         fields = []
789         # Recursively call _get_fields() on each parent, with the same
790         # options provided in this call.
791         if include_parents is not False:
792             for parent in self.parents:
793                 # In diamond inheritance it is possible that we see the same
794                 # model from two different routes. In that case, avoid adding
795                 # fields from the same parent again.
796                 if parent in seen_models:
797                     continue
798                 if (parent._meta.concrete_model != self.concrete_model and
799                         include_parents == PROXY_PARENTS):
800                     continue
801                 for obj in parent._meta._get_fields(
802                         forward=forward, reverse=reverse, include_parents=include_parents,
803                         include_hidden=include_hidden, seen_models=seen_models):
804                     if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:
805                         fields.append(obj)
806         if reverse and not self.proxy:
807             # Tree is computed once and cached until the app cache is expired.
808             # It is composed of a list of fields pointing to the current model
809             # from other models.
810             all_fields = self._relation_tree
811             for field in all_fields:
812                 # If hidden fields should be included or the relation is not
813                 # intentionally hidden, add to the fields dict.
814                 if include_hidden or not field.remote_field.hidden:
815                     fields.append(field.remote_field)
816 
817         if forward:
818             fields += self.local_fields
819             fields += self.local_many_to_many
820             # Private fields are recopied to each child model, and they get a
821             # different model as field.model in each child. Hence we have to
822             # add the private fields separately from the topmost call. If we
823             # did this recursively similar to local_fields, we would get field
824             # instances with field.model != self.model.
825             if topmost_call:
826                 fields += self.private_fields
827 
828         # In order to avoid list manipulation. Always
829         # return a shallow copy of the results
830         fields = make_immutable_fields_list("get_fields()", fields)
831 
832         # Store result into cache for later access
833         self._get_fields_cache[cache_key] = fields
834         return fields
835 
836     @cached_property
837     def _property_names(self):
838         """Return a set of the names of the properties defined on the model."""
839         names = []
840         for name in dir(self.model):
841             attr = inspect.getattr_static(self.model, name)
842             if isinstance(attr, property):
843                 names.append(name)
844         return frozenset(names)

</code><intended_behavior>Examine how migration system handles quoted names, especially where model `_meta` options are processed.</intended_behavior>]
2025-10-18 10:33:05.078 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 10:33:05.078 | INFO     | Search-only: skipping patch selection
2025-10-18 10:33:05.212 | INFO     | Task django__django-11612 completed successfully.
2025-10-18 10:33:05.213 | INFO     | No patch generated. You can try running ACR again.
