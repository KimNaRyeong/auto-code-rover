[
    {
        "rel_file_path": "django/db/backends/sqlite3/schema.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/sqlite3/schema.py",
        "start": 1,
        "end": 411,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 from decimal import Decimal\n3 \n4 from django.apps.registry import Apps\n5 from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n6 from django.db.backends.ddl_references import Statement\n7 from django.db.models import UniqueConstraint\n8 from django.db.transaction import atomic\n9 from django.db.utils import NotSupportedError\n10 \n11 \n12 class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n13 \n14     sql_delete_table = \"DROP TABLE %(table)s\"\n15     sql_create_fk = None\n16     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n17     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n18     sql_delete_unique = \"DROP INDEX %(name)s\"\n19 \n20     def __enter__(self):\n21         # Some SQLite schema alterations need foreign key constraints to be\n22         # disabled. Enforce it here for the duration of the schema edition.\n23         if not self.connection.disable_constraint_checking():\n24             raise NotSupportedError(\n25                 'SQLite schema editor cannot be used while foreign key '\n26                 'constraint checks are enabled. Make sure to disable them '\n27                 'before entering a transaction.atomic() context because '\n28                 'SQLite does not support disabling them in the middle of '\n29                 'a multi-statement transaction.'\n30             )\n31         return super().__enter__()\n32 \n33     def __exit__(self, exc_type, exc_value, traceback):\n34         self.connection.check_constraints()\n35         super().__exit__(exc_type, exc_value, traceback)\n36         self.connection.enable_constraint_checking()\n37 \n38     def quote_value(self, value):\n39         # The backend \"mostly works\" without this function and there are use\n40         # cases for compiling Python without the sqlite3 libraries (e.g.\n41         # security hardening).\n42         try:\n43             import sqlite3\n44             value = sqlite3.adapt(value)\n45         except ImportError:\n46             pass\n47         except sqlite3.ProgrammingError:\n48             pass\n49         # Manual emulation of SQLite parameter quoting\n50         if isinstance(value, bool):\n51             return str(int(value))\n52         elif isinstance(value, (Decimal, float, int)):\n53             return str(value)\n54         elif isinstance(value, str):\n55             return \"'%s'\" % value.replace(\"\\'\", \"\\'\\'\")\n56         elif value is None:\n57             return \"NULL\"\n58         elif isinstance(value, (bytes, bytearray, memoryview)):\n59             # Bytes are only allowed for BLOB fields, encoded as string\n60             # literals containing hexadecimal data and preceded by a single \"X\"\n61             # character.\n62             return \"X'%s'\" % value.hex()\n63         else:\n64             raise ValueError(\"Cannot quote parameter value %r of type %s\" % (value, type(value)))\n65 \n66     def _is_referenced_by_fk_constraint(self, table_name, column_name=None, ignore_self=False):\n67         \"\"\"\n68         Return whether or not the provided table name is referenced by another\n69         one. If `column_name` is specified, only references pointing to that\n70         column are considered. If `ignore_self` is True, self-referential\n71         constraints are ignored.\n72         \"\"\"\n73         with self.connection.cursor() as cursor:\n74             for other_table in self.connection.introspection.get_table_list(cursor):\n75                 if ignore_self and other_table.name == table_name:\n76                     continue\n77                 constraints = self.connection.introspection._get_foreign_key_constraints(cursor, other_table.name)\n78                 for constraint in constraints.values():\n79                     constraint_table, constraint_column = constraint['foreign_key']\n80                     if (constraint_table == table_name and\n81                             (column_name is None or constraint_column == column_name)):\n82                         return True\n83         return False\n84 \n85     def alter_db_table(self, model, old_db_table, new_db_table, disable_constraints=True):\n86         if (not self.connection.features.supports_atomic_references_rename and\n87                 disable_constraints and self._is_referenced_by_fk_constraint(old_db_table)):\n88             if self.connection.in_atomic_block:\n89                 raise NotSupportedError((\n90                     'Renaming the %r table while in a transaction is not '\n91                     'supported on SQLite < 3.26 because it would break referential '\n92                     'integrity. Try adding `atomic = False` to the Migration class.'\n93                 ) % old_db_table)\n94             self.connection.enable_constraint_checking()\n95             super().alter_db_table(model, old_db_table, new_db_table)\n96             self.connection.disable_constraint_checking()\n97         else:\n98             super().alter_db_table(model, old_db_table, new_db_table)\n99 \n100     def alter_field(self, model, old_field, new_field, strict=False):\n101         old_field_name = old_field.name\n102         table_name = model._meta.db_table\n103         _, old_column_name = old_field.get_attname_column()\n104         if (new_field.name != old_field_name and\n105                 not self.connection.features.supports_atomic_references_rename and\n106                 self._is_referenced_by_fk_constraint(table_name, old_column_name, ignore_self=True)):\n107             if self.connection.in_atomic_block:\n108                 raise NotSupportedError((\n109                     'Renaming the %r.%r column while in a transaction is not '\n110                     'supported on SQLite < 3.26 because it would break referential '\n111                     'integrity. Try adding `atomic = False` to the Migration class.'\n112                 ) % (model._meta.db_table, old_field_name))\n113             with atomic(self.connection.alias):\n114                 super().alter_field(model, old_field, new_field, strict=strict)\n115                 # Follow SQLite's documented procedure for performing changes\n116                 # that don't affect the on-disk content.\n117                 # https://sqlite.org/lang_altertable.html#otheralter\n118                 with self.connection.cursor() as cursor:\n119                     schema_version = cursor.execute('PRAGMA schema_version').fetchone()[0]\n120                     cursor.execute('PRAGMA writable_schema = 1')\n121                     references_template = ' REFERENCES \"%s\" (\"%%s\") ' % table_name\n122                     new_column_name = new_field.get_attname_column()[1]\n123                     search = references_template % old_column_name\n124                     replacement = references_template % new_column_name\n125                     cursor.execute('UPDATE sqlite_master SET sql = replace(sql, %s, %s)', (search, replacement))\n126                     cursor.execute('PRAGMA schema_version = %d' % (schema_version + 1))\n127                     cursor.execute('PRAGMA writable_schema = 0')\n128                     # The integrity check will raise an exception and rollback\n129                     # the transaction if the sqlite_master updates corrupt the\n130                     # database.\n131                     cursor.execute('PRAGMA integrity_check')\n132             # Perform a VACUUM to refresh the database representation from\n133             # the sqlite_master table.\n134             with self.connection.cursor() as cursor:\n135                 cursor.execute('VACUUM')\n136         else:\n137             super().alter_field(model, old_field, new_field, strict=strict)\n138 \n139     def _remake_table(self, model, create_field=None, delete_field=None, alter_field=None):\n140         \"\"\"\n141         Shortcut to transform a model from old_model into new_model\n142 \n143         This follows the correct procedure to perform non-rename or column\n144         addition operations based on SQLite's documentation\n145 \n146         https://www.sqlite.org/lang_altertable.html#caution\n147 \n148         The essential steps are:\n149           1. Create a table with the updated definition called \"new__app_model\"\n150           2. Copy the data from the existing \"app_model\" table to the new table\n151           3. Drop the \"app_model\" table\n152           4. Rename the \"new__app_model\" table to \"app_model\"\n153           5. Restore any index of the previous \"app_model\" table.\n154         \"\"\"\n155         # Self-referential fields must be recreated rather than copied from\n156         # the old model to ensure their remote_field.field_name doesn't refer\n157         # to an altered field.\n158         def is_self_referential(f):\n159             return f.is_relation and f.remote_field.model is model\n160         # Work out the new fields dict / mapping\n161         body = {\n162             f.name: f.clone() if is_self_referential(f) else f\n163             for f in model._meta.local_concrete_fields\n164         }\n165         # Since mapping might mix column names and default values,\n166         # its values must be already quoted.\n167         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}\n168         # This maps field names (not columns) for things like unique_together\n169         rename_mapping = {}\n170         # If any of the new or altered fields is introducing a new PK,\n171         # remove the old one\n172         restore_pk_field = None\n173         if getattr(create_field, 'primary_key', False) or (\n174                 alter_field and getattr(alter_field[1], 'primary_key', False)):\n175             for name, field in list(body.items()):\n176                 if field.primary_key:\n177                     field.primary_key = False\n178                     restore_pk_field = field\n179                     if field.auto_created:\n180                         del body[name]\n181                         del mapping[field.column]\n182         # Add in any created fields\n183         if create_field:\n184             body[create_field.name] = create_field\n185             # Choose a default and insert it into the copy map\n186             if not create_field.many_to_many and create_field.concrete:\n187                 mapping[create_field.column] = self.quote_value(\n188                     self.effective_default(create_field)\n189                 )\n190         # Add in any altered fields\n191         if alter_field:\n192             old_field, new_field = alter_field\n193             body.pop(old_field.name, None)\n194             mapping.pop(old_field.column, None)\n195             body[new_field.name] = new_field\n196             if old_field.null and not new_field.null:\n197                 case_sql = \"coalesce(%(col)s, %(default)s)\" % {\n198                     'col': self.quote_name(old_field.column),\n199                     'default': self.quote_value(self.effective_default(new_field))\n200                 }\n201                 mapping[new_field.column] = case_sql\n202             else:\n203                 mapping[new_field.column] = self.quote_name(old_field.column)\n204             rename_mapping[old_field.name] = new_field.name\n205         # Remove any deleted fields\n206         if delete_field:\n207             del body[delete_field.name]\n208             del mapping[delete_field.column]\n209             # Remove any implicit M2M tables\n210             if delete_field.many_to_many and delete_field.remote_field.through._meta.auto_created:\n211                 return self.delete_model(delete_field.remote_field.through)\n212         # Work inside a new app registry\n213         apps = Apps()\n214 \n215         # Work out the new value of unique_together, taking renames into\n216         # account\n217         unique_together = [\n218             [rename_mapping.get(n, n) for n in unique]\n219             for unique in model._meta.unique_together\n220         ]\n221 \n222         # Work out the new value for index_together, taking renames into\n223         # account\n224         index_together = [\n225             [rename_mapping.get(n, n) for n in index]\n226             for index in model._meta.index_together\n227         ]\n228 \n229         indexes = model._meta.indexes\n230         if delete_field:\n231             indexes = [\n232                 index for index in indexes\n233                 if delete_field.name not in index.fields\n234             ]\n235 \n236         constraints = list(model._meta.constraints)\n237 \n238         # Provide isolated instances of the fields to the new model body so\n239         # that the existing model's internals aren't interfered with when\n240         # the dummy model is constructed.\n241         body_copy = copy.deepcopy(body)\n242 \n243         # Construct a new model with the new fields to allow self referential\n244         # primary key to resolve to. This model won't ever be materialized as a\n245         # table and solely exists for foreign key reference resolution purposes.\n246         # This wouldn't be required if the schema editor was operating on model\n247         # states instead of rendered models.\n248         meta_contents = {\n249             'app_label': model._meta.app_label,\n250             'db_table': model._meta.db_table,\n251             'unique_together': unique_together,\n252             'index_together': index_together,\n253             'indexes': indexes,\n254             'constraints': constraints,\n255             'apps': apps,\n256         }\n257         meta = type(\"Meta\", (), meta_contents)\n258         body_copy['Meta'] = meta\n259         body_copy['__module__'] = model.__module__\n260         type(model._meta.object_name, model.__bases__, body_copy)\n261 \n262         # Construct a model with a renamed table name.\n263         body_copy = copy.deepcopy(body)\n264         meta_contents = {\n265             'app_label': model._meta.app_label,\n266             'db_table': 'new__%s' % model._meta.db_table,\n267             'unique_together': unique_together,\n268             'index_together': index_together,\n269             'indexes': indexes,\n270             'constraints': constraints,\n271             'apps': apps,\n272         }\n273         meta = type(\"Meta\", (), meta_contents)\n274         body_copy['Meta'] = meta\n275         body_copy['__module__'] = model.__module__\n276         new_model = type('New%s' % model._meta.object_name, model.__bases__, body_copy)\n277 \n278         # Create a new table with the updated schema.\n279         self.create_model(new_model)\n280 \n281         # Copy data from the old table into the new table\n282         self.execute(\"INSERT INTO %s (%s) SELECT %s FROM %s\" % (\n283             self.quote_name(new_model._meta.db_table),\n284             ', '.join(self.quote_name(x) for x in mapping),\n285             ', '.join(mapping.values()),\n286             self.quote_name(model._meta.db_table),\n287         ))\n288 \n289         # Delete the old table to make way for the new\n290         self.delete_model(model, handle_autom2m=False)\n291 \n292         # Rename the new table to take way for the old\n293         self.alter_db_table(\n294             new_model, new_model._meta.db_table, model._meta.db_table,\n295             disable_constraints=False,\n296         )\n297 \n298         # Run deferred SQL on correct table\n299         for sql in self.deferred_sql:\n300             self.execute(sql)\n301         self.deferred_sql = []\n302         # Fix any PK-removed field\n303         if restore_pk_field:\n304             restore_pk_field.primary_key = True\n305 \n306     def delete_model(self, model, handle_autom2m=True):\n307         if handle_autom2m:\n308             super().delete_model(model)\n309         else:\n310             # Delete the table (and only that)\n311             self.execute(self.sql_delete_table % {\n312                 \"table\": self.quote_name(model._meta.db_table),\n313             })\n314             # Remove all deferred statements referencing the deleted table.\n315             for sql in list(self.deferred_sql):\n316                 if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):\n317                     self.deferred_sql.remove(sql)\n318 \n319     def add_field(self, model, field):\n320         \"\"\"\n321         Create a field on a model. Usually involves adding a column, but may\n322         involve adding a table instead (for M2M fields).\n323         \"\"\"\n324         # Special-case implicit M2M tables\n325         if field.many_to_many and field.remote_field.through._meta.auto_created:\n326             return self.create_model(field.remote_field.through)\n327         self._remake_table(model, create_field=field)\n328 \n329     def remove_field(self, model, field):\n330         \"\"\"\n331         Remove a field from a model. Usually involves deleting a column,\n332         but for M2Ms may involve deleting a table.\n333         \"\"\"\n334         # M2M fields are a special case\n335         if field.many_to_many:\n336             # For implicit M2M tables, delete the auto-created table\n337             if field.remote_field.through._meta.auto_created:\n338                 self.delete_model(field.remote_field.through)\n339             # For explicit \"through\" M2M fields, do nothing\n340         # For everything else, remake.\n341         else:\n342             # It might not actually have a column behind it\n343             if field.db_parameters(connection=self.connection)['type'] is None:\n344                 return\n345             self._remake_table(model, delete_field=field)\n346 \n347     def _alter_field(self, model, old_field, new_field, old_type, new_type,\n348                      old_db_params, new_db_params, strict=False):\n349         \"\"\"Perform a \"physical\" (non-ManyToMany) field update.\"\"\"\n350         # Use \"ALTER TABLE ... RENAME COLUMN\" if only the column name\n351         # changed and there aren't any constraints.\n352         if (self.connection.features.can_alter_table_rename_column and\n353             old_field.column != new_field.column and\n354             self.column_sql(model, old_field) == self.column_sql(model, new_field) and\n355             not (old_field.remote_field and old_field.db_constraint or\n356                  new_field.remote_field and new_field.db_constraint)):\n357             return self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))\n358         # Alter by remaking table\n359         self._remake_table(model, alter_field=(old_field, new_field))\n360         # Rebuild tables with FKs pointing to this field if the PK type changed.\n361         if old_field.primary_key and new_field.primary_key and old_type != new_type:\n362             for rel in new_field.model._meta.related_objects:\n363                 if not rel.many_to_many:\n364                     self._remake_table(rel.related_model)\n365 \n366     def _alter_many_to_many(self, model, old_field, new_field, strict):\n367         \"\"\"Alter M2Ms to repoint their to= endpoints.\"\"\"\n368         if old_field.remote_field.through._meta.db_table == new_field.remote_field.through._meta.db_table:\n369             # The field name didn't change, but some options did; we have to propagate this altering.\n370             self._remake_table(\n371                 old_field.remote_field.through,\n372                 alter_field=(\n373                     # We need the field that points to the target model, so we can tell alter_field to change it -\n374                     # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)\n375                     old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),\n376                     new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),\n377                 ),\n378             )\n379             return\n380 \n381         # Make a new through table\n382         self.create_model(new_field.remote_field.through)\n383         # Copy the data across\n384         self.execute(\"INSERT INTO %s (%s) SELECT %s FROM %s\" % (\n385             self.quote_name(new_field.remote_field.through._meta.db_table),\n386             ', '.join([\n387                 \"id\",\n388                 new_field.m2m_column_name(),\n389                 new_field.m2m_reverse_name(),\n390             ]),\n391             ', '.join([\n392                 \"id\",\n393                 old_field.m2m_column_name(),\n394                 old_field.m2m_reverse_name(),\n395             ]),\n396             self.quote_name(old_field.remote_field.through._meta.db_table),\n397         ))\n398         # Delete the old through table\n399         self.delete_model(old_field.remote_field.through)\n400 \n401     def add_constraint(self, model, constraint):\n402         if isinstance(constraint, UniqueConstraint) and constraint.condition:\n403             super().add_constraint(model, constraint)\n404         else:\n405             self._remake_table(model)\n406 \n407     def remove_constraint(self, model, constraint):\n408         if isinstance(constraint, UniqueConstraint) and constraint.condition:\n409             super().remove_constraint(model, constraint)\n410         else:\n411             self._remake_table(model)\n",
        "intended_behavior": "Look for how table creation commands are generated and executed."
    },
    {
        "rel_file_path": "django/db/migrations/executor.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/migrations/executor.py",
        "start": 231,
        "end": 253,
        "class_name": null,
        "method_name": "apply_migration",
        "code": "231     def apply_migration(self, state, migration, fake=False, fake_initial=False):\n232         \"\"\"Run a migration forwards.\"\"\"\n233         migration_recorded = False\n234         if self.progress_callback:\n235             self.progress_callback(\"apply_start\", migration, fake)\n236         if not fake:\n237             if fake_initial:\n238                 # Test to see if this is an already-applied initial migration\n239                 applied, state = self.detect_soft_applied(state, migration)\n240                 if applied:\n241                     fake = True\n242             if not fake:\n243                 # Alright, do it normally\n244                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:\n245                     state = migration.apply(state, schema_editor)\n246                     self.record_migration(migration)\n247                     migration_recorded = True\n248         if not migration_recorded:\n249             self.record_migration(migration)\n250         # Report progress\n251         if self.progress_callback:\n252             self.progress_callback(\"apply_success\", migration, fake)\n253         return state\n",
        "intended_behavior": "Investigate methods for invoking schema changes in SQLite."
    },
    {
        "rel_file_path": "django/db/migrations/executor.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/migrations/executor.py",
        "start": 231,
        "end": 253,
        "class_name": "MigrationExecutor",
        "method_name": "apply_migration",
        "code": "231     def apply_migration(self, state, migration, fake=False, fake_initial=False):\n232         \"\"\"Run a migration forwards.\"\"\"\n233         migration_recorded = False\n234         if self.progress_callback:\n235             self.progress_callback(\"apply_start\", migration, fake)\n236         if not fake:\n237             if fake_initial:\n238                 # Test to see if this is an already-applied initial migration\n239                 applied, state = self.detect_soft_applied(state, migration)\n240                 if applied:\n241                     fake = True\n242             if not fake:\n243                 # Alright, do it normally\n244                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:\n245                     state = migration.apply(state, schema_editor)\n246                     self.record_migration(migration)\n247                     migration_recorded = True\n248         if not migration_recorded:\n249             self.record_migration(migration)\n250         # Report progress\n251         if self.progress_callback:\n252             self.progress_callback(\"apply_success\", migration, fake)\n253         return state\n",
        "intended_behavior": "Investigate methods for invoking schema changes in SQLite."
    },
    {
        "rel_file_path": "django/db/models/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/models/options.py",
        "start": 1,
        "end": 844,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 import inspect\n3 from bisect import bisect\n4 from collections import defaultdict\n5 \n6 from django.apps import apps\n7 from django.conf import settings\n8 from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured\n9 from django.db import connections\n10 from django.db.models import Manager\n11 from django.db.models.fields import AutoField\n12 from django.db.models.fields.proxy import OrderWrt\n13 from django.db.models.query_utils import PathInfo\n14 from django.utils.datastructures import ImmutableList, OrderedSet\n15 from django.utils.functional import cached_property\n16 from django.utils.text import camel_case_to_spaces, format_lazy\n17 from django.utils.translation import override\n18 \n19 PROXY_PARENTS = object()\n20 \n21 EMPTY_RELATION_TREE = ()\n22 \n23 IMMUTABLE_WARNING = (\n24     \"The return type of '%s' should never be mutated. If you want to manipulate this list \"\n25     \"for your own use, make a copy first.\"\n26 )\n27 \n28 DEFAULT_NAMES = (\n29     'verbose_name', 'verbose_name_plural', 'db_table', 'ordering',\n30     'unique_together', 'permissions', 'get_latest_by', 'order_with_respect_to',\n31     'app_label', 'db_tablespace', 'abstract', 'managed', 'proxy', 'swappable',\n32     'auto_created', 'index_together', 'apps', 'default_permissions',\n33     'select_on_save', 'default_related_name', 'required_db_features',\n34     'required_db_vendor', 'base_manager_name', 'default_manager_name',\n35     'indexes', 'constraints',\n36 )\n37 \n38 \n39 def normalize_together(option_together):\n40     \"\"\"\n41     option_together can be either a tuple of tuples, or a single\n42     tuple of two strings. Normalize it to a tuple of tuples, so that\n43     calling code can uniformly expect that.\n44     \"\"\"\n45     try:\n46         if not option_together:\n47             return ()\n48         if not isinstance(option_together, (tuple, list)):\n49             raise TypeError\n50         first_element = option_together[0]\n51         if not isinstance(first_element, (tuple, list)):\n52             option_together = (option_together,)\n53         # Normalize everything to tuples\n54         return tuple(tuple(ot) for ot in option_together)\n55     except TypeError:\n56         # If the value of option_together isn't valid, return it\n57         # verbatim; this will be picked up by the check framework later.\n58         return option_together\n59 \n60 \n61 def make_immutable_fields_list(name, data):\n62     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)\n63 \n64 \n65 class Options:\n66     FORWARD_PROPERTIES = {\n67         'fields', 'many_to_many', 'concrete_fields', 'local_concrete_fields',\n68         '_forward_fields_map', 'managers', 'managers_map', 'base_manager',\n69         'default_manager',\n70     }\n71     REVERSE_PROPERTIES = {'related_objects', 'fields_map', '_relation_tree'}\n72 \n73     default_apps = apps\n74 \n75     def __init__(self, meta, app_label=None):\n76         self._get_fields_cache = {}\n77         self.local_fields = []\n78         self.local_many_to_many = []\n79         self.private_fields = []\n80         self.local_managers = []\n81         self.base_manager_name = None\n82         self.default_manager_name = None\n83         self.model_name = None\n84         self.verbose_name = None\n85         self.verbose_name_plural = None\n86         self.db_table = ''\n87         self.ordering = []\n88         self._ordering_clash = False\n89         self.indexes = []\n90         self.constraints = []\n91         self.unique_together = []\n92         self.index_together = []\n93         self.select_on_save = False\n94         self.default_permissions = ('add', 'change', 'delete', 'view')\n95         self.permissions = []\n96         self.object_name = None\n97         self.app_label = app_label\n98         self.get_latest_by = None\n99         self.order_with_respect_to = None\n100         self.db_tablespace = settings.DEFAULT_TABLESPACE\n101         self.required_db_features = []\n102         self.required_db_vendor = None\n103         self.meta = meta\n104         self.pk = None\n105         self.auto_field = None\n106         self.abstract = False\n107         self.managed = True\n108         self.proxy = False\n109         # For any class that is a proxy (including automatically created\n110         # classes for deferred object loading), proxy_for_model tells us\n111         # which class this model is proxying. Note that proxy_for_model\n112         # can create a chain of proxy models. For non-proxy models, the\n113         # variable is always None.\n114         self.proxy_for_model = None\n115         # For any non-abstract class, the concrete class is the model\n116         # in the end of the proxy_for_model chain. In particular, for\n117         # concrete models, the concrete_model is always the class itself.\n118         self.concrete_model = None\n119         self.swappable = None\n120         self.parents = {}\n121         self.auto_created = False\n122 \n123         # List of all lookups defined in ForeignKey 'limit_choices_to' options\n124         # from *other* models. Needed for some admin checks. Internal use only.\n125         self.related_fkey_lookups = []\n126 \n127         # A custom app registry to use, if you're making a separate model set.\n128         self.apps = self.default_apps\n129 \n130         self.default_related_name = None\n131 \n132     @property\n133     def label(self):\n134         return '%s.%s' % (self.app_label, self.object_name)\n135 \n136     @property\n137     def label_lower(self):\n138         return '%s.%s' % (self.app_label, self.model_name)\n139 \n140     @property\n141     def app_config(self):\n142         # Don't go through get_app_config to avoid triggering imports.\n143         return self.apps.app_configs.get(self.app_label)\n144 \n145     @property\n146     def installed(self):\n147         return self.app_config is not None\n148 \n149     def contribute_to_class(self, cls, name):\n150         from django.db import connection\n151         from django.db.backends.utils import truncate_name\n152 \n153         cls._meta = self\n154         self.model = cls\n155         # First, construct the default values for these options.\n156         self.object_name = cls.__name__\n157         self.model_name = self.object_name.lower()\n158         self.verbose_name = camel_case_to_spaces(self.object_name)\n159 \n160         # Store the original user-defined values for each option,\n161         # for use when serializing the model definition\n162         self.original_attrs = {}\n163 \n164         # Next, apply any overridden values from 'class Meta'.\n165         if self.meta:\n166             meta_attrs = self.meta.__dict__.copy()\n167             for name in self.meta.__dict__:\n168                 # Ignore any private attributes that Django doesn't care about.\n169                 # NOTE: We can't modify a dictionary's contents while looping\n170                 # over it, so we loop over the *original* dictionary instead.\n171                 if name.startswith('_'):\n172                     del meta_attrs[name]\n173             for attr_name in DEFAULT_NAMES:\n174                 if attr_name in meta_attrs:\n175                     setattr(self, attr_name, meta_attrs.pop(attr_name))\n176                     self.original_attrs[attr_name] = getattr(self, attr_name)\n177                 elif hasattr(self.meta, attr_name):\n178                     setattr(self, attr_name, getattr(self.meta, attr_name))\n179                     self.original_attrs[attr_name] = getattr(self, attr_name)\n180 \n181             self.unique_together = normalize_together(self.unique_together)\n182             self.index_together = normalize_together(self.index_together)\n183             # App label/class name interpolation for names of constraints and\n184             # indexes.\n185             if not getattr(cls._meta, 'abstract', False):\n186                 for attr_name in {'constraints', 'indexes'}:\n187                     objs = getattr(self, attr_name, [])\n188                     setattr(self, attr_name, self._format_names_with_class(cls, objs))\n189 \n190             # verbose_name_plural is a special case because it uses a 's'\n191             # by default.\n192             if self.verbose_name_plural is None:\n193                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n194 \n195             # order_with_respect_and ordering are mutually exclusive.\n196             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)\n197 \n198             # Any leftover attributes must be invalid.\n199             if meta_attrs != {}:\n200                 raise TypeError(\"'class Meta' got invalid attribute(s): %s\" % ','.join(meta_attrs))\n201         else:\n202             self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n203         del self.meta\n204 \n205         # If the db_table wasn't provided, use the app_label + model_name.\n206         if not self.db_table:\n207             self.db_table = \"%s_%s\" % (self.app_label, self.model_name)\n208             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())\n209 \n210     def _format_names_with_class(self, cls, objs):\n211         \"\"\"App label/class name interpolation for object names.\"\"\"\n212         new_objs = []\n213         for obj in objs:\n214             obj = obj.clone()\n215             obj.name = obj.name % {\n216                 'app_label': cls._meta.app_label.lower(),\n217                 'class': cls.__name__.lower(),\n218             }\n219             new_objs.append(obj)\n220         return new_objs\n221 \n222     def _prepare(self, model):\n223         if self.order_with_respect_to:\n224             # The app registry will not be ready at this point, so we cannot\n225             # use get_field().\n226             query = self.order_with_respect_to\n227             try:\n228                 self.order_with_respect_to = next(\n229                     f for f in self._get_fields(reverse=False)\n230                     if f.name == query or f.attname == query\n231                 )\n232             except StopIteration:\n233                 raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, query))\n234 \n235             self.ordering = ('_order',)\n236             if not any(isinstance(field, OrderWrt) for field in model._meta.local_fields):\n237                 model.add_to_class('_order', OrderWrt())\n238         else:\n239             self.order_with_respect_to = None\n240 \n241         if self.pk is None:\n242             if self.parents:\n243                 # Promote the first parent link in lieu of adding yet another\n244                 # field.\n245                 field = next(iter(self.parents.values()))\n246                 # Look for a local field with the same name as the\n247                 # first parent link. If a local field has already been\n248                 # created, use it instead of promoting the parent\n249                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n250                 if already_created:\n251                     field = already_created[0]\n252                 field.primary_key = True\n253                 self.setup_pk(field)\n254                 if not field.remote_field.parent_link:\n255                     raise ImproperlyConfigured(\n256                         'Add parent_link=True to %s.' % field,\n257                     )\n258             else:\n259                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)\n260                 model.add_to_class('id', auto)\n261 \n262     def add_manager(self, manager):\n263         self.local_managers.append(manager)\n264         self._expire_cache()\n265 \n266     def add_field(self, field, private=False):\n267         # Insert the given field in the order in which it was created, using\n268         # the \"creation_counter\" attribute of the field.\n269         # Move many-to-many related fields from self.fields into\n270         # self.many_to_many.\n271         if private:\n272             self.private_fields.append(field)\n273         elif field.is_relation and field.many_to_many:\n274             self.local_many_to_many.insert(bisect(self.local_many_to_many, field), field)\n275         else:\n276             self.local_fields.insert(bisect(self.local_fields, field), field)\n277             self.setup_pk(field)\n278 \n279         # If the field being added is a relation to another known field,\n280         # expire the cache on this field and the forward cache on the field\n281         # being referenced, because there will be new relationships in the\n282         # cache. Otherwise, expire the cache of references *to* this field.\n283         # The mechanism for getting at the related model is slightly odd -\n284         # ideally, we'd just ask for field.related_model. However, related_model\n285         # is a cached property, and all the models haven't been loaded yet, so\n286         # we need to make sure we don't cache a string reference.\n287         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:\n288             try:\n289                 field.remote_field.model._meta._expire_cache(forward=False)\n290             except AttributeError:\n291                 pass\n292             self._expire_cache()\n293         else:\n294             self._expire_cache(reverse=False)\n295 \n296     def setup_pk(self, field):\n297         if not self.pk and field.primary_key:\n298             self.pk = field\n299             field.serialize = False\n300 \n301     def setup_proxy(self, target):\n302         \"\"\"\n303         Do the internal setup so that the current model is a proxy for\n304         \"target\".\n305         \"\"\"\n306         self.pk = target._meta.pk\n307         self.proxy_for_model = target\n308         self.db_table = target._meta.db_table\n309 \n310     def __repr__(self):\n311         return '<Options for %s>' % self.object_name\n312 \n313     def __str__(self):\n314         return \"%s.%s\" % (self.app_label, self.model_name)\n315 \n316     def can_migrate(self, connection):\n317         \"\"\"\n318         Return True if the model can/should be migrated on the `connection`.\n319         `connection` can be either a real connection or a connection alias.\n320         \"\"\"\n321         if self.proxy or self.swapped or not self.managed:\n322             return False\n323         if isinstance(connection, str):\n324             connection = connections[connection]\n325         if self.required_db_vendor:\n326             return self.required_db_vendor == connection.vendor\n327         if self.required_db_features:\n328             return all(getattr(connection.features, feat, False)\n329                        for feat in self.required_db_features)\n330         return True\n331 \n332     @property\n333     def verbose_name_raw(self):\n334         \"\"\"Return the untranslated verbose name.\"\"\"\n335         with override(None):\n336             return str(self.verbose_name)\n337 \n338     @property\n339     def swapped(self):\n340         \"\"\"\n341         Has this model been swapped out for another? If so, return the model\n342         name of the replacement; otherwise, return None.\n343 \n344         For historical reasons, model name lookups using get_model() are\n345         case insensitive, so we make sure we are case insensitive here.\n346         \"\"\"\n347         if self.swappable:\n348             swapped_for = getattr(settings, self.swappable, None)\n349             if swapped_for:\n350                 try:\n351                     swapped_label, swapped_object = swapped_for.split('.')\n352                 except ValueError:\n353                     # setting not in the format app_label.model_name\n354                     # raising ImproperlyConfigured here causes problems with\n355                     # test cleanup code - instead it is raised in get_user_model\n356                     # or as part of validation.\n357                     return swapped_for\n358 \n359                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:\n360                     return swapped_for\n361         return None\n362 \n363     @cached_property\n364     def managers(self):\n365         managers = []\n366         seen_managers = set()\n367         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))\n368         for depth, base in enumerate(bases):\n369             for manager in base._meta.local_managers:\n370                 if manager.name in seen_managers:\n371                     continue\n372 \n373                 manager = copy.copy(manager)\n374                 manager.model = self.model\n375                 seen_managers.add(manager.name)\n376                 managers.append((depth, manager.creation_counter, manager))\n377 \n378         return make_immutable_fields_list(\n379             \"managers\",\n380             (m[2] for m in sorted(managers)),\n381         )\n382 \n383     @cached_property\n384     def managers_map(self):\n385         return {manager.name: manager for manager in self.managers}\n386 \n387     @cached_property\n388     def base_manager(self):\n389         base_manager_name = self.base_manager_name\n390         if not base_manager_name:\n391             # Get the first parent's base_manager_name if there's one.\n392             for parent in self.model.mro()[1:]:\n393                 if hasattr(parent, '_meta'):\n394                     if parent._base_manager.name != '_base_manager':\n395                         base_manager_name = parent._base_manager.name\n396                     break\n397 \n398         if base_manager_name:\n399             try:\n400                 return self.managers_map[base_manager_name]\n401             except KeyError:\n402                 raise ValueError(\n403                     \"%s has no manager named %r\" % (\n404                         self.object_name,\n405                         base_manager_name,\n406                     )\n407                 )\n408 \n409         manager = Manager()\n410         manager.name = '_base_manager'\n411         manager.model = self.model\n412         manager.auto_created = True\n413         return manager\n414 \n415     @cached_property\n416     def default_manager(self):\n417         default_manager_name = self.default_manager_name\n418         if not default_manager_name and not self.local_managers:\n419             # Get the first parent's default_manager_name if there's one.\n420             for parent in self.model.mro()[1:]:\n421                 if hasattr(parent, '_meta'):\n422                     default_manager_name = parent._meta.default_manager_name\n423                     break\n424 \n425         if default_manager_name:\n426             try:\n427                 return self.managers_map[default_manager_name]\n428             except KeyError:\n429                 raise ValueError(\n430                     \"%s has no manager named %r\" % (\n431                         self.object_name,\n432                         default_manager_name,\n433                     )\n434                 )\n435 \n436         if self.managers:\n437             return self.managers[0]\n438 \n439     @cached_property\n440     def fields(self):\n441         \"\"\"\n442         Return a list of all forward fields on the model and its parents,\n443         excluding ManyToManyFields.\n444 \n445         Private API intended only to be used by Django itself; get_fields()\n446         combined with filtering of field properties is the public API for\n447         obtaining this field list.\n448         \"\"\"\n449         # For legacy reasons, the fields property should only contain forward\n450         # fields that are not private or with a m2m cardinality. Therefore we\n451         # pass these three filters as filters to the generator.\n452         # The third lambda is a longwinded way of checking f.related_model - we don't\n453         # use that property directly because related_model is a cached property,\n454         # and all the models may not have been loaded yet; we don't want to cache\n455         # the string reference to the related_model.\n456         def is_not_an_m2m_field(f):\n457             return not (f.is_relation and f.many_to_many)\n458 \n459         def is_not_a_generic_relation(f):\n460             return not (f.is_relation and f.one_to_many)\n461 \n462         def is_not_a_generic_foreign_key(f):\n463             return not (\n464                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)\n465             )\n466 \n467         return make_immutable_fields_list(\n468             \"fields\",\n469             (f for f in self._get_fields(reverse=False)\n470              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))\n471         )\n472 \n473     @cached_property\n474     def concrete_fields(self):\n475         \"\"\"\n476         Return a list of all concrete fields on the model and its parents.\n477 \n478         Private API intended only to be used by Django itself; get_fields()\n479         combined with filtering of field properties is the public API for\n480         obtaining this field list.\n481         \"\"\"\n482         return make_immutable_fields_list(\n483             \"concrete_fields\", (f for f in self.fields if f.concrete)\n484         )\n485 \n486     @cached_property\n487     def local_concrete_fields(self):\n488         \"\"\"\n489         Return a list of all concrete fields on the model.\n490 \n491         Private API intended only to be used by Django itself; get_fields()\n492         combined with filtering of field properties is the public API for\n493         obtaining this field list.\n494         \"\"\"\n495         return make_immutable_fields_list(\n496             \"local_concrete_fields\", (f for f in self.local_fields if f.concrete)\n497         )\n498 \n499     @cached_property\n500     def many_to_many(self):\n501         \"\"\"\n502         Return a list of all many to many fields on the model and its parents.\n503 \n504         Private API intended only to be used by Django itself; get_fields()\n505         combined with filtering of field properties is the public API for\n506         obtaining this list.\n507         \"\"\"\n508         return make_immutable_fields_list(\n509             \"many_to_many\",\n510             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)\n511         )\n512 \n513     @cached_property\n514     def related_objects(self):\n515         \"\"\"\n516         Return all related objects pointing to the current model. The related\n517         objects can come from a one-to-one, one-to-many, or many-to-many field\n518         relation type.\n519 \n520         Private API intended only to be used by Django itself; get_fields()\n521         combined with filtering of field properties is the public API for\n522         obtaining this field list.\n523         \"\"\"\n524         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)\n525         return make_immutable_fields_list(\n526             \"related_objects\",\n527             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)\n528         )\n529 \n530     @cached_property\n531     def _forward_fields_map(self):\n532         res = {}\n533         fields = self._get_fields(reverse=False)\n534         for field in fields:\n535             res[field.name] = field\n536             # Due to the way Django's internals work, get_field() should also\n537             # be able to fetch a field by attname. In the case of a concrete\n538             # field with relation, includes the *_id name too\n539             try:\n540                 res[field.attname] = field\n541             except AttributeError:\n542                 pass\n543         return res\n544 \n545     @cached_property\n546     def fields_map(self):\n547         res = {}\n548         fields = self._get_fields(forward=False, include_hidden=True)\n549         for field in fields:\n550             res[field.name] = field\n551             # Due to the way Django's internals work, get_field() should also\n552             # be able to fetch a field by attname. In the case of a concrete\n553             # field with relation, includes the *_id name too\n554             try:\n555                 res[field.attname] = field\n556             except AttributeError:\n557                 pass\n558         return res\n559 \n560     def get_field(self, field_name):\n561         \"\"\"\n562         Return a field instance given the name of a forward or reverse field.\n563         \"\"\"\n564         try:\n565             # In order to avoid premature loading of the relation tree\n566             # (expensive) we prefer checking if the field is a forward field.\n567             return self._forward_fields_map[field_name]\n568         except KeyError:\n569             # If the app registry is not ready, reverse fields are\n570             # unavailable, therefore we throw a FieldDoesNotExist exception.\n571             if not self.apps.models_ready:\n572                 raise FieldDoesNotExist(\n573                     \"%s has no field named '%s'. The app cache isn't ready yet, \"\n574                     \"so if this is an auto-created related field, it won't \"\n575                     \"be available yet.\" % (self.object_name, field_name)\n576                 )\n577 \n578         try:\n579             # Retrieve field instance by name from cached or just-computed\n580             # field map.\n581             return self.fields_map[field_name]\n582         except KeyError:\n583             raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, field_name))\n584 \n585     def get_base_chain(self, model):\n586         \"\"\"\n587         Return a list of parent classes leading to `model` (ordered from\n588         closest to most distant ancestor). This has to handle the case where\n589         `model` is a grandparent or even more distant relation.\n590         \"\"\"\n591         if not self.parents:\n592             return []\n593         if model in self.parents:\n594             return [model]\n595         for parent in self.parents:\n596             res = parent._meta.get_base_chain(model)\n597             if res:\n598                 res.insert(0, parent)\n599                 return res\n600         return []\n601 \n602     def get_parent_list(self):\n603         \"\"\"\n604         Return all the ancestors of this model as a list ordered by MRO.\n605         Useful for determining if something is an ancestor, regardless of lineage.\n606         \"\"\"\n607         result = OrderedSet(self.parents)\n608         for parent in self.parents:\n609             for ancestor in parent._meta.get_parent_list():\n610                 result.add(ancestor)\n611         return list(result)\n612 \n613     def get_ancestor_link(self, ancestor):\n614         \"\"\"\n615         Return the field on the current model which points to the given\n616         \"ancestor\". This is possible an indirect link (a pointer to a parent\n617         model, which points, eventually, to the ancestor). Used when\n618         constructing table joins for model inheritance.\n619 \n620         Return None if the model isn't an ancestor of this one.\n621         \"\"\"\n622         if ancestor in self.parents:\n623             return self.parents[ancestor]\n624         for parent in self.parents:\n625             # Tries to get a link field from the immediate parent\n626             parent_link = parent._meta.get_ancestor_link(ancestor)\n627             if parent_link:\n628                 # In case of a proxied model, the first link\n629                 # of the chain to the ancestor is that parent\n630                 # links\n631                 return self.parents[parent] or parent_link\n632 \n633     def get_path_to_parent(self, parent):\n634         \"\"\"\n635         Return a list of PathInfos containing the path from the current\n636         model to the parent model, or an empty list if parent is not a\n637         parent of the current model.\n638         \"\"\"\n639         if self.model is parent:\n640             return []\n641         # Skip the chain of proxy to the concrete proxied model.\n642         proxied_model = self.concrete_model\n643         path = []\n644         opts = self\n645         for int_model in self.get_base_chain(parent):\n646             if int_model is proxied_model:\n647                 opts = int_model._meta\n648             else:\n649                 final_field = opts.parents[int_model]\n650                 targets = (final_field.remote_field.get_related_field(),)\n651                 opts = int_model._meta\n652                 path.append(PathInfo(\n653                     from_opts=final_field.model._meta,\n654                     to_opts=opts,\n655                     target_fields=targets,\n656                     join_field=final_field,\n657                     m2m=False,\n658                     direct=True,\n659                     filtered_relation=None,\n660                 ))\n661         return path\n662 \n663     def get_path_from_parent(self, parent):\n664         \"\"\"\n665         Return a list of PathInfos containing the path from the parent\n666         model to the current model, or an empty list if parent is not a\n667         parent of the current model.\n668         \"\"\"\n669         if self.model is parent:\n670             return []\n671         model = self.concrete_model\n672         # Get a reversed base chain including both the current and parent\n673         # models.\n674         chain = model._meta.get_base_chain(parent)\n675         chain.reverse()\n676         chain.append(model)\n677         # Construct a list of the PathInfos between models in chain.\n678         path = []\n679         for i, ancestor in enumerate(chain[:-1]):\n680             child = chain[i + 1]\n681             link = child._meta.get_ancestor_link(ancestor)\n682             path.extend(link.get_reverse_path_info())\n683         return path\n684 \n685     def _populate_directed_relation_graph(self):\n686         \"\"\"\n687         This method is used by each model to find its reverse objects. As this\n688         method is very expensive and is accessed frequently (it looks up every\n689         field in a model, in every app), it is computed on first access and then\n690         is set as a property on every model.\n691         \"\"\"\n692         related_objects_graph = defaultdict(list)\n693 \n694         all_models = self.apps.get_models(include_auto_created=True)\n695         for model in all_models:\n696             opts = model._meta\n697             # Abstract model's fields are copied to child models, hence we will\n698             # see the fields from the child models.\n699             if opts.abstract:\n700                 continue\n701             fields_with_relations = (\n702                 f for f in opts._get_fields(reverse=False, include_parents=False)\n703                 if f.is_relation and f.related_model is not None\n704             )\n705             for f in fields_with_relations:\n706                 if not isinstance(f.remote_field.model, str):\n707                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)\n708 \n709         for model in all_models:\n710             # Set the relation_tree using the internal __dict__. In this way\n711             # we avoid calling the cached property. In attribute lookup,\n712             # __dict__ takes precedence over a data descriptor (such as\n713             # @cached_property). This means that the _meta._relation_tree is\n714             # only called if related_objects is not in __dict__.\n715             related_objects = related_objects_graph[model._meta.concrete_model._meta]\n716             model._meta.__dict__['_relation_tree'] = related_objects\n717         # It seems it is possible that self is not in all_models, so guard\n718         # against that with default for get().\n719         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)\n720 \n721     @cached_property\n722     def _relation_tree(self):\n723         return self._populate_directed_relation_graph()\n724 \n725     def _expire_cache(self, forward=True, reverse=True):\n726         # This method is usually called by apps.cache_clear(), when the\n727         # registry is finalized, or when a new field is added.\n728         if forward:\n729             for cache_key in self.FORWARD_PROPERTIES:\n730                 if cache_key in self.__dict__:\n731                     delattr(self, cache_key)\n732         if reverse and not self.abstract:\n733             for cache_key in self.REVERSE_PROPERTIES:\n734                 if cache_key in self.__dict__:\n735                     delattr(self, cache_key)\n736         self._get_fields_cache = {}\n737 \n738     def get_fields(self, include_parents=True, include_hidden=False):\n739         \"\"\"\n740         Return a list of fields associated to the model. By default, include\n741         forward and reverse fields, fields derived from inheritance, but not\n742         hidden fields. The returned fields can be changed using the parameters:\n743 \n744         - include_parents: include fields derived from inheritance\n745         - include_hidden:  include fields that have a related_name that\n746                            starts with a \"+\"\n747         \"\"\"\n748         if include_parents is False:\n749             include_parents = PROXY_PARENTS\n750         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)\n751 \n752     def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False,\n753                     seen_models=None):\n754         \"\"\"\n755         Internal helper function to return fields of the model.\n756         * If forward=True, then fields defined on this model are returned.\n757         * If reverse=True, then relations pointing to this model are returned.\n758         * If include_hidden=True, then fields with is_hidden=True are returned.\n759         * The include_parents argument toggles if fields from parent models\n760           should be included. It has three values: True, False, and\n761           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all\n762           fields defined for the current model or any of its parents in the\n763           parent chain to the model's concrete model.\n764         \"\"\"\n765         if include_parents not in (True, False, PROXY_PARENTS):\n766             raise TypeError(\"Invalid argument for include_parents: %s\" % (include_parents,))\n767         # This helper function is used to allow recursion in ``get_fields()``\n768         # implementation and to provide a fast way for Django's internals to\n769         # access specific subsets of fields.\n770 \n771         # We must keep track of which models we have already seen. Otherwise we\n772         # could include the same field multiple times from different models.\n773         topmost_call = seen_models is None\n774         if topmost_call:\n775             seen_models = set()\n776         seen_models.add(self.model)\n777 \n778         # Creates a cache key composed of all arguments\n779         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)\n780 \n781         try:\n782             # In order to avoid list manipulation. Always return a shallow copy\n783             # of the results.\n784             return self._get_fields_cache[cache_key]\n785         except KeyError:\n786             pass\n787 \n788         fields = []\n789         # Recursively call _get_fields() on each parent, with the same\n790         # options provided in this call.\n791         if include_parents is not False:\n792             for parent in self.parents:\n793                 # In diamond inheritance it is possible that we see the same\n794                 # model from two different routes. In that case, avoid adding\n795                 # fields from the same parent again.\n796                 if parent in seen_models:\n797                     continue\n798                 if (parent._meta.concrete_model != self.concrete_model and\n799                         include_parents == PROXY_PARENTS):\n800                     continue\n801                 for obj in parent._meta._get_fields(\n802                         forward=forward, reverse=reverse, include_parents=include_parents,\n803                         include_hidden=include_hidden, seen_models=seen_models):\n804                     if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:\n805                         fields.append(obj)\n806         if reverse and not self.proxy:\n807             # Tree is computed once and cached until the app cache is expired.\n808             # It is composed of a list of fields pointing to the current model\n809             # from other models.\n810             all_fields = self._relation_tree\n811             for field in all_fields:\n812                 # If hidden fields should be included or the relation is not\n813                 # intentionally hidden, add to the fields dict.\n814                 if include_hidden or not field.remote_field.hidden:\n815                     fields.append(field.remote_field)\n816 \n817         if forward:\n818             fields += self.local_fields\n819             fields += self.local_many_to_many\n820             # Private fields are recopied to each child model, and they get a\n821             # different model as field.model in each child. Hence we have to\n822             # add the private fields separately from the topmost call. If we\n823             # did this recursively similar to local_fields, we would get field\n824             # instances with field.model != self.model.\n825             if topmost_call:\n826                 fields += self.private_fields\n827 \n828         # In order to avoid list manipulation. Always\n829         # return a shallow copy of the results\n830         fields = make_immutable_fields_list(\"get_fields()\", fields)\n831 \n832         # Store result into cache for later access\n833         self._get_fields_cache[cache_key] = fields\n834         return fields\n835 \n836     @cached_property\n837     def _property_names(self):\n838         \"\"\"Return a set of the names of the properties defined on the model.\"\"\"\n839         names = []\n840         for name in dir(self.model):\n841             attr = inspect.getattr_static(self.model, name)\n842             if isinstance(attr, property):\n843                 names.append(name)\n844         return frozenset(names)\n",
        "intended_behavior": "Examine how migration system handles quoted names, especially where model `_meta` options are processed."
    }
]