2025-10-18 11:39:28.484 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 11:39:32.167 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=432, output_tokens=12, cost=0.004680
2025-10-18 11:39:46.412 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=612, output_tokens=606, cost=0.024300
2025-10-18 11:39:47.640 | INFO     | registered non reproducing test 0
2025-10-18 11:40:03.780 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1876, output_tokens=771, cost=0.041890
2025-10-18 11:40:05.010 | INFO     | registered non reproducing test 1
2025-10-18 11:40:20.895 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2337, output_tokens=743, cost=0.045660
2025-10-18 11:40:22.045 | INFO     | registered non reproducing test 2
2025-10-18 11:40:22.045 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 11:40:22.051 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:40:29.644 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=735, output_tokens=365, cost=0.018300
2025-10-18 11:40:29.652 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:40:32.475 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=719, output_tokens=56, cost=0.008870
2025-10-18 11:40:32.476 | DEBUG    | Extracted a valid json.
2025-10-18 11:40:32.476 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"State\")",
        "search_class(\"County\")",
        "search_method(\"Exists\")",
        "search_method(\"When\")",
        "search_method(\"annotate\")"
    ],
    "bug_locations": []
}
2025-10-18 11:40:32.505 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 11:40:32.506 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 11:40:46.704 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2262, output_tokens=677, cost=0.042930
2025-10-18 11:40:46.718 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:40:54.146 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3155, output_tokens=331, cost=0.041480
2025-10-18 11:40:54.153 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:40:59.062 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=685, output_tokens=146, cost=0.011230
2025-10-18 11:40:59.063 | DEBUG    | Extracted a valid json.
2025-10-18 11:40:59.063 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/expressions.py",
            "class": "",
            "method": "When",
            "intended_behavior": "Modify the `When` method to automatically recognize and correctly handle `Exists` expressions as valid arguments without requiring them to be wrapped in a `Q` object. This could involve adjusting the method's argument parsing to treat `Exists` similarly to how `filter` expressions are treated, ensuring that `Exists` can be passed directly as a condition. This change must not disrupt the existing functionality, which allows `Q` objects, boolean expressions, and lookups as conditions."
        }
    ]
}
2025-10-18 11:40:59.073 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import inspect
4 from decimal import Decimal
5 
6 from django.core.exceptions import EmptyResultSet, FieldError
7 from django.db import NotSupportedError, connection
8 from django.db.models import fields
9 from django.db.models.constants import LOOKUP_SEP
10 from django.db.models.query_utils import Q
11 from django.utils.deconstruct import deconstructible
12 from django.utils.functional import cached_property
13 from django.utils.hashable import make_hashable
14 
15 
16 class SQLiteNumericMixin:
17     """
18     Some expressions with output_field=DecimalField() must be cast to
19     numeric to be properly filtered.
20     """
21     def as_sqlite(self, compiler, connection, **extra_context):
22         sql, params = self.as_sql(compiler, connection, **extra_context)
23         try:
24             if self.output_field.get_internal_type() == 'DecimalField':
25                 sql = 'CAST(%s AS NUMERIC)' % sql
26         except FieldError:
27             pass
28         return sql, params
29 
30 
31 class Combinable:
32     """
33     Provide the ability to combine one or two objects with
34     some connector. For example F('foo') + F('bar').
35     """
36 
37     # Arithmetic connectors
38     ADD = '+'
39     SUB = '-'
40     MUL = '*'
41     DIV = '/'
42     POW = '^'
43     # The following is a quoted % operator - it is quoted because it can be
44     # used in strings that also have parameter substitution.
45     MOD = '%%'
46 
47     # Bitwise operators - note that these are generated by .bitand()
48     # and .bitor(), the '&' and '|' are reserved for boolean operator
49     # usage.
50     BITAND = '&'
51     BITOR = '|'
52     BITLEFTSHIFT = '<<'
53     BITRIGHTSHIFT = '>>'
54     BITXOR = '#'
55 
56     def _combine(self, other, connector, reversed):
57         if not hasattr(other, 'resolve_expression'):
58             # everything must be resolvable to an expression
59             if isinstance(other, datetime.timedelta):
60                 other = DurationValue(other, output_field=fields.DurationField())
61             else:
62                 other = Value(other)
63 
64         if reversed:
65             return CombinedExpression(other, connector, self)
66         return CombinedExpression(self, connector, other)
67 
68     #############
69     # OPERATORS #
70     #############
71 
72     def __neg__(self):
73         return self._combine(-1, self.MUL, False)
74 
75     def __add__(self, other):
76         return self._combine(other, self.ADD, False)
77 
78     def __sub__(self, other):
79         return self._combine(other, self.SUB, False)
80 
81     def __mul__(self, other):
82         return self._combine(other, self.MUL, False)
83 
84     def __truediv__(self, other):
85         return self._combine(other, self.DIV, False)
86 
87     def __mod__(self, other):
88         return self._combine(other, self.MOD, False)
89 
90     def __pow__(self, other):
91         return self._combine(other, self.POW, False)
92 
93     def __and__(self, other):
94         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
95             return Q(self) & Q(other)
96         raise NotImplementedError(
97             "Use .bitand() and .bitor() for bitwise logical operations."
98         )
99 
100     def bitand(self, other):
101         return self._combine(other, self.BITAND, False)
102 
103     def bitleftshift(self, other):
104         return self._combine(other, self.BITLEFTSHIFT, False)
105 
106     def bitrightshift(self, other):
107         return self._combine(other, self.BITRIGHTSHIFT, False)
108 
109     def bitxor(self, other):
110         return self._combine(other, self.BITXOR, False)
111 
112     def __or__(self, other):
113         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
114             return Q(self) | Q(other)
115         raise NotImplementedError(
116             "Use .bitand() and .bitor() for bitwise logical operations."
117         )
118 
119     def bitor(self, other):
120         return self._combine(other, self.BITOR, False)
121 
122     def __radd__(self, other):
123         return self._combine(other, self.ADD, True)
124 
125     def __rsub__(self, other):
126         return self._combine(other, self.SUB, True)
127 
128     def __rmul__(self, other):
129         return self._combine(other, self.MUL, True)
130 
131     def __rtruediv__(self, other):
132         return self._combine(other, self.DIV, True)
133 
134     def __rmod__(self, other):
135         return self._combine(other, self.MOD, True)
136 
137     def __rpow__(self, other):
138         return self._combine(other, self.POW, True)
139 
140     def __rand__(self, other):
141         raise NotImplementedError(
142             "Use .bitand() and .bitor() for bitwise logical operations."
143         )
144 
145     def __ror__(self, other):
146         raise NotImplementedError(
147             "Use .bitand() and .bitor() for bitwise logical operations."
148         )
149 
150 
151 @deconstructible
152 class BaseExpression:
153     """Base class for all query expressions."""
154 
155     # aggregate specific fields
156     is_summary = False
157     _output_field_resolved_to_none = False
158     # Can the expression be used in a WHERE clause?
159     filterable = True
160     # Can the expression can be used as a source expression in Window?
161     window_compatible = False
162 
163     def __init__(self, output_field=None):
164         if output_field is not None:
165             self.output_field = output_field
166 
167     def __getstate__(self):
168         state = self.__dict__.copy()
169         state.pop('convert_value', None)
170         return state
171 
172     def get_db_converters(self, connection):
173         return (
174             []
175             if self.convert_value is self._convert_value_noop else
176             [self.convert_value]
177         ) + self.output_field.get_db_converters(connection)
178 
179     def get_source_expressions(self):
180         return []
181 
182     def set_source_expressions(self, exprs):
183         assert not exprs
184 
185     def _parse_expressions(self, *expressions):
186         return [
187             arg if hasattr(arg, 'resolve_expression') else (
188                 F(arg) if isinstance(arg, str) else Value(arg)
189             ) for arg in expressions
190         ]
191 
192     def as_sql(self, compiler, connection):
193         """
194         Responsible for returning a (sql, [params]) tuple to be included
195         in the current query.
196 
197         Different backends can provide their own implementation, by
198         providing an `as_{vendor}` method and patching the Expression:
199 
200         ```
201         def override_as_sql(self, compiler, connection):
202             # custom logic
203             return super().as_sql(compiler, connection)
204         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
205         ```
206 
207         Arguments:
208          * compiler: the query compiler responsible for generating the query.
209            Must have a compile method, returning a (sql, [params]) tuple.
210            Calling compiler(value) will return a quoted `value`.
211 
212          * connection: the database connection used for the current query.
213 
214         Return: (sql, params)
215           Where `sql` is a string containing ordered sql parameters to be
216           replaced with the elements of the list `params`.
217         """
218         raise NotImplementedError("Subclasses must implement as_sql()")
219 
220     @cached_property
221     def contains_aggregate(self):
222         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
223 
224     @cached_property
225     def contains_over_clause(self):
226         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
227 
228     @cached_property
229     def contains_column_references(self):
230         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
231 
232     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
233         """
234         Provide the chance to do any preprocessing or validation before being
235         added to the query.
236 
237         Arguments:
238          * query: the backend query implementation
239          * allow_joins: boolean allowing or denying use of joins
240            in this query
241          * reuse: a set of reusable joins for multijoins
242          * summarize: a terminal aggregate clause
243          * for_save: whether this expression about to be used in a save or update
244 
245         Return: an Expression to be added to the query.
246         """
247         c = self.copy()
248         c.is_summary = summarize
249         c.set_source_expressions([
250             expr.resolve_expression(query, allow_joins, reuse, summarize)
251             if expr else None
252             for expr in c.get_source_expressions()
253         ])
254         return c
255 
256     @property
257     def conditional(self):
258         return isinstance(self.output_field, fields.BooleanField)
259 
260     @property
261     def field(self):
262         return self.output_field
263 
264     @cached_property
265     def output_field(self):
266         """Return the output type of this expressions."""
267         output_field = self._resolve_output_field()
268         if output_field is None:
269             self._output_field_resolved_to_none = True
270             raise FieldError('Cannot resolve expression type, unknown output_field')
271         return output_field
272 
273     @cached_property
274     def _output_field_or_none(self):
275         """
276         Return the output field of this expression, or None if
277         _resolve_output_field() didn't return an output type.
278         """
279         try:
280             return self.output_field
281         except FieldError:
282             if not self._output_field_resolved_to_none:
283                 raise
284 
285     def _resolve_output_field(self):
286         """
287         Attempt to infer the output type of the expression. If the output
288         fields of all source fields match then, simply infer the same type
289         here. This isn't always correct, but it makes sense most of the time.
290 
291         Consider the difference between `2 + 2` and `2 / 3`. Inferring
292         the type here is a convenience for the common case. The user should
293         supply their own output_field with more complex computations.
294 
295         If a source's output field resolves to None, exclude it from this check.
296         If all sources are None, then an error is raised higher up the stack in
297         the output_field property.
298         """
299         sources_iter = (source for source in self.get_source_fields() if source is not None)
300         for output_field in sources_iter:
301             for source in sources_iter:
302                 if not isinstance(output_field, source.__class__):
303                     raise FieldError(
304                         'Expression contains mixed types: %s, %s. You must '
305                         'set output_field.' % (
306                             output_field.__class__.__name__,
307                             source.__class__.__name__,
308                         )
309                     )
310             return output_field
311 
312     @staticmethod
313     def _convert_value_noop(value, expression, connection):
314         return value
315 
316     @cached_property
317     def convert_value(self):
318         """
319         Expressions provide their own converters because users have the option
320         of manually specifying the output_field which may be a different type
321         from the one the database returns.
322         """
323         field = self.output_field
324         internal_type = field.get_internal_type()
325         if internal_type == 'FloatField':
326             return lambda value, expression, connection: None if value is None else float(value)
327         elif internal_type.endswith('IntegerField'):
328             return lambda value, expression, connection: None if value is None else int(value)
329         elif internal_type == 'DecimalField':
330             return lambda value, expression, connection: None if value is None else Decimal(value)
331         return self._convert_value_noop
332 
333     def get_lookup(self, lookup):
334         return self.output_field.get_lookup(lookup)
335 
336     def get_transform(self, name):
337         return self.output_field.get_transform(name)
338 
339     def relabeled_clone(self, change_map):
340         clone = self.copy()
341         clone.set_source_expressions([
342             e.relabeled_clone(change_map) if e is not None else None
343             for e in self.get_source_expressions()
344         ])
345         return clone
346 
347     def copy(self):
348         return copy.copy(self)
349 
350     def get_group_by_cols(self, alias=None):
351         if not self.contains_aggregate:
352             return [self]
353         cols = []
354         for source in self.get_source_expressions():
355             cols.extend(source.get_group_by_cols())
356         return cols
357 
358     def get_source_fields(self):
359         """Return the underlying field types used by this aggregate."""
360         return [e._output_field_or_none for e in self.get_source_expressions()]
361 
362     def asc(self, **kwargs):
363         return OrderBy(self, **kwargs)
364 
365     def desc(self, **kwargs):
366         return OrderBy(self, descending=True, **kwargs)
367 
368     def reverse_ordering(self):
369         return self
370 
371     def flatten(self):
372         """
373         Recursively yield this expression and all subexpressions, in
374         depth-first order.
375         """
376         yield self
377         for expr in self.get_source_expressions():
378             if expr:
379                 yield from expr.flatten()
380 
381     def select_format(self, compiler, sql, params):
382         """
383         Custom format for select clauses. For example, EXISTS expressions need
384         to be wrapped in CASE WHEN on Oracle.
385         """
386         return self.output_field.select_format(compiler, sql, params)
387 
388     @cached_property
389     def identity(self):
390         constructor_signature = inspect.signature(self.__init__)
391         args, kwargs = self._constructor_args
392         signature = constructor_signature.bind_partial(*args, **kwargs)
393         signature.apply_defaults()
394         arguments = signature.arguments.items()
395         identity = [self.__class__]
396         for arg, value in arguments:
397             if isinstance(value, fields.Field):
398                 if value.name and value.model:
399                     value = (value.model._meta.label, value.name)
400                 else:
401                     value = type(value)
402             else:
403                 value = make_hashable(value)
404             identity.append((arg, value))
405         return tuple(identity)
406 
407     def __eq__(self, other):
408         if not isinstance(other, BaseExpression):
409             return NotImplemented
410         return other.identity == self.identity
411 
412     def __hash__(self):
413         return hash(self.identity)
414 
415 
416 class Expression(BaseExpression, Combinable):
417     """An expression that can be combined with other expressions."""
418     pass
419 
420 
421 class CombinedExpression(SQLiteNumericMixin, Expression):
422 
423     def __init__(self, lhs, connector, rhs, output_field=None):
424         super().__init__(output_field=output_field)
425         self.connector = connector
426         self.lhs = lhs
427         self.rhs = rhs
428 
429     def __repr__(self):
430         return "<{}: {}>".format(self.__class__.__name__, self)
431 
432     def __str__(self):
433         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
434 
435     def get_source_expressions(self):
436         return [self.lhs, self.rhs]
437 
438     def set_source_expressions(self, exprs):
439         self.lhs, self.rhs = exprs
440 
441     def as_sql(self, compiler, connection):
442         try:
443             lhs_output = self.lhs.output_field
444         except FieldError:
445             lhs_output = None
446         try:
447             rhs_output = self.rhs.output_field
448         except FieldError:
449             rhs_output = None
450         if (not connection.features.has_native_duration_field and
451                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or
452                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):
453             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)
454         if (lhs_output and rhs_output and self.connector == self.SUB and
455             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and
456                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):
457             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)
458         expressions = []
459         expression_params = []
460         sql, params = compiler.compile(self.lhs)
461         expressions.append(sql)
462         expression_params.extend(params)
463         sql, params = compiler.compile(self.rhs)
464         expressions.append(sql)
465         expression_params.extend(params)
466         # order of precedence
467         expression_wrapper = '(%s)'
468         sql = connection.ops.combine_expression(self.connector, expressions)
469         return expression_wrapper % sql, expression_params
470 
471     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
472         c = self.copy()
473         c.is_summary = summarize
474         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
475         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
476         return c
477 
478 
479 class DurationExpression(CombinedExpression):
480     def compile(self, side, compiler, connection):
481         if not isinstance(side, DurationValue):
482             try:
483                 output = side.output_field
484             except FieldError:
485                 pass
486             else:
487                 if output.get_internal_type() == 'DurationField':
488                     sql, params = compiler.compile(side)
489                     return connection.ops.format_for_duration_arithmetic(sql), params
490         return compiler.compile(side)
491 
492     def as_sql(self, compiler, connection):
493         connection.ops.check_expression_support(self)
494         expressions = []
495         expression_params = []
496         sql, params = self.compile(self.lhs, compiler, connection)
497         expressions.append(sql)
498         expression_params.extend(params)
499         sql, params = self.compile(self.rhs, compiler, connection)
500         expressions.append(sql)
501         expression_params.extend(params)
502         # order of precedence
503         expression_wrapper = '(%s)'
504         sql = connection.ops.combine_duration_expression(self.connector, expressions)
505         return expression_wrapper % sql, expression_params
506 
507 
508 class TemporalSubtraction(CombinedExpression):
509     output_field = fields.DurationField()
510 
511     def __init__(self, lhs, rhs):
512         super().__init__(lhs, self.SUB, rhs)
513 
514     def as_sql(self, compiler, connection):
515         connection.ops.check_expression_support(self)
516         lhs = compiler.compile(self.lhs)
517         rhs = compiler.compile(self.rhs)
518         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
519 
520 
521 @deconstructible
522 class F(Combinable):
523     """An object capable of resolving references to existing query objects."""
524 
525     def __init__(self, name):
526         """
527         Arguments:
528          * name: the name of the field this expression references
529         """
530         self.name = name
531 
532     def __repr__(self):
533         return "{}({})".format(self.__class__.__name__, self.name)
534 
535     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
536                            summarize=False, for_save=False):
537         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
538 
539     def asc(self, **kwargs):
540         return OrderBy(self, **kwargs)
541 
542     def desc(self, **kwargs):
543         return OrderBy(self, descending=True, **kwargs)
544 
545     def __eq__(self, other):
546         return self.__class__ == other.__class__ and self.name == other.name
547 
548     def __hash__(self):
549         return hash(self.name)
550 
551 
552 class ResolvedOuterRef(F):
553     """
554     An object that contains a reference to an outer query.
555 
556     In this case, the reference to the outer query has been resolved because
557     the inner query has been used as a subquery.
558     """
559     contains_aggregate = False
560 
561     def as_sql(self, *args, **kwargs):
562         raise ValueError(
563             'This queryset contains a reference to an outer query and may '
564             'only be used in a subquery.'
565         )
566 
567     def resolve_expression(self, *args, **kwargs):
568         col = super().resolve_expression(*args, **kwargs)
569         # FIXME: Rename possibly_multivalued to multivalued and fix detection
570         # for non-multivalued JOINs (e.g. foreign key fields). This should take
571         # into accountÂ only many-to-many and one-to-many relationships.
572         col.possibly_multivalued = LOOKUP_SEP in self.name
573         return col
574 
575     def relabeled_clone(self, relabels):
576         return self
577 
578     def get_group_by_cols(self, alias=None):
579         return []
580 
581 
582 class OuterRef(F):
583     def resolve_expression(self, *args, **kwargs):
584         if isinstance(self.name, self.__class__):
585             return self.name
586         return ResolvedOuterRef(self.name)
587 
588     def relabeled_clone(self, relabels):
589         return self
590 
591 
592 class Func(SQLiteNumericMixin, Expression):
593     """An SQL function call."""
594     function = None
595     template = '%(function)s(%(expressions)s)'
596     arg_joiner = ', '
597     arity = None  # The number of arguments the function accepts.
598 
599     def __init__(self, *expressions, output_field=None, **extra):
600         if self.arity is not None and len(expressions) != self.arity:
601             raise TypeError(
602                 "'%s' takes exactly %s %s (%s given)" % (
603                     self.__class__.__name__,
604                     self.arity,
605                     "argument" if self.arity == 1 else "arguments",
606                     len(expressions),
607                 )
608             )
609         super().__init__(output_field=output_field)
610         self.source_expressions = self._parse_expressions(*expressions)
611         self.extra = extra
612 
613     def __repr__(self):
614         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
615         extra = {**self.extra, **self._get_repr_options()}
616         if extra:
617             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
618             return "{}({}, {})".format(self.__class__.__name__, args, extra)
619         return "{}({})".format(self.__class__.__name__, args)
620 
621     def _get_repr_options(self):
622         """Return a dict of extra __init__() options to include in the repr."""
623         return {}
624 
625     def get_source_expressions(self):
626         return self.source_expressions
627 
628     def set_source_expressions(self, exprs):
629         self.source_expressions = exprs
630 
631     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
632         c = self.copy()
633         c.is_summary = summarize
634         for pos, arg in enumerate(c.source_expressions):
635             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
636         return c
637 
638     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
639         connection.ops.check_expression_support(self)
640         sql_parts = []
641         params = []
642         for arg in self.source_expressions:
643             arg_sql, arg_params = compiler.compile(arg)
644             sql_parts.append(arg_sql)
645             params.extend(arg_params)
646         data = {**self.extra, **extra_context}
647         # Use the first supplied value in this order: the parameter to this
648         # method, a value supplied in __init__()'s **extra (the value in
649         # `data`), or the value defined on the class.
650         if function is not None:
651             data['function'] = function
652         else:
653             data.setdefault('function', self.function)
654         template = template or data.get('template', self.template)
655         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
656         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
657         return template % data, params
658 
659     def copy(self):
660         copy = super().copy()
661         copy.source_expressions = self.source_expressions[:]
662         copy.extra = self.extra.copy()
663         return copy
664 
665 
666 class Value(Expression):
667     """Represent a wrapped value as a node within an expression."""
668     def __init__(self, value, output_field=None):
669         """
670         Arguments:
671          * value: the value this expression represents. The value will be
672            added into the sql parameter list and properly quoted.
673 
674          * output_field: an instance of the model field type that this
675            expression will return, such as IntegerField() or CharField().
676         """
677         super().__init__(output_field=output_field)
678         self.value = value
679 
680     def __repr__(self):
681         return "{}({})".format(self.__class__.__name__, self.value)
682 
683     def as_sql(self, compiler, connection):
684         connection.ops.check_expression_support(self)
685         val = self.value
686         output_field = self._output_field_or_none
687         if output_field is not None:
688             if self.for_save:
689                 val = output_field.get_db_prep_save(val, connection=connection)
690             else:
691                 val = output_field.get_db_prep_value(val, connection=connection)
692             if hasattr(output_field, 'get_placeholder'):
693                 return output_field.get_placeholder(val, compiler, connection), [val]
694         if val is None:
695             # cx_Oracle does not always convert None to the appropriate
696             # NULL type (like in case expressions using numbers), so we
697             # use a literal SQL NULL
698             return 'NULL', []
699         return '%s', [val]
700 
701     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
702         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
703         c.for_save = for_save
704         return c
705 
706     def get_group_by_cols(self, alias=None):
707         return []
708 
709 
710 class DurationValue(Value):
711     def as_sql(self, compiler, connection):
712         connection.ops.check_expression_support(self)
713         if connection.features.has_native_duration_field:
714             return super().as_sql(compiler, connection)
715         return connection.ops.date_interval_sql(self.value), []
716 
717 
718 class RawSQL(Expression):
719     def __init__(self, sql, params, output_field=None):
720         if output_field is None:
721             output_field = fields.Field()
722         self.sql, self.params = sql, params
723         super().__init__(output_field=output_field)
724 
725     def __repr__(self):
726         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
727 
728     def as_sql(self, compiler, connection):
729         return '(%s)' % self.sql, self.params
730 
731     def get_group_by_cols(self, alias=None):
732         return [self]
733 
734     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
735         # Resolve parents fields used in raw SQL.
736         for parent in query.model._meta.get_parent_list():
737             for parent_field in parent._meta.local_fields:
738                 _, column_name = parent_field.get_attname_column()
739                 if column_name.lower() in self.sql.lower():
740                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
741                     break
742         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
743 
744 
745 class Star(Expression):
746     def __repr__(self):
747         return "'*'"
748 
749     def as_sql(self, compiler, connection):
750         return '*', []
751 
752 
753 class Random(Expression):
754     output_field = fields.FloatField()
755 
756     def __repr__(self):
757         return "Random()"
758 
759     def as_sql(self, compiler, connection):
760         return connection.ops.random_function_sql(), []
761 
762 
763 class Col(Expression):
764 
765     contains_column_references = True
766     possibly_multivalued = False
767 
768     def __init__(self, alias, target, output_field=None):
769         if output_field is None:
770             output_field = target
771         super().__init__(output_field=output_field)
772         self.alias, self.target = alias, target
773 
774     def __repr__(self):
775         alias, target = self.alias, self.target
776         identifiers = (alias, str(target)) if alias else (str(target),)
777         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
778 
779     def as_sql(self, compiler, connection):
780         alias, column = self.alias, self.target.column
781         identifiers = (alias, column) if alias else (column,)
782         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
783         return sql, []
784 
785     def relabeled_clone(self, relabels):
786         if self.alias is None:
787             return self
788         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
789 
790     def get_group_by_cols(self, alias=None):
791         return [self]
792 
793     def get_db_converters(self, connection):
794         if self.target == self.output_field:
795             return self.output_field.get_db_converters(connection)
796         return (self.output_field.get_db_converters(connection) +
797                 self.target.get_db_converters(connection))
798 
799 
800 class Ref(Expression):
801     """
802     Reference to column alias of the query. For example, Ref('sum_cost') in
803     qs.annotate(sum_cost=Sum('cost')) query.
804     """
805     def __init__(self, refs, source):
806         super().__init__()
807         self.refs, self.source = refs, source
808 
809     def __repr__(self):
810         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
811 
812     def get_source_expressions(self):
813         return [self.source]
814 
815     def set_source_expressions(self, exprs):
816         self.source, = exprs
817 
818     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
819         # The sub-expression `source` has already been resolved, as this is
820         # just a reference to the name of `source`.
821         return self
822 
823     def relabeled_clone(self, relabels):
824         return self
825 
826     def as_sql(self, compiler, connection):
827         return connection.ops.quote_name(self.refs), []
828 
829     def get_group_by_cols(self, alias=None):
830         return [self]
831 
832 
833 class ExpressionList(Func):
834     """
835     An expression containing multiple expressions. Can be used to provide a
836     list of expressions as an argument to another expression, like an
837     ordering clause.
838     """
839     template = '%(expressions)s'
840 
841     def __init__(self, *expressions, **extra):
842         if not expressions:
843             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
844         super().__init__(*expressions, **extra)
845 
846     def __str__(self):
847         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
848 
849 
850 class ExpressionWrapper(Expression):
851     """
852     An expression that can wrap another expression so that it can provide
853     extra context to the inner expression, such as the output_field.
854     """
855 
856     def __init__(self, expression, output_field):
857         super().__init__(output_field=output_field)
858         self.expression = expression
859 
860     def set_source_expressions(self, exprs):
861         self.expression = exprs[0]
862 
863     def get_source_expressions(self):
864         return [self.expression]
865 
866     def as_sql(self, compiler, connection):
867         return self.expression.as_sql(compiler, connection)
868 
869     def __repr__(self):
870         return "{}({})".format(self.__class__.__name__, self.expression)
871 
872 
873 class When(Expression):
874     template = 'WHEN %(condition)s THEN %(result)s'
875     # This isn't a complete conditional expression, must be used in Case().
876     conditional = False
877 
878     def __init__(self, condition=None, then=None, **lookups):
879         if lookups and condition is None:
880             condition, lookups = Q(**lookups), None
881         if condition is None or not getattr(condition, 'conditional', False) or lookups:
882             raise TypeError(
883                 'When() supports a Q object, a boolean expression, or lookups '
884                 'as a condition.'
885             )
886         if isinstance(condition, Q) and not condition:
887             raise ValueError("An empty Q() can't be used as a When() condition.")
888         super().__init__(output_field=None)
889         self.condition = condition
890         self.result = self._parse_expressions(then)[0]
891 
892     def __str__(self):
893         return "WHEN %r THEN %r" % (self.condition, self.result)
894 
895     def __repr__(self):
896         return "<%s: %s>" % (self.__class__.__name__, self)
897 
898     def get_source_expressions(self):
899         return [self.condition, self.result]
900 
901     def set_source_expressions(self, exprs):
902         self.condition, self.result = exprs
903 
904     def get_source_fields(self):
905         # We're only interested in the fields of the result expressions.
906         return [self.result._output_field_or_none]
907 
908     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
909         c = self.copy()
910         c.is_summary = summarize
911         if hasattr(c.condition, 'resolve_expression'):
912             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
913         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
914         return c
915 
916     def as_sql(self, compiler, connection, template=None, **extra_context):
917         connection.ops.check_expression_support(self)
918         template_params = extra_context
919         sql_params = []
920         condition_sql, condition_params = compiler.compile(self.condition)
921         template_params['condition'] = condition_sql
922         sql_params.extend(condition_params)
923         result_sql, result_params = compiler.compile(self.result)
924         template_params['result'] = result_sql
925         sql_params.extend(result_params)
926         template = template or self.template
927         return template % template_params, sql_params
928 
929     def get_group_by_cols(self, alias=None):
930         # This is not a complete expression and cannot be used in GROUP BY.
931         cols = []
932         for source in self.get_source_expressions():
933             cols.extend(source.get_group_by_cols())
934         return cols
935 
936 
937 class Case(Expression):
938     """
939     An SQL searched CASE expression:
940 
941         CASE
942             WHEN n > 0
943                 THEN 'positive'
944             WHEN n < 0
945                 THEN 'negative'
946             ELSE 'zero'
947         END
948     """
949     template = 'CASE %(cases)s ELSE %(default)s END'
950     case_joiner = ' '
951 
952     def __init__(self, *cases, default=None, output_field=None, **extra):
953         if not all(isinstance(case, When) for case in cases):
954             raise TypeError("Positional arguments must all be When objects.")
955         super().__init__(output_field)
956         self.cases = list(cases)
957         self.default = self._parse_expressions(default)[0]
958         self.extra = extra
959 
960     def __str__(self):
961         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
962 
963     def __repr__(self):
964         return "<%s: %s>" % (self.__class__.__name__, self)
965 
966     def get_source_expressions(self):
967         return self.cases + [self.default]
968 
969     def set_source_expressions(self, exprs):
970         *self.cases, self.default = exprs
971 
972     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
973         c = self.copy()
974         c.is_summary = summarize
975         for pos, case in enumerate(c.cases):
976             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
977         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
978         return c
979 
980     def copy(self):
981         c = super().copy()
982         c.cases = c.cases[:]
983         return c
984 
985     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
986         connection.ops.check_expression_support(self)
987         if not self.cases:
988             return compiler.compile(self.default)
989         template_params = {**self.extra, **extra_context}
990         case_parts = []
991         sql_params = []
992         for case in self.cases:
993             try:
994                 case_sql, case_params = compiler.compile(case)
995             except EmptyResultSet:
996                 continue
997             case_parts.append(case_sql)
998             sql_params.extend(case_params)
999         default_sql, default_params = compiler.compile(self.default)
1000         if not case_parts:
1001             return default_sql, default_params
1002         case_joiner = case_joiner or self.case_joiner
1003         template_params['cases'] = case_joiner.join(case_parts)
1004         template_params['default'] = default_sql
1005         sql_params.extend(default_params)
1006         template = template or template_params.get('template', self.template)
1007         sql = template % template_params
1008         if self._output_field_or_none is not None:
1009             sql = connection.ops.unification_cast_sql(self.output_field) % sql
1010         return sql, sql_params
1011 
1012 
1013 class Subquery(Expression):
1014     """
1015     An explicit subquery. It may contain OuterRef() references to the outer
1016     query which will be resolved when it is applied to that query.
1017     """
1018     template = '(%(subquery)s)'
1019     contains_aggregate = False
1020 
1021     def __init__(self, queryset, output_field=None, **extra):
1022         self.query = queryset.query
1023         self.extra = extra
1024         # Prevent the QuerySet from being evaluated.
1025         self.queryset = queryset._chain(_result_cache=[], prefetch_done=True)
1026         super().__init__(output_field)
1027 
1028     def __getstate__(self):
1029         state = super().__getstate__()
1030         args, kwargs = state['_constructor_args']
1031         if args:
1032             args = (self.queryset, *args[1:])
1033         else:
1034             kwargs['queryset'] = self.queryset
1035         state['_constructor_args'] = args, kwargs
1036         return state
1037 
1038     def get_source_expressions(self):
1039         return [self.query]
1040 
1041     def set_source_expressions(self, exprs):
1042         self.query = exprs[0]
1043 
1044     def _resolve_output_field(self):
1045         return self.query.output_field
1046 
1047     def copy(self):
1048         clone = super().copy()
1049         clone.query = clone.query.clone()
1050         return clone
1051 
1052     @property
1053     def external_aliases(self):
1054         return self.query.external_aliases
1055 
1056     def as_sql(self, compiler, connection, template=None, **extra_context):
1057         connection.ops.check_expression_support(self)
1058         template_params = {**self.extra, **extra_context}
1059         subquery_sql, sql_params = self.query.as_sql(compiler, connection)
1060         template_params['subquery'] = subquery_sql[1:-1]
1061 
1062         template = template or template_params.get('template', self.template)
1063         sql = template % template_params
1064         return sql, sql_params
1065 
1066     def get_group_by_cols(self, alias=None):
1067         if alias:
1068             return [Ref(alias, self)]
1069         external_cols = self.query.get_external_cols()
1070         if any(col.possibly_multivalued for col in external_cols):
1071             return [self]
1072         return external_cols
1073 
1074 
1075 class Exists(Subquery):
1076     template = 'EXISTS(%(subquery)s)'
1077     output_field = fields.BooleanField()
1078 
1079     def __init__(self, queryset, negated=False, **kwargs):
1080         # As a performance optimization, remove ordering since EXISTS doesn't
1081         # care about it, just whether or not a row matches.
1082         queryset = queryset.order_by()
1083         self.negated = negated
1084         super().__init__(queryset, **kwargs)
1085 
1086     def __invert__(self):
1087         clone = self.copy()
1088         clone.negated = not self.negated
1089         return clone
1090 
1091     def as_sql(self, compiler, connection, template=None, **extra_context):
1092         sql, params = super().as_sql(compiler, connection, template, **extra_context)
1093         if self.negated:
1094             sql = 'NOT {}'.format(sql)
1095         return sql, params
1096 
1097     def select_format(self, compiler, sql, params):
1098         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1099         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP
1100         # BY list.
1101         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1102             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1103         return sql, params
1104 
1105 
1106 class OrderBy(BaseExpression):
1107     template = '%(expression)s %(ordering)s'
1108     conditional = False
1109 
1110     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1111         if nulls_first and nulls_last:
1112             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1113         self.nulls_first = nulls_first
1114         self.nulls_last = nulls_last
1115         self.descending = descending
1116         if not hasattr(expression, 'resolve_expression'):
1117             raise ValueError('expression must be an expression type')
1118         self.expression = expression
1119 
1120     def __repr__(self):
1121         return "{}({}, descending={})".format(
1122             self.__class__.__name__, self.expression, self.descending)
1123 
1124     def set_source_expressions(self, exprs):
1125         self.expression = exprs[0]
1126 
1127     def get_source_expressions(self):
1128         return [self.expression]
1129 
1130     def as_sql(self, compiler, connection, template=None, **extra_context):
1131         template = template or self.template
1132         if connection.features.supports_order_by_nulls_modifier:
1133             if self.nulls_last:
1134                 template = '%s NULLS LAST' % template
1135             elif self.nulls_first:
1136                 template = '%s NULLS FIRST' % template
1137         else:
1138             if self.nulls_last and not (
1139                 self.descending and connection.features.order_by_nulls_first
1140             ):
1141                 template = '%%(expression)s IS NULL, %s' % template
1142             elif self.nulls_first and not (
1143                 not self.descending and connection.features.order_by_nulls_first
1144             ):
1145                 template = '%%(expression)s IS NOT NULL, %s' % template
1146         connection.ops.check_expression_support(self)
1147         expression_sql, params = compiler.compile(self.expression)
1148         placeholders = {
1149             'expression': expression_sql,
1150             'ordering': 'DESC' if self.descending else 'ASC',
1151             **extra_context,
1152         }
1153         template = template or self.template
1154         params *= template.count('%(expression)s')
1155         return (template % placeholders).rstrip(), params
1156 
1157     def as_oracle(self, compiler, connection):
1158         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in
1159         # a CASE WHEN.
1160         if isinstance(self.expression, Exists):
1161             copy = self.copy()
1162             copy.expression = Case(
1163                 When(self.expression, then=True),
1164                 default=False,
1165                 output_field=fields.BooleanField(),
1166             )
1167             return copy.as_sql(compiler, connection)
1168         return self.as_sql(compiler, connection)
1169 
1170     def get_group_by_cols(self, alias=None):
1171         cols = []
1172         for source in self.get_source_expressions():
1173             cols.extend(source.get_group_by_cols())
1174         return cols
1175 
1176     def reverse_ordering(self):
1177         self.descending = not self.descending
1178         if self.nulls_first or self.nulls_last:
1179             self.nulls_first = not self.nulls_first
1180             self.nulls_last = not self.nulls_last
1181         return self
1182 
1183     def asc(self):
1184         self.descending = False
1185 
1186     def desc(self):
1187         self.descending = True
1188 
1189 
1190 class Window(Expression):
1191     template = '%(expression)s OVER (%(window)s)'
1192     # Although the main expression may either be an aggregate or an
1193     # expression with an aggregate function, the GROUP BY that will
1194     # be introduced in the query as a result is not desired.
1195     contains_aggregate = False
1196     contains_over_clause = True
1197     filterable = False
1198 
1199     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1200         self.partition_by = partition_by
1201         self.order_by = order_by
1202         self.frame = frame
1203 
1204         if not getattr(expression, 'window_compatible', False):
1205             raise ValueError(
1206                 "Expression '%s' isn't compatible with OVER clauses." %
1207                 expression.__class__.__name__
1208             )
1209 
1210         if self.partition_by is not None:
1211             if not isinstance(self.partition_by, (tuple, list)):
1212                 self.partition_by = (self.partition_by,)
1213             self.partition_by = ExpressionList(*self.partition_by)
1214 
1215         if self.order_by is not None:
1216             if isinstance(self.order_by, (list, tuple)):
1217                 self.order_by = ExpressionList(*self.order_by)
1218             elif not isinstance(self.order_by, BaseExpression):
1219                 raise ValueError(
1220                     'order_by must be either an Expression or a sequence of '
1221                     'expressions.'
1222                 )
1223         super().__init__(output_field=output_field)
1224         self.source_expression = self._parse_expressions(expression)[0]
1225 
1226     def _resolve_output_field(self):
1227         return self.source_expression.output_field
1228 
1229     def get_source_expressions(self):
1230         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1231 
1232     def set_source_expressions(self, exprs):
1233         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1234 
1235     def as_sql(self, compiler, connection, template=None):
1236         connection.ops.check_expression_support(self)
1237         if not connection.features.supports_over_clause:
1238             raise NotSupportedError('This backend does not support window expressions.')
1239         expr_sql, params = compiler.compile(self.source_expression)
1240         window_sql, window_params = [], []
1241 
1242         if self.partition_by is not None:
1243             sql_expr, sql_params = self.partition_by.as_sql(
1244                 compiler=compiler, connection=connection,
1245                 template='PARTITION BY %(expressions)s',
1246             )
1247             window_sql.extend(sql_expr)
1248             window_params.extend(sql_params)
1249 
1250         if self.order_by is not None:
1251             window_sql.append(' ORDER BY ')
1252             order_sql, order_params = compiler.compile(self.order_by)
1253             window_sql.extend(order_sql)
1254             window_params.extend(order_params)
1255 
1256         if self.frame:
1257             frame_sql, frame_params = compiler.compile(self.frame)
1258             window_sql.append(' ' + frame_sql)
1259             window_params.extend(frame_params)
1260 
1261         params.extend(window_params)
1262         template = template or self.template
1263 
1264         return template % {
1265             'expression': expr_sql,
1266             'window': ''.join(window_sql).strip()
1267         }, params
1268 
1269     def __str__(self):
1270         return '{} OVER ({}{}{})'.format(
1271             str(self.source_expression),
1272             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1273             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1274             str(self.frame or ''),
1275         )
1276 
1277     def __repr__(self):
1278         return '<%s: %s>' % (self.__class__.__name__, self)
1279 
1280     def get_group_by_cols(self, alias=None):
1281         return []
1282 
1283 
1284 class WindowFrame(Expression):
1285     """
1286     Model the frame clause in window expressions. There are two types of frame
1287     clauses which are subclasses, however, all processing and validation (by no
1288     means intended to be complete) is done here. Thus, providing an end for a
1289     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1290     row in the frame).
1291     """
1292     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1293 
1294     def __init__(self, start=None, end=None):
1295         self.start = Value(start)
1296         self.end = Value(end)
1297 
1298     def set_source_expressions(self, exprs):
1299         self.start, self.end = exprs
1300 
1301     def get_source_expressions(self):
1302         return [self.start, self.end]
1303 
1304     def as_sql(self, compiler, connection):
1305         connection.ops.check_expression_support(self)
1306         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1307         return self.template % {
1308             'frame_type': self.frame_type,
1309             'start': start,
1310             'end': end,
1311         }, []
1312 
1313     def __repr__(self):
1314         return '<%s: %s>' % (self.__class__.__name__, self)
1315 
1316     def get_group_by_cols(self, alias=None):
1317         return []
1318 
1319     def __str__(self):
1320         if self.start.value is not None and self.start.value < 0:
1321             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1322         elif self.start.value is not None and self.start.value == 0:
1323             start = connection.ops.CURRENT_ROW
1324         else:
1325             start = connection.ops.UNBOUNDED_PRECEDING
1326 
1327         if self.end.value is not None and self.end.value > 0:
1328             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1329         elif self.end.value is not None and self.end.value == 0:
1330             end = connection.ops.CURRENT_ROW
1331         else:
1332             end = connection.ops.UNBOUNDED_FOLLOWING
1333         return self.template % {
1334             'frame_type': self.frame_type,
1335             'start': start,
1336             'end': end,
1337         }
1338 
1339     def window_frame_start_end(self, connection, start, end):
1340         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1341 
1342 
1343 class RowRange(WindowFrame):
1344     frame_type = 'ROWS'
1345 
1346     def window_frame_start_end(self, connection, start, end):
1347         return connection.ops.window_frame_rows_start_end(start, end)
1348 
1349 
1350 class ValueRange(WindowFrame):
1351     frame_type = 'RANGE'
1352 
1353     def window_frame_start_end(self, connection, start, end):
1354         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>Modify the `When` method to automatically recognize and correctly handle `Exists` expressions as valid arguments without requiring them to be wrapped in a `Q` object. This could involve adjusting the method's argument parsing to treat `Exists` similarly to how `filter` expressions are treated, ensuring that `Exists` can be passed directly as a condition. This change must not disrupt the existing functionality, which allows `Q` objects, boolean expressions, and lookups as conditions.</intended_behavior>]
2025-10-18 11:40:59.073 | INFO     | Search completed. Bug locations: [<file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import inspect
4 from decimal import Decimal
5 
6 from django.core.exceptions import EmptyResultSet, FieldError
7 from django.db import NotSupportedError, connection
8 from django.db.models import fields
9 from django.db.models.constants import LOOKUP_SEP
10 from django.db.models.query_utils import Q
11 from django.utils.deconstruct import deconstructible
12 from django.utils.functional import cached_property
13 from django.utils.hashable import make_hashable
14 
15 
16 class SQLiteNumericMixin:
17     """
18     Some expressions with output_field=DecimalField() must be cast to
19     numeric to be properly filtered.
20     """
21     def as_sqlite(self, compiler, connection, **extra_context):
22         sql, params = self.as_sql(compiler, connection, **extra_context)
23         try:
24             if self.output_field.get_internal_type() == 'DecimalField':
25                 sql = 'CAST(%s AS NUMERIC)' % sql
26         except FieldError:
27             pass
28         return sql, params
29 
30 
31 class Combinable:
32     """
33     Provide the ability to combine one or two objects with
34     some connector. For example F('foo') + F('bar').
35     """
36 
37     # Arithmetic connectors
38     ADD = '+'
39     SUB = '-'
40     MUL = '*'
41     DIV = '/'
42     POW = '^'
43     # The following is a quoted % operator - it is quoted because it can be
44     # used in strings that also have parameter substitution.
45     MOD = '%%'
46 
47     # Bitwise operators - note that these are generated by .bitand()
48     # and .bitor(), the '&' and '|' are reserved for boolean operator
49     # usage.
50     BITAND = '&'
51     BITOR = '|'
52     BITLEFTSHIFT = '<<'
53     BITRIGHTSHIFT = '>>'
54     BITXOR = '#'
55 
56     def _combine(self, other, connector, reversed):
57         if not hasattr(other, 'resolve_expression'):
58             # everything must be resolvable to an expression
59             if isinstance(other, datetime.timedelta):
60                 other = DurationValue(other, output_field=fields.DurationField())
61             else:
62                 other = Value(other)
63 
64         if reversed:
65             return CombinedExpression(other, connector, self)
66         return CombinedExpression(self, connector, other)
67 
68     #############
69     # OPERATORS #
70     #############
71 
72     def __neg__(self):
73         return self._combine(-1, self.MUL, False)
74 
75     def __add__(self, other):
76         return self._combine(other, self.ADD, False)
77 
78     def __sub__(self, other):
79         return self._combine(other, self.SUB, False)
80 
81     def __mul__(self, other):
82         return self._combine(other, self.MUL, False)
83 
84     def __truediv__(self, other):
85         return self._combine(other, self.DIV, False)
86 
87     def __mod__(self, other):
88         return self._combine(other, self.MOD, False)
89 
90     def __pow__(self, other):
91         return self._combine(other, self.POW, False)
92 
93     def __and__(self, other):
94         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
95             return Q(self) & Q(other)
96         raise NotImplementedError(
97             "Use .bitand() and .bitor() for bitwise logical operations."
98         )
99 
100     def bitand(self, other):
101         return self._combine(other, self.BITAND, False)
102 
103     def bitleftshift(self, other):
104         return self._combine(other, self.BITLEFTSHIFT, False)
105 
106     def bitrightshift(self, other):
107         return self._combine(other, self.BITRIGHTSHIFT, False)
108 
109     def bitxor(self, other):
110         return self._combine(other, self.BITXOR, False)
111 
112     def __or__(self, other):
113         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
114             return Q(self) | Q(other)
115         raise NotImplementedError(
116             "Use .bitand() and .bitor() for bitwise logical operations."
117         )
118 
119     def bitor(self, other):
120         return self._combine(other, self.BITOR, False)
121 
122     def __radd__(self, other):
123         return self._combine(other, self.ADD, True)
124 
125     def __rsub__(self, other):
126         return self._combine(other, self.SUB, True)
127 
128     def __rmul__(self, other):
129         return self._combine(other, self.MUL, True)
130 
131     def __rtruediv__(self, other):
132         return self._combine(other, self.DIV, True)
133 
134     def __rmod__(self, other):
135         return self._combine(other, self.MOD, True)
136 
137     def __rpow__(self, other):
138         return self._combine(other, self.POW, True)
139 
140     def __rand__(self, other):
141         raise NotImplementedError(
142             "Use .bitand() and .bitor() for bitwise logical operations."
143         )
144 
145     def __ror__(self, other):
146         raise NotImplementedError(
147             "Use .bitand() and .bitor() for bitwise logical operations."
148         )
149 
150 
151 @deconstructible
152 class BaseExpression:
153     """Base class for all query expressions."""
154 
155     # aggregate specific fields
156     is_summary = False
157     _output_field_resolved_to_none = False
158     # Can the expression be used in a WHERE clause?
159     filterable = True
160     # Can the expression can be used as a source expression in Window?
161     window_compatible = False
162 
163     def __init__(self, output_field=None):
164         if output_field is not None:
165             self.output_field = output_field
166 
167     def __getstate__(self):
168         state = self.__dict__.copy()
169         state.pop('convert_value', None)
170         return state
171 
172     def get_db_converters(self, connection):
173         return (
174             []
175             if self.convert_value is self._convert_value_noop else
176             [self.convert_value]
177         ) + self.output_field.get_db_converters(connection)
178 
179     def get_source_expressions(self):
180         return []
181 
182     def set_source_expressions(self, exprs):
183         assert not exprs
184 
185     def _parse_expressions(self, *expressions):
186         return [
187             arg if hasattr(arg, 'resolve_expression') else (
188                 F(arg) if isinstance(arg, str) else Value(arg)
189             ) for arg in expressions
190         ]
191 
192     def as_sql(self, compiler, connection):
193         """
194         Responsible for returning a (sql, [params]) tuple to be included
195         in the current query.
196 
197         Different backends can provide their own implementation, by
198         providing an `as_{vendor}` method and patching the Expression:
199 
200         ```
201         def override_as_sql(self, compiler, connection):
202             # custom logic
203             return super().as_sql(compiler, connection)
204         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
205         ```
206 
207         Arguments:
208          * compiler: the query compiler responsible for generating the query.
209            Must have a compile method, returning a (sql, [params]) tuple.
210            Calling compiler(value) will return a quoted `value`.
211 
212          * connection: the database connection used for the current query.
213 
214         Return: (sql, params)
215           Where `sql` is a string containing ordered sql parameters to be
216           replaced with the elements of the list `params`.
217         """
218         raise NotImplementedError("Subclasses must implement as_sql()")
219 
220     @cached_property
221     def contains_aggregate(self):
222         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
223 
224     @cached_property
225     def contains_over_clause(self):
226         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
227 
228     @cached_property
229     def contains_column_references(self):
230         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
231 
232     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
233         """
234         Provide the chance to do any preprocessing or validation before being
235         added to the query.
236 
237         Arguments:
238          * query: the backend query implementation
239          * allow_joins: boolean allowing or denying use of joins
240            in this query
241          * reuse: a set of reusable joins for multijoins
242          * summarize: a terminal aggregate clause
243          * for_save: whether this expression about to be used in a save or update
244 
245         Return: an Expression to be added to the query.
246         """
247         c = self.copy()
248         c.is_summary = summarize
249         c.set_source_expressions([
250             expr.resolve_expression(query, allow_joins, reuse, summarize)
251             if expr else None
252             for expr in c.get_source_expressions()
253         ])
254         return c
255 
256     @property
257     def conditional(self):
258         return isinstance(self.output_field, fields.BooleanField)
259 
260     @property
261     def field(self):
262         return self.output_field
263 
264     @cached_property
265     def output_field(self):
266         """Return the output type of this expressions."""
267         output_field = self._resolve_output_field()
268         if output_field is None:
269             self._output_field_resolved_to_none = True
270             raise FieldError('Cannot resolve expression type, unknown output_field')
271         return output_field
272 
273     @cached_property
274     def _output_field_or_none(self):
275         """
276         Return the output field of this expression, or None if
277         _resolve_output_field() didn't return an output type.
278         """
279         try:
280             return self.output_field
281         except FieldError:
282             if not self._output_field_resolved_to_none:
283                 raise
284 
285     def _resolve_output_field(self):
286         """
287         Attempt to infer the output type of the expression. If the output
288         fields of all source fields match then, simply infer the same type
289         here. This isn't always correct, but it makes sense most of the time.
290 
291         Consider the difference between `2 + 2` and `2 / 3`. Inferring
292         the type here is a convenience for the common case. The user should
293         supply their own output_field with more complex computations.
294 
295         If a source's output field resolves to None, exclude it from this check.
296         If all sources are None, then an error is raised higher up the stack in
297         the output_field property.
298         """
299         sources_iter = (source for source in self.get_source_fields() if source is not None)
300         for output_field in sources_iter:
301             for source in sources_iter:
302                 if not isinstance(output_field, source.__class__):
303                     raise FieldError(
304                         'Expression contains mixed types: %s, %s. You must '
305                         'set output_field.' % (
306                             output_field.__class__.__name__,
307                             source.__class__.__name__,
308                         )
309                     )
310             return output_field
311 
312     @staticmethod
313     def _convert_value_noop(value, expression, connection):
314         return value
315 
316     @cached_property
317     def convert_value(self):
318         """
319         Expressions provide their own converters because users have the option
320         of manually specifying the output_field which may be a different type
321         from the one the database returns.
322         """
323         field = self.output_field
324         internal_type = field.get_internal_type()
325         if internal_type == 'FloatField':
326             return lambda value, expression, connection: None if value is None else float(value)
327         elif internal_type.endswith('IntegerField'):
328             return lambda value, expression, connection: None if value is None else int(value)
329         elif internal_type == 'DecimalField':
330             return lambda value, expression, connection: None if value is None else Decimal(value)
331         return self._convert_value_noop
332 
333     def get_lookup(self, lookup):
334         return self.output_field.get_lookup(lookup)
335 
336     def get_transform(self, name):
337         return self.output_field.get_transform(name)
338 
339     def relabeled_clone(self, change_map):
340         clone = self.copy()
341         clone.set_source_expressions([
342             e.relabeled_clone(change_map) if e is not None else None
343             for e in self.get_source_expressions()
344         ])
345         return clone
346 
347     def copy(self):
348         return copy.copy(self)
349 
350     def get_group_by_cols(self, alias=None):
351         if not self.contains_aggregate:
352             return [self]
353         cols = []
354         for source in self.get_source_expressions():
355             cols.extend(source.get_group_by_cols())
356         return cols
357 
358     def get_source_fields(self):
359         """Return the underlying field types used by this aggregate."""
360         return [e._output_field_or_none for e in self.get_source_expressions()]
361 
362     def asc(self, **kwargs):
363         return OrderBy(self, **kwargs)
364 
365     def desc(self, **kwargs):
366         return OrderBy(self, descending=True, **kwargs)
367 
368     def reverse_ordering(self):
369         return self
370 
371     def flatten(self):
372         """
373         Recursively yield this expression and all subexpressions, in
374         depth-first order.
375         """
376         yield self
377         for expr in self.get_source_expressions():
378             if expr:
379                 yield from expr.flatten()
380 
381     def select_format(self, compiler, sql, params):
382         """
383         Custom format for select clauses. For example, EXISTS expressions need
384         to be wrapped in CASE WHEN on Oracle.
385         """
386         return self.output_field.select_format(compiler, sql, params)
387 
388     @cached_property
389     def identity(self):
390         constructor_signature = inspect.signature(self.__init__)
391         args, kwargs = self._constructor_args
392         signature = constructor_signature.bind_partial(*args, **kwargs)
393         signature.apply_defaults()
394         arguments = signature.arguments.items()
395         identity = [self.__class__]
396         for arg, value in arguments:
397             if isinstance(value, fields.Field):
398                 if value.name and value.model:
399                     value = (value.model._meta.label, value.name)
400                 else:
401                     value = type(value)
402             else:
403                 value = make_hashable(value)
404             identity.append((arg, value))
405         return tuple(identity)
406 
407     def __eq__(self, other):
408         if not isinstance(other, BaseExpression):
409             return NotImplemented
410         return other.identity == self.identity
411 
412     def __hash__(self):
413         return hash(self.identity)
414 
415 
416 class Expression(BaseExpression, Combinable):
417     """An expression that can be combined with other expressions."""
418     pass
419 
420 
421 class CombinedExpression(SQLiteNumericMixin, Expression):
422 
423     def __init__(self, lhs, connector, rhs, output_field=None):
424         super().__init__(output_field=output_field)
425         self.connector = connector
426         self.lhs = lhs
427         self.rhs = rhs
428 
429     def __repr__(self):
430         return "<{}: {}>".format(self.__class__.__name__, self)
431 
432     def __str__(self):
433         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
434 
435     def get_source_expressions(self):
436         return [self.lhs, self.rhs]
437 
438     def set_source_expressions(self, exprs):
439         self.lhs, self.rhs = exprs
440 
441     def as_sql(self, compiler, connection):
442         try:
443             lhs_output = self.lhs.output_field
444         except FieldError:
445             lhs_output = None
446         try:
447             rhs_output = self.rhs.output_field
448         except FieldError:
449             rhs_output = None
450         if (not connection.features.has_native_duration_field and
451                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or
452                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):
453             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)
454         if (lhs_output and rhs_output and self.connector == self.SUB and
455             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and
456                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):
457             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)
458         expressions = []
459         expression_params = []
460         sql, params = compiler.compile(self.lhs)
461         expressions.append(sql)
462         expression_params.extend(params)
463         sql, params = compiler.compile(self.rhs)
464         expressions.append(sql)
465         expression_params.extend(params)
466         # order of precedence
467         expression_wrapper = '(%s)'
468         sql = connection.ops.combine_expression(self.connector, expressions)
469         return expression_wrapper % sql, expression_params
470 
471     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
472         c = self.copy()
473         c.is_summary = summarize
474         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
475         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
476         return c
477 
478 
479 class DurationExpression(CombinedExpression):
480     def compile(self, side, compiler, connection):
481         if not isinstance(side, DurationValue):
482             try:
483                 output = side.output_field
484             except FieldError:
485                 pass
486             else:
487                 if output.get_internal_type() == 'DurationField':
488                     sql, params = compiler.compile(side)
489                     return connection.ops.format_for_duration_arithmetic(sql), params
490         return compiler.compile(side)
491 
492     def as_sql(self, compiler, connection):
493         connection.ops.check_expression_support(self)
494         expressions = []
495         expression_params = []
496         sql, params = self.compile(self.lhs, compiler, connection)
497         expressions.append(sql)
498         expression_params.extend(params)
499         sql, params = self.compile(self.rhs, compiler, connection)
500         expressions.append(sql)
501         expression_params.extend(params)
502         # order of precedence
503         expression_wrapper = '(%s)'
504         sql = connection.ops.combine_duration_expression(self.connector, expressions)
505         return expression_wrapper % sql, expression_params
506 
507 
508 class TemporalSubtraction(CombinedExpression):
509     output_field = fields.DurationField()
510 
511     def __init__(self, lhs, rhs):
512         super().__init__(lhs, self.SUB, rhs)
513 
514     def as_sql(self, compiler, connection):
515         connection.ops.check_expression_support(self)
516         lhs = compiler.compile(self.lhs)
517         rhs = compiler.compile(self.rhs)
518         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
519 
520 
521 @deconstructible
522 class F(Combinable):
523     """An object capable of resolving references to existing query objects."""
524 
525     def __init__(self, name):
526         """
527         Arguments:
528          * name: the name of the field this expression references
529         """
530         self.name = name
531 
532     def __repr__(self):
533         return "{}({})".format(self.__class__.__name__, self.name)
534 
535     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
536                            summarize=False, for_save=False):
537         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
538 
539     def asc(self, **kwargs):
540         return OrderBy(self, **kwargs)
541 
542     def desc(self, **kwargs):
543         return OrderBy(self, descending=True, **kwargs)
544 
545     def __eq__(self, other):
546         return self.__class__ == other.__class__ and self.name == other.name
547 
548     def __hash__(self):
549         return hash(self.name)
550 
551 
552 class ResolvedOuterRef(F):
553     """
554     An object that contains a reference to an outer query.
555 
556     In this case, the reference to the outer query has been resolved because
557     the inner query has been used as a subquery.
558     """
559     contains_aggregate = False
560 
561     def as_sql(self, *args, **kwargs):
562         raise ValueError(
563             'This queryset contains a reference to an outer query and may '
564             'only be used in a subquery.'
565         )
566 
567     def resolve_expression(self, *args, **kwargs):
568         col = super().resolve_expression(*args, **kwargs)
569         # FIXME: Rename possibly_multivalued to multivalued and fix detection
570         # for non-multivalued JOINs (e.g. foreign key fields). This should take
571         # into accountÂ only many-to-many and one-to-many relationships.
572         col.possibly_multivalued = LOOKUP_SEP in self.name
573         return col
574 
575     def relabeled_clone(self, relabels):
576         return self
577 
578     def get_group_by_cols(self, alias=None):
579         return []
580 
581 
582 class OuterRef(F):
583     def resolve_expression(self, *args, **kwargs):
584         if isinstance(self.name, self.__class__):
585             return self.name
586         return ResolvedOuterRef(self.name)
587 
588     def relabeled_clone(self, relabels):
589         return self
590 
591 
592 class Func(SQLiteNumericMixin, Expression):
593     """An SQL function call."""
594     function = None
595     template = '%(function)s(%(expressions)s)'
596     arg_joiner = ', '
597     arity = None  # The number of arguments the function accepts.
598 
599     def __init__(self, *expressions, output_field=None, **extra):
600         if self.arity is not None and len(expressions) != self.arity:
601             raise TypeError(
602                 "'%s' takes exactly %s %s (%s given)" % (
603                     self.__class__.__name__,
604                     self.arity,
605                     "argument" if self.arity == 1 else "arguments",
606                     len(expressions),
607                 )
608             )
609         super().__init__(output_field=output_field)
610         self.source_expressions = self._parse_expressions(*expressions)
611         self.extra = extra
612 
613     def __repr__(self):
614         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
615         extra = {**self.extra, **self._get_repr_options()}
616         if extra:
617             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
618             return "{}({}, {})".format(self.__class__.__name__, args, extra)
619         return "{}({})".format(self.__class__.__name__, args)
620 
621     def _get_repr_options(self):
622         """Return a dict of extra __init__() options to include in the repr."""
623         return {}
624 
625     def get_source_expressions(self):
626         return self.source_expressions
627 
628     def set_source_expressions(self, exprs):
629         self.source_expressions = exprs
630 
631     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
632         c = self.copy()
633         c.is_summary = summarize
634         for pos, arg in enumerate(c.source_expressions):
635             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
636         return c
637 
638     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
639         connection.ops.check_expression_support(self)
640         sql_parts = []
641         params = []
642         for arg in self.source_expressions:
643             arg_sql, arg_params = compiler.compile(arg)
644             sql_parts.append(arg_sql)
645             params.extend(arg_params)
646         data = {**self.extra, **extra_context}
647         # Use the first supplied value in this order: the parameter to this
648         # method, a value supplied in __init__()'s **extra (the value in
649         # `data`), or the value defined on the class.
650         if function is not None:
651             data['function'] = function
652         else:
653             data.setdefault('function', self.function)
654         template = template or data.get('template', self.template)
655         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
656         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
657         return template % data, params
658 
659     def copy(self):
660         copy = super().copy()
661         copy.source_expressions = self.source_expressions[:]
662         copy.extra = self.extra.copy()
663         return copy
664 
665 
666 class Value(Expression):
667     """Represent a wrapped value as a node within an expression."""
668     def __init__(self, value, output_field=None):
669         """
670         Arguments:
671          * value: the value this expression represents. The value will be
672            added into the sql parameter list and properly quoted.
673 
674          * output_field: an instance of the model field type that this
675            expression will return, such as IntegerField() or CharField().
676         """
677         super().__init__(output_field=output_field)
678         self.value = value
679 
680     def __repr__(self):
681         return "{}({})".format(self.__class__.__name__, self.value)
682 
683     def as_sql(self, compiler, connection):
684         connection.ops.check_expression_support(self)
685         val = self.value
686         output_field = self._output_field_or_none
687         if output_field is not None:
688             if self.for_save:
689                 val = output_field.get_db_prep_save(val, connection=connection)
690             else:
691                 val = output_field.get_db_prep_value(val, connection=connection)
692             if hasattr(output_field, 'get_placeholder'):
693                 return output_field.get_placeholder(val, compiler, connection), [val]
694         if val is None:
695             # cx_Oracle does not always convert None to the appropriate
696             # NULL type (like in case expressions using numbers), so we
697             # use a literal SQL NULL
698             return 'NULL', []
699         return '%s', [val]
700 
701     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
702         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
703         c.for_save = for_save
704         return c
705 
706     def get_group_by_cols(self, alias=None):
707         return []
708 
709 
710 class DurationValue(Value):
711     def as_sql(self, compiler, connection):
712         connection.ops.check_expression_support(self)
713         if connection.features.has_native_duration_field:
714             return super().as_sql(compiler, connection)
715         return connection.ops.date_interval_sql(self.value), []
716 
717 
718 class RawSQL(Expression):
719     def __init__(self, sql, params, output_field=None):
720         if output_field is None:
721             output_field = fields.Field()
722         self.sql, self.params = sql, params
723         super().__init__(output_field=output_field)
724 
725     def __repr__(self):
726         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
727 
728     def as_sql(self, compiler, connection):
729         return '(%s)' % self.sql, self.params
730 
731     def get_group_by_cols(self, alias=None):
732         return [self]
733 
734     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
735         # Resolve parents fields used in raw SQL.
736         for parent in query.model._meta.get_parent_list():
737             for parent_field in parent._meta.local_fields:
738                 _, column_name = parent_field.get_attname_column()
739                 if column_name.lower() in self.sql.lower():
740                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
741                     break
742         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
743 
744 
745 class Star(Expression):
746     def __repr__(self):
747         return "'*'"
748 
749     def as_sql(self, compiler, connection):
750         return '*', []
751 
752 
753 class Random(Expression):
754     output_field = fields.FloatField()
755 
756     def __repr__(self):
757         return "Random()"
758 
759     def as_sql(self, compiler, connection):
760         return connection.ops.random_function_sql(), []
761 
762 
763 class Col(Expression):
764 
765     contains_column_references = True
766     possibly_multivalued = False
767 
768     def __init__(self, alias, target, output_field=None):
769         if output_field is None:
770             output_field = target
771         super().__init__(output_field=output_field)
772         self.alias, self.target = alias, target
773 
774     def __repr__(self):
775         alias, target = self.alias, self.target
776         identifiers = (alias, str(target)) if alias else (str(target),)
777         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
778 
779     def as_sql(self, compiler, connection):
780         alias, column = self.alias, self.target.column
781         identifiers = (alias, column) if alias else (column,)
782         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
783         return sql, []
784 
785     def relabeled_clone(self, relabels):
786         if self.alias is None:
787             return self
788         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
789 
790     def get_group_by_cols(self, alias=None):
791         return [self]
792 
793     def get_db_converters(self, connection):
794         if self.target == self.output_field:
795             return self.output_field.get_db_converters(connection)
796         return (self.output_field.get_db_converters(connection) +
797                 self.target.get_db_converters(connection))
798 
799 
800 class Ref(Expression):
801     """
802     Reference to column alias of the query. For example, Ref('sum_cost') in
803     qs.annotate(sum_cost=Sum('cost')) query.
804     """
805     def __init__(self, refs, source):
806         super().__init__()
807         self.refs, self.source = refs, source
808 
809     def __repr__(self):
810         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
811 
812     def get_source_expressions(self):
813         return [self.source]
814 
815     def set_source_expressions(self, exprs):
816         self.source, = exprs
817 
818     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
819         # The sub-expression `source` has already been resolved, as this is
820         # just a reference to the name of `source`.
821         return self
822 
823     def relabeled_clone(self, relabels):
824         return self
825 
826     def as_sql(self, compiler, connection):
827         return connection.ops.quote_name(self.refs), []
828 
829     def get_group_by_cols(self, alias=None):
830         return [self]
831 
832 
833 class ExpressionList(Func):
834     """
835     An expression containing multiple expressions. Can be used to provide a
836     list of expressions as an argument to another expression, like an
837     ordering clause.
838     """
839     template = '%(expressions)s'
840 
841     def __init__(self, *expressions, **extra):
842         if not expressions:
843             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
844         super().__init__(*expressions, **extra)
845 
846     def __str__(self):
847         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
848 
849 
850 class ExpressionWrapper(Expression):
851     """
852     An expression that can wrap another expression so that it can provide
853     extra context to the inner expression, such as the output_field.
854     """
855 
856     def __init__(self, expression, output_field):
857         super().__init__(output_field=output_field)
858         self.expression = expression
859 
860     def set_source_expressions(self, exprs):
861         self.expression = exprs[0]
862 
863     def get_source_expressions(self):
864         return [self.expression]
865 
866     def as_sql(self, compiler, connection):
867         return self.expression.as_sql(compiler, connection)
868 
869     def __repr__(self):
870         return "{}({})".format(self.__class__.__name__, self.expression)
871 
872 
873 class When(Expression):
874     template = 'WHEN %(condition)s THEN %(result)s'
875     # This isn't a complete conditional expression, must be used in Case().
876     conditional = False
877 
878     def __init__(self, condition=None, then=None, **lookups):
879         if lookups and condition is None:
880             condition, lookups = Q(**lookups), None
881         if condition is None or not getattr(condition, 'conditional', False) or lookups:
882             raise TypeError(
883                 'When() supports a Q object, a boolean expression, or lookups '
884                 'as a condition.'
885             )
886         if isinstance(condition, Q) and not condition:
887             raise ValueError("An empty Q() can't be used as a When() condition.")
888         super().__init__(output_field=None)
889         self.condition = condition
890         self.result = self._parse_expressions(then)[0]
891 
892     def __str__(self):
893         return "WHEN %r THEN %r" % (self.condition, self.result)
894 
895     def __repr__(self):
896         return "<%s: %s>" % (self.__class__.__name__, self)
897 
898     def get_source_expressions(self):
899         return [self.condition, self.result]
900 
901     def set_source_expressions(self, exprs):
902         self.condition, self.result = exprs
903 
904     def get_source_fields(self):
905         # We're only interested in the fields of the result expressions.
906         return [self.result._output_field_or_none]
907 
908     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
909         c = self.copy()
910         c.is_summary = summarize
911         if hasattr(c.condition, 'resolve_expression'):
912             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
913         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
914         return c
915 
916     def as_sql(self, compiler, connection, template=None, **extra_context):
917         connection.ops.check_expression_support(self)
918         template_params = extra_context
919         sql_params = []
920         condition_sql, condition_params = compiler.compile(self.condition)
921         template_params['condition'] = condition_sql
922         sql_params.extend(condition_params)
923         result_sql, result_params = compiler.compile(self.result)
924         template_params['result'] = result_sql
925         sql_params.extend(result_params)
926         template = template or self.template
927         return template % template_params, sql_params
928 
929     def get_group_by_cols(self, alias=None):
930         # This is not a complete expression and cannot be used in GROUP BY.
931         cols = []
932         for source in self.get_source_expressions():
933             cols.extend(source.get_group_by_cols())
934         return cols
935 
936 
937 class Case(Expression):
938     """
939     An SQL searched CASE expression:
940 
941         CASE
942             WHEN n > 0
943                 THEN 'positive'
944             WHEN n < 0
945                 THEN 'negative'
946             ELSE 'zero'
947         END
948     """
949     template = 'CASE %(cases)s ELSE %(default)s END'
950     case_joiner = ' '
951 
952     def __init__(self, *cases, default=None, output_field=None, **extra):
953         if not all(isinstance(case, When) for case in cases):
954             raise TypeError("Positional arguments must all be When objects.")
955         super().__init__(output_field)
956         self.cases = list(cases)
957         self.default = self._parse_expressions(default)[0]
958         self.extra = extra
959 
960     def __str__(self):
961         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
962 
963     def __repr__(self):
964         return "<%s: %s>" % (self.__class__.__name__, self)
965 
966     def get_source_expressions(self):
967         return self.cases + [self.default]
968 
969     def set_source_expressions(self, exprs):
970         *self.cases, self.default = exprs
971 
972     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
973         c = self.copy()
974         c.is_summary = summarize
975         for pos, case in enumerate(c.cases):
976             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
977         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
978         return c
979 
980     def copy(self):
981         c = super().copy()
982         c.cases = c.cases[:]
983         return c
984 
985     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
986         connection.ops.check_expression_support(self)
987         if not self.cases:
988             return compiler.compile(self.default)
989         template_params = {**self.extra, **extra_context}
990         case_parts = []
991         sql_params = []
992         for case in self.cases:
993             try:
994                 case_sql, case_params = compiler.compile(case)
995             except EmptyResultSet:
996                 continue
997             case_parts.append(case_sql)
998             sql_params.extend(case_params)
999         default_sql, default_params = compiler.compile(self.default)
1000         if not case_parts:
1001             return default_sql, default_params
1002         case_joiner = case_joiner or self.case_joiner
1003         template_params['cases'] = case_joiner.join(case_parts)
1004         template_params['default'] = default_sql
1005         sql_params.extend(default_params)
1006         template = template or template_params.get('template', self.template)
1007         sql = template % template_params
1008         if self._output_field_or_none is not None:
1009             sql = connection.ops.unification_cast_sql(self.output_field) % sql
1010         return sql, sql_params
1011 
1012 
1013 class Subquery(Expression):
1014     """
1015     An explicit subquery. It may contain OuterRef() references to the outer
1016     query which will be resolved when it is applied to that query.
1017     """
1018     template = '(%(subquery)s)'
1019     contains_aggregate = False
1020 
1021     def __init__(self, queryset, output_field=None, **extra):
1022         self.query = queryset.query
1023         self.extra = extra
1024         # Prevent the QuerySet from being evaluated.
1025         self.queryset = queryset._chain(_result_cache=[], prefetch_done=True)
1026         super().__init__(output_field)
1027 
1028     def __getstate__(self):
1029         state = super().__getstate__()
1030         args, kwargs = state['_constructor_args']
1031         if args:
1032             args = (self.queryset, *args[1:])
1033         else:
1034             kwargs['queryset'] = self.queryset
1035         state['_constructor_args'] = args, kwargs
1036         return state
1037 
1038     def get_source_expressions(self):
1039         return [self.query]
1040 
1041     def set_source_expressions(self, exprs):
1042         self.query = exprs[0]
1043 
1044     def _resolve_output_field(self):
1045         return self.query.output_field
1046 
1047     def copy(self):
1048         clone = super().copy()
1049         clone.query = clone.query.clone()
1050         return clone
1051 
1052     @property
1053     def external_aliases(self):
1054         return self.query.external_aliases
1055 
1056     def as_sql(self, compiler, connection, template=None, **extra_context):
1057         connection.ops.check_expression_support(self)
1058         template_params = {**self.extra, **extra_context}
1059         subquery_sql, sql_params = self.query.as_sql(compiler, connection)
1060         template_params['subquery'] = subquery_sql[1:-1]
1061 
1062         template = template or template_params.get('template', self.template)
1063         sql = template % template_params
1064         return sql, sql_params
1065 
1066     def get_group_by_cols(self, alias=None):
1067         if alias:
1068             return [Ref(alias, self)]
1069         external_cols = self.query.get_external_cols()
1070         if any(col.possibly_multivalued for col in external_cols):
1071             return [self]
1072         return external_cols
1073 
1074 
1075 class Exists(Subquery):
1076     template = 'EXISTS(%(subquery)s)'
1077     output_field = fields.BooleanField()
1078 
1079     def __init__(self, queryset, negated=False, **kwargs):
1080         # As a performance optimization, remove ordering since EXISTS doesn't
1081         # care about it, just whether or not a row matches.
1082         queryset = queryset.order_by()
1083         self.negated = negated
1084         super().__init__(queryset, **kwargs)
1085 
1086     def __invert__(self):
1087         clone = self.copy()
1088         clone.negated = not self.negated
1089         return clone
1090 
1091     def as_sql(self, compiler, connection, template=None, **extra_context):
1092         sql, params = super().as_sql(compiler, connection, template, **extra_context)
1093         if self.negated:
1094             sql = 'NOT {}'.format(sql)
1095         return sql, params
1096 
1097     def select_format(self, compiler, sql, params):
1098         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1099         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP
1100         # BY list.
1101         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1102             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1103         return sql, params
1104 
1105 
1106 class OrderBy(BaseExpression):
1107     template = '%(expression)s %(ordering)s'
1108     conditional = False
1109 
1110     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1111         if nulls_first and nulls_last:
1112             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1113         self.nulls_first = nulls_first
1114         self.nulls_last = nulls_last
1115         self.descending = descending
1116         if not hasattr(expression, 'resolve_expression'):
1117             raise ValueError('expression must be an expression type')
1118         self.expression = expression
1119 
1120     def __repr__(self):
1121         return "{}({}, descending={})".format(
1122             self.__class__.__name__, self.expression, self.descending)
1123 
1124     def set_source_expressions(self, exprs):
1125         self.expression = exprs[0]
1126 
1127     def get_source_expressions(self):
1128         return [self.expression]
1129 
1130     def as_sql(self, compiler, connection, template=None, **extra_context):
1131         template = template or self.template
1132         if connection.features.supports_order_by_nulls_modifier:
1133             if self.nulls_last:
1134                 template = '%s NULLS LAST' % template
1135             elif self.nulls_first:
1136                 template = '%s NULLS FIRST' % template
1137         else:
1138             if self.nulls_last and not (
1139                 self.descending and connection.features.order_by_nulls_first
1140             ):
1141                 template = '%%(expression)s IS NULL, %s' % template
1142             elif self.nulls_first and not (
1143                 not self.descending and connection.features.order_by_nulls_first
1144             ):
1145                 template = '%%(expression)s IS NOT NULL, %s' % template
1146         connection.ops.check_expression_support(self)
1147         expression_sql, params = compiler.compile(self.expression)
1148         placeholders = {
1149             'expression': expression_sql,
1150             'ordering': 'DESC' if self.descending else 'ASC',
1151             **extra_context,
1152         }
1153         template = template or self.template
1154         params *= template.count('%(expression)s')
1155         return (template % placeholders).rstrip(), params
1156 
1157     def as_oracle(self, compiler, connection):
1158         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in
1159         # a CASE WHEN.
1160         if isinstance(self.expression, Exists):
1161             copy = self.copy()
1162             copy.expression = Case(
1163                 When(self.expression, then=True),
1164                 default=False,
1165                 output_field=fields.BooleanField(),
1166             )
1167             return copy.as_sql(compiler, connection)
1168         return self.as_sql(compiler, connection)
1169 
1170     def get_group_by_cols(self, alias=None):
1171         cols = []
1172         for source in self.get_source_expressions():
1173             cols.extend(source.get_group_by_cols())
1174         return cols
1175 
1176     def reverse_ordering(self):
1177         self.descending = not self.descending
1178         if self.nulls_first or self.nulls_last:
1179             self.nulls_first = not self.nulls_first
1180             self.nulls_last = not self.nulls_last
1181         return self
1182 
1183     def asc(self):
1184         self.descending = False
1185 
1186     def desc(self):
1187         self.descending = True
1188 
1189 
1190 class Window(Expression):
1191     template = '%(expression)s OVER (%(window)s)'
1192     # Although the main expression may either be an aggregate or an
1193     # expression with an aggregate function, the GROUP BY that will
1194     # be introduced in the query as a result is not desired.
1195     contains_aggregate = False
1196     contains_over_clause = True
1197     filterable = False
1198 
1199     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1200         self.partition_by = partition_by
1201         self.order_by = order_by
1202         self.frame = frame
1203 
1204         if not getattr(expression, 'window_compatible', False):
1205             raise ValueError(
1206                 "Expression '%s' isn't compatible with OVER clauses." %
1207                 expression.__class__.__name__
1208             )
1209 
1210         if self.partition_by is not None:
1211             if not isinstance(self.partition_by, (tuple, list)):
1212                 self.partition_by = (self.partition_by,)
1213             self.partition_by = ExpressionList(*self.partition_by)
1214 
1215         if self.order_by is not None:
1216             if isinstance(self.order_by, (list, tuple)):
1217                 self.order_by = ExpressionList(*self.order_by)
1218             elif not isinstance(self.order_by, BaseExpression):
1219                 raise ValueError(
1220                     'order_by must be either an Expression or a sequence of '
1221                     'expressions.'
1222                 )
1223         super().__init__(output_field=output_field)
1224         self.source_expression = self._parse_expressions(expression)[0]
1225 
1226     def _resolve_output_field(self):
1227         return self.source_expression.output_field
1228 
1229     def get_source_expressions(self):
1230         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1231 
1232     def set_source_expressions(self, exprs):
1233         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1234 
1235     def as_sql(self, compiler, connection, template=None):
1236         connection.ops.check_expression_support(self)
1237         if not connection.features.supports_over_clause:
1238             raise NotSupportedError('This backend does not support window expressions.')
1239         expr_sql, params = compiler.compile(self.source_expression)
1240         window_sql, window_params = [], []
1241 
1242         if self.partition_by is not None:
1243             sql_expr, sql_params = self.partition_by.as_sql(
1244                 compiler=compiler, connection=connection,
1245                 template='PARTITION BY %(expressions)s',
1246             )
1247             window_sql.extend(sql_expr)
1248             window_params.extend(sql_params)
1249 
1250         if self.order_by is not None:
1251             window_sql.append(' ORDER BY ')
1252             order_sql, order_params = compiler.compile(self.order_by)
1253             window_sql.extend(order_sql)
1254             window_params.extend(order_params)
1255 
1256         if self.frame:
1257             frame_sql, frame_params = compiler.compile(self.frame)
1258             window_sql.append(' ' + frame_sql)
1259             window_params.extend(frame_params)
1260 
1261         params.extend(window_params)
1262         template = template or self.template
1263 
1264         return template % {
1265             'expression': expr_sql,
1266             'window': ''.join(window_sql).strip()
1267         }, params
1268 
1269     def __str__(self):
1270         return '{} OVER ({}{}{})'.format(
1271             str(self.source_expression),
1272             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1273             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1274             str(self.frame or ''),
1275         )
1276 
1277     def __repr__(self):
1278         return '<%s: %s>' % (self.__class__.__name__, self)
1279 
1280     def get_group_by_cols(self, alias=None):
1281         return []
1282 
1283 
1284 class WindowFrame(Expression):
1285     """
1286     Model the frame clause in window expressions. There are two types of frame
1287     clauses which are subclasses, however, all processing and validation (by no
1288     means intended to be complete) is done here. Thus, providing an end for a
1289     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1290     row in the frame).
1291     """
1292     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1293 
1294     def __init__(self, start=None, end=None):
1295         self.start = Value(start)
1296         self.end = Value(end)
1297 
1298     def set_source_expressions(self, exprs):
1299         self.start, self.end = exprs
1300 
1301     def get_source_expressions(self):
1302         return [self.start, self.end]
1303 
1304     def as_sql(self, compiler, connection):
1305         connection.ops.check_expression_support(self)
1306         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1307         return self.template % {
1308             'frame_type': self.frame_type,
1309             'start': start,
1310             'end': end,
1311         }, []
1312 
1313     def __repr__(self):
1314         return '<%s: %s>' % (self.__class__.__name__, self)
1315 
1316     def get_group_by_cols(self, alias=None):
1317         return []
1318 
1319     def __str__(self):
1320         if self.start.value is not None and self.start.value < 0:
1321             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1322         elif self.start.value is not None and self.start.value == 0:
1323             start = connection.ops.CURRENT_ROW
1324         else:
1325             start = connection.ops.UNBOUNDED_PRECEDING
1326 
1327         if self.end.value is not None and self.end.value > 0:
1328             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1329         elif self.end.value is not None and self.end.value == 0:
1330             end = connection.ops.CURRENT_ROW
1331         else:
1332             end = connection.ops.UNBOUNDED_FOLLOWING
1333         return self.template % {
1334             'frame_type': self.frame_type,
1335             'start': start,
1336             'end': end,
1337         }
1338 
1339     def window_frame_start_end(self, connection, start, end):
1340         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1341 
1342 
1343 class RowRange(WindowFrame):
1344     frame_type = 'ROWS'
1345 
1346     def window_frame_start_end(self, connection, start, end):
1347         return connection.ops.window_frame_rows_start_end(start, end)
1348 
1349 
1350 class ValueRange(WindowFrame):
1351     frame_type = 'RANGE'
1352 
1353     def window_frame_start_end(self, connection, start, end):
1354         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>Modify the `When` method to automatically recognize and correctly handle `Exists` expressions as valid arguments without requiring them to be wrapped in a `Q` object. This could involve adjusting the method's argument parsing to treat `Exists` similarly to how `filter` expressions are treated, ensuring that `Exists` can be passed directly as a condition. This change must not disrupt the existing functionality, which allows `Q` objects, boolean expressions, and lookups as conditions.</intended_behavior>]
2025-10-18 11:40:59.073 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 11:40:59.073 | INFO     | Search-only: skipping patch selection
2025-10-18 11:40:59.306 | INFO     | Task django__django-12951 completed successfully.
2025-10-18 11:40:59.306 | INFO     | No patch generated. You can try running ACR again.
