[
    {
        "rel_file_path": "django/db/models/expressions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/expressions.py",
        "start": 1,
        "end": 1354,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 import datetime\n3 import inspect\n4 from decimal import Decimal\n5 \n6 from django.core.exceptions import EmptyResultSet, FieldError\n7 from django.db import NotSupportedError, connection\n8 from django.db.models import fields\n9 from django.db.models.constants import LOOKUP_SEP\n10 from django.db.models.query_utils import Q\n11 from django.utils.deconstruct import deconstructible\n12 from django.utils.functional import cached_property\n13 from django.utils.hashable import make_hashable\n14 \n15 \n16 class SQLiteNumericMixin:\n17     \"\"\"\n18     Some expressions with output_field=DecimalField() must be cast to\n19     numeric to be properly filtered.\n20     \"\"\"\n21     def as_sqlite(self, compiler, connection, **extra_context):\n22         sql, params = self.as_sql(compiler, connection, **extra_context)\n23         try:\n24             if self.output_field.get_internal_type() == 'DecimalField':\n25                 sql = 'CAST(%s AS NUMERIC)' % sql\n26         except FieldError:\n27             pass\n28         return sql, params\n29 \n30 \n31 class Combinable:\n32     \"\"\"\n33     Provide the ability to combine one or two objects with\n34     some connector. For example F('foo') + F('bar').\n35     \"\"\"\n36 \n37     # Arithmetic connectors\n38     ADD = '+'\n39     SUB = '-'\n40     MUL = '*'\n41     DIV = '/'\n42     POW = '^'\n43     # The following is a quoted % operator - it is quoted because it can be\n44     # used in strings that also have parameter substitution.\n45     MOD = '%%'\n46 \n47     # Bitwise operators - note that these are generated by .bitand()\n48     # and .bitor(), the '&' and '|' are reserved for boolean operator\n49     # usage.\n50     BITAND = '&'\n51     BITOR = '|'\n52     BITLEFTSHIFT = '<<'\n53     BITRIGHTSHIFT = '>>'\n54     BITXOR = '#'\n55 \n56     def _combine(self, other, connector, reversed):\n57         if not hasattr(other, 'resolve_expression'):\n58             # everything must be resolvable to an expression\n59             if isinstance(other, datetime.timedelta):\n60                 other = DurationValue(other, output_field=fields.DurationField())\n61             else:\n62                 other = Value(other)\n63 \n64         if reversed:\n65             return CombinedExpression(other, connector, self)\n66         return CombinedExpression(self, connector, other)\n67 \n68     #############\n69     # OPERATORS #\n70     #############\n71 \n72     def __neg__(self):\n73         return self._combine(-1, self.MUL, False)\n74 \n75     def __add__(self, other):\n76         return self._combine(other, self.ADD, False)\n77 \n78     def __sub__(self, other):\n79         return self._combine(other, self.SUB, False)\n80 \n81     def __mul__(self, other):\n82         return self._combine(other, self.MUL, False)\n83 \n84     def __truediv__(self, other):\n85         return self._combine(other, self.DIV, False)\n86 \n87     def __mod__(self, other):\n88         return self._combine(other, self.MOD, False)\n89 \n90     def __pow__(self, other):\n91         return self._combine(other, self.POW, False)\n92 \n93     def __and__(self, other):\n94         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n95             return Q(self) & Q(other)\n96         raise NotImplementedError(\n97             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n98         )\n99 \n100     def bitand(self, other):\n101         return self._combine(other, self.BITAND, False)\n102 \n103     def bitleftshift(self, other):\n104         return self._combine(other, self.BITLEFTSHIFT, False)\n105 \n106     def bitrightshift(self, other):\n107         return self._combine(other, self.BITRIGHTSHIFT, False)\n108 \n109     def bitxor(self, other):\n110         return self._combine(other, self.BITXOR, False)\n111 \n112     def __or__(self, other):\n113         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n114             return Q(self) | Q(other)\n115         raise NotImplementedError(\n116             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n117         )\n118 \n119     def bitor(self, other):\n120         return self._combine(other, self.BITOR, False)\n121 \n122     def __radd__(self, other):\n123         return self._combine(other, self.ADD, True)\n124 \n125     def __rsub__(self, other):\n126         return self._combine(other, self.SUB, True)\n127 \n128     def __rmul__(self, other):\n129         return self._combine(other, self.MUL, True)\n130 \n131     def __rtruediv__(self, other):\n132         return self._combine(other, self.DIV, True)\n133 \n134     def __rmod__(self, other):\n135         return self._combine(other, self.MOD, True)\n136 \n137     def __rpow__(self, other):\n138         return self._combine(other, self.POW, True)\n139 \n140     def __rand__(self, other):\n141         raise NotImplementedError(\n142             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n143         )\n144 \n145     def __ror__(self, other):\n146         raise NotImplementedError(\n147             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n148         )\n149 \n150 \n151 @deconstructible\n152 class BaseExpression:\n153     \"\"\"Base class for all query expressions.\"\"\"\n154 \n155     # aggregate specific fields\n156     is_summary = False\n157     _output_field_resolved_to_none = False\n158     # Can the expression be used in a WHERE clause?\n159     filterable = True\n160     # Can the expression can be used as a source expression in Window?\n161     window_compatible = False\n162 \n163     def __init__(self, output_field=None):\n164         if output_field is not None:\n165             self.output_field = output_field\n166 \n167     def __getstate__(self):\n168         state = self.__dict__.copy()\n169         state.pop('convert_value', None)\n170         return state\n171 \n172     def get_db_converters(self, connection):\n173         return (\n174             []\n175             if self.convert_value is self._convert_value_noop else\n176             [self.convert_value]\n177         ) + self.output_field.get_db_converters(connection)\n178 \n179     def get_source_expressions(self):\n180         return []\n181 \n182     def set_source_expressions(self, exprs):\n183         assert not exprs\n184 \n185     def _parse_expressions(self, *expressions):\n186         return [\n187             arg if hasattr(arg, 'resolve_expression') else (\n188                 F(arg) if isinstance(arg, str) else Value(arg)\n189             ) for arg in expressions\n190         ]\n191 \n192     def as_sql(self, compiler, connection):\n193         \"\"\"\n194         Responsible for returning a (sql, [params]) tuple to be included\n195         in the current query.\n196 \n197         Different backends can provide their own implementation, by\n198         providing an `as_{vendor}` method and patching the Expression:\n199 \n200         ```\n201         def override_as_sql(self, compiler, connection):\n202             # custom logic\n203             return super().as_sql(compiler, connection)\n204         setattr(Expression, 'as_' + connection.vendor, override_as_sql)\n205         ```\n206 \n207         Arguments:\n208          * compiler: the query compiler responsible for generating the query.\n209            Must have a compile method, returning a (sql, [params]) tuple.\n210            Calling compiler(value) will return a quoted `value`.\n211 \n212          * connection: the database connection used for the current query.\n213 \n214         Return: (sql, params)\n215           Where `sql` is a string containing ordered sql parameters to be\n216           replaced with the elements of the list `params`.\n217         \"\"\"\n218         raise NotImplementedError(\"Subclasses must implement as_sql()\")\n219 \n220     @cached_property\n221     def contains_aggregate(self):\n222         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())\n223 \n224     @cached_property\n225     def contains_over_clause(self):\n226         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())\n227 \n228     @cached_property\n229     def contains_column_references(self):\n230         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())\n231 \n232     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n233         \"\"\"\n234         Provide the chance to do any preprocessing or validation before being\n235         added to the query.\n236 \n237         Arguments:\n238          * query: the backend query implementation\n239          * allow_joins: boolean allowing or denying use of joins\n240            in this query\n241          * reuse: a set of reusable joins for multijoins\n242          * summarize: a terminal aggregate clause\n243          * for_save: whether this expression about to be used in a save or update\n244 \n245         Return: an Expression to be added to the query.\n246         \"\"\"\n247         c = self.copy()\n248         c.is_summary = summarize\n249         c.set_source_expressions([\n250             expr.resolve_expression(query, allow_joins, reuse, summarize)\n251             if expr else None\n252             for expr in c.get_source_expressions()\n253         ])\n254         return c\n255 \n256     @property\n257     def conditional(self):\n258         return isinstance(self.output_field, fields.BooleanField)\n259 \n260     @property\n261     def field(self):\n262         return self.output_field\n263 \n264     @cached_property\n265     def output_field(self):\n266         \"\"\"Return the output type of this expressions.\"\"\"\n267         output_field = self._resolve_output_field()\n268         if output_field is None:\n269             self._output_field_resolved_to_none = True\n270             raise FieldError('Cannot resolve expression type, unknown output_field')\n271         return output_field\n272 \n273     @cached_property\n274     def _output_field_or_none(self):\n275         \"\"\"\n276         Return the output field of this expression, or None if\n277         _resolve_output_field() didn't return an output type.\n278         \"\"\"\n279         try:\n280             return self.output_field\n281         except FieldError:\n282             if not self._output_field_resolved_to_none:\n283                 raise\n284 \n285     def _resolve_output_field(self):\n286         \"\"\"\n287         Attempt to infer the output type of the expression. If the output\n288         fields of all source fields match then, simply infer the same type\n289         here. This isn't always correct, but it makes sense most of the time.\n290 \n291         Consider the difference between `2 + 2` and `2 / 3`. Inferring\n292         the type here is a convenience for the common case. The user should\n293         supply their own output_field with more complex computations.\n294 \n295         If a source's output field resolves to None, exclude it from this check.\n296         If all sources are None, then an error is raised higher up the stack in\n297         the output_field property.\n298         \"\"\"\n299         sources_iter = (source for source in self.get_source_fields() if source is not None)\n300         for output_field in sources_iter:\n301             for source in sources_iter:\n302                 if not isinstance(output_field, source.__class__):\n303                     raise FieldError(\n304                         'Expression contains mixed types: %s, %s. You must '\n305                         'set output_field.' % (\n306                             output_field.__class__.__name__,\n307                             source.__class__.__name__,\n308                         )\n309                     )\n310             return output_field\n311 \n312     @staticmethod\n313     def _convert_value_noop(value, expression, connection):\n314         return value\n315 \n316     @cached_property\n317     def convert_value(self):\n318         \"\"\"\n319         Expressions provide their own converters because users have the option\n320         of manually specifying the output_field which may be a different type\n321         from the one the database returns.\n322         \"\"\"\n323         field = self.output_field\n324         internal_type = field.get_internal_type()\n325         if internal_type == 'FloatField':\n326             return lambda value, expression, connection: None if value is None else float(value)\n327         elif internal_type.endswith('IntegerField'):\n328             return lambda value, expression, connection: None if value is None else int(value)\n329         elif internal_type == 'DecimalField':\n330             return lambda value, expression, connection: None if value is None else Decimal(value)\n331         return self._convert_value_noop\n332 \n333     def get_lookup(self, lookup):\n334         return self.output_field.get_lookup(lookup)\n335 \n336     def get_transform(self, name):\n337         return self.output_field.get_transform(name)\n338 \n339     def relabeled_clone(self, change_map):\n340         clone = self.copy()\n341         clone.set_source_expressions([\n342             e.relabeled_clone(change_map) if e is not None else None\n343             for e in self.get_source_expressions()\n344         ])\n345         return clone\n346 \n347     def copy(self):\n348         return copy.copy(self)\n349 \n350     def get_group_by_cols(self, alias=None):\n351         if not self.contains_aggregate:\n352             return [self]\n353         cols = []\n354         for source in self.get_source_expressions():\n355             cols.extend(source.get_group_by_cols())\n356         return cols\n357 \n358     def get_source_fields(self):\n359         \"\"\"Return the underlying field types used by this aggregate.\"\"\"\n360         return [e._output_field_or_none for e in self.get_source_expressions()]\n361 \n362     def asc(self, **kwargs):\n363         return OrderBy(self, **kwargs)\n364 \n365     def desc(self, **kwargs):\n366         return OrderBy(self, descending=True, **kwargs)\n367 \n368     def reverse_ordering(self):\n369         return self\n370 \n371     def flatten(self):\n372         \"\"\"\n373         Recursively yield this expression and all subexpressions, in\n374         depth-first order.\n375         \"\"\"\n376         yield self\n377         for expr in self.get_source_expressions():\n378             if expr:\n379                 yield from expr.flatten()\n380 \n381     def select_format(self, compiler, sql, params):\n382         \"\"\"\n383         Custom format for select clauses. For example, EXISTS expressions need\n384         to be wrapped in CASE WHEN on Oracle.\n385         \"\"\"\n386         return self.output_field.select_format(compiler, sql, params)\n387 \n388     @cached_property\n389     def identity(self):\n390         constructor_signature = inspect.signature(self.__init__)\n391         args, kwargs = self._constructor_args\n392         signature = constructor_signature.bind_partial(*args, **kwargs)\n393         signature.apply_defaults()\n394         arguments = signature.arguments.items()\n395         identity = [self.__class__]\n396         for arg, value in arguments:\n397             if isinstance(value, fields.Field):\n398                 if value.name and value.model:\n399                     value = (value.model._meta.label, value.name)\n400                 else:\n401                     value = type(value)\n402             else:\n403                 value = make_hashable(value)\n404             identity.append((arg, value))\n405         return tuple(identity)\n406 \n407     def __eq__(self, other):\n408         if not isinstance(other, BaseExpression):\n409             return NotImplemented\n410         return other.identity == self.identity\n411 \n412     def __hash__(self):\n413         return hash(self.identity)\n414 \n415 \n416 class Expression(BaseExpression, Combinable):\n417     \"\"\"An expression that can be combined with other expressions.\"\"\"\n418     pass\n419 \n420 \n421 class CombinedExpression(SQLiteNumericMixin, Expression):\n422 \n423     def __init__(self, lhs, connector, rhs, output_field=None):\n424         super().__init__(output_field=output_field)\n425         self.connector = connector\n426         self.lhs = lhs\n427         self.rhs = rhs\n428 \n429     def __repr__(self):\n430         return \"<{}: {}>\".format(self.__class__.__name__, self)\n431 \n432     def __str__(self):\n433         return \"{} {} {}\".format(self.lhs, self.connector, self.rhs)\n434 \n435     def get_source_expressions(self):\n436         return [self.lhs, self.rhs]\n437 \n438     def set_source_expressions(self, exprs):\n439         self.lhs, self.rhs = exprs\n440 \n441     def as_sql(self, compiler, connection):\n442         try:\n443             lhs_output = self.lhs.output_field\n444         except FieldError:\n445             lhs_output = None\n446         try:\n447             rhs_output = self.rhs.output_field\n448         except FieldError:\n449             rhs_output = None\n450         if (not connection.features.has_native_duration_field and\n451                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or\n452                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):\n453             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\n454         if (lhs_output and rhs_output and self.connector == self.SUB and\n455             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and\n456                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):\n457             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n458         expressions = []\n459         expression_params = []\n460         sql, params = compiler.compile(self.lhs)\n461         expressions.append(sql)\n462         expression_params.extend(params)\n463         sql, params = compiler.compile(self.rhs)\n464         expressions.append(sql)\n465         expression_params.extend(params)\n466         # order of precedence\n467         expression_wrapper = '(%s)'\n468         sql = connection.ops.combine_expression(self.connector, expressions)\n469         return expression_wrapper % sql, expression_params\n470 \n471     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n472         c = self.copy()\n473         c.is_summary = summarize\n474         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n475         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n476         return c\n477 \n478 \n479 class DurationExpression(CombinedExpression):\n480     def compile(self, side, compiler, connection):\n481         if not isinstance(side, DurationValue):\n482             try:\n483                 output = side.output_field\n484             except FieldError:\n485                 pass\n486             else:\n487                 if output.get_internal_type() == 'DurationField':\n488                     sql, params = compiler.compile(side)\n489                     return connection.ops.format_for_duration_arithmetic(sql), params\n490         return compiler.compile(side)\n491 \n492     def as_sql(self, compiler, connection):\n493         connection.ops.check_expression_support(self)\n494         expressions = []\n495         expression_params = []\n496         sql, params = self.compile(self.lhs, compiler, connection)\n497         expressions.append(sql)\n498         expression_params.extend(params)\n499         sql, params = self.compile(self.rhs, compiler, connection)\n500         expressions.append(sql)\n501         expression_params.extend(params)\n502         # order of precedence\n503         expression_wrapper = '(%s)'\n504         sql = connection.ops.combine_duration_expression(self.connector, expressions)\n505         return expression_wrapper % sql, expression_params\n506 \n507 \n508 class TemporalSubtraction(CombinedExpression):\n509     output_field = fields.DurationField()\n510 \n511     def __init__(self, lhs, rhs):\n512         super().__init__(lhs, self.SUB, rhs)\n513 \n514     def as_sql(self, compiler, connection):\n515         connection.ops.check_expression_support(self)\n516         lhs = compiler.compile(self.lhs)\n517         rhs = compiler.compile(self.rhs)\n518         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)\n519 \n520 \n521 @deconstructible\n522 class F(Combinable):\n523     \"\"\"An object capable of resolving references to existing query objects.\"\"\"\n524 \n525     def __init__(self, name):\n526         \"\"\"\n527         Arguments:\n528          * name: the name of the field this expression references\n529         \"\"\"\n530         self.name = name\n531 \n532     def __repr__(self):\n533         return \"{}({})\".format(self.__class__.__name__, self.name)\n534 \n535     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n536                            summarize=False, for_save=False):\n537         return query.resolve_ref(self.name, allow_joins, reuse, summarize)\n538 \n539     def asc(self, **kwargs):\n540         return OrderBy(self, **kwargs)\n541 \n542     def desc(self, **kwargs):\n543         return OrderBy(self, descending=True, **kwargs)\n544 \n545     def __eq__(self, other):\n546         return self.__class__ == other.__class__ and self.name == other.name\n547 \n548     def __hash__(self):\n549         return hash(self.name)\n550 \n551 \n552 class ResolvedOuterRef(F):\n553     \"\"\"\n554     An object that contains a reference to an outer query.\n555 \n556     In this case, the reference to the outer query has been resolved because\n557     the inner query has been used as a subquery.\n558     \"\"\"\n559     contains_aggregate = False\n560 \n561     def as_sql(self, *args, **kwargs):\n562         raise ValueError(\n563             'This queryset contains a reference to an outer query and may '\n564             'only be used in a subquery.'\n565         )\n566 \n567     def resolve_expression(self, *args, **kwargs):\n568         col = super().resolve_expression(*args, **kwargs)\n569         # FIXME: Rename possibly_multivalued to multivalued and fix detection\n570         # for non-multivalued JOINs (e.g. foreign key fields). This should take\n571         # into account\u00a0only many-to-many and one-to-many relationships.\n572         col.possibly_multivalued = LOOKUP_SEP in self.name\n573         return col\n574 \n575     def relabeled_clone(self, relabels):\n576         return self\n577 \n578     def get_group_by_cols(self, alias=None):\n579         return []\n580 \n581 \n582 class OuterRef(F):\n583     def resolve_expression(self, *args, **kwargs):\n584         if isinstance(self.name, self.__class__):\n585             return self.name\n586         return ResolvedOuterRef(self.name)\n587 \n588     def relabeled_clone(self, relabels):\n589         return self\n590 \n591 \n592 class Func(SQLiteNumericMixin, Expression):\n593     \"\"\"An SQL function call.\"\"\"\n594     function = None\n595     template = '%(function)s(%(expressions)s)'\n596     arg_joiner = ', '\n597     arity = None  # The number of arguments the function accepts.\n598 \n599     def __init__(self, *expressions, output_field=None, **extra):\n600         if self.arity is not None and len(expressions) != self.arity:\n601             raise TypeError(\n602                 \"'%s' takes exactly %s %s (%s given)\" % (\n603                     self.__class__.__name__,\n604                     self.arity,\n605                     \"argument\" if self.arity == 1 else \"arguments\",\n606                     len(expressions),\n607                 )\n608             )\n609         super().__init__(output_field=output_field)\n610         self.source_expressions = self._parse_expressions(*expressions)\n611         self.extra = extra\n612 \n613     def __repr__(self):\n614         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n615         extra = {**self.extra, **self._get_repr_options()}\n616         if extra:\n617             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))\n618             return \"{}({}, {})\".format(self.__class__.__name__, args, extra)\n619         return \"{}({})\".format(self.__class__.__name__, args)\n620 \n621     def _get_repr_options(self):\n622         \"\"\"Return a dict of extra __init__() options to include in the repr.\"\"\"\n623         return {}\n624 \n625     def get_source_expressions(self):\n626         return self.source_expressions\n627 \n628     def set_source_expressions(self, exprs):\n629         self.source_expressions = exprs\n630 \n631     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n632         c = self.copy()\n633         c.is_summary = summarize\n634         for pos, arg in enumerate(c.source_expressions):\n635             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n636         return c\n637 \n638     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):\n639         connection.ops.check_expression_support(self)\n640         sql_parts = []\n641         params = []\n642         for arg in self.source_expressions:\n643             arg_sql, arg_params = compiler.compile(arg)\n644             sql_parts.append(arg_sql)\n645             params.extend(arg_params)\n646         data = {**self.extra, **extra_context}\n647         # Use the first supplied value in this order: the parameter to this\n648         # method, a value supplied in __init__()'s **extra (the value in\n649         # `data`), or the value defined on the class.\n650         if function is not None:\n651             data['function'] = function\n652         else:\n653             data.setdefault('function', self.function)\n654         template = template or data.get('template', self.template)\n655         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)\n656         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)\n657         return template % data, params\n658 \n659     def copy(self):\n660         copy = super().copy()\n661         copy.source_expressions = self.source_expressions[:]\n662         copy.extra = self.extra.copy()\n663         return copy\n664 \n665 \n666 class Value(Expression):\n667     \"\"\"Represent a wrapped value as a node within an expression.\"\"\"\n668     def __init__(self, value, output_field=None):\n669         \"\"\"\n670         Arguments:\n671          * value: the value this expression represents. The value will be\n672            added into the sql parameter list and properly quoted.\n673 \n674          * output_field: an instance of the model field type that this\n675            expression will return, such as IntegerField() or CharField().\n676         \"\"\"\n677         super().__init__(output_field=output_field)\n678         self.value = value\n679 \n680     def __repr__(self):\n681         return \"{}({})\".format(self.__class__.__name__, self.value)\n682 \n683     def as_sql(self, compiler, connection):\n684         connection.ops.check_expression_support(self)\n685         val = self.value\n686         output_field = self._output_field_or_none\n687         if output_field is not None:\n688             if self.for_save:\n689                 val = output_field.get_db_prep_save(val, connection=connection)\n690             else:\n691                 val = output_field.get_db_prep_value(val, connection=connection)\n692             if hasattr(output_field, 'get_placeholder'):\n693                 return output_field.get_placeholder(val, compiler, connection), [val]\n694         if val is None:\n695             # cx_Oracle does not always convert None to the appropriate\n696             # NULL type (like in case expressions using numbers), so we\n697             # use a literal SQL NULL\n698             return 'NULL', []\n699         return '%s', [val]\n700 \n701     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n702         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n703         c.for_save = for_save\n704         return c\n705 \n706     def get_group_by_cols(self, alias=None):\n707         return []\n708 \n709 \n710 class DurationValue(Value):\n711     def as_sql(self, compiler, connection):\n712         connection.ops.check_expression_support(self)\n713         if connection.features.has_native_duration_field:\n714             return super().as_sql(compiler, connection)\n715         return connection.ops.date_interval_sql(self.value), []\n716 \n717 \n718 class RawSQL(Expression):\n719     def __init__(self, sql, params, output_field=None):\n720         if output_field is None:\n721             output_field = fields.Field()\n722         self.sql, self.params = sql, params\n723         super().__init__(output_field=output_field)\n724 \n725     def __repr__(self):\n726         return \"{}({}, {})\".format(self.__class__.__name__, self.sql, self.params)\n727 \n728     def as_sql(self, compiler, connection):\n729         return '(%s)' % self.sql, self.params\n730 \n731     def get_group_by_cols(self, alias=None):\n732         return [self]\n733 \n734     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n735         # Resolve parents fields used in raw SQL.\n736         for parent in query.model._meta.get_parent_list():\n737             for parent_field in parent._meta.local_fields:\n738                 _, column_name = parent_field.get_attname_column()\n739                 if column_name.lower() in self.sql.lower():\n740                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)\n741                     break\n742         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n743 \n744 \n745 class Star(Expression):\n746     def __repr__(self):\n747         return \"'*'\"\n748 \n749     def as_sql(self, compiler, connection):\n750         return '*', []\n751 \n752 \n753 class Random(Expression):\n754     output_field = fields.FloatField()\n755 \n756     def __repr__(self):\n757         return \"Random()\"\n758 \n759     def as_sql(self, compiler, connection):\n760         return connection.ops.random_function_sql(), []\n761 \n762 \n763 class Col(Expression):\n764 \n765     contains_column_references = True\n766     possibly_multivalued = False\n767 \n768     def __init__(self, alias, target, output_field=None):\n769         if output_field is None:\n770             output_field = target\n771         super().__init__(output_field=output_field)\n772         self.alias, self.target = alias, target\n773 \n774     def __repr__(self):\n775         alias, target = self.alias, self.target\n776         identifiers = (alias, str(target)) if alias else (str(target),)\n777         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))\n778 \n779     def as_sql(self, compiler, connection):\n780         alias, column = self.alias, self.target.column\n781         identifiers = (alias, column) if alias else (column,)\n782         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n783         return sql, []\n784 \n785     def relabeled_clone(self, relabels):\n786         if self.alias is None:\n787             return self\n788         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)\n789 \n790     def get_group_by_cols(self, alias=None):\n791         return [self]\n792 \n793     def get_db_converters(self, connection):\n794         if self.target == self.output_field:\n795             return self.output_field.get_db_converters(connection)\n796         return (self.output_field.get_db_converters(connection) +\n797                 self.target.get_db_converters(connection))\n798 \n799 \n800 class Ref(Expression):\n801     \"\"\"\n802     Reference to column alias of the query. For example, Ref('sum_cost') in\n803     qs.annotate(sum_cost=Sum('cost')) query.\n804     \"\"\"\n805     def __init__(self, refs, source):\n806         super().__init__()\n807         self.refs, self.source = refs, source\n808 \n809     def __repr__(self):\n810         return \"{}({}, {})\".format(self.__class__.__name__, self.refs, self.source)\n811 \n812     def get_source_expressions(self):\n813         return [self.source]\n814 \n815     def set_source_expressions(self, exprs):\n816         self.source, = exprs\n817 \n818     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n819         # The sub-expression `source` has already been resolved, as this is\n820         # just a reference to the name of `source`.\n821         return self\n822 \n823     def relabeled_clone(self, relabels):\n824         return self\n825 \n826     def as_sql(self, compiler, connection):\n827         return connection.ops.quote_name(self.refs), []\n828 \n829     def get_group_by_cols(self, alias=None):\n830         return [self]\n831 \n832 \n833 class ExpressionList(Func):\n834     \"\"\"\n835     An expression containing multiple expressions. Can be used to provide a\n836     list of expressions as an argument to another expression, like an\n837     ordering clause.\n838     \"\"\"\n839     template = '%(expressions)s'\n840 \n841     def __init__(self, *expressions, **extra):\n842         if not expressions:\n843             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)\n844         super().__init__(*expressions, **extra)\n845 \n846     def __str__(self):\n847         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n848 \n849 \n850 class ExpressionWrapper(Expression):\n851     \"\"\"\n852     An expression that can wrap another expression so that it can provide\n853     extra context to the inner expression, such as the output_field.\n854     \"\"\"\n855 \n856     def __init__(self, expression, output_field):\n857         super().__init__(output_field=output_field)\n858         self.expression = expression\n859 \n860     def set_source_expressions(self, exprs):\n861         self.expression = exprs[0]\n862 \n863     def get_source_expressions(self):\n864         return [self.expression]\n865 \n866     def as_sql(self, compiler, connection):\n867         return self.expression.as_sql(compiler, connection)\n868 \n869     def __repr__(self):\n870         return \"{}({})\".format(self.__class__.__name__, self.expression)\n871 \n872 \n873 class When(Expression):\n874     template = 'WHEN %(condition)s THEN %(result)s'\n875     # This isn't a complete conditional expression, must be used in Case().\n876     conditional = False\n877 \n878     def __init__(self, condition=None, then=None, **lookups):\n879         if lookups and condition is None:\n880             condition, lookups = Q(**lookups), None\n881         if condition is None or not getattr(condition, 'conditional', False) or lookups:\n882             raise TypeError(\n883                 'When() supports a Q object, a boolean expression, or lookups '\n884                 'as a condition.'\n885             )\n886         if isinstance(condition, Q) and not condition:\n887             raise ValueError(\"An empty Q() can't be used as a When() condition.\")\n888         super().__init__(output_field=None)\n889         self.condition = condition\n890         self.result = self._parse_expressions(then)[0]\n891 \n892     def __str__(self):\n893         return \"WHEN %r THEN %r\" % (self.condition, self.result)\n894 \n895     def __repr__(self):\n896         return \"<%s: %s>\" % (self.__class__.__name__, self)\n897 \n898     def get_source_expressions(self):\n899         return [self.condition, self.result]\n900 \n901     def set_source_expressions(self, exprs):\n902         self.condition, self.result = exprs\n903 \n904     def get_source_fields(self):\n905         # We're only interested in the fields of the result expressions.\n906         return [self.result._output_field_or_none]\n907 \n908     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n909         c = self.copy()\n910         c.is_summary = summarize\n911         if hasattr(c.condition, 'resolve_expression'):\n912             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)\n913         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n914         return c\n915 \n916     def as_sql(self, compiler, connection, template=None, **extra_context):\n917         connection.ops.check_expression_support(self)\n918         template_params = extra_context\n919         sql_params = []\n920         condition_sql, condition_params = compiler.compile(self.condition)\n921         template_params['condition'] = condition_sql\n922         sql_params.extend(condition_params)\n923         result_sql, result_params = compiler.compile(self.result)\n924         template_params['result'] = result_sql\n925         sql_params.extend(result_params)\n926         template = template or self.template\n927         return template % template_params, sql_params\n928 \n929     def get_group_by_cols(self, alias=None):\n930         # This is not a complete expression and cannot be used in GROUP BY.\n931         cols = []\n932         for source in self.get_source_expressions():\n933             cols.extend(source.get_group_by_cols())\n934         return cols\n935 \n936 \n937 class Case(Expression):\n938     \"\"\"\n939     An SQL searched CASE expression:\n940 \n941         CASE\n942             WHEN n > 0\n943                 THEN 'positive'\n944             WHEN n < 0\n945                 THEN 'negative'\n946             ELSE 'zero'\n947         END\n948     \"\"\"\n949     template = 'CASE %(cases)s ELSE %(default)s END'\n950     case_joiner = ' '\n951 \n952     def __init__(self, *cases, default=None, output_field=None, **extra):\n953         if not all(isinstance(case, When) for case in cases):\n954             raise TypeError(\"Positional arguments must all be When objects.\")\n955         super().__init__(output_field)\n956         self.cases = list(cases)\n957         self.default = self._parse_expressions(default)[0]\n958         self.extra = extra\n959 \n960     def __str__(self):\n961         return \"CASE %s, ELSE %r\" % (', '.join(str(c) for c in self.cases), self.default)\n962 \n963     def __repr__(self):\n964         return \"<%s: %s>\" % (self.__class__.__name__, self)\n965 \n966     def get_source_expressions(self):\n967         return self.cases + [self.default]\n968 \n969     def set_source_expressions(self, exprs):\n970         *self.cases, self.default = exprs\n971 \n972     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n973         c = self.copy()\n974         c.is_summary = summarize\n975         for pos, case in enumerate(c.cases):\n976             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n977         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n978         return c\n979 \n980     def copy(self):\n981         c = super().copy()\n982         c.cases = c.cases[:]\n983         return c\n984 \n985     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n986         connection.ops.check_expression_support(self)\n987         if not self.cases:\n988             return compiler.compile(self.default)\n989         template_params = {**self.extra, **extra_context}\n990         case_parts = []\n991         sql_params = []\n992         for case in self.cases:\n993             try:\n994                 case_sql, case_params = compiler.compile(case)\n995             except EmptyResultSet:\n996                 continue\n997             case_parts.append(case_sql)\n998             sql_params.extend(case_params)\n999         default_sql, default_params = compiler.compile(self.default)\n1000         if not case_parts:\n1001             return default_sql, default_params\n1002         case_joiner = case_joiner or self.case_joiner\n1003         template_params['cases'] = case_joiner.join(case_parts)\n1004         template_params['default'] = default_sql\n1005         sql_params.extend(default_params)\n1006         template = template or template_params.get('template', self.template)\n1007         sql = template % template_params\n1008         if self._output_field_or_none is not None:\n1009             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n1010         return sql, sql_params\n1011 \n1012 \n1013 class Subquery(Expression):\n1014     \"\"\"\n1015     An explicit subquery. It may contain OuterRef() references to the outer\n1016     query which will be resolved when it is applied to that query.\n1017     \"\"\"\n1018     template = '(%(subquery)s)'\n1019     contains_aggregate = False\n1020 \n1021     def __init__(self, queryset, output_field=None, **extra):\n1022         self.query = queryset.query\n1023         self.extra = extra\n1024         # Prevent the QuerySet from being evaluated.\n1025         self.queryset = queryset._chain(_result_cache=[], prefetch_done=True)\n1026         super().__init__(output_field)\n1027 \n1028     def __getstate__(self):\n1029         state = super().__getstate__()\n1030         args, kwargs = state['_constructor_args']\n1031         if args:\n1032             args = (self.queryset, *args[1:])\n1033         else:\n1034             kwargs['queryset'] = self.queryset\n1035         state['_constructor_args'] = args, kwargs\n1036         return state\n1037 \n1038     def get_source_expressions(self):\n1039         return [self.query]\n1040 \n1041     def set_source_expressions(self, exprs):\n1042         self.query = exprs[0]\n1043 \n1044     def _resolve_output_field(self):\n1045         return self.query.output_field\n1046 \n1047     def copy(self):\n1048         clone = super().copy()\n1049         clone.query = clone.query.clone()\n1050         return clone\n1051 \n1052     @property\n1053     def external_aliases(self):\n1054         return self.query.external_aliases\n1055 \n1056     def as_sql(self, compiler, connection, template=None, **extra_context):\n1057         connection.ops.check_expression_support(self)\n1058         template_params = {**self.extra, **extra_context}\n1059         subquery_sql, sql_params = self.query.as_sql(compiler, connection)\n1060         template_params['subquery'] = subquery_sql[1:-1]\n1061 \n1062         template = template or template_params.get('template', self.template)\n1063         sql = template % template_params\n1064         return sql, sql_params\n1065 \n1066     def get_group_by_cols(self, alias=None):\n1067         if alias:\n1068             return [Ref(alias, self)]\n1069         external_cols = self.query.get_external_cols()\n1070         if any(col.possibly_multivalued for col in external_cols):\n1071             return [self]\n1072         return external_cols\n1073 \n1074 \n1075 class Exists(Subquery):\n1076     template = 'EXISTS(%(subquery)s)'\n1077     output_field = fields.BooleanField()\n1078 \n1079     def __init__(self, queryset, negated=False, **kwargs):\n1080         # As a performance optimization, remove ordering since EXISTS doesn't\n1081         # care about it, just whether or not a row matches.\n1082         queryset = queryset.order_by()\n1083         self.negated = negated\n1084         super().__init__(queryset, **kwargs)\n1085 \n1086     def __invert__(self):\n1087         clone = self.copy()\n1088         clone.negated = not self.negated\n1089         return clone\n1090 \n1091     def as_sql(self, compiler, connection, template=None, **extra_context):\n1092         sql, params = super().as_sql(compiler, connection, template, **extra_context)\n1093         if self.negated:\n1094             sql = 'NOT {}'.format(sql)\n1095         return sql, params\n1096 \n1097     def select_format(self, compiler, sql, params):\n1098         # Wrap EXISTS() with a CASE WHEN expression if a database backend\n1099         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP\n1100         # BY list.\n1101         if not compiler.connection.features.supports_boolean_expr_in_select_clause:\n1102             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n1103         return sql, params\n1104 \n1105 \n1106 class OrderBy(BaseExpression):\n1107     template = '%(expression)s %(ordering)s'\n1108     conditional = False\n1109 \n1110     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):\n1111         if nulls_first and nulls_last:\n1112             raise ValueError('nulls_first and nulls_last are mutually exclusive')\n1113         self.nulls_first = nulls_first\n1114         self.nulls_last = nulls_last\n1115         self.descending = descending\n1116         if not hasattr(expression, 'resolve_expression'):\n1117             raise ValueError('expression must be an expression type')\n1118         self.expression = expression\n1119 \n1120     def __repr__(self):\n1121         return \"{}({}, descending={})\".format(\n1122             self.__class__.__name__, self.expression, self.descending)\n1123 \n1124     def set_source_expressions(self, exprs):\n1125         self.expression = exprs[0]\n1126 \n1127     def get_source_expressions(self):\n1128         return [self.expression]\n1129 \n1130     def as_sql(self, compiler, connection, template=None, **extra_context):\n1131         template = template or self.template\n1132         if connection.features.supports_order_by_nulls_modifier:\n1133             if self.nulls_last:\n1134                 template = '%s NULLS LAST' % template\n1135             elif self.nulls_first:\n1136                 template = '%s NULLS FIRST' % template\n1137         else:\n1138             if self.nulls_last and not (\n1139                 self.descending and connection.features.order_by_nulls_first\n1140             ):\n1141                 template = '%%(expression)s IS NULL, %s' % template\n1142             elif self.nulls_first and not (\n1143                 not self.descending and connection.features.order_by_nulls_first\n1144             ):\n1145                 template = '%%(expression)s IS NOT NULL, %s' % template\n1146         connection.ops.check_expression_support(self)\n1147         expression_sql, params = compiler.compile(self.expression)\n1148         placeholders = {\n1149             'expression': expression_sql,\n1150             'ordering': 'DESC' if self.descending else 'ASC',\n1151             **extra_context,\n1152         }\n1153         template = template or self.template\n1154         params *= template.count('%(expression)s')\n1155         return (template % placeholders).rstrip(), params\n1156 \n1157     def as_oracle(self, compiler, connection):\n1158         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in\n1159         # a CASE WHEN.\n1160         if isinstance(self.expression, Exists):\n1161             copy = self.copy()\n1162             copy.expression = Case(\n1163                 When(self.expression, then=True),\n1164                 default=False,\n1165                 output_field=fields.BooleanField(),\n1166             )\n1167             return copy.as_sql(compiler, connection)\n1168         return self.as_sql(compiler, connection)\n1169 \n1170     def get_group_by_cols(self, alias=None):\n1171         cols = []\n1172         for source in self.get_source_expressions():\n1173             cols.extend(source.get_group_by_cols())\n1174         return cols\n1175 \n1176     def reverse_ordering(self):\n1177         self.descending = not self.descending\n1178         if self.nulls_first or self.nulls_last:\n1179             self.nulls_first = not self.nulls_first\n1180             self.nulls_last = not self.nulls_last\n1181         return self\n1182 \n1183     def asc(self):\n1184         self.descending = False\n1185 \n1186     def desc(self):\n1187         self.descending = True\n1188 \n1189 \n1190 class Window(Expression):\n1191     template = '%(expression)s OVER (%(window)s)'\n1192     # Although the main expression may either be an aggregate or an\n1193     # expression with an aggregate function, the GROUP BY that will\n1194     # be introduced in the query as a result is not desired.\n1195     contains_aggregate = False\n1196     contains_over_clause = True\n1197     filterable = False\n1198 \n1199     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n1200         self.partition_by = partition_by\n1201         self.order_by = order_by\n1202         self.frame = frame\n1203 \n1204         if not getattr(expression, 'window_compatible', False):\n1205             raise ValueError(\n1206                 \"Expression '%s' isn't compatible with OVER clauses.\" %\n1207                 expression.__class__.__name__\n1208             )\n1209 \n1210         if self.partition_by is not None:\n1211             if not isinstance(self.partition_by, (tuple, list)):\n1212                 self.partition_by = (self.partition_by,)\n1213             self.partition_by = ExpressionList(*self.partition_by)\n1214 \n1215         if self.order_by is not None:\n1216             if isinstance(self.order_by, (list, tuple)):\n1217                 self.order_by = ExpressionList(*self.order_by)\n1218             elif not isinstance(self.order_by, BaseExpression):\n1219                 raise ValueError(\n1220                     'order_by must be either an Expression or a sequence of '\n1221                     'expressions.'\n1222                 )\n1223         super().__init__(output_field=output_field)\n1224         self.source_expression = self._parse_expressions(expression)[0]\n1225 \n1226     def _resolve_output_field(self):\n1227         return self.source_expression.output_field\n1228 \n1229     def get_source_expressions(self):\n1230         return [self.source_expression, self.partition_by, self.order_by, self.frame]\n1231 \n1232     def set_source_expressions(self, exprs):\n1233         self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n1234 \n1235     def as_sql(self, compiler, connection, template=None):\n1236         connection.ops.check_expression_support(self)\n1237         if not connection.features.supports_over_clause:\n1238             raise NotSupportedError('This backend does not support window expressions.')\n1239         expr_sql, params = compiler.compile(self.source_expression)\n1240         window_sql, window_params = [], []\n1241 \n1242         if self.partition_by is not None:\n1243             sql_expr, sql_params = self.partition_by.as_sql(\n1244                 compiler=compiler, connection=connection,\n1245                 template='PARTITION BY %(expressions)s',\n1246             )\n1247             window_sql.extend(sql_expr)\n1248             window_params.extend(sql_params)\n1249 \n1250         if self.order_by is not None:\n1251             window_sql.append(' ORDER BY ')\n1252             order_sql, order_params = compiler.compile(self.order_by)\n1253             window_sql.extend(order_sql)\n1254             window_params.extend(order_params)\n1255 \n1256         if self.frame:\n1257             frame_sql, frame_params = compiler.compile(self.frame)\n1258             window_sql.append(' ' + frame_sql)\n1259             window_params.extend(frame_params)\n1260 \n1261         params.extend(window_params)\n1262         template = template or self.template\n1263 \n1264         return template % {\n1265             'expression': expr_sql,\n1266             'window': ''.join(window_sql).strip()\n1267         }, params\n1268 \n1269     def __str__(self):\n1270         return '{} OVER ({}{}{})'.format(\n1271             str(self.source_expression),\n1272             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n1273             'ORDER BY ' + str(self.order_by) if self.order_by else '',\n1274             str(self.frame or ''),\n1275         )\n1276 \n1277     def __repr__(self):\n1278         return '<%s: %s>' % (self.__class__.__name__, self)\n1279 \n1280     def get_group_by_cols(self, alias=None):\n1281         return []\n1282 \n1283 \n1284 class WindowFrame(Expression):\n1285     \"\"\"\n1286     Model the frame clause in window expressions. There are two types of frame\n1287     clauses which are subclasses, however, all processing and validation (by no\n1288     means intended to be complete) is done here. Thus, providing an end for a\n1289     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last\n1290     row in the frame).\n1291     \"\"\"\n1292     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'\n1293 \n1294     def __init__(self, start=None, end=None):\n1295         self.start = Value(start)\n1296         self.end = Value(end)\n1297 \n1298     def set_source_expressions(self, exprs):\n1299         self.start, self.end = exprs\n1300 \n1301     def get_source_expressions(self):\n1302         return [self.start, self.end]\n1303 \n1304     def as_sql(self, compiler, connection):\n1305         connection.ops.check_expression_support(self)\n1306         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)\n1307         return self.template % {\n1308             'frame_type': self.frame_type,\n1309             'start': start,\n1310             'end': end,\n1311         }, []\n1312 \n1313     def __repr__(self):\n1314         return '<%s: %s>' % (self.__class__.__name__, self)\n1315 \n1316     def get_group_by_cols(self, alias=None):\n1317         return []\n1318 \n1319     def __str__(self):\n1320         if self.start.value is not None and self.start.value < 0:\n1321             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)\n1322         elif self.start.value is not None and self.start.value == 0:\n1323             start = connection.ops.CURRENT_ROW\n1324         else:\n1325             start = connection.ops.UNBOUNDED_PRECEDING\n1326 \n1327         if self.end.value is not None and self.end.value > 0:\n1328             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)\n1329         elif self.end.value is not None and self.end.value == 0:\n1330             end = connection.ops.CURRENT_ROW\n1331         else:\n1332             end = connection.ops.UNBOUNDED_FOLLOWING\n1333         return self.template % {\n1334             'frame_type': self.frame_type,\n1335             'start': start,\n1336             'end': end,\n1337         }\n1338 \n1339     def window_frame_start_end(self, connection, start, end):\n1340         raise NotImplementedError('Subclasses must implement window_frame_start_end().')\n1341 \n1342 \n1343 class RowRange(WindowFrame):\n1344     frame_type = 'ROWS'\n1345 \n1346     def window_frame_start_end(self, connection, start, end):\n1347         return connection.ops.window_frame_rows_start_end(start, end)\n1348 \n1349 \n1350 class ValueRange(WindowFrame):\n1351     frame_type = 'RANGE'\n1352 \n1353     def window_frame_start_end(self, connection, start, end):\n1354         return connection.ops.window_frame_range_start_end(start, end)\n",
        "intended_behavior": "Modify the `When` method to automatically recognize and correctly handle `Exists` expressions as valid arguments without requiring them to be wrapped in a `Q` object. This could involve adjusting the method's argument parsing to treat `Exists` similarly to how `filter` expressions are treated, ensuring that `Exists` can be passed directly as a condition. This change must not disrupt the existing functionality, which allows `Q` objects, boolean expressions, and lookups as conditions."
    }
]