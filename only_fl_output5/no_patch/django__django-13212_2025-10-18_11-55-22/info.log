2025-10-18 11:55:22.564 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 11:55:26.079 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=178, output_tokens=12, cost=0.002140
2025-10-18 11:55:26.080 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 11:55:26.083 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:55:33.151 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=487, output_tokens=294, cost=0.013690
2025-10-18 11:55:33.201 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:55:35.807 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=50, cost=0.007980
2025-10-18 11:55:35.809 | DEBUG    | Extracted a valid json.
2025-10-18 11:55:35.809 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ValidationError\")",
        "search_code(\"validators\")",
        "search_code(\"def validate\")",
        "search_code(\"ValidationError(\")"
    ],
    "bug_locations": []
}
2025-10-18 11:55:36.199 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 11:55:36.199 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 11:55:50.702 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2422, output_tokens=704, cost=0.045340
2025-10-18 11:55:50.716 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:55:59.163 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3342, output_tokens=380, cost=0.044820
2025-10-18 11:55:59.173 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:56:09.558 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=734, output_tokens=356, cost=0.018020
2025-10-18 11:56:09.559 | DEBUG    | Extracted a valid json.
2025-10-18 11:56:09.559 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/core/exceptions.py",
            "class": "ValidationError",
            "method": "__init__",
            "intended_behavior": "Enhance the __init__ method of ValidationError to accept an optional provided_value argument. This value should be stored as an instance attribute and utilized in the error message composition if present. This enables error messages to dynamically include the validated value, helping create more context-aware error messages."
        },
        {
            "file": "django/core/validators.py",
            "class": "",
            "method": "",
            "intended_behavior": "Update the built-in validator functions in this file to pass the provided_value to ValidationError when raising it. This change allows these validators to include the value that failed validation in the error message, improving the informativeness of validation errors."
        },
        {
            "file": "django/forms/fields.py",
            "class": "",
            "method": "",
            "intended_behavior": "In every method within form field classes that raises a ValidationError, modify the call to pass the field's value to the exception. This ensures that form validation errors can include the specific value that failed validation, aiding in debugging and user feedback."
        },
        {
            "file": "django/db/models/fields/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "For every validator attached to model fields, ensure that when raising ValidationError, the value being validated is passed along. This requires modifications to both direct raises of ValidationError within methods and possibly updates to how validators are called, ensuring they have the necessary context to include the value in the error."
        }
    ]
}
2025-10-18 11:56:09.579 | DEBUG    | Bug location extracted successfully: [<file>django/core/exceptions.py</file>
<class>ValidationError</class>
<method>__init__</method>
<code>
101     def __init__(self, message, code=None, params=None):
102         """
103         The `message` argument can be a single error, a list of errors, or a
104         dictionary that maps field names to lists of errors. What we define as
105         an "error" can be either a simple string or an instance of
106         ValidationError with its message attribute set, and what we define as
107         list or dictionary can be an actual `list` or `dict` or an instance
108         of ValidationError with its `error_list` or `error_dict` attribute set.
109         """
110         super().__init__(message, code, params)
111 
112         if isinstance(message, ValidationError):
113             if hasattr(message, 'error_dict'):
114                 message = message.error_dict
115             elif not hasattr(message, 'message'):
116                 message = message.error_list
117             else:
118                 message, code, params = message.message, message.code, message.params
119 
120         if isinstance(message, dict):
121             self.error_dict = {}
122             for field, messages in message.items():
123                 if not isinstance(messages, ValidationError):
124                     messages = ValidationError(messages)
125                 self.error_dict[field] = messages.error_list
126 
127         elif isinstance(message, list):
128             self.error_list = []
129             for message in message:
130                 # Normalize plain strings to instances of ValidationError.
131                 if not isinstance(message, ValidationError):
132                     message = ValidationError(message)
133                 if hasattr(message, 'error_dict'):
134                     self.error_list.extend(sum(message.error_dict.values(), []))
135                 else:
136                     self.error_list.extend(message.error_list)
137 
138         else:
139             self.message = message
140             self.code = code
141             self.params = params
142             self.error_list = [self]

</code><intended_behavior>Enhance the __init__ method of ValidationError to accept an optional provided_value argument. This value should be stored as an instance attribute and utilized in the error message composition if present. This enables error messages to dynamically include the validated value, helping create more context-aware error messages.</intended_behavior>, <file>django/core/exceptions.py</file>
<class>ValidationError</class>
<method>None</method>
<code>
99 class ValidationError(Exception):
100     """An error while validating data."""
101     def __init__(self, message, code=None, params=None):
102         """
103         The `message` argument can be a single error, a list of errors, or a
104         dictionary that maps field names to lists of errors. What we define as
105         an "error" can be either a simple string or an instance of
106         ValidationError with its message attribute set, and what we define as
107         list or dictionary can be an actual `list` or `dict` or an instance
108         of ValidationError with its `error_list` or `error_dict` attribute set.
109         """
110         super().__init__(message, code, params)
111 
112         if isinstance(message, ValidationError):
113             if hasattr(message, 'error_dict'):
114                 message = message.error_dict
115             elif not hasattr(message, 'message'):
116                 message = message.error_list
117             else:
118                 message, code, params = message.message, message.code, message.params
119 
120         if isinstance(message, dict):
121             self.error_dict = {}
122             for field, messages in message.items():
123                 if not isinstance(messages, ValidationError):
124                     messages = ValidationError(messages)
125                 self.error_dict[field] = messages.error_list
126 
127         elif isinstance(message, list):
128             self.error_list = []
129             for message in message:
130                 # Normalize plain strings to instances of ValidationError.
131                 if not isinstance(message, ValidationError):
132                     message = ValidationError(message)
133                 if hasattr(message, 'error_dict'):
134                     self.error_list.extend(sum(message.error_dict.values(), []))
135                 else:
136                     self.error_list.extend(message.error_list)
137 
138         else:
139             self.message = message
140             self.code = code
141             self.params = params
142             self.error_list = [self]
143 
144     @property
145     def message_dict(self):
146         # Trigger an AttributeError if this ValidationError
147         # doesn't have an error_dict.
148         getattr(self, 'error_dict')
149 
150         return dict(self)
151 
152     @property
153     def messages(self):
154         if hasattr(self, 'error_dict'):
155             return sum(dict(self).values(), [])
156         return list(self)
157 
158     def update_error_dict(self, error_dict):
159         if hasattr(self, 'error_dict'):
160             for field, error_list in self.error_dict.items():
161                 error_dict.setdefault(field, []).extend(error_list)
162         else:
163             error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)
164         return error_dict
165 
166     def __iter__(self):
167         if hasattr(self, 'error_dict'):
168             for field, errors in self.error_dict.items():
169                 yield field, list(ValidationError(errors))
170         else:
171             for error in self.error_list:
172                 message = error.message
173                 if error.params:
174                     message %= error.params
175                 yield str(message)
176 
177     def __str__(self):
178         if hasattr(self, 'error_dict'):
179             return repr(dict(self))
180         return repr(list(self))
181 
182     def __repr__(self):
183         return 'ValidationError(%s)' % self

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/validators.py</file>
<class>None</class>
<method>None</method>
<code>
1 import ipaddress
2 import re
3 import warnings
4 from pathlib import Path
5 from urllib.parse import urlsplit, urlunsplit
6 
7 from django.core.exceptions import ValidationError
8 from django.utils.deconstruct import deconstructible
9 from django.utils.deprecation import RemovedInDjango41Warning
10 from django.utils.encoding import punycode
11 from django.utils.ipv6 import is_valid_ipv6_address
12 from django.utils.regex_helper import _lazy_re_compile
13 from django.utils.translation import gettext_lazy as _, ngettext_lazy
14 
15 # These values, if given to validate(), will trigger the self.required check.
16 EMPTY_VALUES = (None, '', [], (), {})
17 
18 
19 @deconstructible
20 class RegexValidator:
21     regex = ''
22     message = _('Enter a valid value.')
23     code = 'invalid'
24     inverse_match = False
25     flags = 0
26 
27     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):
28         if regex is not None:
29             self.regex = regex
30         if message is not None:
31             self.message = message
32         if code is not None:
33             self.code = code
34         if inverse_match is not None:
35             self.inverse_match = inverse_match
36         if flags is not None:
37             self.flags = flags
38         if self.flags and not isinstance(self.regex, str):
39             raise TypeError("If the flags are set, regex must be a regular expression string.")
40 
41         self.regex = _lazy_re_compile(self.regex, self.flags)
42 
43     def __call__(self, value):
44         """
45         Validate that the input contains (or does *not* contain, if
46         inverse_match is True) a match for the regular expression.
47         """
48         regex_matches = self.regex.search(str(value))
49         invalid_input = regex_matches if self.inverse_match else not regex_matches
50         if invalid_input:
51             raise ValidationError(self.message, code=self.code)
52 
53     def __eq__(self, other):
54         return (
55             isinstance(other, RegexValidator) and
56             self.regex.pattern == other.regex.pattern and
57             self.regex.flags == other.regex.flags and
58             (self.message == other.message) and
59             (self.code == other.code) and
60             (self.inverse_match == other.inverse_match)
61         )
62 
63 
64 @deconstructible
65 class URLValidator(RegexValidator):
66     ul = '\u00a1-\uffff'  # Unicode letters range (must not be a raw string).
67 
68     # IP patterns
69     ipv4_re = r'(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}'
70     ipv6_re = r'\[[0-9a-f:.]+\]'  # (simple regex, validated later)
71 
72     # Host patterns
73     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'
74     # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1
75     domain_re = r'(?:\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'
76     tld_re = (
77         r'\.'                                # dot
78         r'(?!-)'                             # can't start with a dash
79         r'(?:[a-z' + ul + '-]{2,63}'         # domain label
80         r'|xn--[a-z0-9]{1,59})'              # or punycode label
81         r'(?<!-)'                            # can't end with a dash
82         r'\.?'                               # may have a trailing dot
83     )
84     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'
85 
86     regex = _lazy_re_compile(
87         r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately
88         r'(?:[^\s:@/]+(?::[^\s:@/]*)?@)?'  # user:pass authentication
89         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
90         r'(?::\d{2,5})?'  # port
91         r'(?:[/?#][^\s]*)?'  # resource path
92         r'\Z', re.IGNORECASE)
93     message = _('Enter a valid URL.')
94     schemes = ['http', 'https', 'ftp', 'ftps']
95 
96     def __init__(self, schemes=None, **kwargs):
97         super().__init__(**kwargs)
98         if schemes is not None:
99             self.schemes = schemes
100 
101     def __call__(self, value):
102         if not isinstance(value, str):
103             raise ValidationError(self.message, code=self.code)
104         # Check if the scheme is valid.
105         scheme = value.split('://')[0].lower()
106         if scheme not in self.schemes:
107             raise ValidationError(self.message, code=self.code)
108 
109         # Then check full URL
110         try:
111             super().__call__(value)
112         except ValidationError as e:
113             # Trivial case failed. Try for possible IDN domain
114             if value:
115                 try:
116                     scheme, netloc, path, query, fragment = urlsplit(value)
117                 except ValueError:  # for example, "Invalid IPv6 URL"
118                     raise ValidationError(self.message, code=self.code)
119                 try:
120                     netloc = punycode(netloc)  # IDN -> ACE
121                 except UnicodeError:  # invalid domain part
122                     raise e
123                 url = urlunsplit((scheme, netloc, path, query, fragment))
124                 super().__call__(url)
125             else:
126                 raise
127         else:
128             # Now verify IPv6 in the netloc part
129             host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(value).netloc)
130             if host_match:
131                 potential_ip = host_match[1]
132                 try:
133                     validate_ipv6_address(potential_ip)
134                 except ValidationError:
135                     raise ValidationError(self.message, code=self.code)
136 
137         # The maximum length of a full host name is 253 characters per RFC 1034
138         # section 3.1. It's defined to be 255 bytes or less, but this includes
139         # one byte for the length of the name and one byte for the trailing dot
140         # that's used to indicate absolute names in DNS.
141         if len(urlsplit(value).netloc) > 253:
142             raise ValidationError(self.message, code=self.code)
143 
144 
145 integer_validator = RegexValidator(
146     _lazy_re_compile(r'^-?\d+\Z'),
147     message=_('Enter a valid integer.'),
148     code='invalid',
149 )
150 
151 
152 def validate_integer(value):
153     return integer_validator(value)
154 
155 
156 @deconstructible
157 class EmailValidator:
158     message = _('Enter a valid email address.')
159     code = 'invalid'
160     user_regex = _lazy_re_compile(
161         r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\Z"  # dot-atom
162         r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"\Z)',  # quoted-string
163         re.IGNORECASE)
164     domain_regex = _lazy_re_compile(
165         # max length for domain name labels is 63 characters per RFC 1034
166         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\Z',
167         re.IGNORECASE)
168     literal_regex = _lazy_re_compile(
169         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)
170         r'\[([A-f0-9:.]+)\]\Z',
171         re.IGNORECASE)
172     domain_allowlist = ['localhost']
173 
174     @property
175     def domain_whitelist(self):
176         warnings.warn(
177             'The domain_whitelist attribute is deprecated in favor of '
178             'domain_allowlist.',
179             RemovedInDjango41Warning,
180             stacklevel=2,
181         )
182         return self.domain_allowlist
183 
184     @domain_whitelist.setter
185     def domain_whitelist(self, allowlist):
186         warnings.warn(
187             'The domain_whitelist attribute is deprecated in favor of '
188             'domain_allowlist.',
189             RemovedInDjango41Warning,
190             stacklevel=2,
191         )
192         self.domain_allowlist = allowlist
193 
194     def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):
195         if whitelist is not None:
196             allowlist = whitelist
197             warnings.warn(
198                 'The whitelist argument is deprecated in favor of allowlist.',
199                 RemovedInDjango41Warning,
200                 stacklevel=2,
201             )
202         if message is not None:
203             self.message = message
204         if code is not None:
205             self.code = code
206         if allowlist is not None:
207             self.domain_allowlist = allowlist
208 
209     def __call__(self, value):
210         if not value or '@' not in value:
211             raise ValidationError(self.message, code=self.code)
212 
213         user_part, domain_part = value.rsplit('@', 1)
214 
215         if not self.user_regex.match(user_part):
216             raise ValidationError(self.message, code=self.code)
217 
218         if (domain_part not in self.domain_allowlist and
219                 not self.validate_domain_part(domain_part)):
220             # Try for possible IDN domain-part
221             try:
222                 domain_part = punycode(domain_part)
223             except UnicodeError:
224                 pass
225             else:
226                 if self.validate_domain_part(domain_part):
227                     return
228             raise ValidationError(self.message, code=self.code)
229 
230     def validate_domain_part(self, domain_part):
231         if self.domain_regex.match(domain_part):
232             return True
233 
234         literal_match = self.literal_regex.match(domain_part)
235         if literal_match:
236             ip_address = literal_match[1]
237             try:
238                 validate_ipv46_address(ip_address)
239                 return True
240             except ValidationError:
241                 pass
242         return False
243 
244     def __eq__(self, other):
245         return (
246             isinstance(other, EmailValidator) and
247             (self.domain_allowlist == other.domain_allowlist) and
248             (self.message == other.message) and
249             (self.code == other.code)
250         )
251 
252 
253 validate_email = EmailValidator()
254 
255 slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\Z')
256 validate_slug = RegexValidator(
257     slug_re,
258     # Translators: "letters" means latin letters: a-z and A-Z.
259     _('Enter a valid “slug” consisting of letters, numbers, underscores or hyphens.'),
260     'invalid'
261 )
262 
263 slug_unicode_re = _lazy_re_compile(r'^[-\w]+\Z')
264 validate_unicode_slug = RegexValidator(
265     slug_unicode_re,
266     _('Enter a valid “slug” consisting of Unicode letters, numbers, underscores, or hyphens.'),
267     'invalid'
268 )
269 
270 
271 def validate_ipv4_address(value):
272     try:
273         ipaddress.IPv4Address(value)
274     except ValueError:
275         raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')
276 
277 
278 def validate_ipv6_address(value):
279     if not is_valid_ipv6_address(value):
280         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')
281 
282 
283 def validate_ipv46_address(value):
284     try:
285         validate_ipv4_address(value)
286     except ValidationError:
287         try:
288             validate_ipv6_address(value)
289         except ValidationError:
290             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')
291 
292 
293 ip_address_validator_map = {
294     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),
295     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),
296     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),
297 }
298 
299 
300 def ip_address_validators(protocol, unpack_ipv4):
301     """
302     Depending on the given parameters, return the appropriate validators for
303     the GenericIPAddressField.
304     """
305     if protocol != 'both' and unpack_ipv4:
306         raise ValueError(
307             "You can only use `unpack_ipv4` if `protocol` is set to 'both'")
308     try:
309         return ip_address_validator_map[protocol.lower()]
310     except KeyError:
311         raise ValueError("The protocol '%s' is unknown. Supported: %s"
312                          % (protocol, list(ip_address_validator_map)))
313 
314 
315 def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):
316     regexp = _lazy_re_compile(r'^%(neg)s\d+(?:%(sep)s%(neg)s\d+)*\Z' % {
317         'neg': '(-)?' if allow_negative else '',
318         'sep': re.escape(sep),
319     })
320     return RegexValidator(regexp, message=message, code=code)
321 
322 
323 validate_comma_separated_integer_list = int_list_validator(
324     message=_('Enter only digits separated by commas.'),
325 )
326 
327 
328 @deconstructible
329 class BaseValidator:
330     message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')
331     code = 'limit_value'
332 
333     def __init__(self, limit_value, message=None):
334         self.limit_value = limit_value
335         if message:
336             self.message = message
337 
338     def __call__(self, value):
339         cleaned = self.clean(value)
340         limit_value = self.limit_value() if callable(self.limit_value) else self.limit_value
341         params = {'limit_value': limit_value, 'show_value': cleaned, 'value': value}
342         if self.compare(cleaned, limit_value):
343             raise ValidationError(self.message, code=self.code, params=params)
344 
345     def __eq__(self, other):
346         if not isinstance(other, self.__class__):
347             return NotImplemented
348         return (
349             self.limit_value == other.limit_value and
350             self.message == other.message and
351             self.code == other.code
352         )
353 
354     def compare(self, a, b):
355         return a is not b
356 
357     def clean(self, x):
358         return x
359 
360 
361 @deconstructible
362 class MaxValueValidator(BaseValidator):
363     message = _('Ensure this value is less than or equal to %(limit_value)s.')
364     code = 'max_value'
365 
366     def compare(self, a, b):
367         return a > b
368 
369 
370 @deconstructible
371 class MinValueValidator(BaseValidator):
372     message = _('Ensure this value is greater than or equal to %(limit_value)s.')
373     code = 'min_value'
374 
375     def compare(self, a, b):
376         return a < b
377 
378 
379 @deconstructible
380 class MinLengthValidator(BaseValidator):
381     message = ngettext_lazy(
382         'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',
383         'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',
384         'limit_value')
385     code = 'min_length'
386 
387     def compare(self, a, b):
388         return a < b
389 
390     def clean(self, x):
391         return len(x)
392 
393 
394 @deconstructible
395 class MaxLengthValidator(BaseValidator):
396     message = ngettext_lazy(
397         'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',
398         'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',
399         'limit_value')
400     code = 'max_length'
401 
402     def compare(self, a, b):
403         return a > b
404 
405     def clean(self, x):
406         return len(x)
407 
408 
409 @deconstructible
410 class DecimalValidator:
411     """
412     Validate that the input does not exceed the maximum number of digits
413     expected, otherwise raise ValidationError.
414     """
415     messages = {
416         'invalid': _('Enter a number.'),
417         'max_digits': ngettext_lazy(
418             'Ensure that there are no more than %(max)s digit in total.',
419             'Ensure that there are no more than %(max)s digits in total.',
420             'max'
421         ),
422         'max_decimal_places': ngettext_lazy(
423             'Ensure that there are no more than %(max)s decimal place.',
424             'Ensure that there are no more than %(max)s decimal places.',
425             'max'
426         ),
427         'max_whole_digits': ngettext_lazy(
428             'Ensure that there are no more than %(max)s digit before the decimal point.',
429             'Ensure that there are no more than %(max)s digits before the decimal point.',
430             'max'
431         ),
432     }
433 
434     def __init__(self, max_digits, decimal_places):
435         self.max_digits = max_digits
436         self.decimal_places = decimal_places
437 
438     def __call__(self, value):
439         digit_tuple, exponent = value.as_tuple()[1:]
440         if exponent in {'F', 'n', 'N'}:
441             raise ValidationError(self.messages['invalid'])
442         if exponent >= 0:
443             # A positive exponent adds that many trailing zeros.
444             digits = len(digit_tuple) + exponent
445             decimals = 0
446         else:
447             # If the absolute value of the negative exponent is larger than the
448             # number of digits, then it's the same as the number of digits,
449             # because it'll consume all of the digits in digit_tuple and then
450             # add abs(exponent) - len(digit_tuple) leading zeros after the
451             # decimal point.
452             if abs(exponent) > len(digit_tuple):
453                 digits = decimals = abs(exponent)
454             else:
455                 digits = len(digit_tuple)
456                 decimals = abs(exponent)
457         whole_digits = digits - decimals
458 
459         if self.max_digits is not None and digits > self.max_digits:
460             raise ValidationError(
461                 self.messages['max_digits'],
462                 code='max_digits',
463                 params={'max': self.max_digits},
464             )
465         if self.decimal_places is not None and decimals > self.decimal_places:
466             raise ValidationError(
467                 self.messages['max_decimal_places'],
468                 code='max_decimal_places',
469                 params={'max': self.decimal_places},
470             )
471         if (self.max_digits is not None and self.decimal_places is not None and
472                 whole_digits > (self.max_digits - self.decimal_places)):
473             raise ValidationError(
474                 self.messages['max_whole_digits'],
475                 code='max_whole_digits',
476                 params={'max': (self.max_digits - self.decimal_places)},
477             )
478 
479     def __eq__(self, other):
480         return (
481             isinstance(other, self.__class__) and
482             self.max_digits == other.max_digits and
483             self.decimal_places == other.decimal_places
484         )
485 
486 
487 @deconstructible
488 class FileExtensionValidator:
489     message = _(
490         'File extension “%(extension)s” is not allowed. '
491         'Allowed extensions are: %(allowed_extensions)s.'
492     )
493     code = 'invalid_extension'
494 
495     def __init__(self, allowed_extensions=None, message=None, code=None):
496         if allowed_extensions is not None:
497             allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]
498         self.allowed_extensions = allowed_extensions
499         if message is not None:
500             self.message = message
501         if code is not None:
502             self.code = code
503 
504     def __call__(self, value):
505         extension = Path(value.name).suffix[1:].lower()
506         if self.allowed_extensions is not None and extension not in self.allowed_extensions:
507             raise ValidationError(
508                 self.message,
509                 code=self.code,
510                 params={
511                     'extension': extension,
512                     'allowed_extensions': ', '.join(self.allowed_extensions)
513                 }
514             )
515 
516     def __eq__(self, other):
517         return (
518             isinstance(other, self.__class__) and
519             self.allowed_extensions == other.allowed_extensions and
520             self.message == other.message and
521             self.code == other.code
522         )
523 
524 
525 def get_available_image_extensions():
526     try:
527         from PIL import Image
528     except ImportError:
529         return []
530     else:
531         Image.init()
532         return [ext.lower()[1:] for ext in Image.EXTENSION]
533 
534 
535 def validate_image_file_extension(value):
536     return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)
537 
538 
539 @deconstructible
540 class ProhibitNullCharactersValidator:
541     """Validate that the string doesn't contain the null character."""
542     message = _('Null characters are not allowed.')
543     code = 'null_characters_not_allowed'
544 
545     def __init__(self, message=None, code=None):
546         if message is not None:
547             self.message = message
548         if code is not None:
549             self.code = code
550 
551     def __call__(self, value):
552         if '\x00' in str(value):
553             raise ValidationError(self.message, code=self.code)
554 
555     def __eq__(self, other):
556         return (
557             isinstance(other, self.__class__) and
558             self.message == other.message and
559             self.code == other.code
560         )

</code><intended_behavior>Update the built-in validator functions in this file to pass the provided_value to ValidationError when raising it. This change allows these validators to include the value that failed validation in the error message, improving the informativeness of validation errors.</intended_behavior>, <file>django/forms/fields.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Field classes.
3 """
4 
5 import copy
6 import datetime
7 import json
8 import math
9 import operator
10 import os
11 import re
12 import uuid
13 from decimal import Decimal, DecimalException
14 from io import BytesIO
15 from urllib.parse import urlsplit, urlunsplit
16 
17 from django.core import validators
18 from django.core.exceptions import ValidationError
19 from django.forms.boundfield import BoundField
20 from django.forms.utils import from_current_timezone, to_current_timezone
21 from django.forms.widgets import (
22     FILE_INPUT_CONTRADICTION, CheckboxInput, ClearableFileInput, DateInput,
23     DateTimeInput, EmailInput, FileInput, HiddenInput, MultipleHiddenInput,
24     NullBooleanSelect, NumberInput, Select, SelectMultiple,
25     SplitDateTimeWidget, SplitHiddenDateTimeWidget, Textarea, TextInput,
26     TimeInput, URLInput,
27 )
28 from django.utils import formats
29 from django.utils.dateparse import parse_datetime, parse_duration
30 from django.utils.duration import duration_string
31 from django.utils.ipv6 import clean_ipv6_address
32 from django.utils.regex_helper import _lazy_re_compile
33 from django.utils.translation import gettext_lazy as _, ngettext_lazy
34 
35 __all__ = (
36     'Field', 'CharField', 'IntegerField',
37     'DateField', 'TimeField', 'DateTimeField', 'DurationField',
38     'RegexField', 'EmailField', 'FileField', 'ImageField', 'URLField',
39     'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',
40     'ComboField', 'MultiValueField', 'FloatField', 'DecimalField',
41     'SplitDateTimeField', 'GenericIPAddressField', 'FilePathField',
42     'JSONField', 'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField',
43     'UUIDField',
44 )
45 
46 
47 class Field:
48     widget = TextInput  # Default widget to use when rendering this type of Field.
49     hidden_widget = HiddenInput  # Default widget to use when rendering this as "hidden".
50     default_validators = []  # Default set of validators
51     # Add an 'invalid' entry to default_error_message if you want a specific
52     # field error message not raised by the field validators.
53     default_error_messages = {
54         'required': _('This field is required.'),
55     }
56     empty_values = list(validators.EMPTY_VALUES)
57 
58     def __init__(self, *, required=True, widget=None, label=None, initial=None,
59                  help_text='', error_messages=None, show_hidden_initial=False,
60                  validators=(), localize=False, disabled=False, label_suffix=None):
61         # required -- Boolean that specifies whether the field is required.
62         #             True by default.
63         # widget -- A Widget class, or instance of a Widget class, that should
64         #           be used for this Field when displaying it. Each Field has a
65         #           default Widget that it'll use if you don't specify this. In
66         #           most cases, the default widget is TextInput.
67         # label -- A verbose name for this field, for use in displaying this
68         #          field in a form. By default, Django will use a "pretty"
69         #          version of the form field name, if the Field is part of a
70         #          Form.
71         # initial -- A value to use in this Field's initial display. This value
72         #            is *not* used as a fallback if data isn't given.
73         # help_text -- An optional string to use as "help text" for this Field.
74         # error_messages -- An optional dictionary to override the default
75         #                   messages that the field will raise.
76         # show_hidden_initial -- Boolean that specifies if it is needed to render a
77         #                        hidden widget with initial value after widget.
78         # validators -- List of additional validators to use
79         # localize -- Boolean that specifies if the field should be localized.
80         # disabled -- Boolean that specifies whether the field is disabled, that
81         #             is its widget is shown in the form but not editable.
82         # label_suffix -- Suffix to be added to the label. Overrides
83         #                 form's label_suffix.
84         self.required, self.label, self.initial = required, label, initial
85         self.show_hidden_initial = show_hidden_initial
86         self.help_text = help_text
87         self.disabled = disabled
88         self.label_suffix = label_suffix
89         widget = widget or self.widget
90         if isinstance(widget, type):
91             widget = widget()
92         else:
93             widget = copy.deepcopy(widget)
94 
95         # Trigger the localization machinery if needed.
96         self.localize = localize
97         if self.localize:
98             widget.is_localized = True
99 
100         # Let the widget know whether it should display as required.
101         widget.is_required = self.required
102 
103         # Hook into self.widget_attrs() for any Field-specific HTML attributes.
104         extra_attrs = self.widget_attrs(widget)
105         if extra_attrs:
106             widget.attrs.update(extra_attrs)
107 
108         self.widget = widget
109 
110         messages = {}
111         for c in reversed(self.__class__.__mro__):
112             messages.update(getattr(c, 'default_error_messages', {}))
113         messages.update(error_messages or {})
114         self.error_messages = messages
115 
116         self.validators = [*self.default_validators, *validators]
117 
118         super().__init__()
119 
120     def prepare_value(self, value):
121         return value
122 
123     def to_python(self, value):
124         return value
125 
126     def validate(self, value):
127         if value in self.empty_values and self.required:
128             raise ValidationError(self.error_messages['required'], code='required')
129 
130     def run_validators(self, value):
131         if value in self.empty_values:
132             return
133         errors = []
134         for v in self.validators:
135             try:
136                 v(value)
137             except ValidationError as e:
138                 if hasattr(e, 'code') and e.code in self.error_messages:
139                     e.message = self.error_messages[e.code]
140                 errors.extend(e.error_list)
141         if errors:
142             raise ValidationError(errors)
143 
144     def clean(self, value):
145         """
146         Validate the given value and return its "cleaned" value as an
147         appropriate Python object. Raise ValidationError for any errors.
148         """
149         value = self.to_python(value)
150         self.validate(value)
151         self.run_validators(value)
152         return value
153 
154     def bound_data(self, data, initial):
155         """
156         Return the value that should be shown for this field on render of a
157         bound form, given the submitted POST data for the field and the initial
158         data, if any.
159 
160         For most fields, this will simply be data; FileFields need to handle it
161         a bit differently.
162         """
163         if self.disabled:
164             return initial
165         return data
166 
167     def widget_attrs(self, widget):
168         """
169         Given a Widget instance (*not* a Widget class), return a dictionary of
170         any HTML attributes that should be added to the Widget, based on this
171         Field.
172         """
173         return {}
174 
175     def has_changed(self, initial, data):
176         """Return True if data differs from initial."""
177         # Always return False if the field is disabled since self.bound_data
178         # always uses the initial value in this case.
179         if self.disabled:
180             return False
181         try:
182             data = self.to_python(data)
183             if hasattr(self, '_coerce'):
184                 return self._coerce(data) != self._coerce(initial)
185         except ValidationError:
186             return True
187         # For purposes of seeing whether something has changed, None is
188         # the same as an empty string, if the data or initial value we get
189         # is None, replace it with ''.
190         initial_value = initial if initial is not None else ''
191         data_value = data if data is not None else ''
192         return initial_value != data_value
193 
194     def get_bound_field(self, form, field_name):
195         """
196         Return a BoundField instance that will be used when accessing the form
197         field in a template.
198         """
199         return BoundField(form, self, field_name)
200 
201     def __deepcopy__(self, memo):
202         result = copy.copy(self)
203         memo[id(self)] = result
204         result.widget = copy.deepcopy(self.widget, memo)
205         result.error_messages = self.error_messages.copy()
206         result.validators = self.validators[:]
207         return result
208 
209 
210 class CharField(Field):
211     def __init__(self, *, max_length=None, min_length=None, strip=True, empty_value='', **kwargs):
212         self.max_length = max_length
213         self.min_length = min_length
214         self.strip = strip
215         self.empty_value = empty_value
216         super().__init__(**kwargs)
217         if min_length is not None:
218             self.validators.append(validators.MinLengthValidator(int(min_length)))
219         if max_length is not None:
220             self.validators.append(validators.MaxLengthValidator(int(max_length)))
221         self.validators.append(validators.ProhibitNullCharactersValidator())
222 
223     def to_python(self, value):
224         """Return a string."""
225         if value not in self.empty_values:
226             value = str(value)
227             if self.strip:
228                 value = value.strip()
229         if value in self.empty_values:
230             return self.empty_value
231         return value
232 
233     def widget_attrs(self, widget):
234         attrs = super().widget_attrs(widget)
235         if self.max_length is not None and not widget.is_hidden:
236             # The HTML attribute is maxlength, not max_length.
237             attrs['maxlength'] = str(self.max_length)
238         if self.min_length is not None and not widget.is_hidden:
239             # The HTML attribute is minlength, not min_length.
240             attrs['minlength'] = str(self.min_length)
241         return attrs
242 
243 
244 class IntegerField(Field):
245     widget = NumberInput
246     default_error_messages = {
247         'invalid': _('Enter a whole number.'),
248     }
249     re_decimal = _lazy_re_compile(r'\.0*\s*$')
250 
251     def __init__(self, *, max_value=None, min_value=None, **kwargs):
252         self.max_value, self.min_value = max_value, min_value
253         if kwargs.get('localize') and self.widget == NumberInput:
254             # Localized number input is not well supported on most browsers
255             kwargs.setdefault('widget', super().widget)
256         super().__init__(**kwargs)
257 
258         if max_value is not None:
259             self.validators.append(validators.MaxValueValidator(max_value))
260         if min_value is not None:
261             self.validators.append(validators.MinValueValidator(min_value))
262 
263     def to_python(self, value):
264         """
265         Validate that int() can be called on the input. Return the result
266         of int() or None for empty values.
267         """
268         value = super().to_python(value)
269         if value in self.empty_values:
270             return None
271         if self.localize:
272             value = formats.sanitize_separators(value)
273         # Strip trailing decimal and zeros.
274         try:
275             value = int(self.re_decimal.sub('', str(value)))
276         except (ValueError, TypeError):
277             raise ValidationError(self.error_messages['invalid'], code='invalid')
278         return value
279 
280     def widget_attrs(self, widget):
281         attrs = super().widget_attrs(widget)
282         if isinstance(widget, NumberInput):
283             if self.min_value is not None:
284                 attrs['min'] = self.min_value
285             if self.max_value is not None:
286                 attrs['max'] = self.max_value
287         return attrs
288 
289 
290 class FloatField(IntegerField):
291     default_error_messages = {
292         'invalid': _('Enter a number.'),
293     }
294 
295     def to_python(self, value):
296         """
297         Validate that float() can be called on the input. Return the result
298         of float() or None for empty values.
299         """
300         value = super(IntegerField, self).to_python(value)
301         if value in self.empty_values:
302             return None
303         if self.localize:
304             value = formats.sanitize_separators(value)
305         try:
306             value = float(value)
307         except (ValueError, TypeError):
308             raise ValidationError(self.error_messages['invalid'], code='invalid')
309         return value
310 
311     def validate(self, value):
312         super().validate(value)
313         if value in self.empty_values:
314             return
315         if not math.isfinite(value):
316             raise ValidationError(self.error_messages['invalid'], code='invalid')
317 
318     def widget_attrs(self, widget):
319         attrs = super().widget_attrs(widget)
320         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:
321             attrs.setdefault('step', 'any')
322         return attrs
323 
324 
325 class DecimalField(IntegerField):
326     default_error_messages = {
327         'invalid': _('Enter a number.'),
328     }
329 
330     def __init__(self, *, max_value=None, min_value=None, max_digits=None, decimal_places=None, **kwargs):
331         self.max_digits, self.decimal_places = max_digits, decimal_places
332         super().__init__(max_value=max_value, min_value=min_value, **kwargs)
333         self.validators.append(validators.DecimalValidator(max_digits, decimal_places))
334 
335     def to_python(self, value):
336         """
337         Validate that the input is a decimal number. Return a Decimal
338         instance or None for empty values. Ensure that there are no more
339         than max_digits in the number and no more than decimal_places digits
340         after the decimal point.
341         """
342         if value in self.empty_values:
343             return None
344         if self.localize:
345             value = formats.sanitize_separators(value)
346         value = str(value).strip()
347         try:
348             value = Decimal(value)
349         except DecimalException:
350             raise ValidationError(self.error_messages['invalid'], code='invalid')
351         return value
352 
353     def validate(self, value):
354         super().validate(value)
355         if value in self.empty_values:
356             return
357         if not value.is_finite():
358             raise ValidationError(self.error_messages['invalid'], code='invalid')
359 
360     def widget_attrs(self, widget):
361         attrs = super().widget_attrs(widget)
362         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:
363             if self.decimal_places is not None:
364                 # Use exponential notation for small values since they might
365                 # be parsed as 0 otherwise. ref #20765
366                 step = str(Decimal(1).scaleb(-self.decimal_places)).lower()
367             else:
368                 step = 'any'
369             attrs.setdefault('step', step)
370         return attrs
371 
372 
373 class BaseTemporalField(Field):
374 
375     def __init__(self, *, input_formats=None, **kwargs):
376         super().__init__(**kwargs)
377         if input_formats is not None:
378             self.input_formats = input_formats
379 
380     def to_python(self, value):
381         value = value.strip()
382         # Try to strptime against each input format.
383         for format in self.input_formats:
384             try:
385                 return self.strptime(value, format)
386             except (ValueError, TypeError):
387                 continue
388         raise ValidationError(self.error_messages['invalid'], code='invalid')
389 
390     def strptime(self, value, format):
391         raise NotImplementedError('Subclasses must define this method.')
392 
393 
394 class DateField(BaseTemporalField):
395     widget = DateInput
396     input_formats = formats.get_format_lazy('DATE_INPUT_FORMATS')
397     default_error_messages = {
398         'invalid': _('Enter a valid date.'),
399     }
400 
401     def to_python(self, value):
402         """
403         Validate that the input can be converted to a date. Return a Python
404         datetime.date object.
405         """
406         if value in self.empty_values:
407             return None
408         if isinstance(value, datetime.datetime):
409             return value.date()
410         if isinstance(value, datetime.date):
411             return value
412         return super().to_python(value)
413 
414     def strptime(self, value, format):
415         return datetime.datetime.strptime(value, format).date()
416 
417 
418 class TimeField(BaseTemporalField):
419     widget = TimeInput
420     input_formats = formats.get_format_lazy('TIME_INPUT_FORMATS')
421     default_error_messages = {
422         'invalid': _('Enter a valid time.')
423     }
424 
425     def to_python(self, value):
426         """
427         Validate that the input can be converted to a time. Return a Python
428         datetime.time object.
429         """
430         if value in self.empty_values:
431             return None
432         if isinstance(value, datetime.time):
433             return value
434         return super().to_python(value)
435 
436     def strptime(self, value, format):
437         return datetime.datetime.strptime(value, format).time()
438 
439 
440 class DateTimeFormatsIterator:
441     def __iter__(self):
442         yield from formats.get_format('DATETIME_INPUT_FORMATS')
443         yield from formats.get_format('DATE_INPUT_FORMATS')
444 
445 
446 class DateTimeField(BaseTemporalField):
447     widget = DateTimeInput
448     input_formats = DateTimeFormatsIterator()
449     default_error_messages = {
450         'invalid': _('Enter a valid date/time.'),
451     }
452 
453     def prepare_value(self, value):
454         if isinstance(value, datetime.datetime):
455             value = to_current_timezone(value)
456         return value
457 
458     def to_python(self, value):
459         """
460         Validate that the input can be converted to a datetime. Return a
461         Python datetime.datetime object.
462         """
463         if value in self.empty_values:
464             return None
465         if isinstance(value, datetime.datetime):
466             return from_current_timezone(value)
467         if isinstance(value, datetime.date):
468             result = datetime.datetime(value.year, value.month, value.day)
469             return from_current_timezone(result)
470         try:
471             result = parse_datetime(value.strip())
472         except ValueError:
473             raise ValidationError(self.error_messages['invalid'], code='invalid')
474         if not result:
475             result = super().to_python(value)
476         return from_current_timezone(result)
477 
478     def strptime(self, value, format):
479         return datetime.datetime.strptime(value, format)
480 
481 
482 class DurationField(Field):
483     default_error_messages = {
484         'invalid': _('Enter a valid duration.'),
485         'overflow': _('The number of days must be between {min_days} and {max_days}.')
486     }
487 
488     def prepare_value(self, value):
489         if isinstance(value, datetime.timedelta):
490             return duration_string(value)
491         return value
492 
493     def to_python(self, value):
494         if value in self.empty_values:
495             return None
496         if isinstance(value, datetime.timedelta):
497             return value
498         try:
499             value = parse_duration(str(value))
500         except OverflowError:
501             raise ValidationError(self.error_messages['overflow'].format(
502                 min_days=datetime.timedelta.min.days,
503                 max_days=datetime.timedelta.max.days,
504             ), code='overflow')
505         if value is None:
506             raise ValidationError(self.error_messages['invalid'], code='invalid')
507         return value
508 
509 
510 class RegexField(CharField):
511     def __init__(self, regex, **kwargs):
512         """
513         regex can be either a string or a compiled regular expression object.
514         """
515         kwargs.setdefault('strip', False)
516         super().__init__(**kwargs)
517         self._set_regex(regex)
518 
519     def _get_regex(self):
520         return self._regex
521 
522     def _set_regex(self, regex):
523         if isinstance(regex, str):
524             regex = re.compile(regex)
525         self._regex = regex
526         if hasattr(self, '_regex_validator') and self._regex_validator in self.validators:
527             self.validators.remove(self._regex_validator)
528         self._regex_validator = validators.RegexValidator(regex=regex)
529         self.validators.append(self._regex_validator)
530 
531     regex = property(_get_regex, _set_regex)
532 
533 
534 class EmailField(CharField):
535     widget = EmailInput
536     default_validators = [validators.validate_email]
537 
538     def __init__(self, **kwargs):
539         super().__init__(strip=True, **kwargs)
540 
541 
542 class FileField(Field):
543     widget = ClearableFileInput
544     default_error_messages = {
545         'invalid': _("No file was submitted. Check the encoding type on the form."),
546         'missing': _("No file was submitted."),
547         'empty': _("The submitted file is empty."),
548         'max_length': ngettext_lazy(
549             'Ensure this filename has at most %(max)d character (it has %(length)d).',
550             'Ensure this filename has at most %(max)d characters (it has %(length)d).',
551             'max'),
552         'contradiction': _('Please either submit a file or check the clear checkbox, not both.')
553     }
554 
555     def __init__(self, *, max_length=None, allow_empty_file=False, **kwargs):
556         self.max_length = max_length
557         self.allow_empty_file = allow_empty_file
558         super().__init__(**kwargs)
559 
560     def to_python(self, data):
561         if data in self.empty_values:
562             return None
563 
564         # UploadedFile objects should have name and size attributes.
565         try:
566             file_name = data.name
567             file_size = data.size
568         except AttributeError:
569             raise ValidationError(self.error_messages['invalid'], code='invalid')
570 
571         if self.max_length is not None and len(file_name) > self.max_length:
572             params = {'max': self.max_length, 'length': len(file_name)}
573             raise ValidationError(self.error_messages['max_length'], code='max_length', params=params)
574         if not file_name:
575             raise ValidationError(self.error_messages['invalid'], code='invalid')
576         if not self.allow_empty_file and not file_size:
577             raise ValidationError(self.error_messages['empty'], code='empty')
578 
579         return data
580 
581     def clean(self, data, initial=None):
582         # If the widget got contradictory inputs, we raise a validation error
583         if data is FILE_INPUT_CONTRADICTION:
584             raise ValidationError(self.error_messages['contradiction'], code='contradiction')
585         # False means the field value should be cleared; further validation is
586         # not needed.
587         if data is False:
588             if not self.required:
589                 return False
590             # If the field is required, clearing is not possible (the widget
591             # shouldn't return False data in that case anyway). False is not
592             # in self.empty_value; if a False value makes it this far
593             # it should be validated from here on out as None (so it will be
594             # caught by the required check).
595             data = None
596         if not data and initial:
597             return initial
598         return super().clean(data)
599 
600     def bound_data(self, data, initial):
601         if data in (None, FILE_INPUT_CONTRADICTION):
602             return initial
603         return data
604 
605     def has_changed(self, initial, data):
606         return not self.disabled and data is not None
607 
608 
609 class ImageField(FileField):
610     default_validators = [validators.validate_image_file_extension]
611     default_error_messages = {
612         'invalid_image': _(
613             "Upload a valid image. The file you uploaded was either not an "
614             "image or a corrupted image."
615         ),
616     }
617 
618     def to_python(self, data):
619         """
620         Check that the file-upload field data contains a valid image (GIF, JPG,
621         PNG, etc. -- whatever Pillow supports).
622         """
623         f = super().to_python(data)
624         if f is None:
625             return None
626 
627         from PIL import Image
628 
629         # We need to get a file object for Pillow. We might have a path or we might
630         # have to read the data into memory.
631         if hasattr(data, 'temporary_file_path'):
632             file = data.temporary_file_path()
633         else:
634             if hasattr(data, 'read'):
635                 file = BytesIO(data.read())
636             else:
637                 file = BytesIO(data['content'])
638 
639         try:
640             # load() could spot a truncated JPEG, but it loads the entire
641             # image in memory, which is a DoS vector. See #3848 and #18520.
642             image = Image.open(file)
643             # verify() must be called immediately after the constructor.
644             image.verify()
645 
646             # Annotating so subclasses can reuse it for their own validation
647             f.image = image
648             # Pillow doesn't detect the MIME type of all formats. In those
649             # cases, content_type will be None.
650             f.content_type = Image.MIME.get(image.format)
651         except Exception as exc:
652             # Pillow doesn't recognize it as an image.
653             raise ValidationError(
654                 self.error_messages['invalid_image'],
655                 code='invalid_image',
656             ) from exc
657         if hasattr(f, 'seek') and callable(f.seek):
658             f.seek(0)
659         return f
660 
661     def widget_attrs(self, widget):
662         attrs = super().widget_attrs(widget)
663         if isinstance(widget, FileInput) and 'accept' not in widget.attrs:
664             attrs.setdefault('accept', 'image/*')
665         return attrs
666 
667 
668 class URLField(CharField):
669     widget = URLInput
670     default_error_messages = {
671         'invalid': _('Enter a valid URL.'),
672     }
673     default_validators = [validators.URLValidator()]
674 
675     def __init__(self, **kwargs):
676         super().__init__(strip=True, **kwargs)
677 
678     def to_python(self, value):
679 
680         def split_url(url):
681             """
682             Return a list of url parts via urlparse.urlsplit(), or raise
683             ValidationError for some malformed URLs.
684             """
685             try:
686                 return list(urlsplit(url))
687             except ValueError:
688                 # urlparse.urlsplit can raise a ValueError with some
689                 # misformatted URLs.
690                 raise ValidationError(self.error_messages['invalid'], code='invalid')
691 
692         value = super().to_python(value)
693         if value:
694             url_fields = split_url(value)
695             if not url_fields[0]:
696                 # If no URL scheme given, assume http://
697                 url_fields[0] = 'http'
698             if not url_fields[1]:
699                 # Assume that if no domain is provided, that the path segment
700                 # contains the domain.
701                 url_fields[1] = url_fields[2]
702                 url_fields[2] = ''
703                 # Rebuild the url_fields list, since the domain segment may now
704                 # contain the path too.
705                 url_fields = split_url(urlunsplit(url_fields))
706             value = urlunsplit(url_fields)
707         return value
708 
709 
710 class BooleanField(Field):
711     widget = CheckboxInput
712 
713     def to_python(self, value):
714         """Return a Python boolean object."""
715         # Explicitly check for the string 'False', which is what a hidden field
716         # will submit for False. Also check for '0', since this is what
717         # RadioSelect will provide. Because bool("True") == bool('1') == True,
718         # we don't need to handle that explicitly.
719         if isinstance(value, str) and value.lower() in ('false', '0'):
720             value = False
721         else:
722             value = bool(value)
723         return super().to_python(value)
724 
725     def validate(self, value):
726         if not value and self.required:
727             raise ValidationError(self.error_messages['required'], code='required')
728 
729     def has_changed(self, initial, data):
730         if self.disabled:
731             return False
732         # Sometimes data or initial may be a string equivalent of a boolean
733         # so we should run it through to_python first to get a boolean value
734         return self.to_python(initial) != self.to_python(data)
735 
736 
737 class NullBooleanField(BooleanField):
738     """
739     A field whose valid values are None, True, and False. Clean invalid values
740     to None.
741     """
742     widget = NullBooleanSelect
743 
744     def to_python(self, value):
745         """
746         Explicitly check for the string 'True' and 'False', which is what a
747         hidden field will submit for True and False, for 'true' and 'false',
748         which are likely to be returned by JavaScript serializations of forms,
749         and for '1' and '0', which is what a RadioField will submit. Unlike
750         the Booleanfield, this field must check for True because it doesn't
751         use the bool() function.
752         """
753         if value in (True, 'True', 'true', '1'):
754             return True
755         elif value in (False, 'False', 'false', '0'):
756             return False
757         else:
758             return None
759 
760     def validate(self, value):
761         pass
762 
763 
764 class CallableChoiceIterator:
765     def __init__(self, choices_func):
766         self.choices_func = choices_func
767 
768     def __iter__(self):
769         yield from self.choices_func()
770 
771 
772 class ChoiceField(Field):
773     widget = Select
774     default_error_messages = {
775         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),
776     }
777 
778     def __init__(self, *, choices=(), **kwargs):
779         super().__init__(**kwargs)
780         self.choices = choices
781 
782     def __deepcopy__(self, memo):
783         result = super().__deepcopy__(memo)
784         result._choices = copy.deepcopy(self._choices, memo)
785         return result
786 
787     def _get_choices(self):
788         return self._choices
789 
790     def _set_choices(self, value):
791         # Setting choices also sets the choices on the widget.
792         # choices can be any iterable, but we call list() on it because
793         # it will be consumed more than once.
794         if callable(value):
795             value = CallableChoiceIterator(value)
796         else:
797             value = list(value)
798 
799         self._choices = self.widget.choices = value
800 
801     choices = property(_get_choices, _set_choices)
802 
803     def to_python(self, value):
804         """Return a string."""
805         if value in self.empty_values:
806             return ''
807         return str(value)
808 
809     def validate(self, value):
810         """Validate that the input is in self.choices."""
811         super().validate(value)
812         if value and not self.valid_value(value):
813             raise ValidationError(
814                 self.error_messages['invalid_choice'],
815                 code='invalid_choice',
816                 params={'value': value},
817             )
818 
819     def valid_value(self, value):
820         """Check to see if the provided value is a valid choice."""
821         text_value = str(value)
822         for k, v in self.choices:
823             if isinstance(v, (list, tuple)):
824                 # This is an optgroup, so look inside the group for options
825                 for k2, v2 in v:
826                     if value == k2 or text_value == str(k2):
827                         return True
828             else:
829                 if value == k or text_value == str(k):
830                     return True
831         return False
832 
833 
834 class TypedChoiceField(ChoiceField):
835     def __init__(self, *, coerce=lambda val: val, empty_value='', **kwargs):
836         self.coerce = coerce
837         self.empty_value = empty_value
838         super().__init__(**kwargs)
839 
840     def _coerce(self, value):
841         """
842         Validate that the value can be coerced to the right type (if not empty).
843         """
844         if value == self.empty_value or value in self.empty_values:
845             return self.empty_value
846         try:
847             value = self.coerce(value)
848         except (ValueError, TypeError, ValidationError):
849             raise ValidationError(
850                 self.error_messages['invalid_choice'],
851                 code='invalid_choice',
852                 params={'value': value},
853             )
854         return value
855 
856     def clean(self, value):
857         value = super().clean(value)
858         return self._coerce(value)
859 
860 
861 class MultipleChoiceField(ChoiceField):
862     hidden_widget = MultipleHiddenInput
863     widget = SelectMultiple
864     default_error_messages = {
865         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),
866         'invalid_list': _('Enter a list of values.'),
867     }
868 
869     def to_python(self, value):
870         if not value:
871             return []
872         elif not isinstance(value, (list, tuple)):
873             raise ValidationError(self.error_messages['invalid_list'], code='invalid_list')
874         return [str(val) for val in value]
875 
876     def validate(self, value):
877         """Validate that the input is a list or tuple."""
878         if self.required and not value:
879             raise ValidationError(self.error_messages['required'], code='required')
880         # Validate that each value in the value list is in self.choices.
881         for val in value:
882             if not self.valid_value(val):
883                 raise ValidationError(
884                     self.error_messages['invalid_choice'],
885                     code='invalid_choice',
886                     params={'value': val},
887                 )
888 
889     def has_changed(self, initial, data):
890         if self.disabled:
891             return False
892         if initial is None:
893             initial = []
894         if data is None:
895             data = []
896         if len(initial) != len(data):
897             return True
898         initial_set = {str(value) for value in initial}
899         data_set = {str(value) for value in data}
900         return data_set != initial_set
901 
902 
903 class TypedMultipleChoiceField(MultipleChoiceField):
904     def __init__(self, *, coerce=lambda val: val, **kwargs):
905         self.coerce = coerce
906         self.empty_value = kwargs.pop('empty_value', [])
907         super().__init__(**kwargs)
908 
909     def _coerce(self, value):
910         """
911         Validate that the values are in self.choices and can be coerced to the
912         right type.
913         """
914         if value == self.empty_value or value in self.empty_values:
915             return self.empty_value
916         new_value = []
917         for choice in value:
918             try:
919                 new_value.append(self.coerce(choice))
920             except (ValueError, TypeError, ValidationError):
921                 raise ValidationError(
922                     self.error_messages['invalid_choice'],
923                     code='invalid_choice',
924                     params={'value': choice},
925                 )
926         return new_value
927 
928     def clean(self, value):
929         value = super().clean(value)
930         return self._coerce(value)
931 
932     def validate(self, value):
933         if value != self.empty_value:
934             super().validate(value)
935         elif self.required:
936             raise ValidationError(self.error_messages['required'], code='required')
937 
938 
939 class ComboField(Field):
940     """
941     A Field whose clean() method calls multiple Field clean() methods.
942     """
943     def __init__(self, fields, **kwargs):
944         super().__init__(**kwargs)
945         # Set 'required' to False on the individual fields, because the
946         # required validation will be handled by ComboField, not by those
947         # individual fields.
948         for f in fields:
949             f.required = False
950         self.fields = fields
951 
952     def clean(self, value):
953         """
954         Validate the given value against all of self.fields, which is a
955         list of Field instances.
956         """
957         super().clean(value)
958         for field in self.fields:
959             value = field.clean(value)
960         return value
961 
962 
963 class MultiValueField(Field):
964     """
965     Aggregate the logic of multiple Fields.
966 
967     Its clean() method takes a "decompressed" list of values, which are then
968     cleaned into a single value according to self.fields. Each value in
969     this list is cleaned by the corresponding field -- the first value is
970     cleaned by the first field, the second value is cleaned by the second
971     field, etc. Once all fields are cleaned, the list of clean values is
972     "compressed" into a single value.
973 
974     Subclasses should not have to implement clean(). Instead, they must
975     implement compress(), which takes a list of valid values and returns a
976     "compressed" version of those values -- a single value.
977 
978     You'll probably want to use this with MultiWidget.
979     """
980     default_error_messages = {
981         'invalid': _('Enter a list of values.'),
982         'incomplete': _('Enter a complete value.'),
983     }
984 
985     def __init__(self, fields, *, require_all_fields=True, **kwargs):
986         self.require_all_fields = require_all_fields
987         super().__init__(**kwargs)
988         for f in fields:
989             f.error_messages.setdefault('incomplete',
990                                         self.error_messages['incomplete'])
991             if self.disabled:
992                 f.disabled = True
993             if self.require_all_fields:
994                 # Set 'required' to False on the individual fields, because the
995                 # required validation will be handled by MultiValueField, not
996                 # by those individual fields.
997                 f.required = False
998         self.fields = fields
999 
1000     def __deepcopy__(self, memo):
1001         result = super().__deepcopy__(memo)
1002         result.fields = tuple(x.__deepcopy__(memo) for x in self.fields)
1003         return result
1004 
1005     def validate(self, value):
1006         pass
1007 
1008     def clean(self, value):
1009         """
1010         Validate every value in the given list. A value is validated against
1011         the corresponding Field in self.fields.
1012 
1013         For example, if this MultiValueField was instantiated with
1014         fields=(DateField(), TimeField()), clean() would call
1015         DateField.clean(value[0]) and TimeField.clean(value[1]).
1016         """
1017         clean_data = []
1018         errors = []
1019         if self.disabled and not isinstance(value, list):
1020             value = self.widget.decompress(value)
1021         if not value or isinstance(value, (list, tuple)):
1022             if not value or not [v for v in value if v not in self.empty_values]:
1023                 if self.required:
1024                     raise ValidationError(self.error_messages['required'], code='required')
1025                 else:
1026                     return self.compress([])
1027         else:
1028             raise ValidationError(self.error_messages['invalid'], code='invalid')
1029         for i, field in enumerate(self.fields):
1030             try:
1031                 field_value = value[i]
1032             except IndexError:
1033                 field_value = None
1034             if field_value in self.empty_values:
1035                 if self.require_all_fields:
1036                     # Raise a 'required' error if the MultiValueField is
1037                     # required and any field is empty.
1038                     if self.required:
1039                         raise ValidationError(self.error_messages['required'], code='required')
1040                 elif field.required:
1041                     # Otherwise, add an 'incomplete' error to the list of
1042                     # collected errors and skip field cleaning, if a required
1043                     # field is empty.
1044                     if field.error_messages['incomplete'] not in errors:
1045                         errors.append(field.error_messages['incomplete'])
1046                     continue
1047             try:
1048                 clean_data.append(field.clean(field_value))
1049             except ValidationError as e:
1050                 # Collect all validation errors in a single list, which we'll
1051                 # raise at the end of clean(), rather than raising a single
1052                 # exception for the first error we encounter. Skip duplicates.
1053                 errors.extend(m for m in e.error_list if m not in errors)
1054         if errors:
1055             raise ValidationError(errors)
1056 
1057         out = self.compress(clean_data)
1058         self.validate(out)
1059         self.run_validators(out)
1060         return out
1061 
1062     def compress(self, data_list):
1063         """
1064         Return a single value for the given list of values. The values can be
1065         assumed to be valid.
1066 
1067         For example, if this MultiValueField was instantiated with
1068         fields=(DateField(), TimeField()), this might return a datetime
1069         object created by combining the date and time in data_list.
1070         """
1071         raise NotImplementedError('Subclasses must implement this method.')
1072 
1073     def has_changed(self, initial, data):
1074         if self.disabled:
1075             return False
1076         if initial is None:
1077             initial = ['' for x in range(0, len(data))]
1078         else:
1079             if not isinstance(initial, list):
1080                 initial = self.widget.decompress(initial)
1081         for field, initial, data in zip(self.fields, initial, data):
1082             try:
1083                 initial = field.to_python(initial)
1084             except ValidationError:
1085                 return True
1086             if field.has_changed(initial, data):
1087                 return True
1088         return False
1089 
1090 
1091 class FilePathField(ChoiceField):
1092     def __init__(self, path, *, match=None, recursive=False, allow_files=True,
1093                  allow_folders=False, **kwargs):
1094         self.path, self.match, self.recursive = path, match, recursive
1095         self.allow_files, self.allow_folders = allow_files, allow_folders
1096         super().__init__(choices=(), **kwargs)
1097 
1098         if self.required:
1099             self.choices = []
1100         else:
1101             self.choices = [("", "---------")]
1102 
1103         if self.match is not None:
1104             self.match_re = re.compile(self.match)
1105 
1106         if recursive:
1107             for root, dirs, files in sorted(os.walk(self.path)):
1108                 if self.allow_files:
1109                     for f in sorted(files):
1110                         if self.match is None or self.match_re.search(f):
1111                             f = os.path.join(root, f)
1112                             self.choices.append((f, f.replace(path, "", 1)))
1113                 if self.allow_folders:
1114                     for f in sorted(dirs):
1115                         if f == '__pycache__':
1116                             continue
1117                         if self.match is None or self.match_re.search(f):
1118                             f = os.path.join(root, f)
1119                             self.choices.append((f, f.replace(path, "", 1)))
1120         else:
1121             choices = []
1122             for f in os.scandir(self.path):
1123                 if f.name == '__pycache__':
1124                     continue
1125                 if (((self.allow_files and f.is_file()) or
1126                         (self.allow_folders and f.is_dir())) and
1127                         (self.match is None or self.match_re.search(f.name))):
1128                     choices.append((f.path, f.name))
1129             choices.sort(key=operator.itemgetter(1))
1130             self.choices.extend(choices)
1131 
1132         self.widget.choices = self.choices
1133 
1134 
1135 class SplitDateTimeField(MultiValueField):
1136     widget = SplitDateTimeWidget
1137     hidden_widget = SplitHiddenDateTimeWidget
1138     default_error_messages = {
1139         'invalid_date': _('Enter a valid date.'),
1140         'invalid_time': _('Enter a valid time.'),
1141     }
1142 
1143     def __init__(self, *, input_date_formats=None, input_time_formats=None, **kwargs):
1144         errors = self.default_error_messages.copy()
1145         if 'error_messages' in kwargs:
1146             errors.update(kwargs['error_messages'])
1147         localize = kwargs.get('localize', False)
1148         fields = (
1149             DateField(input_formats=input_date_formats,
1150                       error_messages={'invalid': errors['invalid_date']},
1151                       localize=localize),
1152             TimeField(input_formats=input_time_formats,
1153                       error_messages={'invalid': errors['invalid_time']},
1154                       localize=localize),
1155         )
1156         super().__init__(fields, **kwargs)
1157 
1158     def compress(self, data_list):
1159         if data_list:
1160             # Raise a validation error if time or date is empty
1161             # (possible if SplitDateTimeField has required=False).
1162             if data_list[0] in self.empty_values:
1163                 raise ValidationError(self.error_messages['invalid_date'], code='invalid_date')
1164             if data_list[1] in self.empty_values:
1165                 raise ValidationError(self.error_messages['invalid_time'], code='invalid_time')
1166             result = datetime.datetime.combine(*data_list)
1167             return from_current_timezone(result)
1168         return None
1169 
1170 
1171 class GenericIPAddressField(CharField):
1172     def __init__(self, *, protocol='both', unpack_ipv4=False, **kwargs):
1173         self.unpack_ipv4 = unpack_ipv4
1174         self.default_validators = validators.ip_address_validators(protocol, unpack_ipv4)[0]
1175         super().__init__(**kwargs)
1176 
1177     def to_python(self, value):
1178         if value in self.empty_values:
1179             return ''
1180         value = value.strip()
1181         if value and ':' in value:
1182             return clean_ipv6_address(value, self.unpack_ipv4)
1183         return value
1184 
1185 
1186 class SlugField(CharField):
1187     default_validators = [validators.validate_slug]
1188 
1189     def __init__(self, *, allow_unicode=False, **kwargs):
1190         self.allow_unicode = allow_unicode
1191         if self.allow_unicode:
1192             self.default_validators = [validators.validate_unicode_slug]
1193         super().__init__(**kwargs)
1194 
1195 
1196 class UUIDField(CharField):
1197     default_error_messages = {
1198         'invalid': _('Enter a valid UUID.'),
1199     }
1200 
1201     def prepare_value(self, value):
1202         if isinstance(value, uuid.UUID):
1203             return str(value)
1204         return value
1205 
1206     def to_python(self, value):
1207         value = super().to_python(value)
1208         if value in self.empty_values:
1209             return None
1210         if not isinstance(value, uuid.UUID):
1211             try:
1212                 value = uuid.UUID(value)
1213             except ValueError:
1214                 raise ValidationError(self.error_messages['invalid'], code='invalid')
1215         return value
1216 
1217 
1218 class InvalidJSONInput(str):
1219     pass
1220 
1221 
1222 class JSONString(str):
1223     pass
1224 
1225 
1226 class JSONField(CharField):
1227     default_error_messages = {
1228         'invalid': _('Enter a valid JSON.'),
1229     }
1230     widget = Textarea
1231 
1232     def __init__(self, encoder=None, decoder=None, **kwargs):
1233         self.encoder = encoder
1234         self.decoder = decoder
1235         super().__init__(**kwargs)
1236 
1237     def to_python(self, value):
1238         if self.disabled:
1239             return value
1240         if value in self.empty_values:
1241             return None
1242         elif isinstance(value, (list, dict, int, float, JSONString)):
1243             return value
1244         try:
1245             converted = json.loads(value, cls=self.decoder)
1246         except json.JSONDecodeError:
1247             raise ValidationError(
1248                 self.error_messages['invalid'],
1249                 code='invalid',
1250                 params={'value': value},
1251             )
1252         if isinstance(converted, str):
1253             return JSONString(converted)
1254         else:
1255             return converted
1256 
1257     def bound_data(self, data, initial):
1258         if self.disabled:
1259             return initial
1260         try:
1261             return json.loads(data, cls=self.decoder)
1262         except json.JSONDecodeError:
1263             return InvalidJSONInput(data)
1264 
1265     def prepare_value(self, value):
1266         if isinstance(value, InvalidJSONInput):
1267             return value
1268         return json.dumps(value, cls=self.encoder)
1269 
1270     def has_changed(self, initial, data):
1271         if super().has_changed(initial, data):
1272             return True
1273         # For purposes of seeing whether something has changed, True isn't the
1274         # same as 1 and the order of keys doesn't matter.
1275         return (
1276             json.dumps(initial, sort_keys=True, cls=self.encoder) !=
1277             json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder)
1278         )

</code><intended_behavior>In every method within form field classes that raises a ValidationError, modify the call to pass the field's value to the exception. This ensures that form validation errors can include the specific value that failed validation, aiding in debugging and user feedback.</intended_behavior>, <file>django/db/models/fields/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections.abc
2 import copy
3 import datetime
4 import decimal
5 import operator
6 import uuid
7 import warnings
8 from base64 import b64decode, b64encode
9 from functools import partialmethod, total_ordering
10 
11 from django import forms
12 from django.apps import apps
13 from django.conf import settings
14 from django.core import checks, exceptions, validators
15 from django.db import connection, connections, router
16 from django.db.models.constants import LOOKUP_SEP
17 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin
18 from django.utils import timezone
19 from django.utils.datastructures import DictWrapper
20 from django.utils.dateparse import (
21     parse_date, parse_datetime, parse_duration, parse_time,
22 )
23 from django.utils.duration import duration_microseconds, duration_string
24 from django.utils.functional import Promise, cached_property
25 from django.utils.ipv6 import clean_ipv6_address
26 from django.utils.itercompat import is_iterable
27 from django.utils.text import capfirst
28 from django.utils.translation import gettext_lazy as _
29 
30 __all__ = [
31     'AutoField', 'BLANK_CHOICE_DASH', 'BigAutoField', 'BigIntegerField',
32     'BinaryField', 'BooleanField', 'CharField', 'CommaSeparatedIntegerField',
33     'DateField', 'DateTimeField', 'DecimalField', 'DurationField',
34     'EmailField', 'Empty', 'Field', 'FilePathField', 'FloatField',
35     'GenericIPAddressField', 'IPAddressField', 'IntegerField', 'NOT_PROVIDED',
36     'NullBooleanField', 'PositiveBigIntegerField', 'PositiveIntegerField',
37     'PositiveSmallIntegerField', 'SlugField', 'SmallAutoField',
38     'SmallIntegerField', 'TextField', 'TimeField', 'URLField', 'UUIDField',
39 ]
40 
41 
42 class Empty:
43     pass
44 
45 
46 class NOT_PROVIDED:
47     pass
48 
49 
50 # The values to use for "blank" in SelectFields. Will be appended to the start
51 # of most "choices" lists.
52 BLANK_CHOICE_DASH = [("", "---------")]
53 
54 
55 def _load_field(app_label, model_name, field_name):
56     return apps.get_model(app_label, model_name)._meta.get_field(field_name)
57 
58 
59 # A guide to Field parameters:
60 #
61 #   * name:      The name of the field specified in the model.
62 #   * attname:   The attribute to use on the model object. This is the same as
63 #                "name", except in the case of ForeignKeys, where "_id" is
64 #                appended.
65 #   * db_column: The db_column specified in the model (or None).
66 #   * column:    The database column for this field. This is the same as
67 #                "attname", except if db_column is specified.
68 #
69 # Code that introspects values, or does other dynamic things, should use
70 # attname. For example, this gets the primary key value of object "obj":
71 #
72 #     getattr(obj, opts.pk.attname)
73 
74 def _empty(of_cls):
75     new = Empty()
76     new.__class__ = of_cls
77     return new
78 
79 
80 def return_None():
81     return None
82 
83 
84 @total_ordering
85 class Field(RegisterLookupMixin):
86     """Base class for all field types"""
87 
88     # Designates whether empty strings fundamentally are allowed at the
89     # database level.
90     empty_strings_allowed = True
91     empty_values = list(validators.EMPTY_VALUES)
92 
93     # These track each time a Field instance is created. Used to retain order.
94     # The auto_creation_counter is used for fields that Django implicitly
95     # creates, creation_counter is used for all user-specified fields.
96     creation_counter = 0
97     auto_creation_counter = -1
98     default_validators = []  # Default set of validators
99     default_error_messages = {
100         'invalid_choice': _('Value %(value)r is not a valid choice.'),
101         'null': _('This field cannot be null.'),
102         'blank': _('This field cannot be blank.'),
103         'unique': _('%(model_name)s with this %(field_label)s '
104                     'already exists.'),
105         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.
106         # Eg: "Title must be unique for pub_date year"
107         'unique_for_date': _("%(field_label)s must be unique for "
108                              "%(date_field_label)s %(lookup_type)s."),
109     }
110     system_check_deprecated_details = None
111     system_check_removed_details = None
112 
113     # Field flags
114     hidden = False
115 
116     many_to_many = None
117     many_to_one = None
118     one_to_many = None
119     one_to_one = None
120     related_model = None
121 
122     descriptor_class = DeferredAttribute
123 
124     # Generic field type description, usually overridden by subclasses
125     def _description(self):
126         return _('Field of type: %(field_type)s') % {
127             'field_type': self.__class__.__name__
128         }
129     description = property(_description)
130 
131     def __init__(self, verbose_name=None, name=None, primary_key=False,
132                  max_length=None, unique=False, blank=False, null=False,
133                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,
134                  serialize=True, unique_for_date=None, unique_for_month=None,
135                  unique_for_year=None, choices=None, help_text='', db_column=None,
136                  db_tablespace=None, auto_created=False, validators=(),
137                  error_messages=None):
138         self.name = name
139         self.verbose_name = verbose_name  # May be set by set_attributes_from_name
140         self._verbose_name = verbose_name  # Store original for deconstruction
141         self.primary_key = primary_key
142         self.max_length, self._unique = max_length, unique
143         self.blank, self.null = blank, null
144         self.remote_field = rel
145         self.is_relation = self.remote_field is not None
146         self.default = default
147         self.editable = editable
148         self.serialize = serialize
149         self.unique_for_date = unique_for_date
150         self.unique_for_month = unique_for_month
151         self.unique_for_year = unique_for_year
152         if isinstance(choices, collections.abc.Iterator):
153             choices = list(choices)
154         self.choices = choices
155         self.help_text = help_text
156         self.db_index = db_index
157         self.db_column = db_column
158         self._db_tablespace = db_tablespace
159         self.auto_created = auto_created
160 
161         # Adjust the appropriate creation counter, and save our local copy.
162         if auto_created:
163             self.creation_counter = Field.auto_creation_counter
164             Field.auto_creation_counter -= 1
165         else:
166             self.creation_counter = Field.creation_counter
167             Field.creation_counter += 1
168 
169         self._validators = list(validators)  # Store for deconstruction later
170 
171         messages = {}
172         for c in reversed(self.__class__.__mro__):
173             messages.update(getattr(c, 'default_error_messages', {}))
174         messages.update(error_messages or {})
175         self._error_messages = error_messages  # Store for deconstruction later
176         self.error_messages = messages
177 
178     def __str__(self):
179         """
180         Return "app_label.model_label.field_name" for fields attached to
181         models.
182         """
183         if not hasattr(self, 'model'):
184             return super().__str__()
185         model = self.model
186         app = model._meta.app_label
187         return '%s.%s.%s' % (app, model._meta.object_name, self.name)
188 
189     def __repr__(self):
190         """Display the module, class, and name of the field."""
191         path = '%s.%s' % (self.__class__.__module__, self.__class__.__qualname__)
192         name = getattr(self, 'name', None)
193         if name is not None:
194             return '<%s: %s>' % (path, name)
195         return '<%s>' % path
196 
197     def check(self, **kwargs):
198         return [
199             *self._check_field_name(),
200             *self._check_choices(),
201             *self._check_db_index(),
202             *self._check_null_allowed_for_primary_keys(),
203             *self._check_backend_specific_checks(**kwargs),
204             *self._check_validators(),
205             *self._check_deprecation_details(),
206         ]
207 
208     def _check_field_name(self):
209         """
210         Check if field name is valid, i.e. 1) does not end with an
211         underscore, 2) does not contain "__" and 3) is not "pk".
212         """
213         if self.name.endswith('_'):
214             return [
215                 checks.Error(
216                     'Field names must not end with an underscore.',
217                     obj=self,
218                     id='fields.E001',
219                 )
220             ]
221         elif LOOKUP_SEP in self.name:
222             return [
223                 checks.Error(
224                     'Field names must not contain "%s".' % LOOKUP_SEP,
225                     obj=self,
226                     id='fields.E002',
227                 )
228             ]
229         elif self.name == 'pk':
230             return [
231                 checks.Error(
232                     "'pk' is a reserved word that cannot be used as a field name.",
233                     obj=self,
234                     id='fields.E003',
235                 )
236             ]
237         else:
238             return []
239 
240     @classmethod
241     def _choices_is_value(cls, value):
242         return isinstance(value, (str, Promise)) or not is_iterable(value)
243 
244     def _check_choices(self):
245         if not self.choices:
246             return []
247 
248         if not is_iterable(self.choices) or isinstance(self.choices, str):
249             return [
250                 checks.Error(
251                     "'choices' must be an iterable (e.g., a list or tuple).",
252                     obj=self,
253                     id='fields.E004',
254                 )
255             ]
256 
257         choice_max_length = 0
258         # Expect [group_name, [value, display]]
259         for choices_group in self.choices:
260             try:
261                 group_name, group_choices = choices_group
262             except (TypeError, ValueError):
263                 # Containing non-pairs
264                 break
265             try:
266                 if not all(
267                     self._choices_is_value(value) and self._choices_is_value(human_name)
268                     for value, human_name in group_choices
269                 ):
270                     break
271                 if self.max_length is not None and group_choices:
272                     choice_max_length = max([
273                         choice_max_length,
274                         *(len(value) for value, _ in group_choices if isinstance(value, str)),
275                     ])
276             except (TypeError, ValueError):
277                 # No groups, choices in the form [value, display]
278                 value, human_name = group_name, group_choices
279                 if not self._choices_is_value(value) or not self._choices_is_value(human_name):
280                     break
281                 if self.max_length is not None and isinstance(value, str):
282                     choice_max_length = max(choice_max_length, len(value))
283 
284             # Special case: choices=['ab']
285             if isinstance(choices_group, str):
286                 break
287         else:
288             if self.max_length is not None and choice_max_length > self.max_length:
289                 return [
290                     checks.Error(
291                         "'max_length' is too small to fit the longest value "
292                         "in 'choices' (%d characters)." % choice_max_length,
293                         obj=self,
294                         id='fields.E009',
295                     ),
296                 ]
297             return []
298 
299         return [
300             checks.Error(
301                 "'choices' must be an iterable containing "
302                 "(actual value, human readable name) tuples.",
303                 obj=self,
304                 id='fields.E005',
305             )
306         ]
307 
308     def _check_db_index(self):
309         if self.db_index not in (None, True, False):
310             return [
311                 checks.Error(
312                     "'db_index' must be None, True or False.",
313                     obj=self,
314                     id='fields.E006',
315                 )
316             ]
317         else:
318             return []
319 
320     def _check_null_allowed_for_primary_keys(self):
321         if (self.primary_key and self.null and
322                 not connection.features.interprets_empty_strings_as_nulls):
323             # We cannot reliably check this for backends like Oracle which
324             # consider NULL and '' to be equal (and thus set up
325             # character-based fields a little differently).
326             return [
327                 checks.Error(
328                     'Primary keys must not have null=True.',
329                     hint=('Set null=False on the field, or '
330                           'remove primary_key=True argument.'),
331                     obj=self,
332                     id='fields.E007',
333                 )
334             ]
335         else:
336             return []
337 
338     def _check_backend_specific_checks(self, databases=None, **kwargs):
339         if databases is None:
340             return []
341         app_label = self.model._meta.app_label
342         errors = []
343         for alias in databases:
344             if router.allow_migrate(alias, app_label, model_name=self.model._meta.model_name):
345                 errors.extend(connections[alias].validation.check_field(self, **kwargs))
346         return errors
347 
348     def _check_validators(self):
349         errors = []
350         for i, validator in enumerate(self.validators):
351             if not callable(validator):
352                 errors.append(
353                     checks.Error(
354                         "All 'validators' must be callable.",
355                         hint=(
356                             "validators[{i}] ({repr}) isn't a function or "
357                             "instance of a validator class.".format(
358                                 i=i, repr=repr(validator),
359                             )
360                         ),
361                         obj=self,
362                         id='fields.E008',
363                     )
364                 )
365         return errors
366 
367     def _check_deprecation_details(self):
368         if self.system_check_removed_details is not None:
369             return [
370                 checks.Error(
371                     self.system_check_removed_details.get(
372                         'msg',
373                         '%s has been removed except for support in historical '
374                         'migrations.' % self.__class__.__name__
375                     ),
376                     hint=self.system_check_removed_details.get('hint'),
377                     obj=self,
378                     id=self.system_check_removed_details.get('id', 'fields.EXXX'),
379                 )
380             ]
381         elif self.system_check_deprecated_details is not None:
382             return [
383                 checks.Warning(
384                     self.system_check_deprecated_details.get(
385                         'msg',
386                         '%s has been deprecated.' % self.__class__.__name__
387                     ),
388                     hint=self.system_check_deprecated_details.get('hint'),
389                     obj=self,
390                     id=self.system_check_deprecated_details.get('id', 'fields.WXXX'),
391                 )
392             ]
393         return []
394 
395     def get_col(self, alias, output_field=None):
396         if output_field is None:
397             output_field = self
398         if alias != self.model._meta.db_table or output_field != self:
399             from django.db.models.expressions import Col
400             return Col(alias, self, output_field)
401         else:
402             return self.cached_col
403 
404     @cached_property
405     def cached_col(self):
406         from django.db.models.expressions import Col
407         return Col(self.model._meta.db_table, self)
408 
409     def select_format(self, compiler, sql, params):
410         """
411         Custom format for select clauses. For example, GIS columns need to be
412         selected as AsText(table.col) on MySQL as the table.col data can't be
413         used by Django.
414         """
415         return sql, params
416 
417     def deconstruct(self):
418         """
419         Return enough information to recreate the field as a 4-tuple:
420 
421          * The name of the field on the model, if contribute_to_class() has
422            been run.
423          * The import path of the field, including the class:e.g.
424            django.db.models.IntegerField This should be the most portable
425            version, so less specific may be better.
426          * A list of positional arguments.
427          * A dict of keyword arguments.
428 
429         Note that the positional or keyword arguments must contain values of
430         the following types (including inner values of collection types):
431 
432          * None, bool, str, int, float, complex, set, frozenset, list, tuple,
433            dict
434          * UUID
435          * datetime.datetime (naive), datetime.date
436          * top-level classes, top-level functions - will be referenced by their
437            full import path
438          * Storage instances - these have their own deconstruct() method
439 
440         This is because the values here must be serialized into a text format
441         (possibly new Python code, possibly JSON) and these are the only types
442         with encoding handlers defined.
443 
444         There's no need to return the exact way the field was instantiated this
445         time, just ensure that the resulting field is the same - prefer keyword
446         arguments over positional ones, and omit parameters with their default
447         values.
448         """
449         # Short-form way of fetching all the default parameters
450         keywords = {}
451         possibles = {
452             "verbose_name": None,
453             "primary_key": False,
454             "max_length": None,
455             "unique": False,
456             "blank": False,
457             "null": False,
458             "db_index": False,
459             "default": NOT_PROVIDED,
460             "editable": True,
461             "serialize": True,
462             "unique_for_date": None,
463             "unique_for_month": None,
464             "unique_for_year": None,
465             "choices": None,
466             "help_text": '',
467             "db_column": None,
468             "db_tablespace": None,
469             "auto_created": False,
470             "validators": [],
471             "error_messages": None,
472         }
473         attr_overrides = {
474             "unique": "_unique",
475             "error_messages": "_error_messages",
476             "validators": "_validators",
477             "verbose_name": "_verbose_name",
478             "db_tablespace": "_db_tablespace",
479         }
480         equals_comparison = {"choices", "validators"}
481         for name, default in possibles.items():
482             value = getattr(self, attr_overrides.get(name, name))
483             # Unroll anything iterable for choices into a concrete list
484             if name == "choices" and isinstance(value, collections.abc.Iterable):
485                 value = list(value)
486             # Do correct kind of comparison
487             if name in equals_comparison:
488                 if value != default:
489                     keywords[name] = value
490             else:
491                 if value is not default:
492                     keywords[name] = value
493         # Work out path - we shorten it for known Django core fields
494         path = "%s.%s" % (self.__class__.__module__, self.__class__.__qualname__)
495         if path.startswith("django.db.models.fields.related"):
496             path = path.replace("django.db.models.fields.related", "django.db.models")
497         elif path.startswith("django.db.models.fields.files"):
498             path = path.replace("django.db.models.fields.files", "django.db.models")
499         elif path.startswith('django.db.models.fields.json'):
500             path = path.replace('django.db.models.fields.json', 'django.db.models')
501         elif path.startswith("django.db.models.fields.proxy"):
502             path = path.replace("django.db.models.fields.proxy", "django.db.models")
503         elif path.startswith("django.db.models.fields"):
504             path = path.replace("django.db.models.fields", "django.db.models")
505         # Return basic info - other fields should override this.
506         return (self.name, path, [], keywords)
507 
508     def clone(self):
509         """
510         Uses deconstruct() to clone a new copy of this Field.
511         Will not preserve any class attachments/attribute names.
512         """
513         name, path, args, kwargs = self.deconstruct()
514         return self.__class__(*args, **kwargs)
515 
516     def __eq__(self, other):
517         # Needed for @total_ordering
518         if isinstance(other, Field):
519             return self.creation_counter == other.creation_counter
520         return NotImplemented
521 
522     def __lt__(self, other):
523         # This is needed because bisect does not take a comparison function.
524         if isinstance(other, Field):
525             return self.creation_counter < other.creation_counter
526         return NotImplemented
527 
528     def __hash__(self):
529         return hash(self.creation_counter)
530 
531     def __deepcopy__(self, memodict):
532         # We don't have to deepcopy very much here, since most things are not
533         # intended to be altered after initial creation.
534         obj = copy.copy(self)
535         if self.remote_field:
536             obj.remote_field = copy.copy(self.remote_field)
537             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:
538                 obj.remote_field.field = obj
539         memodict[id(self)] = obj
540         return obj
541 
542     def __copy__(self):
543         # We need to avoid hitting __reduce__, so define this
544         # slightly weird copy construct.
545         obj = Empty()
546         obj.__class__ = self.__class__
547         obj.__dict__ = self.__dict__.copy()
548         return obj
549 
550     def __reduce__(self):
551         """
552         Pickling should return the model._meta.fields instance of the field,
553         not a new copy of that field. So, use the app registry to load the
554         model and then the field back.
555         """
556         if not hasattr(self, 'model'):
557             # Fields are sometimes used without attaching them to models (for
558             # example in aggregation). In this case give back a plain field
559             # instance. The code below will create a new empty instance of
560             # class self.__class__, then update its dict with self.__dict__
561             # values - so, this is very close to normal pickle.
562             state = self.__dict__.copy()
563             # The _get_default cached_property can't be pickled due to lambda
564             # usage.
565             state.pop('_get_default', None)
566             return _empty, (self.__class__,), state
567         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,
568                              self.name)
569 
570     def get_pk_value_on_save(self, instance):
571         """
572         Hook to generate new PK values on save. This method is called when
573         saving instances with no primary key value set. If this method returns
574         something else than None, then the returned value is used when saving
575         the new instance.
576         """
577         if self.default:
578             return self.get_default()
579         return None
580 
581     def to_python(self, value):
582         """
583         Convert the input value into the expected Python data type, raising
584         django.core.exceptions.ValidationError if the data can't be converted.
585         Return the converted value. Subclasses should override this.
586         """
587         return value
588 
589     @cached_property
590     def validators(self):
591         """
592         Some validators can't be created at field initialization time.
593         This method provides a way to delay their creation until required.
594         """
595         return [*self.default_validators, *self._validators]
596 
597     def run_validators(self, value):
598         if value in self.empty_values:
599             return
600 
601         errors = []
602         for v in self.validators:
603             try:
604                 v(value)
605             except exceptions.ValidationError as e:
606                 if hasattr(e, 'code') and e.code in self.error_messages:
607                     e.message = self.error_messages[e.code]
608                 errors.extend(e.error_list)
609 
610         if errors:
611             raise exceptions.ValidationError(errors)
612 
613     def validate(self, value, model_instance):
614         """
615         Validate value and raise ValidationError if necessary. Subclasses
616         should override this to provide validation logic.
617         """
618         if not self.editable:
619             # Skip validation for non-editable fields.
620             return
621 
622         if self.choices is not None and value not in self.empty_values:
623             for option_key, option_value in self.choices:
624                 if isinstance(option_value, (list, tuple)):
625                     # This is an optgroup, so look inside the group for
626                     # options.
627                     for optgroup_key, optgroup_value in option_value:
628                         if value == optgroup_key:
629                             return
630                 elif value == option_key:
631                     return
632             raise exceptions.ValidationError(
633                 self.error_messages['invalid_choice'],
634                 code='invalid_choice',
635                 params={'value': value},
636             )
637 
638         if value is None and not self.null:
639             raise exceptions.ValidationError(self.error_messages['null'], code='null')
640 
641         if not self.blank and value in self.empty_values:
642             raise exceptions.ValidationError(self.error_messages['blank'], code='blank')
643 
644     def clean(self, value, model_instance):
645         """
646         Convert the value's type and run validation. Validation errors
647         from to_python() and validate() are propagated. Return the correct
648         value if no error is raised.
649         """
650         value = self.to_python(value)
651         self.validate(value, model_instance)
652         self.run_validators(value)
653         return value
654 
655     def db_type_parameters(self, connection):
656         return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')
657 
658     def db_check(self, connection):
659         """
660         Return the database column check constraint for this field, for the
661         provided connection. Works the same way as db_type() for the case that
662         get_internal_type() does not map to a preexisting model field.
663         """
664         data = self.db_type_parameters(connection)
665         try:
666             return connection.data_type_check_constraints[self.get_internal_type()] % data
667         except KeyError:
668             return None
669 
670     def db_type(self, connection):
671         """
672         Return the database column data type for this field, for the provided
673         connection.
674         """
675         # The default implementation of this method looks at the
676         # backend-specific data_types dictionary, looking up the field by its
677         # "internal type".
678         #
679         # A Field class can implement the get_internal_type() method to specify
680         # which *preexisting* Django Field class it's most similar to -- i.e.,
681         # a custom field might be represented by a TEXT column type, which is
682         # the same as the TextField Django field type, which means the custom
683         # field's get_internal_type() returns 'TextField'.
684         #
685         # But the limitation of the get_internal_type() / data_types approach
686         # is that it cannot handle database column types that aren't already
687         # mapped to one of the built-in Django field types. In this case, you
688         # can implement db_type() instead of get_internal_type() to specify
689         # exactly which wacky database column type you want to use.
690         data = self.db_type_parameters(connection)
691         try:
692             return connection.data_types[self.get_internal_type()] % data
693         except KeyError:
694             return None
695 
696     def rel_db_type(self, connection):
697         """
698         Return the data type that a related field pointing to this field should
699         use. For example, this method is called by ForeignKey and OneToOneField
700         to determine its data type.
701         """
702         return self.db_type(connection)
703 
704     def cast_db_type(self, connection):
705         """Return the data type to use in the Cast() function."""
706         db_type = connection.ops.cast_data_types.get(self.get_internal_type())
707         if db_type:
708             return db_type % self.db_type_parameters(connection)
709         return self.db_type(connection)
710 
711     def db_parameters(self, connection):
712         """
713         Extension of db_type(), providing a range of different return values
714         (type, checks). This will look at db_type(), allowing custom model
715         fields to override it.
716         """
717         type_string = self.db_type(connection)
718         check_string = self.db_check(connection)
719         return {
720             "type": type_string,
721             "check": check_string,
722         }
723 
724     def db_type_suffix(self, connection):
725         return connection.data_types_suffix.get(self.get_internal_type())
726 
727     def get_db_converters(self, connection):
728         if hasattr(self, 'from_db_value'):
729             return [self.from_db_value]
730         return []
731 
732     @property
733     def unique(self):
734         return self._unique or self.primary_key
735 
736     @property
737     def db_tablespace(self):
738         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE
739 
740     @property
741     def db_returning(self):
742         """
743         Private API intended only to be used by Django itself. Currently only
744         the PostgreSQL backend supports returning multiple fields on a model.
745         """
746         return False
747 
748     def set_attributes_from_name(self, name):
749         self.name = self.name or name
750         self.attname, self.column = self.get_attname_column()
751         self.concrete = self.column is not None
752         if self.verbose_name is None and self.name:
753             self.verbose_name = self.name.replace('_', ' ')
754 
755     def contribute_to_class(self, cls, name, private_only=False):
756         """
757         Register the field with the model class it belongs to.
758 
759         If private_only is True, create a separate instance of this field
760         for every subclass of cls, even if cls is not an abstract model.
761         """
762         self.set_attributes_from_name(name)
763         self.model = cls
764         cls._meta.add_field(self, private=private_only)
765         if self.column:
766             # Don't override classmethods with the descriptor. This means that
767             # if you have a classmethod and a field with the same name, then
768             # such fields can't be deferred (we don't have a check for this).
769             if not getattr(cls, self.attname, None):
770                 setattr(cls, self.attname, self.descriptor_class(self))
771         if self.choices is not None:
772             # Don't override a get_FOO_display() method defined explicitly on
773             # this class, but don't check methods derived from inheritance, to
774             # allow overriding inherited choices. For more complex inheritance
775             # structures users should override contribute_to_class().
776             if 'get_%s_display' % self.name not in cls.__dict__:
777                 setattr(
778                     cls,
779                     'get_%s_display' % self.name,
780                     partialmethod(cls._get_FIELD_display, field=self),
781                 )
782 
783     def get_filter_kwargs_for_object(self, obj):
784         """
785         Return a dict that when passed as kwargs to self.model.filter(), would
786         yield all instances having the same value for this field as obj has.
787         """
788         return {self.name: getattr(obj, self.attname)}
789 
790     def get_attname(self):
791         return self.name
792 
793     def get_attname_column(self):
794         attname = self.get_attname()
795         column = self.db_column or attname
796         return attname, column
797 
798     def get_internal_type(self):
799         return self.__class__.__name__
800 
801     def pre_save(self, model_instance, add):
802         """Return field's value just before saving."""
803         return getattr(model_instance, self.attname)
804 
805     def get_prep_value(self, value):
806         """Perform preliminary non-db specific value checks and conversions."""
807         if isinstance(value, Promise):
808             value = value._proxy____cast()
809         return value
810 
811     def get_db_prep_value(self, value, connection, prepared=False):
812         """
813         Return field's value prepared for interacting with the database backend.
814 
815         Used by the default implementations of get_db_prep_save().
816         """
817         if not prepared:
818             value = self.get_prep_value(value)
819         return value
820 
821     def get_db_prep_save(self, value, connection):
822         """Return field's value prepared for saving into a database."""
823         return self.get_db_prep_value(value, connection=connection, prepared=False)
824 
825     def has_default(self):
826         """Return a boolean of whether this field has a default value."""
827         return self.default is not NOT_PROVIDED
828 
829     def get_default(self):
830         """Return the default value for this field."""
831         return self._get_default()
832 
833     @cached_property
834     def _get_default(self):
835         if self.has_default():
836             if callable(self.default):
837                 return self.default
838             return lambda: self.default
839 
840         if not self.empty_strings_allowed or self.null and not connection.features.interprets_empty_strings_as_nulls:
841             return return_None
842         return str  # return empty string
843 
844     def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH, limit_choices_to=None, ordering=()):
845         """
846         Return choices with a default blank choices included, for use
847         as <select> choices for this field.
848         """
849         if self.choices is not None:
850             choices = list(self.choices)
851             if include_blank:
852                 blank_defined = any(choice in ('', None) for choice, _ in self.flatchoices)
853                 if not blank_defined:
854                     choices = blank_choice + choices
855             return choices
856         rel_model = self.remote_field.model
857         limit_choices_to = limit_choices_to or self.get_limit_choices_to()
858         choice_func = operator.attrgetter(
859             self.remote_field.get_related_field().attname
860             if hasattr(self.remote_field, 'get_related_field')
861             else 'pk'
862         )
863         qs = rel_model._default_manager.complex_filter(limit_choices_to)
864         if ordering:
865             qs = qs.order_by(*ordering)
866         return (blank_choice if include_blank else []) + [
867             (choice_func(x), str(x)) for x in qs
868         ]
869 
870     def value_to_string(self, obj):
871         """
872         Return a string value of this field from the passed obj.
873         This is used by the serialization framework.
874         """
875         return str(self.value_from_object(obj))
876 
877     def _get_flatchoices(self):
878         """Flattened version of choices tuple."""
879         if self.choices is None:
880             return []
881         flat = []
882         for choice, value in self.choices:
883             if isinstance(value, (list, tuple)):
884                 flat.extend(value)
885             else:
886                 flat.append((choice, value))
887         return flat
888     flatchoices = property(_get_flatchoices)
889 
890     def save_form_data(self, instance, data):
891         setattr(instance, self.name, data)
892 
893     def formfield(self, form_class=None, choices_form_class=None, **kwargs):
894         """Return a django.forms.Field instance for this field."""
895         defaults = {
896             'required': not self.blank,
897             'label': capfirst(self.verbose_name),
898             'help_text': self.help_text,
899         }
900         if self.has_default():
901             if callable(self.default):
902                 defaults['initial'] = self.default
903                 defaults['show_hidden_initial'] = True
904             else:
905                 defaults['initial'] = self.get_default()
906         if self.choices is not None:
907             # Fields with choices get special treatment.
908             include_blank = (self.blank or
909                              not (self.has_default() or 'initial' in kwargs))
910             defaults['choices'] = self.get_choices(include_blank=include_blank)
911             defaults['coerce'] = self.to_python
912             if self.null:
913                 defaults['empty_value'] = None
914             if choices_form_class is not None:
915                 form_class = choices_form_class
916             else:
917                 form_class = forms.TypedChoiceField
918             # Many of the subclass-specific formfield arguments (min_value,
919             # max_value) don't apply for choice fields, so be sure to only pass
920             # the values that TypedChoiceField will understand.
921             for k in list(kwargs):
922                 if k not in ('coerce', 'empty_value', 'choices', 'required',
923                              'widget', 'label', 'initial', 'help_text',
924                              'error_messages', 'show_hidden_initial', 'disabled'):
925                     del kwargs[k]
926         defaults.update(kwargs)
927         if form_class is None:
928             form_class = forms.CharField
929         return form_class(**defaults)
930 
931     def value_from_object(self, obj):
932         """Return the value of this field in the given model instance."""
933         return getattr(obj, self.attname)
934 
935 
936 class BooleanField(Field):
937     empty_strings_allowed = False
938     default_error_messages = {
939         'invalid': _('“%(value)s” value must be either True or False.'),
940         'invalid_nullable': _('“%(value)s” value must be either True, False, or None.'),
941     }
942     description = _("Boolean (Either True or False)")
943 
944     def get_internal_type(self):
945         return "BooleanField"
946 
947     def to_python(self, value):
948         if self.null and value in self.empty_values:
949             return None
950         if value in (True, False):
951             # 1/0 are equal to True/False. bool() converts former to latter.
952             return bool(value)
953         if value in ('t', 'True', '1'):
954             return True
955         if value in ('f', 'False', '0'):
956             return False
957         raise exceptions.ValidationError(
958             self.error_messages['invalid_nullable' if self.null else 'invalid'],
959             code='invalid',
960             params={'value': value},
961         )
962 
963     def get_prep_value(self, value):
964         value = super().get_prep_value(value)
965         if value is None:
966             return None
967         return self.to_python(value)
968 
969     def formfield(self, **kwargs):
970         if self.choices is not None:
971             include_blank = not (self.has_default() or 'initial' in kwargs)
972             defaults = {'choices': self.get_choices(include_blank=include_blank)}
973         else:
974             form_class = forms.NullBooleanField if self.null else forms.BooleanField
975             # In HTML checkboxes, 'required' means "must be checked" which is
976             # different from the choices case ("must select some value").
977             # required=False allows unchecked checkboxes.
978             defaults = {'form_class': form_class, 'required': False}
979         return super().formfield(**{**defaults, **kwargs})
980 
981 
982 class CharField(Field):
983     description = _("String (up to %(max_length)s)")
984 
985     def __init__(self, *args, **kwargs):
986         super().__init__(*args, **kwargs)
987         self.validators.append(validators.MaxLengthValidator(self.max_length))
988 
989     def check(self, **kwargs):
990         return [
991             *super().check(**kwargs),
992             *self._check_max_length_attribute(**kwargs),
993         ]
994 
995     def _check_max_length_attribute(self, **kwargs):
996         if self.max_length is None:
997             return [
998                 checks.Error(
999                     "CharFields must define a 'max_length' attribute.",
1000                     obj=self,
1001                     id='fields.E120',
1002                 )
1003             ]
1004         elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or
1005                 self.max_length <= 0):
1006             return [
1007                 checks.Error(
1008                     "'max_length' must be a positive integer.",
1009                     obj=self,
1010                     id='fields.E121',
1011                 )
1012             ]
1013         else:
1014             return []
1015 
1016     def cast_db_type(self, connection):
1017         if self.max_length is None:
1018             return connection.ops.cast_char_field_without_max_length
1019         return super().cast_db_type(connection)
1020 
1021     def get_internal_type(self):
1022         return "CharField"
1023 
1024     def to_python(self, value):
1025         if isinstance(value, str) or value is None:
1026             return value
1027         return str(value)
1028 
1029     def get_prep_value(self, value):
1030         value = super().get_prep_value(value)
1031         return self.to_python(value)
1032 
1033     def formfield(self, **kwargs):
1034         # Passing max_length to forms.CharField means that the value's length
1035         # will be validated twice. This is considered acceptable since we want
1036         # the value in the form field (to pass into widget for example).
1037         defaults = {'max_length': self.max_length}
1038         # TODO: Handle multiple backends with different feature flags.
1039         if self.null and not connection.features.interprets_empty_strings_as_nulls:
1040             defaults['empty_value'] = None
1041         defaults.update(kwargs)
1042         return super().formfield(**defaults)
1043 
1044 
1045 class CommaSeparatedIntegerField(CharField):
1046     default_validators = [validators.validate_comma_separated_integer_list]
1047     description = _("Comma-separated integers")
1048     system_check_removed_details = {
1049         'msg': (
1050             'CommaSeparatedIntegerField is removed except for support in '
1051             'historical migrations.'
1052         ),
1053         'hint': (
1054             'Use CharField(validators=[validate_comma_separated_integer_list]) '
1055             'instead.'
1056         ),
1057         'id': 'fields.E901',
1058     }
1059 
1060 
1061 class DateTimeCheckMixin:
1062 
1063     def check(self, **kwargs):
1064         return [
1065             *super().check(**kwargs),
1066             *self._check_mutually_exclusive_options(),
1067             *self._check_fix_default_value(),
1068         ]
1069 
1070     def _check_mutually_exclusive_options(self):
1071         # auto_now, auto_now_add, and default are mutually exclusive
1072         # options. The use of more than one of these options together
1073         # will trigger an Error
1074         mutually_exclusive_options = [self.auto_now_add, self.auto_now, self.has_default()]
1075         enabled_options = [option not in (None, False) for option in mutually_exclusive_options].count(True)
1076         if enabled_options > 1:
1077             return [
1078                 checks.Error(
1079                     "The options auto_now, auto_now_add, and default "
1080                     "are mutually exclusive. Only one of these options "
1081                     "may be present.",
1082                     obj=self,
1083                     id='fields.E160',
1084                 )
1085             ]
1086         else:
1087             return []
1088 
1089     def _check_fix_default_value(self):
1090         return []
1091 
1092 
1093 class DateField(DateTimeCheckMixin, Field):
1094     empty_strings_allowed = False
1095     default_error_messages = {
1096         'invalid': _('“%(value)s” value has an invalid date format. It must be '
1097                      'in YYYY-MM-DD format.'),
1098         'invalid_date': _('“%(value)s” value has the correct format (YYYY-MM-DD) '
1099                           'but it is an invalid date.'),
1100     }
1101     description = _("Date (without time)")
1102 
1103     def __init__(self, verbose_name=None, name=None, auto_now=False,
1104                  auto_now_add=False, **kwargs):
1105         self.auto_now, self.auto_now_add = auto_now, auto_now_add
1106         if auto_now or auto_now_add:
1107             kwargs['editable'] = False
1108             kwargs['blank'] = True
1109         super().__init__(verbose_name, name, **kwargs)
1110 
1111     def _check_fix_default_value(self):
1112         """
1113         Warn that using an actual date or datetime value is probably wrong;
1114         it's only evaluated on server startup.
1115         """
1116         if not self.has_default():
1117             return []
1118 
1119         now = timezone.now()
1120         if not timezone.is_naive(now):
1121             now = timezone.make_naive(now, timezone.utc)
1122         value = self.default
1123         if isinstance(value, datetime.datetime):
1124             if not timezone.is_naive(value):
1125                 value = timezone.make_naive(value, timezone.utc)
1126             value = value.date()
1127         elif isinstance(value, datetime.date):
1128             # Nothing to do, as dates don't have tz information
1129             pass
1130         else:
1131             # No explicit date / datetime value -- no checks necessary
1132             return []
1133         offset = datetime.timedelta(days=1)
1134         lower = (now - offset).date()
1135         upper = (now + offset).date()
1136         if lower <= value <= upper:
1137             return [
1138                 checks.Warning(
1139                     'Fixed default value provided.',
1140                     hint='It seems you set a fixed date / time / datetime '
1141                          'value as default for this field. This may not be '
1142                          'what you want. If you want to have the current date '
1143                          'as default, use `django.utils.timezone.now`',
1144                     obj=self,
1145                     id='fields.W161',
1146                 )
1147             ]
1148 
1149         return []
1150 
1151     def deconstruct(self):
1152         name, path, args, kwargs = super().deconstruct()
1153         if self.auto_now:
1154             kwargs['auto_now'] = True
1155         if self.auto_now_add:
1156             kwargs['auto_now_add'] = True
1157         if self.auto_now or self.auto_now_add:
1158             del kwargs['editable']
1159             del kwargs['blank']
1160         return name, path, args, kwargs
1161 
1162     def get_internal_type(self):
1163         return "DateField"
1164 
1165     def to_python(self, value):
1166         if value is None:
1167             return value
1168         if isinstance(value, datetime.datetime):
1169             if settings.USE_TZ and timezone.is_aware(value):
1170                 # Convert aware datetimes to the default time zone
1171                 # before casting them to dates (#17742).
1172                 default_timezone = timezone.get_default_timezone()
1173                 value = timezone.make_naive(value, default_timezone)
1174             return value.date()
1175         if isinstance(value, datetime.date):
1176             return value
1177 
1178         try:
1179             parsed = parse_date(value)
1180             if parsed is not None:
1181                 return parsed
1182         except ValueError:
1183             raise exceptions.ValidationError(
1184                 self.error_messages['invalid_date'],
1185                 code='invalid_date',
1186                 params={'value': value},
1187             )
1188 
1189         raise exceptions.ValidationError(
1190             self.error_messages['invalid'],
1191             code='invalid',
1192             params={'value': value},
1193         )
1194 
1195     def pre_save(self, model_instance, add):
1196         if self.auto_now or (self.auto_now_add and add):
1197             value = datetime.date.today()
1198             setattr(model_instance, self.attname, value)
1199             return value
1200         else:
1201             return super().pre_save(model_instance, add)
1202 
1203     def contribute_to_class(self, cls, name, **kwargs):
1204         super().contribute_to_class(cls, name, **kwargs)
1205         if not self.null:
1206             setattr(
1207                 cls, 'get_next_by_%s' % self.name,
1208                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=True)
1209             )
1210             setattr(
1211                 cls, 'get_previous_by_%s' % self.name,
1212                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=False)
1213             )
1214 
1215     def get_prep_value(self, value):
1216         value = super().get_prep_value(value)
1217         return self.to_python(value)
1218 
1219     def get_db_prep_value(self, value, connection, prepared=False):
1220         # Casts dates into the format expected by the backend
1221         if not prepared:
1222             value = self.get_prep_value(value)
1223         return connection.ops.adapt_datefield_value(value)
1224 
1225     def value_to_string(self, obj):
1226         val = self.value_from_object(obj)
1227         return '' if val is None else val.isoformat()
1228 
1229     def formfield(self, **kwargs):
1230         return super().formfield(**{
1231             'form_class': forms.DateField,
1232             **kwargs,
1233         })
1234 
1235 
1236 class DateTimeField(DateField):
1237     empty_strings_allowed = False
1238     default_error_messages = {
1239         'invalid': _('“%(value)s” value has an invalid format. It must be in '
1240                      'YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format.'),
1241         'invalid_date': _("“%(value)s” value has the correct format "
1242                           "(YYYY-MM-DD) but it is an invalid date."),
1243         'invalid_datetime': _('“%(value)s” value has the correct format '
1244                               '(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) '
1245                               'but it is an invalid date/time.'),
1246     }
1247     description = _("Date (with time)")
1248 
1249     # __init__ is inherited from DateField
1250 
1251     def _check_fix_default_value(self):
1252         """
1253         Warn that using an actual date or datetime value is probably wrong;
1254         it's only evaluated on server startup.
1255         """
1256         if not self.has_default():
1257             return []
1258 
1259         now = timezone.now()
1260         if not timezone.is_naive(now):
1261             now = timezone.make_naive(now, timezone.utc)
1262         value = self.default
1263         if isinstance(value, datetime.datetime):
1264             second_offset = datetime.timedelta(seconds=10)
1265             lower = now - second_offset
1266             upper = now + second_offset
1267             if timezone.is_aware(value):
1268                 value = timezone.make_naive(value, timezone.utc)
1269         elif isinstance(value, datetime.date):
1270             second_offset = datetime.timedelta(seconds=10)
1271             lower = now - second_offset
1272             lower = datetime.datetime(lower.year, lower.month, lower.day)
1273             upper = now + second_offset
1274             upper = datetime.datetime(upper.year, upper.month, upper.day)
1275             value = datetime.datetime(value.year, value.month, value.day)
1276         else:
1277             # No explicit date / datetime value -- no checks necessary
1278             return []
1279         if lower <= value <= upper:
1280             return [
1281                 checks.Warning(
1282                     'Fixed default value provided.',
1283                     hint='It seems you set a fixed date / time / datetime '
1284                          'value as default for this field. This may not be '
1285                          'what you want. If you want to have the current date '
1286                          'as default, use `django.utils.timezone.now`',
1287                     obj=self,
1288                     id='fields.W161',
1289                 )
1290             ]
1291 
1292         return []
1293 
1294     def get_internal_type(self):
1295         return "DateTimeField"
1296 
1297     def to_python(self, value):
1298         if value is None:
1299             return value
1300         if isinstance(value, datetime.datetime):
1301             return value
1302         if isinstance(value, datetime.date):
1303             value = datetime.datetime(value.year, value.month, value.day)
1304             if settings.USE_TZ:
1305                 # For backwards compatibility, interpret naive datetimes in
1306                 # local time. This won't work during DST change, but we can't
1307                 # do much about it, so we let the exceptions percolate up the
1308                 # call stack.
1309                 warnings.warn("DateTimeField %s.%s received a naive datetime "
1310                               "(%s) while time zone support is active." %
1311                               (self.model.__name__, self.name, value),
1312                               RuntimeWarning)
1313                 default_timezone = timezone.get_default_timezone()
1314                 value = timezone.make_aware(value, default_timezone)
1315             return value
1316 
1317         try:
1318             parsed = parse_datetime(value)
1319             if parsed is not None:
1320                 return parsed
1321         except ValueError:
1322             raise exceptions.ValidationError(
1323                 self.error_messages['invalid_datetime'],
1324                 code='invalid_datetime',
1325                 params={'value': value},
1326             )
1327 
1328         try:
1329             parsed = parse_date(value)
1330             if parsed is not None:
1331                 return datetime.datetime(parsed.year, parsed.month, parsed.day)
1332         except ValueError:
1333             raise exceptions.ValidationError(
1334                 self.error_messages['invalid_date'],
1335                 code='invalid_date',
1336                 params={'value': value},
1337             )
1338 
1339         raise exceptions.ValidationError(
1340             self.error_messages['invalid'],
1341             code='invalid',
1342             params={'value': value},
1343         )
1344 
1345     def pre_save(self, model_instance, add):
1346         if self.auto_now or (self.auto_now_add and add):
1347             value = timezone.now()
1348             setattr(model_instance, self.attname, value)
1349             return value
1350         else:
1351             return super().pre_save(model_instance, add)
1352 
1353     # contribute_to_class is inherited from DateField, it registers
1354     # get_next_by_FOO and get_prev_by_FOO
1355 
1356     def get_prep_value(self, value):
1357         value = super().get_prep_value(value)
1358         value = self.to_python(value)
1359         if value is not None and settings.USE_TZ and timezone.is_naive(value):
1360             # For backwards compatibility, interpret naive datetimes in local
1361             # time. This won't work during DST change, but we can't do much
1362             # about it, so we let the exceptions percolate up the call stack.
1363             try:
1364                 name = '%s.%s' % (self.model.__name__, self.name)
1365             except AttributeError:
1366                 name = '(unbound)'
1367             warnings.warn("DateTimeField %s received a naive datetime (%s)"
1368                           " while time zone support is active." %
1369                           (name, value),
1370                           RuntimeWarning)
1371             default_timezone = timezone.get_default_timezone()
1372             value = timezone.make_aware(value, default_timezone)
1373         return value
1374 
1375     def get_db_prep_value(self, value, connection, prepared=False):
1376         # Casts datetimes into the format expected by the backend
1377         if not prepared:
1378             value = self.get_prep_value(value)
1379         return connection.ops.adapt_datetimefield_value(value)
1380 
1381     def value_to_string(self, obj):
1382         val = self.value_from_object(obj)
1383         return '' if val is None else val.isoformat()
1384 
1385     def formfield(self, **kwargs):
1386         return super().formfield(**{
1387             'form_class': forms.DateTimeField,
1388             **kwargs,
1389         })
1390 
1391 
1392 class DecimalField(Field):
1393     empty_strings_allowed = False
1394     default_error_messages = {
1395         'invalid': _('“%(value)s” value must be a decimal number.'),
1396     }
1397     description = _("Decimal number")
1398 
1399     def __init__(self, verbose_name=None, name=None, max_digits=None,
1400                  decimal_places=None, **kwargs):
1401         self.max_digits, self.decimal_places = max_digits, decimal_places
1402         super().__init__(verbose_name, name, **kwargs)
1403 
1404     def check(self, **kwargs):
1405         errors = super().check(**kwargs)
1406 
1407         digits_errors = [
1408             *self._check_decimal_places(),
1409             *self._check_max_digits(),
1410         ]
1411         if not digits_errors:
1412             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))
1413         else:
1414             errors.extend(digits_errors)
1415         return errors
1416 
1417     def _check_decimal_places(self):
1418         try:
1419             decimal_places = int(self.decimal_places)
1420             if decimal_places < 0:
1421                 raise ValueError()
1422         except TypeError:
1423             return [
1424                 checks.Error(
1425                     "DecimalFields must define a 'decimal_places' attribute.",
1426                     obj=self,
1427                     id='fields.E130',
1428                 )
1429             ]
1430         except ValueError:
1431             return [
1432                 checks.Error(
1433                     "'decimal_places' must be a non-negative integer.",
1434                     obj=self,
1435                     id='fields.E131',
1436                 )
1437             ]
1438         else:
1439             return []
1440 
1441     def _check_max_digits(self):
1442         try:
1443             max_digits = int(self.max_digits)
1444             if max_digits <= 0:
1445                 raise ValueError()
1446         except TypeError:
1447             return [
1448                 checks.Error(
1449                     "DecimalFields must define a 'max_digits' attribute.",
1450                     obj=self,
1451                     id='fields.E132',
1452                 )
1453             ]
1454         except ValueError:
1455             return [
1456                 checks.Error(
1457                     "'max_digits' must be a positive integer.",
1458                     obj=self,
1459                     id='fields.E133',
1460                 )
1461             ]
1462         else:
1463             return []
1464 
1465     def _check_decimal_places_and_max_digits(self, **kwargs):
1466         if int(self.decimal_places) > int(self.max_digits):
1467             return [
1468                 checks.Error(
1469                     "'max_digits' must be greater or equal to 'decimal_places'.",
1470                     obj=self,
1471                     id='fields.E134',
1472                 )
1473             ]
1474         return []
1475 
1476     @cached_property
1477     def validators(self):
1478         return super().validators + [
1479             validators.DecimalValidator(self.max_digits, self.decimal_places)
1480         ]
1481 
1482     @cached_property
1483     def context(self):
1484         return decimal.Context(prec=self.max_digits)
1485 
1486     def deconstruct(self):
1487         name, path, args, kwargs = super().deconstruct()
1488         if self.max_digits is not None:
1489             kwargs['max_digits'] = self.max_digits
1490         if self.decimal_places is not None:
1491             kwargs['decimal_places'] = self.decimal_places
1492         return name, path, args, kwargs
1493 
1494     def get_internal_type(self):
1495         return "DecimalField"
1496 
1497     def to_python(self, value):
1498         if value is None:
1499             return value
1500         if isinstance(value, float):
1501             return self.context.create_decimal_from_float(value)
1502         try:
1503             return decimal.Decimal(value)
1504         except (decimal.InvalidOperation, TypeError, ValueError):
1505             raise exceptions.ValidationError(
1506                 self.error_messages['invalid'],
1507                 code='invalid',
1508                 params={'value': value},
1509             )
1510 
1511     def get_db_prep_save(self, value, connection):
1512         return connection.ops.adapt_decimalfield_value(self.to_python(value), self.max_digits, self.decimal_places)
1513 
1514     def get_prep_value(self, value):
1515         value = super().get_prep_value(value)
1516         return self.to_python(value)
1517 
1518     def formfield(self, **kwargs):
1519         return super().formfield(**{
1520             'max_digits': self.max_digits,
1521             'decimal_places': self.decimal_places,
1522             'form_class': forms.DecimalField,
1523             **kwargs,
1524         })
1525 
1526 
1527 class DurationField(Field):
1528     """
1529     Store timedelta objects.
1530 
1531     Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint
1532     of microseconds on other databases.
1533     """
1534     empty_strings_allowed = False
1535     default_error_messages = {
1536         'invalid': _('“%(value)s” value has an invalid format. It must be in '
1537                      '[DD] [[HH:]MM:]ss[.uuuuuu] format.')
1538     }
1539     description = _("Duration")
1540 
1541     def get_internal_type(self):
1542         return "DurationField"
1543 
1544     def to_python(self, value):
1545         if value is None:
1546             return value
1547         if isinstance(value, datetime.timedelta):
1548             return value
1549         try:
1550             parsed = parse_duration(value)
1551         except ValueError:
1552             pass
1553         else:
1554             if parsed is not None:
1555                 return parsed
1556 
1557         raise exceptions.ValidationError(
1558             self.error_messages['invalid'],
1559             code='invalid',
1560             params={'value': value},
1561         )
1562 
1563     def get_db_prep_value(self, value, connection, prepared=False):
1564         if connection.features.has_native_duration_field:
1565             return value
1566         if value is None:
1567             return None
1568         return duration_microseconds(value)
1569 
1570     def get_db_converters(self, connection):
1571         converters = []
1572         if not connection.features.has_native_duration_field:
1573             converters.append(connection.ops.convert_durationfield_value)
1574         return converters + super().get_db_converters(connection)
1575 
1576     def value_to_string(self, obj):
1577         val = self.value_from_object(obj)
1578         return '' if val is None else duration_string(val)
1579 
1580     def formfield(self, **kwargs):
1581         return super().formfield(**{
1582             'form_class': forms.DurationField,
1583             **kwargs,
1584         })
1585 
1586 
1587 class EmailField(CharField):
1588     default_validators = [validators.validate_email]
1589     description = _("Email address")
1590 
1591     def __init__(self, *args, **kwargs):
1592         # max_length=254 to be compliant with RFCs 3696 and 5321
1593         kwargs.setdefault('max_length', 254)
1594         super().__init__(*args, **kwargs)
1595 
1596     def deconstruct(self):
1597         name, path, args, kwargs = super().deconstruct()
1598         # We do not exclude max_length if it matches default as we want to change
1599         # the default in future.
1600         return name, path, args, kwargs
1601 
1602     def formfield(self, **kwargs):
1603         # As with CharField, this will cause email validation to be performed
1604         # twice.
1605         return super().formfield(**{
1606             'form_class': forms.EmailField,
1607             **kwargs,
1608         })
1609 
1610 
1611 class FilePathField(Field):
1612     description = _("File path")
1613 
1614     def __init__(self, verbose_name=None, name=None, path='', match=None,
1615                  recursive=False, allow_files=True, allow_folders=False, **kwargs):
1616         self.path, self.match, self.recursive = path, match, recursive
1617         self.allow_files, self.allow_folders = allow_files, allow_folders
1618         kwargs.setdefault('max_length', 100)
1619         super().__init__(verbose_name, name, **kwargs)
1620 
1621     def check(self, **kwargs):
1622         return [
1623             *super().check(**kwargs),
1624             *self._check_allowing_files_or_folders(**kwargs),
1625         ]
1626 
1627     def _check_allowing_files_or_folders(self, **kwargs):
1628         if not self.allow_files and not self.allow_folders:
1629             return [
1630                 checks.Error(
1631                     "FilePathFields must have either 'allow_files' or 'allow_folders' set to True.",
1632                     obj=self,
1633                     id='fields.E140',
1634                 )
1635             ]
1636         return []
1637 
1638     def deconstruct(self):
1639         name, path, args, kwargs = super().deconstruct()
1640         if self.path != '':
1641             kwargs['path'] = self.path
1642         if self.match is not None:
1643             kwargs['match'] = self.match
1644         if self.recursive is not False:
1645             kwargs['recursive'] = self.recursive
1646         if self.allow_files is not True:
1647             kwargs['allow_files'] = self.allow_files
1648         if self.allow_folders is not False:
1649             kwargs['allow_folders'] = self.allow_folders
1650         if kwargs.get("max_length") == 100:
1651             del kwargs["max_length"]
1652         return name, path, args, kwargs
1653 
1654     def get_prep_value(self, value):
1655         value = super().get_prep_value(value)
1656         if value is None:
1657             return None
1658         return str(value)
1659 
1660     def formfield(self, **kwargs):
1661         return super().formfield(**{
1662             'path': self.path() if callable(self.path) else self.path,
1663             'match': self.match,
1664             'recursive': self.recursive,
1665             'form_class': forms.FilePathField,
1666             'allow_files': self.allow_files,
1667             'allow_folders': self.allow_folders,
1668             **kwargs,
1669         })
1670 
1671     def get_internal_type(self):
1672         return "FilePathField"
1673 
1674 
1675 class FloatField(Field):
1676     empty_strings_allowed = False
1677     default_error_messages = {
1678         'invalid': _('“%(value)s” value must be a float.'),
1679     }
1680     description = _("Floating point number")
1681 
1682     def get_prep_value(self, value):
1683         value = super().get_prep_value(value)
1684         if value is None:
1685             return None
1686         try:
1687             return float(value)
1688         except (TypeError, ValueError) as e:
1689             raise e.__class__(
1690                 "Field '%s' expected a number but got %r." % (self.name, value),
1691             ) from e
1692 
1693     def get_internal_type(self):
1694         return "FloatField"
1695 
1696     def to_python(self, value):
1697         if value is None:
1698             return value
1699         try:
1700             return float(value)
1701         except (TypeError, ValueError):
1702             raise exceptions.ValidationError(
1703                 self.error_messages['invalid'],
1704                 code='invalid',
1705                 params={'value': value},
1706             )
1707 
1708     def formfield(self, **kwargs):
1709         return super().formfield(**{
1710             'form_class': forms.FloatField,
1711             **kwargs,
1712         })
1713 
1714 
1715 class IntegerField(Field):
1716     empty_strings_allowed = False
1717     default_error_messages = {
1718         'invalid': _('“%(value)s” value must be an integer.'),
1719     }
1720     description = _("Integer")
1721 
1722     def check(self, **kwargs):
1723         return [
1724             *super().check(**kwargs),
1725             *self._check_max_length_warning(),
1726         ]
1727 
1728     def _check_max_length_warning(self):
1729         if self.max_length is not None:
1730             return [
1731                 checks.Warning(
1732                     "'max_length' is ignored when used with %s." % self.__class__.__name__,
1733                     hint="Remove 'max_length' from field",
1734                     obj=self,
1735                     id='fields.W122',
1736                 )
1737             ]
1738         return []
1739 
1740     @cached_property
1741     def validators(self):
1742         # These validators can't be added at field initialization time since
1743         # they're based on values retrieved from `connection`.
1744         validators_ = super().validators
1745         internal_type = self.get_internal_type()
1746         min_value, max_value = connection.ops.integer_field_range(internal_type)
1747         if min_value is not None and not any(
1748             (
1749                 isinstance(validator, validators.MinValueValidator) and (
1750                     validator.limit_value()
1751                     if callable(validator.limit_value)
1752                     else validator.limit_value
1753                 ) >= min_value
1754             ) for validator in validators_
1755         ):
1756             validators_.append(validators.MinValueValidator(min_value))
1757         if max_value is not None and not any(
1758             (
1759                 isinstance(validator, validators.MaxValueValidator) and (
1760                     validator.limit_value()
1761                     if callable(validator.limit_value)
1762                     else validator.limit_value
1763                 ) <= max_value
1764             ) for validator in validators_
1765         ):
1766             validators_.append(validators.MaxValueValidator(max_value))
1767         return validators_
1768 
1769     def get_prep_value(self, value):
1770         value = super().get_prep_value(value)
1771         if value is None:
1772             return None
1773         try:
1774             return int(value)
1775         except (TypeError, ValueError) as e:
1776             raise e.__class__(
1777                 "Field '%s' expected a number but got %r." % (self.name, value),
1778             ) from e
1779 
1780     def get_internal_type(self):
1781         return "IntegerField"
1782 
1783     def to_python(self, value):
1784         if value is None:
1785             return value
1786         try:
1787             return int(value)
1788         except (TypeError, ValueError):
1789             raise exceptions.ValidationError(
1790                 self.error_messages['invalid'],
1791                 code='invalid',
1792                 params={'value': value},
1793             )
1794 
1795     def formfield(self, **kwargs):
1796         return super().formfield(**{
1797             'form_class': forms.IntegerField,
1798             **kwargs,
1799         })
1800 
1801 
1802 class BigIntegerField(IntegerField):
1803     description = _("Big (8 byte) integer")
1804     MAX_BIGINT = 9223372036854775807
1805 
1806     def get_internal_type(self):
1807         return "BigIntegerField"
1808 
1809     def formfield(self, **kwargs):
1810         return super().formfield(**{
1811             'min_value': -BigIntegerField.MAX_BIGINT - 1,
1812             'max_value': BigIntegerField.MAX_BIGINT,
1813             **kwargs,
1814         })
1815 
1816 
1817 class IPAddressField(Field):
1818     empty_strings_allowed = False
1819     description = _("IPv4 address")
1820     system_check_removed_details = {
1821         'msg': (
1822             'IPAddressField has been removed except for support in '
1823             'historical migrations.'
1824         ),
1825         'hint': 'Use GenericIPAddressField instead.',
1826         'id': 'fields.E900',
1827     }
1828 
1829     def __init__(self, *args, **kwargs):
1830         kwargs['max_length'] = 15
1831         super().__init__(*args, **kwargs)
1832 
1833     def deconstruct(self):
1834         name, path, args, kwargs = super().deconstruct()
1835         del kwargs['max_length']
1836         return name, path, args, kwargs
1837 
1838     def get_prep_value(self, value):
1839         value = super().get_prep_value(value)
1840         if value is None:
1841             return None
1842         return str(value)
1843 
1844     def get_internal_type(self):
1845         return "IPAddressField"
1846 
1847 
1848 class GenericIPAddressField(Field):
1849     empty_strings_allowed = False
1850     description = _("IP address")
1851     default_error_messages = {}
1852 
1853     def __init__(self, verbose_name=None, name=None, protocol='both',
1854                  unpack_ipv4=False, *args, **kwargs):
1855         self.unpack_ipv4 = unpack_ipv4
1856         self.protocol = protocol
1857         self.default_validators, invalid_error_message = \
1858             validators.ip_address_validators(protocol, unpack_ipv4)
1859         self.default_error_messages['invalid'] = invalid_error_message
1860         kwargs['max_length'] = 39
1861         super().__init__(verbose_name, name, *args, **kwargs)
1862 
1863     def check(self, **kwargs):
1864         return [
1865             *super().check(**kwargs),
1866             *self._check_blank_and_null_values(**kwargs),
1867         ]
1868 
1869     def _check_blank_and_null_values(self, **kwargs):
1870         if not getattr(self, 'null', False) and getattr(self, 'blank', False):
1871             return [
1872                 checks.Error(
1873                     'GenericIPAddressFields cannot have blank=True if null=False, '
1874                     'as blank values are stored as nulls.',
1875                     obj=self,
1876                     id='fields.E150',
1877                 )
1878             ]
1879         return []
1880 
1881     def deconstruct(self):
1882         name, path, args, kwargs = super().deconstruct()
1883         if self.unpack_ipv4 is not False:
1884             kwargs['unpack_ipv4'] = self.unpack_ipv4
1885         if self.protocol != "both":
1886             kwargs['protocol'] = self.protocol
1887         if kwargs.get("max_length") == 39:
1888             del kwargs['max_length']
1889         return name, path, args, kwargs
1890 
1891     def get_internal_type(self):
1892         return "GenericIPAddressField"
1893 
1894     def to_python(self, value):
1895         if value is None:
1896             return None
1897         if not isinstance(value, str):
1898             value = str(value)
1899         value = value.strip()
1900         if ':' in value:
1901             return clean_ipv6_address(value, self.unpack_ipv4, self.error_messages['invalid'])
1902         return value
1903 
1904     def get_db_prep_value(self, value, connection, prepared=False):
1905         if not prepared:
1906             value = self.get_prep_value(value)
1907         return connection.ops.adapt_ipaddressfield_value(value)
1908 
1909     def get_prep_value(self, value):
1910         value = super().get_prep_value(value)
1911         if value is None:
1912             return None
1913         if value and ':' in value:
1914             try:
1915                 return clean_ipv6_address(value, self.unpack_ipv4)
1916             except exceptions.ValidationError:
1917                 pass
1918         return str(value)
1919 
1920     def formfield(self, **kwargs):
1921         return super().formfield(**{
1922             'protocol': self.protocol,
1923             'form_class': forms.GenericIPAddressField,
1924             **kwargs,
1925         })
1926 
1927 
1928 class NullBooleanField(BooleanField):
1929     default_error_messages = {
1930         'invalid': _('“%(value)s” value must be either None, True or False.'),
1931         'invalid_nullable': _('“%(value)s” value must be either None, True or False.'),
1932     }
1933     description = _("Boolean (Either True, False or None)")
1934     system_check_deprecated_details = {
1935         'msg': (
1936             'NullBooleanField is deprecated. Support for it (except in '
1937             'historical migrations) will be removed in Django 4.0.'
1938         ),
1939         'hint': 'Use BooleanField(null=True) instead.',
1940         'id': 'fields.W903',
1941     }
1942 
1943     def __init__(self, *args, **kwargs):
1944         kwargs['null'] = True
1945         kwargs['blank'] = True
1946         super().__init__(*args, **kwargs)
1947 
1948     def deconstruct(self):
1949         name, path, args, kwargs = super().deconstruct()
1950         del kwargs['null']
1951         del kwargs['blank']
1952         return name, path, args, kwargs
1953 
1954     def get_internal_type(self):
1955         return "NullBooleanField"
1956 
1957 
1958 class PositiveIntegerRelDbTypeMixin:
1959 
1960     def rel_db_type(self, connection):
1961         """
1962         Return the data type that a related field pointing to this field should
1963         use. In most cases, a foreign key pointing to a positive integer
1964         primary key will have an integer column data type but some databases
1965         (e.g. MySQL) have an unsigned integer type. In that case
1966         (related_fields_match_type=True), the primary key should return its
1967         db_type.
1968         """
1969         if connection.features.related_fields_match_type:
1970             return self.db_type(connection)
1971         else:
1972             return IntegerField().db_type(connection=connection)
1973 
1974 
1975 class PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
1976     description = _('Positive big integer')
1977 
1978     def get_internal_type(self):
1979         return 'PositiveBigIntegerField'
1980 
1981     def formfield(self, **kwargs):
1982         return super().formfield(**{
1983             'min_value': 0,
1984             **kwargs,
1985         })
1986 
1987 
1988 class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
1989     description = _("Positive integer")
1990 
1991     def get_internal_type(self):
1992         return "PositiveIntegerField"
1993 
1994     def formfield(self, **kwargs):
1995         return super().formfield(**{
1996             'min_value': 0,
1997             **kwargs,
1998         })
1999 
2000 
2001 class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
2002     description = _("Positive small integer")
2003 
2004     def get_internal_type(self):
2005         return "PositiveSmallIntegerField"
2006 
2007     def formfield(self, **kwargs):
2008         return super().formfield(**{
2009             'min_value': 0,
2010             **kwargs,
2011         })
2012 
2013 
2014 class SlugField(CharField):
2015     default_validators = [validators.validate_slug]
2016     description = _("Slug (up to %(max_length)s)")
2017 
2018     def __init__(self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs):
2019         self.allow_unicode = allow_unicode
2020         if self.allow_unicode:
2021             self.default_validators = [validators.validate_unicode_slug]
2022         super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)
2023 
2024     def deconstruct(self):
2025         name, path, args, kwargs = super().deconstruct()
2026         if kwargs.get("max_length") == 50:
2027             del kwargs['max_length']
2028         if self.db_index is False:
2029             kwargs['db_index'] = False
2030         else:
2031             del kwargs['db_index']
2032         if self.allow_unicode is not False:
2033             kwargs['allow_unicode'] = self.allow_unicode
2034         return name, path, args, kwargs
2035 
2036     def get_internal_type(self):
2037         return "SlugField"
2038 
2039     def formfield(self, **kwargs):
2040         return super().formfield(**{
2041             'form_class': forms.SlugField,
2042             'allow_unicode': self.allow_unicode,
2043             **kwargs,
2044         })
2045 
2046 
2047 class SmallIntegerField(IntegerField):
2048     description = _("Small integer")
2049 
2050     def get_internal_type(self):
2051         return "SmallIntegerField"
2052 
2053 
2054 class TextField(Field):
2055     description = _("Text")
2056 
2057     def get_internal_type(self):
2058         return "TextField"
2059 
2060     def to_python(self, value):
2061         if isinstance(value, str) or value is None:
2062             return value
2063         return str(value)
2064 
2065     def get_prep_value(self, value):
2066         value = super().get_prep_value(value)
2067         return self.to_python(value)
2068 
2069     def formfield(self, **kwargs):
2070         # Passing max_length to forms.CharField means that the value's length
2071         # will be validated twice. This is considered acceptable since we want
2072         # the value in the form field (to pass into widget for example).
2073         return super().formfield(**{
2074             'max_length': self.max_length,
2075             **({} if self.choices is not None else {'widget': forms.Textarea}),
2076             **kwargs,
2077         })
2078 
2079 
2080 class TimeField(DateTimeCheckMixin, Field):
2081     empty_strings_allowed = False
2082     default_error_messages = {
2083         'invalid': _('“%(value)s” value has an invalid format. It must be in '
2084                      'HH:MM[:ss[.uuuuuu]] format.'),
2085         'invalid_time': _('“%(value)s” value has the correct format '
2086                           '(HH:MM[:ss[.uuuuuu]]) but it is an invalid time.'),
2087     }
2088     description = _("Time")
2089 
2090     def __init__(self, verbose_name=None, name=None, auto_now=False,
2091                  auto_now_add=False, **kwargs):
2092         self.auto_now, self.auto_now_add = auto_now, auto_now_add
2093         if auto_now or auto_now_add:
2094             kwargs['editable'] = False
2095             kwargs['blank'] = True
2096         super().__init__(verbose_name, name, **kwargs)
2097 
2098     def _check_fix_default_value(self):
2099         """
2100         Warn that using an actual date or datetime value is probably wrong;
2101         it's only evaluated on server startup.
2102         """
2103         if not self.has_default():
2104             return []
2105 
2106         now = timezone.now()
2107         if not timezone.is_naive(now):
2108             now = timezone.make_naive(now, timezone.utc)
2109         value = self.default
2110         if isinstance(value, datetime.datetime):
2111             second_offset = datetime.timedelta(seconds=10)
2112             lower = now - second_offset
2113             upper = now + second_offset
2114             if timezone.is_aware(value):
2115                 value = timezone.make_naive(value, timezone.utc)
2116         elif isinstance(value, datetime.time):
2117             second_offset = datetime.timedelta(seconds=10)
2118             lower = now - second_offset
2119             upper = now + second_offset
2120             value = datetime.datetime.combine(now.date(), value)
2121             if timezone.is_aware(value):
2122                 value = timezone.make_naive(value, timezone.utc).time()
2123         else:
2124             # No explicit time / datetime value -- no checks necessary
2125             return []
2126         if lower <= value <= upper:
2127             return [
2128                 checks.Warning(
2129                     'Fixed default value provided.',
2130                     hint='It seems you set a fixed date / time / datetime '
2131                          'value as default for this field. This may not be '
2132                          'what you want. If you want to have the current date '
2133                          'as default, use `django.utils.timezone.now`',
2134                     obj=self,
2135                     id='fields.W161',
2136                 )
2137             ]
2138 
2139         return []
2140 
2141     def deconstruct(self):
2142         name, path, args, kwargs = super().deconstruct()
2143         if self.auto_now is not False:
2144             kwargs["auto_now"] = self.auto_now
2145         if self.auto_now_add is not False:
2146             kwargs["auto_now_add"] = self.auto_now_add
2147         if self.auto_now or self.auto_now_add:
2148             del kwargs['blank']
2149             del kwargs['editable']
2150         return name, path, args, kwargs
2151 
2152     def get_internal_type(self):
2153         return "TimeField"
2154 
2155     def to_python(self, value):
2156         if value is None:
2157             return None
2158         if isinstance(value, datetime.time):
2159             return value
2160         if isinstance(value, datetime.datetime):
2161             # Not usually a good idea to pass in a datetime here (it loses
2162             # information), but this can be a side-effect of interacting with a
2163             # database backend (e.g. Oracle), so we'll be accommodating.
2164             return value.time()
2165 
2166         try:
2167             parsed = parse_time(value)
2168             if parsed is not None:
2169                 return parsed
2170         except ValueError:
2171             raise exceptions.ValidationError(
2172                 self.error_messages['invalid_time'],
2173                 code='invalid_time',
2174                 params={'value': value},
2175             )
2176 
2177         raise exceptions.ValidationError(
2178             self.error_messages['invalid'],
2179             code='invalid',
2180             params={'value': value},
2181         )
2182 
2183     def pre_save(self, model_instance, add):
2184         if self.auto_now or (self.auto_now_add and add):
2185             value = datetime.datetime.now().time()
2186             setattr(model_instance, self.attname, value)
2187             return value
2188         else:
2189             return super().pre_save(model_instance, add)
2190 
2191     def get_prep_value(self, value):
2192         value = super().get_prep_value(value)
2193         return self.to_python(value)
2194 
2195     def get_db_prep_value(self, value, connection, prepared=False):
2196         # Casts times into the format expected by the backend
2197         if not prepared:
2198             value = self.get_prep_value(value)
2199         return connection.ops.adapt_timefield_value(value)
2200 
2201     def value_to_string(self, obj):
2202         val = self.value_from_object(obj)
2203         return '' if val is None else val.isoformat()
2204 
2205     def formfield(self, **kwargs):
2206         return super().formfield(**{
2207             'form_class': forms.TimeField,
2208             **kwargs,
2209         })
2210 
2211 
2212 class URLField(CharField):
2213     default_validators = [validators.URLValidator()]
2214     description = _("URL")
2215 
2216     def __init__(self, verbose_name=None, name=None, **kwargs):
2217         kwargs.setdefault('max_length', 200)
2218         super().__init__(verbose_name, name, **kwargs)
2219 
2220     def deconstruct(self):
2221         name, path, args, kwargs = super().deconstruct()
2222         if kwargs.get("max_length") == 200:
2223             del kwargs['max_length']
2224         return name, path, args, kwargs
2225 
2226     def formfield(self, **kwargs):
2227         # As with CharField, this will cause URL validation to be performed
2228         # twice.
2229         return super().formfield(**{
2230             'form_class': forms.URLField,
2231             **kwargs,
2232         })
2233 
2234 
2235 class BinaryField(Field):
2236     description = _("Raw binary data")
2237     empty_values = [None, b'']
2238 
2239     def __init__(self, *args, **kwargs):
2240         kwargs.setdefault('editable', False)
2241         super().__init__(*args, **kwargs)
2242         if self.max_length is not None:
2243             self.validators.append(validators.MaxLengthValidator(self.max_length))
2244 
2245     def check(self, **kwargs):
2246         return [*super().check(**kwargs), *self._check_str_default_value()]
2247 
2248     def _check_str_default_value(self):
2249         if self.has_default() and isinstance(self.default, str):
2250             return [
2251                 checks.Error(
2252                     "BinaryField's default cannot be a string. Use bytes "
2253                     "content instead.",
2254                     obj=self,
2255                     id='fields.E170',
2256                 )
2257             ]
2258         return []
2259 
2260     def deconstruct(self):
2261         name, path, args, kwargs = super().deconstruct()
2262         if self.editable:
2263             kwargs['editable'] = True
2264         else:
2265             del kwargs['editable']
2266         return name, path, args, kwargs
2267 
2268     def get_internal_type(self):
2269         return "BinaryField"
2270 
2271     def get_placeholder(self, value, compiler, connection):
2272         return connection.ops.binary_placeholder_sql(value)
2273 
2274     def get_default(self):
2275         if self.has_default() and not callable(self.default):
2276             return self.default
2277         default = super().get_default()
2278         if default == '':
2279             return b''
2280         return default
2281 
2282     def get_db_prep_value(self, value, connection, prepared=False):
2283         value = super().get_db_prep_value(value, connection, prepared)
2284         if value is not None:
2285             return connection.Database.Binary(value)
2286         return value
2287 
2288     def value_to_string(self, obj):
2289         """Binary data is serialized as base64"""
2290         return b64encode(self.value_from_object(obj)).decode('ascii')
2291 
2292     def to_python(self, value):
2293         # If it's a string, it should be base64-encoded data
2294         if isinstance(value, str):
2295             return memoryview(b64decode(value.encode('ascii')))
2296         return value
2297 
2298 
2299 class UUIDField(Field):
2300     default_error_messages = {
2301         'invalid': _('“%(value)s” is not a valid UUID.'),
2302     }
2303     description = _('Universally unique identifier')
2304     empty_strings_allowed = False
2305 
2306     def __init__(self, verbose_name=None, **kwargs):
2307         kwargs['max_length'] = 32
2308         super().__init__(verbose_name, **kwargs)
2309 
2310     def deconstruct(self):
2311         name, path, args, kwargs = super().deconstruct()
2312         del kwargs['max_length']
2313         return name, path, args, kwargs
2314 
2315     def get_internal_type(self):
2316         return "UUIDField"
2317 
2318     def get_prep_value(self, value):
2319         value = super().get_prep_value(value)
2320         return self.to_python(value)
2321 
2322     def get_db_prep_value(self, value, connection, prepared=False):
2323         if value is None:
2324             return None
2325         if not isinstance(value, uuid.UUID):
2326             value = self.to_python(value)
2327 
2328         if connection.features.has_native_uuid_field:
2329             return value
2330         return value.hex
2331 
2332     def to_python(self, value):
2333         if value is not None and not isinstance(value, uuid.UUID):
2334             input_form = 'int' if isinstance(value, int) else 'hex'
2335             try:
2336                 return uuid.UUID(**{input_form: value})
2337             except (AttributeError, ValueError):
2338                 raise exceptions.ValidationError(
2339                     self.error_messages['invalid'],
2340                     code='invalid',
2341                     params={'value': value},
2342                 )
2343         return value
2344 
2345     def formfield(self, **kwargs):
2346         return super().formfield(**{
2347             'form_class': forms.UUIDField,
2348             **kwargs,
2349         })
2350 
2351 
2352 class AutoFieldMixin:
2353     db_returning = True
2354 
2355     def __init__(self, *args, **kwargs):
2356         kwargs['blank'] = True
2357         super().__init__(*args, **kwargs)
2358 
2359     def check(self, **kwargs):
2360         return [
2361             *super().check(**kwargs),
2362             *self._check_primary_key(),
2363         ]
2364 
2365     def _check_primary_key(self):
2366         if not self.primary_key:
2367             return [
2368                 checks.Error(
2369                     'AutoFields must set primary_key=True.',
2370                     obj=self,
2371                     id='fields.E100',
2372                 ),
2373             ]
2374         else:
2375             return []
2376 
2377     def deconstruct(self):
2378         name, path, args, kwargs = super().deconstruct()
2379         del kwargs['blank']
2380         kwargs['primary_key'] = True
2381         return name, path, args, kwargs
2382 
2383     def validate(self, value, model_instance):
2384         pass
2385 
2386     def get_db_prep_value(self, value, connection, prepared=False):
2387         if not prepared:
2388             value = self.get_prep_value(value)
2389             value = connection.ops.validate_autopk_value(value)
2390         return value
2391 
2392     def contribute_to_class(self, cls, name, **kwargs):
2393         assert not cls._meta.auto_field, (
2394             "Model %s can't have more than one auto-generated field."
2395             % cls._meta.label
2396         )
2397         super().contribute_to_class(cls, name, **kwargs)
2398         cls._meta.auto_field = self
2399 
2400     def formfield(self, **kwargs):
2401         return None
2402 
2403 
2404 class AutoFieldMeta(type):
2405     """
2406     Metaclass to maintain backward inheritance compatibility for AutoField.
2407 
2408     It is intended that AutoFieldMixin become public API when it is possible to
2409     create a non-integer automatically-generated field using column defaults
2410     stored in the database.
2411 
2412     In many areas Django also relies on using isinstance() to check for an
2413     automatically-generated field as a subclass of AutoField. A new flag needs
2414     to be implemented on Field to be used instead.
2415 
2416     When these issues have been addressed, this metaclass could be used to
2417     deprecate inheritance from AutoField and use of isinstance() with AutoField
2418     for detecting automatically-generated fields.
2419     """
2420 
2421     @property
2422     def _subclasses(self):
2423         return (BigAutoField, SmallAutoField)
2424 
2425     def __instancecheck__(self, instance):
2426         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)
2427 
2428     def __subclasscheck__(self, subclass):
2429         return subclass in self._subclasses or super().__subclasscheck__(subclass)
2430 
2431 
2432 class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):
2433 
2434     def get_internal_type(self):
2435         return 'AutoField'
2436 
2437     def rel_db_type(self, connection):
2438         return IntegerField().db_type(connection=connection)
2439 
2440 
2441 class BigAutoField(AutoFieldMixin, BigIntegerField):
2442 
2443     def get_internal_type(self):
2444         return 'BigAutoField'
2445 
2446     def rel_db_type(self, connection):
2447         return BigIntegerField().db_type(connection=connection)
2448 
2449 
2450 class SmallAutoField(AutoFieldMixin, SmallIntegerField):
2451 
2452     def get_internal_type(self):
2453         return 'SmallAutoField'
2454 
2455     def rel_db_type(self, connection):
2456         return SmallIntegerField().db_type(connection=connection)

</code><intended_behavior>For every validator attached to model fields, ensure that when raising ValidationError, the value being validated is passed along. This requires modifications to both direct raises of ValidationError within methods and possibly updates to how validators are called, ensuring they have the necessary context to include the value in the error.</intended_behavior>]
2025-10-18 11:56:09.581 | INFO     | Search completed. Bug locations: [<file>django/core/exceptions.py</file>
<class>ValidationError</class>
<method>__init__</method>
<code>
101     def __init__(self, message, code=None, params=None):
102         """
103         The `message` argument can be a single error, a list of errors, or a
104         dictionary that maps field names to lists of errors. What we define as
105         an "error" can be either a simple string or an instance of
106         ValidationError with its message attribute set, and what we define as
107         list or dictionary can be an actual `list` or `dict` or an instance
108         of ValidationError with its `error_list` or `error_dict` attribute set.
109         """
110         super().__init__(message, code, params)
111 
112         if isinstance(message, ValidationError):
113             if hasattr(message, 'error_dict'):
114                 message = message.error_dict
115             elif not hasattr(message, 'message'):
116                 message = message.error_list
117             else:
118                 message, code, params = message.message, message.code, message.params
119 
120         if isinstance(message, dict):
121             self.error_dict = {}
122             for field, messages in message.items():
123                 if not isinstance(messages, ValidationError):
124                     messages = ValidationError(messages)
125                 self.error_dict[field] = messages.error_list
126 
127         elif isinstance(message, list):
128             self.error_list = []
129             for message in message:
130                 # Normalize plain strings to instances of ValidationError.
131                 if not isinstance(message, ValidationError):
132                     message = ValidationError(message)
133                 if hasattr(message, 'error_dict'):
134                     self.error_list.extend(sum(message.error_dict.values(), []))
135                 else:
136                     self.error_list.extend(message.error_list)
137 
138         else:
139             self.message = message
140             self.code = code
141             self.params = params
142             self.error_list = [self]

</code><intended_behavior>Enhance the __init__ method of ValidationError to accept an optional provided_value argument. This value should be stored as an instance attribute and utilized in the error message composition if present. This enables error messages to dynamically include the validated value, helping create more context-aware error messages.</intended_behavior>, <file>django/core/exceptions.py</file>
<class>ValidationError</class>
<method>None</method>
<code>
99 class ValidationError(Exception):
100     """An error while validating data."""
101     def __init__(self, message, code=None, params=None):
102         """
103         The `message` argument can be a single error, a list of errors, or a
104         dictionary that maps field names to lists of errors. What we define as
105         an "error" can be either a simple string or an instance of
106         ValidationError with its message attribute set, and what we define as
107         list or dictionary can be an actual `list` or `dict` or an instance
108         of ValidationError with its `error_list` or `error_dict` attribute set.
109         """
110         super().__init__(message, code, params)
111 
112         if isinstance(message, ValidationError):
113             if hasattr(message, 'error_dict'):
114                 message = message.error_dict
115             elif not hasattr(message, 'message'):
116                 message = message.error_list
117             else:
118                 message, code, params = message.message, message.code, message.params
119 
120         if isinstance(message, dict):
121             self.error_dict = {}
122             for field, messages in message.items():
123                 if not isinstance(messages, ValidationError):
124                     messages = ValidationError(messages)
125                 self.error_dict[field] = messages.error_list
126 
127         elif isinstance(message, list):
128             self.error_list = []
129             for message in message:
130                 # Normalize plain strings to instances of ValidationError.
131                 if not isinstance(message, ValidationError):
132                     message = ValidationError(message)
133                 if hasattr(message, 'error_dict'):
134                     self.error_list.extend(sum(message.error_dict.values(), []))
135                 else:
136                     self.error_list.extend(message.error_list)
137 
138         else:
139             self.message = message
140             self.code = code
141             self.params = params
142             self.error_list = [self]
143 
144     @property
145     def message_dict(self):
146         # Trigger an AttributeError if this ValidationError
147         # doesn't have an error_dict.
148         getattr(self, 'error_dict')
149 
150         return dict(self)
151 
152     @property
153     def messages(self):
154         if hasattr(self, 'error_dict'):
155             return sum(dict(self).values(), [])
156         return list(self)
157 
158     def update_error_dict(self, error_dict):
159         if hasattr(self, 'error_dict'):
160             for field, error_list in self.error_dict.items():
161                 error_dict.setdefault(field, []).extend(error_list)
162         else:
163             error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)
164         return error_dict
165 
166     def __iter__(self):
167         if hasattr(self, 'error_dict'):
168             for field, errors in self.error_dict.items():
169                 yield field, list(ValidationError(errors))
170         else:
171             for error in self.error_list:
172                 message = error.message
173                 if error.params:
174                     message %= error.params
175                 yield str(message)
176 
177     def __str__(self):
178         if hasattr(self, 'error_dict'):
179             return repr(dict(self))
180         return repr(list(self))
181 
182     def __repr__(self):
183         return 'ValidationError(%s)' % self

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/validators.py</file>
<class>None</class>
<method>None</method>
<code>
1 import ipaddress
2 import re
3 import warnings
4 from pathlib import Path
5 from urllib.parse import urlsplit, urlunsplit
6 
7 from django.core.exceptions import ValidationError
8 from django.utils.deconstruct import deconstructible
9 from django.utils.deprecation import RemovedInDjango41Warning
10 from django.utils.encoding import punycode
11 from django.utils.ipv6 import is_valid_ipv6_address
12 from django.utils.regex_helper import _lazy_re_compile
13 from django.utils.translation import gettext_lazy as _, ngettext_lazy
14 
15 # These values, if given to validate(), will trigger the self.required check.
16 EMPTY_VALUES = (None, '', [], (), {})
17 
18 
19 @deconstructible
20 class RegexValidator:
21     regex = ''
22     message = _('Enter a valid value.')
23     code = 'invalid'
24     inverse_match = False
25     flags = 0
26 
27     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):
28         if regex is not None:
29             self.regex = regex
30         if message is not None:
31             self.message = message
32         if code is not None:
33             self.code = code
34         if inverse_match is not None:
35             self.inverse_match = inverse_match
36         if flags is not None:
37             self.flags = flags
38         if self.flags and not isinstance(self.regex, str):
39             raise TypeError("If the flags are set, regex must be a regular expression string.")
40 
41         self.regex = _lazy_re_compile(self.regex, self.flags)
42 
43     def __call__(self, value):
44         """
45         Validate that the input contains (or does *not* contain, if
46         inverse_match is True) a match for the regular expression.
47         """
48         regex_matches = self.regex.search(str(value))
49         invalid_input = regex_matches if self.inverse_match else not regex_matches
50         if invalid_input:
51             raise ValidationError(self.message, code=self.code)
52 
53     def __eq__(self, other):
54         return (
55             isinstance(other, RegexValidator) and
56             self.regex.pattern == other.regex.pattern and
57             self.regex.flags == other.regex.flags and
58             (self.message == other.message) and
59             (self.code == other.code) and
60             (self.inverse_match == other.inverse_match)
61         )
62 
63 
64 @deconstructible
65 class URLValidator(RegexValidator):
66     ul = '\u00a1-\uffff'  # Unicode letters range (must not be a raw string).
67 
68     # IP patterns
69     ipv4_re = r'(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}'
70     ipv6_re = r'\[[0-9a-f:.]+\]'  # (simple regex, validated later)
71 
72     # Host patterns
73     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'
74     # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1
75     domain_re = r'(?:\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'
76     tld_re = (
77         r'\.'                                # dot
78         r'(?!-)'                             # can't start with a dash
79         r'(?:[a-z' + ul + '-]{2,63}'         # domain label
80         r'|xn--[a-z0-9]{1,59})'              # or punycode label
81         r'(?<!-)'                            # can't end with a dash
82         r'\.?'                               # may have a trailing dot
83     )
84     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'
85 
86     regex = _lazy_re_compile(
87         r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately
88         r'(?:[^\s:@/]+(?::[^\s:@/]*)?@)?'  # user:pass authentication
89         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
90         r'(?::\d{2,5})?'  # port
91         r'(?:[/?#][^\s]*)?'  # resource path
92         r'\Z', re.IGNORECASE)
93     message = _('Enter a valid URL.')
94     schemes = ['http', 'https', 'ftp', 'ftps']
95 
96     def __init__(self, schemes=None, **kwargs):
97         super().__init__(**kwargs)
98         if schemes is not None:
99             self.schemes = schemes
100 
101     def __call__(self, value):
102         if not isinstance(value, str):
103             raise ValidationError(self.message, code=self.code)
104         # Check if the scheme is valid.
105         scheme = value.split('://')[0].lower()
106         if scheme not in self.schemes:
107             raise ValidationError(self.message, code=self.code)
108 
109         # Then check full URL
110         try:
111             super().__call__(value)
112         except ValidationError as e:
113             # Trivial case failed. Try for possible IDN domain
114             if value:
115                 try:
116                     scheme, netloc, path, query, fragment = urlsplit(value)
117                 except ValueError:  # for example, "Invalid IPv6 URL"
118                     raise ValidationError(self.message, code=self.code)
119                 try:
120                     netloc = punycode(netloc)  # IDN -> ACE
121                 except UnicodeError:  # invalid domain part
122                     raise e
123                 url = urlunsplit((scheme, netloc, path, query, fragment))
124                 super().__call__(url)
125             else:
126                 raise
127         else:
128             # Now verify IPv6 in the netloc part
129             host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(value).netloc)
130             if host_match:
131                 potential_ip = host_match[1]
132                 try:
133                     validate_ipv6_address(potential_ip)
134                 except ValidationError:
135                     raise ValidationError(self.message, code=self.code)
136 
137         # The maximum length of a full host name is 253 characters per RFC 1034
138         # section 3.1. It's defined to be 255 bytes or less, but this includes
139         # one byte for the length of the name and one byte for the trailing dot
140         # that's used to indicate absolute names in DNS.
141         if len(urlsplit(value).netloc) > 253:
142             raise ValidationError(self.message, code=self.code)
143 
144 
145 integer_validator = RegexValidator(
146     _lazy_re_compile(r'^-?\d+\Z'),
147     message=_('Enter a valid integer.'),
148     code='invalid',
149 )
150 
151 
152 def validate_integer(value):
153     return integer_validator(value)
154 
155 
156 @deconstructible
157 class EmailValidator:
158     message = _('Enter a valid email address.')
159     code = 'invalid'
160     user_regex = _lazy_re_compile(
161         r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\Z"  # dot-atom
162         r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"\Z)',  # quoted-string
163         re.IGNORECASE)
164     domain_regex = _lazy_re_compile(
165         # max length for domain name labels is 63 characters per RFC 1034
166         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\Z',
167         re.IGNORECASE)
168     literal_regex = _lazy_re_compile(
169         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)
170         r'\[([A-f0-9:.]+)\]\Z',
171         re.IGNORECASE)
172     domain_allowlist = ['localhost']
173 
174     @property
175     def domain_whitelist(self):
176         warnings.warn(
177             'The domain_whitelist attribute is deprecated in favor of '
178             'domain_allowlist.',
179             RemovedInDjango41Warning,
180             stacklevel=2,
181         )
182         return self.domain_allowlist
183 
184     @domain_whitelist.setter
185     def domain_whitelist(self, allowlist):
186         warnings.warn(
187             'The domain_whitelist attribute is deprecated in favor of '
188             'domain_allowlist.',
189             RemovedInDjango41Warning,
190             stacklevel=2,
191         )
192         self.domain_allowlist = allowlist
193 
194     def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):
195         if whitelist is not None:
196             allowlist = whitelist
197             warnings.warn(
198                 'The whitelist argument is deprecated in favor of allowlist.',
199                 RemovedInDjango41Warning,
200                 stacklevel=2,
201             )
202         if message is not None:
203             self.message = message
204         if code is not None:
205             self.code = code
206         if allowlist is not None:
207             self.domain_allowlist = allowlist
208 
209     def __call__(self, value):
210         if not value or '@' not in value:
211             raise ValidationError(self.message, code=self.code)
212 
213         user_part, domain_part = value.rsplit('@', 1)
214 
215         if not self.user_regex.match(user_part):
216             raise ValidationError(self.message, code=self.code)
217 
218         if (domain_part not in self.domain_allowlist and
219                 not self.validate_domain_part(domain_part)):
220             # Try for possible IDN domain-part
221             try:
222                 domain_part = punycode(domain_part)
223             except UnicodeError:
224                 pass
225             else:
226                 if self.validate_domain_part(domain_part):
227                     return
228             raise ValidationError(self.message, code=self.code)
229 
230     def validate_domain_part(self, domain_part):
231         if self.domain_regex.match(domain_part):
232             return True
233 
234         literal_match = self.literal_regex.match(domain_part)
235         if literal_match:
236             ip_address = literal_match[1]
237             try:
238                 validate_ipv46_address(ip_address)
239                 return True
240             except ValidationError:
241                 pass
242         return False
243 
244     def __eq__(self, other):
245         return (
246             isinstance(other, EmailValidator) and
247             (self.domain_allowlist == other.domain_allowlist) and
248             (self.message == other.message) and
249             (self.code == other.code)
250         )
251 
252 
253 validate_email = EmailValidator()
254 
255 slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\Z')
256 validate_slug = RegexValidator(
257     slug_re,
258     # Translators: "letters" means latin letters: a-z and A-Z.
259     _('Enter a valid “slug” consisting of letters, numbers, underscores or hyphens.'),
260     'invalid'
261 )
262 
263 slug_unicode_re = _lazy_re_compile(r'^[-\w]+\Z')
264 validate_unicode_slug = RegexValidator(
265     slug_unicode_re,
266     _('Enter a valid “slug” consisting of Unicode letters, numbers, underscores, or hyphens.'),
267     'invalid'
268 )
269 
270 
271 def validate_ipv4_address(value):
272     try:
273         ipaddress.IPv4Address(value)
274     except ValueError:
275         raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')
276 
277 
278 def validate_ipv6_address(value):
279     if not is_valid_ipv6_address(value):
280         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')
281 
282 
283 def validate_ipv46_address(value):
284     try:
285         validate_ipv4_address(value)
286     except ValidationError:
287         try:
288             validate_ipv6_address(value)
289         except ValidationError:
290             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')
291 
292 
293 ip_address_validator_map = {
294     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),
295     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),
296     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),
297 }
298 
299 
300 def ip_address_validators(protocol, unpack_ipv4):
301     """
302     Depending on the given parameters, return the appropriate validators for
303     the GenericIPAddressField.
304     """
305     if protocol != 'both' and unpack_ipv4:
306         raise ValueError(
307             "You can only use `unpack_ipv4` if `protocol` is set to 'both'")
308     try:
309         return ip_address_validator_map[protocol.lower()]
310     except KeyError:
311         raise ValueError("The protocol '%s' is unknown. Supported: %s"
312                          % (protocol, list(ip_address_validator_map)))
313 
314 
315 def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):
316     regexp = _lazy_re_compile(r'^%(neg)s\d+(?:%(sep)s%(neg)s\d+)*\Z' % {
317         'neg': '(-)?' if allow_negative else '',
318         'sep': re.escape(sep),
319     })
320     return RegexValidator(regexp, message=message, code=code)
321 
322 
323 validate_comma_separated_integer_list = int_list_validator(
324     message=_('Enter only digits separated by commas.'),
325 )
326 
327 
328 @deconstructible
329 class BaseValidator:
330     message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')
331     code = 'limit_value'
332 
333     def __init__(self, limit_value, message=None):
334         self.limit_value = limit_value
335         if message:
336             self.message = message
337 
338     def __call__(self, value):
339         cleaned = self.clean(value)
340         limit_value = self.limit_value() if callable(self.limit_value) else self.limit_value
341         params = {'limit_value': limit_value, 'show_value': cleaned, 'value': value}
342         if self.compare(cleaned, limit_value):
343             raise ValidationError(self.message, code=self.code, params=params)
344 
345     def __eq__(self, other):
346         if not isinstance(other, self.__class__):
347             return NotImplemented
348         return (
349             self.limit_value == other.limit_value and
350             self.message == other.message and
351             self.code == other.code
352         )
353 
354     def compare(self, a, b):
355         return a is not b
356 
357     def clean(self, x):
358         return x
359 
360 
361 @deconstructible
362 class MaxValueValidator(BaseValidator):
363     message = _('Ensure this value is less than or equal to %(limit_value)s.')
364     code = 'max_value'
365 
366     def compare(self, a, b):
367         return a > b
368 
369 
370 @deconstructible
371 class MinValueValidator(BaseValidator):
372     message = _('Ensure this value is greater than or equal to %(limit_value)s.')
373     code = 'min_value'
374 
375     def compare(self, a, b):
376         return a < b
377 
378 
379 @deconstructible
380 class MinLengthValidator(BaseValidator):
381     message = ngettext_lazy(
382         'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',
383         'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',
384         'limit_value')
385     code = 'min_length'
386 
387     def compare(self, a, b):
388         return a < b
389 
390     def clean(self, x):
391         return len(x)
392 
393 
394 @deconstructible
395 class MaxLengthValidator(BaseValidator):
396     message = ngettext_lazy(
397         'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',
398         'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',
399         'limit_value')
400     code = 'max_length'
401 
402     def compare(self, a, b):
403         return a > b
404 
405     def clean(self, x):
406         return len(x)
407 
408 
409 @deconstructible
410 class DecimalValidator:
411     """
412     Validate that the input does not exceed the maximum number of digits
413     expected, otherwise raise ValidationError.
414     """
415     messages = {
416         'invalid': _('Enter a number.'),
417         'max_digits': ngettext_lazy(
418             'Ensure that there are no more than %(max)s digit in total.',
419             'Ensure that there are no more than %(max)s digits in total.',
420             'max'
421         ),
422         'max_decimal_places': ngettext_lazy(
423             'Ensure that there are no more than %(max)s decimal place.',
424             'Ensure that there are no more than %(max)s decimal places.',
425             'max'
426         ),
427         'max_whole_digits': ngettext_lazy(
428             'Ensure that there are no more than %(max)s digit before the decimal point.',
429             'Ensure that there are no more than %(max)s digits before the decimal point.',
430             'max'
431         ),
432     }
433 
434     def __init__(self, max_digits, decimal_places):
435         self.max_digits = max_digits
436         self.decimal_places = decimal_places
437 
438     def __call__(self, value):
439         digit_tuple, exponent = value.as_tuple()[1:]
440         if exponent in {'F', 'n', 'N'}:
441             raise ValidationError(self.messages['invalid'])
442         if exponent >= 0:
443             # A positive exponent adds that many trailing zeros.
444             digits = len(digit_tuple) + exponent
445             decimals = 0
446         else:
447             # If the absolute value of the negative exponent is larger than the
448             # number of digits, then it's the same as the number of digits,
449             # because it'll consume all of the digits in digit_tuple and then
450             # add abs(exponent) - len(digit_tuple) leading zeros after the
451             # decimal point.
452             if abs(exponent) > len(digit_tuple):
453                 digits = decimals = abs(exponent)
454             else:
455                 digits = len(digit_tuple)
456                 decimals = abs(exponent)
457         whole_digits = digits - decimals
458 
459         if self.max_digits is not None and digits > self.max_digits:
460             raise ValidationError(
461                 self.messages['max_digits'],
462                 code='max_digits',
463                 params={'max': self.max_digits},
464             )
465         if self.decimal_places is not None and decimals > self.decimal_places:
466             raise ValidationError(
467                 self.messages['max_decimal_places'],
468                 code='max_decimal_places',
469                 params={'max': self.decimal_places},
470             )
471         if (self.max_digits is not None and self.decimal_places is not None and
472                 whole_digits > (self.max_digits - self.decimal_places)):
473             raise ValidationError(
474                 self.messages['max_whole_digits'],
475                 code='max_whole_digits',
476                 params={'max': (self.max_digits - self.decimal_places)},
477             )
478 
479     def __eq__(self, other):
480         return (
481             isinstance(other, self.__class__) and
482             self.max_digits == other.max_digits and
483             self.decimal_places == other.decimal_places
484         )
485 
486 
487 @deconstructible
488 class FileExtensionValidator:
489     message = _(
490         'File extension “%(extension)s” is not allowed. '
491         'Allowed extensions are: %(allowed_extensions)s.'
492     )
493     code = 'invalid_extension'
494 
495     def __init__(self, allowed_extensions=None, message=None, code=None):
496         if allowed_extensions is not None:
497             allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]
498         self.allowed_extensions = allowed_extensions
499         if message is not None:
500             self.message = message
501         if code is not None:
502             self.code = code
503 
504     def __call__(self, value):
505         extension = Path(value.name).suffix[1:].lower()
506         if self.allowed_extensions is not None and extension not in self.allowed_extensions:
507             raise ValidationError(
508                 self.message,
509                 code=self.code,
510                 params={
511                     'extension': extension,
512                     'allowed_extensions': ', '.join(self.allowed_extensions)
513                 }
514             )
515 
516     def __eq__(self, other):
517         return (
518             isinstance(other, self.__class__) and
519             self.allowed_extensions == other.allowed_extensions and
520             self.message == other.message and
521             self.code == other.code
522         )
523 
524 
525 def get_available_image_extensions():
526     try:
527         from PIL import Image
528     except ImportError:
529         return []
530     else:
531         Image.init()
532         return [ext.lower()[1:] for ext in Image.EXTENSION]
533 
534 
535 def validate_image_file_extension(value):
536     return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)
537 
538 
539 @deconstructible
540 class ProhibitNullCharactersValidator:
541     """Validate that the string doesn't contain the null character."""
542     message = _('Null characters are not allowed.')
543     code = 'null_characters_not_allowed'
544 
545     def __init__(self, message=None, code=None):
546         if message is not None:
547             self.message = message
548         if code is not None:
549             self.code = code
550 
551     def __call__(self, value):
552         if '\x00' in str(value):
553             raise ValidationError(self.message, code=self.code)
554 
555     def __eq__(self, other):
556         return (
557             isinstance(other, self.__class__) and
558             self.message == other.message and
559             self.code == other.code
560         )

</code><intended_behavior>Update the built-in validator functions in this file to pass the provided_value to ValidationError when raising it. This change allows these validators to include the value that failed validation in the error message, improving the informativeness of validation errors.</intended_behavior>, <file>django/forms/fields.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Field classes.
3 """
4 
5 import copy
6 import datetime
7 import json
8 import math
9 import operator
10 import os
11 import re
12 import uuid
13 from decimal import Decimal, DecimalException
14 from io import BytesIO
15 from urllib.parse import urlsplit, urlunsplit
16 
17 from django.core import validators
18 from django.core.exceptions import ValidationError
19 from django.forms.boundfield import BoundField
20 from django.forms.utils import from_current_timezone, to_current_timezone
21 from django.forms.widgets import (
22     FILE_INPUT_CONTRADICTION, CheckboxInput, ClearableFileInput, DateInput,
23     DateTimeInput, EmailInput, FileInput, HiddenInput, MultipleHiddenInput,
24     NullBooleanSelect, NumberInput, Select, SelectMultiple,
25     SplitDateTimeWidget, SplitHiddenDateTimeWidget, Textarea, TextInput,
26     TimeInput, URLInput,
27 )
28 from django.utils import formats
29 from django.utils.dateparse import parse_datetime, parse_duration
30 from django.utils.duration import duration_string
31 from django.utils.ipv6 import clean_ipv6_address
32 from django.utils.regex_helper import _lazy_re_compile
33 from django.utils.translation import gettext_lazy as _, ngettext_lazy
34 
35 __all__ = (
36     'Field', 'CharField', 'IntegerField',
37     'DateField', 'TimeField', 'DateTimeField', 'DurationField',
38     'RegexField', 'EmailField', 'FileField', 'ImageField', 'URLField',
39     'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',
40     'ComboField', 'MultiValueField', 'FloatField', 'DecimalField',
41     'SplitDateTimeField', 'GenericIPAddressField', 'FilePathField',
42     'JSONField', 'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField',
43     'UUIDField',
44 )
45 
46 
47 class Field:
48     widget = TextInput  # Default widget to use when rendering this type of Field.
49     hidden_widget = HiddenInput  # Default widget to use when rendering this as "hidden".
50     default_validators = []  # Default set of validators
51     # Add an 'invalid' entry to default_error_message if you want a specific
52     # field error message not raised by the field validators.
53     default_error_messages = {
54         'required': _('This field is required.'),
55     }
56     empty_values = list(validators.EMPTY_VALUES)
57 
58     def __init__(self, *, required=True, widget=None, label=None, initial=None,
59                  help_text='', error_messages=None, show_hidden_initial=False,
60                  validators=(), localize=False, disabled=False, label_suffix=None):
61         # required -- Boolean that specifies whether the field is required.
62         #             True by default.
63         # widget -- A Widget class, or instance of a Widget class, that should
64         #           be used for this Field when displaying it. Each Field has a
65         #           default Widget that it'll use if you don't specify this. In
66         #           most cases, the default widget is TextInput.
67         # label -- A verbose name for this field, for use in displaying this
68         #          field in a form. By default, Django will use a "pretty"
69         #          version of the form field name, if the Field is part of a
70         #          Form.
71         # initial -- A value to use in this Field's initial display. This value
72         #            is *not* used as a fallback if data isn't given.
73         # help_text -- An optional string to use as "help text" for this Field.
74         # error_messages -- An optional dictionary to override the default
75         #                   messages that the field will raise.
76         # show_hidden_initial -- Boolean that specifies if it is needed to render a
77         #                        hidden widget with initial value after widget.
78         # validators -- List of additional validators to use
79         # localize -- Boolean that specifies if the field should be localized.
80         # disabled -- Boolean that specifies whether the field is disabled, that
81         #             is its widget is shown in the form but not editable.
82         # label_suffix -- Suffix to be added to the label. Overrides
83         #                 form's label_suffix.
84         self.required, self.label, self.initial = required, label, initial
85         self.show_hidden_initial = show_hidden_initial
86         self.help_text = help_text
87         self.disabled = disabled
88         self.label_suffix = label_suffix
89         widget = widget or self.widget
90         if isinstance(widget, type):
91             widget = widget()
92         else:
93             widget = copy.deepcopy(widget)
94 
95         # Trigger the localization machinery if needed.
96         self.localize = localize
97         if self.localize:
98             widget.is_localized = True
99 
100         # Let the widget know whether it should display as required.
101         widget.is_required = self.required
102 
103         # Hook into self.widget_attrs() for any Field-specific HTML attributes.
104         extra_attrs = self.widget_attrs(widget)
105         if extra_attrs:
106             widget.attrs.update(extra_attrs)
107 
108         self.widget = widget
109 
110         messages = {}
111         for c in reversed(self.__class__.__mro__):
112             messages.update(getattr(c, 'default_error_messages', {}))
113         messages.update(error_messages or {})
114         self.error_messages = messages
115 
116         self.validators = [*self.default_validators, *validators]
117 
118         super().__init__()
119 
120     def prepare_value(self, value):
121         return value
122 
123     def to_python(self, value):
124         return value
125 
126     def validate(self, value):
127         if value in self.empty_values and self.required:
128             raise ValidationError(self.error_messages['required'], code='required')
129 
130     def run_validators(self, value):
131         if value in self.empty_values:
132             return
133         errors = []
134         for v in self.validators:
135             try:
136                 v(value)
137             except ValidationError as e:
138                 if hasattr(e, 'code') and e.code in self.error_messages:
139                     e.message = self.error_messages[e.code]
140                 errors.extend(e.error_list)
141         if errors:
142             raise ValidationError(errors)
143 
144     def clean(self, value):
145         """
146         Validate the given value and return its "cleaned" value as an
147         appropriate Python object. Raise ValidationError for any errors.
148         """
149         value = self.to_python(value)
150         self.validate(value)
151         self.run_validators(value)
152         return value
153 
154     def bound_data(self, data, initial):
155         """
156         Return the value that should be shown for this field on render of a
157         bound form, given the submitted POST data for the field and the initial
158         data, if any.
159 
160         For most fields, this will simply be data; FileFields need to handle it
161         a bit differently.
162         """
163         if self.disabled:
164             return initial
165         return data
166 
167     def widget_attrs(self, widget):
168         """
169         Given a Widget instance (*not* a Widget class), return a dictionary of
170         any HTML attributes that should be added to the Widget, based on this
171         Field.
172         """
173         return {}
174 
175     def has_changed(self, initial, data):
176         """Return True if data differs from initial."""
177         # Always return False if the field is disabled since self.bound_data
178         # always uses the initial value in this case.
179         if self.disabled:
180             return False
181         try:
182             data = self.to_python(data)
183             if hasattr(self, '_coerce'):
184                 return self._coerce(data) != self._coerce(initial)
185         except ValidationError:
186             return True
187         # For purposes of seeing whether something has changed, None is
188         # the same as an empty string, if the data or initial value we get
189         # is None, replace it with ''.
190         initial_value = initial if initial is not None else ''
191         data_value = data if data is not None else ''
192         return initial_value != data_value
193 
194     def get_bound_field(self, form, field_name):
195         """
196         Return a BoundField instance that will be used when accessing the form
197         field in a template.
198         """
199         return BoundField(form, self, field_name)
200 
201     def __deepcopy__(self, memo):
202         result = copy.copy(self)
203         memo[id(self)] = result
204         result.widget = copy.deepcopy(self.widget, memo)
205         result.error_messages = self.error_messages.copy()
206         result.validators = self.validators[:]
207         return result
208 
209 
210 class CharField(Field):
211     def __init__(self, *, max_length=None, min_length=None, strip=True, empty_value='', **kwargs):
212         self.max_length = max_length
213         self.min_length = min_length
214         self.strip = strip
215         self.empty_value = empty_value
216         super().__init__(**kwargs)
217         if min_length is not None:
218             self.validators.append(validators.MinLengthValidator(int(min_length)))
219         if max_length is not None:
220             self.validators.append(validators.MaxLengthValidator(int(max_length)))
221         self.validators.append(validators.ProhibitNullCharactersValidator())
222 
223     def to_python(self, value):
224         """Return a string."""
225         if value not in self.empty_values:
226             value = str(value)
227             if self.strip:
228                 value = value.strip()
229         if value in self.empty_values:
230             return self.empty_value
231         return value
232 
233     def widget_attrs(self, widget):
234         attrs = super().widget_attrs(widget)
235         if self.max_length is not None and not widget.is_hidden:
236             # The HTML attribute is maxlength, not max_length.
237             attrs['maxlength'] = str(self.max_length)
238         if self.min_length is not None and not widget.is_hidden:
239             # The HTML attribute is minlength, not min_length.
240             attrs['minlength'] = str(self.min_length)
241         return attrs
242 
243 
244 class IntegerField(Field):
245     widget = NumberInput
246     default_error_messages = {
247         'invalid': _('Enter a whole number.'),
248     }
249     re_decimal = _lazy_re_compile(r'\.0*\s*$')
250 
251     def __init__(self, *, max_value=None, min_value=None, **kwargs):
252         self.max_value, self.min_value = max_value, min_value
253         if kwargs.get('localize') and self.widget == NumberInput:
254             # Localized number input is not well supported on most browsers
255             kwargs.setdefault('widget', super().widget)
256         super().__init__(**kwargs)
257 
258         if max_value is not None:
259             self.validators.append(validators.MaxValueValidator(max_value))
260         if min_value is not None:
261             self.validators.append(validators.MinValueValidator(min_value))
262 
263     def to_python(self, value):
264         """
265         Validate that int() can be called on the input. Return the result
266         of int() or None for empty values.
267         """
268         value = super().to_python(value)
269         if value in self.empty_values:
270             return None
271         if self.localize:
272             value = formats.sanitize_separators(value)
273         # Strip trailing decimal and zeros.
274         try:
275             value = int(self.re_decimal.sub('', str(value)))
276         except (ValueError, TypeError):
277             raise ValidationError(self.error_messages['invalid'], code='invalid')
278         return value
279 
280     def widget_attrs(self, widget):
281         attrs = super().widget_attrs(widget)
282         if isinstance(widget, NumberInput):
283             if self.min_value is not None:
284                 attrs['min'] = self.min_value
285             if self.max_value is not None:
286                 attrs['max'] = self.max_value
287         return attrs
288 
289 
290 class FloatField(IntegerField):
291     default_error_messages = {
292         'invalid': _('Enter a number.'),
293     }
294 
295     def to_python(self, value):
296         """
297         Validate that float() can be called on the input. Return the result
298         of float() or None for empty values.
299         """
300         value = super(IntegerField, self).to_python(value)
301         if value in self.empty_values:
302             return None
303         if self.localize:
304             value = formats.sanitize_separators(value)
305         try:
306             value = float(value)
307         except (ValueError, TypeError):
308             raise ValidationError(self.error_messages['invalid'], code='invalid')
309         return value
310 
311     def validate(self, value):
312         super().validate(value)
313         if value in self.empty_values:
314             return
315         if not math.isfinite(value):
316             raise ValidationError(self.error_messages['invalid'], code='invalid')
317 
318     def widget_attrs(self, widget):
319         attrs = super().widget_attrs(widget)
320         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:
321             attrs.setdefault('step', 'any')
322         return attrs
323 
324 
325 class DecimalField(IntegerField):
326     default_error_messages = {
327         'invalid': _('Enter a number.'),
328     }
329 
330     def __init__(self, *, max_value=None, min_value=None, max_digits=None, decimal_places=None, **kwargs):
331         self.max_digits, self.decimal_places = max_digits, decimal_places
332         super().__init__(max_value=max_value, min_value=min_value, **kwargs)
333         self.validators.append(validators.DecimalValidator(max_digits, decimal_places))
334 
335     def to_python(self, value):
336         """
337         Validate that the input is a decimal number. Return a Decimal
338         instance or None for empty values. Ensure that there are no more
339         than max_digits in the number and no more than decimal_places digits
340         after the decimal point.
341         """
342         if value in self.empty_values:
343             return None
344         if self.localize:
345             value = formats.sanitize_separators(value)
346         value = str(value).strip()
347         try:
348             value = Decimal(value)
349         except DecimalException:
350             raise ValidationError(self.error_messages['invalid'], code='invalid')
351         return value
352 
353     def validate(self, value):
354         super().validate(value)
355         if value in self.empty_values:
356             return
357         if not value.is_finite():
358             raise ValidationError(self.error_messages['invalid'], code='invalid')
359 
360     def widget_attrs(self, widget):
361         attrs = super().widget_attrs(widget)
362         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:
363             if self.decimal_places is not None:
364                 # Use exponential notation for small values since they might
365                 # be parsed as 0 otherwise. ref #20765
366                 step = str(Decimal(1).scaleb(-self.decimal_places)).lower()
367             else:
368                 step = 'any'
369             attrs.setdefault('step', step)
370         return attrs
371 
372 
373 class BaseTemporalField(Field):
374 
375     def __init__(self, *, input_formats=None, **kwargs):
376         super().__init__(**kwargs)
377         if input_formats is not None:
378             self.input_formats = input_formats
379 
380     def to_python(self, value):
381         value = value.strip()
382         # Try to strptime against each input format.
383         for format in self.input_formats:
384             try:
385                 return self.strptime(value, format)
386             except (ValueError, TypeError):
387                 continue
388         raise ValidationError(self.error_messages['invalid'], code='invalid')
389 
390     def strptime(self, value, format):
391         raise NotImplementedError('Subclasses must define this method.')
392 
393 
394 class DateField(BaseTemporalField):
395     widget = DateInput
396     input_formats = formats.get_format_lazy('DATE_INPUT_FORMATS')
397     default_error_messages = {
398         'invalid': _('Enter a valid date.'),
399     }
400 
401     def to_python(self, value):
402         """
403         Validate that the input can be converted to a date. Return a Python
404         datetime.date object.
405         """
406         if value in self.empty_values:
407             return None
408         if isinstance(value, datetime.datetime):
409             return value.date()
410         if isinstance(value, datetime.date):
411             return value
412         return super().to_python(value)
413 
414     def strptime(self, value, format):
415         return datetime.datetime.strptime(value, format).date()
416 
417 
418 class TimeField(BaseTemporalField):
419     widget = TimeInput
420     input_formats = formats.get_format_lazy('TIME_INPUT_FORMATS')
421     default_error_messages = {
422         'invalid': _('Enter a valid time.')
423     }
424 
425     def to_python(self, value):
426         """
427         Validate that the input can be converted to a time. Return a Python
428         datetime.time object.
429         """
430         if value in self.empty_values:
431             return None
432         if isinstance(value, datetime.time):
433             return value
434         return super().to_python(value)
435 
436     def strptime(self, value, format):
437         return datetime.datetime.strptime(value, format).time()
438 
439 
440 class DateTimeFormatsIterator:
441     def __iter__(self):
442         yield from formats.get_format('DATETIME_INPUT_FORMATS')
443         yield from formats.get_format('DATE_INPUT_FORMATS')
444 
445 
446 class DateTimeField(BaseTemporalField):
447     widget = DateTimeInput
448     input_formats = DateTimeFormatsIterator()
449     default_error_messages = {
450         'invalid': _('Enter a valid date/time.'),
451     }
452 
453     def prepare_value(self, value):
454         if isinstance(value, datetime.datetime):
455             value = to_current_timezone(value)
456         return value
457 
458     def to_python(self, value):
459         """
460         Validate that the input can be converted to a datetime. Return a
461         Python datetime.datetime object.
462         """
463         if value in self.empty_values:
464             return None
465         if isinstance(value, datetime.datetime):
466             return from_current_timezone(value)
467         if isinstance(value, datetime.date):
468             result = datetime.datetime(value.year, value.month, value.day)
469             return from_current_timezone(result)
470         try:
471             result = parse_datetime(value.strip())
472         except ValueError:
473             raise ValidationError(self.error_messages['invalid'], code='invalid')
474         if not result:
475             result = super().to_python(value)
476         return from_current_timezone(result)
477 
478     def strptime(self, value, format):
479         return datetime.datetime.strptime(value, format)
480 
481 
482 class DurationField(Field):
483     default_error_messages = {
484         'invalid': _('Enter a valid duration.'),
485         'overflow': _('The number of days must be between {min_days} and {max_days}.')
486     }
487 
488     def prepare_value(self, value):
489         if isinstance(value, datetime.timedelta):
490             return duration_string(value)
491         return value
492 
493     def to_python(self, value):
494         if value in self.empty_values:
495             return None
496         if isinstance(value, datetime.timedelta):
497             return value
498         try:
499             value = parse_duration(str(value))
500         except OverflowError:
501             raise ValidationError(self.error_messages['overflow'].format(
502                 min_days=datetime.timedelta.min.days,
503                 max_days=datetime.timedelta.max.days,
504             ), code='overflow')
505         if value is None:
506             raise ValidationError(self.error_messages['invalid'], code='invalid')
507         return value
508 
509 
510 class RegexField(CharField):
511     def __init__(self, regex, **kwargs):
512         """
513         regex can be either a string or a compiled regular expression object.
514         """
515         kwargs.setdefault('strip', False)
516         super().__init__(**kwargs)
517         self._set_regex(regex)
518 
519     def _get_regex(self):
520         return self._regex
521 
522     def _set_regex(self, regex):
523         if isinstance(regex, str):
524             regex = re.compile(regex)
525         self._regex = regex
526         if hasattr(self, '_regex_validator') and self._regex_validator in self.validators:
527             self.validators.remove(self._regex_validator)
528         self._regex_validator = validators.RegexValidator(regex=regex)
529         self.validators.append(self._regex_validator)
530 
531     regex = property(_get_regex, _set_regex)
532 
533 
534 class EmailField(CharField):
535     widget = EmailInput
536     default_validators = [validators.validate_email]
537 
538     def __init__(self, **kwargs):
539         super().__init__(strip=True, **kwargs)
540 
541 
542 class FileField(Field):
543     widget = ClearableFileInput
544     default_error_messages = {
545         'invalid': _("No file was submitted. Check the encoding type on the form."),
546         'missing': _("No file was submitted."),
547         'empty': _("The submitted file is empty."),
548         'max_length': ngettext_lazy(
549             'Ensure this filename has at most %(max)d character (it has %(length)d).',
550             'Ensure this filename has at most %(max)d characters (it has %(length)d).',
551             'max'),
552         'contradiction': _('Please either submit a file or check the clear checkbox, not both.')
553     }
554 
555     def __init__(self, *, max_length=None, allow_empty_file=False, **kwargs):
556         self.max_length = max_length
557         self.allow_empty_file = allow_empty_file
558         super().__init__(**kwargs)
559 
560     def to_python(self, data):
561         if data in self.empty_values:
562             return None
563 
564         # UploadedFile objects should have name and size attributes.
565         try:
566             file_name = data.name
567             file_size = data.size
568         except AttributeError:
569             raise ValidationError(self.error_messages['invalid'], code='invalid')
570 
571         if self.max_length is not None and len(file_name) > self.max_length:
572             params = {'max': self.max_length, 'length': len(file_name)}
573             raise ValidationError(self.error_messages['max_length'], code='max_length', params=params)
574         if not file_name:
575             raise ValidationError(self.error_messages['invalid'], code='invalid')
576         if not self.allow_empty_file and not file_size:
577             raise ValidationError(self.error_messages['empty'], code='empty')
578 
579         return data
580 
581     def clean(self, data, initial=None):
582         # If the widget got contradictory inputs, we raise a validation error
583         if data is FILE_INPUT_CONTRADICTION:
584             raise ValidationError(self.error_messages['contradiction'], code='contradiction')
585         # False means the field value should be cleared; further validation is
586         # not needed.
587         if data is False:
588             if not self.required:
589                 return False
590             # If the field is required, clearing is not possible (the widget
591             # shouldn't return False data in that case anyway). False is not
592             # in self.empty_value; if a False value makes it this far
593             # it should be validated from here on out as None (so it will be
594             # caught by the required check).
595             data = None
596         if not data and initial:
597             return initial
598         return super().clean(data)
599 
600     def bound_data(self, data, initial):
601         if data in (None, FILE_INPUT_CONTRADICTION):
602             return initial
603         return data
604 
605     def has_changed(self, initial, data):
606         return not self.disabled and data is not None
607 
608 
609 class ImageField(FileField):
610     default_validators = [validators.validate_image_file_extension]
611     default_error_messages = {
612         'invalid_image': _(
613             "Upload a valid image. The file you uploaded was either not an "
614             "image or a corrupted image."
615         ),
616     }
617 
618     def to_python(self, data):
619         """
620         Check that the file-upload field data contains a valid image (GIF, JPG,
621         PNG, etc. -- whatever Pillow supports).
622         """
623         f = super().to_python(data)
624         if f is None:
625             return None
626 
627         from PIL import Image
628 
629         # We need to get a file object for Pillow. We might have a path or we might
630         # have to read the data into memory.
631         if hasattr(data, 'temporary_file_path'):
632             file = data.temporary_file_path()
633         else:
634             if hasattr(data, 'read'):
635                 file = BytesIO(data.read())
636             else:
637                 file = BytesIO(data['content'])
638 
639         try:
640             # load() could spot a truncated JPEG, but it loads the entire
641             # image in memory, which is a DoS vector. See #3848 and #18520.
642             image = Image.open(file)
643             # verify() must be called immediately after the constructor.
644             image.verify()
645 
646             # Annotating so subclasses can reuse it for their own validation
647             f.image = image
648             # Pillow doesn't detect the MIME type of all formats. In those
649             # cases, content_type will be None.
650             f.content_type = Image.MIME.get(image.format)
651         except Exception as exc:
652             # Pillow doesn't recognize it as an image.
653             raise ValidationError(
654                 self.error_messages['invalid_image'],
655                 code='invalid_image',
656             ) from exc
657         if hasattr(f, 'seek') and callable(f.seek):
658             f.seek(0)
659         return f
660 
661     def widget_attrs(self, widget):
662         attrs = super().widget_attrs(widget)
663         if isinstance(widget, FileInput) and 'accept' not in widget.attrs:
664             attrs.setdefault('accept', 'image/*')
665         return attrs
666 
667 
668 class URLField(CharField):
669     widget = URLInput
670     default_error_messages = {
671         'invalid': _('Enter a valid URL.'),
672     }
673     default_validators = [validators.URLValidator()]
674 
675     def __init__(self, **kwargs):
676         super().__init__(strip=True, **kwargs)
677 
678     def to_python(self, value):
679 
680         def split_url(url):
681             """
682             Return a list of url parts via urlparse.urlsplit(), or raise
683             ValidationError for some malformed URLs.
684             """
685             try:
686                 return list(urlsplit(url))
687             except ValueError:
688                 # urlparse.urlsplit can raise a ValueError with some
689                 # misformatted URLs.
690                 raise ValidationError(self.error_messages['invalid'], code='invalid')
691 
692         value = super().to_python(value)
693         if value:
694             url_fields = split_url(value)
695             if not url_fields[0]:
696                 # If no URL scheme given, assume http://
697                 url_fields[0] = 'http'
698             if not url_fields[1]:
699                 # Assume that if no domain is provided, that the path segment
700                 # contains the domain.
701                 url_fields[1] = url_fields[2]
702                 url_fields[2] = ''
703                 # Rebuild the url_fields list, since the domain segment may now
704                 # contain the path too.
705                 url_fields = split_url(urlunsplit(url_fields))
706             value = urlunsplit(url_fields)
707         return value
708 
709 
710 class BooleanField(Field):
711     widget = CheckboxInput
712 
713     def to_python(self, value):
714         """Return a Python boolean object."""
715         # Explicitly check for the string 'False', which is what a hidden field
716         # will submit for False. Also check for '0', since this is what
717         # RadioSelect will provide. Because bool("True") == bool('1') == True,
718         # we don't need to handle that explicitly.
719         if isinstance(value, str) and value.lower() in ('false', '0'):
720             value = False
721         else:
722             value = bool(value)
723         return super().to_python(value)
724 
725     def validate(self, value):
726         if not value and self.required:
727             raise ValidationError(self.error_messages['required'], code='required')
728 
729     def has_changed(self, initial, data):
730         if self.disabled:
731             return False
732         # Sometimes data or initial may be a string equivalent of a boolean
733         # so we should run it through to_python first to get a boolean value
734         return self.to_python(initial) != self.to_python(data)
735 
736 
737 class NullBooleanField(BooleanField):
738     """
739     A field whose valid values are None, True, and False. Clean invalid values
740     to None.
741     """
742     widget = NullBooleanSelect
743 
744     def to_python(self, value):
745         """
746         Explicitly check for the string 'True' and 'False', which is what a
747         hidden field will submit for True and False, for 'true' and 'false',
748         which are likely to be returned by JavaScript serializations of forms,
749         and for '1' and '0', which is what a RadioField will submit. Unlike
750         the Booleanfield, this field must check for True because it doesn't
751         use the bool() function.
752         """
753         if value in (True, 'True', 'true', '1'):
754             return True
755         elif value in (False, 'False', 'false', '0'):
756             return False
757         else:
758             return None
759 
760     def validate(self, value):
761         pass
762 
763 
764 class CallableChoiceIterator:
765     def __init__(self, choices_func):
766         self.choices_func = choices_func
767 
768     def __iter__(self):
769         yield from self.choices_func()
770 
771 
772 class ChoiceField(Field):
773     widget = Select
774     default_error_messages = {
775         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),
776     }
777 
778     def __init__(self, *, choices=(), **kwargs):
779         super().__init__(**kwargs)
780         self.choices = choices
781 
782     def __deepcopy__(self, memo):
783         result = super().__deepcopy__(memo)
784         result._choices = copy.deepcopy(self._choices, memo)
785         return result
786 
787     def _get_choices(self):
788         return self._choices
789 
790     def _set_choices(self, value):
791         # Setting choices also sets the choices on the widget.
792         # choices can be any iterable, but we call list() on it because
793         # it will be consumed more than once.
794         if callable(value):
795             value = CallableChoiceIterator(value)
796         else:
797             value = list(value)
798 
799         self._choices = self.widget.choices = value
800 
801     choices = property(_get_choices, _set_choices)
802 
803     def to_python(self, value):
804         """Return a string."""
805         if value in self.empty_values:
806             return ''
807         return str(value)
808 
809     def validate(self, value):
810         """Validate that the input is in self.choices."""
811         super().validate(value)
812         if value and not self.valid_value(value):
813             raise ValidationError(
814                 self.error_messages['invalid_choice'],
815                 code='invalid_choice',
816                 params={'value': value},
817             )
818 
819     def valid_value(self, value):
820         """Check to see if the provided value is a valid choice."""
821         text_value = str(value)
822         for k, v in self.choices:
823             if isinstance(v, (list, tuple)):
824                 # This is an optgroup, so look inside the group for options
825                 for k2, v2 in v:
826                     if value == k2 or text_value == str(k2):
827                         return True
828             else:
829                 if value == k or text_value == str(k):
830                     return True
831         return False
832 
833 
834 class TypedChoiceField(ChoiceField):
835     def __init__(self, *, coerce=lambda val: val, empty_value='', **kwargs):
836         self.coerce = coerce
837         self.empty_value = empty_value
838         super().__init__(**kwargs)
839 
840     def _coerce(self, value):
841         """
842         Validate that the value can be coerced to the right type (if not empty).
843         """
844         if value == self.empty_value or value in self.empty_values:
845             return self.empty_value
846         try:
847             value = self.coerce(value)
848         except (ValueError, TypeError, ValidationError):
849             raise ValidationError(
850                 self.error_messages['invalid_choice'],
851                 code='invalid_choice',
852                 params={'value': value},
853             )
854         return value
855 
856     def clean(self, value):
857         value = super().clean(value)
858         return self._coerce(value)
859 
860 
861 class MultipleChoiceField(ChoiceField):
862     hidden_widget = MultipleHiddenInput
863     widget = SelectMultiple
864     default_error_messages = {
865         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),
866         'invalid_list': _('Enter a list of values.'),
867     }
868 
869     def to_python(self, value):
870         if not value:
871             return []
872         elif not isinstance(value, (list, tuple)):
873             raise ValidationError(self.error_messages['invalid_list'], code='invalid_list')
874         return [str(val) for val in value]
875 
876     def validate(self, value):
877         """Validate that the input is a list or tuple."""
878         if self.required and not value:
879             raise ValidationError(self.error_messages['required'], code='required')
880         # Validate that each value in the value list is in self.choices.
881         for val in value:
882             if not self.valid_value(val):
883                 raise ValidationError(
884                     self.error_messages['invalid_choice'],
885                     code='invalid_choice',
886                     params={'value': val},
887                 )
888 
889     def has_changed(self, initial, data):
890         if self.disabled:
891             return False
892         if initial is None:
893             initial = []
894         if data is None:
895             data = []
896         if len(initial) != len(data):
897             return True
898         initial_set = {str(value) for value in initial}
899         data_set = {str(value) for value in data}
900         return data_set != initial_set
901 
902 
903 class TypedMultipleChoiceField(MultipleChoiceField):
904     def __init__(self, *, coerce=lambda val: val, **kwargs):
905         self.coerce = coerce
906         self.empty_value = kwargs.pop('empty_value', [])
907         super().__init__(**kwargs)
908 
909     def _coerce(self, value):
910         """
911         Validate that the values are in self.choices and can be coerced to the
912         right type.
913         """
914         if value == self.empty_value or value in self.empty_values:
915             return self.empty_value
916         new_value = []
917         for choice in value:
918             try:
919                 new_value.append(self.coerce(choice))
920             except (ValueError, TypeError, ValidationError):
921                 raise ValidationError(
922                     self.error_messages['invalid_choice'],
923                     code='invalid_choice',
924                     params={'value': choice},
925                 )
926         return new_value
927 
928     def clean(self, value):
929         value = super().clean(value)
930         return self._coerce(value)
931 
932     def validate(self, value):
933         if value != self.empty_value:
934             super().validate(value)
935         elif self.required:
936             raise ValidationError(self.error_messages['required'], code='required')
937 
938 
939 class ComboField(Field):
940     """
941     A Field whose clean() method calls multiple Field clean() methods.
942     """
943     def __init__(self, fields, **kwargs):
944         super().__init__(**kwargs)
945         # Set 'required' to False on the individual fields, because the
946         # required validation will be handled by ComboField, not by those
947         # individual fields.
948         for f in fields:
949             f.required = False
950         self.fields = fields
951 
952     def clean(self, value):
953         """
954         Validate the given value against all of self.fields, which is a
955         list of Field instances.
956         """
957         super().clean(value)
958         for field in self.fields:
959             value = field.clean(value)
960         return value
961 
962 
963 class MultiValueField(Field):
964     """
965     Aggregate the logic of multiple Fields.
966 
967     Its clean() method takes a "decompressed" list of values, which are then
968     cleaned into a single value according to self.fields. Each value in
969     this list is cleaned by the corresponding field -- the first value is
970     cleaned by the first field, the second value is cleaned by the second
971     field, etc. Once all fields are cleaned, the list of clean values is
972     "compressed" into a single value.
973 
974     Subclasses should not have to implement clean(). Instead, they must
975     implement compress(), which takes a list of valid values and returns a
976     "compressed" version of those values -- a single value.
977 
978     You'll probably want to use this with MultiWidget.
979     """
980     default_error_messages = {
981         'invalid': _('Enter a list of values.'),
982         'incomplete': _('Enter a complete value.'),
983     }
984 
985     def __init__(self, fields, *, require_all_fields=True, **kwargs):
986         self.require_all_fields = require_all_fields
987         super().__init__(**kwargs)
988         for f in fields:
989             f.error_messages.setdefault('incomplete',
990                                         self.error_messages['incomplete'])
991             if self.disabled:
992                 f.disabled = True
993             if self.require_all_fields:
994                 # Set 'required' to False on the individual fields, because the
995                 # required validation will be handled by MultiValueField, not
996                 # by those individual fields.
997                 f.required = False
998         self.fields = fields
999 
1000     def __deepcopy__(self, memo):
1001         result = super().__deepcopy__(memo)
1002         result.fields = tuple(x.__deepcopy__(memo) for x in self.fields)
1003         return result
1004 
1005     def validate(self, value):
1006         pass
1007 
1008     def clean(self, value):
1009         """
1010         Validate every value in the given list. A value is validated against
1011         the corresponding Field in self.fields.
1012 
1013         For example, if this MultiValueField was instantiated with
1014         fields=(DateField(), TimeField()), clean() would call
1015         DateField.clean(value[0]) and TimeField.clean(value[1]).
1016         """
1017         clean_data = []
1018         errors = []
1019         if self.disabled and not isinstance(value, list):
1020             value = self.widget.decompress(value)
1021         if not value or isinstance(value, (list, tuple)):
1022             if not value or not [v for v in value if v not in self.empty_values]:
1023                 if self.required:
1024                     raise ValidationError(self.error_messages['required'], code='required')
1025                 else:
1026                     return self.compress([])
1027         else:
1028             raise ValidationError(self.error_messages['invalid'], code='invalid')
1029         for i, field in enumerate(self.fields):
1030             try:
1031                 field_value = value[i]
1032             except IndexError:
1033                 field_value = None
1034             if field_value in self.empty_values:
1035                 if self.require_all_fields:
1036                     # Raise a 'required' error if the MultiValueField is
1037                     # required and any field is empty.
1038                     if self.required:
1039                         raise ValidationError(self.error_messages['required'], code='required')
1040                 elif field.required:
1041                     # Otherwise, add an 'incomplete' error to the list of
1042                     # collected errors and skip field cleaning, if a required
1043                     # field is empty.
1044                     if field.error_messages['incomplete'] not in errors:
1045                         errors.append(field.error_messages['incomplete'])
1046                     continue
1047             try:
1048                 clean_data.append(field.clean(field_value))
1049             except ValidationError as e:
1050                 # Collect all validation errors in a single list, which we'll
1051                 # raise at the end of clean(), rather than raising a single
1052                 # exception for the first error we encounter. Skip duplicates.
1053                 errors.extend(m for m in e.error_list if m not in errors)
1054         if errors:
1055             raise ValidationError(errors)
1056 
1057         out = self.compress(clean_data)
1058         self.validate(out)
1059         self.run_validators(out)
1060         return out
1061 
1062     def compress(self, data_list):
1063         """
1064         Return a single value for the given list of values. The values can be
1065         assumed to be valid.
1066 
1067         For example, if this MultiValueField was instantiated with
1068         fields=(DateField(), TimeField()), this might return a datetime
1069         object created by combining the date and time in data_list.
1070         """
1071         raise NotImplementedError('Subclasses must implement this method.')
1072 
1073     def has_changed(self, initial, data):
1074         if self.disabled:
1075             return False
1076         if initial is None:
1077             initial = ['' for x in range(0, len(data))]
1078         else:
1079             if not isinstance(initial, list):
1080                 initial = self.widget.decompress(initial)
1081         for field, initial, data in zip(self.fields, initial, data):
1082             try:
1083                 initial = field.to_python(initial)
1084             except ValidationError:
1085                 return True
1086             if field.has_changed(initial, data):
1087                 return True
1088         return False
1089 
1090 
1091 class FilePathField(ChoiceField):
1092     def __init__(self, path, *, match=None, recursive=False, allow_files=True,
1093                  allow_folders=False, **kwargs):
1094         self.path, self.match, self.recursive = path, match, recursive
1095         self.allow_files, self.allow_folders = allow_files, allow_folders
1096         super().__init__(choices=(), **kwargs)
1097 
1098         if self.required:
1099             self.choices = []
1100         else:
1101             self.choices = [("", "---------")]
1102 
1103         if self.match is not None:
1104             self.match_re = re.compile(self.match)
1105 
1106         if recursive:
1107             for root, dirs, files in sorted(os.walk(self.path)):
1108                 if self.allow_files:
1109                     for f in sorted(files):
1110                         if self.match is None or self.match_re.search(f):
1111                             f = os.path.join(root, f)
1112                             self.choices.append((f, f.replace(path, "", 1)))
1113                 if self.allow_folders:
1114                     for f in sorted(dirs):
1115                         if f == '__pycache__':
1116                             continue
1117                         if self.match is None or self.match_re.search(f):
1118                             f = os.path.join(root, f)
1119                             self.choices.append((f, f.replace(path, "", 1)))
1120         else:
1121             choices = []
1122             for f in os.scandir(self.path):
1123                 if f.name == '__pycache__':
1124                     continue
1125                 if (((self.allow_files and f.is_file()) or
1126                         (self.allow_folders and f.is_dir())) and
1127                         (self.match is None or self.match_re.search(f.name))):
1128                     choices.append((f.path, f.name))
1129             choices.sort(key=operator.itemgetter(1))
1130             self.choices.extend(choices)
1131 
1132         self.widget.choices = self.choices
1133 
1134 
1135 class SplitDateTimeField(MultiValueField):
1136     widget = SplitDateTimeWidget
1137     hidden_widget = SplitHiddenDateTimeWidget
1138     default_error_messages = {
1139         'invalid_date': _('Enter a valid date.'),
1140         'invalid_time': _('Enter a valid time.'),
1141     }
1142 
1143     def __init__(self, *, input_date_formats=None, input_time_formats=None, **kwargs):
1144         errors = self.default_error_messages.copy()
1145         if 'error_messages' in kwargs:
1146             errors.update(kwargs['error_messages'])
1147         localize = kwargs.get('localize', False)
1148         fields = (
1149             DateField(input_formats=input_date_formats,
1150                       error_messages={'invalid': errors['invalid_date']},
1151                       localize=localize),
1152             TimeField(input_formats=input_time_formats,
1153                       error_messages={'invalid': errors['invalid_time']},
1154                       localize=localize),
1155         )
1156         super().__init__(fields, **kwargs)
1157 
1158     def compress(self, data_list):
1159         if data_list:
1160             # Raise a validation error if time or date is empty
1161             # (possible if SplitDateTimeField has required=False).
1162             if data_list[0] in self.empty_values:
1163                 raise ValidationError(self.error_messages['invalid_date'], code='invalid_date')
1164             if data_list[1] in self.empty_values:
1165                 raise ValidationError(self.error_messages['invalid_time'], code='invalid_time')
1166             result = datetime.datetime.combine(*data_list)
1167             return from_current_timezone(result)
1168         return None
1169 
1170 
1171 class GenericIPAddressField(CharField):
1172     def __init__(self, *, protocol='both', unpack_ipv4=False, **kwargs):
1173         self.unpack_ipv4 = unpack_ipv4
1174         self.default_validators = validators.ip_address_validators(protocol, unpack_ipv4)[0]
1175         super().__init__(**kwargs)
1176 
1177     def to_python(self, value):
1178         if value in self.empty_values:
1179             return ''
1180         value = value.strip()
1181         if value and ':' in value:
1182             return clean_ipv6_address(value, self.unpack_ipv4)
1183         return value
1184 
1185 
1186 class SlugField(CharField):
1187     default_validators = [validators.validate_slug]
1188 
1189     def __init__(self, *, allow_unicode=False, **kwargs):
1190         self.allow_unicode = allow_unicode
1191         if self.allow_unicode:
1192             self.default_validators = [validators.validate_unicode_slug]
1193         super().__init__(**kwargs)
1194 
1195 
1196 class UUIDField(CharField):
1197     default_error_messages = {
1198         'invalid': _('Enter a valid UUID.'),
1199     }
1200 
1201     def prepare_value(self, value):
1202         if isinstance(value, uuid.UUID):
1203             return str(value)
1204         return value
1205 
1206     def to_python(self, value):
1207         value = super().to_python(value)
1208         if value in self.empty_values:
1209             return None
1210         if not isinstance(value, uuid.UUID):
1211             try:
1212                 value = uuid.UUID(value)
1213             except ValueError:
1214                 raise ValidationError(self.error_messages['invalid'], code='invalid')
1215         return value
1216 
1217 
1218 class InvalidJSONInput(str):
1219     pass
1220 
1221 
1222 class JSONString(str):
1223     pass
1224 
1225 
1226 class JSONField(CharField):
1227     default_error_messages = {
1228         'invalid': _('Enter a valid JSON.'),
1229     }
1230     widget = Textarea
1231 
1232     def __init__(self, encoder=None, decoder=None, **kwargs):
1233         self.encoder = encoder
1234         self.decoder = decoder
1235         super().__init__(**kwargs)
1236 
1237     def to_python(self, value):
1238         if self.disabled:
1239             return value
1240         if value in self.empty_values:
1241             return None
1242         elif isinstance(value, (list, dict, int, float, JSONString)):
1243             return value
1244         try:
1245             converted = json.loads(value, cls=self.decoder)
1246         except json.JSONDecodeError:
1247             raise ValidationError(
1248                 self.error_messages['invalid'],
1249                 code='invalid',
1250                 params={'value': value},
1251             )
1252         if isinstance(converted, str):
1253             return JSONString(converted)
1254         else:
1255             return converted
1256 
1257     def bound_data(self, data, initial):
1258         if self.disabled:
1259             return initial
1260         try:
1261             return json.loads(data, cls=self.decoder)
1262         except json.JSONDecodeError:
1263             return InvalidJSONInput(data)
1264 
1265     def prepare_value(self, value):
1266         if isinstance(value, InvalidJSONInput):
1267             return value
1268         return json.dumps(value, cls=self.encoder)
1269 
1270     def has_changed(self, initial, data):
1271         if super().has_changed(initial, data):
1272             return True
1273         # For purposes of seeing whether something has changed, True isn't the
1274         # same as 1 and the order of keys doesn't matter.
1275         return (
1276             json.dumps(initial, sort_keys=True, cls=self.encoder) !=
1277             json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder)
1278         )

</code><intended_behavior>In every method within form field classes that raises a ValidationError, modify the call to pass the field's value to the exception. This ensures that form validation errors can include the specific value that failed validation, aiding in debugging and user feedback.</intended_behavior>, <file>django/db/models/fields/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections.abc
2 import copy
3 import datetime
4 import decimal
5 import operator
6 import uuid
7 import warnings
8 from base64 import b64decode, b64encode
9 from functools import partialmethod, total_ordering
10 
11 from django import forms
12 from django.apps import apps
13 from django.conf import settings
14 from django.core import checks, exceptions, validators
15 from django.db import connection, connections, router
16 from django.db.models.constants import LOOKUP_SEP
17 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin
18 from django.utils import timezone
19 from django.utils.datastructures import DictWrapper
20 from django.utils.dateparse import (
21     parse_date, parse_datetime, parse_duration, parse_time,
22 )
23 from django.utils.duration import duration_microseconds, duration_string
24 from django.utils.functional import Promise, cached_property
25 from django.utils.ipv6 import clean_ipv6_address
26 from django.utils.itercompat import is_iterable
27 from django.utils.text import capfirst
28 from django.utils.translation import gettext_lazy as _
29 
30 __all__ = [
31     'AutoField', 'BLANK_CHOICE_DASH', 'BigAutoField', 'BigIntegerField',
32     'BinaryField', 'BooleanField', 'CharField', 'CommaSeparatedIntegerField',
33     'DateField', 'DateTimeField', 'DecimalField', 'DurationField',
34     'EmailField', 'Empty', 'Field', 'FilePathField', 'FloatField',
35     'GenericIPAddressField', 'IPAddressField', 'IntegerField', 'NOT_PROVIDED',
36     'NullBooleanField', 'PositiveBigIntegerField', 'PositiveIntegerField',
37     'PositiveSmallIntegerField', 'SlugField', 'SmallAutoField',
38     'SmallIntegerField', 'TextField', 'TimeField', 'URLField', 'UUIDField',
39 ]
40 
41 
42 class Empty:
43     pass
44 
45 
46 class NOT_PROVIDED:
47     pass
48 
49 
50 # The values to use for "blank" in SelectFields. Will be appended to the start
51 # of most "choices" lists.
52 BLANK_CHOICE_DASH = [("", "---------")]
53 
54 
55 def _load_field(app_label, model_name, field_name):
56     return apps.get_model(app_label, model_name)._meta.get_field(field_name)
57 
58 
59 # A guide to Field parameters:
60 #
61 #   * name:      The name of the field specified in the model.
62 #   * attname:   The attribute to use on the model object. This is the same as
63 #                "name", except in the case of ForeignKeys, where "_id" is
64 #                appended.
65 #   * db_column: The db_column specified in the model (or None).
66 #   * column:    The database column for this field. This is the same as
67 #                "attname", except if db_column is specified.
68 #
69 # Code that introspects values, or does other dynamic things, should use
70 # attname. For example, this gets the primary key value of object "obj":
71 #
72 #     getattr(obj, opts.pk.attname)
73 
74 def _empty(of_cls):
75     new = Empty()
76     new.__class__ = of_cls
77     return new
78 
79 
80 def return_None():
81     return None
82 
83 
84 @total_ordering
85 class Field(RegisterLookupMixin):
86     """Base class for all field types"""
87 
88     # Designates whether empty strings fundamentally are allowed at the
89     # database level.
90     empty_strings_allowed = True
91     empty_values = list(validators.EMPTY_VALUES)
92 
93     # These track each time a Field instance is created. Used to retain order.
94     # The auto_creation_counter is used for fields that Django implicitly
95     # creates, creation_counter is used for all user-specified fields.
96     creation_counter = 0
97     auto_creation_counter = -1
98     default_validators = []  # Default set of validators
99     default_error_messages = {
100         'invalid_choice': _('Value %(value)r is not a valid choice.'),
101         'null': _('This field cannot be null.'),
102         'blank': _('This field cannot be blank.'),
103         'unique': _('%(model_name)s with this %(field_label)s '
104                     'already exists.'),
105         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.
106         # Eg: "Title must be unique for pub_date year"
107         'unique_for_date': _("%(field_label)s must be unique for "
108                              "%(date_field_label)s %(lookup_type)s."),
109     }
110     system_check_deprecated_details = None
111     system_check_removed_details = None
112 
113     # Field flags
114     hidden = False
115 
116     many_to_many = None
117     many_to_one = None
118     one_to_many = None
119     one_to_one = None
120     related_model = None
121 
122     descriptor_class = DeferredAttribute
123 
124     # Generic field type description, usually overridden by subclasses
125     def _description(self):
126         return _('Field of type: %(field_type)s') % {
127             'field_type': self.__class__.__name__
128         }
129     description = property(_description)
130 
131     def __init__(self, verbose_name=None, name=None, primary_key=False,
132                  max_length=None, unique=False, blank=False, null=False,
133                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,
134                  serialize=True, unique_for_date=None, unique_for_month=None,
135                  unique_for_year=None, choices=None, help_text='', db_column=None,
136                  db_tablespace=None, auto_created=False, validators=(),
137                  error_messages=None):
138         self.name = name
139         self.verbose_name = verbose_name  # May be set by set_attributes_from_name
140         self._verbose_name = verbose_name  # Store original for deconstruction
141         self.primary_key = primary_key
142         self.max_length, self._unique = max_length, unique
143         self.blank, self.null = blank, null
144         self.remote_field = rel
145         self.is_relation = self.remote_field is not None
146         self.default = default
147         self.editable = editable
148         self.serialize = serialize
149         self.unique_for_date = unique_for_date
150         self.unique_for_month = unique_for_month
151         self.unique_for_year = unique_for_year
152         if isinstance(choices, collections.abc.Iterator):
153             choices = list(choices)
154         self.choices = choices
155         self.help_text = help_text
156         self.db_index = db_index
157         self.db_column = db_column
158         self._db_tablespace = db_tablespace
159         self.auto_created = auto_created
160 
161         # Adjust the appropriate creation counter, and save our local copy.
162         if auto_created:
163             self.creation_counter = Field.auto_creation_counter
164             Field.auto_creation_counter -= 1
165         else:
166             self.creation_counter = Field.creation_counter
167             Field.creation_counter += 1
168 
169         self._validators = list(validators)  # Store for deconstruction later
170 
171         messages = {}
172         for c in reversed(self.__class__.__mro__):
173             messages.update(getattr(c, 'default_error_messages', {}))
174         messages.update(error_messages or {})
175         self._error_messages = error_messages  # Store for deconstruction later
176         self.error_messages = messages
177 
178     def __str__(self):
179         """
180         Return "app_label.model_label.field_name" for fields attached to
181         models.
182         """
183         if not hasattr(self, 'model'):
184             return super().__str__()
185         model = self.model
186         app = model._meta.app_label
187         return '%s.%s.%s' % (app, model._meta.object_name, self.name)
188 
189     def __repr__(self):
190         """Display the module, class, and name of the field."""
191         path = '%s.%s' % (self.__class__.__module__, self.__class__.__qualname__)
192         name = getattr(self, 'name', None)
193         if name is not None:
194             return '<%s: %s>' % (path, name)
195         return '<%s>' % path
196 
197     def check(self, **kwargs):
198         return [
199             *self._check_field_name(),
200             *self._check_choices(),
201             *self._check_db_index(),
202             *self._check_null_allowed_for_primary_keys(),
203             *self._check_backend_specific_checks(**kwargs),
204             *self._check_validators(),
205             *self._check_deprecation_details(),
206         ]
207 
208     def _check_field_name(self):
209         """
210         Check if field name is valid, i.e. 1) does not end with an
211         underscore, 2) does not contain "__" and 3) is not "pk".
212         """
213         if self.name.endswith('_'):
214             return [
215                 checks.Error(
216                     'Field names must not end with an underscore.',
217                     obj=self,
218                     id='fields.E001',
219                 )
220             ]
221         elif LOOKUP_SEP in self.name:
222             return [
223                 checks.Error(
224                     'Field names must not contain "%s".' % LOOKUP_SEP,
225                     obj=self,
226                     id='fields.E002',
227                 )
228             ]
229         elif self.name == 'pk':
230             return [
231                 checks.Error(
232                     "'pk' is a reserved word that cannot be used as a field name.",
233                     obj=self,
234                     id='fields.E003',
235                 )
236             ]
237         else:
238             return []
239 
240     @classmethod
241     def _choices_is_value(cls, value):
242         return isinstance(value, (str, Promise)) or not is_iterable(value)
243 
244     def _check_choices(self):
245         if not self.choices:
246             return []
247 
248         if not is_iterable(self.choices) or isinstance(self.choices, str):
249             return [
250                 checks.Error(
251                     "'choices' must be an iterable (e.g., a list or tuple).",
252                     obj=self,
253                     id='fields.E004',
254                 )
255             ]
256 
257         choice_max_length = 0
258         # Expect [group_name, [value, display]]
259         for choices_group in self.choices:
260             try:
261                 group_name, group_choices = choices_group
262             except (TypeError, ValueError):
263                 # Containing non-pairs
264                 break
265             try:
266                 if not all(
267                     self._choices_is_value(value) and self._choices_is_value(human_name)
268                     for value, human_name in group_choices
269                 ):
270                     break
271                 if self.max_length is not None and group_choices:
272                     choice_max_length = max([
273                         choice_max_length,
274                         *(len(value) for value, _ in group_choices if isinstance(value, str)),
275                     ])
276             except (TypeError, ValueError):
277                 # No groups, choices in the form [value, display]
278                 value, human_name = group_name, group_choices
279                 if not self._choices_is_value(value) or not self._choices_is_value(human_name):
280                     break
281                 if self.max_length is not None and isinstance(value, str):
282                     choice_max_length = max(choice_max_length, len(value))
283 
284             # Special case: choices=['ab']
285             if isinstance(choices_group, str):
286                 break
287         else:
288             if self.max_length is not None and choice_max_length > self.max_length:
289                 return [
290                     checks.Error(
291                         "'max_length' is too small to fit the longest value "
292                         "in 'choices' (%d characters)." % choice_max_length,
293                         obj=self,
294                         id='fields.E009',
295                     ),
296                 ]
297             return []
298 
299         return [
300             checks.Error(
301                 "'choices' must be an iterable containing "
302                 "(actual value, human readable name) tuples.",
303                 obj=self,
304                 id='fields.E005',
305             )
306         ]
307 
308     def _check_db_index(self):
309         if self.db_index not in (None, True, False):
310             return [
311                 checks.Error(
312                     "'db_index' must be None, True or False.",
313                     obj=self,
314                     id='fields.E006',
315                 )
316             ]
317         else:
318             return []
319 
320     def _check_null_allowed_for_primary_keys(self):
321         if (self.primary_key and self.null and
322                 not connection.features.interprets_empty_strings_as_nulls):
323             # We cannot reliably check this for backends like Oracle which
324             # consider NULL and '' to be equal (and thus set up
325             # character-based fields a little differently).
326             return [
327                 checks.Error(
328                     'Primary keys must not have null=True.',
329                     hint=('Set null=False on the field, or '
330                           'remove primary_key=True argument.'),
331                     obj=self,
332                     id='fields.E007',
333                 )
334             ]
335         else:
336             return []
337 
338     def _check_backend_specific_checks(self, databases=None, **kwargs):
339         if databases is None:
340             return []
341         app_label = self.model._meta.app_label
342         errors = []
343         for alias in databases:
344             if router.allow_migrate(alias, app_label, model_name=self.model._meta.model_name):
345                 errors.extend(connections[alias].validation.check_field(self, **kwargs))
346         return errors
347 
348     def _check_validators(self):
349         errors = []
350         for i, validator in enumerate(self.validators):
351             if not callable(validator):
352                 errors.append(
353                     checks.Error(
354                         "All 'validators' must be callable.",
355                         hint=(
356                             "validators[{i}] ({repr}) isn't a function or "
357                             "instance of a validator class.".format(
358                                 i=i, repr=repr(validator),
359                             )
360                         ),
361                         obj=self,
362                         id='fields.E008',
363                     )
364                 )
365         return errors
366 
367     def _check_deprecation_details(self):
368         if self.system_check_removed_details is not None:
369             return [
370                 checks.Error(
371                     self.system_check_removed_details.get(
372                         'msg',
373                         '%s has been removed except for support in historical '
374                         'migrations.' % self.__class__.__name__
375                     ),
376                     hint=self.system_check_removed_details.get('hint'),
377                     obj=self,
378                     id=self.system_check_removed_details.get('id', 'fields.EXXX'),
379                 )
380             ]
381         elif self.system_check_deprecated_details is not None:
382             return [
383                 checks.Warning(
384                     self.system_check_deprecated_details.get(
385                         'msg',
386                         '%s has been deprecated.' % self.__class__.__name__
387                     ),
388                     hint=self.system_check_deprecated_details.get('hint'),
389                     obj=self,
390                     id=self.system_check_deprecated_details.get('id', 'fields.WXXX'),
391                 )
392             ]
393         return []
394 
395     def get_col(self, alias, output_field=None):
396         if output_field is None:
397             output_field = self
398         if alias != self.model._meta.db_table or output_field != self:
399             from django.db.models.expressions import Col
400             return Col(alias, self, output_field)
401         else:
402             return self.cached_col
403 
404     @cached_property
405     def cached_col(self):
406         from django.db.models.expressions import Col
407         return Col(self.model._meta.db_table, self)
408 
409     def select_format(self, compiler, sql, params):
410         """
411         Custom format for select clauses. For example, GIS columns need to be
412         selected as AsText(table.col) on MySQL as the table.col data can't be
413         used by Django.
414         """
415         return sql, params
416 
417     def deconstruct(self):
418         """
419         Return enough information to recreate the field as a 4-tuple:
420 
421          * The name of the field on the model, if contribute_to_class() has
422            been run.
423          * The import path of the field, including the class:e.g.
424            django.db.models.IntegerField This should be the most portable
425            version, so less specific may be better.
426          * A list of positional arguments.
427          * A dict of keyword arguments.
428 
429         Note that the positional or keyword arguments must contain values of
430         the following types (including inner values of collection types):
431 
432          * None, bool, str, int, float, complex, set, frozenset, list, tuple,
433            dict
434          * UUID
435          * datetime.datetime (naive), datetime.date
436          * top-level classes, top-level functions - will be referenced by their
437            full import path
438          * Storage instances - these have their own deconstruct() method
439 
440         This is because the values here must be serialized into a text format
441         (possibly new Python code, possibly JSON) and these are the only types
442         with encoding handlers defined.
443 
444         There's no need to return the exact way the field was instantiated this
445         time, just ensure that the resulting field is the same - prefer keyword
446         arguments over positional ones, and omit parameters with their default
447         values.
448         """
449         # Short-form way of fetching all the default parameters
450         keywords = {}
451         possibles = {
452             "verbose_name": None,
453             "primary_key": False,
454             "max_length": None,
455             "unique": False,
456             "blank": False,
457             "null": False,
458             "db_index": False,
459             "default": NOT_PROVIDED,
460             "editable": True,
461             "serialize": True,
462             "unique_for_date": None,
463             "unique_for_month": None,
464             "unique_for_year": None,
465             "choices": None,
466             "help_text": '',
467             "db_column": None,
468             "db_tablespace": None,
469             "auto_created": False,
470             "validators": [],
471             "error_messages": None,
472         }
473         attr_overrides = {
474             "unique": "_unique",
475             "error_messages": "_error_messages",
476             "validators": "_validators",
477             "verbose_name": "_verbose_name",
478             "db_tablespace": "_db_tablespace",
479         }
480         equals_comparison = {"choices", "validators"}
481         for name, default in possibles.items():
482             value = getattr(self, attr_overrides.get(name, name))
483             # Unroll anything iterable for choices into a concrete list
484             if name == "choices" and isinstance(value, collections.abc.Iterable):
485                 value = list(value)
486             # Do correct kind of comparison
487             if name in equals_comparison:
488                 if value != default:
489                     keywords[name] = value
490             else:
491                 if value is not default:
492                     keywords[name] = value
493         # Work out path - we shorten it for known Django core fields
494         path = "%s.%s" % (self.__class__.__module__, self.__class__.__qualname__)
495         if path.startswith("django.db.models.fields.related"):
496             path = path.replace("django.db.models.fields.related", "django.db.models")
497         elif path.startswith("django.db.models.fields.files"):
498             path = path.replace("django.db.models.fields.files", "django.db.models")
499         elif path.startswith('django.db.models.fields.json'):
500             path = path.replace('django.db.models.fields.json', 'django.db.models')
501         elif path.startswith("django.db.models.fields.proxy"):
502             path = path.replace("django.db.models.fields.proxy", "django.db.models")
503         elif path.startswith("django.db.models.fields"):
504             path = path.replace("django.db.models.fields", "django.db.models")
505         # Return basic info - other fields should override this.
506         return (self.name, path, [], keywords)
507 
508     def clone(self):
509         """
510         Uses deconstruct() to clone a new copy of this Field.
511         Will not preserve any class attachments/attribute names.
512         """
513         name, path, args, kwargs = self.deconstruct()
514         return self.__class__(*args, **kwargs)
515 
516     def __eq__(self, other):
517         # Needed for @total_ordering
518         if isinstance(other, Field):
519             return self.creation_counter == other.creation_counter
520         return NotImplemented
521 
522     def __lt__(self, other):
523         # This is needed because bisect does not take a comparison function.
524         if isinstance(other, Field):
525             return self.creation_counter < other.creation_counter
526         return NotImplemented
527 
528     def __hash__(self):
529         return hash(self.creation_counter)
530 
531     def __deepcopy__(self, memodict):
532         # We don't have to deepcopy very much here, since most things are not
533         # intended to be altered after initial creation.
534         obj = copy.copy(self)
535         if self.remote_field:
536             obj.remote_field = copy.copy(self.remote_field)
537             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:
538                 obj.remote_field.field = obj
539         memodict[id(self)] = obj
540         return obj
541 
542     def __copy__(self):
543         # We need to avoid hitting __reduce__, so define this
544         # slightly weird copy construct.
545         obj = Empty()
546         obj.__class__ = self.__class__
547         obj.__dict__ = self.__dict__.copy()
548         return obj
549 
550     def __reduce__(self):
551         """
552         Pickling should return the model._meta.fields instance of the field,
553         not a new copy of that field. So, use the app registry to load the
554         model and then the field back.
555         """
556         if not hasattr(self, 'model'):
557             # Fields are sometimes used without attaching them to models (for
558             # example in aggregation). In this case give back a plain field
559             # instance. The code below will create a new empty instance of
560             # class self.__class__, then update its dict with self.__dict__
561             # values - so, this is very close to normal pickle.
562             state = self.__dict__.copy()
563             # The _get_default cached_property can't be pickled due to lambda
564             # usage.
565             state.pop('_get_default', None)
566             return _empty, (self.__class__,), state
567         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,
568                              self.name)
569 
570     def get_pk_value_on_save(self, instance):
571         """
572         Hook to generate new PK values on save. This method is called when
573         saving instances with no primary key value set. If this method returns
574         something else than None, then the returned value is used when saving
575         the new instance.
576         """
577         if self.default:
578             return self.get_default()
579         return None
580 
581     def to_python(self, value):
582         """
583         Convert the input value into the expected Python data type, raising
584         django.core.exceptions.ValidationError if the data can't be converted.
585         Return the converted value. Subclasses should override this.
586         """
587         return value
588 
589     @cached_property
590     def validators(self):
591         """
592         Some validators can't be created at field initialization time.
593         This method provides a way to delay their creation until required.
594         """
595         return [*self.default_validators, *self._validators]
596 
597     def run_validators(self, value):
598         if value in self.empty_values:
599             return
600 
601         errors = []
602         for v in self.validators:
603             try:
604                 v(value)
605             except exceptions.ValidationError as e:
606                 if hasattr(e, 'code') and e.code in self.error_messages:
607                     e.message = self.error_messages[e.code]
608                 errors.extend(e.error_list)
609 
610         if errors:
611             raise exceptions.ValidationError(errors)
612 
613     def validate(self, value, model_instance):
614         """
615         Validate value and raise ValidationError if necessary. Subclasses
616         should override this to provide validation logic.
617         """
618         if not self.editable:
619             # Skip validation for non-editable fields.
620             return
621 
622         if self.choices is not None and value not in self.empty_values:
623             for option_key, option_value in self.choices:
624                 if isinstance(option_value, (list, tuple)):
625                     # This is an optgroup, so look inside the group for
626                     # options.
627                     for optgroup_key, optgroup_value in option_value:
628                         if value == optgroup_key:
629                             return
630                 elif value == option_key:
631                     return
632             raise exceptions.ValidationError(
633                 self.error_messages['invalid_choice'],
634                 code='invalid_choice',
635                 params={'value': value},
636             )
637 
638         if value is None and not self.null:
639             raise exceptions.ValidationError(self.error_messages['null'], code='null')
640 
641         if not self.blank and value in self.empty_values:
642             raise exceptions.ValidationError(self.error_messages['blank'], code='blank')
643 
644     def clean(self, value, model_instance):
645         """
646         Convert the value's type and run validation. Validation errors
647         from to_python() and validate() are propagated. Return the correct
648         value if no error is raised.
649         """
650         value = self.to_python(value)
651         self.validate(value, model_instance)
652         self.run_validators(value)
653         return value
654 
655     def db_type_parameters(self, connection):
656         return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')
657 
658     def db_check(self, connection):
659         """
660         Return the database column check constraint for this field, for the
661         provided connection. Works the same way as db_type() for the case that
662         get_internal_type() does not map to a preexisting model field.
663         """
664         data = self.db_type_parameters(connection)
665         try:
666             return connection.data_type_check_constraints[self.get_internal_type()] % data
667         except KeyError:
668             return None
669 
670     def db_type(self, connection):
671         """
672         Return the database column data type for this field, for the provided
673         connection.
674         """
675         # The default implementation of this method looks at the
676         # backend-specific data_types dictionary, looking up the field by its
677         # "internal type".
678         #
679         # A Field class can implement the get_internal_type() method to specify
680         # which *preexisting* Django Field class it's most similar to -- i.e.,
681         # a custom field might be represented by a TEXT column type, which is
682         # the same as the TextField Django field type, which means the custom
683         # field's get_internal_type() returns 'TextField'.
684         #
685         # But the limitation of the get_internal_type() / data_types approach
686         # is that it cannot handle database column types that aren't already
687         # mapped to one of the built-in Django field types. In this case, you
688         # can implement db_type() instead of get_internal_type() to specify
689         # exactly which wacky database column type you want to use.
690         data = self.db_type_parameters(connection)
691         try:
692             return connection.data_types[self.get_internal_type()] % data
693         except KeyError:
694             return None
695 
696     def rel_db_type(self, connection):
697         """
698         Return the data type that a related field pointing to this field should
699         use. For example, this method is called by ForeignKey and OneToOneField
700         to determine its data type.
701         """
702         return self.db_type(connection)
703 
704     def cast_db_type(self, connection):
705         """Return the data type to use in the Cast() function."""
706         db_type = connection.ops.cast_data_types.get(self.get_internal_type())
707         if db_type:
708             return db_type % self.db_type_parameters(connection)
709         return self.db_type(connection)
710 
711     def db_parameters(self, connection):
712         """
713         Extension of db_type(), providing a range of different return values
714         (type, checks). This will look at db_type(), allowing custom model
715         fields to override it.
716         """
717         type_string = self.db_type(connection)
718         check_string = self.db_check(connection)
719         return {
720             "type": type_string,
721             "check": check_string,
722         }
723 
724     def db_type_suffix(self, connection):
725         return connection.data_types_suffix.get(self.get_internal_type())
726 
727     def get_db_converters(self, connection):
728         if hasattr(self, 'from_db_value'):
729             return [self.from_db_value]
730         return []
731 
732     @property
733     def unique(self):
734         return self._unique or self.primary_key
735 
736     @property
737     def db_tablespace(self):
738         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE
739 
740     @property
741     def db_returning(self):
742         """
743         Private API intended only to be used by Django itself. Currently only
744         the PostgreSQL backend supports returning multiple fields on a model.
745         """
746         return False
747 
748     def set_attributes_from_name(self, name):
749         self.name = self.name or name
750         self.attname, self.column = self.get_attname_column()
751         self.concrete = self.column is not None
752         if self.verbose_name is None and self.name:
753             self.verbose_name = self.name.replace('_', ' ')
754 
755     def contribute_to_class(self, cls, name, private_only=False):
756         """
757         Register the field with the model class it belongs to.
758 
759         If private_only is True, create a separate instance of this field
760         for every subclass of cls, even if cls is not an abstract model.
761         """
762         self.set_attributes_from_name(name)
763         self.model = cls
764         cls._meta.add_field(self, private=private_only)
765         if self.column:
766             # Don't override classmethods with the descriptor. This means that
767             # if you have a classmethod and a field with the same name, then
768             # such fields can't be deferred (we don't have a check for this).
769             if not getattr(cls, self.attname, None):
770                 setattr(cls, self.attname, self.descriptor_class(self))
771         if self.choices is not None:
772             # Don't override a get_FOO_display() method defined explicitly on
773             # this class, but don't check methods derived from inheritance, to
774             # allow overriding inherited choices. For more complex inheritance
775             # structures users should override contribute_to_class().
776             if 'get_%s_display' % self.name not in cls.__dict__:
777                 setattr(
778                     cls,
779                     'get_%s_display' % self.name,
780                     partialmethod(cls._get_FIELD_display, field=self),
781                 )
782 
783     def get_filter_kwargs_for_object(self, obj):
784         """
785         Return a dict that when passed as kwargs to self.model.filter(), would
786         yield all instances having the same value for this field as obj has.
787         """
788         return {self.name: getattr(obj, self.attname)}
789 
790     def get_attname(self):
791         return self.name
792 
793     def get_attname_column(self):
794         attname = self.get_attname()
795         column = self.db_column or attname
796         return attname, column
797 
798     def get_internal_type(self):
799         return self.__class__.__name__
800 
801     def pre_save(self, model_instance, add):
802         """Return field's value just before saving."""
803         return getattr(model_instance, self.attname)
804 
805     def get_prep_value(self, value):
806         """Perform preliminary non-db specific value checks and conversions."""
807         if isinstance(value, Promise):
808             value = value._proxy____cast()
809         return value
810 
811     def get_db_prep_value(self, value, connection, prepared=False):
812         """
813         Return field's value prepared for interacting with the database backend.
814 
815         Used by the default implementations of get_db_prep_save().
816         """
817         if not prepared:
818             value = self.get_prep_value(value)
819         return value
820 
821     def get_db_prep_save(self, value, connection):
822         """Return field's value prepared for saving into a database."""
823         return self.get_db_prep_value(value, connection=connection, prepared=False)
824 
825     def has_default(self):
826         """Return a boolean of whether this field has a default value."""
827         return self.default is not NOT_PROVIDED
828 
829     def get_default(self):
830         """Return the default value for this field."""
831         return self._get_default()
832 
833     @cached_property
834     def _get_default(self):
835         if self.has_default():
836             if callable(self.default):
837                 return self.default
838             return lambda: self.default
839 
840         if not self.empty_strings_allowed or self.null and not connection.features.interprets_empty_strings_as_nulls:
841             return return_None
842         return str  # return empty string
843 
844     def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH, limit_choices_to=None, ordering=()):
845         """
846         Return choices with a default blank choices included, for use
847         as <select> choices for this field.
848         """
849         if self.choices is not None:
850             choices = list(self.choices)
851             if include_blank:
852                 blank_defined = any(choice in ('', None) for choice, _ in self.flatchoices)
853                 if not blank_defined:
854                     choices = blank_choice + choices
855             return choices
856         rel_model = self.remote_field.model
857         limit_choices_to = limit_choices_to or self.get_limit_choices_to()
858         choice_func = operator.attrgetter(
859             self.remote_field.get_related_field().attname
860             if hasattr(self.remote_field, 'get_related_field')
861             else 'pk'
862         )
863         qs = rel_model._default_manager.complex_filter(limit_choices_to)
864         if ordering:
865             qs = qs.order_by(*ordering)
866         return (blank_choice if include_blank else []) + [
867             (choice_func(x), str(x)) for x in qs
868         ]
869 
870     def value_to_string(self, obj):
871         """
872         Return a string value of this field from the passed obj.
873         This is used by the serialization framework.
874         """
875         return str(self.value_from_object(obj))
876 
877     def _get_flatchoices(self):
878         """Flattened version of choices tuple."""
879         if self.choices is None:
880             return []
881         flat = []
882         for choice, value in self.choices:
883             if isinstance(value, (list, tuple)):
884                 flat.extend(value)
885             else:
886                 flat.append((choice, value))
887         return flat
888     flatchoices = property(_get_flatchoices)
889 
890     def save_form_data(self, instance, data):
891         setattr(instance, self.name, data)
892 
893     def formfield(self, form_class=None, choices_form_class=None, **kwargs):
894         """Return a django.forms.Field instance for this field."""
895         defaults = {
896             'required': not self.blank,
897             'label': capfirst(self.verbose_name),
898             'help_text': self.help_text,
899         }
900         if self.has_default():
901             if callable(self.default):
902                 defaults['initial'] = self.default
903                 defaults['show_hidden_initial'] = True
904             else:
905                 defaults['initial'] = self.get_default()
906         if self.choices is not None:
907             # Fields with choices get special treatment.
908             include_blank = (self.blank or
909                              not (self.has_default() or 'initial' in kwargs))
910             defaults['choices'] = self.get_choices(include_blank=include_blank)
911             defaults['coerce'] = self.to_python
912             if self.null:
913                 defaults['empty_value'] = None
914             if choices_form_class is not None:
915                 form_class = choices_form_class
916             else:
917                 form_class = forms.TypedChoiceField
918             # Many of the subclass-specific formfield arguments (min_value,
919             # max_value) don't apply for choice fields, so be sure to only pass
920             # the values that TypedChoiceField will understand.
921             for k in list(kwargs):
922                 if k not in ('coerce', 'empty_value', 'choices', 'required',
923                              'widget', 'label', 'initial', 'help_text',
924                              'error_messages', 'show_hidden_initial', 'disabled'):
925                     del kwargs[k]
926         defaults.update(kwargs)
927         if form_class is None:
928             form_class = forms.CharField
929         return form_class(**defaults)
930 
931     def value_from_object(self, obj):
932         """Return the value of this field in the given model instance."""
933         return getattr(obj, self.attname)
934 
935 
936 class BooleanField(Field):
937     empty_strings_allowed = False
938     default_error_messages = {
939         'invalid': _('“%(value)s” value must be either True or False.'),
940         'invalid_nullable': _('“%(value)s” value must be either True, False, or None.'),
941     }
942     description = _("Boolean (Either True or False)")
943 
944     def get_internal_type(self):
945         return "BooleanField"
946 
947     def to_python(self, value):
948         if self.null and value in self.empty_values:
949             return None
950         if value in (True, False):
951             # 1/0 are equal to True/False. bool() converts former to latter.
952             return bool(value)
953         if value in ('t', 'True', '1'):
954             return True
955         if value in ('f', 'False', '0'):
956             return False
957         raise exceptions.ValidationError(
958             self.error_messages['invalid_nullable' if self.null else 'invalid'],
959             code='invalid',
960             params={'value': value},
961         )
962 
963     def get_prep_value(self, value):
964         value = super().get_prep_value(value)
965         if value is None:
966             return None
967         return self.to_python(value)
968 
969     def formfield(self, **kwargs):
970         if self.choices is not None:
971             include_blank = not (self.has_default() or 'initial' in kwargs)
972             defaults = {'choices': self.get_choices(include_blank=include_blank)}
973         else:
974             form_class = forms.NullBooleanField if self.null else forms.BooleanField
975             # In HTML checkboxes, 'required' means "must be checked" which is
976             # different from the choices case ("must select some value").
977             # required=False allows unchecked checkboxes.
978             defaults = {'form_class': form_class, 'required': False}
979         return super().formfield(**{**defaults, **kwargs})
980 
981 
982 class CharField(Field):
983     description = _("String (up to %(max_length)s)")
984 
985     def __init__(self, *args, **kwargs):
986         super().__init__(*args, **kwargs)
987         self.validators.append(validators.MaxLengthValidator(self.max_length))
988 
989     def check(self, **kwargs):
990         return [
991             *super().check(**kwargs),
992             *self._check_max_length_attribute(**kwargs),
993         ]
994 
995     def _check_max_length_attribute(self, **kwargs):
996         if self.max_length is None:
997             return [
998                 checks.Error(
999                     "CharFields must define a 'max_length' attribute.",
1000                     obj=self,
1001                     id='fields.E120',
1002                 )
1003             ]
1004         elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or
1005                 self.max_length <= 0):
1006             return [
1007                 checks.Error(
1008                     "'max_length' must be a positive integer.",
1009                     obj=self,
1010                     id='fields.E121',
1011                 )
1012             ]
1013         else:
1014             return []
1015 
1016     def cast_db_type(self, connection):
1017         if self.max_length is None:
1018             return connection.ops.cast_char_field_without_max_length
1019         return super().cast_db_type(connection)
1020 
1021     def get_internal_type(self):
1022         return "CharField"
1023 
1024     def to_python(self, value):
1025         if isinstance(value, str) or value is None:
1026             return value
1027         return str(value)
1028 
1029     def get_prep_value(self, value):
1030         value = super().get_prep_value(value)
1031         return self.to_python(value)
1032 
1033     def formfield(self, **kwargs):
1034         # Passing max_length to forms.CharField means that the value's length
1035         # will be validated twice. This is considered acceptable since we want
1036         # the value in the form field (to pass into widget for example).
1037         defaults = {'max_length': self.max_length}
1038         # TODO: Handle multiple backends with different feature flags.
1039         if self.null and not connection.features.interprets_empty_strings_as_nulls:
1040             defaults['empty_value'] = None
1041         defaults.update(kwargs)
1042         return super().formfield(**defaults)
1043 
1044 
1045 class CommaSeparatedIntegerField(CharField):
1046     default_validators = [validators.validate_comma_separated_integer_list]
1047     description = _("Comma-separated integers")
1048     system_check_removed_details = {
1049         'msg': (
1050             'CommaSeparatedIntegerField is removed except for support in '
1051             'historical migrations.'
1052         ),
1053         'hint': (
1054             'Use CharField(validators=[validate_comma_separated_integer_list]) '
1055             'instead.'
1056         ),
1057         'id': 'fields.E901',
1058     }
1059 
1060 
1061 class DateTimeCheckMixin:
1062 
1063     def check(self, **kwargs):
1064         return [
1065             *super().check(**kwargs),
1066             *self._check_mutually_exclusive_options(),
1067             *self._check_fix_default_value(),
1068         ]
1069 
1070     def _check_mutually_exclusive_options(self):
1071         # auto_now, auto_now_add, and default are mutually exclusive
1072         # options. The use of more than one of these options together
1073         # will trigger an Error
1074         mutually_exclusive_options = [self.auto_now_add, self.auto_now, self.has_default()]
1075         enabled_options = [option not in (None, False) for option in mutually_exclusive_options].count(True)
1076         if enabled_options > 1:
1077             return [
1078                 checks.Error(
1079                     "The options auto_now, auto_now_add, and default "
1080                     "are mutually exclusive. Only one of these options "
1081                     "may be present.",
1082                     obj=self,
1083                     id='fields.E160',
1084                 )
1085             ]
1086         else:
1087             return []
1088 
1089     def _check_fix_default_value(self):
1090         return []
1091 
1092 
1093 class DateField(DateTimeCheckMixin, Field):
1094     empty_strings_allowed = False
1095     default_error_messages = {
1096         'invalid': _('“%(value)s” value has an invalid date format. It must be '
1097                      'in YYYY-MM-DD format.'),
1098         'invalid_date': _('“%(value)s” value has the correct format (YYYY-MM-DD) '
1099                           'but it is an invalid date.'),
1100     }
1101     description = _("Date (without time)")
1102 
1103     def __init__(self, verbose_name=None, name=None, auto_now=False,
1104                  auto_now_add=False, **kwargs):
1105         self.auto_now, self.auto_now_add = auto_now, auto_now_add
1106         if auto_now or auto_now_add:
1107             kwargs['editable'] = False
1108             kwargs['blank'] = True
1109         super().__init__(verbose_name, name, **kwargs)
1110 
1111     def _check_fix_default_value(self):
1112         """
1113         Warn that using an actual date or datetime value is probably wrong;
1114         it's only evaluated on server startup.
1115         """
1116         if not self.has_default():
1117             return []
1118 
1119         now = timezone.now()
1120         if not timezone.is_naive(now):
1121             now = timezone.make_naive(now, timezone.utc)
1122         value = self.default
1123         if isinstance(value, datetime.datetime):
1124             if not timezone.is_naive(value):
1125                 value = timezone.make_naive(value, timezone.utc)
1126             value = value.date()
1127         elif isinstance(value, datetime.date):
1128             # Nothing to do, as dates don't have tz information
1129             pass
1130         else:
1131             # No explicit date / datetime value -- no checks necessary
1132             return []
1133         offset = datetime.timedelta(days=1)
1134         lower = (now - offset).date()
1135         upper = (now + offset).date()
1136         if lower <= value <= upper:
1137             return [
1138                 checks.Warning(
1139                     'Fixed default value provided.',
1140                     hint='It seems you set a fixed date / time / datetime '
1141                          'value as default for this field. This may not be '
1142                          'what you want. If you want to have the current date '
1143                          'as default, use `django.utils.timezone.now`',
1144                     obj=self,
1145                     id='fields.W161',
1146                 )
1147             ]
1148 
1149         return []
1150 
1151     def deconstruct(self):
1152         name, path, args, kwargs = super().deconstruct()
1153         if self.auto_now:
1154             kwargs['auto_now'] = True
1155         if self.auto_now_add:
1156             kwargs['auto_now_add'] = True
1157         if self.auto_now or self.auto_now_add:
1158             del kwargs['editable']
1159             del kwargs['blank']
1160         return name, path, args, kwargs
1161 
1162     def get_internal_type(self):
1163         return "DateField"
1164 
1165     def to_python(self, value):
1166         if value is None:
1167             return value
1168         if isinstance(value, datetime.datetime):
1169             if settings.USE_TZ and timezone.is_aware(value):
1170                 # Convert aware datetimes to the default time zone
1171                 # before casting them to dates (#17742).
1172                 default_timezone = timezone.get_default_timezone()
1173                 value = timezone.make_naive(value, default_timezone)
1174             return value.date()
1175         if isinstance(value, datetime.date):
1176             return value
1177 
1178         try:
1179             parsed = parse_date(value)
1180             if parsed is not None:
1181                 return parsed
1182         except ValueError:
1183             raise exceptions.ValidationError(
1184                 self.error_messages['invalid_date'],
1185                 code='invalid_date',
1186                 params={'value': value},
1187             )
1188 
1189         raise exceptions.ValidationError(
1190             self.error_messages['invalid'],
1191             code='invalid',
1192             params={'value': value},
1193         )
1194 
1195     def pre_save(self, model_instance, add):
1196         if self.auto_now or (self.auto_now_add and add):
1197             value = datetime.date.today()
1198             setattr(model_instance, self.attname, value)
1199             return value
1200         else:
1201             return super().pre_save(model_instance, add)
1202 
1203     def contribute_to_class(self, cls, name, **kwargs):
1204         super().contribute_to_class(cls, name, **kwargs)
1205         if not self.null:
1206             setattr(
1207                 cls, 'get_next_by_%s' % self.name,
1208                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=True)
1209             )
1210             setattr(
1211                 cls, 'get_previous_by_%s' % self.name,
1212                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=False)
1213             )
1214 
1215     def get_prep_value(self, value):
1216         value = super().get_prep_value(value)
1217         return self.to_python(value)
1218 
1219     def get_db_prep_value(self, value, connection, prepared=False):
1220         # Casts dates into the format expected by the backend
1221         if not prepared:
1222             value = self.get_prep_value(value)
1223         return connection.ops.adapt_datefield_value(value)
1224 
1225     def value_to_string(self, obj):
1226         val = self.value_from_object(obj)
1227         return '' if val is None else val.isoformat()
1228 
1229     def formfield(self, **kwargs):
1230         return super().formfield(**{
1231             'form_class': forms.DateField,
1232             **kwargs,
1233         })
1234 
1235 
1236 class DateTimeField(DateField):
1237     empty_strings_allowed = False
1238     default_error_messages = {
1239         'invalid': _('“%(value)s” value has an invalid format. It must be in '
1240                      'YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format.'),
1241         'invalid_date': _("“%(value)s” value has the correct format "
1242                           "(YYYY-MM-DD) but it is an invalid date."),
1243         'invalid_datetime': _('“%(value)s” value has the correct format '
1244                               '(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) '
1245                               'but it is an invalid date/time.'),
1246     }
1247     description = _("Date (with time)")
1248 
1249     # __init__ is inherited from DateField
1250 
1251     def _check_fix_default_value(self):
1252         """
1253         Warn that using an actual date or datetime value is probably wrong;
1254         it's only evaluated on server startup.
1255         """
1256         if not self.has_default():
1257             return []
1258 
1259         now = timezone.now()
1260         if not timezone.is_naive(now):
1261             now = timezone.make_naive(now, timezone.utc)
1262         value = self.default
1263         if isinstance(value, datetime.datetime):
1264             second_offset = datetime.timedelta(seconds=10)
1265             lower = now - second_offset
1266             upper = now + second_offset
1267             if timezone.is_aware(value):
1268                 value = timezone.make_naive(value, timezone.utc)
1269         elif isinstance(value, datetime.date):
1270             second_offset = datetime.timedelta(seconds=10)
1271             lower = now - second_offset
1272             lower = datetime.datetime(lower.year, lower.month, lower.day)
1273             upper = now + second_offset
1274             upper = datetime.datetime(upper.year, upper.month, upper.day)
1275             value = datetime.datetime(value.year, value.month, value.day)
1276         else:
1277             # No explicit date / datetime value -- no checks necessary
1278             return []
1279         if lower <= value <= upper:
1280             return [
1281                 checks.Warning(
1282                     'Fixed default value provided.',
1283                     hint='It seems you set a fixed date / time / datetime '
1284                          'value as default for this field. This may not be '
1285                          'what you want. If you want to have the current date '
1286                          'as default, use `django.utils.timezone.now`',
1287                     obj=self,
1288                     id='fields.W161',
1289                 )
1290             ]
1291 
1292         return []
1293 
1294     def get_internal_type(self):
1295         return "DateTimeField"
1296 
1297     def to_python(self, value):
1298         if value is None:
1299             return value
1300         if isinstance(value, datetime.datetime):
1301             return value
1302         if isinstance(value, datetime.date):
1303             value = datetime.datetime(value.year, value.month, value.day)
1304             if settings.USE_TZ:
1305                 # For backwards compatibility, interpret naive datetimes in
1306                 # local time. This won't work during DST change, but we can't
1307                 # do much about it, so we let the exceptions percolate up the
1308                 # call stack.
1309                 warnings.warn("DateTimeField %s.%s received a naive datetime "
1310                               "(%s) while time zone support is active." %
1311                               (self.model.__name__, self.name, value),
1312                               RuntimeWarning)
1313                 default_timezone = timezone.get_default_timezone()
1314                 value = timezone.make_aware(value, default_timezone)
1315             return value
1316 
1317         try:
1318             parsed = parse_datetime(value)
1319             if parsed is not None:
1320                 return parsed
1321         except ValueError:
1322             raise exceptions.ValidationError(
1323                 self.error_messages['invalid_datetime'],
1324                 code='invalid_datetime',
1325                 params={'value': value},
1326             )
1327 
1328         try:
1329             parsed = parse_date(value)
1330             if parsed is not None:
1331                 return datetime.datetime(parsed.year, parsed.month, parsed.day)
1332         except ValueError:
1333             raise exceptions.ValidationError(
1334                 self.error_messages['invalid_date'],
1335                 code='invalid_date',
1336                 params={'value': value},
1337             )
1338 
1339         raise exceptions.ValidationError(
1340             self.error_messages['invalid'],
1341             code='invalid',
1342             params={'value': value},
1343         )
1344 
1345     def pre_save(self, model_instance, add):
1346         if self.auto_now or (self.auto_now_add and add):
1347             value = timezone.now()
1348             setattr(model_instance, self.attname, value)
1349             return value
1350         else:
1351             return super().pre_save(model_instance, add)
1352 
1353     # contribute_to_class is inherited from DateField, it registers
1354     # get_next_by_FOO and get_prev_by_FOO
1355 
1356     def get_prep_value(self, value):
1357         value = super().get_prep_value(value)
1358         value = self.to_python(value)
1359         if value is not None and settings.USE_TZ and timezone.is_naive(value):
1360             # For backwards compatibility, interpret naive datetimes in local
1361             # time. This won't work during DST change, but we can't do much
1362             # about it, so we let the exceptions percolate up the call stack.
1363             try:
1364                 name = '%s.%s' % (self.model.__name__, self.name)
1365             except AttributeError:
1366                 name = '(unbound)'
1367             warnings.warn("DateTimeField %s received a naive datetime (%s)"
1368                           " while time zone support is active." %
1369                           (name, value),
1370                           RuntimeWarning)
1371             default_timezone = timezone.get_default_timezone()
1372             value = timezone.make_aware(value, default_timezone)
1373         return value
1374 
1375     def get_db_prep_value(self, value, connection, prepared=False):
1376         # Casts datetimes into the format expected by the backend
1377         if not prepared:
1378             value = self.get_prep_value(value)
1379         return connection.ops.adapt_datetimefield_value(value)
1380 
1381     def value_to_string(self, obj):
1382         val = self.value_from_object(obj)
1383         return '' if val is None else val.isoformat()
1384 
1385     def formfield(self, **kwargs):
1386         return super().formfield(**{
1387             'form_class': forms.DateTimeField,
1388             **kwargs,
1389         })
1390 
1391 
1392 class DecimalField(Field):
1393     empty_strings_allowed = False
1394     default_error_messages = {
1395         'invalid': _('“%(value)s” value must be a decimal number.'),
1396     }
1397     description = _("Decimal number")
1398 
1399     def __init__(self, verbose_name=None, name=None, max_digits=None,
1400                  decimal_places=None, **kwargs):
1401         self.max_digits, self.decimal_places = max_digits, decimal_places
1402         super().__init__(verbose_name, name, **kwargs)
1403 
1404     def check(self, **kwargs):
1405         errors = super().check(**kwargs)
1406 
1407         digits_errors = [
1408             *self._check_decimal_places(),
1409             *self._check_max_digits(),
1410         ]
1411         if not digits_errors:
1412             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))
1413         else:
1414             errors.extend(digits_errors)
1415         return errors
1416 
1417     def _check_decimal_places(self):
1418         try:
1419             decimal_places = int(self.decimal_places)
1420             if decimal_places < 0:
1421                 raise ValueError()
1422         except TypeError:
1423             return [
1424                 checks.Error(
1425                     "DecimalFields must define a 'decimal_places' attribute.",
1426                     obj=self,
1427                     id='fields.E130',
1428                 )
1429             ]
1430         except ValueError:
1431             return [
1432                 checks.Error(
1433                     "'decimal_places' must be a non-negative integer.",
1434                     obj=self,
1435                     id='fields.E131',
1436                 )
1437             ]
1438         else:
1439             return []
1440 
1441     def _check_max_digits(self):
1442         try:
1443             max_digits = int(self.max_digits)
1444             if max_digits <= 0:
1445                 raise ValueError()
1446         except TypeError:
1447             return [
1448                 checks.Error(
1449                     "DecimalFields must define a 'max_digits' attribute.",
1450                     obj=self,
1451                     id='fields.E132',
1452                 )
1453             ]
1454         except ValueError:
1455             return [
1456                 checks.Error(
1457                     "'max_digits' must be a positive integer.",
1458                     obj=self,
1459                     id='fields.E133',
1460                 )
1461             ]
1462         else:
1463             return []
1464 
1465     def _check_decimal_places_and_max_digits(self, **kwargs):
1466         if int(self.decimal_places) > int(self.max_digits):
1467             return [
1468                 checks.Error(
1469                     "'max_digits' must be greater or equal to 'decimal_places'.",
1470                     obj=self,
1471                     id='fields.E134',
1472                 )
1473             ]
1474         return []
1475 
1476     @cached_property
1477     def validators(self):
1478         return super().validators + [
1479             validators.DecimalValidator(self.max_digits, self.decimal_places)
1480         ]
1481 
1482     @cached_property
1483     def context(self):
1484         return decimal.Context(prec=self.max_digits)
1485 
1486     def deconstruct(self):
1487         name, path, args, kwargs = super().deconstruct()
1488         if self.max_digits is not None:
1489             kwargs['max_digits'] = self.max_digits
1490         if self.decimal_places is not None:
1491             kwargs['decimal_places'] = self.decimal_places
1492         return name, path, args, kwargs
1493 
1494     def get_internal_type(self):
1495         return "DecimalField"
1496 
1497     def to_python(self, value):
1498         if value is None:
1499             return value
1500         if isinstance(value, float):
1501             return self.context.create_decimal_from_float(value)
1502         try:
1503             return decimal.Decimal(value)
1504         except (decimal.InvalidOperation, TypeError, ValueError):
1505             raise exceptions.ValidationError(
1506                 self.error_messages['invalid'],
1507                 code='invalid',
1508                 params={'value': value},
1509             )
1510 
1511     def get_db_prep_save(self, value, connection):
1512         return connection.ops.adapt_decimalfield_value(self.to_python(value), self.max_digits, self.decimal_places)
1513 
1514     def get_prep_value(self, value):
1515         value = super().get_prep_value(value)
1516         return self.to_python(value)
1517 
1518     def formfield(self, **kwargs):
1519         return super().formfield(**{
1520             'max_digits': self.max_digits,
1521             'decimal_places': self.decimal_places,
1522             'form_class': forms.DecimalField,
1523             **kwargs,
1524         })
1525 
1526 
1527 class DurationField(Field):
1528     """
1529     Store timedelta objects.
1530 
1531     Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint
1532     of microseconds on other databases.
1533     """
1534     empty_strings_allowed = False
1535     default_error_messages = {
1536         'invalid': _('“%(value)s” value has an invalid format. It must be in '
1537                      '[DD] [[HH:]MM:]ss[.uuuuuu] format.')
1538     }
1539     description = _("Duration")
1540 
1541     def get_internal_type(self):
1542         return "DurationField"
1543 
1544     def to_python(self, value):
1545         if value is None:
1546             return value
1547         if isinstance(value, datetime.timedelta):
1548             return value
1549         try:
1550             parsed = parse_duration(value)
1551         except ValueError:
1552             pass
1553         else:
1554             if parsed is not None:
1555                 return parsed
1556 
1557         raise exceptions.ValidationError(
1558             self.error_messages['invalid'],
1559             code='invalid',
1560             params={'value': value},
1561         )
1562 
1563     def get_db_prep_value(self, value, connection, prepared=False):
1564         if connection.features.has_native_duration_field:
1565             return value
1566         if value is None:
1567             return None
1568         return duration_microseconds(value)
1569 
1570     def get_db_converters(self, connection):
1571         converters = []
1572         if not connection.features.has_native_duration_field:
1573             converters.append(connection.ops.convert_durationfield_value)
1574         return converters + super().get_db_converters(connection)
1575 
1576     def value_to_string(self, obj):
1577         val = self.value_from_object(obj)
1578         return '' if val is None else duration_string(val)
1579 
1580     def formfield(self, **kwargs):
1581         return super().formfield(**{
1582             'form_class': forms.DurationField,
1583             **kwargs,
1584         })
1585 
1586 
1587 class EmailField(CharField):
1588     default_validators = [validators.validate_email]
1589     description = _("Email address")
1590 
1591     def __init__(self, *args, **kwargs):
1592         # max_length=254 to be compliant with RFCs 3696 and 5321
1593         kwargs.setdefault('max_length', 254)
1594         super().__init__(*args, **kwargs)
1595 
1596     def deconstruct(self):
1597         name, path, args, kwargs = super().deconstruct()
1598         # We do not exclude max_length if it matches default as we want to change
1599         # the default in future.
1600         return name, path, args, kwargs
1601 
1602     def formfield(self, **kwargs):
1603         # As with CharField, this will cause email validation to be performed
1604         # twice.
1605         return super().formfield(**{
1606             'form_class': forms.EmailField,
1607             **kwargs,
1608         })
1609 
1610 
1611 class FilePathField(Field):
1612     description = _("File path")
1613 
1614     def __init__(self, verbose_name=None, name=None, path='', match=None,
1615                  recursive=False, allow_files=True, allow_folders=False, **kwargs):
1616         self.path, self.match, self.recursive = path, match, recursive
1617         self.allow_files, self.allow_folders = allow_files, allow_folders
1618         kwargs.setdefault('max_length', 100)
1619         super().__init__(verbose_name, name, **kwargs)
1620 
1621     def check(self, **kwargs):
1622         return [
1623             *super().check(**kwargs),
1624             *self._check_allowing_files_or_folders(**kwargs),
1625         ]
1626 
1627     def _check_allowing_files_or_folders(self, **kwargs):
1628         if not self.allow_files and not self.allow_folders:
1629             return [
1630                 checks.Error(
1631                     "FilePathFields must have either 'allow_files' or 'allow_folders' set to True.",
1632                     obj=self,
1633                     id='fields.E140',
1634                 )
1635             ]
1636         return []
1637 
1638     def deconstruct(self):
1639         name, path, args, kwargs = super().deconstruct()
1640         if self.path != '':
1641             kwargs['path'] = self.path
1642         if self.match is not None:
1643             kwargs['match'] = self.match
1644         if self.recursive is not False:
1645             kwargs['recursive'] = self.recursive
1646         if self.allow_files is not True:
1647             kwargs['allow_files'] = self.allow_files
1648         if self.allow_folders is not False:
1649             kwargs['allow_folders'] = self.allow_folders
1650         if kwargs.get("max_length") == 100:
1651             del kwargs["max_length"]
1652         return name, path, args, kwargs
1653 
1654     def get_prep_value(self, value):
1655         value = super().get_prep_value(value)
1656         if value is None:
1657             return None
1658         return str(value)
1659 
1660     def formfield(self, **kwargs):
1661         return super().formfield(**{
1662             'path': self.path() if callable(self.path) else self.path,
1663             'match': self.match,
1664             'recursive': self.recursive,
1665             'form_class': forms.FilePathField,
1666             'allow_files': self.allow_files,
1667             'allow_folders': self.allow_folders,
1668             **kwargs,
1669         })
1670 
1671     def get_internal_type(self):
1672         return "FilePathField"
1673 
1674 
1675 class FloatField(Field):
1676     empty_strings_allowed = False
1677     default_error_messages = {
1678         'invalid': _('“%(value)s” value must be a float.'),
1679     }
1680     description = _("Floating point number")
1681 
1682     def get_prep_value(self, value):
1683         value = super().get_prep_value(value)
1684         if value is None:
1685             return None
1686         try:
1687             return float(value)
1688         except (TypeError, ValueError) as e:
1689             raise e.__class__(
1690                 "Field '%s' expected a number but got %r." % (self.name, value),
1691             ) from e
1692 
1693     def get_internal_type(self):
1694         return "FloatField"
1695 
1696     def to_python(self, value):
1697         if value is None:
1698             return value
1699         try:
1700             return float(value)
1701         except (TypeError, ValueError):
1702             raise exceptions.ValidationError(
1703                 self.error_messages['invalid'],
1704                 code='invalid',
1705                 params={'value': value},
1706             )
1707 
1708     def formfield(self, **kwargs):
1709         return super().formfield(**{
1710             'form_class': forms.FloatField,
1711             **kwargs,
1712         })
1713 
1714 
1715 class IntegerField(Field):
1716     empty_strings_allowed = False
1717     default_error_messages = {
1718         'invalid': _('“%(value)s” value must be an integer.'),
1719     }
1720     description = _("Integer")
1721 
1722     def check(self, **kwargs):
1723         return [
1724             *super().check(**kwargs),
1725             *self._check_max_length_warning(),
1726         ]
1727 
1728     def _check_max_length_warning(self):
1729         if self.max_length is not None:
1730             return [
1731                 checks.Warning(
1732                     "'max_length' is ignored when used with %s." % self.__class__.__name__,
1733                     hint="Remove 'max_length' from field",
1734                     obj=self,
1735                     id='fields.W122',
1736                 )
1737             ]
1738         return []
1739 
1740     @cached_property
1741     def validators(self):
1742         # These validators can't be added at field initialization time since
1743         # they're based on values retrieved from `connection`.
1744         validators_ = super().validators
1745         internal_type = self.get_internal_type()
1746         min_value, max_value = connection.ops.integer_field_range(internal_type)
1747         if min_value is not None and not any(
1748             (
1749                 isinstance(validator, validators.MinValueValidator) and (
1750                     validator.limit_value()
1751                     if callable(validator.limit_value)
1752                     else validator.limit_value
1753                 ) >= min_value
1754             ) for validator in validators_
1755         ):
1756             validators_.append(validators.MinValueValidator(min_value))
1757         if max_value is not None and not any(
1758             (
1759                 isinstance(validator, validators.MaxValueValidator) and (
1760                     validator.limit_value()
1761                     if callable(validator.limit_value)
1762                     else validator.limit_value
1763                 ) <= max_value
1764             ) for validator in validators_
1765         ):
1766             validators_.append(validators.MaxValueValidator(max_value))
1767         return validators_
1768 
1769     def get_prep_value(self, value):
1770         value = super().get_prep_value(value)
1771         if value is None:
1772             return None
1773         try:
1774             return int(value)
1775         except (TypeError, ValueError) as e:
1776             raise e.__class__(
1777                 "Field '%s' expected a number but got %r." % (self.name, value),
1778             ) from e
1779 
1780     def get_internal_type(self):
1781         return "IntegerField"
1782 
1783     def to_python(self, value):
1784         if value is None:
1785             return value
1786         try:
1787             return int(value)
1788         except (TypeError, ValueError):
1789             raise exceptions.ValidationError(
1790                 self.error_messages['invalid'],
1791                 code='invalid',
1792                 params={'value': value},
1793             )
1794 
1795     def formfield(self, **kwargs):
1796         return super().formfield(**{
1797             'form_class': forms.IntegerField,
1798             **kwargs,
1799         })
1800 
1801 
1802 class BigIntegerField(IntegerField):
1803     description = _("Big (8 byte) integer")
1804     MAX_BIGINT = 9223372036854775807
1805 
1806     def get_internal_type(self):
1807         return "BigIntegerField"
1808 
1809     def formfield(self, **kwargs):
1810         return super().formfield(**{
1811             'min_value': -BigIntegerField.MAX_BIGINT - 1,
1812             'max_value': BigIntegerField.MAX_BIGINT,
1813             **kwargs,
1814         })
1815 
1816 
1817 class IPAddressField(Field):
1818     empty_strings_allowed = False
1819     description = _("IPv4 address")
1820     system_check_removed_details = {
1821         'msg': (
1822             'IPAddressField has been removed except for support in '
1823             'historical migrations.'
1824         ),
1825         'hint': 'Use GenericIPAddressField instead.',
1826         'id': 'fields.E900',
1827     }
1828 
1829     def __init__(self, *args, **kwargs):
1830         kwargs['max_length'] = 15
1831         super().__init__(*args, **kwargs)
1832 
1833     def deconstruct(self):
1834         name, path, args, kwargs = super().deconstruct()
1835         del kwargs['max_length']
1836         return name, path, args, kwargs
1837 
1838     def get_prep_value(self, value):
1839         value = super().get_prep_value(value)
1840         if value is None:
1841             return None
1842         return str(value)
1843 
1844     def get_internal_type(self):
1845         return "IPAddressField"
1846 
1847 
1848 class GenericIPAddressField(Field):
1849     empty_strings_allowed = False
1850     description = _("IP address")
1851     default_error_messages = {}
1852 
1853     def __init__(self, verbose_name=None, name=None, protocol='both',
1854                  unpack_ipv4=False, *args, **kwargs):
1855         self.unpack_ipv4 = unpack_ipv4
1856         self.protocol = protocol
1857         self.default_validators, invalid_error_message = \
1858             validators.ip_address_validators(protocol, unpack_ipv4)
1859         self.default_error_messages['invalid'] = invalid_error_message
1860         kwargs['max_length'] = 39
1861         super().__init__(verbose_name, name, *args, **kwargs)
1862 
1863     def check(self, **kwargs):
1864         return [
1865             *super().check(**kwargs),
1866             *self._check_blank_and_null_values(**kwargs),
1867         ]
1868 
1869     def _check_blank_and_null_values(self, **kwargs):
1870         if not getattr(self, 'null', False) and getattr(self, 'blank', False):
1871             return [
1872                 checks.Error(
1873                     'GenericIPAddressFields cannot have blank=True if null=False, '
1874                     'as blank values are stored as nulls.',
1875                     obj=self,
1876                     id='fields.E150',
1877                 )
1878             ]
1879         return []
1880 
1881     def deconstruct(self):
1882         name, path, args, kwargs = super().deconstruct()
1883         if self.unpack_ipv4 is not False:
1884             kwargs['unpack_ipv4'] = self.unpack_ipv4
1885         if self.protocol != "both":
1886             kwargs['protocol'] = self.protocol
1887         if kwargs.get("max_length") == 39:
1888             del kwargs['max_length']
1889         return name, path, args, kwargs
1890 
1891     def get_internal_type(self):
1892         return "GenericIPAddressField"
1893 
1894     def to_python(self, value):
1895         if value is None:
1896             return None
1897         if not isinstance(value, str):
1898             value = str(value)
1899         value = value.strip()
1900         if ':' in value:
1901             return clean_ipv6_address(value, self.unpack_ipv4, self.error_messages['invalid'])
1902         return value
1903 
1904     def get_db_prep_value(self, value, connection, prepared=False):
1905         if not prepared:
1906             value = self.get_prep_value(value)
1907         return connection.ops.adapt_ipaddressfield_value(value)
1908 
1909     def get_prep_value(self, value):
1910         value = super().get_prep_value(value)
1911         if value is None:
1912             return None
1913         if value and ':' in value:
1914             try:
1915                 return clean_ipv6_address(value, self.unpack_ipv4)
1916             except exceptions.ValidationError:
1917                 pass
1918         return str(value)
1919 
1920     def formfield(self, **kwargs):
1921         return super().formfield(**{
1922             'protocol': self.protocol,
1923             'form_class': forms.GenericIPAddressField,
1924             **kwargs,
1925         })
1926 
1927 
1928 class NullBooleanField(BooleanField):
1929     default_error_messages = {
1930         'invalid': _('“%(value)s” value must be either None, True or False.'),
1931         'invalid_nullable': _('“%(value)s” value must be either None, True or False.'),
1932     }
1933     description = _("Boolean (Either True, False or None)")
1934     system_check_deprecated_details = {
1935         'msg': (
1936             'NullBooleanField is deprecated. Support for it (except in '
1937             'historical migrations) will be removed in Django 4.0.'
1938         ),
1939         'hint': 'Use BooleanField(null=True) instead.',
1940         'id': 'fields.W903',
1941     }
1942 
1943     def __init__(self, *args, **kwargs):
1944         kwargs['null'] = True
1945         kwargs['blank'] = True
1946         super().__init__(*args, **kwargs)
1947 
1948     def deconstruct(self):
1949         name, path, args, kwargs = super().deconstruct()
1950         del kwargs['null']
1951         del kwargs['blank']
1952         return name, path, args, kwargs
1953 
1954     def get_internal_type(self):
1955         return "NullBooleanField"
1956 
1957 
1958 class PositiveIntegerRelDbTypeMixin:
1959 
1960     def rel_db_type(self, connection):
1961         """
1962         Return the data type that a related field pointing to this field should
1963         use. In most cases, a foreign key pointing to a positive integer
1964         primary key will have an integer column data type but some databases
1965         (e.g. MySQL) have an unsigned integer type. In that case
1966         (related_fields_match_type=True), the primary key should return its
1967         db_type.
1968         """
1969         if connection.features.related_fields_match_type:
1970             return self.db_type(connection)
1971         else:
1972             return IntegerField().db_type(connection=connection)
1973 
1974 
1975 class PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
1976     description = _('Positive big integer')
1977 
1978     def get_internal_type(self):
1979         return 'PositiveBigIntegerField'
1980 
1981     def formfield(self, **kwargs):
1982         return super().formfield(**{
1983             'min_value': 0,
1984             **kwargs,
1985         })
1986 
1987 
1988 class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
1989     description = _("Positive integer")
1990 
1991     def get_internal_type(self):
1992         return "PositiveIntegerField"
1993 
1994     def formfield(self, **kwargs):
1995         return super().formfield(**{
1996             'min_value': 0,
1997             **kwargs,
1998         })
1999 
2000 
2001 class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):
2002     description = _("Positive small integer")
2003 
2004     def get_internal_type(self):
2005         return "PositiveSmallIntegerField"
2006 
2007     def formfield(self, **kwargs):
2008         return super().formfield(**{
2009             'min_value': 0,
2010             **kwargs,
2011         })
2012 
2013 
2014 class SlugField(CharField):
2015     default_validators = [validators.validate_slug]
2016     description = _("Slug (up to %(max_length)s)")
2017 
2018     def __init__(self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs):
2019         self.allow_unicode = allow_unicode
2020         if self.allow_unicode:
2021             self.default_validators = [validators.validate_unicode_slug]
2022         super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)
2023 
2024     def deconstruct(self):
2025         name, path, args, kwargs = super().deconstruct()
2026         if kwargs.get("max_length") == 50:
2027             del kwargs['max_length']
2028         if self.db_index is False:
2029             kwargs['db_index'] = False
2030         else:
2031             del kwargs['db_index']
2032         if self.allow_unicode is not False:
2033             kwargs['allow_unicode'] = self.allow_unicode
2034         return name, path, args, kwargs
2035 
2036     def get_internal_type(self):
2037         return "SlugField"
2038 
2039     def formfield(self, **kwargs):
2040         return super().formfield(**{
2041             'form_class': forms.SlugField,
2042             'allow_unicode': self.allow_unicode,
2043             **kwargs,
2044         })
2045 
2046 
2047 class SmallIntegerField(IntegerField):
2048     description = _("Small integer")
2049 
2050     def get_internal_type(self):
2051         return "SmallIntegerField"
2052 
2053 
2054 class TextField(Field):
2055     description = _("Text")
2056 
2057     def get_internal_type(self):
2058         return "TextField"
2059 
2060     def to_python(self, value):
2061         if isinstance(value, str) or value is None:
2062             return value
2063         return str(value)
2064 
2065     def get_prep_value(self, value):
2066         value = super().get_prep_value(value)
2067         return self.to_python(value)
2068 
2069     def formfield(self, **kwargs):
2070         # Passing max_length to forms.CharField means that the value's length
2071         # will be validated twice. This is considered acceptable since we want
2072         # the value in the form field (to pass into widget for example).
2073         return super().formfield(**{
2074             'max_length': self.max_length,
2075             **({} if self.choices is not None else {'widget': forms.Textarea}),
2076             **kwargs,
2077         })
2078 
2079 
2080 class TimeField(DateTimeCheckMixin, Field):
2081     empty_strings_allowed = False
2082     default_error_messages = {
2083         'invalid': _('“%(value)s” value has an invalid format. It must be in '
2084                      'HH:MM[:ss[.uuuuuu]] format.'),
2085         'invalid_time': _('“%(value)s” value has the correct format '
2086                           '(HH:MM[:ss[.uuuuuu]]) but it is an invalid time.'),
2087     }
2088     description = _("Time")
2089 
2090     def __init__(self, verbose_name=None, name=None, auto_now=False,
2091                  auto_now_add=False, **kwargs):
2092         self.auto_now, self.auto_now_add = auto_now, auto_now_add
2093         if auto_now or auto_now_add:
2094             kwargs['editable'] = False
2095             kwargs['blank'] = True
2096         super().__init__(verbose_name, name, **kwargs)
2097 
2098     def _check_fix_default_value(self):
2099         """
2100         Warn that using an actual date or datetime value is probably wrong;
2101         it's only evaluated on server startup.
2102         """
2103         if not self.has_default():
2104             return []
2105 
2106         now = timezone.now()
2107         if not timezone.is_naive(now):
2108             now = timezone.make_naive(now, timezone.utc)
2109         value = self.default
2110         if isinstance(value, datetime.datetime):
2111             second_offset = datetime.timedelta(seconds=10)
2112             lower = now - second_offset
2113             upper = now + second_offset
2114             if timezone.is_aware(value):
2115                 value = timezone.make_naive(value, timezone.utc)
2116         elif isinstance(value, datetime.time):
2117             second_offset = datetime.timedelta(seconds=10)
2118             lower = now - second_offset
2119             upper = now + second_offset
2120             value = datetime.datetime.combine(now.date(), value)
2121             if timezone.is_aware(value):
2122                 value = timezone.make_naive(value, timezone.utc).time()
2123         else:
2124             # No explicit time / datetime value -- no checks necessary
2125             return []
2126         if lower <= value <= upper:
2127             return [
2128                 checks.Warning(
2129                     'Fixed default value provided.',
2130                     hint='It seems you set a fixed date / time / datetime '
2131                          'value as default for this field. This may not be '
2132                          'what you want. If you want to have the current date '
2133                          'as default, use `django.utils.timezone.now`',
2134                     obj=self,
2135                     id='fields.W161',
2136                 )
2137             ]
2138 
2139         return []
2140 
2141     def deconstruct(self):
2142         name, path, args, kwargs = super().deconstruct()
2143         if self.auto_now is not False:
2144             kwargs["auto_now"] = self.auto_now
2145         if self.auto_now_add is not False:
2146             kwargs["auto_now_add"] = self.auto_now_add
2147         if self.auto_now or self.auto_now_add:
2148             del kwargs['blank']
2149             del kwargs['editable']
2150         return name, path, args, kwargs
2151 
2152     def get_internal_type(self):
2153         return "TimeField"
2154 
2155     def to_python(self, value):
2156         if value is None:
2157             return None
2158         if isinstance(value, datetime.time):
2159             return value
2160         if isinstance(value, datetime.datetime):
2161             # Not usually a good idea to pass in a datetime here (it loses
2162             # information), but this can be a side-effect of interacting with a
2163             # database backend (e.g. Oracle), so we'll be accommodating.
2164             return value.time()
2165 
2166         try:
2167             parsed = parse_time(value)
2168             if parsed is not None:
2169                 return parsed
2170         except ValueError:
2171             raise exceptions.ValidationError(
2172                 self.error_messages['invalid_time'],
2173                 code='invalid_time',
2174                 params={'value': value},
2175             )
2176 
2177         raise exceptions.ValidationError(
2178             self.error_messages['invalid'],
2179             code='invalid',
2180             params={'value': value},
2181         )
2182 
2183     def pre_save(self, model_instance, add):
2184         if self.auto_now or (self.auto_now_add and add):
2185             value = datetime.datetime.now().time()
2186             setattr(model_instance, self.attname, value)
2187             return value
2188         else:
2189             return super().pre_save(model_instance, add)
2190 
2191     def get_prep_value(self, value):
2192         value = super().get_prep_value(value)
2193         return self.to_python(value)
2194 
2195     def get_db_prep_value(self, value, connection, prepared=False):
2196         # Casts times into the format expected by the backend
2197         if not prepared:
2198             value = self.get_prep_value(value)
2199         return connection.ops.adapt_timefield_value(value)
2200 
2201     def value_to_string(self, obj):
2202         val = self.value_from_object(obj)
2203         return '' if val is None else val.isoformat()
2204 
2205     def formfield(self, **kwargs):
2206         return super().formfield(**{
2207             'form_class': forms.TimeField,
2208             **kwargs,
2209         })
2210 
2211 
2212 class URLField(CharField):
2213     default_validators = [validators.URLValidator()]
2214     description = _("URL")
2215 
2216     def __init__(self, verbose_name=None, name=None, **kwargs):
2217         kwargs.setdefault('max_length', 200)
2218         super().__init__(verbose_name, name, **kwargs)
2219 
2220     def deconstruct(self):
2221         name, path, args, kwargs = super().deconstruct()
2222         if kwargs.get("max_length") == 200:
2223             del kwargs['max_length']
2224         return name, path, args, kwargs
2225 
2226     def formfield(self, **kwargs):
2227         # As with CharField, this will cause URL validation to be performed
2228         # twice.
2229         return super().formfield(**{
2230             'form_class': forms.URLField,
2231             **kwargs,
2232         })
2233 
2234 
2235 class BinaryField(Field):
2236     description = _("Raw binary data")
2237     empty_values = [None, b'']
2238 
2239     def __init__(self, *args, **kwargs):
2240         kwargs.setdefault('editable', False)
2241         super().__init__(*args, **kwargs)
2242         if self.max_length is not None:
2243             self.validators.append(validators.MaxLengthValidator(self.max_length))
2244 
2245     def check(self, **kwargs):
2246         return [*super().check(**kwargs), *self._check_str_default_value()]
2247 
2248     def _check_str_default_value(self):
2249         if self.has_default() and isinstance(self.default, str):
2250             return [
2251                 checks.Error(
2252                     "BinaryField's default cannot be a string. Use bytes "
2253                     "content instead.",
2254                     obj=self,
2255                     id='fields.E170',
2256                 )
2257             ]
2258         return []
2259 
2260     def deconstruct(self):
2261         name, path, args, kwargs = super().deconstruct()
2262         if self.editable:
2263             kwargs['editable'] = True
2264         else:
2265             del kwargs['editable']
2266         return name, path, args, kwargs
2267 
2268     def get_internal_type(self):
2269         return "BinaryField"
2270 
2271     def get_placeholder(self, value, compiler, connection):
2272         return connection.ops.binary_placeholder_sql(value)
2273 
2274     def get_default(self):
2275         if self.has_default() and not callable(self.default):
2276             return self.default
2277         default = super().get_default()
2278         if default == '':
2279             return b''
2280         return default
2281 
2282     def get_db_prep_value(self, value, connection, prepared=False):
2283         value = super().get_db_prep_value(value, connection, prepared)
2284         if value is not None:
2285             return connection.Database.Binary(value)
2286         return value
2287 
2288     def value_to_string(self, obj):
2289         """Binary data is serialized as base64"""
2290         return b64encode(self.value_from_object(obj)).decode('ascii')
2291 
2292     def to_python(self, value):
2293         # If it's a string, it should be base64-encoded data
2294         if isinstance(value, str):
2295             return memoryview(b64decode(value.encode('ascii')))
2296         return value
2297 
2298 
2299 class UUIDField(Field):
2300     default_error_messages = {
2301         'invalid': _('“%(value)s” is not a valid UUID.'),
2302     }
2303     description = _('Universally unique identifier')
2304     empty_strings_allowed = False
2305 
2306     def __init__(self, verbose_name=None, **kwargs):
2307         kwargs['max_length'] = 32
2308         super().__init__(verbose_name, **kwargs)
2309 
2310     def deconstruct(self):
2311         name, path, args, kwargs = super().deconstruct()
2312         del kwargs['max_length']
2313         return name, path, args, kwargs
2314 
2315     def get_internal_type(self):
2316         return "UUIDField"
2317 
2318     def get_prep_value(self, value):
2319         value = super().get_prep_value(value)
2320         return self.to_python(value)
2321 
2322     def get_db_prep_value(self, value, connection, prepared=False):
2323         if value is None:
2324             return None
2325         if not isinstance(value, uuid.UUID):
2326             value = self.to_python(value)
2327 
2328         if connection.features.has_native_uuid_field:
2329             return value
2330         return value.hex
2331 
2332     def to_python(self, value):
2333         if value is not None and not isinstance(value, uuid.UUID):
2334             input_form = 'int' if isinstance(value, int) else 'hex'
2335             try:
2336                 return uuid.UUID(**{input_form: value})
2337             except (AttributeError, ValueError):
2338                 raise exceptions.ValidationError(
2339                     self.error_messages['invalid'],
2340                     code='invalid',
2341                     params={'value': value},
2342                 )
2343         return value
2344 
2345     def formfield(self, **kwargs):
2346         return super().formfield(**{
2347             'form_class': forms.UUIDField,
2348             **kwargs,
2349         })
2350 
2351 
2352 class AutoFieldMixin:
2353     db_returning = True
2354 
2355     def __init__(self, *args, **kwargs):
2356         kwargs['blank'] = True
2357         super().__init__(*args, **kwargs)
2358 
2359     def check(self, **kwargs):
2360         return [
2361             *super().check(**kwargs),
2362             *self._check_primary_key(),
2363         ]
2364 
2365     def _check_primary_key(self):
2366         if not self.primary_key:
2367             return [
2368                 checks.Error(
2369                     'AutoFields must set primary_key=True.',
2370                     obj=self,
2371                     id='fields.E100',
2372                 ),
2373             ]
2374         else:
2375             return []
2376 
2377     def deconstruct(self):
2378         name, path, args, kwargs = super().deconstruct()
2379         del kwargs['blank']
2380         kwargs['primary_key'] = True
2381         return name, path, args, kwargs
2382 
2383     def validate(self, value, model_instance):
2384         pass
2385 
2386     def get_db_prep_value(self, value, connection, prepared=False):
2387         if not prepared:
2388             value = self.get_prep_value(value)
2389             value = connection.ops.validate_autopk_value(value)
2390         return value
2391 
2392     def contribute_to_class(self, cls, name, **kwargs):
2393         assert not cls._meta.auto_field, (
2394             "Model %s can't have more than one auto-generated field."
2395             % cls._meta.label
2396         )
2397         super().contribute_to_class(cls, name, **kwargs)
2398         cls._meta.auto_field = self
2399 
2400     def formfield(self, **kwargs):
2401         return None
2402 
2403 
2404 class AutoFieldMeta(type):
2405     """
2406     Metaclass to maintain backward inheritance compatibility for AutoField.
2407 
2408     It is intended that AutoFieldMixin become public API when it is possible to
2409     create a non-integer automatically-generated field using column defaults
2410     stored in the database.
2411 
2412     In many areas Django also relies on using isinstance() to check for an
2413     automatically-generated field as a subclass of AutoField. A new flag needs
2414     to be implemented on Field to be used instead.
2415 
2416     When these issues have been addressed, this metaclass could be used to
2417     deprecate inheritance from AutoField and use of isinstance() with AutoField
2418     for detecting automatically-generated fields.
2419     """
2420 
2421     @property
2422     def _subclasses(self):
2423         return (BigAutoField, SmallAutoField)
2424 
2425     def __instancecheck__(self, instance):
2426         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)
2427 
2428     def __subclasscheck__(self, subclass):
2429         return subclass in self._subclasses or super().__subclasscheck__(subclass)
2430 
2431 
2432 class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):
2433 
2434     def get_internal_type(self):
2435         return 'AutoField'
2436 
2437     def rel_db_type(self, connection):
2438         return IntegerField().db_type(connection=connection)
2439 
2440 
2441 class BigAutoField(AutoFieldMixin, BigIntegerField):
2442 
2443     def get_internal_type(self):
2444         return 'BigAutoField'
2445 
2446     def rel_db_type(self, connection):
2447         return BigIntegerField().db_type(connection=connection)
2448 
2449 
2450 class SmallAutoField(AutoFieldMixin, SmallIntegerField):
2451 
2452     def get_internal_type(self):
2453         return 'SmallAutoField'
2454 
2455     def rel_db_type(self, connection):
2456         return SmallIntegerField().db_type(connection=connection)

</code><intended_behavior>For every validator attached to model fields, ensure that when raising ValidationError, the value being validated is passed along. This requires modifications to both direct raises of ValidationError within methods and possibly updates to how validators are called, ensuring they have the necessary context to include the value in the error.</intended_behavior>]
2025-10-18 11:56:09.582 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 11:56:09.582 | INFO     | Search-only: skipping patch selection
2025-10-18 11:56:09.739 | INFO     | Task django__django-13212 completed successfully.
2025-10-18 11:56:09.740 | INFO     | No patch generated. You can try running ACR again.
