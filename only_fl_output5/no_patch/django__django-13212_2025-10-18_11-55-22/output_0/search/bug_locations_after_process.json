[
    {
        "rel_file_path": "django/core/exceptions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/exceptions.py",
        "start": 101,
        "end": 142,
        "class_name": "ValidationError",
        "method_name": "__init__",
        "code": "101     def __init__(self, message, code=None, params=None):\n102         \"\"\"\n103         The `message` argument can be a single error, a list of errors, or a\n104         dictionary that maps field names to lists of errors. What we define as\n105         an \"error\" can be either a simple string or an instance of\n106         ValidationError with its message attribute set, and what we define as\n107         list or dictionary can be an actual `list` or `dict` or an instance\n108         of ValidationError with its `error_list` or `error_dict` attribute set.\n109         \"\"\"\n110         super().__init__(message, code, params)\n111 \n112         if isinstance(message, ValidationError):\n113             if hasattr(message, 'error_dict'):\n114                 message = message.error_dict\n115             elif not hasattr(message, 'message'):\n116                 message = message.error_list\n117             else:\n118                 message, code, params = message.message, message.code, message.params\n119 \n120         if isinstance(message, dict):\n121             self.error_dict = {}\n122             for field, messages in message.items():\n123                 if not isinstance(messages, ValidationError):\n124                     messages = ValidationError(messages)\n125                 self.error_dict[field] = messages.error_list\n126 \n127         elif isinstance(message, list):\n128             self.error_list = []\n129             for message in message:\n130                 # Normalize plain strings to instances of ValidationError.\n131                 if not isinstance(message, ValidationError):\n132                     message = ValidationError(message)\n133                 if hasattr(message, 'error_dict'):\n134                     self.error_list.extend(sum(message.error_dict.values(), []))\n135                 else:\n136                     self.error_list.extend(message.error_list)\n137 \n138         else:\n139             self.message = message\n140             self.code = code\n141             self.params = params\n142             self.error_list = [self]\n",
        "intended_behavior": "Enhance the __init__ method of ValidationError to accept an optional provided_value argument. This value should be stored as an instance attribute and utilized in the error message composition if present. This enables error messages to dynamically include the validated value, helping create more context-aware error messages."
    },
    {
        "rel_file_path": "django/core/exceptions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/exceptions.py",
        "start": 99,
        "end": 183,
        "class_name": "ValidationError",
        "method_name": null,
        "code": "99 class ValidationError(Exception):\n100     \"\"\"An error while validating data.\"\"\"\n101     def __init__(self, message, code=None, params=None):\n102         \"\"\"\n103         The `message` argument can be a single error, a list of errors, or a\n104         dictionary that maps field names to lists of errors. What we define as\n105         an \"error\" can be either a simple string or an instance of\n106         ValidationError with its message attribute set, and what we define as\n107         list or dictionary can be an actual `list` or `dict` or an instance\n108         of ValidationError with its `error_list` or `error_dict` attribute set.\n109         \"\"\"\n110         super().__init__(message, code, params)\n111 \n112         if isinstance(message, ValidationError):\n113             if hasattr(message, 'error_dict'):\n114                 message = message.error_dict\n115             elif not hasattr(message, 'message'):\n116                 message = message.error_list\n117             else:\n118                 message, code, params = message.message, message.code, message.params\n119 \n120         if isinstance(message, dict):\n121             self.error_dict = {}\n122             for field, messages in message.items():\n123                 if not isinstance(messages, ValidationError):\n124                     messages = ValidationError(messages)\n125                 self.error_dict[field] = messages.error_list\n126 \n127         elif isinstance(message, list):\n128             self.error_list = []\n129             for message in message:\n130                 # Normalize plain strings to instances of ValidationError.\n131                 if not isinstance(message, ValidationError):\n132                     message = ValidationError(message)\n133                 if hasattr(message, 'error_dict'):\n134                     self.error_list.extend(sum(message.error_dict.values(), []))\n135                 else:\n136                     self.error_list.extend(message.error_list)\n137 \n138         else:\n139             self.message = message\n140             self.code = code\n141             self.params = params\n142             self.error_list = [self]\n143 \n144     @property\n145     def message_dict(self):\n146         # Trigger an AttributeError if this ValidationError\n147         # doesn't have an error_dict.\n148         getattr(self, 'error_dict')\n149 \n150         return dict(self)\n151 \n152     @property\n153     def messages(self):\n154         if hasattr(self, 'error_dict'):\n155             return sum(dict(self).values(), [])\n156         return list(self)\n157 \n158     def update_error_dict(self, error_dict):\n159         if hasattr(self, 'error_dict'):\n160             for field, error_list in self.error_dict.items():\n161                 error_dict.setdefault(field, []).extend(error_list)\n162         else:\n163             error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)\n164         return error_dict\n165 \n166     def __iter__(self):\n167         if hasattr(self, 'error_dict'):\n168             for field, errors in self.error_dict.items():\n169                 yield field, list(ValidationError(errors))\n170         else:\n171             for error in self.error_list:\n172                 message = error.message\n173                 if error.params:\n174                     message %= error.params\n175                 yield str(message)\n176 \n177     def __str__(self):\n178         if hasattr(self, 'error_dict'):\n179             return repr(dict(self))\n180         return repr(list(self))\n181 \n182     def __repr__(self):\n183         return 'ValidationError(%s)' % self\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/validators.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/validators.py",
        "start": 1,
        "end": 560,
        "class_name": null,
        "method_name": null,
        "code": "1 import ipaddress\n2 import re\n3 import warnings\n4 from pathlib import Path\n5 from urllib.parse import urlsplit, urlunsplit\n6 \n7 from django.core.exceptions import ValidationError\n8 from django.utils.deconstruct import deconstructible\n9 from django.utils.deprecation import RemovedInDjango41Warning\n10 from django.utils.encoding import punycode\n11 from django.utils.ipv6 import is_valid_ipv6_address\n12 from django.utils.regex_helper import _lazy_re_compile\n13 from django.utils.translation import gettext_lazy as _, ngettext_lazy\n14 \n15 # These values, if given to validate(), will trigger the self.required check.\n16 EMPTY_VALUES = (None, '', [], (), {})\n17 \n18 \n19 @deconstructible\n20 class RegexValidator:\n21     regex = ''\n22     message = _('Enter a valid value.')\n23     code = 'invalid'\n24     inverse_match = False\n25     flags = 0\n26 \n27     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):\n28         if regex is not None:\n29             self.regex = regex\n30         if message is not None:\n31             self.message = message\n32         if code is not None:\n33             self.code = code\n34         if inverse_match is not None:\n35             self.inverse_match = inverse_match\n36         if flags is not None:\n37             self.flags = flags\n38         if self.flags and not isinstance(self.regex, str):\n39             raise TypeError(\"If the flags are set, regex must be a regular expression string.\")\n40 \n41         self.regex = _lazy_re_compile(self.regex, self.flags)\n42 \n43     def __call__(self, value):\n44         \"\"\"\n45         Validate that the input contains (or does *not* contain, if\n46         inverse_match is True) a match for the regular expression.\n47         \"\"\"\n48         regex_matches = self.regex.search(str(value))\n49         invalid_input = regex_matches if self.inverse_match else not regex_matches\n50         if invalid_input:\n51             raise ValidationError(self.message, code=self.code)\n52 \n53     def __eq__(self, other):\n54         return (\n55             isinstance(other, RegexValidator) and\n56             self.regex.pattern == other.regex.pattern and\n57             self.regex.flags == other.regex.flags and\n58             (self.message == other.message) and\n59             (self.code == other.code) and\n60             (self.inverse_match == other.inverse_match)\n61         )\n62 \n63 \n64 @deconstructible\n65 class URLValidator(RegexValidator):\n66     ul = '\\u00a1-\\uffff'  # Unicode letters range (must not be a raw string).\n67 \n68     # IP patterns\n69     ipv4_re = r'(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}'\n70     ipv6_re = r'\\[[0-9a-f:.]+\\]'  # (simple regex, validated later)\n71 \n72     # Host patterns\n73     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'\n74     # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1\n75     domain_re = r'(?:\\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'\n76     tld_re = (\n77         r'\\.'                                # dot\n78         r'(?!-)'                             # can't start with a dash\n79         r'(?:[a-z' + ul + '-]{2,63}'         # domain label\n80         r'|xn--[a-z0-9]{1,59})'              # or punycode label\n81         r'(?<!-)'                            # can't end with a dash\n82         r'\\.?'                               # may have a trailing dot\n83     )\n84     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'\n85 \n86     regex = _lazy_re_compile(\n87         r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately\n88         r'(?:[^\\s:@/]+(?::[^\\s:@/]*)?@)?'  # user:pass authentication\n89         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n90         r'(?::\\d{2,5})?'  # port\n91         r'(?:[/?#][^\\s]*)?'  # resource path\n92         r'\\Z', re.IGNORECASE)\n93     message = _('Enter a valid URL.')\n94     schemes = ['http', 'https', 'ftp', 'ftps']\n95 \n96     def __init__(self, schemes=None, **kwargs):\n97         super().__init__(**kwargs)\n98         if schemes is not None:\n99             self.schemes = schemes\n100 \n101     def __call__(self, value):\n102         if not isinstance(value, str):\n103             raise ValidationError(self.message, code=self.code)\n104         # Check if the scheme is valid.\n105         scheme = value.split('://')[0].lower()\n106         if scheme not in self.schemes:\n107             raise ValidationError(self.message, code=self.code)\n108 \n109         # Then check full URL\n110         try:\n111             super().__call__(value)\n112         except ValidationError as e:\n113             # Trivial case failed. Try for possible IDN domain\n114             if value:\n115                 try:\n116                     scheme, netloc, path, query, fragment = urlsplit(value)\n117                 except ValueError:  # for example, \"Invalid IPv6 URL\"\n118                     raise ValidationError(self.message, code=self.code)\n119                 try:\n120                     netloc = punycode(netloc)  # IDN -> ACE\n121                 except UnicodeError:  # invalid domain part\n122                     raise e\n123                 url = urlunsplit((scheme, netloc, path, query, fragment))\n124                 super().__call__(url)\n125             else:\n126                 raise\n127         else:\n128             # Now verify IPv6 in the netloc part\n129             host_match = re.search(r'^\\[(.+)\\](?::\\d{2,5})?$', urlsplit(value).netloc)\n130             if host_match:\n131                 potential_ip = host_match[1]\n132                 try:\n133                     validate_ipv6_address(potential_ip)\n134                 except ValidationError:\n135                     raise ValidationError(self.message, code=self.code)\n136 \n137         # The maximum length of a full host name is 253 characters per RFC 1034\n138         # section 3.1. It's defined to be 255 bytes or less, but this includes\n139         # one byte for the length of the name and one byte for the trailing dot\n140         # that's used to indicate absolute names in DNS.\n141         if len(urlsplit(value).netloc) > 253:\n142             raise ValidationError(self.message, code=self.code)\n143 \n144 \n145 integer_validator = RegexValidator(\n146     _lazy_re_compile(r'^-?\\d+\\Z'),\n147     message=_('Enter a valid integer.'),\n148     code='invalid',\n149 )\n150 \n151 \n152 def validate_integer(value):\n153     return integer_validator(value)\n154 \n155 \n156 @deconstructible\n157 class EmailValidator:\n158     message = _('Enter a valid email address.')\n159     code = 'invalid'\n160     user_regex = _lazy_re_compile(\n161         r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\\Z\"  # dot-atom\n162         r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"\\Z)',  # quoted-string\n163         re.IGNORECASE)\n164     domain_regex = _lazy_re_compile(\n165         # max length for domain name labels is 63 characters per RFC 1034\n166         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\\Z',\n167         re.IGNORECASE)\n168     literal_regex = _lazy_re_compile(\n169         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)\n170         r'\\[([A-f0-9:.]+)\\]\\Z',\n171         re.IGNORECASE)\n172     domain_allowlist = ['localhost']\n173 \n174     @property\n175     def domain_whitelist(self):\n176         warnings.warn(\n177             'The domain_whitelist attribute is deprecated in favor of '\n178             'domain_allowlist.',\n179             RemovedInDjango41Warning,\n180             stacklevel=2,\n181         )\n182         return self.domain_allowlist\n183 \n184     @domain_whitelist.setter\n185     def domain_whitelist(self, allowlist):\n186         warnings.warn(\n187             'The domain_whitelist attribute is deprecated in favor of '\n188             'domain_allowlist.',\n189             RemovedInDjango41Warning,\n190             stacklevel=2,\n191         )\n192         self.domain_allowlist = allowlist\n193 \n194     def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):\n195         if whitelist is not None:\n196             allowlist = whitelist\n197             warnings.warn(\n198                 'The whitelist argument is deprecated in favor of allowlist.',\n199                 RemovedInDjango41Warning,\n200                 stacklevel=2,\n201             )\n202         if message is not None:\n203             self.message = message\n204         if code is not None:\n205             self.code = code\n206         if allowlist is not None:\n207             self.domain_allowlist = allowlist\n208 \n209     def __call__(self, value):\n210         if not value or '@' not in value:\n211             raise ValidationError(self.message, code=self.code)\n212 \n213         user_part, domain_part = value.rsplit('@', 1)\n214 \n215         if not self.user_regex.match(user_part):\n216             raise ValidationError(self.message, code=self.code)\n217 \n218         if (domain_part not in self.domain_allowlist and\n219                 not self.validate_domain_part(domain_part)):\n220             # Try for possible IDN domain-part\n221             try:\n222                 domain_part = punycode(domain_part)\n223             except UnicodeError:\n224                 pass\n225             else:\n226                 if self.validate_domain_part(domain_part):\n227                     return\n228             raise ValidationError(self.message, code=self.code)\n229 \n230     def validate_domain_part(self, domain_part):\n231         if self.domain_regex.match(domain_part):\n232             return True\n233 \n234         literal_match = self.literal_regex.match(domain_part)\n235         if literal_match:\n236             ip_address = literal_match[1]\n237             try:\n238                 validate_ipv46_address(ip_address)\n239                 return True\n240             except ValidationError:\n241                 pass\n242         return False\n243 \n244     def __eq__(self, other):\n245         return (\n246             isinstance(other, EmailValidator) and\n247             (self.domain_allowlist == other.domain_allowlist) and\n248             (self.message == other.message) and\n249             (self.code == other.code)\n250         )\n251 \n252 \n253 validate_email = EmailValidator()\n254 \n255 slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\\Z')\n256 validate_slug = RegexValidator(\n257     slug_re,\n258     # Translators: \"letters\" means latin letters: a-z and A-Z.\n259     _('Enter a valid \u201cslug\u201d consisting of letters, numbers, underscores or hyphens.'),\n260     'invalid'\n261 )\n262 \n263 slug_unicode_re = _lazy_re_compile(r'^[-\\w]+\\Z')\n264 validate_unicode_slug = RegexValidator(\n265     slug_unicode_re,\n266     _('Enter a valid \u201cslug\u201d consisting of Unicode letters, numbers, underscores, or hyphens.'),\n267     'invalid'\n268 )\n269 \n270 \n271 def validate_ipv4_address(value):\n272     try:\n273         ipaddress.IPv4Address(value)\n274     except ValueError:\n275         raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')\n276 \n277 \n278 def validate_ipv6_address(value):\n279     if not is_valid_ipv6_address(value):\n280         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')\n281 \n282 \n283 def validate_ipv46_address(value):\n284     try:\n285         validate_ipv4_address(value)\n286     except ValidationError:\n287         try:\n288             validate_ipv6_address(value)\n289         except ValidationError:\n290             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')\n291 \n292 \n293 ip_address_validator_map = {\n294     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),\n295     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),\n296     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),\n297 }\n298 \n299 \n300 def ip_address_validators(protocol, unpack_ipv4):\n301     \"\"\"\n302     Depending on the given parameters, return the appropriate validators for\n303     the GenericIPAddressField.\n304     \"\"\"\n305     if protocol != 'both' and unpack_ipv4:\n306         raise ValueError(\n307             \"You can only use `unpack_ipv4` if `protocol` is set to 'both'\")\n308     try:\n309         return ip_address_validator_map[protocol.lower()]\n310     except KeyError:\n311         raise ValueError(\"The protocol '%s' is unknown. Supported: %s\"\n312                          % (protocol, list(ip_address_validator_map)))\n313 \n314 \n315 def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):\n316     regexp = _lazy_re_compile(r'^%(neg)s\\d+(?:%(sep)s%(neg)s\\d+)*\\Z' % {\n317         'neg': '(-)?' if allow_negative else '',\n318         'sep': re.escape(sep),\n319     })\n320     return RegexValidator(regexp, message=message, code=code)\n321 \n322 \n323 validate_comma_separated_integer_list = int_list_validator(\n324     message=_('Enter only digits separated by commas.'),\n325 )\n326 \n327 \n328 @deconstructible\n329 class BaseValidator:\n330     message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')\n331     code = 'limit_value'\n332 \n333     def __init__(self, limit_value, message=None):\n334         self.limit_value = limit_value\n335         if message:\n336             self.message = message\n337 \n338     def __call__(self, value):\n339         cleaned = self.clean(value)\n340         limit_value = self.limit_value() if callable(self.limit_value) else self.limit_value\n341         params = {'limit_value': limit_value, 'show_value': cleaned, 'value': value}\n342         if self.compare(cleaned, limit_value):\n343             raise ValidationError(self.message, code=self.code, params=params)\n344 \n345     def __eq__(self, other):\n346         if not isinstance(other, self.__class__):\n347             return NotImplemented\n348         return (\n349             self.limit_value == other.limit_value and\n350             self.message == other.message and\n351             self.code == other.code\n352         )\n353 \n354     def compare(self, a, b):\n355         return a is not b\n356 \n357     def clean(self, x):\n358         return x\n359 \n360 \n361 @deconstructible\n362 class MaxValueValidator(BaseValidator):\n363     message = _('Ensure this value is less than or equal to %(limit_value)s.')\n364     code = 'max_value'\n365 \n366     def compare(self, a, b):\n367         return a > b\n368 \n369 \n370 @deconstructible\n371 class MinValueValidator(BaseValidator):\n372     message = _('Ensure this value is greater than or equal to %(limit_value)s.')\n373     code = 'min_value'\n374 \n375     def compare(self, a, b):\n376         return a < b\n377 \n378 \n379 @deconstructible\n380 class MinLengthValidator(BaseValidator):\n381     message = ngettext_lazy(\n382         'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',\n383         'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',\n384         'limit_value')\n385     code = 'min_length'\n386 \n387     def compare(self, a, b):\n388         return a < b\n389 \n390     def clean(self, x):\n391         return len(x)\n392 \n393 \n394 @deconstructible\n395 class MaxLengthValidator(BaseValidator):\n396     message = ngettext_lazy(\n397         'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',\n398         'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',\n399         'limit_value')\n400     code = 'max_length'\n401 \n402     def compare(self, a, b):\n403         return a > b\n404 \n405     def clean(self, x):\n406         return len(x)\n407 \n408 \n409 @deconstructible\n410 class DecimalValidator:\n411     \"\"\"\n412     Validate that the input does not exceed the maximum number of digits\n413     expected, otherwise raise ValidationError.\n414     \"\"\"\n415     messages = {\n416         'invalid': _('Enter a number.'),\n417         'max_digits': ngettext_lazy(\n418             'Ensure that there are no more than %(max)s digit in total.',\n419             'Ensure that there are no more than %(max)s digits in total.',\n420             'max'\n421         ),\n422         'max_decimal_places': ngettext_lazy(\n423             'Ensure that there are no more than %(max)s decimal place.',\n424             'Ensure that there are no more than %(max)s decimal places.',\n425             'max'\n426         ),\n427         'max_whole_digits': ngettext_lazy(\n428             'Ensure that there are no more than %(max)s digit before the decimal point.',\n429             'Ensure that there are no more than %(max)s digits before the decimal point.',\n430             'max'\n431         ),\n432     }\n433 \n434     def __init__(self, max_digits, decimal_places):\n435         self.max_digits = max_digits\n436         self.decimal_places = decimal_places\n437 \n438     def __call__(self, value):\n439         digit_tuple, exponent = value.as_tuple()[1:]\n440         if exponent in {'F', 'n', 'N'}:\n441             raise ValidationError(self.messages['invalid'])\n442         if exponent >= 0:\n443             # A positive exponent adds that many trailing zeros.\n444             digits = len(digit_tuple) + exponent\n445             decimals = 0\n446         else:\n447             # If the absolute value of the negative exponent is larger than the\n448             # number of digits, then it's the same as the number of digits,\n449             # because it'll consume all of the digits in digit_tuple and then\n450             # add abs(exponent) - len(digit_tuple) leading zeros after the\n451             # decimal point.\n452             if abs(exponent) > len(digit_tuple):\n453                 digits = decimals = abs(exponent)\n454             else:\n455                 digits = len(digit_tuple)\n456                 decimals = abs(exponent)\n457         whole_digits = digits - decimals\n458 \n459         if self.max_digits is not None and digits > self.max_digits:\n460             raise ValidationError(\n461                 self.messages['max_digits'],\n462                 code='max_digits',\n463                 params={'max': self.max_digits},\n464             )\n465         if self.decimal_places is not None and decimals > self.decimal_places:\n466             raise ValidationError(\n467                 self.messages['max_decimal_places'],\n468                 code='max_decimal_places',\n469                 params={'max': self.decimal_places},\n470             )\n471         if (self.max_digits is not None and self.decimal_places is not None and\n472                 whole_digits > (self.max_digits - self.decimal_places)):\n473             raise ValidationError(\n474                 self.messages['max_whole_digits'],\n475                 code='max_whole_digits',\n476                 params={'max': (self.max_digits - self.decimal_places)},\n477             )\n478 \n479     def __eq__(self, other):\n480         return (\n481             isinstance(other, self.__class__) and\n482             self.max_digits == other.max_digits and\n483             self.decimal_places == other.decimal_places\n484         )\n485 \n486 \n487 @deconstructible\n488 class FileExtensionValidator:\n489     message = _(\n490         'File extension \u201c%(extension)s\u201d is not allowed. '\n491         'Allowed extensions are: %(allowed_extensions)s.'\n492     )\n493     code = 'invalid_extension'\n494 \n495     def __init__(self, allowed_extensions=None, message=None, code=None):\n496         if allowed_extensions is not None:\n497             allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]\n498         self.allowed_extensions = allowed_extensions\n499         if message is not None:\n500             self.message = message\n501         if code is not None:\n502             self.code = code\n503 \n504     def __call__(self, value):\n505         extension = Path(value.name).suffix[1:].lower()\n506         if self.allowed_extensions is not None and extension not in self.allowed_extensions:\n507             raise ValidationError(\n508                 self.message,\n509                 code=self.code,\n510                 params={\n511                     'extension': extension,\n512                     'allowed_extensions': ', '.join(self.allowed_extensions)\n513                 }\n514             )\n515 \n516     def __eq__(self, other):\n517         return (\n518             isinstance(other, self.__class__) and\n519             self.allowed_extensions == other.allowed_extensions and\n520             self.message == other.message and\n521             self.code == other.code\n522         )\n523 \n524 \n525 def get_available_image_extensions():\n526     try:\n527         from PIL import Image\n528     except ImportError:\n529         return []\n530     else:\n531         Image.init()\n532         return [ext.lower()[1:] for ext in Image.EXTENSION]\n533 \n534 \n535 def validate_image_file_extension(value):\n536     return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)\n537 \n538 \n539 @deconstructible\n540 class ProhibitNullCharactersValidator:\n541     \"\"\"Validate that the string doesn't contain the null character.\"\"\"\n542     message = _('Null characters are not allowed.')\n543     code = 'null_characters_not_allowed'\n544 \n545     def __init__(self, message=None, code=None):\n546         if message is not None:\n547             self.message = message\n548         if code is not None:\n549             self.code = code\n550 \n551     def __call__(self, value):\n552         if '\\x00' in str(value):\n553             raise ValidationError(self.message, code=self.code)\n554 \n555     def __eq__(self, other):\n556         return (\n557             isinstance(other, self.__class__) and\n558             self.message == other.message and\n559             self.code == other.code\n560         )\n",
        "intended_behavior": "Update the built-in validator functions in this file to pass the provided_value to ValidationError when raising it. This change allows these validators to include the value that failed validation in the error message, improving the informativeness of validation errors."
    },
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/forms/fields.py",
        "start": 1,
        "end": 1278,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Field classes.\n3 \"\"\"\n4 \n5 import copy\n6 import datetime\n7 import json\n8 import math\n9 import operator\n10 import os\n11 import re\n12 import uuid\n13 from decimal import Decimal, DecimalException\n14 from io import BytesIO\n15 from urllib.parse import urlsplit, urlunsplit\n16 \n17 from django.core import validators\n18 from django.core.exceptions import ValidationError\n19 from django.forms.boundfield import BoundField\n20 from django.forms.utils import from_current_timezone, to_current_timezone\n21 from django.forms.widgets import (\n22     FILE_INPUT_CONTRADICTION, CheckboxInput, ClearableFileInput, DateInput,\n23     DateTimeInput, EmailInput, FileInput, HiddenInput, MultipleHiddenInput,\n24     NullBooleanSelect, NumberInput, Select, SelectMultiple,\n25     SplitDateTimeWidget, SplitHiddenDateTimeWidget, Textarea, TextInput,\n26     TimeInput, URLInput,\n27 )\n28 from django.utils import formats\n29 from django.utils.dateparse import parse_datetime, parse_duration\n30 from django.utils.duration import duration_string\n31 from django.utils.ipv6 import clean_ipv6_address\n32 from django.utils.regex_helper import _lazy_re_compile\n33 from django.utils.translation import gettext_lazy as _, ngettext_lazy\n34 \n35 __all__ = (\n36     'Field', 'CharField', 'IntegerField',\n37     'DateField', 'TimeField', 'DateTimeField', 'DurationField',\n38     'RegexField', 'EmailField', 'FileField', 'ImageField', 'URLField',\n39     'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',\n40     'ComboField', 'MultiValueField', 'FloatField', 'DecimalField',\n41     'SplitDateTimeField', 'GenericIPAddressField', 'FilePathField',\n42     'JSONField', 'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField',\n43     'UUIDField',\n44 )\n45 \n46 \n47 class Field:\n48     widget = TextInput  # Default widget to use when rendering this type of Field.\n49     hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\n50     default_validators = []  # Default set of validators\n51     # Add an 'invalid' entry to default_error_message if you want a specific\n52     # field error message not raised by the field validators.\n53     default_error_messages = {\n54         'required': _('This field is required.'),\n55     }\n56     empty_values = list(validators.EMPTY_VALUES)\n57 \n58     def __init__(self, *, required=True, widget=None, label=None, initial=None,\n59                  help_text='', error_messages=None, show_hidden_initial=False,\n60                  validators=(), localize=False, disabled=False, label_suffix=None):\n61         # required -- Boolean that specifies whether the field is required.\n62         #             True by default.\n63         # widget -- A Widget class, or instance of a Widget class, that should\n64         #           be used for this Field when displaying it. Each Field has a\n65         #           default Widget that it'll use if you don't specify this. In\n66         #           most cases, the default widget is TextInput.\n67         # label -- A verbose name for this field, for use in displaying this\n68         #          field in a form. By default, Django will use a \"pretty\"\n69         #          version of the form field name, if the Field is part of a\n70         #          Form.\n71         # initial -- A value to use in this Field's initial display. This value\n72         #            is *not* used as a fallback if data isn't given.\n73         # help_text -- An optional string to use as \"help text\" for this Field.\n74         # error_messages -- An optional dictionary to override the default\n75         #                   messages that the field will raise.\n76         # show_hidden_initial -- Boolean that specifies if it is needed to render a\n77         #                        hidden widget with initial value after widget.\n78         # validators -- List of additional validators to use\n79         # localize -- Boolean that specifies if the field should be localized.\n80         # disabled -- Boolean that specifies whether the field is disabled, that\n81         #             is its widget is shown in the form but not editable.\n82         # label_suffix -- Suffix to be added to the label. Overrides\n83         #                 form's label_suffix.\n84         self.required, self.label, self.initial = required, label, initial\n85         self.show_hidden_initial = show_hidden_initial\n86         self.help_text = help_text\n87         self.disabled = disabled\n88         self.label_suffix = label_suffix\n89         widget = widget or self.widget\n90         if isinstance(widget, type):\n91             widget = widget()\n92         else:\n93             widget = copy.deepcopy(widget)\n94 \n95         # Trigger the localization machinery if needed.\n96         self.localize = localize\n97         if self.localize:\n98             widget.is_localized = True\n99 \n100         # Let the widget know whether it should display as required.\n101         widget.is_required = self.required\n102 \n103         # Hook into self.widget_attrs() for any Field-specific HTML attributes.\n104         extra_attrs = self.widget_attrs(widget)\n105         if extra_attrs:\n106             widget.attrs.update(extra_attrs)\n107 \n108         self.widget = widget\n109 \n110         messages = {}\n111         for c in reversed(self.__class__.__mro__):\n112             messages.update(getattr(c, 'default_error_messages', {}))\n113         messages.update(error_messages or {})\n114         self.error_messages = messages\n115 \n116         self.validators = [*self.default_validators, *validators]\n117 \n118         super().__init__()\n119 \n120     def prepare_value(self, value):\n121         return value\n122 \n123     def to_python(self, value):\n124         return value\n125 \n126     def validate(self, value):\n127         if value in self.empty_values and self.required:\n128             raise ValidationError(self.error_messages['required'], code='required')\n129 \n130     def run_validators(self, value):\n131         if value in self.empty_values:\n132             return\n133         errors = []\n134         for v in self.validators:\n135             try:\n136                 v(value)\n137             except ValidationError as e:\n138                 if hasattr(e, 'code') and e.code in self.error_messages:\n139                     e.message = self.error_messages[e.code]\n140                 errors.extend(e.error_list)\n141         if errors:\n142             raise ValidationError(errors)\n143 \n144     def clean(self, value):\n145         \"\"\"\n146         Validate the given value and return its \"cleaned\" value as an\n147         appropriate Python object. Raise ValidationError for any errors.\n148         \"\"\"\n149         value = self.to_python(value)\n150         self.validate(value)\n151         self.run_validators(value)\n152         return value\n153 \n154     def bound_data(self, data, initial):\n155         \"\"\"\n156         Return the value that should be shown for this field on render of a\n157         bound form, given the submitted POST data for the field and the initial\n158         data, if any.\n159 \n160         For most fields, this will simply be data; FileFields need to handle it\n161         a bit differently.\n162         \"\"\"\n163         if self.disabled:\n164             return initial\n165         return data\n166 \n167     def widget_attrs(self, widget):\n168         \"\"\"\n169         Given a Widget instance (*not* a Widget class), return a dictionary of\n170         any HTML attributes that should be added to the Widget, based on this\n171         Field.\n172         \"\"\"\n173         return {}\n174 \n175     def has_changed(self, initial, data):\n176         \"\"\"Return True if data differs from initial.\"\"\"\n177         # Always return False if the field is disabled since self.bound_data\n178         # always uses the initial value in this case.\n179         if self.disabled:\n180             return False\n181         try:\n182             data = self.to_python(data)\n183             if hasattr(self, '_coerce'):\n184                 return self._coerce(data) != self._coerce(initial)\n185         except ValidationError:\n186             return True\n187         # For purposes of seeing whether something has changed, None is\n188         # the same as an empty string, if the data or initial value we get\n189         # is None, replace it with ''.\n190         initial_value = initial if initial is not None else ''\n191         data_value = data if data is not None else ''\n192         return initial_value != data_value\n193 \n194     def get_bound_field(self, form, field_name):\n195         \"\"\"\n196         Return a BoundField instance that will be used when accessing the form\n197         field in a template.\n198         \"\"\"\n199         return BoundField(form, self, field_name)\n200 \n201     def __deepcopy__(self, memo):\n202         result = copy.copy(self)\n203         memo[id(self)] = result\n204         result.widget = copy.deepcopy(self.widget, memo)\n205         result.error_messages = self.error_messages.copy()\n206         result.validators = self.validators[:]\n207         return result\n208 \n209 \n210 class CharField(Field):\n211     def __init__(self, *, max_length=None, min_length=None, strip=True, empty_value='', **kwargs):\n212         self.max_length = max_length\n213         self.min_length = min_length\n214         self.strip = strip\n215         self.empty_value = empty_value\n216         super().__init__(**kwargs)\n217         if min_length is not None:\n218             self.validators.append(validators.MinLengthValidator(int(min_length)))\n219         if max_length is not None:\n220             self.validators.append(validators.MaxLengthValidator(int(max_length)))\n221         self.validators.append(validators.ProhibitNullCharactersValidator())\n222 \n223     def to_python(self, value):\n224         \"\"\"Return a string.\"\"\"\n225         if value not in self.empty_values:\n226             value = str(value)\n227             if self.strip:\n228                 value = value.strip()\n229         if value in self.empty_values:\n230             return self.empty_value\n231         return value\n232 \n233     def widget_attrs(self, widget):\n234         attrs = super().widget_attrs(widget)\n235         if self.max_length is not None and not widget.is_hidden:\n236             # The HTML attribute is maxlength, not max_length.\n237             attrs['maxlength'] = str(self.max_length)\n238         if self.min_length is not None and not widget.is_hidden:\n239             # The HTML attribute is minlength, not min_length.\n240             attrs['minlength'] = str(self.min_length)\n241         return attrs\n242 \n243 \n244 class IntegerField(Field):\n245     widget = NumberInput\n246     default_error_messages = {\n247         'invalid': _('Enter a whole number.'),\n248     }\n249     re_decimal = _lazy_re_compile(r'\\.0*\\s*$')\n250 \n251     def __init__(self, *, max_value=None, min_value=None, **kwargs):\n252         self.max_value, self.min_value = max_value, min_value\n253         if kwargs.get('localize') and self.widget == NumberInput:\n254             # Localized number input is not well supported on most browsers\n255             kwargs.setdefault('widget', super().widget)\n256         super().__init__(**kwargs)\n257 \n258         if max_value is not None:\n259             self.validators.append(validators.MaxValueValidator(max_value))\n260         if min_value is not None:\n261             self.validators.append(validators.MinValueValidator(min_value))\n262 \n263     def to_python(self, value):\n264         \"\"\"\n265         Validate that int() can be called on the input. Return the result\n266         of int() or None for empty values.\n267         \"\"\"\n268         value = super().to_python(value)\n269         if value in self.empty_values:\n270             return None\n271         if self.localize:\n272             value = formats.sanitize_separators(value)\n273         # Strip trailing decimal and zeros.\n274         try:\n275             value = int(self.re_decimal.sub('', str(value)))\n276         except (ValueError, TypeError):\n277             raise ValidationError(self.error_messages['invalid'], code='invalid')\n278         return value\n279 \n280     def widget_attrs(self, widget):\n281         attrs = super().widget_attrs(widget)\n282         if isinstance(widget, NumberInput):\n283             if self.min_value is not None:\n284                 attrs['min'] = self.min_value\n285             if self.max_value is not None:\n286                 attrs['max'] = self.max_value\n287         return attrs\n288 \n289 \n290 class FloatField(IntegerField):\n291     default_error_messages = {\n292         'invalid': _('Enter a number.'),\n293     }\n294 \n295     def to_python(self, value):\n296         \"\"\"\n297         Validate that float() can be called on the input. Return the result\n298         of float() or None for empty values.\n299         \"\"\"\n300         value = super(IntegerField, self).to_python(value)\n301         if value in self.empty_values:\n302             return None\n303         if self.localize:\n304             value = formats.sanitize_separators(value)\n305         try:\n306             value = float(value)\n307         except (ValueError, TypeError):\n308             raise ValidationError(self.error_messages['invalid'], code='invalid')\n309         return value\n310 \n311     def validate(self, value):\n312         super().validate(value)\n313         if value in self.empty_values:\n314             return\n315         if not math.isfinite(value):\n316             raise ValidationError(self.error_messages['invalid'], code='invalid')\n317 \n318     def widget_attrs(self, widget):\n319         attrs = super().widget_attrs(widget)\n320         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:\n321             attrs.setdefault('step', 'any')\n322         return attrs\n323 \n324 \n325 class DecimalField(IntegerField):\n326     default_error_messages = {\n327         'invalid': _('Enter a number.'),\n328     }\n329 \n330     def __init__(self, *, max_value=None, min_value=None, max_digits=None, decimal_places=None, **kwargs):\n331         self.max_digits, self.decimal_places = max_digits, decimal_places\n332         super().__init__(max_value=max_value, min_value=min_value, **kwargs)\n333         self.validators.append(validators.DecimalValidator(max_digits, decimal_places))\n334 \n335     def to_python(self, value):\n336         \"\"\"\n337         Validate that the input is a decimal number. Return a Decimal\n338         instance or None for empty values. Ensure that there are no more\n339         than max_digits in the number and no more than decimal_places digits\n340         after the decimal point.\n341         \"\"\"\n342         if value in self.empty_values:\n343             return None\n344         if self.localize:\n345             value = formats.sanitize_separators(value)\n346         value = str(value).strip()\n347         try:\n348             value = Decimal(value)\n349         except DecimalException:\n350             raise ValidationError(self.error_messages['invalid'], code='invalid')\n351         return value\n352 \n353     def validate(self, value):\n354         super().validate(value)\n355         if value in self.empty_values:\n356             return\n357         if not value.is_finite():\n358             raise ValidationError(self.error_messages['invalid'], code='invalid')\n359 \n360     def widget_attrs(self, widget):\n361         attrs = super().widget_attrs(widget)\n362         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:\n363             if self.decimal_places is not None:\n364                 # Use exponential notation for small values since they might\n365                 # be parsed as 0 otherwise. ref #20765\n366                 step = str(Decimal(1).scaleb(-self.decimal_places)).lower()\n367             else:\n368                 step = 'any'\n369             attrs.setdefault('step', step)\n370         return attrs\n371 \n372 \n373 class BaseTemporalField(Field):\n374 \n375     def __init__(self, *, input_formats=None, **kwargs):\n376         super().__init__(**kwargs)\n377         if input_formats is not None:\n378             self.input_formats = input_formats\n379 \n380     def to_python(self, value):\n381         value = value.strip()\n382         # Try to strptime against each input format.\n383         for format in self.input_formats:\n384             try:\n385                 return self.strptime(value, format)\n386             except (ValueError, TypeError):\n387                 continue\n388         raise ValidationError(self.error_messages['invalid'], code='invalid')\n389 \n390     def strptime(self, value, format):\n391         raise NotImplementedError('Subclasses must define this method.')\n392 \n393 \n394 class DateField(BaseTemporalField):\n395     widget = DateInput\n396     input_formats = formats.get_format_lazy('DATE_INPUT_FORMATS')\n397     default_error_messages = {\n398         'invalid': _('Enter a valid date.'),\n399     }\n400 \n401     def to_python(self, value):\n402         \"\"\"\n403         Validate that the input can be converted to a date. Return a Python\n404         datetime.date object.\n405         \"\"\"\n406         if value in self.empty_values:\n407             return None\n408         if isinstance(value, datetime.datetime):\n409             return value.date()\n410         if isinstance(value, datetime.date):\n411             return value\n412         return super().to_python(value)\n413 \n414     def strptime(self, value, format):\n415         return datetime.datetime.strptime(value, format).date()\n416 \n417 \n418 class TimeField(BaseTemporalField):\n419     widget = TimeInput\n420     input_formats = formats.get_format_lazy('TIME_INPUT_FORMATS')\n421     default_error_messages = {\n422         'invalid': _('Enter a valid time.')\n423     }\n424 \n425     def to_python(self, value):\n426         \"\"\"\n427         Validate that the input can be converted to a time. Return a Python\n428         datetime.time object.\n429         \"\"\"\n430         if value in self.empty_values:\n431             return None\n432         if isinstance(value, datetime.time):\n433             return value\n434         return super().to_python(value)\n435 \n436     def strptime(self, value, format):\n437         return datetime.datetime.strptime(value, format).time()\n438 \n439 \n440 class DateTimeFormatsIterator:\n441     def __iter__(self):\n442         yield from formats.get_format('DATETIME_INPUT_FORMATS')\n443         yield from formats.get_format('DATE_INPUT_FORMATS')\n444 \n445 \n446 class DateTimeField(BaseTemporalField):\n447     widget = DateTimeInput\n448     input_formats = DateTimeFormatsIterator()\n449     default_error_messages = {\n450         'invalid': _('Enter a valid date/time.'),\n451     }\n452 \n453     def prepare_value(self, value):\n454         if isinstance(value, datetime.datetime):\n455             value = to_current_timezone(value)\n456         return value\n457 \n458     def to_python(self, value):\n459         \"\"\"\n460         Validate that the input can be converted to a datetime. Return a\n461         Python datetime.datetime object.\n462         \"\"\"\n463         if value in self.empty_values:\n464             return None\n465         if isinstance(value, datetime.datetime):\n466             return from_current_timezone(value)\n467         if isinstance(value, datetime.date):\n468             result = datetime.datetime(value.year, value.month, value.day)\n469             return from_current_timezone(result)\n470         try:\n471             result = parse_datetime(value.strip())\n472         except ValueError:\n473             raise ValidationError(self.error_messages['invalid'], code='invalid')\n474         if not result:\n475             result = super().to_python(value)\n476         return from_current_timezone(result)\n477 \n478     def strptime(self, value, format):\n479         return datetime.datetime.strptime(value, format)\n480 \n481 \n482 class DurationField(Field):\n483     default_error_messages = {\n484         'invalid': _('Enter a valid duration.'),\n485         'overflow': _('The number of days must be between {min_days} and {max_days}.')\n486     }\n487 \n488     def prepare_value(self, value):\n489         if isinstance(value, datetime.timedelta):\n490             return duration_string(value)\n491         return value\n492 \n493     def to_python(self, value):\n494         if value in self.empty_values:\n495             return None\n496         if isinstance(value, datetime.timedelta):\n497             return value\n498         try:\n499             value = parse_duration(str(value))\n500         except OverflowError:\n501             raise ValidationError(self.error_messages['overflow'].format(\n502                 min_days=datetime.timedelta.min.days,\n503                 max_days=datetime.timedelta.max.days,\n504             ), code='overflow')\n505         if value is None:\n506             raise ValidationError(self.error_messages['invalid'], code='invalid')\n507         return value\n508 \n509 \n510 class RegexField(CharField):\n511     def __init__(self, regex, **kwargs):\n512         \"\"\"\n513         regex can be either a string or a compiled regular expression object.\n514         \"\"\"\n515         kwargs.setdefault('strip', False)\n516         super().__init__(**kwargs)\n517         self._set_regex(regex)\n518 \n519     def _get_regex(self):\n520         return self._regex\n521 \n522     def _set_regex(self, regex):\n523         if isinstance(regex, str):\n524             regex = re.compile(regex)\n525         self._regex = regex\n526         if hasattr(self, '_regex_validator') and self._regex_validator in self.validators:\n527             self.validators.remove(self._regex_validator)\n528         self._regex_validator = validators.RegexValidator(regex=regex)\n529         self.validators.append(self._regex_validator)\n530 \n531     regex = property(_get_regex, _set_regex)\n532 \n533 \n534 class EmailField(CharField):\n535     widget = EmailInput\n536     default_validators = [validators.validate_email]\n537 \n538     def __init__(self, **kwargs):\n539         super().__init__(strip=True, **kwargs)\n540 \n541 \n542 class FileField(Field):\n543     widget = ClearableFileInput\n544     default_error_messages = {\n545         'invalid': _(\"No file was submitted. Check the encoding type on the form.\"),\n546         'missing': _(\"No file was submitted.\"),\n547         'empty': _(\"The submitted file is empty.\"),\n548         'max_length': ngettext_lazy(\n549             'Ensure this filename has at most %(max)d character (it has %(length)d).',\n550             'Ensure this filename has at most %(max)d characters (it has %(length)d).',\n551             'max'),\n552         'contradiction': _('Please either submit a file or check the clear checkbox, not both.')\n553     }\n554 \n555     def __init__(self, *, max_length=None, allow_empty_file=False, **kwargs):\n556         self.max_length = max_length\n557         self.allow_empty_file = allow_empty_file\n558         super().__init__(**kwargs)\n559 \n560     def to_python(self, data):\n561         if data in self.empty_values:\n562             return None\n563 \n564         # UploadedFile objects should have name and size attributes.\n565         try:\n566             file_name = data.name\n567             file_size = data.size\n568         except AttributeError:\n569             raise ValidationError(self.error_messages['invalid'], code='invalid')\n570 \n571         if self.max_length is not None and len(file_name) > self.max_length:\n572             params = {'max': self.max_length, 'length': len(file_name)}\n573             raise ValidationError(self.error_messages['max_length'], code='max_length', params=params)\n574         if not file_name:\n575             raise ValidationError(self.error_messages['invalid'], code='invalid')\n576         if not self.allow_empty_file and not file_size:\n577             raise ValidationError(self.error_messages['empty'], code='empty')\n578 \n579         return data\n580 \n581     def clean(self, data, initial=None):\n582         # If the widget got contradictory inputs, we raise a validation error\n583         if data is FILE_INPUT_CONTRADICTION:\n584             raise ValidationError(self.error_messages['contradiction'], code='contradiction')\n585         # False means the field value should be cleared; further validation is\n586         # not needed.\n587         if data is False:\n588             if not self.required:\n589                 return False\n590             # If the field is required, clearing is not possible (the widget\n591             # shouldn't return False data in that case anyway). False is not\n592             # in self.empty_value; if a False value makes it this far\n593             # it should be validated from here on out as None (so it will be\n594             # caught by the required check).\n595             data = None\n596         if not data and initial:\n597             return initial\n598         return super().clean(data)\n599 \n600     def bound_data(self, data, initial):\n601         if data in (None, FILE_INPUT_CONTRADICTION):\n602             return initial\n603         return data\n604 \n605     def has_changed(self, initial, data):\n606         return not self.disabled and data is not None\n607 \n608 \n609 class ImageField(FileField):\n610     default_validators = [validators.validate_image_file_extension]\n611     default_error_messages = {\n612         'invalid_image': _(\n613             \"Upload a valid image. The file you uploaded was either not an \"\n614             \"image or a corrupted image.\"\n615         ),\n616     }\n617 \n618     def to_python(self, data):\n619         \"\"\"\n620         Check that the file-upload field data contains a valid image (GIF, JPG,\n621         PNG, etc. -- whatever Pillow supports).\n622         \"\"\"\n623         f = super().to_python(data)\n624         if f is None:\n625             return None\n626 \n627         from PIL import Image\n628 \n629         # We need to get a file object for Pillow. We might have a path or we might\n630         # have to read the data into memory.\n631         if hasattr(data, 'temporary_file_path'):\n632             file = data.temporary_file_path()\n633         else:\n634             if hasattr(data, 'read'):\n635                 file = BytesIO(data.read())\n636             else:\n637                 file = BytesIO(data['content'])\n638 \n639         try:\n640             # load() could spot a truncated JPEG, but it loads the entire\n641             # image in memory, which is a DoS vector. See #3848 and #18520.\n642             image = Image.open(file)\n643             # verify() must be called immediately after the constructor.\n644             image.verify()\n645 \n646             # Annotating so subclasses can reuse it for their own validation\n647             f.image = image\n648             # Pillow doesn't detect the MIME type of all formats. In those\n649             # cases, content_type will be None.\n650             f.content_type = Image.MIME.get(image.format)\n651         except Exception as exc:\n652             # Pillow doesn't recognize it as an image.\n653             raise ValidationError(\n654                 self.error_messages['invalid_image'],\n655                 code='invalid_image',\n656             ) from exc\n657         if hasattr(f, 'seek') and callable(f.seek):\n658             f.seek(0)\n659         return f\n660 \n661     def widget_attrs(self, widget):\n662         attrs = super().widget_attrs(widget)\n663         if isinstance(widget, FileInput) and 'accept' not in widget.attrs:\n664             attrs.setdefault('accept', 'image/*')\n665         return attrs\n666 \n667 \n668 class URLField(CharField):\n669     widget = URLInput\n670     default_error_messages = {\n671         'invalid': _('Enter a valid URL.'),\n672     }\n673     default_validators = [validators.URLValidator()]\n674 \n675     def __init__(self, **kwargs):\n676         super().__init__(strip=True, **kwargs)\n677 \n678     def to_python(self, value):\n679 \n680         def split_url(url):\n681             \"\"\"\n682             Return a list of url parts via urlparse.urlsplit(), or raise\n683             ValidationError for some malformed URLs.\n684             \"\"\"\n685             try:\n686                 return list(urlsplit(url))\n687             except ValueError:\n688                 # urlparse.urlsplit can raise a ValueError with some\n689                 # misformatted URLs.\n690                 raise ValidationError(self.error_messages['invalid'], code='invalid')\n691 \n692         value = super().to_python(value)\n693         if value:\n694             url_fields = split_url(value)\n695             if not url_fields[0]:\n696                 # If no URL scheme given, assume http://\n697                 url_fields[0] = 'http'\n698             if not url_fields[1]:\n699                 # Assume that if no domain is provided, that the path segment\n700                 # contains the domain.\n701                 url_fields[1] = url_fields[2]\n702                 url_fields[2] = ''\n703                 # Rebuild the url_fields list, since the domain segment may now\n704                 # contain the path too.\n705                 url_fields = split_url(urlunsplit(url_fields))\n706             value = urlunsplit(url_fields)\n707         return value\n708 \n709 \n710 class BooleanField(Field):\n711     widget = CheckboxInput\n712 \n713     def to_python(self, value):\n714         \"\"\"Return a Python boolean object.\"\"\"\n715         # Explicitly check for the string 'False', which is what a hidden field\n716         # will submit for False. Also check for '0', since this is what\n717         # RadioSelect will provide. Because bool(\"True\") == bool('1') == True,\n718         # we don't need to handle that explicitly.\n719         if isinstance(value, str) and value.lower() in ('false', '0'):\n720             value = False\n721         else:\n722             value = bool(value)\n723         return super().to_python(value)\n724 \n725     def validate(self, value):\n726         if not value and self.required:\n727             raise ValidationError(self.error_messages['required'], code='required')\n728 \n729     def has_changed(self, initial, data):\n730         if self.disabled:\n731             return False\n732         # Sometimes data or initial may be a string equivalent of a boolean\n733         # so we should run it through to_python first to get a boolean value\n734         return self.to_python(initial) != self.to_python(data)\n735 \n736 \n737 class NullBooleanField(BooleanField):\n738     \"\"\"\n739     A field whose valid values are None, True, and False. Clean invalid values\n740     to None.\n741     \"\"\"\n742     widget = NullBooleanSelect\n743 \n744     def to_python(self, value):\n745         \"\"\"\n746         Explicitly check for the string 'True' and 'False', which is what a\n747         hidden field will submit for True and False, for 'true' and 'false',\n748         which are likely to be returned by JavaScript serializations of forms,\n749         and for '1' and '0', which is what a RadioField will submit. Unlike\n750         the Booleanfield, this field must check for True because it doesn't\n751         use the bool() function.\n752         \"\"\"\n753         if value in (True, 'True', 'true', '1'):\n754             return True\n755         elif value in (False, 'False', 'false', '0'):\n756             return False\n757         else:\n758             return None\n759 \n760     def validate(self, value):\n761         pass\n762 \n763 \n764 class CallableChoiceIterator:\n765     def __init__(self, choices_func):\n766         self.choices_func = choices_func\n767 \n768     def __iter__(self):\n769         yield from self.choices_func()\n770 \n771 \n772 class ChoiceField(Field):\n773     widget = Select\n774     default_error_messages = {\n775         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),\n776     }\n777 \n778     def __init__(self, *, choices=(), **kwargs):\n779         super().__init__(**kwargs)\n780         self.choices = choices\n781 \n782     def __deepcopy__(self, memo):\n783         result = super().__deepcopy__(memo)\n784         result._choices = copy.deepcopy(self._choices, memo)\n785         return result\n786 \n787     def _get_choices(self):\n788         return self._choices\n789 \n790     def _set_choices(self, value):\n791         # Setting choices also sets the choices on the widget.\n792         # choices can be any iterable, but we call list() on it because\n793         # it will be consumed more than once.\n794         if callable(value):\n795             value = CallableChoiceIterator(value)\n796         else:\n797             value = list(value)\n798 \n799         self._choices = self.widget.choices = value\n800 \n801     choices = property(_get_choices, _set_choices)\n802 \n803     def to_python(self, value):\n804         \"\"\"Return a string.\"\"\"\n805         if value in self.empty_values:\n806             return ''\n807         return str(value)\n808 \n809     def validate(self, value):\n810         \"\"\"Validate that the input is in self.choices.\"\"\"\n811         super().validate(value)\n812         if value and not self.valid_value(value):\n813             raise ValidationError(\n814                 self.error_messages['invalid_choice'],\n815                 code='invalid_choice',\n816                 params={'value': value},\n817             )\n818 \n819     def valid_value(self, value):\n820         \"\"\"Check to see if the provided value is a valid choice.\"\"\"\n821         text_value = str(value)\n822         for k, v in self.choices:\n823             if isinstance(v, (list, tuple)):\n824                 # This is an optgroup, so look inside the group for options\n825                 for k2, v2 in v:\n826                     if value == k2 or text_value == str(k2):\n827                         return True\n828             else:\n829                 if value == k or text_value == str(k):\n830                     return True\n831         return False\n832 \n833 \n834 class TypedChoiceField(ChoiceField):\n835     def __init__(self, *, coerce=lambda val: val, empty_value='', **kwargs):\n836         self.coerce = coerce\n837         self.empty_value = empty_value\n838         super().__init__(**kwargs)\n839 \n840     def _coerce(self, value):\n841         \"\"\"\n842         Validate that the value can be coerced to the right type (if not empty).\n843         \"\"\"\n844         if value == self.empty_value or value in self.empty_values:\n845             return self.empty_value\n846         try:\n847             value = self.coerce(value)\n848         except (ValueError, TypeError, ValidationError):\n849             raise ValidationError(\n850                 self.error_messages['invalid_choice'],\n851                 code='invalid_choice',\n852                 params={'value': value},\n853             )\n854         return value\n855 \n856     def clean(self, value):\n857         value = super().clean(value)\n858         return self._coerce(value)\n859 \n860 \n861 class MultipleChoiceField(ChoiceField):\n862     hidden_widget = MultipleHiddenInput\n863     widget = SelectMultiple\n864     default_error_messages = {\n865         'invalid_choice': _('Select a valid choice. %(value)s is not one of the available choices.'),\n866         'invalid_list': _('Enter a list of values.'),\n867     }\n868 \n869     def to_python(self, value):\n870         if not value:\n871             return []\n872         elif not isinstance(value, (list, tuple)):\n873             raise ValidationError(self.error_messages['invalid_list'], code='invalid_list')\n874         return [str(val) for val in value]\n875 \n876     def validate(self, value):\n877         \"\"\"Validate that the input is a list or tuple.\"\"\"\n878         if self.required and not value:\n879             raise ValidationError(self.error_messages['required'], code='required')\n880         # Validate that each value in the value list is in self.choices.\n881         for val in value:\n882             if not self.valid_value(val):\n883                 raise ValidationError(\n884                     self.error_messages['invalid_choice'],\n885                     code='invalid_choice',\n886                     params={'value': val},\n887                 )\n888 \n889     def has_changed(self, initial, data):\n890         if self.disabled:\n891             return False\n892         if initial is None:\n893             initial = []\n894         if data is None:\n895             data = []\n896         if len(initial) != len(data):\n897             return True\n898         initial_set = {str(value) for value in initial}\n899         data_set = {str(value) for value in data}\n900         return data_set != initial_set\n901 \n902 \n903 class TypedMultipleChoiceField(MultipleChoiceField):\n904     def __init__(self, *, coerce=lambda val: val, **kwargs):\n905         self.coerce = coerce\n906         self.empty_value = kwargs.pop('empty_value', [])\n907         super().__init__(**kwargs)\n908 \n909     def _coerce(self, value):\n910         \"\"\"\n911         Validate that the values are in self.choices and can be coerced to the\n912         right type.\n913         \"\"\"\n914         if value == self.empty_value or value in self.empty_values:\n915             return self.empty_value\n916         new_value = []\n917         for choice in value:\n918             try:\n919                 new_value.append(self.coerce(choice))\n920             except (ValueError, TypeError, ValidationError):\n921                 raise ValidationError(\n922                     self.error_messages['invalid_choice'],\n923                     code='invalid_choice',\n924                     params={'value': choice},\n925                 )\n926         return new_value\n927 \n928     def clean(self, value):\n929         value = super().clean(value)\n930         return self._coerce(value)\n931 \n932     def validate(self, value):\n933         if value != self.empty_value:\n934             super().validate(value)\n935         elif self.required:\n936             raise ValidationError(self.error_messages['required'], code='required')\n937 \n938 \n939 class ComboField(Field):\n940     \"\"\"\n941     A Field whose clean() method calls multiple Field clean() methods.\n942     \"\"\"\n943     def __init__(self, fields, **kwargs):\n944         super().__init__(**kwargs)\n945         # Set 'required' to False on the individual fields, because the\n946         # required validation will be handled by ComboField, not by those\n947         # individual fields.\n948         for f in fields:\n949             f.required = False\n950         self.fields = fields\n951 \n952     def clean(self, value):\n953         \"\"\"\n954         Validate the given value against all of self.fields, which is a\n955         list of Field instances.\n956         \"\"\"\n957         super().clean(value)\n958         for field in self.fields:\n959             value = field.clean(value)\n960         return value\n961 \n962 \n963 class MultiValueField(Field):\n964     \"\"\"\n965     Aggregate the logic of multiple Fields.\n966 \n967     Its clean() method takes a \"decompressed\" list of values, which are then\n968     cleaned into a single value according to self.fields. Each value in\n969     this list is cleaned by the corresponding field -- the first value is\n970     cleaned by the first field, the second value is cleaned by the second\n971     field, etc. Once all fields are cleaned, the list of clean values is\n972     \"compressed\" into a single value.\n973 \n974     Subclasses should not have to implement clean(). Instead, they must\n975     implement compress(), which takes a list of valid values and returns a\n976     \"compressed\" version of those values -- a single value.\n977 \n978     You'll probably want to use this with MultiWidget.\n979     \"\"\"\n980     default_error_messages = {\n981         'invalid': _('Enter a list of values.'),\n982         'incomplete': _('Enter a complete value.'),\n983     }\n984 \n985     def __init__(self, fields, *, require_all_fields=True, **kwargs):\n986         self.require_all_fields = require_all_fields\n987         super().__init__(**kwargs)\n988         for f in fields:\n989             f.error_messages.setdefault('incomplete',\n990                                         self.error_messages['incomplete'])\n991             if self.disabled:\n992                 f.disabled = True\n993             if self.require_all_fields:\n994                 # Set 'required' to False on the individual fields, because the\n995                 # required validation will be handled by MultiValueField, not\n996                 # by those individual fields.\n997                 f.required = False\n998         self.fields = fields\n999 \n1000     def __deepcopy__(self, memo):\n1001         result = super().__deepcopy__(memo)\n1002         result.fields = tuple(x.__deepcopy__(memo) for x in self.fields)\n1003         return result\n1004 \n1005     def validate(self, value):\n1006         pass\n1007 \n1008     def clean(self, value):\n1009         \"\"\"\n1010         Validate every value in the given list. A value is validated against\n1011         the corresponding Field in self.fields.\n1012 \n1013         For example, if this MultiValueField was instantiated with\n1014         fields=(DateField(), TimeField()), clean() would call\n1015         DateField.clean(value[0]) and TimeField.clean(value[1]).\n1016         \"\"\"\n1017         clean_data = []\n1018         errors = []\n1019         if self.disabled and not isinstance(value, list):\n1020             value = self.widget.decompress(value)\n1021         if not value or isinstance(value, (list, tuple)):\n1022             if not value or not [v for v in value if v not in self.empty_values]:\n1023                 if self.required:\n1024                     raise ValidationError(self.error_messages['required'], code='required')\n1025                 else:\n1026                     return self.compress([])\n1027         else:\n1028             raise ValidationError(self.error_messages['invalid'], code='invalid')\n1029         for i, field in enumerate(self.fields):\n1030             try:\n1031                 field_value = value[i]\n1032             except IndexError:\n1033                 field_value = None\n1034             if field_value in self.empty_values:\n1035                 if self.require_all_fields:\n1036                     # Raise a 'required' error if the MultiValueField is\n1037                     # required and any field is empty.\n1038                     if self.required:\n1039                         raise ValidationError(self.error_messages['required'], code='required')\n1040                 elif field.required:\n1041                     # Otherwise, add an 'incomplete' error to the list of\n1042                     # collected errors and skip field cleaning, if a required\n1043                     # field is empty.\n1044                     if field.error_messages['incomplete'] not in errors:\n1045                         errors.append(field.error_messages['incomplete'])\n1046                     continue\n1047             try:\n1048                 clean_data.append(field.clean(field_value))\n1049             except ValidationError as e:\n1050                 # Collect all validation errors in a single list, which we'll\n1051                 # raise at the end of clean(), rather than raising a single\n1052                 # exception for the first error we encounter. Skip duplicates.\n1053                 errors.extend(m for m in e.error_list if m not in errors)\n1054         if errors:\n1055             raise ValidationError(errors)\n1056 \n1057         out = self.compress(clean_data)\n1058         self.validate(out)\n1059         self.run_validators(out)\n1060         return out\n1061 \n1062     def compress(self, data_list):\n1063         \"\"\"\n1064         Return a single value for the given list of values. The values can be\n1065         assumed to be valid.\n1066 \n1067         For example, if this MultiValueField was instantiated with\n1068         fields=(DateField(), TimeField()), this might return a datetime\n1069         object created by combining the date and time in data_list.\n1070         \"\"\"\n1071         raise NotImplementedError('Subclasses must implement this method.')\n1072 \n1073     def has_changed(self, initial, data):\n1074         if self.disabled:\n1075             return False\n1076         if initial is None:\n1077             initial = ['' for x in range(0, len(data))]\n1078         else:\n1079             if not isinstance(initial, list):\n1080                 initial = self.widget.decompress(initial)\n1081         for field, initial, data in zip(self.fields, initial, data):\n1082             try:\n1083                 initial = field.to_python(initial)\n1084             except ValidationError:\n1085                 return True\n1086             if field.has_changed(initial, data):\n1087                 return True\n1088         return False\n1089 \n1090 \n1091 class FilePathField(ChoiceField):\n1092     def __init__(self, path, *, match=None, recursive=False, allow_files=True,\n1093                  allow_folders=False, **kwargs):\n1094         self.path, self.match, self.recursive = path, match, recursive\n1095         self.allow_files, self.allow_folders = allow_files, allow_folders\n1096         super().__init__(choices=(), **kwargs)\n1097 \n1098         if self.required:\n1099             self.choices = []\n1100         else:\n1101             self.choices = [(\"\", \"---------\")]\n1102 \n1103         if self.match is not None:\n1104             self.match_re = re.compile(self.match)\n1105 \n1106         if recursive:\n1107             for root, dirs, files in sorted(os.walk(self.path)):\n1108                 if self.allow_files:\n1109                     for f in sorted(files):\n1110                         if self.match is None or self.match_re.search(f):\n1111                             f = os.path.join(root, f)\n1112                             self.choices.append((f, f.replace(path, \"\", 1)))\n1113                 if self.allow_folders:\n1114                     for f in sorted(dirs):\n1115                         if f == '__pycache__':\n1116                             continue\n1117                         if self.match is None or self.match_re.search(f):\n1118                             f = os.path.join(root, f)\n1119                             self.choices.append((f, f.replace(path, \"\", 1)))\n1120         else:\n1121             choices = []\n1122             for f in os.scandir(self.path):\n1123                 if f.name == '__pycache__':\n1124                     continue\n1125                 if (((self.allow_files and f.is_file()) or\n1126                         (self.allow_folders and f.is_dir())) and\n1127                         (self.match is None or self.match_re.search(f.name))):\n1128                     choices.append((f.path, f.name))\n1129             choices.sort(key=operator.itemgetter(1))\n1130             self.choices.extend(choices)\n1131 \n1132         self.widget.choices = self.choices\n1133 \n1134 \n1135 class SplitDateTimeField(MultiValueField):\n1136     widget = SplitDateTimeWidget\n1137     hidden_widget = SplitHiddenDateTimeWidget\n1138     default_error_messages = {\n1139         'invalid_date': _('Enter a valid date.'),\n1140         'invalid_time': _('Enter a valid time.'),\n1141     }\n1142 \n1143     def __init__(self, *, input_date_formats=None, input_time_formats=None, **kwargs):\n1144         errors = self.default_error_messages.copy()\n1145         if 'error_messages' in kwargs:\n1146             errors.update(kwargs['error_messages'])\n1147         localize = kwargs.get('localize', False)\n1148         fields = (\n1149             DateField(input_formats=input_date_formats,\n1150                       error_messages={'invalid': errors['invalid_date']},\n1151                       localize=localize),\n1152             TimeField(input_formats=input_time_formats,\n1153                       error_messages={'invalid': errors['invalid_time']},\n1154                       localize=localize),\n1155         )\n1156         super().__init__(fields, **kwargs)\n1157 \n1158     def compress(self, data_list):\n1159         if data_list:\n1160             # Raise a validation error if time or date is empty\n1161             # (possible if SplitDateTimeField has required=False).\n1162             if data_list[0] in self.empty_values:\n1163                 raise ValidationError(self.error_messages['invalid_date'], code='invalid_date')\n1164             if data_list[1] in self.empty_values:\n1165                 raise ValidationError(self.error_messages['invalid_time'], code='invalid_time')\n1166             result = datetime.datetime.combine(*data_list)\n1167             return from_current_timezone(result)\n1168         return None\n1169 \n1170 \n1171 class GenericIPAddressField(CharField):\n1172     def __init__(self, *, protocol='both', unpack_ipv4=False, **kwargs):\n1173         self.unpack_ipv4 = unpack_ipv4\n1174         self.default_validators = validators.ip_address_validators(protocol, unpack_ipv4)[0]\n1175         super().__init__(**kwargs)\n1176 \n1177     def to_python(self, value):\n1178         if value in self.empty_values:\n1179             return ''\n1180         value = value.strip()\n1181         if value and ':' in value:\n1182             return clean_ipv6_address(value, self.unpack_ipv4)\n1183         return value\n1184 \n1185 \n1186 class SlugField(CharField):\n1187     default_validators = [validators.validate_slug]\n1188 \n1189     def __init__(self, *, allow_unicode=False, **kwargs):\n1190         self.allow_unicode = allow_unicode\n1191         if self.allow_unicode:\n1192             self.default_validators = [validators.validate_unicode_slug]\n1193         super().__init__(**kwargs)\n1194 \n1195 \n1196 class UUIDField(CharField):\n1197     default_error_messages = {\n1198         'invalid': _('Enter a valid UUID.'),\n1199     }\n1200 \n1201     def prepare_value(self, value):\n1202         if isinstance(value, uuid.UUID):\n1203             return str(value)\n1204         return value\n1205 \n1206     def to_python(self, value):\n1207         value = super().to_python(value)\n1208         if value in self.empty_values:\n1209             return None\n1210         if not isinstance(value, uuid.UUID):\n1211             try:\n1212                 value = uuid.UUID(value)\n1213             except ValueError:\n1214                 raise ValidationError(self.error_messages['invalid'], code='invalid')\n1215         return value\n1216 \n1217 \n1218 class InvalidJSONInput(str):\n1219     pass\n1220 \n1221 \n1222 class JSONString(str):\n1223     pass\n1224 \n1225 \n1226 class JSONField(CharField):\n1227     default_error_messages = {\n1228         'invalid': _('Enter a valid JSON.'),\n1229     }\n1230     widget = Textarea\n1231 \n1232     def __init__(self, encoder=None, decoder=None, **kwargs):\n1233         self.encoder = encoder\n1234         self.decoder = decoder\n1235         super().__init__(**kwargs)\n1236 \n1237     def to_python(self, value):\n1238         if self.disabled:\n1239             return value\n1240         if value in self.empty_values:\n1241             return None\n1242         elif isinstance(value, (list, dict, int, float, JSONString)):\n1243             return value\n1244         try:\n1245             converted = json.loads(value, cls=self.decoder)\n1246         except json.JSONDecodeError:\n1247             raise ValidationError(\n1248                 self.error_messages['invalid'],\n1249                 code='invalid',\n1250                 params={'value': value},\n1251             )\n1252         if isinstance(converted, str):\n1253             return JSONString(converted)\n1254         else:\n1255             return converted\n1256 \n1257     def bound_data(self, data, initial):\n1258         if self.disabled:\n1259             return initial\n1260         try:\n1261             return json.loads(data, cls=self.decoder)\n1262         except json.JSONDecodeError:\n1263             return InvalidJSONInput(data)\n1264 \n1265     def prepare_value(self, value):\n1266         if isinstance(value, InvalidJSONInput):\n1267             return value\n1268         return json.dumps(value, cls=self.encoder)\n1269 \n1270     def has_changed(self, initial, data):\n1271         if super().has_changed(initial, data):\n1272             return True\n1273         # For purposes of seeing whether something has changed, True isn't the\n1274         # same as 1 and the order of keys doesn't matter.\n1275         return (\n1276             json.dumps(initial, sort_keys=True, cls=self.encoder) !=\n1277             json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder)\n1278         )\n",
        "intended_behavior": "In every method within form field classes that raises a ValidationError, modify the call to pass the field's value to the exception. This ensures that form validation errors can include the specific value that failed validation, aiding in debugging and user feedback."
    },
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/fields/__init__.py",
        "start": 1,
        "end": 2456,
        "class_name": null,
        "method_name": null,
        "code": "1 import collections.abc\n2 import copy\n3 import datetime\n4 import decimal\n5 import operator\n6 import uuid\n7 import warnings\n8 from base64 import b64decode, b64encode\n9 from functools import partialmethod, total_ordering\n10 \n11 from django import forms\n12 from django.apps import apps\n13 from django.conf import settings\n14 from django.core import checks, exceptions, validators\n15 from django.db import connection, connections, router\n16 from django.db.models.constants import LOOKUP_SEP\n17 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin\n18 from django.utils import timezone\n19 from django.utils.datastructures import DictWrapper\n20 from django.utils.dateparse import (\n21     parse_date, parse_datetime, parse_duration, parse_time,\n22 )\n23 from django.utils.duration import duration_microseconds, duration_string\n24 from django.utils.functional import Promise, cached_property\n25 from django.utils.ipv6 import clean_ipv6_address\n26 from django.utils.itercompat import is_iterable\n27 from django.utils.text import capfirst\n28 from django.utils.translation import gettext_lazy as _\n29 \n30 __all__ = [\n31     'AutoField', 'BLANK_CHOICE_DASH', 'BigAutoField', 'BigIntegerField',\n32     'BinaryField', 'BooleanField', 'CharField', 'CommaSeparatedIntegerField',\n33     'DateField', 'DateTimeField', 'DecimalField', 'DurationField',\n34     'EmailField', 'Empty', 'Field', 'FilePathField', 'FloatField',\n35     'GenericIPAddressField', 'IPAddressField', 'IntegerField', 'NOT_PROVIDED',\n36     'NullBooleanField', 'PositiveBigIntegerField', 'PositiveIntegerField',\n37     'PositiveSmallIntegerField', 'SlugField', 'SmallAutoField',\n38     'SmallIntegerField', 'TextField', 'TimeField', 'URLField', 'UUIDField',\n39 ]\n40 \n41 \n42 class Empty:\n43     pass\n44 \n45 \n46 class NOT_PROVIDED:\n47     pass\n48 \n49 \n50 # The values to use for \"blank\" in SelectFields. Will be appended to the start\n51 # of most \"choices\" lists.\n52 BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n53 \n54 \n55 def _load_field(app_label, model_name, field_name):\n56     return apps.get_model(app_label, model_name)._meta.get_field(field_name)\n57 \n58 \n59 # A guide to Field parameters:\n60 #\n61 #   * name:      The name of the field specified in the model.\n62 #   * attname:   The attribute to use on the model object. This is the same as\n63 #                \"name\", except in the case of ForeignKeys, where \"_id\" is\n64 #                appended.\n65 #   * db_column: The db_column specified in the model (or None).\n66 #   * column:    The database column for this field. This is the same as\n67 #                \"attname\", except if db_column is specified.\n68 #\n69 # Code that introspects values, or does other dynamic things, should use\n70 # attname. For example, this gets the primary key value of object \"obj\":\n71 #\n72 #     getattr(obj, opts.pk.attname)\n73 \n74 def _empty(of_cls):\n75     new = Empty()\n76     new.__class__ = of_cls\n77     return new\n78 \n79 \n80 def return_None():\n81     return None\n82 \n83 \n84 @total_ordering\n85 class Field(RegisterLookupMixin):\n86     \"\"\"Base class for all field types\"\"\"\n87 \n88     # Designates whether empty strings fundamentally are allowed at the\n89     # database level.\n90     empty_strings_allowed = True\n91     empty_values = list(validators.EMPTY_VALUES)\n92 \n93     # These track each time a Field instance is created. Used to retain order.\n94     # The auto_creation_counter is used for fields that Django implicitly\n95     # creates, creation_counter is used for all user-specified fields.\n96     creation_counter = 0\n97     auto_creation_counter = -1\n98     default_validators = []  # Default set of validators\n99     default_error_messages = {\n100         'invalid_choice': _('Value %(value)r is not a valid choice.'),\n101         'null': _('This field cannot be null.'),\n102         'blank': _('This field cannot be blank.'),\n103         'unique': _('%(model_name)s with this %(field_label)s '\n104                     'already exists.'),\n105         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.\n106         # Eg: \"Title must be unique for pub_date year\"\n107         'unique_for_date': _(\"%(field_label)s must be unique for \"\n108                              \"%(date_field_label)s %(lookup_type)s.\"),\n109     }\n110     system_check_deprecated_details = None\n111     system_check_removed_details = None\n112 \n113     # Field flags\n114     hidden = False\n115 \n116     many_to_many = None\n117     many_to_one = None\n118     one_to_many = None\n119     one_to_one = None\n120     related_model = None\n121 \n122     descriptor_class = DeferredAttribute\n123 \n124     # Generic field type description, usually overridden by subclasses\n125     def _description(self):\n126         return _('Field of type: %(field_type)s') % {\n127             'field_type': self.__class__.__name__\n128         }\n129     description = property(_description)\n130 \n131     def __init__(self, verbose_name=None, name=None, primary_key=False,\n132                  max_length=None, unique=False, blank=False, null=False,\n133                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n134                  serialize=True, unique_for_date=None, unique_for_month=None,\n135                  unique_for_year=None, choices=None, help_text='', db_column=None,\n136                  db_tablespace=None, auto_created=False, validators=(),\n137                  error_messages=None):\n138         self.name = name\n139         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n140         self._verbose_name = verbose_name  # Store original for deconstruction\n141         self.primary_key = primary_key\n142         self.max_length, self._unique = max_length, unique\n143         self.blank, self.null = blank, null\n144         self.remote_field = rel\n145         self.is_relation = self.remote_field is not None\n146         self.default = default\n147         self.editable = editable\n148         self.serialize = serialize\n149         self.unique_for_date = unique_for_date\n150         self.unique_for_month = unique_for_month\n151         self.unique_for_year = unique_for_year\n152         if isinstance(choices, collections.abc.Iterator):\n153             choices = list(choices)\n154         self.choices = choices\n155         self.help_text = help_text\n156         self.db_index = db_index\n157         self.db_column = db_column\n158         self._db_tablespace = db_tablespace\n159         self.auto_created = auto_created\n160 \n161         # Adjust the appropriate creation counter, and save our local copy.\n162         if auto_created:\n163             self.creation_counter = Field.auto_creation_counter\n164             Field.auto_creation_counter -= 1\n165         else:\n166             self.creation_counter = Field.creation_counter\n167             Field.creation_counter += 1\n168 \n169         self._validators = list(validators)  # Store for deconstruction later\n170 \n171         messages = {}\n172         for c in reversed(self.__class__.__mro__):\n173             messages.update(getattr(c, 'default_error_messages', {}))\n174         messages.update(error_messages or {})\n175         self._error_messages = error_messages  # Store for deconstruction later\n176         self.error_messages = messages\n177 \n178     def __str__(self):\n179         \"\"\"\n180         Return \"app_label.model_label.field_name\" for fields attached to\n181         models.\n182         \"\"\"\n183         if not hasattr(self, 'model'):\n184             return super().__str__()\n185         model = self.model\n186         app = model._meta.app_label\n187         return '%s.%s.%s' % (app, model._meta.object_name, self.name)\n188 \n189     def __repr__(self):\n190         \"\"\"Display the module, class, and name of the field.\"\"\"\n191         path = '%s.%s' % (self.__class__.__module__, self.__class__.__qualname__)\n192         name = getattr(self, 'name', None)\n193         if name is not None:\n194             return '<%s: %s>' % (path, name)\n195         return '<%s>' % path\n196 \n197     def check(self, **kwargs):\n198         return [\n199             *self._check_field_name(),\n200             *self._check_choices(),\n201             *self._check_db_index(),\n202             *self._check_null_allowed_for_primary_keys(),\n203             *self._check_backend_specific_checks(**kwargs),\n204             *self._check_validators(),\n205             *self._check_deprecation_details(),\n206         ]\n207 \n208     def _check_field_name(self):\n209         \"\"\"\n210         Check if field name is valid, i.e. 1) does not end with an\n211         underscore, 2) does not contain \"__\" and 3) is not \"pk\".\n212         \"\"\"\n213         if self.name.endswith('_'):\n214             return [\n215                 checks.Error(\n216                     'Field names must not end with an underscore.',\n217                     obj=self,\n218                     id='fields.E001',\n219                 )\n220             ]\n221         elif LOOKUP_SEP in self.name:\n222             return [\n223                 checks.Error(\n224                     'Field names must not contain \"%s\".' % LOOKUP_SEP,\n225                     obj=self,\n226                     id='fields.E002',\n227                 )\n228             ]\n229         elif self.name == 'pk':\n230             return [\n231                 checks.Error(\n232                     \"'pk' is a reserved word that cannot be used as a field name.\",\n233                     obj=self,\n234                     id='fields.E003',\n235                 )\n236             ]\n237         else:\n238             return []\n239 \n240     @classmethod\n241     def _choices_is_value(cls, value):\n242         return isinstance(value, (str, Promise)) or not is_iterable(value)\n243 \n244     def _check_choices(self):\n245         if not self.choices:\n246             return []\n247 \n248         if not is_iterable(self.choices) or isinstance(self.choices, str):\n249             return [\n250                 checks.Error(\n251                     \"'choices' must be an iterable (e.g., a list or tuple).\",\n252                     obj=self,\n253                     id='fields.E004',\n254                 )\n255             ]\n256 \n257         choice_max_length = 0\n258         # Expect [group_name, [value, display]]\n259         for choices_group in self.choices:\n260             try:\n261                 group_name, group_choices = choices_group\n262             except (TypeError, ValueError):\n263                 # Containing non-pairs\n264                 break\n265             try:\n266                 if not all(\n267                     self._choices_is_value(value) and self._choices_is_value(human_name)\n268                     for value, human_name in group_choices\n269                 ):\n270                     break\n271                 if self.max_length is not None and group_choices:\n272                     choice_max_length = max([\n273                         choice_max_length,\n274                         *(len(value) for value, _ in group_choices if isinstance(value, str)),\n275                     ])\n276             except (TypeError, ValueError):\n277                 # No groups, choices in the form [value, display]\n278                 value, human_name = group_name, group_choices\n279                 if not self._choices_is_value(value) or not self._choices_is_value(human_name):\n280                     break\n281                 if self.max_length is not None and isinstance(value, str):\n282                     choice_max_length = max(choice_max_length, len(value))\n283 \n284             # Special case: choices=['ab']\n285             if isinstance(choices_group, str):\n286                 break\n287         else:\n288             if self.max_length is not None and choice_max_length > self.max_length:\n289                 return [\n290                     checks.Error(\n291                         \"'max_length' is too small to fit the longest value \"\n292                         \"in 'choices' (%d characters).\" % choice_max_length,\n293                         obj=self,\n294                         id='fields.E009',\n295                     ),\n296                 ]\n297             return []\n298 \n299         return [\n300             checks.Error(\n301                 \"'choices' must be an iterable containing \"\n302                 \"(actual value, human readable name) tuples.\",\n303                 obj=self,\n304                 id='fields.E005',\n305             )\n306         ]\n307 \n308     def _check_db_index(self):\n309         if self.db_index not in (None, True, False):\n310             return [\n311                 checks.Error(\n312                     \"'db_index' must be None, True or False.\",\n313                     obj=self,\n314                     id='fields.E006',\n315                 )\n316             ]\n317         else:\n318             return []\n319 \n320     def _check_null_allowed_for_primary_keys(self):\n321         if (self.primary_key and self.null and\n322                 not connection.features.interprets_empty_strings_as_nulls):\n323             # We cannot reliably check this for backends like Oracle which\n324             # consider NULL and '' to be equal (and thus set up\n325             # character-based fields a little differently).\n326             return [\n327                 checks.Error(\n328                     'Primary keys must not have null=True.',\n329                     hint=('Set null=False on the field, or '\n330                           'remove primary_key=True argument.'),\n331                     obj=self,\n332                     id='fields.E007',\n333                 )\n334             ]\n335         else:\n336             return []\n337 \n338     def _check_backend_specific_checks(self, databases=None, **kwargs):\n339         if databases is None:\n340             return []\n341         app_label = self.model._meta.app_label\n342         errors = []\n343         for alias in databases:\n344             if router.allow_migrate(alias, app_label, model_name=self.model._meta.model_name):\n345                 errors.extend(connections[alias].validation.check_field(self, **kwargs))\n346         return errors\n347 \n348     def _check_validators(self):\n349         errors = []\n350         for i, validator in enumerate(self.validators):\n351             if not callable(validator):\n352                 errors.append(\n353                     checks.Error(\n354                         \"All 'validators' must be callable.\",\n355                         hint=(\n356                             \"validators[{i}] ({repr}) isn't a function or \"\n357                             \"instance of a validator class.\".format(\n358                                 i=i, repr=repr(validator),\n359                             )\n360                         ),\n361                         obj=self,\n362                         id='fields.E008',\n363                     )\n364                 )\n365         return errors\n366 \n367     def _check_deprecation_details(self):\n368         if self.system_check_removed_details is not None:\n369             return [\n370                 checks.Error(\n371                     self.system_check_removed_details.get(\n372                         'msg',\n373                         '%s has been removed except for support in historical '\n374                         'migrations.' % self.__class__.__name__\n375                     ),\n376                     hint=self.system_check_removed_details.get('hint'),\n377                     obj=self,\n378                     id=self.system_check_removed_details.get('id', 'fields.EXXX'),\n379                 )\n380             ]\n381         elif self.system_check_deprecated_details is not None:\n382             return [\n383                 checks.Warning(\n384                     self.system_check_deprecated_details.get(\n385                         'msg',\n386                         '%s has been deprecated.' % self.__class__.__name__\n387                     ),\n388                     hint=self.system_check_deprecated_details.get('hint'),\n389                     obj=self,\n390                     id=self.system_check_deprecated_details.get('id', 'fields.WXXX'),\n391                 )\n392             ]\n393         return []\n394 \n395     def get_col(self, alias, output_field=None):\n396         if output_field is None:\n397             output_field = self\n398         if alias != self.model._meta.db_table or output_field != self:\n399             from django.db.models.expressions import Col\n400             return Col(alias, self, output_field)\n401         else:\n402             return self.cached_col\n403 \n404     @cached_property\n405     def cached_col(self):\n406         from django.db.models.expressions import Col\n407         return Col(self.model._meta.db_table, self)\n408 \n409     def select_format(self, compiler, sql, params):\n410         \"\"\"\n411         Custom format for select clauses. For example, GIS columns need to be\n412         selected as AsText(table.col) on MySQL as the table.col data can't be\n413         used by Django.\n414         \"\"\"\n415         return sql, params\n416 \n417     def deconstruct(self):\n418         \"\"\"\n419         Return enough information to recreate the field as a 4-tuple:\n420 \n421          * The name of the field on the model, if contribute_to_class() has\n422            been run.\n423          * The import path of the field, including the class:e.g.\n424            django.db.models.IntegerField This should be the most portable\n425            version, so less specific may be better.\n426          * A list of positional arguments.\n427          * A dict of keyword arguments.\n428 \n429         Note that the positional or keyword arguments must contain values of\n430         the following types (including inner values of collection types):\n431 \n432          * None, bool, str, int, float, complex, set, frozenset, list, tuple,\n433            dict\n434          * UUID\n435          * datetime.datetime (naive), datetime.date\n436          * top-level classes, top-level functions - will be referenced by their\n437            full import path\n438          * Storage instances - these have their own deconstruct() method\n439 \n440         This is because the values here must be serialized into a text format\n441         (possibly new Python code, possibly JSON) and these are the only types\n442         with encoding handlers defined.\n443 \n444         There's no need to return the exact way the field was instantiated this\n445         time, just ensure that the resulting field is the same - prefer keyword\n446         arguments over positional ones, and omit parameters with their default\n447         values.\n448         \"\"\"\n449         # Short-form way of fetching all the default parameters\n450         keywords = {}\n451         possibles = {\n452             \"verbose_name\": None,\n453             \"primary_key\": False,\n454             \"max_length\": None,\n455             \"unique\": False,\n456             \"blank\": False,\n457             \"null\": False,\n458             \"db_index\": False,\n459             \"default\": NOT_PROVIDED,\n460             \"editable\": True,\n461             \"serialize\": True,\n462             \"unique_for_date\": None,\n463             \"unique_for_month\": None,\n464             \"unique_for_year\": None,\n465             \"choices\": None,\n466             \"help_text\": '',\n467             \"db_column\": None,\n468             \"db_tablespace\": None,\n469             \"auto_created\": False,\n470             \"validators\": [],\n471             \"error_messages\": None,\n472         }\n473         attr_overrides = {\n474             \"unique\": \"_unique\",\n475             \"error_messages\": \"_error_messages\",\n476             \"validators\": \"_validators\",\n477             \"verbose_name\": \"_verbose_name\",\n478             \"db_tablespace\": \"_db_tablespace\",\n479         }\n480         equals_comparison = {\"choices\", \"validators\"}\n481         for name, default in possibles.items():\n482             value = getattr(self, attr_overrides.get(name, name))\n483             # Unroll anything iterable for choices into a concrete list\n484             if name == \"choices\" and isinstance(value, collections.abc.Iterable):\n485                 value = list(value)\n486             # Do correct kind of comparison\n487             if name in equals_comparison:\n488                 if value != default:\n489                     keywords[name] = value\n490             else:\n491                 if value is not default:\n492                     keywords[name] = value\n493         # Work out path - we shorten it for known Django core fields\n494         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n495         if path.startswith(\"django.db.models.fields.related\"):\n496             path = path.replace(\"django.db.models.fields.related\", \"django.db.models\")\n497         elif path.startswith(\"django.db.models.fields.files\"):\n498             path = path.replace(\"django.db.models.fields.files\", \"django.db.models\")\n499         elif path.startswith('django.db.models.fields.json'):\n500             path = path.replace('django.db.models.fields.json', 'django.db.models')\n501         elif path.startswith(\"django.db.models.fields.proxy\"):\n502             path = path.replace(\"django.db.models.fields.proxy\", \"django.db.models\")\n503         elif path.startswith(\"django.db.models.fields\"):\n504             path = path.replace(\"django.db.models.fields\", \"django.db.models\")\n505         # Return basic info - other fields should override this.\n506         return (self.name, path, [], keywords)\n507 \n508     def clone(self):\n509         \"\"\"\n510         Uses deconstruct() to clone a new copy of this Field.\n511         Will not preserve any class attachments/attribute names.\n512         \"\"\"\n513         name, path, args, kwargs = self.deconstruct()\n514         return self.__class__(*args, **kwargs)\n515 \n516     def __eq__(self, other):\n517         # Needed for @total_ordering\n518         if isinstance(other, Field):\n519             return self.creation_counter == other.creation_counter\n520         return NotImplemented\n521 \n522     def __lt__(self, other):\n523         # This is needed because bisect does not take a comparison function.\n524         if isinstance(other, Field):\n525             return self.creation_counter < other.creation_counter\n526         return NotImplemented\n527 \n528     def __hash__(self):\n529         return hash(self.creation_counter)\n530 \n531     def __deepcopy__(self, memodict):\n532         # We don't have to deepcopy very much here, since most things are not\n533         # intended to be altered after initial creation.\n534         obj = copy.copy(self)\n535         if self.remote_field:\n536             obj.remote_field = copy.copy(self.remote_field)\n537             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:\n538                 obj.remote_field.field = obj\n539         memodict[id(self)] = obj\n540         return obj\n541 \n542     def __copy__(self):\n543         # We need to avoid hitting __reduce__, so define this\n544         # slightly weird copy construct.\n545         obj = Empty()\n546         obj.__class__ = self.__class__\n547         obj.__dict__ = self.__dict__.copy()\n548         return obj\n549 \n550     def __reduce__(self):\n551         \"\"\"\n552         Pickling should return the model._meta.fields instance of the field,\n553         not a new copy of that field. So, use the app registry to load the\n554         model and then the field back.\n555         \"\"\"\n556         if not hasattr(self, 'model'):\n557             # Fields are sometimes used without attaching them to models (for\n558             # example in aggregation). In this case give back a plain field\n559             # instance. The code below will create a new empty instance of\n560             # class self.__class__, then update its dict with self.__dict__\n561             # values - so, this is very close to normal pickle.\n562             state = self.__dict__.copy()\n563             # The _get_default cached_property can't be pickled due to lambda\n564             # usage.\n565             state.pop('_get_default', None)\n566             return _empty, (self.__class__,), state\n567         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,\n568                              self.name)\n569 \n570     def get_pk_value_on_save(self, instance):\n571         \"\"\"\n572         Hook to generate new PK values on save. This method is called when\n573         saving instances with no primary key value set. If this method returns\n574         something else than None, then the returned value is used when saving\n575         the new instance.\n576         \"\"\"\n577         if self.default:\n578             return self.get_default()\n579         return None\n580 \n581     def to_python(self, value):\n582         \"\"\"\n583         Convert the input value into the expected Python data type, raising\n584         django.core.exceptions.ValidationError if the data can't be converted.\n585         Return the converted value. Subclasses should override this.\n586         \"\"\"\n587         return value\n588 \n589     @cached_property\n590     def validators(self):\n591         \"\"\"\n592         Some validators can't be created at field initialization time.\n593         This method provides a way to delay their creation until required.\n594         \"\"\"\n595         return [*self.default_validators, *self._validators]\n596 \n597     def run_validators(self, value):\n598         if value in self.empty_values:\n599             return\n600 \n601         errors = []\n602         for v in self.validators:\n603             try:\n604                 v(value)\n605             except exceptions.ValidationError as e:\n606                 if hasattr(e, 'code') and e.code in self.error_messages:\n607                     e.message = self.error_messages[e.code]\n608                 errors.extend(e.error_list)\n609 \n610         if errors:\n611             raise exceptions.ValidationError(errors)\n612 \n613     def validate(self, value, model_instance):\n614         \"\"\"\n615         Validate value and raise ValidationError if necessary. Subclasses\n616         should override this to provide validation logic.\n617         \"\"\"\n618         if not self.editable:\n619             # Skip validation for non-editable fields.\n620             return\n621 \n622         if self.choices is not None and value not in self.empty_values:\n623             for option_key, option_value in self.choices:\n624                 if isinstance(option_value, (list, tuple)):\n625                     # This is an optgroup, so look inside the group for\n626                     # options.\n627                     for optgroup_key, optgroup_value in option_value:\n628                         if value == optgroup_key:\n629                             return\n630                 elif value == option_key:\n631                     return\n632             raise exceptions.ValidationError(\n633                 self.error_messages['invalid_choice'],\n634                 code='invalid_choice',\n635                 params={'value': value},\n636             )\n637 \n638         if value is None and not self.null:\n639             raise exceptions.ValidationError(self.error_messages['null'], code='null')\n640 \n641         if not self.blank and value in self.empty_values:\n642             raise exceptions.ValidationError(self.error_messages['blank'], code='blank')\n643 \n644     def clean(self, value, model_instance):\n645         \"\"\"\n646         Convert the value's type and run validation. Validation errors\n647         from to_python() and validate() are propagated. Return the correct\n648         value if no error is raised.\n649         \"\"\"\n650         value = self.to_python(value)\n651         self.validate(value, model_instance)\n652         self.run_validators(value)\n653         return value\n654 \n655     def db_type_parameters(self, connection):\n656         return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')\n657 \n658     def db_check(self, connection):\n659         \"\"\"\n660         Return the database column check constraint for this field, for the\n661         provided connection. Works the same way as db_type() for the case that\n662         get_internal_type() does not map to a preexisting model field.\n663         \"\"\"\n664         data = self.db_type_parameters(connection)\n665         try:\n666             return connection.data_type_check_constraints[self.get_internal_type()] % data\n667         except KeyError:\n668             return None\n669 \n670     def db_type(self, connection):\n671         \"\"\"\n672         Return the database column data type for this field, for the provided\n673         connection.\n674         \"\"\"\n675         # The default implementation of this method looks at the\n676         # backend-specific data_types dictionary, looking up the field by its\n677         # \"internal type\".\n678         #\n679         # A Field class can implement the get_internal_type() method to specify\n680         # which *preexisting* Django Field class it's most similar to -- i.e.,\n681         # a custom field might be represented by a TEXT column type, which is\n682         # the same as the TextField Django field type, which means the custom\n683         # field's get_internal_type() returns 'TextField'.\n684         #\n685         # But the limitation of the get_internal_type() / data_types approach\n686         # is that it cannot handle database column types that aren't already\n687         # mapped to one of the built-in Django field types. In this case, you\n688         # can implement db_type() instead of get_internal_type() to specify\n689         # exactly which wacky database column type you want to use.\n690         data = self.db_type_parameters(connection)\n691         try:\n692             return connection.data_types[self.get_internal_type()] % data\n693         except KeyError:\n694             return None\n695 \n696     def rel_db_type(self, connection):\n697         \"\"\"\n698         Return the data type that a related field pointing to this field should\n699         use. For example, this method is called by ForeignKey and OneToOneField\n700         to determine its data type.\n701         \"\"\"\n702         return self.db_type(connection)\n703 \n704     def cast_db_type(self, connection):\n705         \"\"\"Return the data type to use in the Cast() function.\"\"\"\n706         db_type = connection.ops.cast_data_types.get(self.get_internal_type())\n707         if db_type:\n708             return db_type % self.db_type_parameters(connection)\n709         return self.db_type(connection)\n710 \n711     def db_parameters(self, connection):\n712         \"\"\"\n713         Extension of db_type(), providing a range of different return values\n714         (type, checks). This will look at db_type(), allowing custom model\n715         fields to override it.\n716         \"\"\"\n717         type_string = self.db_type(connection)\n718         check_string = self.db_check(connection)\n719         return {\n720             \"type\": type_string,\n721             \"check\": check_string,\n722         }\n723 \n724     def db_type_suffix(self, connection):\n725         return connection.data_types_suffix.get(self.get_internal_type())\n726 \n727     def get_db_converters(self, connection):\n728         if hasattr(self, 'from_db_value'):\n729             return [self.from_db_value]\n730         return []\n731 \n732     @property\n733     def unique(self):\n734         return self._unique or self.primary_key\n735 \n736     @property\n737     def db_tablespace(self):\n738         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE\n739 \n740     @property\n741     def db_returning(self):\n742         \"\"\"\n743         Private API intended only to be used by Django itself. Currently only\n744         the PostgreSQL backend supports returning multiple fields on a model.\n745         \"\"\"\n746         return False\n747 \n748     def set_attributes_from_name(self, name):\n749         self.name = self.name or name\n750         self.attname, self.column = self.get_attname_column()\n751         self.concrete = self.column is not None\n752         if self.verbose_name is None and self.name:\n753             self.verbose_name = self.name.replace('_', ' ')\n754 \n755     def contribute_to_class(self, cls, name, private_only=False):\n756         \"\"\"\n757         Register the field with the model class it belongs to.\n758 \n759         If private_only is True, create a separate instance of this field\n760         for every subclass of cls, even if cls is not an abstract model.\n761         \"\"\"\n762         self.set_attributes_from_name(name)\n763         self.model = cls\n764         cls._meta.add_field(self, private=private_only)\n765         if self.column:\n766             # Don't override classmethods with the descriptor. This means that\n767             # if you have a classmethod and a field with the same name, then\n768             # such fields can't be deferred (we don't have a check for this).\n769             if not getattr(cls, self.attname, None):\n770                 setattr(cls, self.attname, self.descriptor_class(self))\n771         if self.choices is not None:\n772             # Don't override a get_FOO_display() method defined explicitly on\n773             # this class, but don't check methods derived from inheritance, to\n774             # allow overriding inherited choices. For more complex inheritance\n775             # structures users should override contribute_to_class().\n776             if 'get_%s_display' % self.name not in cls.__dict__:\n777                 setattr(\n778                     cls,\n779                     'get_%s_display' % self.name,\n780                     partialmethod(cls._get_FIELD_display, field=self),\n781                 )\n782 \n783     def get_filter_kwargs_for_object(self, obj):\n784         \"\"\"\n785         Return a dict that when passed as kwargs to self.model.filter(), would\n786         yield all instances having the same value for this field as obj has.\n787         \"\"\"\n788         return {self.name: getattr(obj, self.attname)}\n789 \n790     def get_attname(self):\n791         return self.name\n792 \n793     def get_attname_column(self):\n794         attname = self.get_attname()\n795         column = self.db_column or attname\n796         return attname, column\n797 \n798     def get_internal_type(self):\n799         return self.__class__.__name__\n800 \n801     def pre_save(self, model_instance, add):\n802         \"\"\"Return field's value just before saving.\"\"\"\n803         return getattr(model_instance, self.attname)\n804 \n805     def get_prep_value(self, value):\n806         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n807         if isinstance(value, Promise):\n808             value = value._proxy____cast()\n809         return value\n810 \n811     def get_db_prep_value(self, value, connection, prepared=False):\n812         \"\"\"\n813         Return field's value prepared for interacting with the database backend.\n814 \n815         Used by the default implementations of get_db_prep_save().\n816         \"\"\"\n817         if not prepared:\n818             value = self.get_prep_value(value)\n819         return value\n820 \n821     def get_db_prep_save(self, value, connection):\n822         \"\"\"Return field's value prepared for saving into a database.\"\"\"\n823         return self.get_db_prep_value(value, connection=connection, prepared=False)\n824 \n825     def has_default(self):\n826         \"\"\"Return a boolean of whether this field has a default value.\"\"\"\n827         return self.default is not NOT_PROVIDED\n828 \n829     def get_default(self):\n830         \"\"\"Return the default value for this field.\"\"\"\n831         return self._get_default()\n832 \n833     @cached_property\n834     def _get_default(self):\n835         if self.has_default():\n836             if callable(self.default):\n837                 return self.default\n838             return lambda: self.default\n839 \n840         if not self.empty_strings_allowed or self.null and not connection.features.interprets_empty_strings_as_nulls:\n841             return return_None\n842         return str  # return empty string\n843 \n844     def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH, limit_choices_to=None, ordering=()):\n845         \"\"\"\n846         Return choices with a default blank choices included, for use\n847         as <select> choices for this field.\n848         \"\"\"\n849         if self.choices is not None:\n850             choices = list(self.choices)\n851             if include_blank:\n852                 blank_defined = any(choice in ('', None) for choice, _ in self.flatchoices)\n853                 if not blank_defined:\n854                     choices = blank_choice + choices\n855             return choices\n856         rel_model = self.remote_field.model\n857         limit_choices_to = limit_choices_to or self.get_limit_choices_to()\n858         choice_func = operator.attrgetter(\n859             self.remote_field.get_related_field().attname\n860             if hasattr(self.remote_field, 'get_related_field')\n861             else 'pk'\n862         )\n863         qs = rel_model._default_manager.complex_filter(limit_choices_to)\n864         if ordering:\n865             qs = qs.order_by(*ordering)\n866         return (blank_choice if include_blank else []) + [\n867             (choice_func(x), str(x)) for x in qs\n868         ]\n869 \n870     def value_to_string(self, obj):\n871         \"\"\"\n872         Return a string value of this field from the passed obj.\n873         This is used by the serialization framework.\n874         \"\"\"\n875         return str(self.value_from_object(obj))\n876 \n877     def _get_flatchoices(self):\n878         \"\"\"Flattened version of choices tuple.\"\"\"\n879         if self.choices is None:\n880             return []\n881         flat = []\n882         for choice, value in self.choices:\n883             if isinstance(value, (list, tuple)):\n884                 flat.extend(value)\n885             else:\n886                 flat.append((choice, value))\n887         return flat\n888     flatchoices = property(_get_flatchoices)\n889 \n890     def save_form_data(self, instance, data):\n891         setattr(instance, self.name, data)\n892 \n893     def formfield(self, form_class=None, choices_form_class=None, **kwargs):\n894         \"\"\"Return a django.forms.Field instance for this field.\"\"\"\n895         defaults = {\n896             'required': not self.blank,\n897             'label': capfirst(self.verbose_name),\n898             'help_text': self.help_text,\n899         }\n900         if self.has_default():\n901             if callable(self.default):\n902                 defaults['initial'] = self.default\n903                 defaults['show_hidden_initial'] = True\n904             else:\n905                 defaults['initial'] = self.get_default()\n906         if self.choices is not None:\n907             # Fields with choices get special treatment.\n908             include_blank = (self.blank or\n909                              not (self.has_default() or 'initial' in kwargs))\n910             defaults['choices'] = self.get_choices(include_blank=include_blank)\n911             defaults['coerce'] = self.to_python\n912             if self.null:\n913                 defaults['empty_value'] = None\n914             if choices_form_class is not None:\n915                 form_class = choices_form_class\n916             else:\n917                 form_class = forms.TypedChoiceField\n918             # Many of the subclass-specific formfield arguments (min_value,\n919             # max_value) don't apply for choice fields, so be sure to only pass\n920             # the values that TypedChoiceField will understand.\n921             for k in list(kwargs):\n922                 if k not in ('coerce', 'empty_value', 'choices', 'required',\n923                              'widget', 'label', 'initial', 'help_text',\n924                              'error_messages', 'show_hidden_initial', 'disabled'):\n925                     del kwargs[k]\n926         defaults.update(kwargs)\n927         if form_class is None:\n928             form_class = forms.CharField\n929         return form_class(**defaults)\n930 \n931     def value_from_object(self, obj):\n932         \"\"\"Return the value of this field in the given model instance.\"\"\"\n933         return getattr(obj, self.attname)\n934 \n935 \n936 class BooleanField(Field):\n937     empty_strings_allowed = False\n938     default_error_messages = {\n939         'invalid': _('\u201c%(value)s\u201d value must be either True or False.'),\n940         'invalid_nullable': _('\u201c%(value)s\u201d value must be either True, False, or None.'),\n941     }\n942     description = _(\"Boolean (Either True or False)\")\n943 \n944     def get_internal_type(self):\n945         return \"BooleanField\"\n946 \n947     def to_python(self, value):\n948         if self.null and value in self.empty_values:\n949             return None\n950         if value in (True, False):\n951             # 1/0 are equal to True/False. bool() converts former to latter.\n952             return bool(value)\n953         if value in ('t', 'True', '1'):\n954             return True\n955         if value in ('f', 'False', '0'):\n956             return False\n957         raise exceptions.ValidationError(\n958             self.error_messages['invalid_nullable' if self.null else 'invalid'],\n959             code='invalid',\n960             params={'value': value},\n961         )\n962 \n963     def get_prep_value(self, value):\n964         value = super().get_prep_value(value)\n965         if value is None:\n966             return None\n967         return self.to_python(value)\n968 \n969     def formfield(self, **kwargs):\n970         if self.choices is not None:\n971             include_blank = not (self.has_default() or 'initial' in kwargs)\n972             defaults = {'choices': self.get_choices(include_blank=include_blank)}\n973         else:\n974             form_class = forms.NullBooleanField if self.null else forms.BooleanField\n975             # In HTML checkboxes, 'required' means \"must be checked\" which is\n976             # different from the choices case (\"must select some value\").\n977             # required=False allows unchecked checkboxes.\n978             defaults = {'form_class': form_class, 'required': False}\n979         return super().formfield(**{**defaults, **kwargs})\n980 \n981 \n982 class CharField(Field):\n983     description = _(\"String (up to %(max_length)s)\")\n984 \n985     def __init__(self, *args, **kwargs):\n986         super().__init__(*args, **kwargs)\n987         self.validators.append(validators.MaxLengthValidator(self.max_length))\n988 \n989     def check(self, **kwargs):\n990         return [\n991             *super().check(**kwargs),\n992             *self._check_max_length_attribute(**kwargs),\n993         ]\n994 \n995     def _check_max_length_attribute(self, **kwargs):\n996         if self.max_length is None:\n997             return [\n998                 checks.Error(\n999                     \"CharFields must define a 'max_length' attribute.\",\n1000                     obj=self,\n1001                     id='fields.E120',\n1002                 )\n1003             ]\n1004         elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n1005                 self.max_length <= 0):\n1006             return [\n1007                 checks.Error(\n1008                     \"'max_length' must be a positive integer.\",\n1009                     obj=self,\n1010                     id='fields.E121',\n1011                 )\n1012             ]\n1013         else:\n1014             return []\n1015 \n1016     def cast_db_type(self, connection):\n1017         if self.max_length is None:\n1018             return connection.ops.cast_char_field_without_max_length\n1019         return super().cast_db_type(connection)\n1020 \n1021     def get_internal_type(self):\n1022         return \"CharField\"\n1023 \n1024     def to_python(self, value):\n1025         if isinstance(value, str) or value is None:\n1026             return value\n1027         return str(value)\n1028 \n1029     def get_prep_value(self, value):\n1030         value = super().get_prep_value(value)\n1031         return self.to_python(value)\n1032 \n1033     def formfield(self, **kwargs):\n1034         # Passing max_length to forms.CharField means that the value's length\n1035         # will be validated twice. This is considered acceptable since we want\n1036         # the value in the form field (to pass into widget for example).\n1037         defaults = {'max_length': self.max_length}\n1038         # TODO: Handle multiple backends with different feature flags.\n1039         if self.null and not connection.features.interprets_empty_strings_as_nulls:\n1040             defaults['empty_value'] = None\n1041         defaults.update(kwargs)\n1042         return super().formfield(**defaults)\n1043 \n1044 \n1045 class CommaSeparatedIntegerField(CharField):\n1046     default_validators = [validators.validate_comma_separated_integer_list]\n1047     description = _(\"Comma-separated integers\")\n1048     system_check_removed_details = {\n1049         'msg': (\n1050             'CommaSeparatedIntegerField is removed except for support in '\n1051             'historical migrations.'\n1052         ),\n1053         'hint': (\n1054             'Use CharField(validators=[validate_comma_separated_integer_list]) '\n1055             'instead.'\n1056         ),\n1057         'id': 'fields.E901',\n1058     }\n1059 \n1060 \n1061 class DateTimeCheckMixin:\n1062 \n1063     def check(self, **kwargs):\n1064         return [\n1065             *super().check(**kwargs),\n1066             *self._check_mutually_exclusive_options(),\n1067             *self._check_fix_default_value(),\n1068         ]\n1069 \n1070     def _check_mutually_exclusive_options(self):\n1071         # auto_now, auto_now_add, and default are mutually exclusive\n1072         # options. The use of more than one of these options together\n1073         # will trigger an Error\n1074         mutually_exclusive_options = [self.auto_now_add, self.auto_now, self.has_default()]\n1075         enabled_options = [option not in (None, False) for option in mutually_exclusive_options].count(True)\n1076         if enabled_options > 1:\n1077             return [\n1078                 checks.Error(\n1079                     \"The options auto_now, auto_now_add, and default \"\n1080                     \"are mutually exclusive. Only one of these options \"\n1081                     \"may be present.\",\n1082                     obj=self,\n1083                     id='fields.E160',\n1084                 )\n1085             ]\n1086         else:\n1087             return []\n1088 \n1089     def _check_fix_default_value(self):\n1090         return []\n1091 \n1092 \n1093 class DateField(DateTimeCheckMixin, Field):\n1094     empty_strings_allowed = False\n1095     default_error_messages = {\n1096         'invalid': _('\u201c%(value)s\u201d value has an invalid date format. It must be '\n1097                      'in YYYY-MM-DD format.'),\n1098         'invalid_date': _('\u201c%(value)s\u201d value has the correct format (YYYY-MM-DD) '\n1099                           'but it is an invalid date.'),\n1100     }\n1101     description = _(\"Date (without time)\")\n1102 \n1103     def __init__(self, verbose_name=None, name=None, auto_now=False,\n1104                  auto_now_add=False, **kwargs):\n1105         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n1106         if auto_now or auto_now_add:\n1107             kwargs['editable'] = False\n1108             kwargs['blank'] = True\n1109         super().__init__(verbose_name, name, **kwargs)\n1110 \n1111     def _check_fix_default_value(self):\n1112         \"\"\"\n1113         Warn that using an actual date or datetime value is probably wrong;\n1114         it's only evaluated on server startup.\n1115         \"\"\"\n1116         if not self.has_default():\n1117             return []\n1118 \n1119         now = timezone.now()\n1120         if not timezone.is_naive(now):\n1121             now = timezone.make_naive(now, timezone.utc)\n1122         value = self.default\n1123         if isinstance(value, datetime.datetime):\n1124             if not timezone.is_naive(value):\n1125                 value = timezone.make_naive(value, timezone.utc)\n1126             value = value.date()\n1127         elif isinstance(value, datetime.date):\n1128             # Nothing to do, as dates don't have tz information\n1129             pass\n1130         else:\n1131             # No explicit date / datetime value -- no checks necessary\n1132             return []\n1133         offset = datetime.timedelta(days=1)\n1134         lower = (now - offset).date()\n1135         upper = (now + offset).date()\n1136         if lower <= value <= upper:\n1137             return [\n1138                 checks.Warning(\n1139                     'Fixed default value provided.',\n1140                     hint='It seems you set a fixed date / time / datetime '\n1141                          'value as default for this field. This may not be '\n1142                          'what you want. If you want to have the current date '\n1143                          'as default, use `django.utils.timezone.now`',\n1144                     obj=self,\n1145                     id='fields.W161',\n1146                 )\n1147             ]\n1148 \n1149         return []\n1150 \n1151     def deconstruct(self):\n1152         name, path, args, kwargs = super().deconstruct()\n1153         if self.auto_now:\n1154             kwargs['auto_now'] = True\n1155         if self.auto_now_add:\n1156             kwargs['auto_now_add'] = True\n1157         if self.auto_now or self.auto_now_add:\n1158             del kwargs['editable']\n1159             del kwargs['blank']\n1160         return name, path, args, kwargs\n1161 \n1162     def get_internal_type(self):\n1163         return \"DateField\"\n1164 \n1165     def to_python(self, value):\n1166         if value is None:\n1167             return value\n1168         if isinstance(value, datetime.datetime):\n1169             if settings.USE_TZ and timezone.is_aware(value):\n1170                 # Convert aware datetimes to the default time zone\n1171                 # before casting them to dates (#17742).\n1172                 default_timezone = timezone.get_default_timezone()\n1173                 value = timezone.make_naive(value, default_timezone)\n1174             return value.date()\n1175         if isinstance(value, datetime.date):\n1176             return value\n1177 \n1178         try:\n1179             parsed = parse_date(value)\n1180             if parsed is not None:\n1181                 return parsed\n1182         except ValueError:\n1183             raise exceptions.ValidationError(\n1184                 self.error_messages['invalid_date'],\n1185                 code='invalid_date',\n1186                 params={'value': value},\n1187             )\n1188 \n1189         raise exceptions.ValidationError(\n1190             self.error_messages['invalid'],\n1191             code='invalid',\n1192             params={'value': value},\n1193         )\n1194 \n1195     def pre_save(self, model_instance, add):\n1196         if self.auto_now or (self.auto_now_add and add):\n1197             value = datetime.date.today()\n1198             setattr(model_instance, self.attname, value)\n1199             return value\n1200         else:\n1201             return super().pre_save(model_instance, add)\n1202 \n1203     def contribute_to_class(self, cls, name, **kwargs):\n1204         super().contribute_to_class(cls, name, **kwargs)\n1205         if not self.null:\n1206             setattr(\n1207                 cls, 'get_next_by_%s' % self.name,\n1208                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=True)\n1209             )\n1210             setattr(\n1211                 cls, 'get_previous_by_%s' % self.name,\n1212                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=False)\n1213             )\n1214 \n1215     def get_prep_value(self, value):\n1216         value = super().get_prep_value(value)\n1217         return self.to_python(value)\n1218 \n1219     def get_db_prep_value(self, value, connection, prepared=False):\n1220         # Casts dates into the format expected by the backend\n1221         if not prepared:\n1222             value = self.get_prep_value(value)\n1223         return connection.ops.adapt_datefield_value(value)\n1224 \n1225     def value_to_string(self, obj):\n1226         val = self.value_from_object(obj)\n1227         return '' if val is None else val.isoformat()\n1228 \n1229     def formfield(self, **kwargs):\n1230         return super().formfield(**{\n1231             'form_class': forms.DateField,\n1232             **kwargs,\n1233         })\n1234 \n1235 \n1236 class DateTimeField(DateField):\n1237     empty_strings_allowed = False\n1238     default_error_messages = {\n1239         'invalid': _('\u201c%(value)s\u201d value has an invalid format. It must be in '\n1240                      'YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format.'),\n1241         'invalid_date': _(\"\u201c%(value)s\u201d value has the correct format \"\n1242                           \"(YYYY-MM-DD) but it is an invalid date.\"),\n1243         'invalid_datetime': _('\u201c%(value)s\u201d value has the correct format '\n1244                               '(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) '\n1245                               'but it is an invalid date/time.'),\n1246     }\n1247     description = _(\"Date (with time)\")\n1248 \n1249     # __init__ is inherited from DateField\n1250 \n1251     def _check_fix_default_value(self):\n1252         \"\"\"\n1253         Warn that using an actual date or datetime value is probably wrong;\n1254         it's only evaluated on server startup.\n1255         \"\"\"\n1256         if not self.has_default():\n1257             return []\n1258 \n1259         now = timezone.now()\n1260         if not timezone.is_naive(now):\n1261             now = timezone.make_naive(now, timezone.utc)\n1262         value = self.default\n1263         if isinstance(value, datetime.datetime):\n1264             second_offset = datetime.timedelta(seconds=10)\n1265             lower = now - second_offset\n1266             upper = now + second_offset\n1267             if timezone.is_aware(value):\n1268                 value = timezone.make_naive(value, timezone.utc)\n1269         elif isinstance(value, datetime.date):\n1270             second_offset = datetime.timedelta(seconds=10)\n1271             lower = now - second_offset\n1272             lower = datetime.datetime(lower.year, lower.month, lower.day)\n1273             upper = now + second_offset\n1274             upper = datetime.datetime(upper.year, upper.month, upper.day)\n1275             value = datetime.datetime(value.year, value.month, value.day)\n1276         else:\n1277             # No explicit date / datetime value -- no checks necessary\n1278             return []\n1279         if lower <= value <= upper:\n1280             return [\n1281                 checks.Warning(\n1282                     'Fixed default value provided.',\n1283                     hint='It seems you set a fixed date / time / datetime '\n1284                          'value as default for this field. This may not be '\n1285                          'what you want. If you want to have the current date '\n1286                          'as default, use `django.utils.timezone.now`',\n1287                     obj=self,\n1288                     id='fields.W161',\n1289                 )\n1290             ]\n1291 \n1292         return []\n1293 \n1294     def get_internal_type(self):\n1295         return \"DateTimeField\"\n1296 \n1297     def to_python(self, value):\n1298         if value is None:\n1299             return value\n1300         if isinstance(value, datetime.datetime):\n1301             return value\n1302         if isinstance(value, datetime.date):\n1303             value = datetime.datetime(value.year, value.month, value.day)\n1304             if settings.USE_TZ:\n1305                 # For backwards compatibility, interpret naive datetimes in\n1306                 # local time. This won't work during DST change, but we can't\n1307                 # do much about it, so we let the exceptions percolate up the\n1308                 # call stack.\n1309                 warnings.warn(\"DateTimeField %s.%s received a naive datetime \"\n1310                               \"(%s) while time zone support is active.\" %\n1311                               (self.model.__name__, self.name, value),\n1312                               RuntimeWarning)\n1313                 default_timezone = timezone.get_default_timezone()\n1314                 value = timezone.make_aware(value, default_timezone)\n1315             return value\n1316 \n1317         try:\n1318             parsed = parse_datetime(value)\n1319             if parsed is not None:\n1320                 return parsed\n1321         except ValueError:\n1322             raise exceptions.ValidationError(\n1323                 self.error_messages['invalid_datetime'],\n1324                 code='invalid_datetime',\n1325                 params={'value': value},\n1326             )\n1327 \n1328         try:\n1329             parsed = parse_date(value)\n1330             if parsed is not None:\n1331                 return datetime.datetime(parsed.year, parsed.month, parsed.day)\n1332         except ValueError:\n1333             raise exceptions.ValidationError(\n1334                 self.error_messages['invalid_date'],\n1335                 code='invalid_date',\n1336                 params={'value': value},\n1337             )\n1338 \n1339         raise exceptions.ValidationError(\n1340             self.error_messages['invalid'],\n1341             code='invalid',\n1342             params={'value': value},\n1343         )\n1344 \n1345     def pre_save(self, model_instance, add):\n1346         if self.auto_now or (self.auto_now_add and add):\n1347             value = timezone.now()\n1348             setattr(model_instance, self.attname, value)\n1349             return value\n1350         else:\n1351             return super().pre_save(model_instance, add)\n1352 \n1353     # contribute_to_class is inherited from DateField, it registers\n1354     # get_next_by_FOO and get_prev_by_FOO\n1355 \n1356     def get_prep_value(self, value):\n1357         value = super().get_prep_value(value)\n1358         value = self.to_python(value)\n1359         if value is not None and settings.USE_TZ and timezone.is_naive(value):\n1360             # For backwards compatibility, interpret naive datetimes in local\n1361             # time. This won't work during DST change, but we can't do much\n1362             # about it, so we let the exceptions percolate up the call stack.\n1363             try:\n1364                 name = '%s.%s' % (self.model.__name__, self.name)\n1365             except AttributeError:\n1366                 name = '(unbound)'\n1367             warnings.warn(\"DateTimeField %s received a naive datetime (%s)\"\n1368                           \" while time zone support is active.\" %\n1369                           (name, value),\n1370                           RuntimeWarning)\n1371             default_timezone = timezone.get_default_timezone()\n1372             value = timezone.make_aware(value, default_timezone)\n1373         return value\n1374 \n1375     def get_db_prep_value(self, value, connection, prepared=False):\n1376         # Casts datetimes into the format expected by the backend\n1377         if not prepared:\n1378             value = self.get_prep_value(value)\n1379         return connection.ops.adapt_datetimefield_value(value)\n1380 \n1381     def value_to_string(self, obj):\n1382         val = self.value_from_object(obj)\n1383         return '' if val is None else val.isoformat()\n1384 \n1385     def formfield(self, **kwargs):\n1386         return super().formfield(**{\n1387             'form_class': forms.DateTimeField,\n1388             **kwargs,\n1389         })\n1390 \n1391 \n1392 class DecimalField(Field):\n1393     empty_strings_allowed = False\n1394     default_error_messages = {\n1395         'invalid': _('\u201c%(value)s\u201d value must be a decimal number.'),\n1396     }\n1397     description = _(\"Decimal number\")\n1398 \n1399     def __init__(self, verbose_name=None, name=None, max_digits=None,\n1400                  decimal_places=None, **kwargs):\n1401         self.max_digits, self.decimal_places = max_digits, decimal_places\n1402         super().__init__(verbose_name, name, **kwargs)\n1403 \n1404     def check(self, **kwargs):\n1405         errors = super().check(**kwargs)\n1406 \n1407         digits_errors = [\n1408             *self._check_decimal_places(),\n1409             *self._check_max_digits(),\n1410         ]\n1411         if not digits_errors:\n1412             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n1413         else:\n1414             errors.extend(digits_errors)\n1415         return errors\n1416 \n1417     def _check_decimal_places(self):\n1418         try:\n1419             decimal_places = int(self.decimal_places)\n1420             if decimal_places < 0:\n1421                 raise ValueError()\n1422         except TypeError:\n1423             return [\n1424                 checks.Error(\n1425                     \"DecimalFields must define a 'decimal_places' attribute.\",\n1426                     obj=self,\n1427                     id='fields.E130',\n1428                 )\n1429             ]\n1430         except ValueError:\n1431             return [\n1432                 checks.Error(\n1433                     \"'decimal_places' must be a non-negative integer.\",\n1434                     obj=self,\n1435                     id='fields.E131',\n1436                 )\n1437             ]\n1438         else:\n1439             return []\n1440 \n1441     def _check_max_digits(self):\n1442         try:\n1443             max_digits = int(self.max_digits)\n1444             if max_digits <= 0:\n1445                 raise ValueError()\n1446         except TypeError:\n1447             return [\n1448                 checks.Error(\n1449                     \"DecimalFields must define a 'max_digits' attribute.\",\n1450                     obj=self,\n1451                     id='fields.E132',\n1452                 )\n1453             ]\n1454         except ValueError:\n1455             return [\n1456                 checks.Error(\n1457                     \"'max_digits' must be a positive integer.\",\n1458                     obj=self,\n1459                     id='fields.E133',\n1460                 )\n1461             ]\n1462         else:\n1463             return []\n1464 \n1465     def _check_decimal_places_and_max_digits(self, **kwargs):\n1466         if int(self.decimal_places) > int(self.max_digits):\n1467             return [\n1468                 checks.Error(\n1469                     \"'max_digits' must be greater or equal to 'decimal_places'.\",\n1470                     obj=self,\n1471                     id='fields.E134',\n1472                 )\n1473             ]\n1474         return []\n1475 \n1476     @cached_property\n1477     def validators(self):\n1478         return super().validators + [\n1479             validators.DecimalValidator(self.max_digits, self.decimal_places)\n1480         ]\n1481 \n1482     @cached_property\n1483     def context(self):\n1484         return decimal.Context(prec=self.max_digits)\n1485 \n1486     def deconstruct(self):\n1487         name, path, args, kwargs = super().deconstruct()\n1488         if self.max_digits is not None:\n1489             kwargs['max_digits'] = self.max_digits\n1490         if self.decimal_places is not None:\n1491             kwargs['decimal_places'] = self.decimal_places\n1492         return name, path, args, kwargs\n1493 \n1494     def get_internal_type(self):\n1495         return \"DecimalField\"\n1496 \n1497     def to_python(self, value):\n1498         if value is None:\n1499             return value\n1500         if isinstance(value, float):\n1501             return self.context.create_decimal_from_float(value)\n1502         try:\n1503             return decimal.Decimal(value)\n1504         except (decimal.InvalidOperation, TypeError, ValueError):\n1505             raise exceptions.ValidationError(\n1506                 self.error_messages['invalid'],\n1507                 code='invalid',\n1508                 params={'value': value},\n1509             )\n1510 \n1511     def get_db_prep_save(self, value, connection):\n1512         return connection.ops.adapt_decimalfield_value(self.to_python(value), self.max_digits, self.decimal_places)\n1513 \n1514     def get_prep_value(self, value):\n1515         value = super().get_prep_value(value)\n1516         return self.to_python(value)\n1517 \n1518     def formfield(self, **kwargs):\n1519         return super().formfield(**{\n1520             'max_digits': self.max_digits,\n1521             'decimal_places': self.decimal_places,\n1522             'form_class': forms.DecimalField,\n1523             **kwargs,\n1524         })\n1525 \n1526 \n1527 class DurationField(Field):\n1528     \"\"\"\n1529     Store timedelta objects.\n1530 \n1531     Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint\n1532     of microseconds on other databases.\n1533     \"\"\"\n1534     empty_strings_allowed = False\n1535     default_error_messages = {\n1536         'invalid': _('\u201c%(value)s\u201d value has an invalid format. It must be in '\n1537                      '[DD] [[HH:]MM:]ss[.uuuuuu] format.')\n1538     }\n1539     description = _(\"Duration\")\n1540 \n1541     def get_internal_type(self):\n1542         return \"DurationField\"\n1543 \n1544     def to_python(self, value):\n1545         if value is None:\n1546             return value\n1547         if isinstance(value, datetime.timedelta):\n1548             return value\n1549         try:\n1550             parsed = parse_duration(value)\n1551         except ValueError:\n1552             pass\n1553         else:\n1554             if parsed is not None:\n1555                 return parsed\n1556 \n1557         raise exceptions.ValidationError(\n1558             self.error_messages['invalid'],\n1559             code='invalid',\n1560             params={'value': value},\n1561         )\n1562 \n1563     def get_db_prep_value(self, value, connection, prepared=False):\n1564         if connection.features.has_native_duration_field:\n1565             return value\n1566         if value is None:\n1567             return None\n1568         return duration_microseconds(value)\n1569 \n1570     def get_db_converters(self, connection):\n1571         converters = []\n1572         if not connection.features.has_native_duration_field:\n1573             converters.append(connection.ops.convert_durationfield_value)\n1574         return converters + super().get_db_converters(connection)\n1575 \n1576     def value_to_string(self, obj):\n1577         val = self.value_from_object(obj)\n1578         return '' if val is None else duration_string(val)\n1579 \n1580     def formfield(self, **kwargs):\n1581         return super().formfield(**{\n1582             'form_class': forms.DurationField,\n1583             **kwargs,\n1584         })\n1585 \n1586 \n1587 class EmailField(CharField):\n1588     default_validators = [validators.validate_email]\n1589     description = _(\"Email address\")\n1590 \n1591     def __init__(self, *args, **kwargs):\n1592         # max_length=254 to be compliant with RFCs 3696 and 5321\n1593         kwargs.setdefault('max_length', 254)\n1594         super().__init__(*args, **kwargs)\n1595 \n1596     def deconstruct(self):\n1597         name, path, args, kwargs = super().deconstruct()\n1598         # We do not exclude max_length if it matches default as we want to change\n1599         # the default in future.\n1600         return name, path, args, kwargs\n1601 \n1602     def formfield(self, **kwargs):\n1603         # As with CharField, this will cause email validation to be performed\n1604         # twice.\n1605         return super().formfield(**{\n1606             'form_class': forms.EmailField,\n1607             **kwargs,\n1608         })\n1609 \n1610 \n1611 class FilePathField(Field):\n1612     description = _(\"File path\")\n1613 \n1614     def __init__(self, verbose_name=None, name=None, path='', match=None,\n1615                  recursive=False, allow_files=True, allow_folders=False, **kwargs):\n1616         self.path, self.match, self.recursive = path, match, recursive\n1617         self.allow_files, self.allow_folders = allow_files, allow_folders\n1618         kwargs.setdefault('max_length', 100)\n1619         super().__init__(verbose_name, name, **kwargs)\n1620 \n1621     def check(self, **kwargs):\n1622         return [\n1623             *super().check(**kwargs),\n1624             *self._check_allowing_files_or_folders(**kwargs),\n1625         ]\n1626 \n1627     def _check_allowing_files_or_folders(self, **kwargs):\n1628         if not self.allow_files and not self.allow_folders:\n1629             return [\n1630                 checks.Error(\n1631                     \"FilePathFields must have either 'allow_files' or 'allow_folders' set to True.\",\n1632                     obj=self,\n1633                     id='fields.E140',\n1634                 )\n1635             ]\n1636         return []\n1637 \n1638     def deconstruct(self):\n1639         name, path, args, kwargs = super().deconstruct()\n1640         if self.path != '':\n1641             kwargs['path'] = self.path\n1642         if self.match is not None:\n1643             kwargs['match'] = self.match\n1644         if self.recursive is not False:\n1645             kwargs['recursive'] = self.recursive\n1646         if self.allow_files is not True:\n1647             kwargs['allow_files'] = self.allow_files\n1648         if self.allow_folders is not False:\n1649             kwargs['allow_folders'] = self.allow_folders\n1650         if kwargs.get(\"max_length\") == 100:\n1651             del kwargs[\"max_length\"]\n1652         return name, path, args, kwargs\n1653 \n1654     def get_prep_value(self, value):\n1655         value = super().get_prep_value(value)\n1656         if value is None:\n1657             return None\n1658         return str(value)\n1659 \n1660     def formfield(self, **kwargs):\n1661         return super().formfield(**{\n1662             'path': self.path() if callable(self.path) else self.path,\n1663             'match': self.match,\n1664             'recursive': self.recursive,\n1665             'form_class': forms.FilePathField,\n1666             'allow_files': self.allow_files,\n1667             'allow_folders': self.allow_folders,\n1668             **kwargs,\n1669         })\n1670 \n1671     def get_internal_type(self):\n1672         return \"FilePathField\"\n1673 \n1674 \n1675 class FloatField(Field):\n1676     empty_strings_allowed = False\n1677     default_error_messages = {\n1678         'invalid': _('\u201c%(value)s\u201d value must be a float.'),\n1679     }\n1680     description = _(\"Floating point number\")\n1681 \n1682     def get_prep_value(self, value):\n1683         value = super().get_prep_value(value)\n1684         if value is None:\n1685             return None\n1686         try:\n1687             return float(value)\n1688         except (TypeError, ValueError) as e:\n1689             raise e.__class__(\n1690                 \"Field '%s' expected a number but got %r.\" % (self.name, value),\n1691             ) from e\n1692 \n1693     def get_internal_type(self):\n1694         return \"FloatField\"\n1695 \n1696     def to_python(self, value):\n1697         if value is None:\n1698             return value\n1699         try:\n1700             return float(value)\n1701         except (TypeError, ValueError):\n1702             raise exceptions.ValidationError(\n1703                 self.error_messages['invalid'],\n1704                 code='invalid',\n1705                 params={'value': value},\n1706             )\n1707 \n1708     def formfield(self, **kwargs):\n1709         return super().formfield(**{\n1710             'form_class': forms.FloatField,\n1711             **kwargs,\n1712         })\n1713 \n1714 \n1715 class IntegerField(Field):\n1716     empty_strings_allowed = False\n1717     default_error_messages = {\n1718         'invalid': _('\u201c%(value)s\u201d value must be an integer.'),\n1719     }\n1720     description = _(\"Integer\")\n1721 \n1722     def check(self, **kwargs):\n1723         return [\n1724             *super().check(**kwargs),\n1725             *self._check_max_length_warning(),\n1726         ]\n1727 \n1728     def _check_max_length_warning(self):\n1729         if self.max_length is not None:\n1730             return [\n1731                 checks.Warning(\n1732                     \"'max_length' is ignored when used with %s.\" % self.__class__.__name__,\n1733                     hint=\"Remove 'max_length' from field\",\n1734                     obj=self,\n1735                     id='fields.W122',\n1736                 )\n1737             ]\n1738         return []\n1739 \n1740     @cached_property\n1741     def validators(self):\n1742         # These validators can't be added at field initialization time since\n1743         # they're based on values retrieved from `connection`.\n1744         validators_ = super().validators\n1745         internal_type = self.get_internal_type()\n1746         min_value, max_value = connection.ops.integer_field_range(internal_type)\n1747         if min_value is not None and not any(\n1748             (\n1749                 isinstance(validator, validators.MinValueValidator) and (\n1750                     validator.limit_value()\n1751                     if callable(validator.limit_value)\n1752                     else validator.limit_value\n1753                 ) >= min_value\n1754             ) for validator in validators_\n1755         ):\n1756             validators_.append(validators.MinValueValidator(min_value))\n1757         if max_value is not None and not any(\n1758             (\n1759                 isinstance(validator, validators.MaxValueValidator) and (\n1760                     validator.limit_value()\n1761                     if callable(validator.limit_value)\n1762                     else validator.limit_value\n1763                 ) <= max_value\n1764             ) for validator in validators_\n1765         ):\n1766             validators_.append(validators.MaxValueValidator(max_value))\n1767         return validators_\n1768 \n1769     def get_prep_value(self, value):\n1770         value = super().get_prep_value(value)\n1771         if value is None:\n1772             return None\n1773         try:\n1774             return int(value)\n1775         except (TypeError, ValueError) as e:\n1776             raise e.__class__(\n1777                 \"Field '%s' expected a number but got %r.\" % (self.name, value),\n1778             ) from e\n1779 \n1780     def get_internal_type(self):\n1781         return \"IntegerField\"\n1782 \n1783     def to_python(self, value):\n1784         if value is None:\n1785             return value\n1786         try:\n1787             return int(value)\n1788         except (TypeError, ValueError):\n1789             raise exceptions.ValidationError(\n1790                 self.error_messages['invalid'],\n1791                 code='invalid',\n1792                 params={'value': value},\n1793             )\n1794 \n1795     def formfield(self, **kwargs):\n1796         return super().formfield(**{\n1797             'form_class': forms.IntegerField,\n1798             **kwargs,\n1799         })\n1800 \n1801 \n1802 class BigIntegerField(IntegerField):\n1803     description = _(\"Big (8 byte) integer\")\n1804     MAX_BIGINT = 9223372036854775807\n1805 \n1806     def get_internal_type(self):\n1807         return \"BigIntegerField\"\n1808 \n1809     def formfield(self, **kwargs):\n1810         return super().formfield(**{\n1811             'min_value': -BigIntegerField.MAX_BIGINT - 1,\n1812             'max_value': BigIntegerField.MAX_BIGINT,\n1813             **kwargs,\n1814         })\n1815 \n1816 \n1817 class IPAddressField(Field):\n1818     empty_strings_allowed = False\n1819     description = _(\"IPv4 address\")\n1820     system_check_removed_details = {\n1821         'msg': (\n1822             'IPAddressField has been removed except for support in '\n1823             'historical migrations.'\n1824         ),\n1825         'hint': 'Use GenericIPAddressField instead.',\n1826         'id': 'fields.E900',\n1827     }\n1828 \n1829     def __init__(self, *args, **kwargs):\n1830         kwargs['max_length'] = 15\n1831         super().__init__(*args, **kwargs)\n1832 \n1833     def deconstruct(self):\n1834         name, path, args, kwargs = super().deconstruct()\n1835         del kwargs['max_length']\n1836         return name, path, args, kwargs\n1837 \n1838     def get_prep_value(self, value):\n1839         value = super().get_prep_value(value)\n1840         if value is None:\n1841             return None\n1842         return str(value)\n1843 \n1844     def get_internal_type(self):\n1845         return \"IPAddressField\"\n1846 \n1847 \n1848 class GenericIPAddressField(Field):\n1849     empty_strings_allowed = False\n1850     description = _(\"IP address\")\n1851     default_error_messages = {}\n1852 \n1853     def __init__(self, verbose_name=None, name=None, protocol='both',\n1854                  unpack_ipv4=False, *args, **kwargs):\n1855         self.unpack_ipv4 = unpack_ipv4\n1856         self.protocol = protocol\n1857         self.default_validators, invalid_error_message = \\\n1858             validators.ip_address_validators(protocol, unpack_ipv4)\n1859         self.default_error_messages['invalid'] = invalid_error_message\n1860         kwargs['max_length'] = 39\n1861         super().__init__(verbose_name, name, *args, **kwargs)\n1862 \n1863     def check(self, **kwargs):\n1864         return [\n1865             *super().check(**kwargs),\n1866             *self._check_blank_and_null_values(**kwargs),\n1867         ]\n1868 \n1869     def _check_blank_and_null_values(self, **kwargs):\n1870         if not getattr(self, 'null', False) and getattr(self, 'blank', False):\n1871             return [\n1872                 checks.Error(\n1873                     'GenericIPAddressFields cannot have blank=True if null=False, '\n1874                     'as blank values are stored as nulls.',\n1875                     obj=self,\n1876                     id='fields.E150',\n1877                 )\n1878             ]\n1879         return []\n1880 \n1881     def deconstruct(self):\n1882         name, path, args, kwargs = super().deconstruct()\n1883         if self.unpack_ipv4 is not False:\n1884             kwargs['unpack_ipv4'] = self.unpack_ipv4\n1885         if self.protocol != \"both\":\n1886             kwargs['protocol'] = self.protocol\n1887         if kwargs.get(\"max_length\") == 39:\n1888             del kwargs['max_length']\n1889         return name, path, args, kwargs\n1890 \n1891     def get_internal_type(self):\n1892         return \"GenericIPAddressField\"\n1893 \n1894     def to_python(self, value):\n1895         if value is None:\n1896             return None\n1897         if not isinstance(value, str):\n1898             value = str(value)\n1899         value = value.strip()\n1900         if ':' in value:\n1901             return clean_ipv6_address(value, self.unpack_ipv4, self.error_messages['invalid'])\n1902         return value\n1903 \n1904     def get_db_prep_value(self, value, connection, prepared=False):\n1905         if not prepared:\n1906             value = self.get_prep_value(value)\n1907         return connection.ops.adapt_ipaddressfield_value(value)\n1908 \n1909     def get_prep_value(self, value):\n1910         value = super().get_prep_value(value)\n1911         if value is None:\n1912             return None\n1913         if value and ':' in value:\n1914             try:\n1915                 return clean_ipv6_address(value, self.unpack_ipv4)\n1916             except exceptions.ValidationError:\n1917                 pass\n1918         return str(value)\n1919 \n1920     def formfield(self, **kwargs):\n1921         return super().formfield(**{\n1922             'protocol': self.protocol,\n1923             'form_class': forms.GenericIPAddressField,\n1924             **kwargs,\n1925         })\n1926 \n1927 \n1928 class NullBooleanField(BooleanField):\n1929     default_error_messages = {\n1930         'invalid': _('\u201c%(value)s\u201d value must be either None, True or False.'),\n1931         'invalid_nullable': _('\u201c%(value)s\u201d value must be either None, True or False.'),\n1932     }\n1933     description = _(\"Boolean (Either True, False or None)\")\n1934     system_check_deprecated_details = {\n1935         'msg': (\n1936             'NullBooleanField is deprecated. Support for it (except in '\n1937             'historical migrations) will be removed in Django 4.0.'\n1938         ),\n1939         'hint': 'Use BooleanField(null=True) instead.',\n1940         'id': 'fields.W903',\n1941     }\n1942 \n1943     def __init__(self, *args, **kwargs):\n1944         kwargs['null'] = True\n1945         kwargs['blank'] = True\n1946         super().__init__(*args, **kwargs)\n1947 \n1948     def deconstruct(self):\n1949         name, path, args, kwargs = super().deconstruct()\n1950         del kwargs['null']\n1951         del kwargs['blank']\n1952         return name, path, args, kwargs\n1953 \n1954     def get_internal_type(self):\n1955         return \"NullBooleanField\"\n1956 \n1957 \n1958 class PositiveIntegerRelDbTypeMixin:\n1959 \n1960     def rel_db_type(self, connection):\n1961         \"\"\"\n1962         Return the data type that a related field pointing to this field should\n1963         use. In most cases, a foreign key pointing to a positive integer\n1964         primary key will have an integer column data type but some databases\n1965         (e.g. MySQL) have an unsigned integer type. In that case\n1966         (related_fields_match_type=True), the primary key should return its\n1967         db_type.\n1968         \"\"\"\n1969         if connection.features.related_fields_match_type:\n1970             return self.db_type(connection)\n1971         else:\n1972             return IntegerField().db_type(connection=connection)\n1973 \n1974 \n1975 class PositiveBigIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):\n1976     description = _('Positive big integer')\n1977 \n1978     def get_internal_type(self):\n1979         return 'PositiveBigIntegerField'\n1980 \n1981     def formfield(self, **kwargs):\n1982         return super().formfield(**{\n1983             'min_value': 0,\n1984             **kwargs,\n1985         })\n1986 \n1987 \n1988 class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):\n1989     description = _(\"Positive integer\")\n1990 \n1991     def get_internal_type(self):\n1992         return \"PositiveIntegerField\"\n1993 \n1994     def formfield(self, **kwargs):\n1995         return super().formfield(**{\n1996             'min_value': 0,\n1997             **kwargs,\n1998         })\n1999 \n2000 \n2001 class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):\n2002     description = _(\"Positive small integer\")\n2003 \n2004     def get_internal_type(self):\n2005         return \"PositiveSmallIntegerField\"\n2006 \n2007     def formfield(self, **kwargs):\n2008         return super().formfield(**{\n2009             'min_value': 0,\n2010             **kwargs,\n2011         })\n2012 \n2013 \n2014 class SlugField(CharField):\n2015     default_validators = [validators.validate_slug]\n2016     description = _(\"Slug (up to %(max_length)s)\")\n2017 \n2018     def __init__(self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs):\n2019         self.allow_unicode = allow_unicode\n2020         if self.allow_unicode:\n2021             self.default_validators = [validators.validate_unicode_slug]\n2022         super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)\n2023 \n2024     def deconstruct(self):\n2025         name, path, args, kwargs = super().deconstruct()\n2026         if kwargs.get(\"max_length\") == 50:\n2027             del kwargs['max_length']\n2028         if self.db_index is False:\n2029             kwargs['db_index'] = False\n2030         else:\n2031             del kwargs['db_index']\n2032         if self.allow_unicode is not False:\n2033             kwargs['allow_unicode'] = self.allow_unicode\n2034         return name, path, args, kwargs\n2035 \n2036     def get_internal_type(self):\n2037         return \"SlugField\"\n2038 \n2039     def formfield(self, **kwargs):\n2040         return super().formfield(**{\n2041             'form_class': forms.SlugField,\n2042             'allow_unicode': self.allow_unicode,\n2043             **kwargs,\n2044         })\n2045 \n2046 \n2047 class SmallIntegerField(IntegerField):\n2048     description = _(\"Small integer\")\n2049 \n2050     def get_internal_type(self):\n2051         return \"SmallIntegerField\"\n2052 \n2053 \n2054 class TextField(Field):\n2055     description = _(\"Text\")\n2056 \n2057     def get_internal_type(self):\n2058         return \"TextField\"\n2059 \n2060     def to_python(self, value):\n2061         if isinstance(value, str) or value is None:\n2062             return value\n2063         return str(value)\n2064 \n2065     def get_prep_value(self, value):\n2066         value = super().get_prep_value(value)\n2067         return self.to_python(value)\n2068 \n2069     def formfield(self, **kwargs):\n2070         # Passing max_length to forms.CharField means that the value's length\n2071         # will be validated twice. This is considered acceptable since we want\n2072         # the value in the form field (to pass into widget for example).\n2073         return super().formfield(**{\n2074             'max_length': self.max_length,\n2075             **({} if self.choices is not None else {'widget': forms.Textarea}),\n2076             **kwargs,\n2077         })\n2078 \n2079 \n2080 class TimeField(DateTimeCheckMixin, Field):\n2081     empty_strings_allowed = False\n2082     default_error_messages = {\n2083         'invalid': _('\u201c%(value)s\u201d value has an invalid format. It must be in '\n2084                      'HH:MM[:ss[.uuuuuu]] format.'),\n2085         'invalid_time': _('\u201c%(value)s\u201d value has the correct format '\n2086                           '(HH:MM[:ss[.uuuuuu]]) but it is an invalid time.'),\n2087     }\n2088     description = _(\"Time\")\n2089 \n2090     def __init__(self, verbose_name=None, name=None, auto_now=False,\n2091                  auto_now_add=False, **kwargs):\n2092         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n2093         if auto_now or auto_now_add:\n2094             kwargs['editable'] = False\n2095             kwargs['blank'] = True\n2096         super().__init__(verbose_name, name, **kwargs)\n2097 \n2098     def _check_fix_default_value(self):\n2099         \"\"\"\n2100         Warn that using an actual date or datetime value is probably wrong;\n2101         it's only evaluated on server startup.\n2102         \"\"\"\n2103         if not self.has_default():\n2104             return []\n2105 \n2106         now = timezone.now()\n2107         if not timezone.is_naive(now):\n2108             now = timezone.make_naive(now, timezone.utc)\n2109         value = self.default\n2110         if isinstance(value, datetime.datetime):\n2111             second_offset = datetime.timedelta(seconds=10)\n2112             lower = now - second_offset\n2113             upper = now + second_offset\n2114             if timezone.is_aware(value):\n2115                 value = timezone.make_naive(value, timezone.utc)\n2116         elif isinstance(value, datetime.time):\n2117             second_offset = datetime.timedelta(seconds=10)\n2118             lower = now - second_offset\n2119             upper = now + second_offset\n2120             value = datetime.datetime.combine(now.date(), value)\n2121             if timezone.is_aware(value):\n2122                 value = timezone.make_naive(value, timezone.utc).time()\n2123         else:\n2124             # No explicit time / datetime value -- no checks necessary\n2125             return []\n2126         if lower <= value <= upper:\n2127             return [\n2128                 checks.Warning(\n2129                     'Fixed default value provided.',\n2130                     hint='It seems you set a fixed date / time / datetime '\n2131                          'value as default for this field. This may not be '\n2132                          'what you want. If you want to have the current date '\n2133                          'as default, use `django.utils.timezone.now`',\n2134                     obj=self,\n2135                     id='fields.W161',\n2136                 )\n2137             ]\n2138 \n2139         return []\n2140 \n2141     def deconstruct(self):\n2142         name, path, args, kwargs = super().deconstruct()\n2143         if self.auto_now is not False:\n2144             kwargs[\"auto_now\"] = self.auto_now\n2145         if self.auto_now_add is not False:\n2146             kwargs[\"auto_now_add\"] = self.auto_now_add\n2147         if self.auto_now or self.auto_now_add:\n2148             del kwargs['blank']\n2149             del kwargs['editable']\n2150         return name, path, args, kwargs\n2151 \n2152     def get_internal_type(self):\n2153         return \"TimeField\"\n2154 \n2155     def to_python(self, value):\n2156         if value is None:\n2157             return None\n2158         if isinstance(value, datetime.time):\n2159             return value\n2160         if isinstance(value, datetime.datetime):\n2161             # Not usually a good idea to pass in a datetime here (it loses\n2162             # information), but this can be a side-effect of interacting with a\n2163             # database backend (e.g. Oracle), so we'll be accommodating.\n2164             return value.time()\n2165 \n2166         try:\n2167             parsed = parse_time(value)\n2168             if parsed is not None:\n2169                 return parsed\n2170         except ValueError:\n2171             raise exceptions.ValidationError(\n2172                 self.error_messages['invalid_time'],\n2173                 code='invalid_time',\n2174                 params={'value': value},\n2175             )\n2176 \n2177         raise exceptions.ValidationError(\n2178             self.error_messages['invalid'],\n2179             code='invalid',\n2180             params={'value': value},\n2181         )\n2182 \n2183     def pre_save(self, model_instance, add):\n2184         if self.auto_now or (self.auto_now_add and add):\n2185             value = datetime.datetime.now().time()\n2186             setattr(model_instance, self.attname, value)\n2187             return value\n2188         else:\n2189             return super().pre_save(model_instance, add)\n2190 \n2191     def get_prep_value(self, value):\n2192         value = super().get_prep_value(value)\n2193         return self.to_python(value)\n2194 \n2195     def get_db_prep_value(self, value, connection, prepared=False):\n2196         # Casts times into the format expected by the backend\n2197         if not prepared:\n2198             value = self.get_prep_value(value)\n2199         return connection.ops.adapt_timefield_value(value)\n2200 \n2201     def value_to_string(self, obj):\n2202         val = self.value_from_object(obj)\n2203         return '' if val is None else val.isoformat()\n2204 \n2205     def formfield(self, **kwargs):\n2206         return super().formfield(**{\n2207             'form_class': forms.TimeField,\n2208             **kwargs,\n2209         })\n2210 \n2211 \n2212 class URLField(CharField):\n2213     default_validators = [validators.URLValidator()]\n2214     description = _(\"URL\")\n2215 \n2216     def __init__(self, verbose_name=None, name=None, **kwargs):\n2217         kwargs.setdefault('max_length', 200)\n2218         super().__init__(verbose_name, name, **kwargs)\n2219 \n2220     def deconstruct(self):\n2221         name, path, args, kwargs = super().deconstruct()\n2222         if kwargs.get(\"max_length\") == 200:\n2223             del kwargs['max_length']\n2224         return name, path, args, kwargs\n2225 \n2226     def formfield(self, **kwargs):\n2227         # As with CharField, this will cause URL validation to be performed\n2228         # twice.\n2229         return super().formfield(**{\n2230             'form_class': forms.URLField,\n2231             **kwargs,\n2232         })\n2233 \n2234 \n2235 class BinaryField(Field):\n2236     description = _(\"Raw binary data\")\n2237     empty_values = [None, b'']\n2238 \n2239     def __init__(self, *args, **kwargs):\n2240         kwargs.setdefault('editable', False)\n2241         super().__init__(*args, **kwargs)\n2242         if self.max_length is not None:\n2243             self.validators.append(validators.MaxLengthValidator(self.max_length))\n2244 \n2245     def check(self, **kwargs):\n2246         return [*super().check(**kwargs), *self._check_str_default_value()]\n2247 \n2248     def _check_str_default_value(self):\n2249         if self.has_default() and isinstance(self.default, str):\n2250             return [\n2251                 checks.Error(\n2252                     \"BinaryField's default cannot be a string. Use bytes \"\n2253                     \"content instead.\",\n2254                     obj=self,\n2255                     id='fields.E170',\n2256                 )\n2257             ]\n2258         return []\n2259 \n2260     def deconstruct(self):\n2261         name, path, args, kwargs = super().deconstruct()\n2262         if self.editable:\n2263             kwargs['editable'] = True\n2264         else:\n2265             del kwargs['editable']\n2266         return name, path, args, kwargs\n2267 \n2268     def get_internal_type(self):\n2269         return \"BinaryField\"\n2270 \n2271     def get_placeholder(self, value, compiler, connection):\n2272         return connection.ops.binary_placeholder_sql(value)\n2273 \n2274     def get_default(self):\n2275         if self.has_default() and not callable(self.default):\n2276             return self.default\n2277         default = super().get_default()\n2278         if default == '':\n2279             return b''\n2280         return default\n2281 \n2282     def get_db_prep_value(self, value, connection, prepared=False):\n2283         value = super().get_db_prep_value(value, connection, prepared)\n2284         if value is not None:\n2285             return connection.Database.Binary(value)\n2286         return value\n2287 \n2288     def value_to_string(self, obj):\n2289         \"\"\"Binary data is serialized as base64\"\"\"\n2290         return b64encode(self.value_from_object(obj)).decode('ascii')\n2291 \n2292     def to_python(self, value):\n2293         # If it's a string, it should be base64-encoded data\n2294         if isinstance(value, str):\n2295             return memoryview(b64decode(value.encode('ascii')))\n2296         return value\n2297 \n2298 \n2299 class UUIDField(Field):\n2300     default_error_messages = {\n2301         'invalid': _('\u201c%(value)s\u201d is not a valid UUID.'),\n2302     }\n2303     description = _('Universally unique identifier')\n2304     empty_strings_allowed = False\n2305 \n2306     def __init__(self, verbose_name=None, **kwargs):\n2307         kwargs['max_length'] = 32\n2308         super().__init__(verbose_name, **kwargs)\n2309 \n2310     def deconstruct(self):\n2311         name, path, args, kwargs = super().deconstruct()\n2312         del kwargs['max_length']\n2313         return name, path, args, kwargs\n2314 \n2315     def get_internal_type(self):\n2316         return \"UUIDField\"\n2317 \n2318     def get_prep_value(self, value):\n2319         value = super().get_prep_value(value)\n2320         return self.to_python(value)\n2321 \n2322     def get_db_prep_value(self, value, connection, prepared=False):\n2323         if value is None:\n2324             return None\n2325         if not isinstance(value, uuid.UUID):\n2326             value = self.to_python(value)\n2327 \n2328         if connection.features.has_native_uuid_field:\n2329             return value\n2330         return value.hex\n2331 \n2332     def to_python(self, value):\n2333         if value is not None and not isinstance(value, uuid.UUID):\n2334             input_form = 'int' if isinstance(value, int) else 'hex'\n2335             try:\n2336                 return uuid.UUID(**{input_form: value})\n2337             except (AttributeError, ValueError):\n2338                 raise exceptions.ValidationError(\n2339                     self.error_messages['invalid'],\n2340                     code='invalid',\n2341                     params={'value': value},\n2342                 )\n2343         return value\n2344 \n2345     def formfield(self, **kwargs):\n2346         return super().formfield(**{\n2347             'form_class': forms.UUIDField,\n2348             **kwargs,\n2349         })\n2350 \n2351 \n2352 class AutoFieldMixin:\n2353     db_returning = True\n2354 \n2355     def __init__(self, *args, **kwargs):\n2356         kwargs['blank'] = True\n2357         super().__init__(*args, **kwargs)\n2358 \n2359     def check(self, **kwargs):\n2360         return [\n2361             *super().check(**kwargs),\n2362             *self._check_primary_key(),\n2363         ]\n2364 \n2365     def _check_primary_key(self):\n2366         if not self.primary_key:\n2367             return [\n2368                 checks.Error(\n2369                     'AutoFields must set primary_key=True.',\n2370                     obj=self,\n2371                     id='fields.E100',\n2372                 ),\n2373             ]\n2374         else:\n2375             return []\n2376 \n2377     def deconstruct(self):\n2378         name, path, args, kwargs = super().deconstruct()\n2379         del kwargs['blank']\n2380         kwargs['primary_key'] = True\n2381         return name, path, args, kwargs\n2382 \n2383     def validate(self, value, model_instance):\n2384         pass\n2385 \n2386     def get_db_prep_value(self, value, connection, prepared=False):\n2387         if not prepared:\n2388             value = self.get_prep_value(value)\n2389             value = connection.ops.validate_autopk_value(value)\n2390         return value\n2391 \n2392     def contribute_to_class(self, cls, name, **kwargs):\n2393         assert not cls._meta.auto_field, (\n2394             \"Model %s can't have more than one auto-generated field.\"\n2395             % cls._meta.label\n2396         )\n2397         super().contribute_to_class(cls, name, **kwargs)\n2398         cls._meta.auto_field = self\n2399 \n2400     def formfield(self, **kwargs):\n2401         return None\n2402 \n2403 \n2404 class AutoFieldMeta(type):\n2405     \"\"\"\n2406     Metaclass to maintain backward inheritance compatibility for AutoField.\n2407 \n2408     It is intended that AutoFieldMixin become public API when it is possible to\n2409     create a non-integer automatically-generated field using column defaults\n2410     stored in the database.\n2411 \n2412     In many areas Django also relies on using isinstance() to check for an\n2413     automatically-generated field as a subclass of AutoField. A new flag needs\n2414     to be implemented on Field to be used instead.\n2415 \n2416     When these issues have been addressed, this metaclass could be used to\n2417     deprecate inheritance from AutoField and use of isinstance() with AutoField\n2418     for detecting automatically-generated fields.\n2419     \"\"\"\n2420 \n2421     @property\n2422     def _subclasses(self):\n2423         return (BigAutoField, SmallAutoField)\n2424 \n2425     def __instancecheck__(self, instance):\n2426         return isinstance(instance, self._subclasses) or super().__instancecheck__(instance)\n2427 \n2428     def __subclasscheck__(self, subclass):\n2429         return subclass in self._subclasses or super().__subclasscheck__(subclass)\n2430 \n2431 \n2432 class AutoField(AutoFieldMixin, IntegerField, metaclass=AutoFieldMeta):\n2433 \n2434     def get_internal_type(self):\n2435         return 'AutoField'\n2436 \n2437     def rel_db_type(self, connection):\n2438         return IntegerField().db_type(connection=connection)\n2439 \n2440 \n2441 class BigAutoField(AutoFieldMixin, BigIntegerField):\n2442 \n2443     def get_internal_type(self):\n2444         return 'BigAutoField'\n2445 \n2446     def rel_db_type(self, connection):\n2447         return BigIntegerField().db_type(connection=connection)\n2448 \n2449 \n2450 class SmallAutoField(AutoFieldMixin, SmallIntegerField):\n2451 \n2452     def get_internal_type(self):\n2453         return 'SmallAutoField'\n2454 \n2455     def rel_db_type(self, connection):\n2456         return SmallIntegerField().db_type(connection=connection)\n",
        "intended_behavior": "For every validator attached to model fields, ensure that when raising ValidationError, the value being validated is passed along. This requires modifications to both direct raises of ValidationError within methods and possibly updates to how validators are called, ensuring they have the necessary context to include the value in the error."
    }
]