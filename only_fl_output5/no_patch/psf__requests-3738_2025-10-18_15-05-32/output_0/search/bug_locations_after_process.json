[
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/models.py",
        "start": 334,
        "end": 418,
        "class_name": "PreparedRequest",
        "method_name": "prepare_url",
        "code": "334     def prepare_url(self, url, params):\n335         \"\"\"Prepares the given HTTP URL.\"\"\"\n336         #: Accept objects that have string representations.\n337         #: We're unable to blindly call unicode/str functions\n338         #: as this will include the bytestring indicator (b'')\n339         #: on python 3.x.\n340         #: https://github.com/kennethreitz/requests/pull/2238\n341         if isinstance(url, bytes):\n342             url = url.decode('utf8')\n343         else:\n344             url = unicode(url) if is_py2 else str(url)\n345 \n346         # Remove leading whitespaces from url\n347         url = url.lstrip()\n348 \n349         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n350         # `data`, `http+unix` etc to work around exceptions from `url_parse`,\n351         # which handles RFC 3986 only.\n352         if ':' in url and not url.lower().startswith(('http://', 'https://')):\n353             self.url = url\n354             return\n355 \n356         # Support for unicode domain names and paths.\n357         try:\n358             scheme, auth, host, port, path, query, fragment = parse_url(url)\n359         except LocationParseError as e:\n360             raise InvalidURL(*e.args)\n361 \n362         if not scheme:\n363             error = (\"Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?\")\n364             error = error.format(to_native_string(url, 'utf8'))\n365 \n366             raise MissingSchema(error)\n367 \n368         if not host:\n369             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n370 \n371         # In general, we want to try IDNA encoding every hostname, as that\n372         # allows users to automatically get the correct behaviour. However,\n373         # we\u2019re quite strict about IDNA encoding, so certain valid hostnames\n374         # may fail to encode. On failure, we verify the hostname meets a\n375         # minimum standard of only containing ASCII characters, and not starting\n376         # with a wildcard (*), before allowing the unencoded hostname through.\n377         try:\n378             host = idna.encode(host, uts46=True).decode('utf-8')\n379         except (UnicodeError, idna.IDNAError):\n380             if not unicode_is_ascii(host) or host.startswith(u'*'):\n381                 raise InvalidURL('URL has an invalid label.')\n382 \n383         # Carefully reconstruct the network location\n384         netloc = auth or ''\n385         if netloc:\n386             netloc += '@'\n387         netloc += host\n388         if port:\n389             netloc += ':' + str(port)\n390 \n391         # Bare domains aren't valid URLs.\n392         if not path:\n393             path = '/'\n394 \n395         if is_py2:\n396             if isinstance(scheme, str):\n397                 scheme = scheme.encode('utf-8')\n398             if isinstance(netloc, str):\n399                 netloc = netloc.encode('utf-8')\n400             if isinstance(path, str):\n401                 path = path.encode('utf-8')\n402             if isinstance(query, str):\n403                 query = query.encode('utf-8')\n404             if isinstance(fragment, str):\n405                 fragment = fragment.encode('utf-8')\n406 \n407         if isinstance(params, (str, bytes)):\n408             params = to_native_string(params)\n409 \n410         enc_params = self._encode_params(params)\n411         if enc_params:\n412             if query:\n413                 query = '%s&%s' % (query, enc_params)\n414             else:\n415                 query = enc_params\n416 \n417         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n418         self.url = url\n",
        "intended_behavior": "This method should be modified to allow URL preparation for non-HTTP schemes if they are explicitly allowed or registered by the user. This means extending the functionality to not just bypass URLs with schemes other than `http://` or `https://`. A registry or configuration setting could be introduced at the `Session` level, allowing users to specify which schemes should be treated like HTTP schemes for the purpose of URL preparation. This would involve adding a check against this new registry/configuration within the `if` condition that currently skips URL preparation for non-HTTP schemes. The condition at lines 349-352 needs to be adjusted to account for the new mechanism, allowing specified non-HTTP schemes to undergo the same preparation process as HTTP URLs, including parameter encoding and normalization. The solution should preserve the existing functionality for all standard HTTP and HTTPS URLs and add new functionality for user-defined schemes without altering the behavior for truly unsupported or unknown schemes not explicitly marked by the user for HTTP-like processing. This approach ensures backward compatibility while providing flexibility for cases like `http+unix`."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/models.py",
        "start": 262,
        "end": 562,
        "class_name": "PreparedRequest",
        "method_name": null,
        "code": "262 class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n263     \"\"\"The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\n264     containing the exact bytes that will be sent to the server.\n265 \n266     Generated from either a :class:`Request <Request>` object or manually.\n267 \n268     Usage::\n269 \n270       >>> import requests\n271       >>> req = requests.Request('GET', 'http://httpbin.org/get')\n272       >>> r = req.prepare()\n273       <PreparedRequest [GET]>\n274 \n275       >>> s = requests.Session()\n276       >>> s.send(r)\n277       <Response [200]>\n278     \"\"\"\n279 \n280     def __init__(self):\n281         #: HTTP verb to send to the server.\n282         self.method = None\n283         #: HTTP URL to send the request to.\n284         self.url = None\n285         #: dictionary of HTTP headers.\n286         self.headers = None\n287         # The `CookieJar` used to create the Cookie header will be stored here\n288         # after prepare_cookies is called\n289         self._cookies = None\n290         #: request body to send to the server.\n291         self.body = None\n292         #: dictionary of callback hooks, for internal usage.\n293         self.hooks = default_hooks()\n294         #: integer denoting starting position of a readable file-like body.\n295         self._body_position = None\n296 \n297     def prepare(self, method=None, url=None, headers=None, files=None,\n298         data=None, params=None, auth=None, cookies=None, hooks=None, json=None):\n299         \"\"\"Prepares the entire request with the given parameters.\"\"\"\n300 \n301         self.prepare_method(method)\n302         self.prepare_url(url, params)\n303         self.prepare_headers(headers)\n304         self.prepare_cookies(cookies)\n305         self.prepare_body(data, files, json)\n306         self.prepare_auth(auth, url)\n307 \n308         # Note that prepare_auth must be last to enable authentication schemes\n309         # such as OAuth to work on a fully prepared request.\n310 \n311         # This MUST go after prepare_auth. Authenticators could add a hook\n312         self.prepare_hooks(hooks)\n313 \n314     def __repr__(self):\n315         return '<PreparedRequest [%s]>' % (self.method)\n316 \n317     def copy(self):\n318         p = PreparedRequest()\n319         p.method = self.method\n320         p.url = self.url\n321         p.headers = self.headers.copy() if self.headers is not None else None\n322         p._cookies = _copy_cookie_jar(self._cookies)\n323         p.body = self.body\n324         p.hooks = self.hooks\n325         p._body_position = self._body_position\n326         return p\n327 \n328     def prepare_method(self, method):\n329         \"\"\"Prepares the given HTTP method.\"\"\"\n330         self.method = method\n331         if self.method is not None:\n332             self.method = to_native_string(self.method.upper())\n333 \n334     def prepare_url(self, url, params):\n335         \"\"\"Prepares the given HTTP URL.\"\"\"\n336         #: Accept objects that have string representations.\n337         #: We're unable to blindly call unicode/str functions\n338         #: as this will include the bytestring indicator (b'')\n339         #: on python 3.x.\n340         #: https://github.com/kennethreitz/requests/pull/2238\n341         if isinstance(url, bytes):\n342             url = url.decode('utf8')\n343         else:\n344             url = unicode(url) if is_py2 else str(url)\n345 \n346         # Remove leading whitespaces from url\n347         url = url.lstrip()\n348 \n349         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n350         # `data`, `http+unix` etc to work around exceptions from `url_parse`,\n351         # which handles RFC 3986 only.\n352         if ':' in url and not url.lower().startswith(('http://', 'https://')):\n353             self.url = url\n354             return\n355 \n356         # Support for unicode domain names and paths.\n357         try:\n358             scheme, auth, host, port, path, query, fragment = parse_url(url)\n359         except LocationParseError as e:\n360             raise InvalidURL(*e.args)\n361 \n362         if not scheme:\n363             error = (\"Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?\")\n364             error = error.format(to_native_string(url, 'utf8'))\n365 \n366             raise MissingSchema(error)\n367 \n368         if not host:\n369             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n370 \n371         # In general, we want to try IDNA encoding every hostname, as that\n372         # allows users to automatically get the correct behaviour. However,\n373         # we\u2019re quite strict about IDNA encoding, so certain valid hostnames\n374         # may fail to encode. On failure, we verify the hostname meets a\n375         # minimum standard of only containing ASCII characters, and not starting\n376         # with a wildcard (*), before allowing the unencoded hostname through.\n377         try:\n378             host = idna.encode(host, uts46=True).decode('utf-8')\n379         except (UnicodeError, idna.IDNAError):\n380             if not unicode_is_ascii(host) or host.startswith(u'*'):\n381                 raise InvalidURL('URL has an invalid label.')\n382 \n383         # Carefully reconstruct the network location\n384         netloc = auth or ''\n385         if netloc:\n386             netloc += '@'\n387         netloc += host\n388         if port:\n389             netloc += ':' + str(port)\n390 \n391         # Bare domains aren't valid URLs.\n392         if not path:\n393             path = '/'\n394 \n395         if is_py2:\n396             if isinstance(scheme, str):\n397                 scheme = scheme.encode('utf-8')\n398             if isinstance(netloc, str):\n399                 netloc = netloc.encode('utf-8')\n400             if isinstance(path, str):\n401                 path = path.encode('utf-8')\n402             if isinstance(query, str):\n403                 query = query.encode('utf-8')\n404             if isinstance(fragment, str):\n405                 fragment = fragment.encode('utf-8')\n406 \n407         if isinstance(params, (str, bytes)):\n408             params = to_native_string(params)\n409 \n410         enc_params = self._encode_params(params)\n411         if enc_params:\n412             if query:\n413                 query = '%s&%s' % (query, enc_params)\n414             else:\n415                 query = enc_params\n416 \n417         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n418         self.url = url\n419 \n420     def prepare_headers(self, headers):\n421         \"\"\"Prepares the given HTTP headers.\"\"\"\n422 \n423         self.headers = CaseInsensitiveDict()\n424         if headers:\n425             for header in headers.items():\n426                 # Raise exception on invalid header value.\n427                 check_header_validity(header)\n428                 name, value = header\n429                 self.headers[to_native_string(name)] = value\n430 \n431     def prepare_body(self, data, files, json=None):\n432         \"\"\"Prepares the given HTTP body data.\"\"\"\n433 \n434         # Check if file, fo, generator, iterator.\n435         # If not, run through normal process.\n436 \n437         # Nottin' on you.\n438         body = None\n439         content_type = None\n440 \n441         if not data and json is not None:\n442             # urllib3 requires a bytes-like body. Python 2's json.dumps\n443             # provides this natively, but Python 3 gives a Unicode string.\n444             content_type = 'application/json'\n445             body = complexjson.dumps(json)\n446             if not isinstance(body, bytes):\n447                 body = body.encode('utf-8')\n448 \n449         is_stream = all([\n450             hasattr(data, '__iter__'),\n451             not isinstance(data, (basestring, list, tuple, collections.Mapping))\n452         ])\n453 \n454         try:\n455             length = super_len(data)\n456         except (TypeError, AttributeError, UnsupportedOperation):\n457             length = None\n458 \n459         if is_stream:\n460             body = data\n461 \n462             if getattr(body, 'tell', None) is not None:\n463                 # Record the current file position before reading.\n464                 # This will allow us to rewind a file in the event\n465                 # of a redirect.\n466                 try:\n467                     self._body_position = body.tell()\n468                 except (IOError, OSError):\n469                     # This differentiates from None, allowing us to catch\n470                     # a failed `tell()` later when trying to rewind the body\n471                     self._body_position = object()\n472 \n473             if files:\n474                 raise NotImplementedError('Streamed bodies and files are mutually exclusive.')\n475 \n476             if length:\n477                 self.headers['Content-Length'] = builtin_str(length)\n478             else:\n479                 self.headers['Transfer-Encoding'] = 'chunked'\n480         else:\n481             # Multi-part file uploads.\n482             if files:\n483                 (body, content_type) = self._encode_files(files, data)\n484             else:\n485                 if data:\n486                     body = self._encode_params(data)\n487                     if isinstance(data, basestring) or hasattr(data, 'read'):\n488                         content_type = None\n489                     else:\n490                         content_type = 'application/x-www-form-urlencoded'\n491 \n492             self.prepare_content_length(body)\n493 \n494             # Add content-type if it wasn't explicitly provided.\n495             if content_type and ('content-type' not in self.headers):\n496                 self.headers['Content-Type'] = content_type\n497 \n498         self.body = body\n499 \n500     def prepare_content_length(self, body):\n501         \"\"\"Prepare Content-Length header based on request method and body\"\"\"\n502         if body is not None:\n503             length = super_len(body)\n504             if length:\n505                 # If length exists, set it. Otherwise, we fallback\n506                 # to Transfer-Encoding: chunked.\n507                 self.headers['Content-Length'] = builtin_str(length)\n508         elif self.method not in ('GET', 'HEAD') and self.headers.get('Content-Length') is None:\n509             # Set Content-Length to 0 for methods that can have a body\n510             # but don't provide one. (i.e. not GET or HEAD)\n511             self.headers['Content-Length'] = '0'\n512 \n513     def prepare_auth(self, auth, url=''):\n514         \"\"\"Prepares the given HTTP auth data.\"\"\"\n515 \n516         # If no Auth is explicitly provided, extract it from the URL first.\n517         if auth is None:\n518             url_auth = get_auth_from_url(self.url)\n519             auth = url_auth if any(url_auth) else None\n520 \n521         if auth:\n522             if isinstance(auth, tuple) and len(auth) == 2:\n523                 # special-case basic HTTP auth\n524                 auth = HTTPBasicAuth(*auth)\n525 \n526             # Allow auth to make its changes.\n527             r = auth(self)\n528 \n529             # Update self to reflect the auth changes.\n530             self.__dict__.update(r.__dict__)\n531 \n532             # Recompute Content-Length\n533             self.prepare_content_length(self.body)\n534 \n535     def prepare_cookies(self, cookies):\n536         \"\"\"Prepares the given HTTP cookie data.\n537 \n538         This function eventually generates a ``Cookie`` header from the\n539         given cookies using cookielib. Due to cookielib's design, the header\n540         will not be regenerated if it already exists, meaning this function\n541         can only be called once for the life of the\n542         :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls\n543         to ``prepare_cookies`` will have no actual effect, unless the \"Cookie\"\n544         header is removed beforehand.\n545         \"\"\"\n546         if isinstance(cookies, cookielib.CookieJar):\n547             self._cookies = cookies\n548         else:\n549             self._cookies = cookiejar_from_dict(cookies)\n550 \n551         cookie_header = get_cookie_header(self._cookies, self)\n552         if cookie_header is not None:\n553             self.headers['Cookie'] = cookie_header\n554 \n555     def prepare_hooks(self, hooks):\n556         \"\"\"Prepares the given hooks.\"\"\"\n557         # hooks can be passed as None to the prepare method and to this\n558         # method. To prevent iterating over None, simply use an empty list\n559         # if hooks is False-y\n560         hooks = hooks or []\n561         for event in hooks:\n562             self.register_hook(event, hooks[event])\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]