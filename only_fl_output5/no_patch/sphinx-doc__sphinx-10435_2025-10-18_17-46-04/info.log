2025-10-18 17:46:04.661 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 17:46:07.064 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=856, output_tokens=13, cost=0.008950
2025-10-18 17:46:22.505 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1036, output_tokens=734, cost=0.032380
2025-10-18 17:46:23.528 | INFO     | registered non reproducing test 0
2025-10-18 17:46:39.570 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2290, output_tokens=737, cost=0.045010
2025-10-18 17:46:40.604 | INFO     | registered non reproducing test 1
2025-10-18 17:47:06.841 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2477, output_tokens=809, cost=0.049040
2025-10-18 17:47:12.392 | INFO     | registered non reproducing test 2
2025-10-18 17:47:12.392 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 17:47:12.398 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 17:47:19.445 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1160, output_tokens=338, cost=0.021740
2025-10-18 17:47:19.454 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 17:47:22.924 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=77, cost=0.009230
2025-10-18 17:47:22.925 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\sphinxcode{\\\\sphinxupquote{")': old result is ['\\\\sphinxcode{\\\\sphinxupquote{'], new result  is ['\\sphinxcode{\\sphinxupquote{']
2025-10-18 17:47:22.926 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\PYG")': old result is ['\\\\PYG'], new result  is ['\\PYG']
2025-10-18 17:47:22.927 | DEBUG    | Extracted a valid json.
2025-10-18 17:47:22.927 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"\\\\sphinxcode{\\\\sphinxupquote{\")",
        "search_code(\"\\\\PYG\")",
        "search_method(\"visit_Inline\")",
        "search_method(\"depart_Inline\")",
        "search_code(\".. role:: python(code)\")"
    ],
    "bug_locations": []
}
2025-10-18 17:47:22.930 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\sphinxcode{\\\\sphinxupquote{")': old result is ['\\\\sphinxcode{\\\\sphinxupquote{'], new result  is ['\\sphinxcode{\\sphinxupquote{']
2025-10-18 17:47:22.940 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\PYG")': old result is ['\\\\PYG'], new result  is ['\\PYG']
2025-10-18 17:47:22.979 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 17:47:22.980 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 17:47:38.464 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2085, output_tokens=730, cost=0.042750
2025-10-18 17:47:38.476 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 17:47:47.670 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3031, output_tokens=373, cost=0.041500
2025-10-18 17:47:47.674 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 17:47:52.198 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=727, output_tokens=132, cost=0.011230
2025-10-18 17:47:52.199 | DEBUG    | Extracted a valid json.
2025-10-18 17:47:52.199 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/highlighting.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that when inline code is converted to LaTeX, no additional whitespace is introduced at the beginning or end of the inline code."
        },
        {
            "file": "sphinx/roles.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure roles that represent inline code, when rendered to LaTeX, maintain their content without extra whitespace padding, preserving the exact intended appearance."
        }
    ]
}
2025-10-18 17:47:52.204 | DEBUG    | Bug location extracted successfully: [<file>sphinx/highlighting.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Highlight code blocks using Pygments."""
2 
3 from functools import partial
4 from importlib import import_module
5 from typing import Any, Dict
6 
7 from packaging import version
8 from pygments import __version__ as pygmentsversion
9 from pygments import highlight
10 from pygments.filters import ErrorToken
11 from pygments.formatter import Formatter
12 from pygments.formatters import HtmlFormatter, LatexFormatter
13 from pygments.lexer import Lexer
14 from pygments.lexers import (CLexer, Python3Lexer, PythonConsoleLexer, PythonLexer, RstLexer,
15                              TextLexer, get_lexer_by_name, guess_lexer)
16 from pygments.style import Style
17 from pygments.styles import get_style_by_name
18 from pygments.util import ClassNotFound
19 
20 from sphinx.locale import __
21 from sphinx.pygments_styles import NoneStyle, SphinxStyle
22 from sphinx.util import logging, texescape
23 
24 logger = logging.getLogger(__name__)
25 
26 lexers: Dict[str, Lexer] = {}
27 lexer_classes: Dict[str, Lexer] = {
28     'none': partial(TextLexer, stripnl=False),
29     'python': partial(PythonLexer, stripnl=False),
30     'python3': partial(Python3Lexer, stripnl=False),
31     'pycon': partial(PythonConsoleLexer, stripnl=False),
32     'pycon3': partial(PythonConsoleLexer, python3=True, stripnl=False),
33     'rest': partial(RstLexer, stripnl=False),
34     'c': partial(CLexer, stripnl=False),
35 }
36 
37 
38 escape_hl_chars = {ord('\\'): '\\PYGZbs{}',
39                    ord('{'): '\\PYGZob{}',
40                    ord('}'): '\\PYGZcb{}'}
41 
42 # used if Pygments is available
43 # use textcomp quote to get a true single quote
44 _LATEX_ADD_STYLES = r'''
45 \renewcommand\PYGZsq{\textquotesingle}
46 '''
47 # fix extra space between lines when Pygments highlighting uses \fcolorbox
48 # add a {..} to limit \fboxsep scope, and force \fcolorbox use correct value
49 # cf pygments #1708 which makes this unneeded for Pygments > 2.7.4
50 _LATEX_ADD_STYLES_FIXPYG = r'''
51 \makeatletter
52 % fix for Pygments <= 2.7.4
53 \let\spx@original@fcolorbox\fcolorbox
54 \def\spx@fixpyg@fcolorbox{\fboxsep-\fboxrule\spx@original@fcolorbox}
55 \def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+%
56              {\let\fcolorbox\spx@fixpyg@fcolorbox\PYG@do{#2}}}
57 \makeatother
58 '''
59 if version.parse(pygmentsversion).release <= (2, 7, 4):
60     _LATEX_ADD_STYLES += _LATEX_ADD_STYLES_FIXPYG
61 
62 
63 class PygmentsBridge:
64     # Set these attributes if you want to have different Pygments formatters
65     # than the default ones.
66     html_formatter = HtmlFormatter
67     latex_formatter = LatexFormatter
68 
69     def __init__(self, dest: str = 'html', stylename: str = 'sphinx',
70                  latex_engine: str = None) -> None:
71         self.dest = dest
72         self.latex_engine = latex_engine
73 
74         style = self.get_style(stylename)
75         self.formatter_args: Dict[str, Any] = {'style': style}
76         if dest == 'html':
77             self.formatter = self.html_formatter
78         else:
79             self.formatter = self.latex_formatter
80             self.formatter_args['commandprefix'] = 'PYG'
81 
82     def get_style(self, stylename: str) -> Style:
83         if stylename is None or stylename == 'sphinx':
84             return SphinxStyle
85         elif stylename == 'none':
86             return NoneStyle
87         elif '.' in stylename:
88             module, stylename = stylename.rsplit('.', 1)
89             return getattr(import_module(module), stylename)
90         else:
91             return get_style_by_name(stylename)
92 
93     def get_formatter(self, **kwargs: Any) -> Formatter:
94         kwargs.update(self.formatter_args)
95         return self.formatter(**kwargs)
96 
97     def get_lexer(self, source: str, lang: str, opts: Dict = None,
98                   force: bool = False, location: Any = None) -> Lexer:
99         if not opts:
100             opts = {}
101 
102         # find out which lexer to use
103         if lang in ('py', 'python'):
104             if source.startswith('>>>'):
105                 # interactive session
106                 lang = 'pycon'
107             else:
108                 lang = 'python'
109         elif lang in ('py3', 'python3', 'default'):
110             if source.startswith('>>>'):
111                 lang = 'pycon3'
112             else:
113                 lang = 'python3'
114 
115         if lang in lexers:
116             # just return custom lexers here (without installing raiseonerror filter)
117             return lexers[lang]
118         elif lang in lexer_classes:
119             lexer = lexer_classes[lang](**opts)
120         else:
121             try:
122                 if lang == 'guess':
123                     lexer = guess_lexer(source, **opts)
124                 else:
125                     lexer = get_lexer_by_name(lang, **opts)
126             except ClassNotFound:
127                 logger.warning(__('Pygments lexer name %r is not known'), lang,
128                                location=location)
129                 lexer = lexer_classes['none'](**opts)
130 
131         if not force:
132             lexer.add_filter('raiseonerror')
133 
134         return lexer
135 
136     def highlight_block(self, source: str, lang: str, opts: Dict = None,
137                         force: bool = False, location: Any = None, **kwargs: Any) -> str:
138         if not isinstance(source, str):
139             source = source.decode()
140 
141         lexer = self.get_lexer(source, lang, opts, force, location)
142 
143         # highlight via Pygments
144         formatter = self.get_formatter(**kwargs)
145         try:
146             hlsource = highlight(source, lexer, formatter)
147         except ErrorToken:
148             # this is most probably not the selected language,
149             # so let it pass unhighlighted
150             if lang == 'default':
151                 pass  # automatic highlighting failed.
152             else:
153                 logger.warning(__('Could not lex literal_block as "%s". '
154                                   'Highlighting skipped.'), lang,
155                                type='misc', subtype='highlighting_failure',
156                                location=location)
157             lexer = self.get_lexer(source, 'none', opts, force, location)
158             hlsource = highlight(source, lexer, formatter)
159 
160         if self.dest == 'html':
161             return hlsource
162         else:
163             # MEMO: this is done to escape Unicode chars with non-Unicode engines
164             return texescape.hlescape(hlsource, self.latex_engine)
165 
166     def get_stylesheet(self) -> str:
167         formatter = self.get_formatter()
168         if self.dest == 'html':
169             return formatter.get_style_defs('.highlight')
170         else:
171             return formatter.get_style_defs() + _LATEX_ADD_STYLES

</code><intended_behavior>Ensure that when inline code is converted to LaTeX, no additional whitespace is introduced at the beginning or end of the inline code.</intended_behavior>, <file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Handlers for additional ReST roles."""
2 
3 import re
4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple, Type
5 
6 import docutils.parsers.rst.directives
7 import docutils.parsers.rst.roles
8 import docutils.parsers.rst.states
9 from docutils import nodes, utils
10 from docutils.nodes import Element, Node, TextElement, system_message
11 
12 from sphinx import addnodes
13 from sphinx.locale import _, __
14 from sphinx.util import ws_re
15 from sphinx.util.docutils import ReferenceRole, SphinxRole
16 from sphinx.util.typing import RoleFunction
17 
18 if TYPE_CHECKING:
19     from sphinx.application import Sphinx
20     from sphinx.environment import BuildEnvironment
21 
22 
23 generic_docroles = {
24     'command': addnodes.literal_strong,
25     'dfn': nodes.emphasis,
26     'kbd': nodes.literal,
27     'mailheader': addnodes.literal_emphasis,
28     'makevar': addnodes.literal_strong,
29     'manpage': addnodes.manpage,
30     'mimetype': addnodes.literal_emphasis,
31     'newsgroup': addnodes.literal_emphasis,
32     'program': addnodes.literal_strong,  # XXX should be an x-ref
33     'regexp': nodes.literal,
34 }
35 
36 
37 # -- generic cross-reference role ----------------------------------------------
38 
39 class XRefRole(ReferenceRole):
40     """
41     A generic cross-referencing role.  To create a callable that can be used as
42     a role function, create an instance of this class.
43 
44     The general features of this role are:
45 
46     * Automatic creation of a reference and a content node.
47     * Optional separation of title and target with `title <target>`.
48     * The implementation is a class rather than a function to make
49       customization easier.
50 
51     Customization can be done in two ways:
52 
53     * Supplying constructor parameters:
54       * `fix_parens` to normalize parentheses (strip from target, and add to
55         title if configured)
56       * `lowercase` to lowercase the target
57       * `nodeclass` and `innernodeclass` select the node classes for
58         the reference and the content node
59 
60     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
61     """
62 
63     nodeclass: Type[Element] = addnodes.pending_xref
64     innernodeclass: Type[TextElement] = nodes.literal
65 
66     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
67                  nodeclass: Type[Element] = None, innernodeclass: Type[TextElement] = None,
68                  warn_dangling: bool = False) -> None:
69         self.fix_parens = fix_parens
70         self.lowercase = lowercase
71         self.warn_dangling = warn_dangling
72         if nodeclass is not None:
73             self.nodeclass = nodeclass
74         if innernodeclass is not None:
75             self.innernodeclass = innernodeclass
76 
77         super().__init__()
78 
79     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
80         if not self.has_explicit_title:
81             if title.endswith('()'):
82                 # remove parentheses
83                 title = title[:-2]
84             if self.config.add_function_parentheses:
85                 # add them back to all occurrences if configured
86                 title += '()'
87         # remove parentheses from the target too
88         if target.endswith('()'):
89             target = target[:-2]
90         return title, target
91 
92     def run(self) -> Tuple[List[Node], List[system_message]]:
93         if ':' not in self.name:
94             self.refdomain, self.reftype = '', self.name
95             self.classes = ['xref', self.reftype]
96         else:
97             self.refdomain, self.reftype = self.name.split(':', 1)
98             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
99 
100         if self.disabled:
101             return self.create_non_xref_node()
102         else:
103             return self.create_xref_node()
104 
105     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
106         text = utils.unescape(self.text[1:])
107         if self.fix_parens:
108             self.has_explicit_title = False  # treat as implicit
109             text, target = self.update_title_and_target(text, "")
110 
111         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
112         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
113 
114     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
115         target = self.target
116         title = self.title
117         if self.lowercase:
118             target = target.lower()
119         if self.fix_parens:
120             title, target = self.update_title_and_target(title, target)
121 
122         # create the reference node
123         options = {'refdoc': self.env.docname,
124                    'refdomain': self.refdomain,
125                    'reftype': self.reftype,
126                    'refexplicit': self.has_explicit_title,
127                    'refwarn': self.warn_dangling}
128         refnode = self.nodeclass(self.rawtext, **options)
129         self.set_source_info(refnode)
130 
131         # determine the target and title for the class
132         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
133                                           title, target)
134         refnode['reftarget'] = target
135         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
136 
137         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
138 
139     # methods that can be overwritten
140 
141     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
142                      title: str, target: str) -> Tuple[str, str]:
143         """Called after parsing title and target text, and creating the
144         reference node (given in *refnode*).  This method can alter the
145         reference node and must return a new (or the same) ``(title, target)``
146         tuple.
147         """
148         return title, ws_re.sub(' ', target)
149 
150     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
151                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
152         """Called before returning the finished nodes.  *node* is the reference
153         node if one was created (*is_ref* is then true), else the content node.
154         This method can add other nodes and must return a ``(nodes, messages)``
155         tuple (the usual return value of a role function).
156         """
157         return [node], []
158 
159 
160 class AnyXRefRole(XRefRole):
161     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
162                      title: str, target: str) -> Tuple[str, str]:
163         result = super().process_link(env, refnode, has_explicit_title, title, target)
164         # add all possible context info (i.e. std:program, py:module etc.)
165         refnode.attributes.update(env.ref_context)
166         return result
167 
168 
169 class PEP(ReferenceRole):
170     def run(self) -> Tuple[List[Node], List[system_message]]:
171         target_id = 'index-%s' % self.env.new_serialno('index')
172         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
173                     target_id, '', None)]
174 
175         index = addnodes.index(entries=entries)
176         target = nodes.target('', '', ids=[target_id])
177         self.inliner.document.note_explicit_target(target)
178 
179         try:
180             refuri = self.build_uri()
181             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
182             if self.has_explicit_title:
183                 reference += nodes.strong(self.title, self.title)
184             else:
185                 title = "PEP " + self.title
186                 reference += nodes.strong(title, title)
187         except ValueError:
188             msg = self.inliner.reporter.error(__('invalid PEP number %s') % self.target,
189                                               line=self.lineno)
190             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
191             return [prb], [msg]
192 
193         return [index, target, reference], []
194 
195     def build_uri(self) -> str:
196         base_url = self.inliner.document.settings.pep_base_url
197         ret = self.target.split('#', 1)
198         if len(ret) == 2:
199             return base_url + 'pep-%04d/#%s' % (int(ret[0]), ret[1])
200         else:
201             return base_url + 'pep-%04d/' % int(ret[0])
202 
203 
204 class RFC(ReferenceRole):
205     def run(self) -> Tuple[List[Node], List[system_message]]:
206         target_id = 'index-%s' % self.env.new_serialno('index')
207         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
208 
209         index = addnodes.index(entries=entries)
210         target = nodes.target('', '', ids=[target_id])
211         self.inliner.document.note_explicit_target(target)
212 
213         try:
214             refuri = self.build_uri()
215             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
216             if self.has_explicit_title:
217                 reference += nodes.strong(self.title, self.title)
218             else:
219                 title = "RFC " + self.title
220                 reference += nodes.strong(title, title)
221         except ValueError:
222             msg = self.inliner.reporter.error(__('invalid RFC number %s') % self.target,
223                                               line=self.lineno)
224             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
225             return [prb], [msg]
226 
227         return [index, target, reference], []
228 
229     def build_uri(self) -> str:
230         base_url = self.inliner.document.settings.rfc_base_url
231         ret = self.target.split('#', 1)
232         if len(ret) == 2:
233             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
234         else:
235             return base_url + self.inliner.rfc_url % int(ret[0])
236 
237 
238 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
239 
240 
241 class GUILabel(SphinxRole):
242     amp_re = re.compile(r'(?<!&)&(?![&\s])')
243 
244     def run(self) -> Tuple[List[Node], List[system_message]]:
245         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
246         spans = self.amp_re.split(self.text)
247         node += nodes.Text(spans.pop(0))
248         for span in spans:
249             span = span.replace('&&', '&')
250 
251             letter = nodes.Text(span[0])
252             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
253             node += accelerator
254             node += nodes.Text(span[1:])
255 
256         return [node], []
257 
258 
259 class MenuSelection(GUILabel):
260     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
261 
262     def run(self) -> Tuple[List[Node], List[system_message]]:
263         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
264         return super().run()
265 
266 
267 _litvar_re = re.compile('{([^}]+)}')
268 parens_re = re.compile(r'(\\*{|\\*})')
269 
270 
271 class EmphasizedLiteral(SphinxRole):
272     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
273 
274     def run(self) -> Tuple[List[Node], List[system_message]]:
275         children = self.parse(self.text)
276         node = nodes.literal(self.rawtext, '', *children,
277                              role=self.name.lower(), classes=[self.name])
278 
279         return [node], []
280 
281     def parse(self, text: str) -> List[Node]:
282         result: List[Node] = []
283 
284         stack = ['']
285         for part in self.parens_re.split(text):
286             if part == '\\\\':  # escaped backslash
287                 stack[-1] += '\\'
288             elif part == '{':
289                 if len(stack) >= 2 and stack[-2] == "{":  # nested
290                     stack[-1] += "{"
291                 else:
292                     # start emphasis
293                     stack.append('{')
294                     stack.append('')
295             elif part == '}':
296                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
297                     # emphasized word found
298                     if stack[0]:
299                         result.append(nodes.Text(stack[0]))
300                     result.append(nodes.emphasis(stack[2], stack[2]))
301                     stack = ['']
302                 else:
303                     # emphasized word not found; the rparen is not a special symbol
304                     stack.append('}')
305                     stack = [''.join(stack)]
306             elif part == '\\{':  # escaped left-brace
307                 stack[-1] += '{'
308             elif part == '\\}':  # escaped right-brace
309                 stack[-1] += '}'
310             else:  # others (containing escaped braces)
311                 stack[-1] += part
312 
313         if ''.join(stack):
314             # remaining is treated as Text
315             text = ''.join(stack)
316             result.append(nodes.Text(text))
317 
318         return result
319 
320 
321 _abbr_re = re.compile(r'\((.*)\)$', re.S)
322 
323 
324 class Abbreviation(SphinxRole):
325     abbr_re = re.compile(r'\((.*)\)$', re.S)
326 
327     def run(self) -> Tuple[List[Node], List[system_message]]:
328         options = self.options.copy()
329         matched = self.abbr_re.search(self.text)
330         if matched:
331             text = self.text[:matched.start()].strip()
332             options['explanation'] = matched.group(1)
333         else:
334             text = self.text
335 
336         return [nodes.abbreviation(self.rawtext, text, **options)], []
337 
338 
339 # Sphinx provides the `code-block` directive for highlighting code blocks.
340 # Docutils provides the `code` role which in theory can be used similarly by
341 # defining a custom role for a given programming language:
342 #
343 #     .. .. role:: python(code)
344 #          :language: python
345 #          :class: highlight
346 #
347 # In practice this does not produce correct highlighting because it uses a
348 # separate highlighting mechanism that results in the "long" pygments class
349 # names rather than "short" pygments class names produced by the Sphinx
350 # `code-block` directive and for which this extension contains CSS rules.
351 #
352 # In addition, even if that issue is fixed, because the highlighting
353 # implementation in docutils, despite being based on pygments, differs from that
354 # used by Sphinx, the output does not exactly match that produced by the Sphinx
355 # `code-block` directive.
356 #
357 # This issue is noted here: //github.com/sphinx-doc/sphinx/issues/5157
358 #
359 # This overrides the docutils `code` role to perform highlighting in the same
360 # way as the Sphinx `code-block` directive.
361 #
362 # TODO: Change to use `SphinxRole` once SphinxRole is fixed to support options.
363 def code_role(name: str, rawtext: str, text: str, lineno: int,
364               inliner: docutils.parsers.rst.states.Inliner,
365               options: Dict = {}, content: List[str] = []
366               ) -> Tuple[List[Node], List[system_message]]:
367     options = options.copy()
368     docutils.parsers.rst.roles.set_classes(options)
369     language = options.get('language', '')
370     classes = ['code']
371     if language:
372         classes.append('highlight')
373     if 'classes' in options:
374         classes.extend(options['classes'])
375 
376     if language and language not in classes:
377         classes.append(language)
378 
379     node = nodes.literal(rawtext, text, classes=classes, language=language)
380 
381     return [node], []
382 
383 
384 code_role.options = {  # type: ignore
385     'class': docutils.parsers.rst.directives.class_option,
386     'language': docutils.parsers.rst.directives.unchanged,
387 }
388 
389 
390 specific_docroles: Dict[str, RoleFunction] = {
391     # links to download references
392     'download': XRefRole(nodeclass=addnodes.download_reference),
393     # links to anything
394     'any': AnyXRefRole(warn_dangling=True),
395 
396     'pep': PEP(),
397     'rfc': RFC(),
398     'guilabel': GUILabel(),
399     'menuselection': MenuSelection(),
400     'file': EmphasizedLiteral(),
401     'samp': EmphasizedLiteral(),
402     'abbr': Abbreviation(),
403 }
404 
405 
406 def setup(app: "Sphinx") -> Dict[str, Any]:
407     from docutils.parsers.rst import roles
408 
409     for rolename, nodeclass in generic_docroles.items():
410         generic = roles.GenericRole(rolename, nodeclass)
411         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
412         roles.register_local_role(rolename, role)
413 
414     for rolename, func in specific_docroles.items():
415         roles.register_local_role(rolename, func)
416 
417     # Since docutils registers it as a canonical role, override it as a
418     # canonical role as well.
419     roles.register_canonical_role('code', code_role)
420 
421     return {
422         'version': 'builtin',
423         'parallel_read_safe': True,
424         'parallel_write_safe': True,
425     }

</code><intended_behavior>Ensure roles that represent inline code, when rendered to LaTeX, maintain their content without extra whitespace padding, preserving the exact intended appearance.</intended_behavior>]
2025-10-18 17:47:52.204 | INFO     | Search completed. Bug locations: [<file>sphinx/highlighting.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Highlight code blocks using Pygments."""
2 
3 from functools import partial
4 from importlib import import_module
5 from typing import Any, Dict
6 
7 from packaging import version
8 from pygments import __version__ as pygmentsversion
9 from pygments import highlight
10 from pygments.filters import ErrorToken
11 from pygments.formatter import Formatter
12 from pygments.formatters import HtmlFormatter, LatexFormatter
13 from pygments.lexer import Lexer
14 from pygments.lexers import (CLexer, Python3Lexer, PythonConsoleLexer, PythonLexer, RstLexer,
15                              TextLexer, get_lexer_by_name, guess_lexer)
16 from pygments.style import Style
17 from pygments.styles import get_style_by_name
18 from pygments.util import ClassNotFound
19 
20 from sphinx.locale import __
21 from sphinx.pygments_styles import NoneStyle, SphinxStyle
22 from sphinx.util import logging, texescape
23 
24 logger = logging.getLogger(__name__)
25 
26 lexers: Dict[str, Lexer] = {}
27 lexer_classes: Dict[str, Lexer] = {
28     'none': partial(TextLexer, stripnl=False),
29     'python': partial(PythonLexer, stripnl=False),
30     'python3': partial(Python3Lexer, stripnl=False),
31     'pycon': partial(PythonConsoleLexer, stripnl=False),
32     'pycon3': partial(PythonConsoleLexer, python3=True, stripnl=False),
33     'rest': partial(RstLexer, stripnl=False),
34     'c': partial(CLexer, stripnl=False),
35 }
36 
37 
38 escape_hl_chars = {ord('\\'): '\\PYGZbs{}',
39                    ord('{'): '\\PYGZob{}',
40                    ord('}'): '\\PYGZcb{}'}
41 
42 # used if Pygments is available
43 # use textcomp quote to get a true single quote
44 _LATEX_ADD_STYLES = r'''
45 \renewcommand\PYGZsq{\textquotesingle}
46 '''
47 # fix extra space between lines when Pygments highlighting uses \fcolorbox
48 # add a {..} to limit \fboxsep scope, and force \fcolorbox use correct value
49 # cf pygments #1708 which makes this unneeded for Pygments > 2.7.4
50 _LATEX_ADD_STYLES_FIXPYG = r'''
51 \makeatletter
52 % fix for Pygments <= 2.7.4
53 \let\spx@original@fcolorbox\fcolorbox
54 \def\spx@fixpyg@fcolorbox{\fboxsep-\fboxrule\spx@original@fcolorbox}
55 \def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+%
56              {\let\fcolorbox\spx@fixpyg@fcolorbox\PYG@do{#2}}}
57 \makeatother
58 '''
59 if version.parse(pygmentsversion).release <= (2, 7, 4):
60     _LATEX_ADD_STYLES += _LATEX_ADD_STYLES_FIXPYG
61 
62 
63 class PygmentsBridge:
64     # Set these attributes if you want to have different Pygments formatters
65     # than the default ones.
66     html_formatter = HtmlFormatter
67     latex_formatter = LatexFormatter
68 
69     def __init__(self, dest: str = 'html', stylename: str = 'sphinx',
70                  latex_engine: str = None) -> None:
71         self.dest = dest
72         self.latex_engine = latex_engine
73 
74         style = self.get_style(stylename)
75         self.formatter_args: Dict[str, Any] = {'style': style}
76         if dest == 'html':
77             self.formatter = self.html_formatter
78         else:
79             self.formatter = self.latex_formatter
80             self.formatter_args['commandprefix'] = 'PYG'
81 
82     def get_style(self, stylename: str) -> Style:
83         if stylename is None or stylename == 'sphinx':
84             return SphinxStyle
85         elif stylename == 'none':
86             return NoneStyle
87         elif '.' in stylename:
88             module, stylename = stylename.rsplit('.', 1)
89             return getattr(import_module(module), stylename)
90         else:
91             return get_style_by_name(stylename)
92 
93     def get_formatter(self, **kwargs: Any) -> Formatter:
94         kwargs.update(self.formatter_args)
95         return self.formatter(**kwargs)
96 
97     def get_lexer(self, source: str, lang: str, opts: Dict = None,
98                   force: bool = False, location: Any = None) -> Lexer:
99         if not opts:
100             opts = {}
101 
102         # find out which lexer to use
103         if lang in ('py', 'python'):
104             if source.startswith('>>>'):
105                 # interactive session
106                 lang = 'pycon'
107             else:
108                 lang = 'python'
109         elif lang in ('py3', 'python3', 'default'):
110             if source.startswith('>>>'):
111                 lang = 'pycon3'
112             else:
113                 lang = 'python3'
114 
115         if lang in lexers:
116             # just return custom lexers here (without installing raiseonerror filter)
117             return lexers[lang]
118         elif lang in lexer_classes:
119             lexer = lexer_classes[lang](**opts)
120         else:
121             try:
122                 if lang == 'guess':
123                     lexer = guess_lexer(source, **opts)
124                 else:
125                     lexer = get_lexer_by_name(lang, **opts)
126             except ClassNotFound:
127                 logger.warning(__('Pygments lexer name %r is not known'), lang,
128                                location=location)
129                 lexer = lexer_classes['none'](**opts)
130 
131         if not force:
132             lexer.add_filter('raiseonerror')
133 
134         return lexer
135 
136     def highlight_block(self, source: str, lang: str, opts: Dict = None,
137                         force: bool = False, location: Any = None, **kwargs: Any) -> str:
138         if not isinstance(source, str):
139             source = source.decode()
140 
141         lexer = self.get_lexer(source, lang, opts, force, location)
142 
143         # highlight via Pygments
144         formatter = self.get_formatter(**kwargs)
145         try:
146             hlsource = highlight(source, lexer, formatter)
147         except ErrorToken:
148             # this is most probably not the selected language,
149             # so let it pass unhighlighted
150             if lang == 'default':
151                 pass  # automatic highlighting failed.
152             else:
153                 logger.warning(__('Could not lex literal_block as "%s". '
154                                   'Highlighting skipped.'), lang,
155                                type='misc', subtype='highlighting_failure',
156                                location=location)
157             lexer = self.get_lexer(source, 'none', opts, force, location)
158             hlsource = highlight(source, lexer, formatter)
159 
160         if self.dest == 'html':
161             return hlsource
162         else:
163             # MEMO: this is done to escape Unicode chars with non-Unicode engines
164             return texescape.hlescape(hlsource, self.latex_engine)
165 
166     def get_stylesheet(self) -> str:
167         formatter = self.get_formatter()
168         if self.dest == 'html':
169             return formatter.get_style_defs('.highlight')
170         else:
171             return formatter.get_style_defs() + _LATEX_ADD_STYLES

</code><intended_behavior>Ensure that when inline code is converted to LaTeX, no additional whitespace is introduced at the beginning or end of the inline code.</intended_behavior>, <file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Handlers for additional ReST roles."""
2 
3 import re
4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple, Type
5 
6 import docutils.parsers.rst.directives
7 import docutils.parsers.rst.roles
8 import docutils.parsers.rst.states
9 from docutils import nodes, utils
10 from docutils.nodes import Element, Node, TextElement, system_message
11 
12 from sphinx import addnodes
13 from sphinx.locale import _, __
14 from sphinx.util import ws_re
15 from sphinx.util.docutils import ReferenceRole, SphinxRole
16 from sphinx.util.typing import RoleFunction
17 
18 if TYPE_CHECKING:
19     from sphinx.application import Sphinx
20     from sphinx.environment import BuildEnvironment
21 
22 
23 generic_docroles = {
24     'command': addnodes.literal_strong,
25     'dfn': nodes.emphasis,
26     'kbd': nodes.literal,
27     'mailheader': addnodes.literal_emphasis,
28     'makevar': addnodes.literal_strong,
29     'manpage': addnodes.manpage,
30     'mimetype': addnodes.literal_emphasis,
31     'newsgroup': addnodes.literal_emphasis,
32     'program': addnodes.literal_strong,  # XXX should be an x-ref
33     'regexp': nodes.literal,
34 }
35 
36 
37 # -- generic cross-reference role ----------------------------------------------
38 
39 class XRefRole(ReferenceRole):
40     """
41     A generic cross-referencing role.  To create a callable that can be used as
42     a role function, create an instance of this class.
43 
44     The general features of this role are:
45 
46     * Automatic creation of a reference and a content node.
47     * Optional separation of title and target with `title <target>`.
48     * The implementation is a class rather than a function to make
49       customization easier.
50 
51     Customization can be done in two ways:
52 
53     * Supplying constructor parameters:
54       * `fix_parens` to normalize parentheses (strip from target, and add to
55         title if configured)
56       * `lowercase` to lowercase the target
57       * `nodeclass` and `innernodeclass` select the node classes for
58         the reference and the content node
59 
60     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
61     """
62 
63     nodeclass: Type[Element] = addnodes.pending_xref
64     innernodeclass: Type[TextElement] = nodes.literal
65 
66     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
67                  nodeclass: Type[Element] = None, innernodeclass: Type[TextElement] = None,
68                  warn_dangling: bool = False) -> None:
69         self.fix_parens = fix_parens
70         self.lowercase = lowercase
71         self.warn_dangling = warn_dangling
72         if nodeclass is not None:
73             self.nodeclass = nodeclass
74         if innernodeclass is not None:
75             self.innernodeclass = innernodeclass
76 
77         super().__init__()
78 
79     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
80         if not self.has_explicit_title:
81             if title.endswith('()'):
82                 # remove parentheses
83                 title = title[:-2]
84             if self.config.add_function_parentheses:
85                 # add them back to all occurrences if configured
86                 title += '()'
87         # remove parentheses from the target too
88         if target.endswith('()'):
89             target = target[:-2]
90         return title, target
91 
92     def run(self) -> Tuple[List[Node], List[system_message]]:
93         if ':' not in self.name:
94             self.refdomain, self.reftype = '', self.name
95             self.classes = ['xref', self.reftype]
96         else:
97             self.refdomain, self.reftype = self.name.split(':', 1)
98             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
99 
100         if self.disabled:
101             return self.create_non_xref_node()
102         else:
103             return self.create_xref_node()
104 
105     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
106         text = utils.unescape(self.text[1:])
107         if self.fix_parens:
108             self.has_explicit_title = False  # treat as implicit
109             text, target = self.update_title_and_target(text, "")
110 
111         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
112         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
113 
114     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
115         target = self.target
116         title = self.title
117         if self.lowercase:
118             target = target.lower()
119         if self.fix_parens:
120             title, target = self.update_title_and_target(title, target)
121 
122         # create the reference node
123         options = {'refdoc': self.env.docname,
124                    'refdomain': self.refdomain,
125                    'reftype': self.reftype,
126                    'refexplicit': self.has_explicit_title,
127                    'refwarn': self.warn_dangling}
128         refnode = self.nodeclass(self.rawtext, **options)
129         self.set_source_info(refnode)
130 
131         # determine the target and title for the class
132         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
133                                           title, target)
134         refnode['reftarget'] = target
135         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
136 
137         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
138 
139     # methods that can be overwritten
140 
141     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
142                      title: str, target: str) -> Tuple[str, str]:
143         """Called after parsing title and target text, and creating the
144         reference node (given in *refnode*).  This method can alter the
145         reference node and must return a new (or the same) ``(title, target)``
146         tuple.
147         """
148         return title, ws_re.sub(' ', target)
149 
150     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
151                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
152         """Called before returning the finished nodes.  *node* is the reference
153         node if one was created (*is_ref* is then true), else the content node.
154         This method can add other nodes and must return a ``(nodes, messages)``
155         tuple (the usual return value of a role function).
156         """
157         return [node], []
158 
159 
160 class AnyXRefRole(XRefRole):
161     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
162                      title: str, target: str) -> Tuple[str, str]:
163         result = super().process_link(env, refnode, has_explicit_title, title, target)
164         # add all possible context info (i.e. std:program, py:module etc.)
165         refnode.attributes.update(env.ref_context)
166         return result
167 
168 
169 class PEP(ReferenceRole):
170     def run(self) -> Tuple[List[Node], List[system_message]]:
171         target_id = 'index-%s' % self.env.new_serialno('index')
172         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
173                     target_id, '', None)]
174 
175         index = addnodes.index(entries=entries)
176         target = nodes.target('', '', ids=[target_id])
177         self.inliner.document.note_explicit_target(target)
178 
179         try:
180             refuri = self.build_uri()
181             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
182             if self.has_explicit_title:
183                 reference += nodes.strong(self.title, self.title)
184             else:
185                 title = "PEP " + self.title
186                 reference += nodes.strong(title, title)
187         except ValueError:
188             msg = self.inliner.reporter.error(__('invalid PEP number %s') % self.target,
189                                               line=self.lineno)
190             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
191             return [prb], [msg]
192 
193         return [index, target, reference], []
194 
195     def build_uri(self) -> str:
196         base_url = self.inliner.document.settings.pep_base_url
197         ret = self.target.split('#', 1)
198         if len(ret) == 2:
199             return base_url + 'pep-%04d/#%s' % (int(ret[0]), ret[1])
200         else:
201             return base_url + 'pep-%04d/' % int(ret[0])
202 
203 
204 class RFC(ReferenceRole):
205     def run(self) -> Tuple[List[Node], List[system_message]]:
206         target_id = 'index-%s' % self.env.new_serialno('index')
207         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
208 
209         index = addnodes.index(entries=entries)
210         target = nodes.target('', '', ids=[target_id])
211         self.inliner.document.note_explicit_target(target)
212 
213         try:
214             refuri = self.build_uri()
215             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
216             if self.has_explicit_title:
217                 reference += nodes.strong(self.title, self.title)
218             else:
219                 title = "RFC " + self.title
220                 reference += nodes.strong(title, title)
221         except ValueError:
222             msg = self.inliner.reporter.error(__('invalid RFC number %s') % self.target,
223                                               line=self.lineno)
224             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
225             return [prb], [msg]
226 
227         return [index, target, reference], []
228 
229     def build_uri(self) -> str:
230         base_url = self.inliner.document.settings.rfc_base_url
231         ret = self.target.split('#', 1)
232         if len(ret) == 2:
233             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
234         else:
235             return base_url + self.inliner.rfc_url % int(ret[0])
236 
237 
238 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
239 
240 
241 class GUILabel(SphinxRole):
242     amp_re = re.compile(r'(?<!&)&(?![&\s])')
243 
244     def run(self) -> Tuple[List[Node], List[system_message]]:
245         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
246         spans = self.amp_re.split(self.text)
247         node += nodes.Text(spans.pop(0))
248         for span in spans:
249             span = span.replace('&&', '&')
250 
251             letter = nodes.Text(span[0])
252             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
253             node += accelerator
254             node += nodes.Text(span[1:])
255 
256         return [node], []
257 
258 
259 class MenuSelection(GUILabel):
260     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
261 
262     def run(self) -> Tuple[List[Node], List[system_message]]:
263         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
264         return super().run()
265 
266 
267 _litvar_re = re.compile('{([^}]+)}')
268 parens_re = re.compile(r'(\\*{|\\*})')
269 
270 
271 class EmphasizedLiteral(SphinxRole):
272     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
273 
274     def run(self) -> Tuple[List[Node], List[system_message]]:
275         children = self.parse(self.text)
276         node = nodes.literal(self.rawtext, '', *children,
277                              role=self.name.lower(), classes=[self.name])
278 
279         return [node], []
280 
281     def parse(self, text: str) -> List[Node]:
282         result: List[Node] = []
283 
284         stack = ['']
285         for part in self.parens_re.split(text):
286             if part == '\\\\':  # escaped backslash
287                 stack[-1] += '\\'
288             elif part == '{':
289                 if len(stack) >= 2 and stack[-2] == "{":  # nested
290                     stack[-1] += "{"
291                 else:
292                     # start emphasis
293                     stack.append('{')
294                     stack.append('')
295             elif part == '}':
296                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
297                     # emphasized word found
298                     if stack[0]:
299                         result.append(nodes.Text(stack[0]))
300                     result.append(nodes.emphasis(stack[2], stack[2]))
301                     stack = ['']
302                 else:
303                     # emphasized word not found; the rparen is not a special symbol
304                     stack.append('}')
305                     stack = [''.join(stack)]
306             elif part == '\\{':  # escaped left-brace
307                 stack[-1] += '{'
308             elif part == '\\}':  # escaped right-brace
309                 stack[-1] += '}'
310             else:  # others (containing escaped braces)
311                 stack[-1] += part
312 
313         if ''.join(stack):
314             # remaining is treated as Text
315             text = ''.join(stack)
316             result.append(nodes.Text(text))
317 
318         return result
319 
320 
321 _abbr_re = re.compile(r'\((.*)\)$', re.S)
322 
323 
324 class Abbreviation(SphinxRole):
325     abbr_re = re.compile(r'\((.*)\)$', re.S)
326 
327     def run(self) -> Tuple[List[Node], List[system_message]]:
328         options = self.options.copy()
329         matched = self.abbr_re.search(self.text)
330         if matched:
331             text = self.text[:matched.start()].strip()
332             options['explanation'] = matched.group(1)
333         else:
334             text = self.text
335 
336         return [nodes.abbreviation(self.rawtext, text, **options)], []
337 
338 
339 # Sphinx provides the `code-block` directive for highlighting code blocks.
340 # Docutils provides the `code` role which in theory can be used similarly by
341 # defining a custom role for a given programming language:
342 #
343 #     .. .. role:: python(code)
344 #          :language: python
345 #          :class: highlight
346 #
347 # In practice this does not produce correct highlighting because it uses a
348 # separate highlighting mechanism that results in the "long" pygments class
349 # names rather than "short" pygments class names produced by the Sphinx
350 # `code-block` directive and for which this extension contains CSS rules.
351 #
352 # In addition, even if that issue is fixed, because the highlighting
353 # implementation in docutils, despite being based on pygments, differs from that
354 # used by Sphinx, the output does not exactly match that produced by the Sphinx
355 # `code-block` directive.
356 #
357 # This issue is noted here: //github.com/sphinx-doc/sphinx/issues/5157
358 #
359 # This overrides the docutils `code` role to perform highlighting in the same
360 # way as the Sphinx `code-block` directive.
361 #
362 # TODO: Change to use `SphinxRole` once SphinxRole is fixed to support options.
363 def code_role(name: str, rawtext: str, text: str, lineno: int,
364               inliner: docutils.parsers.rst.states.Inliner,
365               options: Dict = {}, content: List[str] = []
366               ) -> Tuple[List[Node], List[system_message]]:
367     options = options.copy()
368     docutils.parsers.rst.roles.set_classes(options)
369     language = options.get('language', '')
370     classes = ['code']
371     if language:
372         classes.append('highlight')
373     if 'classes' in options:
374         classes.extend(options['classes'])
375 
376     if language and language not in classes:
377         classes.append(language)
378 
379     node = nodes.literal(rawtext, text, classes=classes, language=language)
380 
381     return [node], []
382 
383 
384 code_role.options = {  # type: ignore
385     'class': docutils.parsers.rst.directives.class_option,
386     'language': docutils.parsers.rst.directives.unchanged,
387 }
388 
389 
390 specific_docroles: Dict[str, RoleFunction] = {
391     # links to download references
392     'download': XRefRole(nodeclass=addnodes.download_reference),
393     # links to anything
394     'any': AnyXRefRole(warn_dangling=True),
395 
396     'pep': PEP(),
397     'rfc': RFC(),
398     'guilabel': GUILabel(),
399     'menuselection': MenuSelection(),
400     'file': EmphasizedLiteral(),
401     'samp': EmphasizedLiteral(),
402     'abbr': Abbreviation(),
403 }
404 
405 
406 def setup(app: "Sphinx") -> Dict[str, Any]:
407     from docutils.parsers.rst import roles
408 
409     for rolename, nodeclass in generic_docroles.items():
410         generic = roles.GenericRole(rolename, nodeclass)
411         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
412         roles.register_local_role(rolename, role)
413 
414     for rolename, func in specific_docroles.items():
415         roles.register_local_role(rolename, func)
416 
417     # Since docutils registers it as a canonical role, override it as a
418     # canonical role as well.
419     roles.register_canonical_role('code', code_role)
420 
421     return {
422         'version': 'builtin',
423         'parallel_read_safe': True,
424         'parallel_write_safe': True,
425     }

</code><intended_behavior>Ensure roles that represent inline code, when rendered to LaTeX, maintain their content without extra whitespace padding, preserving the exact intended appearance.</intended_behavior>]
2025-10-18 17:47:52.204 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 17:47:52.204 | INFO     | Search-only: skipping patch selection
2025-10-18 17:47:52.333 | INFO     | Task sphinx-doc__sphinx-10435 completed successfully.
2025-10-18 17:47:52.333 | INFO     | No patch generated. You can try running ACR again.
