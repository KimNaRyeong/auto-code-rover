[
    {
        "rel_file_path": "sphinx/highlighting.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/highlighting.py",
        "start": 1,
        "end": 171,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Highlight code blocks using Pygments.\"\"\"\n2 \n3 from functools import partial\n4 from importlib import import_module\n5 from typing import Any, Dict\n6 \n7 from packaging import version\n8 from pygments import __version__ as pygmentsversion\n9 from pygments import highlight\n10 from pygments.filters import ErrorToken\n11 from pygments.formatter import Formatter\n12 from pygments.formatters import HtmlFormatter, LatexFormatter\n13 from pygments.lexer import Lexer\n14 from pygments.lexers import (CLexer, Python3Lexer, PythonConsoleLexer, PythonLexer, RstLexer,\n15                              TextLexer, get_lexer_by_name, guess_lexer)\n16 from pygments.style import Style\n17 from pygments.styles import get_style_by_name\n18 from pygments.util import ClassNotFound\n19 \n20 from sphinx.locale import __\n21 from sphinx.pygments_styles import NoneStyle, SphinxStyle\n22 from sphinx.util import logging, texescape\n23 \n24 logger = logging.getLogger(__name__)\n25 \n26 lexers: Dict[str, Lexer] = {}\n27 lexer_classes: Dict[str, Lexer] = {\n28     'none': partial(TextLexer, stripnl=False),\n29     'python': partial(PythonLexer, stripnl=False),\n30     'python3': partial(Python3Lexer, stripnl=False),\n31     'pycon': partial(PythonConsoleLexer, stripnl=False),\n32     'pycon3': partial(PythonConsoleLexer, python3=True, stripnl=False),\n33     'rest': partial(RstLexer, stripnl=False),\n34     'c': partial(CLexer, stripnl=False),\n35 }\n36 \n37 \n38 escape_hl_chars = {ord('\\\\'): '\\\\PYGZbs{}',\n39                    ord('{'): '\\\\PYGZob{}',\n40                    ord('}'): '\\\\PYGZcb{}'}\n41 \n42 # used if Pygments is available\n43 # use textcomp quote to get a true single quote\n44 _LATEX_ADD_STYLES = r'''\n45 \\renewcommand\\PYGZsq{\\textquotesingle}\n46 '''\n47 # fix extra space between lines when Pygments highlighting uses \\fcolorbox\n48 # add a {..} to limit \\fboxsep scope, and force \\fcolorbox use correct value\n49 # cf pygments #1708 which makes this unneeded for Pygments > 2.7.4\n50 _LATEX_ADD_STYLES_FIXPYG = r'''\n51 \\makeatletter\n52 % fix for Pygments <= 2.7.4\n53 \\let\\spx@original@fcolorbox\\fcolorbox\n54 \\def\\spx@fixpyg@fcolorbox{\\fboxsep-\\fboxrule\\spx@original@fcolorbox}\n55 \\def\\PYG#1#2{\\PYG@reset\\PYG@toks#1+\\relax+%\n56              {\\let\\fcolorbox\\spx@fixpyg@fcolorbox\\PYG@do{#2}}}\n57 \\makeatother\n58 '''\n59 if version.parse(pygmentsversion).release <= (2, 7, 4):\n60     _LATEX_ADD_STYLES += _LATEX_ADD_STYLES_FIXPYG\n61 \n62 \n63 class PygmentsBridge:\n64     # Set these attributes if you want to have different Pygments formatters\n65     # than the default ones.\n66     html_formatter = HtmlFormatter\n67     latex_formatter = LatexFormatter\n68 \n69     def __init__(self, dest: str = 'html', stylename: str = 'sphinx',\n70                  latex_engine: str = None) -> None:\n71         self.dest = dest\n72         self.latex_engine = latex_engine\n73 \n74         style = self.get_style(stylename)\n75         self.formatter_args: Dict[str, Any] = {'style': style}\n76         if dest == 'html':\n77             self.formatter = self.html_formatter\n78         else:\n79             self.formatter = self.latex_formatter\n80             self.formatter_args['commandprefix'] = 'PYG'\n81 \n82     def get_style(self, stylename: str) -> Style:\n83         if stylename is None or stylename == 'sphinx':\n84             return SphinxStyle\n85         elif stylename == 'none':\n86             return NoneStyle\n87         elif '.' in stylename:\n88             module, stylename = stylename.rsplit('.', 1)\n89             return getattr(import_module(module), stylename)\n90         else:\n91             return get_style_by_name(stylename)\n92 \n93     def get_formatter(self, **kwargs: Any) -> Formatter:\n94         kwargs.update(self.formatter_args)\n95         return self.formatter(**kwargs)\n96 \n97     def get_lexer(self, source: str, lang: str, opts: Dict = None,\n98                   force: bool = False, location: Any = None) -> Lexer:\n99         if not opts:\n100             opts = {}\n101 \n102         # find out which lexer to use\n103         if lang in ('py', 'python'):\n104             if source.startswith('>>>'):\n105                 # interactive session\n106                 lang = 'pycon'\n107             else:\n108                 lang = 'python'\n109         elif lang in ('py3', 'python3', 'default'):\n110             if source.startswith('>>>'):\n111                 lang = 'pycon3'\n112             else:\n113                 lang = 'python3'\n114 \n115         if lang in lexers:\n116             # just return custom lexers here (without installing raiseonerror filter)\n117             return lexers[lang]\n118         elif lang in lexer_classes:\n119             lexer = lexer_classes[lang](**opts)\n120         else:\n121             try:\n122                 if lang == 'guess':\n123                     lexer = guess_lexer(source, **opts)\n124                 else:\n125                     lexer = get_lexer_by_name(lang, **opts)\n126             except ClassNotFound:\n127                 logger.warning(__('Pygments lexer name %r is not known'), lang,\n128                                location=location)\n129                 lexer = lexer_classes['none'](**opts)\n130 \n131         if not force:\n132             lexer.add_filter('raiseonerror')\n133 \n134         return lexer\n135 \n136     def highlight_block(self, source: str, lang: str, opts: Dict = None,\n137                         force: bool = False, location: Any = None, **kwargs: Any) -> str:\n138         if not isinstance(source, str):\n139             source = source.decode()\n140 \n141         lexer = self.get_lexer(source, lang, opts, force, location)\n142 \n143         # highlight via Pygments\n144         formatter = self.get_formatter(**kwargs)\n145         try:\n146             hlsource = highlight(source, lexer, formatter)\n147         except ErrorToken:\n148             # this is most probably not the selected language,\n149             # so let it pass unhighlighted\n150             if lang == 'default':\n151                 pass  # automatic highlighting failed.\n152             else:\n153                 logger.warning(__('Could not lex literal_block as \"%s\". '\n154                                   'Highlighting skipped.'), lang,\n155                                type='misc', subtype='highlighting_failure',\n156                                location=location)\n157             lexer = self.get_lexer(source, 'none', opts, force, location)\n158             hlsource = highlight(source, lexer, formatter)\n159 \n160         if self.dest == 'html':\n161             return hlsource\n162         else:\n163             # MEMO: this is done to escape Unicode chars with non-Unicode engines\n164             return texescape.hlescape(hlsource, self.latex_engine)\n165 \n166     def get_stylesheet(self) -> str:\n167         formatter = self.get_formatter()\n168         if self.dest == 'html':\n169             return formatter.get_style_defs('.highlight')\n170         else:\n171             return formatter.get_style_defs() + _LATEX_ADD_STYLES\n",
        "intended_behavior": "Ensure that when inline code is converted to LaTeX, no additional whitespace is introduced at the beginning or end of the inline code."
    },
    {
        "rel_file_path": "sphinx/roles.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/roles.py",
        "start": 1,
        "end": 425,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Handlers for additional ReST roles.\"\"\"\n2 \n3 import re\n4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple, Type\n5 \n6 import docutils.parsers.rst.directives\n7 import docutils.parsers.rst.roles\n8 import docutils.parsers.rst.states\n9 from docutils import nodes, utils\n10 from docutils.nodes import Element, Node, TextElement, system_message\n11 \n12 from sphinx import addnodes\n13 from sphinx.locale import _, __\n14 from sphinx.util import ws_re\n15 from sphinx.util.docutils import ReferenceRole, SphinxRole\n16 from sphinx.util.typing import RoleFunction\n17 \n18 if TYPE_CHECKING:\n19     from sphinx.application import Sphinx\n20     from sphinx.environment import BuildEnvironment\n21 \n22 \n23 generic_docroles = {\n24     'command': addnodes.literal_strong,\n25     'dfn': nodes.emphasis,\n26     'kbd': nodes.literal,\n27     'mailheader': addnodes.literal_emphasis,\n28     'makevar': addnodes.literal_strong,\n29     'manpage': addnodes.manpage,\n30     'mimetype': addnodes.literal_emphasis,\n31     'newsgroup': addnodes.literal_emphasis,\n32     'program': addnodes.literal_strong,  # XXX should be an x-ref\n33     'regexp': nodes.literal,\n34 }\n35 \n36 \n37 # -- generic cross-reference role ----------------------------------------------\n38 \n39 class XRefRole(ReferenceRole):\n40     \"\"\"\n41     A generic cross-referencing role.  To create a callable that can be used as\n42     a role function, create an instance of this class.\n43 \n44     The general features of this role are:\n45 \n46     * Automatic creation of a reference and a content node.\n47     * Optional separation of title and target with `title <target>`.\n48     * The implementation is a class rather than a function to make\n49       customization easier.\n50 \n51     Customization can be done in two ways:\n52 \n53     * Supplying constructor parameters:\n54       * `fix_parens` to normalize parentheses (strip from target, and add to\n55         title if configured)\n56       * `lowercase` to lowercase the target\n57       * `nodeclass` and `innernodeclass` select the node classes for\n58         the reference and the content node\n59 \n60     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.\n61     \"\"\"\n62 \n63     nodeclass: Type[Element] = addnodes.pending_xref\n64     innernodeclass: Type[TextElement] = nodes.literal\n65 \n66     def __init__(self, fix_parens: bool = False, lowercase: bool = False,\n67                  nodeclass: Type[Element] = None, innernodeclass: Type[TextElement] = None,\n68                  warn_dangling: bool = False) -> None:\n69         self.fix_parens = fix_parens\n70         self.lowercase = lowercase\n71         self.warn_dangling = warn_dangling\n72         if nodeclass is not None:\n73             self.nodeclass = nodeclass\n74         if innernodeclass is not None:\n75             self.innernodeclass = innernodeclass\n76 \n77         super().__init__()\n78 \n79     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:\n80         if not self.has_explicit_title:\n81             if title.endswith('()'):\n82                 # remove parentheses\n83                 title = title[:-2]\n84             if self.config.add_function_parentheses:\n85                 # add them back to all occurrences if configured\n86                 title += '()'\n87         # remove parentheses from the target too\n88         if target.endswith('()'):\n89             target = target[:-2]\n90         return title, target\n91 \n92     def run(self) -> Tuple[List[Node], List[system_message]]:\n93         if ':' not in self.name:\n94             self.refdomain, self.reftype = '', self.name\n95             self.classes = ['xref', self.reftype]\n96         else:\n97             self.refdomain, self.reftype = self.name.split(':', 1)\n98             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]\n99 \n100         if self.disabled:\n101             return self.create_non_xref_node()\n102         else:\n103             return self.create_xref_node()\n104 \n105     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n106         text = utils.unescape(self.text[1:])\n107         if self.fix_parens:\n108             self.has_explicit_title = False  # treat as implicit\n109             text, target = self.update_title_and_target(text, \"\")\n110 \n111         node = self.innernodeclass(self.rawtext, text, classes=self.classes)\n112         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)\n113 \n114     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n115         target = self.target\n116         title = self.title\n117         if self.lowercase:\n118             target = target.lower()\n119         if self.fix_parens:\n120             title, target = self.update_title_and_target(title, target)\n121 \n122         # create the reference node\n123         options = {'refdoc': self.env.docname,\n124                    'refdomain': self.refdomain,\n125                    'reftype': self.reftype,\n126                    'refexplicit': self.has_explicit_title,\n127                    'refwarn': self.warn_dangling}\n128         refnode = self.nodeclass(self.rawtext, **options)\n129         self.set_source_info(refnode)\n130 \n131         # determine the target and title for the class\n132         title, target = self.process_link(self.env, refnode, self.has_explicit_title,\n133                                           title, target)\n134         refnode['reftarget'] = target\n135         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)\n136 \n137         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)\n138 \n139     # methods that can be overwritten\n140 \n141     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n142                      title: str, target: str) -> Tuple[str, str]:\n143         \"\"\"Called after parsing title and target text, and creating the\n144         reference node (given in *refnode*).  This method can alter the\n145         reference node and must return a new (or the same) ``(title, target)``\n146         tuple.\n147         \"\"\"\n148         return title, ws_re.sub(' ', target)\n149 \n150     def result_nodes(self, document: nodes.document, env: \"BuildEnvironment\", node: Element,\n151                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n152         \"\"\"Called before returning the finished nodes.  *node* is the reference\n153         node if one was created (*is_ref* is then true), else the content node.\n154         This method can add other nodes and must return a ``(nodes, messages)``\n155         tuple (the usual return value of a role function).\n156         \"\"\"\n157         return [node], []\n158 \n159 \n160 class AnyXRefRole(XRefRole):\n161     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n162                      title: str, target: str) -> Tuple[str, str]:\n163         result = super().process_link(env, refnode, has_explicit_title, title, target)\n164         # add all possible context info (i.e. std:program, py:module etc.)\n165         refnode.attributes.update(env.ref_context)\n166         return result\n167 \n168 \n169 class PEP(ReferenceRole):\n170     def run(self) -> Tuple[List[Node], List[system_message]]:\n171         target_id = 'index-%s' % self.env.new_serialno('index')\n172         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,\n173                     target_id, '', None)]\n174 \n175         index = addnodes.index(entries=entries)\n176         target = nodes.target('', '', ids=[target_id])\n177         self.inliner.document.note_explicit_target(target)\n178 \n179         try:\n180             refuri = self.build_uri()\n181             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])\n182             if self.has_explicit_title:\n183                 reference += nodes.strong(self.title, self.title)\n184             else:\n185                 title = \"PEP \" + self.title\n186                 reference += nodes.strong(title, title)\n187         except ValueError:\n188             msg = self.inliner.reporter.error(__('invalid PEP number %s') % self.target,\n189                                               line=self.lineno)\n190             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n191             return [prb], [msg]\n192 \n193         return [index, target, reference], []\n194 \n195     def build_uri(self) -> str:\n196         base_url = self.inliner.document.settings.pep_base_url\n197         ret = self.target.split('#', 1)\n198         if len(ret) == 2:\n199             return base_url + 'pep-%04d/#%s' % (int(ret[0]), ret[1])\n200         else:\n201             return base_url + 'pep-%04d/' % int(ret[0])\n202 \n203 \n204 class RFC(ReferenceRole):\n205     def run(self) -> Tuple[List[Node], List[system_message]]:\n206         target_id = 'index-%s' % self.env.new_serialno('index')\n207         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]\n208 \n209         index = addnodes.index(entries=entries)\n210         target = nodes.target('', '', ids=[target_id])\n211         self.inliner.document.note_explicit_target(target)\n212 \n213         try:\n214             refuri = self.build_uri()\n215             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])\n216             if self.has_explicit_title:\n217                 reference += nodes.strong(self.title, self.title)\n218             else:\n219                 title = \"RFC \" + self.title\n220                 reference += nodes.strong(title, title)\n221         except ValueError:\n222             msg = self.inliner.reporter.error(__('invalid RFC number %s') % self.target,\n223                                               line=self.lineno)\n224             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n225             return [prb], [msg]\n226 \n227         return [index, target, reference], []\n228 \n229     def build_uri(self) -> str:\n230         base_url = self.inliner.document.settings.rfc_base_url\n231         ret = self.target.split('#', 1)\n232         if len(ret) == 2:\n233             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]\n234         else:\n235             return base_url + self.inliner.rfc_url % int(ret[0])\n236 \n237 \n238 _amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n239 \n240 \n241 class GUILabel(SphinxRole):\n242     amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n243 \n244     def run(self) -> Tuple[List[Node], List[system_message]]:\n245         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])\n246         spans = self.amp_re.split(self.text)\n247         node += nodes.Text(spans.pop(0))\n248         for span in spans:\n249             span = span.replace('&&', '&')\n250 \n251             letter = nodes.Text(span[0])\n252             accelerator = nodes.inline('', '', letter, classes=['accelerator'])\n253             node += accelerator\n254             node += nodes.Text(span[1:])\n255 \n256         return [node], []\n257 \n258 \n259 class MenuSelection(GUILabel):\n260     BULLET_CHARACTER = '\\N{TRIANGULAR BULLET}'\n261 \n262     def run(self) -> Tuple[List[Node], List[system_message]]:\n263         self.text = self.text.replace('-->', self.BULLET_CHARACTER)\n264         return super().run()\n265 \n266 \n267 _litvar_re = re.compile('{([^}]+)}')\n268 parens_re = re.compile(r'(\\\\*{|\\\\*})')\n269 \n270 \n271 class EmphasizedLiteral(SphinxRole):\n272     parens_re = re.compile(r'(\\\\\\\\|\\\\{|\\\\}|{|})')\n273 \n274     def run(self) -> Tuple[List[Node], List[system_message]]:\n275         children = self.parse(self.text)\n276         node = nodes.literal(self.rawtext, '', *children,\n277                              role=self.name.lower(), classes=[self.name])\n278 \n279         return [node], []\n280 \n281     def parse(self, text: str) -> List[Node]:\n282         result: List[Node] = []\n283 \n284         stack = ['']\n285         for part in self.parens_re.split(text):\n286             if part == '\\\\\\\\':  # escaped backslash\n287                 stack[-1] += '\\\\'\n288             elif part == '{':\n289                 if len(stack) >= 2 and stack[-2] == \"{\":  # nested\n290                     stack[-1] += \"{\"\n291                 else:\n292                     # start emphasis\n293                     stack.append('{')\n294                     stack.append('')\n295             elif part == '}':\n296                 if len(stack) == 3 and stack[1] == \"{\" and len(stack[2]) > 0:\n297                     # emphasized word found\n298                     if stack[0]:\n299                         result.append(nodes.Text(stack[0]))\n300                     result.append(nodes.emphasis(stack[2], stack[2]))\n301                     stack = ['']\n302                 else:\n303                     # emphasized word not found; the rparen is not a special symbol\n304                     stack.append('}')\n305                     stack = [''.join(stack)]\n306             elif part == '\\\\{':  # escaped left-brace\n307                 stack[-1] += '{'\n308             elif part == '\\\\}':  # escaped right-brace\n309                 stack[-1] += '}'\n310             else:  # others (containing escaped braces)\n311                 stack[-1] += part\n312 \n313         if ''.join(stack):\n314             # remaining is treated as Text\n315             text = ''.join(stack)\n316             result.append(nodes.Text(text))\n317 \n318         return result\n319 \n320 \n321 _abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n322 \n323 \n324 class Abbreviation(SphinxRole):\n325     abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n326 \n327     def run(self) -> Tuple[List[Node], List[system_message]]:\n328         options = self.options.copy()\n329         matched = self.abbr_re.search(self.text)\n330         if matched:\n331             text = self.text[:matched.start()].strip()\n332             options['explanation'] = matched.group(1)\n333         else:\n334             text = self.text\n335 \n336         return [nodes.abbreviation(self.rawtext, text, **options)], []\n337 \n338 \n339 # Sphinx provides the `code-block` directive for highlighting code blocks.\n340 # Docutils provides the `code` role which in theory can be used similarly by\n341 # defining a custom role for a given programming language:\n342 #\n343 #     .. .. role:: python(code)\n344 #          :language: python\n345 #          :class: highlight\n346 #\n347 # In practice this does not produce correct highlighting because it uses a\n348 # separate highlighting mechanism that results in the \"long\" pygments class\n349 # names rather than \"short\" pygments class names produced by the Sphinx\n350 # `code-block` directive and for which this extension contains CSS rules.\n351 #\n352 # In addition, even if that issue is fixed, because the highlighting\n353 # implementation in docutils, despite being based on pygments, differs from that\n354 # used by Sphinx, the output does not exactly match that produced by the Sphinx\n355 # `code-block` directive.\n356 #\n357 # This issue is noted here: //github.com/sphinx-doc/sphinx/issues/5157\n358 #\n359 # This overrides the docutils `code` role to perform highlighting in the same\n360 # way as the Sphinx `code-block` directive.\n361 #\n362 # TODO: Change to use `SphinxRole` once SphinxRole is fixed to support options.\n363 def code_role(name: str, rawtext: str, text: str, lineno: int,\n364               inliner: docutils.parsers.rst.states.Inliner,\n365               options: Dict = {}, content: List[str] = []\n366               ) -> Tuple[List[Node], List[system_message]]:\n367     options = options.copy()\n368     docutils.parsers.rst.roles.set_classes(options)\n369     language = options.get('language', '')\n370     classes = ['code']\n371     if language:\n372         classes.append('highlight')\n373     if 'classes' in options:\n374         classes.extend(options['classes'])\n375 \n376     if language and language not in classes:\n377         classes.append(language)\n378 \n379     node = nodes.literal(rawtext, text, classes=classes, language=language)\n380 \n381     return [node], []\n382 \n383 \n384 code_role.options = {  # type: ignore\n385     'class': docutils.parsers.rst.directives.class_option,\n386     'language': docutils.parsers.rst.directives.unchanged,\n387 }\n388 \n389 \n390 specific_docroles: Dict[str, RoleFunction] = {\n391     # links to download references\n392     'download': XRefRole(nodeclass=addnodes.download_reference),\n393     # links to anything\n394     'any': AnyXRefRole(warn_dangling=True),\n395 \n396     'pep': PEP(),\n397     'rfc': RFC(),\n398     'guilabel': GUILabel(),\n399     'menuselection': MenuSelection(),\n400     'file': EmphasizedLiteral(),\n401     'samp': EmphasizedLiteral(),\n402     'abbr': Abbreviation(),\n403 }\n404 \n405 \n406 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n407     from docutils.parsers.rst import roles\n408 \n409     for rolename, nodeclass in generic_docroles.items():\n410         generic = roles.GenericRole(rolename, nodeclass)\n411         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})\n412         roles.register_local_role(rolename, role)\n413 \n414     for rolename, func in specific_docroles.items():\n415         roles.register_local_role(rolename, func)\n416 \n417     # Since docutils registers it as a canonical role, override it as a\n418     # canonical role as well.\n419     roles.register_canonical_role('code', code_role)\n420 \n421     return {\n422         'version': 'builtin',\n423         'parallel_read_safe': True,\n424         'parallel_write_safe': True,\n425     }\n",
        "intended_behavior": "Ensure roles that represent inline code, when rendered to LaTeX, maintain their content without extra whitespace padding, preserving the exact intended appearance."
    }
]