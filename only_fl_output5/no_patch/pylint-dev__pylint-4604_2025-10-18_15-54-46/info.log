2025-10-18 15:54:46.428 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 15:54:48.209 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=288, output_tokens=12, cost=0.003240
2025-10-18 15:55:04.789 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=468, output_tokens=763, cost=0.027570
2025-10-18 15:55:19.426 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=468, output_tokens=626, cost=0.023460
2025-10-18 15:55:20.410 | INFO     | registered non reproducing test 1
2025-10-18 15:55:36.414 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1701, output_tokens=734, cost=0.039030
2025-10-18 15:55:37.390 | INFO     | registered non reproducing test 2
2025-10-18 15:55:37.390 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 15:55:37.396 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 15:55:47.006 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=595, output_tokens=457, cost=0.019660
2025-10-18 15:55:47.019 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 15:55:52.825 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=811, output_tokens=129, cost=0.011980
2025-10-18 15:55:52.827 | DEBUG    | Extracted a valid json.
2025-10-18 15:55:52.827 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"pylintrc\")",
        "search_code(\"[pylint.\")",
        "search_code(\"pyproject.toml\")",
        "search_code(\"setup.cfg\")",
        "search_code(\"[tool.pylint.\")",
        "search_code(\"`pylint\")",
        "search_code(\"AddMessage\")",
        "search_code(\"BaseChecker\")",
        "search_code(\"IAstroidChecker\")",
        "search_code(\"astroid\")",
        "search_code(\"type: \")"
    ],
    "bug_locations": []
}
2025-10-18 15:55:53.351 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 15:55:53.351 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 15:56:09.117 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4527, output_tokens=706, cost=0.066450
2025-10-18 15:56:09.124 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 15:56:17.203 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5449, output_tokens=328, cost=0.064330
2025-10-18 15:56:17.209 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 15:56:24.432 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=682, output_tokens=282, cost=0.015280
2025-10-18 15:56:24.433 | DEBUG    | Extracted a valid json.
2025-10-18 15:56:24.433 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pylint/checkers/imports.py",
            "class": "ImportsChecker",
            "method": "",
            "intended_behavior": "This code location, being part of the logic that checks for unused imports, needs to be adjusted to correctly identify and ignore import statements that are exclusively used in type annotations within type comments. The ImportsChecker should be enhanced to parse type comments for variable annotations and map these uses back to their respective import statements. This adjustment will preserve the original functionality of detecting genuinely unused import statements while excluding those legitimately used in type comments, thus resolving the false positive issue."
        },
        {
            "file": "pylint/utils/ast_walker.py",
            "class": "",
            "method": "",
            "intended_behavior": "If the AST Walker is used for traversing the Python abstract syntax tree and does not currently account for or properly visit type comments, it should be updated or extended to do so. Given the issue is related to imports used within type comments, enhancing the AST Walker to recognize these patterns as valid usage scenarios of the imports will help in accurate lint checks. This ensures that all parts of the code, including type comments, are considered when determining whether an import is used, maintaining the utility of lint checks without compromising on accuracy."
        }
    ]
}
2025-10-18 15:56:24.440 | DEBUG    | Bug location extracted successfully: [<file>pylint/checkers/imports.py</file>
<class>ImportsChecker</class>
<method>None</method>
<code>
320 class ImportsChecker(DeprecatedMixin, BaseChecker):
321     """checks for
322     * external modules dependencies
323     * relative / wildcard imports
324     * cyclic imports
325     * uses of deprecated modules
326     * uses of modules instead of preferred modules
327     """
328 
329     __implements__ = IAstroidChecker
330 
331     name = "imports"
332     msgs = MSGS
333     priority = -2
334     default_deprecated_modules = ()
335 
336     options = (
337         (
338             "deprecated-modules",
339             {
340                 "default": default_deprecated_modules,
341                 "type": "csv",
342                 "metavar": "<modules>",
343                 "help": "Deprecated modules which should not be used,"
344                 " separated by a comma.",
345             },
346         ),
347         (
348             "preferred-modules",
349             {
350                 "default": DEFAULT_PREFERRED_MODULES,
351                 "type": "csv",
352                 "metavar": "<module:preferred-module>",
353                 "help": "Couples of modules and preferred modules,"
354                 " separated by a comma.",
355             },
356         ),
357         (
358             "import-graph",
359             {
360                 "default": "",
361                 "type": "string",
362                 "metavar": "<file.gv>",
363                 "help": "Output a graph (.gv or any supported image format) of"
364                 " all (i.e. internal and external) dependencies to the given file"
365                 " (report RP0402 must not be disabled).",
366             },
367         ),
368         (
369             "ext-import-graph",
370             {
371                 "default": "",
372                 "type": "string",
373                 "metavar": "<file.gv>",
374                 "help": "Output a graph (.gv or any supported image format)"
375                 " of external dependencies to the given file"
376                 " (report RP0402 must not be disabled).",
377             },
378         ),
379         (
380             "int-import-graph",
381             {
382                 "default": "",
383                 "type": "string",
384                 "metavar": "<file.gv>",
385                 "help": "Output a graph (.gv or any supported image format)"
386                 " of internal dependencies to the given file"
387                 " (report RP0402 must not be disabled).",
388             },
389         ),
390         (
391             "known-standard-library",
392             {
393                 "default": DEFAULT_STANDARD_LIBRARY,
394                 "type": "csv",
395                 "metavar": "<modules>",
396                 "help": "Force import order to recognize a module as part of "
397                 "the standard compatibility libraries.",
398             },
399         ),
400         (
401             "known-third-party",
402             {
403                 "default": DEFAULT_KNOWN_THIRD_PARTY,
404                 "type": "csv",
405                 "metavar": "<modules>",
406                 "help": "Force import order to recognize a module as part of "
407                 "a third party library.",
408             },
409         ),
410         (
411             "allow-any-import-level",
412             {
413                 "default": (),
414                 "type": "csv",
415                 "metavar": "<modules>",
416                 "help": (
417                     "List of modules that can be imported at any level, not just "
418                     "the top level one."
419                 ),
420             },
421         ),
422         (
423             "analyse-fallback-blocks",
424             {
425                 "default": False,
426                 "type": "yn",
427                 "metavar": "<y_or_n>",
428                 "help": "Analyse import fallback blocks. This can be used to "
429                 "support both Python 2 and 3 compatible code, which "
430                 "means that the block might have code that exists "
431                 "only in one or another interpreter, leading to false "
432                 "positives when analysed.",
433             },
434         ),
435         (
436             "allow-wildcard-with-all",
437             {
438                 "default": False,
439                 "type": "yn",
440                 "metavar": "<y_or_n>",
441                 "help": "Allow wildcard imports from modules that define __all__.",
442             },
443         ),
444     )
445 
446     def __init__(self, linter=None):
447         BaseChecker.__init__(self, linter)
448         self.stats = None
449         self.import_graph = None
450         self._imports_stack = []
451         self._first_non_import_node = None
452         self._module_pkg = {}  # mapping of modules to the pkg they belong in
453         self._allow_any_import_level = set()
454         self.reports = (
455             ("RP0401", "External dependencies", self._report_external_dependencies),
456             ("RP0402", "Modules dependencies graph", self._report_dependencies_graph),
457         )
458 
459         self._site_packages = self._compute_site_packages()
460 
461     @staticmethod
462     def _compute_site_packages():
463         def _normalized_path(path):
464             return os.path.normcase(os.path.abspath(path))
465 
466         paths = set()
467         real_prefix = getattr(sys, "real_prefix", None)
468         for prefix in filter(None, (real_prefix, sys.prefix)):
469             path = sysconfig.get_python_lib(prefix=prefix)
470             path = _normalized_path(path)
471             paths.add(path)
472 
473         # Handle Debian's derivatives /usr/local.
474         if os.path.isfile("/etc/debian_version"):
475             for prefix in filter(None, (real_prefix, sys.prefix)):
476                 libpython = os.path.join(
477                     prefix,
478                     "local",
479                     "lib",
480                     "python" + sysconfig.get_python_version(),
481                     "dist-packages",
482                 )
483                 paths.add(libpython)
484         return paths
485 
486     def open(self):
487         """called before visiting project (i.e set of modules)"""
488         self.linter.add_stats(dependencies={})
489         self.linter.add_stats(cycles=[])
490         self.stats = self.linter.stats
491         self.import_graph = collections.defaultdict(set)
492         self._module_pkg = {}  # mapping of modules to the pkg they belong in
493         self._excluded_edges = collections.defaultdict(set)
494         self._ignored_modules = get_global_option(self, "ignored-modules", default=[])
495         # Build a mapping {'module': 'preferred-module'}
496         self.preferred_modules = dict(
497             module.split(":")
498             for module in self.config.preferred_modules
499             if ":" in module
500         )
501         self._allow_any_import_level = set(self.config.allow_any_import_level)
502 
503     def _import_graph_without_ignored_edges(self):
504         filtered_graph = copy.deepcopy(self.import_graph)
505         for node in filtered_graph:
506             filtered_graph[node].difference_update(self._excluded_edges[node])
507         return filtered_graph
508 
509     def close(self):
510         """called before visiting project (i.e set of modules)"""
511         if self.linter.is_message_enabled("cyclic-import"):
512             graph = self._import_graph_without_ignored_edges()
513             vertices = list(graph)
514             for cycle in get_cycles(graph, vertices=vertices):
515                 self.add_message("cyclic-import", args=" -> ".join(cycle))
516 
517     def deprecated_modules(self):
518         """Callback returning the deprecated modules."""
519         return self.config.deprecated_modules
520 
521     @check_messages(*MSGS)
522     def visit_import(self, node):
523         """triggered when an import statement is seen"""
524         self._check_reimport(node)
525         self._check_import_as_rename(node)
526         self._check_toplevel(node)
527 
528         names = [name for name, _ in node.names]
529         if len(names) >= 2:
530             self.add_message("multiple-imports", args=", ".join(names), node=node)
531 
532         for name in names:
533             self.check_deprecated_module(node, name)
534             self._check_preferred_module(node, name)
535             imported_module = self._get_imported_module(node, name)
536             if isinstance(node.parent, astroid.Module):
537                 # Allow imports nested
538                 self._check_position(node)
539             if isinstance(node.scope(), astroid.Module):
540                 self._record_import(node, imported_module)
541 
542             if imported_module is None:
543                 continue
544 
545             self._add_imported_module(node, imported_module.name)
546 
547     @check_messages(*MSGS)
548     def visit_importfrom(self, node):
549         """triggered when a from statement is seen"""
550         basename = node.modname
551         imported_module = self._get_imported_module(node, basename)
552 
553         self._check_import_as_rename(node)
554         self._check_misplaced_future(node)
555         self.check_deprecated_module(node, basename)
556         self._check_preferred_module(node, basename)
557         self._check_wildcard_imports(node, imported_module)
558         self._check_same_line_imports(node)
559         self._check_reimport(node, basename=basename, level=node.level)
560         self._check_toplevel(node)
561 
562         if isinstance(node.parent, astroid.Module):
563             # Allow imports nested
564             self._check_position(node)
565         if isinstance(node.scope(), astroid.Module):
566             self._record_import(node, imported_module)
567         if imported_module is None:
568             return
569         for name, _ in node.names:
570             if name != "*":
571                 self._add_imported_module(node, f"{imported_module.name}.{name}")
572             else:
573                 self._add_imported_module(node, imported_module.name)
574 
575     @check_messages(*MSGS)
576     def leave_module(self, node):
577         # Check imports are grouped by category (standard, 3rd party, local)
578         std_imports, ext_imports, loc_imports = self._check_imports_order(node)
579 
580         # Check that imports are grouped by package within a given category
581         met_import = set()  # set for 'import x' style
582         met_from = set()  # set for 'from x import y' style
583         current_package = None
584         for import_node, import_name in std_imports + ext_imports + loc_imports:
585             if not self.linter.is_message_enabled(
586                 "ungrouped-imports", import_node.fromlineno
587             ):
588                 continue
589             if isinstance(import_node, astroid.node_classes.ImportFrom):
590                 met = met_from
591             else:
592                 met = met_import
593             package, _, _ = import_name.partition(".")
594             if current_package and current_package != package and package in met:
595                 self.add_message("ungrouped-imports", node=import_node, args=package)
596             current_package = package
597             met.add(package)
598 
599         self._imports_stack = []
600         self._first_non_import_node = None
601 
602     def compute_first_non_import_node(self, node):
603         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
604             return
605         # if the node does not contain an import instruction, and if it is the
606         # first node of the module, keep a track of it (all the import positions
607         # of the module will be compared to the position of this first
608         # instruction)
609         if self._first_non_import_node:
610             return
611         if not isinstance(node.parent, astroid.Module):
612             return
613         nested_allowed = [astroid.TryExcept, astroid.TryFinally]
614         is_nested_allowed = [
615             allowed for allowed in nested_allowed if isinstance(node, allowed)
616         ]
617         if is_nested_allowed and any(
618             node.nodes_of_class((astroid.Import, astroid.ImportFrom))
619         ):
620             return
621         if isinstance(node, astroid.Assign):
622             # Add compatibility for module level dunder names
623             # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names
624             valid_targets = [
625                 isinstance(target, astroid.AssignName)
626                 and target.name.startswith("__")
627                 and target.name.endswith("__")
628                 for target in node.targets
629             ]
630             if all(valid_targets):
631                 return
632         self._first_non_import_node = node
633 
634     visit_tryfinally = (
635         visit_tryexcept
636     ) = (
637         visit_assignattr
638     ) = (
639         visit_assign
640     ) = (
641         visit_ifexp
642     ) = visit_comprehension = visit_expr = visit_if = compute_first_non_import_node
643 
644     def visit_functiondef(self, node):
645         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
646             return
647         # If it is the first non import instruction of the module, record it.
648         if self._first_non_import_node:
649             return
650 
651         # Check if the node belongs to an `If` or a `Try` block. If they
652         # contain imports, skip recording this node.
653         if not isinstance(node.parent.scope(), astroid.Module):
654             return
655 
656         root = node
657         while not isinstance(root.parent, astroid.Module):
658             root = root.parent
659 
660         if isinstance(root, (astroid.If, astroid.TryFinally, astroid.TryExcept)):
661             if any(root.nodes_of_class((astroid.Import, astroid.ImportFrom))):
662                 return
663 
664         self._first_non_import_node = node
665 
666     visit_classdef = visit_for = visit_while = visit_functiondef
667 
668     def _check_misplaced_future(self, node):
669         basename = node.modname
670         if basename == "__future__":
671             # check if this is the first non-docstring statement in the module
672             prev = node.previous_sibling()
673             if prev:
674                 # consecutive future statements are possible
675                 if not (
676                     isinstance(prev, astroid.ImportFrom)
677                     and prev.modname == "__future__"
678                 ):
679                     self.add_message("misplaced-future", node=node)
680             return
681 
682     def _check_same_line_imports(self, node):
683         # Detect duplicate imports on the same line.
684         names = (name for name, _ in node.names)
685         counter = collections.Counter(names)
686         for name, count in counter.items():
687             if count > 1:
688                 self.add_message("reimported", node=node, args=(name, node.fromlineno))
689 
690     def _check_position(self, node):
691         """Check `node` import or importfrom node position is correct
692 
693         Send a message  if `node` comes before another instruction
694         """
695         # if a first non-import instruction has already been encountered,
696         # it means the import comes after it and therefore is not well placed
697         if self._first_non_import_node:
698             self.add_message("wrong-import-position", node=node, args=node.as_string())
699 
700     def _record_import(self, node, importedmodnode):
701         """Record the package `node` imports from"""
702         if isinstance(node, astroid.ImportFrom):
703             importedname = node.modname
704         else:
705             importedname = importedmodnode.name if importedmodnode else None
706         if not importedname:
707             importedname = node.names[0][0].split(".")[0]
708 
709         if isinstance(node, astroid.ImportFrom) and (node.level or 0) >= 1:
710             # We need the importedname with first point to detect local package
711             # Example of node:
712             #  'from .my_package1 import MyClass1'
713             #  the output should be '.my_package1' instead of 'my_package1'
714             # Example of node:
715             #  'from . import my_package2'
716             #  the output should be '.my_package2' instead of '{pyfile}'
717             importedname = "." + importedname
718 
719         self._imports_stack.append((node, importedname))
720 
721     @staticmethod
722     def _is_fallback_import(node, imports):
723         imports = [import_node for (import_node, _) in imports]
724         return any(astroid.are_exclusive(import_node, node) for import_node in imports)
725 
726     def _check_imports_order(self, _module_node):
727         """Checks imports of module `node` are grouped by category
728 
729         Imports must follow this order: standard, 3rd party, local
730         """
731         std_imports = []
732         third_party_imports = []
733         first_party_imports = []
734         # need of a list that holds third or first party ordered import
735         external_imports = []
736         local_imports = []
737         third_party_not_ignored = []
738         first_party_not_ignored = []
739         local_not_ignored = []
740         isort_driver = IsortDriver(self.config)
741         for node, modname in self._imports_stack:
742             if modname.startswith("."):
743                 package = "." + modname.split(".")[1]
744             else:
745                 package = modname.split(".")[0]
746             nested = not isinstance(node.parent, astroid.Module)
747             ignore_for_import_order = not self.linter.is_message_enabled(
748                 "wrong-import-order", node.fromlineno
749             )
750             import_category = isort_driver.place_module(package)
751             node_and_package_import = (node, package)
752             if import_category in ("FUTURE", "STDLIB"):
753                 std_imports.append(node_and_package_import)
754                 wrong_import = (
755                     third_party_not_ignored
756                     or first_party_not_ignored
757                     or local_not_ignored
758                 )
759                 if self._is_fallback_import(node, wrong_import):
760                     continue
761                 if wrong_import and not nested:
762                     self.add_message(
763                         "wrong-import-order",
764                         node=node,
765                         args=(
766                             'standard import "%s"' % node.as_string(),
767                             '"%s"' % wrong_import[0][0].as_string(),
768                         ),
769                     )
770             elif import_category == "THIRDPARTY":
771                 third_party_imports.append(node_and_package_import)
772                 external_imports.append(node_and_package_import)
773                 if not nested and not ignore_for_import_order:
774                     third_party_not_ignored.append(node_and_package_import)
775                 wrong_import = first_party_not_ignored or local_not_ignored
776                 if wrong_import and not nested:
777                     self.add_message(
778                         "wrong-import-order",
779                         node=node,
780                         args=(
781                             'third party import "%s"' % node.as_string(),
782                             '"%s"' % wrong_import[0][0].as_string(),
783                         ),
784                     )
785             elif import_category == "FIRSTPARTY":
786                 first_party_imports.append(node_and_package_import)
787                 external_imports.append(node_and_package_import)
788                 if not nested and not ignore_for_import_order:
789                     first_party_not_ignored.append(node_and_package_import)
790                 wrong_import = local_not_ignored
791                 if wrong_import and not nested:
792                     self.add_message(
793                         "wrong-import-order",
794                         node=node,
795                         args=(
796                             'first party import "%s"' % node.as_string(),
797                             '"%s"' % wrong_import[0][0].as_string(),
798                         ),
799                     )
800             elif import_category == "LOCALFOLDER":
801                 local_imports.append((node, package))
802                 if not nested and not ignore_for_import_order:
803                     local_not_ignored.append((node, package))
804         return std_imports, external_imports, local_imports
805 
806     def _get_imported_module(self, importnode, modname):
807         try:
808             return importnode.do_import_module(modname)
809         except astroid.TooManyLevelsError:
810             if _ignore_import_failure(importnode, modname, self._ignored_modules):
811                 return None
812             self.add_message("relative-beyond-top-level", node=importnode)
813         except astroid.AstroidSyntaxError as exc:
814             message = "Cannot import {!r} due to syntax error {!r}".format(
815                 modname, str(exc.error)  # pylint: disable=no-member; false positive
816             )
817             self.add_message("syntax-error", line=importnode.lineno, args=message)
818 
819         except astroid.AstroidBuildingException:
820             if not self.linter.is_message_enabled("import-error"):
821                 return None
822             if _ignore_import_failure(importnode, modname, self._ignored_modules):
823                 return None
824             if not self.config.analyse_fallback_blocks and is_from_fallback_block(
825                 importnode
826             ):
827                 return None
828 
829             dotted_modname = _get_import_name(importnode, modname)
830             self.add_message("import-error", args=repr(dotted_modname), node=importnode)
831         return None
832 
833     def _add_imported_module(self, node, importedmodname):
834         """notify an imported module, used to analyze dependencies"""
835         module_file = node.root().file
836         context_name = node.root().name
837         base = os.path.splitext(os.path.basename(module_file))[0]
838 
839         try:
840             importedmodname = astroid.modutils.get_module_part(
841                 importedmodname, module_file
842             )
843         except ImportError:
844             pass
845 
846         if context_name == importedmodname:
847             self.add_message("import-self", node=node)
848 
849         elif not astroid.modutils.is_standard_module(importedmodname):
850             # if this is not a package __init__ module
851             if base != "__init__" and context_name not in self._module_pkg:
852                 # record the module's parent, or the module itself if this is
853                 # a top level module, as the package it belongs to
854                 self._module_pkg[context_name] = context_name.rsplit(".", 1)[0]
855 
856             # handle dependencies
857             importedmodnames = self.stats["dependencies"].setdefault(
858                 importedmodname, set()
859             )
860             if context_name not in importedmodnames:
861                 importedmodnames.add(context_name)
862 
863             # update import graph
864             self.import_graph[context_name].add(importedmodname)
865             if not self.linter.is_message_enabled("cyclic-import", line=node.lineno):
866                 self._excluded_edges[context_name].add(importedmodname)
867 
868     def _check_preferred_module(self, node, mod_path):
869         """check if the module has a preferred replacement"""
870         if mod_path in self.preferred_modules:
871             self.add_message(
872                 "preferred-module",
873                 node=node,
874                 args=(self.preferred_modules[mod_path], mod_path),
875             )
876 
877     def _check_import_as_rename(
878         self, node: Union[astroid.Import, astroid.ImportFrom]
879     ) -> None:
880         names = node.names
881         for name in names:
882             if not all(name):
883                 return
884 
885             splitted_packages = name[0].rsplit(".", maxsplit=1)
886             import_name = splitted_packages[-1]
887             aliased_name = name[1]
888             if import_name != aliased_name:
889                 continue
890 
891             if len(splitted_packages) == 1:
892                 self.add_message("useless-import-alias", node=node)
893             elif len(splitted_packages) == 2:
894                 self.add_message(
895                     "consider-using-from-import",
896                     node=node,
897                     args=(splitted_packages[0], import_name),
898                 )
899 
900     def _check_reimport(self, node, basename=None, level=None):
901         """check if the import is necessary (i.e. not already done)"""
902         if not self.linter.is_message_enabled("reimported"):
903             return
904 
905         frame = node.frame()
906         root = node.root()
907         contexts = [(frame, level)]
908         if root is not frame:
909             contexts.append((root, None))
910 
911         for known_context, known_level in contexts:
912             for name, alias in node.names:
913                 first = _get_first_import(
914                     node, known_context, name, basename, known_level, alias
915                 )
916                 if first is not None:
917                     self.add_message(
918                         "reimported", node=node, args=(name, first.fromlineno)
919                     )
920 
921     def _report_external_dependencies(self, sect, _, _dummy):
922         """return a verbatim layout for displaying dependencies"""
923         dep_info = _make_tree_defs(self._external_dependencies_info().items())
924         if not dep_info:
925             raise EmptyReportError()
926         tree_str = _repr_tree_defs(dep_info)
927         sect.append(VerbatimText(tree_str))
928 
929     def _report_dependencies_graph(self, sect, _, _dummy):
930         """write dependencies as a dot (graphviz) file"""
931         dep_info = self.stats["dependencies"]
932         if not dep_info or not (
933             self.config.import_graph
934             or self.config.ext_import_graph
935             or self.config.int_import_graph
936         ):
937             raise EmptyReportError()
938         filename = self.config.import_graph
939         if filename:
940             _make_graph(filename, dep_info, sect, "")
941         filename = self.config.ext_import_graph
942         if filename:
943             _make_graph(filename, self._external_dependencies_info(), sect, "external ")
944         filename = self.config.int_import_graph
945         if filename:
946             _make_graph(filename, self._internal_dependencies_info(), sect, "internal ")
947 
948     def _filter_dependencies_graph(self, internal):
949         """build the internal or the external dependency graph"""
950         graph = collections.defaultdict(set)
951         for importee, importers in self.stats["dependencies"].items():
952             for importer in importers:
953                 package = self._module_pkg.get(importer, importer)
954                 is_inside = importee.startswith(package)
955                 if is_inside and internal or not is_inside and not internal:
956                     graph[importee].add(importer)
957         return graph
958 
959     @astroid.decorators.cached
960     def _external_dependencies_info(self):
961         """return cached external dependencies information or build and
962         cache them
963         """
964         return self._filter_dependencies_graph(internal=False)
965 
966     @astroid.decorators.cached
967     def _internal_dependencies_info(self):
968         """return cached internal dependencies information or build and
969         cache them
970         """
971         return self._filter_dependencies_graph(internal=True)
972 
973     def _check_wildcard_imports(self, node, imported_module):
974         if node.root().package:
975             # Skip the check if in __init__.py issue #2026
976             return
977 
978         wildcard_import_is_allowed = self._wildcard_import_is_allowed(imported_module)
979         for name, _ in node.names:
980             if name == "*" and not wildcard_import_is_allowed:
981                 self.add_message("wildcard-import", args=node.modname, node=node)
982 
983     def _wildcard_import_is_allowed(self, imported_module):
984         return (
985             self.config.allow_wildcard_with_all
986             and imported_module is not None
987             and "__all__" in imported_module.locals
988         )
989 
990     def _check_toplevel(self, node):
991         """Check whether the import is made outside the module toplevel."""
992         # If the scope of the import is a module, then obviously it is
993         # not outside the module toplevel.
994         if isinstance(node.scope(), astroid.Module):
995             return
996 
997         module_names = [
998             f"{node.modname}.{name[0]}"
999             if isinstance(node, astroid.ImportFrom)
1000             else name[0]
1001             for name in node.names
1002         ]
1003 
1004         # Get the full names of all the imports that are only allowed at the module level
1005         scoped_imports = [
1006             name for name in module_names if name not in self._allow_any_import_level
1007         ]
1008 
1009         if scoped_imports:
1010             self.add_message(
1011                 "import-outside-toplevel", args=", ".join(scoped_imports), node=node
1012             )

</code><intended_behavior>This code location, being part of the logic that checks for unused imports, needs to be adjusted to correctly identify and ignore import statements that are exclusively used in type annotations within type comments. The ImportsChecker should be enhanced to parse type comments for variable annotations and map these uses back to their respective import statements. This adjustment will preserve the original functionality of detecting genuinely unused import statements while excluding those legitimately used in type comments, thus resolving the false positive issue.</intended_behavior>, <file>pylint/utils/ast_walker.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import collections
5 
6 from astroid import nodes
7 
8 
9 class ASTWalker:
10     def __init__(self, linter):
11         # callbacks per node types
12         self.nbstatements = 0
13         self.visit_events = collections.defaultdict(list)
14         self.leave_events = collections.defaultdict(list)
15         self.linter = linter
16         self.exception_msg = False
17 
18     def _is_method_enabled(self, method):
19         if not hasattr(method, "checks_msgs"):
20             return True
21         for msg_desc in method.checks_msgs:
22             if self.linter.is_message_enabled(msg_desc):
23                 return True
24         return False
25 
26     def add_checker(self, checker):
27         """walk to the checker's dir and collect visit and leave methods"""
28         vcids = set()
29         lcids = set()
30         visits = self.visit_events
31         leaves = self.leave_events
32         for member in dir(checker):
33             cid = member[6:]
34             if cid == "default":
35                 continue
36             if member.startswith("visit_"):
37                 v_meth = getattr(checker, member)
38                 # don't use visit_methods with no activated message:
39                 if self._is_method_enabled(v_meth):
40                     visits[cid].append(v_meth)
41                     vcids.add(cid)
42             elif member.startswith("leave_"):
43                 l_meth = getattr(checker, member)
44                 # don't use leave_methods with no activated message:
45                 if self._is_method_enabled(l_meth):
46                     leaves[cid].append(l_meth)
47                     lcids.add(cid)
48         visit_default = getattr(checker, "visit_default", None)
49         if visit_default:
50             for cls in nodes.ALL_NODE_CLASSES:
51                 cid = cls.__name__.lower()
52                 if cid not in vcids:
53                     visits[cid].append(visit_default)
54         # for now we have no "leave_default" method in Pylint
55 
56     def walk(self, astroid):
57         """call visit events of astroid checkers for the given node, recurse on
58         its children, then leave events.
59         """
60         cid = astroid.__class__.__name__.lower()
61 
62         # Detect if the node is a new name for a deprecated alias.
63         # In this case, favour the methods for the deprecated
64         # alias if any,  in order to maintain backwards
65         # compatibility.
66         visit_events = self.visit_events.get(cid, ())
67         leave_events = self.leave_events.get(cid, ())
68 
69         try:
70             if astroid.is_statement:
71                 self.nbstatements += 1
72             # generate events for this node on each checker
73             for callback in visit_events or ():
74                 callback(astroid)
75             # recurse on children
76             for child in astroid.get_children():
77                 self.walk(child)
78             for callback in leave_events or ():
79                 callback(astroid)
80         except Exception:
81             if self.exception_msg is False:
82                 file = getattr(astroid.root(), "file", None)
83                 print(f"Exception on node {repr(astroid)} in file '{file}'")
84                 self.exception_msg = True
85             raise

</code><intended_behavior>If the AST Walker is used for traversing the Python abstract syntax tree and does not currently account for or properly visit type comments, it should be updated or extended to do so. Given the issue is related to imports used within type comments, enhancing the AST Walker to recognize these patterns as valid usage scenarios of the imports will help in accurate lint checks. This ensures that all parts of the code, including type comments, are considered when determining whether an import is used, maintaining the utility of lint checks without compromising on accuracy.</intended_behavior>]
2025-10-18 15:56:24.441 | INFO     | Search completed. Bug locations: [<file>pylint/checkers/imports.py</file>
<class>ImportsChecker</class>
<method>None</method>
<code>
320 class ImportsChecker(DeprecatedMixin, BaseChecker):
321     """checks for
322     * external modules dependencies
323     * relative / wildcard imports
324     * cyclic imports
325     * uses of deprecated modules
326     * uses of modules instead of preferred modules
327     """
328 
329     __implements__ = IAstroidChecker
330 
331     name = "imports"
332     msgs = MSGS
333     priority = -2
334     default_deprecated_modules = ()
335 
336     options = (
337         (
338             "deprecated-modules",
339             {
340                 "default": default_deprecated_modules,
341                 "type": "csv",
342                 "metavar": "<modules>",
343                 "help": "Deprecated modules which should not be used,"
344                 " separated by a comma.",
345             },
346         ),
347         (
348             "preferred-modules",
349             {
350                 "default": DEFAULT_PREFERRED_MODULES,
351                 "type": "csv",
352                 "metavar": "<module:preferred-module>",
353                 "help": "Couples of modules and preferred modules,"
354                 " separated by a comma.",
355             },
356         ),
357         (
358             "import-graph",
359             {
360                 "default": "",
361                 "type": "string",
362                 "metavar": "<file.gv>",
363                 "help": "Output a graph (.gv or any supported image format) of"
364                 " all (i.e. internal and external) dependencies to the given file"
365                 " (report RP0402 must not be disabled).",
366             },
367         ),
368         (
369             "ext-import-graph",
370             {
371                 "default": "",
372                 "type": "string",
373                 "metavar": "<file.gv>",
374                 "help": "Output a graph (.gv or any supported image format)"
375                 " of external dependencies to the given file"
376                 " (report RP0402 must not be disabled).",
377             },
378         ),
379         (
380             "int-import-graph",
381             {
382                 "default": "",
383                 "type": "string",
384                 "metavar": "<file.gv>",
385                 "help": "Output a graph (.gv or any supported image format)"
386                 " of internal dependencies to the given file"
387                 " (report RP0402 must not be disabled).",
388             },
389         ),
390         (
391             "known-standard-library",
392             {
393                 "default": DEFAULT_STANDARD_LIBRARY,
394                 "type": "csv",
395                 "metavar": "<modules>",
396                 "help": "Force import order to recognize a module as part of "
397                 "the standard compatibility libraries.",
398             },
399         ),
400         (
401             "known-third-party",
402             {
403                 "default": DEFAULT_KNOWN_THIRD_PARTY,
404                 "type": "csv",
405                 "metavar": "<modules>",
406                 "help": "Force import order to recognize a module as part of "
407                 "a third party library.",
408             },
409         ),
410         (
411             "allow-any-import-level",
412             {
413                 "default": (),
414                 "type": "csv",
415                 "metavar": "<modules>",
416                 "help": (
417                     "List of modules that can be imported at any level, not just "
418                     "the top level one."
419                 ),
420             },
421         ),
422         (
423             "analyse-fallback-blocks",
424             {
425                 "default": False,
426                 "type": "yn",
427                 "metavar": "<y_or_n>",
428                 "help": "Analyse import fallback blocks. This can be used to "
429                 "support both Python 2 and 3 compatible code, which "
430                 "means that the block might have code that exists "
431                 "only in one or another interpreter, leading to false "
432                 "positives when analysed.",
433             },
434         ),
435         (
436             "allow-wildcard-with-all",
437             {
438                 "default": False,
439                 "type": "yn",
440                 "metavar": "<y_or_n>",
441                 "help": "Allow wildcard imports from modules that define __all__.",
442             },
443         ),
444     )
445 
446     def __init__(self, linter=None):
447         BaseChecker.__init__(self, linter)
448         self.stats = None
449         self.import_graph = None
450         self._imports_stack = []
451         self._first_non_import_node = None
452         self._module_pkg = {}  # mapping of modules to the pkg they belong in
453         self._allow_any_import_level = set()
454         self.reports = (
455             ("RP0401", "External dependencies", self._report_external_dependencies),
456             ("RP0402", "Modules dependencies graph", self._report_dependencies_graph),
457         )
458 
459         self._site_packages = self._compute_site_packages()
460 
461     @staticmethod
462     def _compute_site_packages():
463         def _normalized_path(path):
464             return os.path.normcase(os.path.abspath(path))
465 
466         paths = set()
467         real_prefix = getattr(sys, "real_prefix", None)
468         for prefix in filter(None, (real_prefix, sys.prefix)):
469             path = sysconfig.get_python_lib(prefix=prefix)
470             path = _normalized_path(path)
471             paths.add(path)
472 
473         # Handle Debian's derivatives /usr/local.
474         if os.path.isfile("/etc/debian_version"):
475             for prefix in filter(None, (real_prefix, sys.prefix)):
476                 libpython = os.path.join(
477                     prefix,
478                     "local",
479                     "lib",
480                     "python" + sysconfig.get_python_version(),
481                     "dist-packages",
482                 )
483                 paths.add(libpython)
484         return paths
485 
486     def open(self):
487         """called before visiting project (i.e set of modules)"""
488         self.linter.add_stats(dependencies={})
489         self.linter.add_stats(cycles=[])
490         self.stats = self.linter.stats
491         self.import_graph = collections.defaultdict(set)
492         self._module_pkg = {}  # mapping of modules to the pkg they belong in
493         self._excluded_edges = collections.defaultdict(set)
494         self._ignored_modules = get_global_option(self, "ignored-modules", default=[])
495         # Build a mapping {'module': 'preferred-module'}
496         self.preferred_modules = dict(
497             module.split(":")
498             for module in self.config.preferred_modules
499             if ":" in module
500         )
501         self._allow_any_import_level = set(self.config.allow_any_import_level)
502 
503     def _import_graph_without_ignored_edges(self):
504         filtered_graph = copy.deepcopy(self.import_graph)
505         for node in filtered_graph:
506             filtered_graph[node].difference_update(self._excluded_edges[node])
507         return filtered_graph
508 
509     def close(self):
510         """called before visiting project (i.e set of modules)"""
511         if self.linter.is_message_enabled("cyclic-import"):
512             graph = self._import_graph_without_ignored_edges()
513             vertices = list(graph)
514             for cycle in get_cycles(graph, vertices=vertices):
515                 self.add_message("cyclic-import", args=" -> ".join(cycle))
516 
517     def deprecated_modules(self):
518         """Callback returning the deprecated modules."""
519         return self.config.deprecated_modules
520 
521     @check_messages(*MSGS)
522     def visit_import(self, node):
523         """triggered when an import statement is seen"""
524         self._check_reimport(node)
525         self._check_import_as_rename(node)
526         self._check_toplevel(node)
527 
528         names = [name for name, _ in node.names]
529         if len(names) >= 2:
530             self.add_message("multiple-imports", args=", ".join(names), node=node)
531 
532         for name in names:
533             self.check_deprecated_module(node, name)
534             self._check_preferred_module(node, name)
535             imported_module = self._get_imported_module(node, name)
536             if isinstance(node.parent, astroid.Module):
537                 # Allow imports nested
538                 self._check_position(node)
539             if isinstance(node.scope(), astroid.Module):
540                 self._record_import(node, imported_module)
541 
542             if imported_module is None:
543                 continue
544 
545             self._add_imported_module(node, imported_module.name)
546 
547     @check_messages(*MSGS)
548     def visit_importfrom(self, node):
549         """triggered when a from statement is seen"""
550         basename = node.modname
551         imported_module = self._get_imported_module(node, basename)
552 
553         self._check_import_as_rename(node)
554         self._check_misplaced_future(node)
555         self.check_deprecated_module(node, basename)
556         self._check_preferred_module(node, basename)
557         self._check_wildcard_imports(node, imported_module)
558         self._check_same_line_imports(node)
559         self._check_reimport(node, basename=basename, level=node.level)
560         self._check_toplevel(node)
561 
562         if isinstance(node.parent, astroid.Module):
563             # Allow imports nested
564             self._check_position(node)
565         if isinstance(node.scope(), astroid.Module):
566             self._record_import(node, imported_module)
567         if imported_module is None:
568             return
569         for name, _ in node.names:
570             if name != "*":
571                 self._add_imported_module(node, f"{imported_module.name}.{name}")
572             else:
573                 self._add_imported_module(node, imported_module.name)
574 
575     @check_messages(*MSGS)
576     def leave_module(self, node):
577         # Check imports are grouped by category (standard, 3rd party, local)
578         std_imports, ext_imports, loc_imports = self._check_imports_order(node)
579 
580         # Check that imports are grouped by package within a given category
581         met_import = set()  # set for 'import x' style
582         met_from = set()  # set for 'from x import y' style
583         current_package = None
584         for import_node, import_name in std_imports + ext_imports + loc_imports:
585             if not self.linter.is_message_enabled(
586                 "ungrouped-imports", import_node.fromlineno
587             ):
588                 continue
589             if isinstance(import_node, astroid.node_classes.ImportFrom):
590                 met = met_from
591             else:
592                 met = met_import
593             package, _, _ = import_name.partition(".")
594             if current_package and current_package != package and package in met:
595                 self.add_message("ungrouped-imports", node=import_node, args=package)
596             current_package = package
597             met.add(package)
598 
599         self._imports_stack = []
600         self._first_non_import_node = None
601 
602     def compute_first_non_import_node(self, node):
603         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
604             return
605         # if the node does not contain an import instruction, and if it is the
606         # first node of the module, keep a track of it (all the import positions
607         # of the module will be compared to the position of this first
608         # instruction)
609         if self._first_non_import_node:
610             return
611         if not isinstance(node.parent, astroid.Module):
612             return
613         nested_allowed = [astroid.TryExcept, astroid.TryFinally]
614         is_nested_allowed = [
615             allowed for allowed in nested_allowed if isinstance(node, allowed)
616         ]
617         if is_nested_allowed and any(
618             node.nodes_of_class((astroid.Import, astroid.ImportFrom))
619         ):
620             return
621         if isinstance(node, astroid.Assign):
622             # Add compatibility for module level dunder names
623             # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names
624             valid_targets = [
625                 isinstance(target, astroid.AssignName)
626                 and target.name.startswith("__")
627                 and target.name.endswith("__")
628                 for target in node.targets
629             ]
630             if all(valid_targets):
631                 return
632         self._first_non_import_node = node
633 
634     visit_tryfinally = (
635         visit_tryexcept
636     ) = (
637         visit_assignattr
638     ) = (
639         visit_assign
640     ) = (
641         visit_ifexp
642     ) = visit_comprehension = visit_expr = visit_if = compute_first_non_import_node
643 
644     def visit_functiondef(self, node):
645         if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
646             return
647         # If it is the first non import instruction of the module, record it.
648         if self._first_non_import_node:
649             return
650 
651         # Check if the node belongs to an `If` or a `Try` block. If they
652         # contain imports, skip recording this node.
653         if not isinstance(node.parent.scope(), astroid.Module):
654             return
655 
656         root = node
657         while not isinstance(root.parent, astroid.Module):
658             root = root.parent
659 
660         if isinstance(root, (astroid.If, astroid.TryFinally, astroid.TryExcept)):
661             if any(root.nodes_of_class((astroid.Import, astroid.ImportFrom))):
662                 return
663 
664         self._first_non_import_node = node
665 
666     visit_classdef = visit_for = visit_while = visit_functiondef
667 
668     def _check_misplaced_future(self, node):
669         basename = node.modname
670         if basename == "__future__":
671             # check if this is the first non-docstring statement in the module
672             prev = node.previous_sibling()
673             if prev:
674                 # consecutive future statements are possible
675                 if not (
676                     isinstance(prev, astroid.ImportFrom)
677                     and prev.modname == "__future__"
678                 ):
679                     self.add_message("misplaced-future", node=node)
680             return
681 
682     def _check_same_line_imports(self, node):
683         # Detect duplicate imports on the same line.
684         names = (name for name, _ in node.names)
685         counter = collections.Counter(names)
686         for name, count in counter.items():
687             if count > 1:
688                 self.add_message("reimported", node=node, args=(name, node.fromlineno))
689 
690     def _check_position(self, node):
691         """Check `node` import or importfrom node position is correct
692 
693         Send a message  if `node` comes before another instruction
694         """
695         # if a first non-import instruction has already been encountered,
696         # it means the import comes after it and therefore is not well placed
697         if self._first_non_import_node:
698             self.add_message("wrong-import-position", node=node, args=node.as_string())
699 
700     def _record_import(self, node, importedmodnode):
701         """Record the package `node` imports from"""
702         if isinstance(node, astroid.ImportFrom):
703             importedname = node.modname
704         else:
705             importedname = importedmodnode.name if importedmodnode else None
706         if not importedname:
707             importedname = node.names[0][0].split(".")[0]
708 
709         if isinstance(node, astroid.ImportFrom) and (node.level or 0) >= 1:
710             # We need the importedname with first point to detect local package
711             # Example of node:
712             #  'from .my_package1 import MyClass1'
713             #  the output should be '.my_package1' instead of 'my_package1'
714             # Example of node:
715             #  'from . import my_package2'
716             #  the output should be '.my_package2' instead of '{pyfile}'
717             importedname = "." + importedname
718 
719         self._imports_stack.append((node, importedname))
720 
721     @staticmethod
722     def _is_fallback_import(node, imports):
723         imports = [import_node for (import_node, _) in imports]
724         return any(astroid.are_exclusive(import_node, node) for import_node in imports)
725 
726     def _check_imports_order(self, _module_node):
727         """Checks imports of module `node` are grouped by category
728 
729         Imports must follow this order: standard, 3rd party, local
730         """
731         std_imports = []
732         third_party_imports = []
733         first_party_imports = []
734         # need of a list that holds third or first party ordered import
735         external_imports = []
736         local_imports = []
737         third_party_not_ignored = []
738         first_party_not_ignored = []
739         local_not_ignored = []
740         isort_driver = IsortDriver(self.config)
741         for node, modname in self._imports_stack:
742             if modname.startswith("."):
743                 package = "." + modname.split(".")[1]
744             else:
745                 package = modname.split(".")[0]
746             nested = not isinstance(node.parent, astroid.Module)
747             ignore_for_import_order = not self.linter.is_message_enabled(
748                 "wrong-import-order", node.fromlineno
749             )
750             import_category = isort_driver.place_module(package)
751             node_and_package_import = (node, package)
752             if import_category in ("FUTURE", "STDLIB"):
753                 std_imports.append(node_and_package_import)
754                 wrong_import = (
755                     third_party_not_ignored
756                     or first_party_not_ignored
757                     or local_not_ignored
758                 )
759                 if self._is_fallback_import(node, wrong_import):
760                     continue
761                 if wrong_import and not nested:
762                     self.add_message(
763                         "wrong-import-order",
764                         node=node,
765                         args=(
766                             'standard import "%s"' % node.as_string(),
767                             '"%s"' % wrong_import[0][0].as_string(),
768                         ),
769                     )
770             elif import_category == "THIRDPARTY":
771                 third_party_imports.append(node_and_package_import)
772                 external_imports.append(node_and_package_import)
773                 if not nested and not ignore_for_import_order:
774                     third_party_not_ignored.append(node_and_package_import)
775                 wrong_import = first_party_not_ignored or local_not_ignored
776                 if wrong_import and not nested:
777                     self.add_message(
778                         "wrong-import-order",
779                         node=node,
780                         args=(
781                             'third party import "%s"' % node.as_string(),
782                             '"%s"' % wrong_import[0][0].as_string(),
783                         ),
784                     )
785             elif import_category == "FIRSTPARTY":
786                 first_party_imports.append(node_and_package_import)
787                 external_imports.append(node_and_package_import)
788                 if not nested and not ignore_for_import_order:
789                     first_party_not_ignored.append(node_and_package_import)
790                 wrong_import = local_not_ignored
791                 if wrong_import and not nested:
792                     self.add_message(
793                         "wrong-import-order",
794                         node=node,
795                         args=(
796                             'first party import "%s"' % node.as_string(),
797                             '"%s"' % wrong_import[0][0].as_string(),
798                         ),
799                     )
800             elif import_category == "LOCALFOLDER":
801                 local_imports.append((node, package))
802                 if not nested and not ignore_for_import_order:
803                     local_not_ignored.append((node, package))
804         return std_imports, external_imports, local_imports
805 
806     def _get_imported_module(self, importnode, modname):
807         try:
808             return importnode.do_import_module(modname)
809         except astroid.TooManyLevelsError:
810             if _ignore_import_failure(importnode, modname, self._ignored_modules):
811                 return None
812             self.add_message("relative-beyond-top-level", node=importnode)
813         except astroid.AstroidSyntaxError as exc:
814             message = "Cannot import {!r} due to syntax error {!r}".format(
815                 modname, str(exc.error)  # pylint: disable=no-member; false positive
816             )
817             self.add_message("syntax-error", line=importnode.lineno, args=message)
818 
819         except astroid.AstroidBuildingException:
820             if not self.linter.is_message_enabled("import-error"):
821                 return None
822             if _ignore_import_failure(importnode, modname, self._ignored_modules):
823                 return None
824             if not self.config.analyse_fallback_blocks and is_from_fallback_block(
825                 importnode
826             ):
827                 return None
828 
829             dotted_modname = _get_import_name(importnode, modname)
830             self.add_message("import-error", args=repr(dotted_modname), node=importnode)
831         return None
832 
833     def _add_imported_module(self, node, importedmodname):
834         """notify an imported module, used to analyze dependencies"""
835         module_file = node.root().file
836         context_name = node.root().name
837         base = os.path.splitext(os.path.basename(module_file))[0]
838 
839         try:
840             importedmodname = astroid.modutils.get_module_part(
841                 importedmodname, module_file
842             )
843         except ImportError:
844             pass
845 
846         if context_name == importedmodname:
847             self.add_message("import-self", node=node)
848 
849         elif not astroid.modutils.is_standard_module(importedmodname):
850             # if this is not a package __init__ module
851             if base != "__init__" and context_name not in self._module_pkg:
852                 # record the module's parent, or the module itself if this is
853                 # a top level module, as the package it belongs to
854                 self._module_pkg[context_name] = context_name.rsplit(".", 1)[0]
855 
856             # handle dependencies
857             importedmodnames = self.stats["dependencies"].setdefault(
858                 importedmodname, set()
859             )
860             if context_name not in importedmodnames:
861                 importedmodnames.add(context_name)
862 
863             # update import graph
864             self.import_graph[context_name].add(importedmodname)
865             if not self.linter.is_message_enabled("cyclic-import", line=node.lineno):
866                 self._excluded_edges[context_name].add(importedmodname)
867 
868     def _check_preferred_module(self, node, mod_path):
869         """check if the module has a preferred replacement"""
870         if mod_path in self.preferred_modules:
871             self.add_message(
872                 "preferred-module",
873                 node=node,
874                 args=(self.preferred_modules[mod_path], mod_path),
875             )
876 
877     def _check_import_as_rename(
878         self, node: Union[astroid.Import, astroid.ImportFrom]
879     ) -> None:
880         names = node.names
881         for name in names:
882             if not all(name):
883                 return
884 
885             splitted_packages = name[0].rsplit(".", maxsplit=1)
886             import_name = splitted_packages[-1]
887             aliased_name = name[1]
888             if import_name != aliased_name:
889                 continue
890 
891             if len(splitted_packages) == 1:
892                 self.add_message("useless-import-alias", node=node)
893             elif len(splitted_packages) == 2:
894                 self.add_message(
895                     "consider-using-from-import",
896                     node=node,
897                     args=(splitted_packages[0], import_name),
898                 )
899 
900     def _check_reimport(self, node, basename=None, level=None):
901         """check if the import is necessary (i.e. not already done)"""
902         if not self.linter.is_message_enabled("reimported"):
903             return
904 
905         frame = node.frame()
906         root = node.root()
907         contexts = [(frame, level)]
908         if root is not frame:
909             contexts.append((root, None))
910 
911         for known_context, known_level in contexts:
912             for name, alias in node.names:
913                 first = _get_first_import(
914                     node, known_context, name, basename, known_level, alias
915                 )
916                 if first is not None:
917                     self.add_message(
918                         "reimported", node=node, args=(name, first.fromlineno)
919                     )
920 
921     def _report_external_dependencies(self, sect, _, _dummy):
922         """return a verbatim layout for displaying dependencies"""
923         dep_info = _make_tree_defs(self._external_dependencies_info().items())
924         if not dep_info:
925             raise EmptyReportError()
926         tree_str = _repr_tree_defs(dep_info)
927         sect.append(VerbatimText(tree_str))
928 
929     def _report_dependencies_graph(self, sect, _, _dummy):
930         """write dependencies as a dot (graphviz) file"""
931         dep_info = self.stats["dependencies"]
932         if not dep_info or not (
933             self.config.import_graph
934             or self.config.ext_import_graph
935             or self.config.int_import_graph
936         ):
937             raise EmptyReportError()
938         filename = self.config.import_graph
939         if filename:
940             _make_graph(filename, dep_info, sect, "")
941         filename = self.config.ext_import_graph
942         if filename:
943             _make_graph(filename, self._external_dependencies_info(), sect, "external ")
944         filename = self.config.int_import_graph
945         if filename:
946             _make_graph(filename, self._internal_dependencies_info(), sect, "internal ")
947 
948     def _filter_dependencies_graph(self, internal):
949         """build the internal or the external dependency graph"""
950         graph = collections.defaultdict(set)
951         for importee, importers in self.stats["dependencies"].items():
952             for importer in importers:
953                 package = self._module_pkg.get(importer, importer)
954                 is_inside = importee.startswith(package)
955                 if is_inside and internal or not is_inside and not internal:
956                     graph[importee].add(importer)
957         return graph
958 
959     @astroid.decorators.cached
960     def _external_dependencies_info(self):
961         """return cached external dependencies information or build and
962         cache them
963         """
964         return self._filter_dependencies_graph(internal=False)
965 
966     @astroid.decorators.cached
967     def _internal_dependencies_info(self):
968         """return cached internal dependencies information or build and
969         cache them
970         """
971         return self._filter_dependencies_graph(internal=True)
972 
973     def _check_wildcard_imports(self, node, imported_module):
974         if node.root().package:
975             # Skip the check if in __init__.py issue #2026
976             return
977 
978         wildcard_import_is_allowed = self._wildcard_import_is_allowed(imported_module)
979         for name, _ in node.names:
980             if name == "*" and not wildcard_import_is_allowed:
981                 self.add_message("wildcard-import", args=node.modname, node=node)
982 
983     def _wildcard_import_is_allowed(self, imported_module):
984         return (
985             self.config.allow_wildcard_with_all
986             and imported_module is not None
987             and "__all__" in imported_module.locals
988         )
989 
990     def _check_toplevel(self, node):
991         """Check whether the import is made outside the module toplevel."""
992         # If the scope of the import is a module, then obviously it is
993         # not outside the module toplevel.
994         if isinstance(node.scope(), astroid.Module):
995             return
996 
997         module_names = [
998             f"{node.modname}.{name[0]}"
999             if isinstance(node, astroid.ImportFrom)
1000             else name[0]
1001             for name in node.names
1002         ]
1003 
1004         # Get the full names of all the imports that are only allowed at the module level
1005         scoped_imports = [
1006             name for name in module_names if name not in self._allow_any_import_level
1007         ]
1008 
1009         if scoped_imports:
1010             self.add_message(
1011                 "import-outside-toplevel", args=", ".join(scoped_imports), node=node
1012             )

</code><intended_behavior>This code location, being part of the logic that checks for unused imports, needs to be adjusted to correctly identify and ignore import statements that are exclusively used in type annotations within type comments. The ImportsChecker should be enhanced to parse type comments for variable annotations and map these uses back to their respective import statements. This adjustment will preserve the original functionality of detecting genuinely unused import statements while excluding those legitimately used in type comments, thus resolving the false positive issue.</intended_behavior>, <file>pylint/utils/ast_walker.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import collections
5 
6 from astroid import nodes
7 
8 
9 class ASTWalker:
10     def __init__(self, linter):
11         # callbacks per node types
12         self.nbstatements = 0
13         self.visit_events = collections.defaultdict(list)
14         self.leave_events = collections.defaultdict(list)
15         self.linter = linter
16         self.exception_msg = False
17 
18     def _is_method_enabled(self, method):
19         if not hasattr(method, "checks_msgs"):
20             return True
21         for msg_desc in method.checks_msgs:
22             if self.linter.is_message_enabled(msg_desc):
23                 return True
24         return False
25 
26     def add_checker(self, checker):
27         """walk to the checker's dir and collect visit and leave methods"""
28         vcids = set()
29         lcids = set()
30         visits = self.visit_events
31         leaves = self.leave_events
32         for member in dir(checker):
33             cid = member[6:]
34             if cid == "default":
35                 continue
36             if member.startswith("visit_"):
37                 v_meth = getattr(checker, member)
38                 # don't use visit_methods with no activated message:
39                 if self._is_method_enabled(v_meth):
40                     visits[cid].append(v_meth)
41                     vcids.add(cid)
42             elif member.startswith("leave_"):
43                 l_meth = getattr(checker, member)
44                 # don't use leave_methods with no activated message:
45                 if self._is_method_enabled(l_meth):
46                     leaves[cid].append(l_meth)
47                     lcids.add(cid)
48         visit_default = getattr(checker, "visit_default", None)
49         if visit_default:
50             for cls in nodes.ALL_NODE_CLASSES:
51                 cid = cls.__name__.lower()
52                 if cid not in vcids:
53                     visits[cid].append(visit_default)
54         # for now we have no "leave_default" method in Pylint
55 
56     def walk(self, astroid):
57         """call visit events of astroid checkers for the given node, recurse on
58         its children, then leave events.
59         """
60         cid = astroid.__class__.__name__.lower()
61 
62         # Detect if the node is a new name for a deprecated alias.
63         # In this case, favour the methods for the deprecated
64         # alias if any,  in order to maintain backwards
65         # compatibility.
66         visit_events = self.visit_events.get(cid, ())
67         leave_events = self.leave_events.get(cid, ())
68 
69         try:
70             if astroid.is_statement:
71                 self.nbstatements += 1
72             # generate events for this node on each checker
73             for callback in visit_events or ():
74                 callback(astroid)
75             # recurse on children
76             for child in astroid.get_children():
77                 self.walk(child)
78             for callback in leave_events or ():
79                 callback(astroid)
80         except Exception:
81             if self.exception_msg is False:
82                 file = getattr(astroid.root(), "file", None)
83                 print(f"Exception on node {repr(astroid)} in file '{file}'")
84                 self.exception_msg = True
85             raise

</code><intended_behavior>If the AST Walker is used for traversing the Python abstract syntax tree and does not currently account for or properly visit type comments, it should be updated or extended to do so. Given the issue is related to imports used within type comments, enhancing the AST Walker to recognize these patterns as valid usage scenarios of the imports will help in accurate lint checks. This ensures that all parts of the code, including type comments, are considered when determining whether an import is used, maintaining the utility of lint checks without compromising on accuracy.</intended_behavior>]
2025-10-18 15:56:24.441 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 15:56:24.441 | INFO     | Search-only: skipping patch selection
2025-10-18 15:56:24.511 | INFO     | Task pylint-dev__pylint-4604 completed successfully.
2025-10-18 15:56:24.512 | INFO     | No patch generated. You can try running ACR again.
