2025-10-18 10:41:38.875 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 10:41:43.016 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=368, output_tokens=12, cost=0.004040
2025-10-18 10:41:43.017 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 10:41:43.021 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:41:52.659 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=672, output_tokens=377, cost=0.018030
2025-10-18 10:41:52.701 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:41:55.179 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=731, output_tokens=70, cost=0.009410
2025-10-18 10:41:55.180 | DEBUG    | Extracted a valid json.
2025-10-18 10:41:55.180 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Client\")",
        "search_class(\"ClientOffice\")",
        "search_class(\"ClientAdmin\")",
        "search_method_in_class(\"get_search_results\", \"ModelAdmin\")",
        "search_code(\"qs = qs.filter(\")"
    ],
    "bug_locations": []
}
2025-10-18 10:41:55.234 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 10:41:55.235 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 10:42:11.431 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1916, output_tokens=617, cost=0.037670
2025-10-18 10:42:11.443 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:42:18.423 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2749, output_tokens=297, cost=0.036400
2025-10-18 10:42:18.429 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:42:25.164 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=651, output_tokens=221, cost=0.013140
2025-10-18 10:42:25.165 | DEBUG    | Extracted a valid json.
2025-10-18 10:42:25.165 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/contrib/admin/options.py",
            "class": "ModelAdmin",
            "method": "get_search_results",
            "intended_behavior": "The method `get_search_results` should be optimized to reduce the number of unnecessary JOIN operations generated when executing searches with multiple terms across related objects. Implementing a way to aggregate search conditions for related fields into a fewer number of more complex ORM queries that achieve the same search results but with less database overhead. Possibly introducing conditional logic that limits the depth or number of JOINs based on the `search_fields` configuration or the number of search terms. Ensuring that the solution preserves the flexibility of the Django admin search_fields, including the ability to specify different types of searches (e.g., starts with, exact match, contains) while enhancing performance. Retaining the functionality to return a tuple containing the modified queryset and a boolean indicating if the results may contain duplicates, without altering the expected outcomes of searches performed through the admin interface."
        }
    ]
}
2025-10-18 10:42:25.179 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>get_search_results</method>
<code>
994     def get_search_results(self, request, queryset, search_term):
995         """
996         Return a tuple containing a queryset to implement the search
997         and a boolean indicating if the results may contain duplicates.
998         """
999         # Apply keyword searches.
1000         def construct_search(field_name):
1001             if field_name.startswith('^'):
1002                 return "%s__istartswith" % field_name[1:]
1003             elif field_name.startswith('='):
1004                 return "%s__iexact" % field_name[1:]
1005             elif field_name.startswith('@'):
1006                 return "%s__search" % field_name[1:]
1007             # Use field_name if it includes a lookup.
1008             opts = queryset.model._meta
1009             lookup_fields = field_name.split(LOOKUP_SEP)
1010             # Go through the fields, following all relations.
1011             prev_field = None
1012             for path_part in lookup_fields:
1013                 if path_part == 'pk':
1014                     path_part = opts.pk.name
1015                 try:
1016                     field = opts.get_field(path_part)
1017                 except FieldDoesNotExist:
1018                     # Use valid query lookups.
1019                     if prev_field and prev_field.get_lookup(path_part):
1020                         return field_name
1021                 else:
1022                     prev_field = field
1023                     if hasattr(field, 'path_infos'):
1024                         # Update opts to follow the relation.
1025                         opts = field.path_infos[-1].to_opts
1026             # Otherwise, use the field with icontains.
1027             return "%s__icontains" % field_name
1028 
1029         may_have_duplicates = False
1030         search_fields = self.get_search_fields(request)
1031         if search_fields and search_term:
1032             orm_lookups = [construct_search(str(search_field))
1033                            for search_field in search_fields]
1034             for bit in smart_split(search_term):
1035                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1036                     bit = unescape_string_literal(bit)
1037                 or_queries = models.Q(
1038                     *((orm_lookup, bit) for orm_lookup in orm_lookups),
1039                     _connector=models.Q.OR,
1040                 )
1041                 queryset = queryset.filter(or_queries)
1042             may_have_duplicates |= any(
1043                 lookup_spawns_duplicates(self.opts, search_spec)
1044                 for search_spec in orm_lookups
1045             )
1046         return queryset, may_have_duplicates

</code><intended_behavior>The method `get_search_results` should be optimized to reduce the number of unnecessary JOIN operations generated when executing searches with multiple terms across related objects. Implementing a way to aggregate search conditions for related fields into a fewer number of more complex ORM queries that achieve the same search results but with less database overhead. Possibly introducing conditional logic that limits the depth or number of JOINs based on the `search_fields` configuration or the number of search terms. Ensuring that the solution preserves the flexibility of the Django admin search_fields, including the ability to specify different types of searches (e.g., starts with, exact match, contains) while enhancing performance. Retaining the functionality to return a tuple containing the modified queryset and a boolean indicating if the results may contain duplicates, without altering the expected outcomes of searches performed through the admin interface.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
550 class ModelAdmin(BaseModelAdmin):
551     """Encapsulate all admin options and functionality for a given model."""
552 
553     list_display = ('__str__',)
554     list_display_links = ()
555     list_filter = ()
556     list_select_related = False
557     list_per_page = 100
558     list_max_show_all = 200
559     list_editable = ()
560     search_fields = ()
561     search_help_text = None
562     date_hierarchy = None
563     save_as = False
564     save_as_continue = True
565     save_on_top = False
566     paginator = Paginator
567     preserve_filters = True
568     inlines = []
569 
570     # Custom templates (designed to be over-ridden in subclasses)
571     add_form_template = None
572     change_form_template = None
573     change_list_template = None
574     delete_confirmation_template = None
575     delete_selected_confirmation_template = None
576     object_history_template = None
577     popup_response_template = None
578 
579     # Actions
580     actions = []
581     action_form = helpers.ActionForm
582     actions_on_top = True
583     actions_on_bottom = False
584     actions_selection_counter = True
585     checks_class = ModelAdminChecks
586 
587     def __init__(self, model, admin_site):
588         self.model = model
589         self.opts = model._meta
590         self.admin_site = admin_site
591         super().__init__()
592 
593     def __str__(self):
594         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
595 
596     def __repr__(self):
597         return (
598             f'<{self.__class__.__qualname__}: model={self.model.__qualname__} '
599             f'site={self.admin_site!r}>'
600         )
601 
602     def get_inline_instances(self, request, obj=None):
603         inline_instances = []
604         for inline_class in self.get_inlines(request, obj):
605             inline = inline_class(self.model, self.admin_site)
606             if request:
607                 if not (inline.has_view_or_change_permission(request, obj) or
608                         inline.has_add_permission(request, obj) or
609                         inline.has_delete_permission(request, obj)):
610                     continue
611                 if not inline.has_add_permission(request, obj):
612                     inline.max_num = 0
613             inline_instances.append(inline)
614 
615         return inline_instances
616 
617     def get_urls(self):
618         from django.urls import path
619 
620         def wrap(view):
621             def wrapper(*args, **kwargs):
622                 return self.admin_site.admin_view(view)(*args, **kwargs)
623             wrapper.model_admin = self
624             return update_wrapper(wrapper, view)
625 
626         info = self.model._meta.app_label, self.model._meta.model_name
627 
628         return [
629             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
630             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
631             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
632             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
633             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
634             # For backwards compatibility (was the change url before 1.9)
635             path('<path:object_id>/', wrap(RedirectView.as_view(
636                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
637             ))),
638         ]
639 
640     @property
641     def urls(self):
642         return self.get_urls()
643 
644     @property
645     def media(self):
646         extra = '' if settings.DEBUG else '.min'
647         js = [
648             'vendor/jquery/jquery%s.js' % extra,
649             'jquery.init.js',
650             'core.js',
651             'admin/RelatedObjectLookups.js',
652             'actions.js',
653             'urlify.js',
654             'prepopulate.js',
655             'vendor/xregexp/xregexp%s.js' % extra,
656         ]
657         return forms.Media(js=['admin/js/%s' % url for url in js])
658 
659     def get_model_perms(self, request):
660         """
661         Return a dict of all perms for this model. This dict has the keys
662         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
663         for each of those actions.
664         """
665         return {
666             'add': self.has_add_permission(request),
667             'change': self.has_change_permission(request),
668             'delete': self.has_delete_permission(request),
669             'view': self.has_view_permission(request),
670         }
671 
672     def _get_form_for_get_fields(self, request, obj):
673         return self.get_form(request, obj, fields=None)
674 
675     def get_form(self, request, obj=None, change=False, **kwargs):
676         """
677         Return a Form class for use in the admin add view. This is used by
678         add_view and change_view.
679         """
680         if 'fields' in kwargs:
681             fields = kwargs.pop('fields')
682         else:
683             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
684         excluded = self.get_exclude(request, obj)
685         exclude = [] if excluded is None else list(excluded)
686         readonly_fields = self.get_readonly_fields(request, obj)
687         exclude.extend(readonly_fields)
688         # Exclude all fields if it's a change form and the user doesn't have
689         # the change permission.
690         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
691             exclude.extend(fields)
692         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
693             # Take the custom ModelForm's Meta.exclude into account only if the
694             # ModelAdmin doesn't define its own.
695             exclude.extend(self.form._meta.exclude)
696         # if exclude is an empty list we pass None to be consistent with the
697         # default on modelform_factory
698         exclude = exclude or None
699 
700         # Remove declared form fields which are in readonly_fields.
701         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
702         form = type(self.form.__name__, (self.form,), new_attrs)
703 
704         defaults = {
705             'form': form,
706             'fields': fields,
707             'exclude': exclude,
708             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
709             **kwargs,
710         }
711 
712         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
713             defaults['fields'] = forms.ALL_FIELDS
714 
715         try:
716             return modelform_factory(self.model, **defaults)
717         except FieldError as e:
718             raise FieldError(
719                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
720                 % (e, self.__class__.__name__)
721             )
722 
723     def get_changelist(self, request, **kwargs):
724         """
725         Return the ChangeList class for use on the changelist page.
726         """
727         from django.contrib.admin.views.main import ChangeList
728         return ChangeList
729 
730     def get_changelist_instance(self, request):
731         """
732         Return a `ChangeList` instance based on `request`. May raise
733         `IncorrectLookupParameters`.
734         """
735         list_display = self.get_list_display(request)
736         list_display_links = self.get_list_display_links(request, list_display)
737         # Add the action checkboxes if any actions are available.
738         if self.get_actions(request):
739             list_display = ['action_checkbox', *list_display]
740         sortable_by = self.get_sortable_by(request)
741         ChangeList = self.get_changelist(request)
742         return ChangeList(
743             request,
744             self.model,
745             list_display,
746             list_display_links,
747             self.get_list_filter(request),
748             self.date_hierarchy,
749             self.get_search_fields(request),
750             self.get_list_select_related(request),
751             self.list_per_page,
752             self.list_max_show_all,
753             self.list_editable,
754             self,
755             sortable_by,
756             self.search_help_text,
757         )
758 
759     def get_object(self, request, object_id, from_field=None):
760         """
761         Return an instance matching the field and value provided, the primary
762         key is used if no field is provided. Return ``None`` if no match is
763         found or the object_id fails validation.
764         """
765         queryset = self.get_queryset(request)
766         model = queryset.model
767         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
768         try:
769             object_id = field.to_python(object_id)
770             return queryset.get(**{field.name: object_id})
771         except (model.DoesNotExist, ValidationError, ValueError):
772             return None
773 
774     def get_changelist_form(self, request, **kwargs):
775         """
776         Return a Form class for use in the Formset on the changelist page.
777         """
778         defaults = {
779             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
780             **kwargs,
781         }
782         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
783             defaults['fields'] = forms.ALL_FIELDS
784 
785         return modelform_factory(self.model, **defaults)
786 
787     def get_changelist_formset(self, request, **kwargs):
788         """
789         Return a FormSet class for use on the changelist page if list_editable
790         is used.
791         """
792         defaults = {
793             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
794             **kwargs,
795         }
796         return modelformset_factory(
797             self.model, self.get_changelist_form(request), extra=0,
798             fields=self.list_editable, **defaults
799         )
800 
801     def get_formsets_with_inlines(self, request, obj=None):
802         """
803         Yield formsets and the corresponding inlines.
804         """
805         for inline in self.get_inline_instances(request, obj):
806             yield inline.get_formset(request, obj), inline
807 
808     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
809         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
810 
811     def log_addition(self, request, obj, message):
812         """
813         Log that an object has been successfully added.
814 
815         The default implementation creates an admin LogEntry object.
816         """
817         from django.contrib.admin.models import ADDITION, LogEntry
818         return LogEntry.objects.log_action(
819             user_id=request.user.pk,
820             content_type_id=get_content_type_for_model(obj).pk,
821             object_id=obj.pk,
822             object_repr=str(obj),
823             action_flag=ADDITION,
824             change_message=message,
825         )
826 
827     def log_change(self, request, obj, message):
828         """
829         Log that an object has been successfully changed.
830 
831         The default implementation creates an admin LogEntry object.
832         """
833         from django.contrib.admin.models import CHANGE, LogEntry
834         return LogEntry.objects.log_action(
835             user_id=request.user.pk,
836             content_type_id=get_content_type_for_model(obj).pk,
837             object_id=obj.pk,
838             object_repr=str(obj),
839             action_flag=CHANGE,
840             change_message=message,
841         )
842 
843     def log_deletion(self, request, obj, object_repr):
844         """
845         Log that an object will be deleted. Note that this method must be
846         called before the deletion.
847 
848         The default implementation creates an admin LogEntry object.
849         """
850         from django.contrib.admin.models import DELETION, LogEntry
851         return LogEntry.objects.log_action(
852             user_id=request.user.pk,
853             content_type_id=get_content_type_for_model(obj).pk,
854             object_id=obj.pk,
855             object_repr=object_repr,
856             action_flag=DELETION,
857         )
858 
859     @display(description=mark_safe('<input type="checkbox" id="action-toggle">'))
860     def action_checkbox(self, obj):
861         """
862         A list_display column containing a checkbox widget.
863         """
864         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
865 
866     @staticmethod
867     def _get_action_description(func, name):
868         return getattr(func, 'short_description', capfirst(name.replace('_', ' ')))
869 
870     def _get_base_actions(self):
871         """Return the list of actions, prior to any request-based filtering."""
872         actions = []
873         base_actions = (self.get_action(action) for action in self.actions or [])
874         # get_action might have returned None, so filter any of those out.
875         base_actions = [action for action in base_actions if action]
876         base_action_names = {name for _, name, _ in base_actions}
877 
878         # Gather actions from the admin site first
879         for (name, func) in self.admin_site.actions:
880             if name in base_action_names:
881                 continue
882             description = self._get_action_description(func, name)
883             actions.append((func, name, description))
884         # Add actions from this ModelAdmin.
885         actions.extend(base_actions)
886         return actions
887 
888     def _filter_actions_by_permissions(self, request, actions):
889         """Filter out any actions that the user doesn't have access to."""
890         filtered_actions = []
891         for action in actions:
892             callable = action[0]
893             if not hasattr(callable, 'allowed_permissions'):
894                 filtered_actions.append(action)
895                 continue
896             permission_checks = (
897                 getattr(self, 'has_%s_permission' % permission)
898                 for permission in callable.allowed_permissions
899             )
900             if any(has_permission(request) for has_permission in permission_checks):
901                 filtered_actions.append(action)
902         return filtered_actions
903 
904     def get_actions(self, request):
905         """
906         Return a dictionary mapping the names of all actions for this
907         ModelAdmin to a tuple of (callable, name, description) for each action.
908         """
909         # If self.actions is set to None that means actions are disabled on
910         # this page.
911         if self.actions is None or IS_POPUP_VAR in request.GET:
912             return {}
913         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
914         return {name: (func, name, desc) for func, name, desc in actions}
915 
916     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
917         """
918         Return a list of choices for use in a form object.  Each choice is a
919         tuple (name, description).
920         """
921         choices = [] + default_choices
922         for func, name, description in self.get_actions(request).values():
923             choice = (name, description % model_format_dict(self.opts))
924             choices.append(choice)
925         return choices
926 
927     def get_action(self, action):
928         """
929         Return a given action from a parameter, which can either be a callable,
930         or the name of a method on the ModelAdmin.  Return is a tuple of
931         (callable, name, description).
932         """
933         # If the action is a callable, just use it.
934         if callable(action):
935             func = action
936             action = action.__name__
937 
938         # Next, look for a method. Grab it off self.__class__ to get an unbound
939         # method instead of a bound one; this ensures that the calling
940         # conventions are the same for functions and methods.
941         elif hasattr(self.__class__, action):
942             func = getattr(self.__class__, action)
943 
944         # Finally, look for a named method on the admin site
945         else:
946             try:
947                 func = self.admin_site.get_action(action)
948             except KeyError:
949                 return None
950 
951         description = self._get_action_description(func, action)
952         return func, action, description
953 
954     def get_list_display(self, request):
955         """
956         Return a sequence containing the fields to be displayed on the
957         changelist.
958         """
959         return self.list_display
960 
961     def get_list_display_links(self, request, list_display):
962         """
963         Return a sequence containing the fields to be displayed as links
964         on the changelist. The list_display parameter is the list of fields
965         returned by get_list_display().
966         """
967         if self.list_display_links or self.list_display_links is None or not list_display:
968             return self.list_display_links
969         else:
970             # Use only the first item in list_display as link
971             return list(list_display)[:1]
972 
973     def get_list_filter(self, request):
974         """
975         Return a sequence containing the fields to be displayed as filters in
976         the right sidebar of the changelist page.
977         """
978         return self.list_filter
979 
980     def get_list_select_related(self, request):
981         """
982         Return a list of fields to add to the select_related() part of the
983         changelist items query.
984         """
985         return self.list_select_related
986 
987     def get_search_fields(self, request):
988         """
989         Return a sequence containing the fields to be searched whenever
990         somebody submits a search query.
991         """
992         return self.search_fields
993 
994     def get_search_results(self, request, queryset, search_term):
995         """
996         Return a tuple containing a queryset to implement the search
997         and a boolean indicating if the results may contain duplicates.
998         """
999         # Apply keyword searches.
1000         def construct_search(field_name):
1001             if field_name.startswith('^'):
1002                 return "%s__istartswith" % field_name[1:]
1003             elif field_name.startswith('='):
1004                 return "%s__iexact" % field_name[1:]
1005             elif field_name.startswith('@'):
1006                 return "%s__search" % field_name[1:]
1007             # Use field_name if it includes a lookup.
1008             opts = queryset.model._meta
1009             lookup_fields = field_name.split(LOOKUP_SEP)
1010             # Go through the fields, following all relations.
1011             prev_field = None
1012             for path_part in lookup_fields:
1013                 if path_part == 'pk':
1014                     path_part = opts.pk.name
1015                 try:
1016                     field = opts.get_field(path_part)
1017                 except FieldDoesNotExist:
1018                     # Use valid query lookups.
1019                     if prev_field and prev_field.get_lookup(path_part):
1020                         return field_name
1021                 else:
1022                     prev_field = field
1023                     if hasattr(field, 'path_infos'):
1024                         # Update opts to follow the relation.
1025                         opts = field.path_infos[-1].to_opts
1026             # Otherwise, use the field with icontains.
1027             return "%s__icontains" % field_name
1028 
1029         may_have_duplicates = False
1030         search_fields = self.get_search_fields(request)
1031         if search_fields and search_term:
1032             orm_lookups = [construct_search(str(search_field))
1033                            for search_field in search_fields]
1034             for bit in smart_split(search_term):
1035                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1036                     bit = unescape_string_literal(bit)
1037                 or_queries = models.Q(
1038                     *((orm_lookup, bit) for orm_lookup in orm_lookups),
1039                     _connector=models.Q.OR,
1040                 )
1041                 queryset = queryset.filter(or_queries)
1042             may_have_duplicates |= any(
1043                 lookup_spawns_duplicates(self.opts, search_spec)
1044                 for search_spec in orm_lookups
1045             )
1046         return queryset, may_have_duplicates
1047 
1048     def get_preserved_filters(self, request):
1049         """
1050         Return the preserved filters querystring.
1051         """
1052         match = request.resolver_match
1053         if self.preserve_filters and match:
1054             opts = self.model._meta
1055             current_url = '%s:%s' % (match.app_name, match.url_name)
1056             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1057             if current_url == changelist_url:
1058                 preserved_filters = request.GET.urlencode()
1059             else:
1060                 preserved_filters = request.GET.get('_changelist_filters')
1061 
1062             if preserved_filters:
1063                 return urlencode({'_changelist_filters': preserved_filters})
1064         return ''
1065 
1066     def construct_change_message(self, request, form, formsets, add=False):
1067         """
1068         Construct a JSON structure describing changes from a changed object.
1069         """
1070         return construct_change_message(form, formsets, add)
1071 
1072     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1073                      fail_silently=False):
1074         """
1075         Send a message to the user. The default implementation
1076         posts a message using the django.contrib.messages backend.
1077 
1078         Exposes almost the same API as messages.add_message(), but accepts the
1079         positional arguments in a different order to maintain backwards
1080         compatibility. For convenience, it accepts the `level` argument as
1081         a string rather than the usual level number.
1082         """
1083         if not isinstance(level, int):
1084             # attempt to get the level if passed a string
1085             try:
1086                 level = getattr(messages.constants, level.upper())
1087             except AttributeError:
1088                 levels = messages.constants.DEFAULT_TAGS.values()
1089                 levels_repr = ', '.join('`%s`' % level for level in levels)
1090                 raise ValueError(
1091                     'Bad message level string: `%s`. Possible values are: %s'
1092                     % (level, levels_repr)
1093                 )
1094 
1095         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1096 
1097     def save_form(self, request, form, change):
1098         """
1099         Given a ModelForm return an unsaved instance. ``change`` is True if
1100         the object is being changed, and False if it's being added.
1101         """
1102         return form.save(commit=False)
1103 
1104     def save_model(self, request, obj, form, change):
1105         """
1106         Given a model instance save it to the database.
1107         """
1108         obj.save()
1109 
1110     def delete_model(self, request, obj):
1111         """
1112         Given a model instance delete it from the database.
1113         """
1114         obj.delete()
1115 
1116     def delete_queryset(self, request, queryset):
1117         """Given a queryset, delete it from the database."""
1118         queryset.delete()
1119 
1120     def save_formset(self, request, form, formset, change):
1121         """
1122         Given an inline formset save it to the database.
1123         """
1124         formset.save()
1125 
1126     def save_related(self, request, form, formsets, change):
1127         """
1128         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1129         list of inline formsets and a boolean value based on whether the
1130         parent is being added or changed, save the related objects to the
1131         database. Note that at this point save_form() and save_model() have
1132         already been called.
1133         """
1134         form.save_m2m()
1135         for formset in formsets:
1136             self.save_formset(request, form, formset, change=change)
1137 
1138     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1139         opts = self.model._meta
1140         app_label = opts.app_label
1141         preserved_filters = self.get_preserved_filters(request)
1142         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1143         view_on_site_url = self.get_view_on_site_url(obj)
1144         has_editable_inline_admin_formsets = False
1145         for inline in context['inline_admin_formsets']:
1146             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1147                 has_editable_inline_admin_formsets = True
1148                 break
1149         context.update({
1150             'add': add,
1151             'change': change,
1152             'has_view_permission': self.has_view_permission(request, obj),
1153             'has_add_permission': self.has_add_permission(request),
1154             'has_change_permission': self.has_change_permission(request, obj),
1155             'has_delete_permission': self.has_delete_permission(request, obj),
1156             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1157             'has_file_field': context['adminform'].form.is_multipart() or any(
1158                 admin_formset.formset.is_multipart()
1159                 for admin_formset in context['inline_admin_formsets']
1160             ),
1161             'has_absolute_url': view_on_site_url is not None,
1162             'absolute_url': view_on_site_url,
1163             'form_url': form_url,
1164             'opts': opts,
1165             'content_type_id': get_content_type_for_model(self.model).pk,
1166             'save_as': self.save_as,
1167             'save_on_top': self.save_on_top,
1168             'to_field_var': TO_FIELD_VAR,
1169             'is_popup_var': IS_POPUP_VAR,
1170             'app_label': app_label,
1171         })
1172         if add and self.add_form_template is not None:
1173             form_template = self.add_form_template
1174         else:
1175             form_template = self.change_form_template
1176 
1177         request.current_app = self.admin_site.name
1178 
1179         return TemplateResponse(request, form_template or [
1180             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1181             "admin/%s/change_form.html" % app_label,
1182             "admin/change_form.html"
1183         ], context)
1184 
1185     def response_add(self, request, obj, post_url_continue=None):
1186         """
1187         Determine the HttpResponse for the add_view stage.
1188         """
1189         opts = obj._meta
1190         preserved_filters = self.get_preserved_filters(request)
1191         obj_url = reverse(
1192             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1193             args=(quote(obj.pk),),
1194             current_app=self.admin_site.name,
1195         )
1196         # Add a link to the object's change form if the user can edit the obj.
1197         if self.has_change_permission(request, obj):
1198             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1199         else:
1200             obj_repr = str(obj)
1201         msg_dict = {
1202             'name': opts.verbose_name,
1203             'obj': obj_repr,
1204         }
1205         # Here, we distinguish between different save types by checking for
1206         # the presence of keys in request.POST.
1207 
1208         if IS_POPUP_VAR in request.POST:
1209             to_field = request.POST.get(TO_FIELD_VAR)
1210             if to_field:
1211                 attr = str(to_field)
1212             else:
1213                 attr = obj._meta.pk.attname
1214             value = obj.serializable_value(attr)
1215             popup_response_data = json.dumps({
1216                 'value': str(value),
1217                 'obj': str(obj),
1218             })
1219             return TemplateResponse(request, self.popup_response_template or [
1220                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1221                 'admin/%s/popup_response.html' % opts.app_label,
1222                 'admin/popup_response.html',
1223             ], {
1224                 'popup_response_data': popup_response_data,
1225             })
1226 
1227         elif "_continue" in request.POST or (
1228                 # Redirecting after "Save as new".
1229                 "_saveasnew" in request.POST and self.save_as_continue and
1230                 self.has_change_permission(request, obj)
1231         ):
1232             msg = _('The {name} “{obj}” was added successfully.')
1233             if self.has_change_permission(request, obj):
1234                 msg += ' ' + _('You may edit it again below.')
1235             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1236             if post_url_continue is None:
1237                 post_url_continue = obj_url
1238             post_url_continue = add_preserved_filters(
1239                 {'preserved_filters': preserved_filters, 'opts': opts},
1240                 post_url_continue
1241             )
1242             return HttpResponseRedirect(post_url_continue)
1243 
1244         elif "_addanother" in request.POST:
1245             msg = format_html(
1246                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1247                 **msg_dict
1248             )
1249             self.message_user(request, msg, messages.SUCCESS)
1250             redirect_url = request.path
1251             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1252             return HttpResponseRedirect(redirect_url)
1253 
1254         else:
1255             msg = format_html(
1256                 _('The {name} “{obj}” was added successfully.'),
1257                 **msg_dict
1258             )
1259             self.message_user(request, msg, messages.SUCCESS)
1260             return self.response_post_save_add(request, obj)
1261 
1262     def response_change(self, request, obj):
1263         """
1264         Determine the HttpResponse for the change_view stage.
1265         """
1266 
1267         if IS_POPUP_VAR in request.POST:
1268             opts = obj._meta
1269             to_field = request.POST.get(TO_FIELD_VAR)
1270             attr = str(to_field) if to_field else opts.pk.attname
1271             value = request.resolver_match.kwargs['object_id']
1272             new_value = obj.serializable_value(attr)
1273             popup_response_data = json.dumps({
1274                 'action': 'change',
1275                 'value': str(value),
1276                 'obj': str(obj),
1277                 'new_value': str(new_value),
1278             })
1279             return TemplateResponse(request, self.popup_response_template or [
1280                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1281                 'admin/%s/popup_response.html' % opts.app_label,
1282                 'admin/popup_response.html',
1283             ], {
1284                 'popup_response_data': popup_response_data,
1285             })
1286 
1287         opts = self.model._meta
1288         preserved_filters = self.get_preserved_filters(request)
1289 
1290         msg_dict = {
1291             'name': opts.verbose_name,
1292             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1293         }
1294         if "_continue" in request.POST:
1295             msg = format_html(
1296                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1297                 **msg_dict
1298             )
1299             self.message_user(request, msg, messages.SUCCESS)
1300             redirect_url = request.path
1301             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1302             return HttpResponseRedirect(redirect_url)
1303 
1304         elif "_saveasnew" in request.POST:
1305             msg = format_html(
1306                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1307                 **msg_dict
1308             )
1309             self.message_user(request, msg, messages.SUCCESS)
1310             redirect_url = reverse('admin:%s_%s_change' %
1311                                    (opts.app_label, opts.model_name),
1312                                    args=(obj.pk,),
1313                                    current_app=self.admin_site.name)
1314             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1315             return HttpResponseRedirect(redirect_url)
1316 
1317         elif "_addanother" in request.POST:
1318             msg = format_html(
1319                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1320                 **msg_dict
1321             )
1322             self.message_user(request, msg, messages.SUCCESS)
1323             redirect_url = reverse('admin:%s_%s_add' %
1324                                    (opts.app_label, opts.model_name),
1325                                    current_app=self.admin_site.name)
1326             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1327             return HttpResponseRedirect(redirect_url)
1328 
1329         else:
1330             msg = format_html(
1331                 _('The {name} “{obj}” was changed successfully.'),
1332                 **msg_dict
1333             )
1334             self.message_user(request, msg, messages.SUCCESS)
1335             return self.response_post_save_change(request, obj)
1336 
1337     def _response_post_save(self, request, obj):
1338         opts = self.model._meta
1339         if self.has_view_or_change_permission(request):
1340             post_url = reverse('admin:%s_%s_changelist' %
1341                                (opts.app_label, opts.model_name),
1342                                current_app=self.admin_site.name)
1343             preserved_filters = self.get_preserved_filters(request)
1344             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1345         else:
1346             post_url = reverse('admin:index',
1347                                current_app=self.admin_site.name)
1348         return HttpResponseRedirect(post_url)
1349 
1350     def response_post_save_add(self, request, obj):
1351         """
1352         Figure out where to redirect after the 'Save' button has been pressed
1353         when adding a new object.
1354         """
1355         return self._response_post_save(request, obj)
1356 
1357     def response_post_save_change(self, request, obj):
1358         """
1359         Figure out where to redirect after the 'Save' button has been pressed
1360         when editing an existing object.
1361         """
1362         return self._response_post_save(request, obj)
1363 
1364     def response_action(self, request, queryset):
1365         """
1366         Handle an admin action. This is called if a request is POSTed to the
1367         changelist; it returns an HttpResponse if the action was handled, and
1368         None otherwise.
1369         """
1370 
1371         # There can be multiple action forms on the page (at the top
1372         # and bottom of the change list, for example). Get the action
1373         # whose button was pushed.
1374         try:
1375             action_index = int(request.POST.get('index', 0))
1376         except ValueError:
1377             action_index = 0
1378 
1379         # Construct the action form.
1380         data = request.POST.copy()
1381         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1382         data.pop("index", None)
1383 
1384         # Use the action whose button was pushed
1385         try:
1386             data.update({'action': data.getlist('action')[action_index]})
1387         except IndexError:
1388             # If we didn't get an action from the chosen form that's invalid
1389             # POST data, so by deleting action it'll fail the validation check
1390             # below. So no need to do anything here
1391             pass
1392 
1393         action_form = self.action_form(data, auto_id=None)
1394         action_form.fields['action'].choices = self.get_action_choices(request)
1395 
1396         # If the form's valid we can handle the action.
1397         if action_form.is_valid():
1398             action = action_form.cleaned_data['action']
1399             select_across = action_form.cleaned_data['select_across']
1400             func = self.get_actions(request)[action][0]
1401 
1402             # Get the list of selected PKs. If nothing's selected, we can't
1403             # perform an action on it, so bail. Except we want to perform
1404             # the action explicitly on all objects.
1405             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1406             if not selected and not select_across:
1407                 # Reminder that something needs to be selected or nothing will happen
1408                 msg = _("Items must be selected in order to perform "
1409                         "actions on them. No items have been changed.")
1410                 self.message_user(request, msg, messages.WARNING)
1411                 return None
1412 
1413             if not select_across:
1414                 # Perform the action only on the selected objects
1415                 queryset = queryset.filter(pk__in=selected)
1416 
1417             response = func(self, request, queryset)
1418 
1419             # Actions may return an HttpResponse-like object, which will be
1420             # used as the response from the POST. If not, we'll be a good
1421             # little HTTP citizen and redirect back to the changelist page.
1422             if isinstance(response, HttpResponseBase):
1423                 return response
1424             else:
1425                 return HttpResponseRedirect(request.get_full_path())
1426         else:
1427             msg = _("No action selected.")
1428             self.message_user(request, msg, messages.WARNING)
1429             return None
1430 
1431     def response_delete(self, request, obj_display, obj_id):
1432         """
1433         Determine the HttpResponse for the delete_view stage.
1434         """
1435         opts = self.model._meta
1436 
1437         if IS_POPUP_VAR in request.POST:
1438             popup_response_data = json.dumps({
1439                 'action': 'delete',
1440                 'value': str(obj_id),
1441             })
1442             return TemplateResponse(request, self.popup_response_template or [
1443                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1444                 'admin/%s/popup_response.html' % opts.app_label,
1445                 'admin/popup_response.html',
1446             ], {
1447                 'popup_response_data': popup_response_data,
1448             })
1449 
1450         self.message_user(
1451             request,
1452             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1453                 'name': opts.verbose_name,
1454                 'obj': obj_display,
1455             },
1456             messages.SUCCESS,
1457         )
1458 
1459         if self.has_change_permission(request, None):
1460             post_url = reverse(
1461                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1462                 current_app=self.admin_site.name,
1463             )
1464             preserved_filters = self.get_preserved_filters(request)
1465             post_url = add_preserved_filters(
1466                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1467             )
1468         else:
1469             post_url = reverse('admin:index', current_app=self.admin_site.name)
1470         return HttpResponseRedirect(post_url)
1471 
1472     def render_delete_form(self, request, context):
1473         opts = self.model._meta
1474         app_label = opts.app_label
1475 
1476         request.current_app = self.admin_site.name
1477         context.update(
1478             to_field_var=TO_FIELD_VAR,
1479             is_popup_var=IS_POPUP_VAR,
1480             media=self.media,
1481         )
1482 
1483         return TemplateResponse(
1484             request,
1485             self.delete_confirmation_template or [
1486                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1487                 "admin/{}/delete_confirmation.html".format(app_label),
1488                 "admin/delete_confirmation.html",
1489             ],
1490             context,
1491         )
1492 
1493     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1494         # Edit permissions on parent model are required for editable inlines.
1495         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1496         inline_admin_formsets = []
1497         for inline, formset in zip(inline_instances, formsets):
1498             fieldsets = list(inline.get_fieldsets(request, obj))
1499             readonly = list(inline.get_readonly_fields(request, obj))
1500             if can_edit_parent:
1501                 has_add_permission = inline.has_add_permission(request, obj)
1502                 has_change_permission = inline.has_change_permission(request, obj)
1503                 has_delete_permission = inline.has_delete_permission(request, obj)
1504             else:
1505                 # Disable all edit-permissions, and overide formset settings.
1506                 has_add_permission = has_change_permission = has_delete_permission = False
1507                 formset.extra = formset.max_num = 0
1508             has_view_permission = inline.has_view_permission(request, obj)
1509             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1510             inline_admin_formset = helpers.InlineAdminFormSet(
1511                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1512                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1513                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1514             )
1515             inline_admin_formsets.append(inline_admin_formset)
1516         return inline_admin_formsets
1517 
1518     def get_changeform_initial_data(self, request):
1519         """
1520         Get the initial form data from the request's GET params.
1521         """
1522         initial = dict(request.GET.items())
1523         for k in initial:
1524             try:
1525                 f = self.model._meta.get_field(k)
1526             except FieldDoesNotExist:
1527                 continue
1528             # We have to special-case M2Ms as a list of comma-separated PKs.
1529             if isinstance(f, models.ManyToManyField):
1530                 initial[k] = initial[k].split(",")
1531         return initial
1532 
1533     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1534         """
1535         Create a message informing the user that the object doesn't exist
1536         and return a redirect to the admin index page.
1537         """
1538         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1539             'name': opts.verbose_name,
1540             'key': unquote(object_id),
1541         }
1542         self.message_user(request, msg, messages.WARNING)
1543         url = reverse('admin:index', current_app=self.admin_site.name)
1544         return HttpResponseRedirect(url)
1545 
1546     @csrf_protect_m
1547     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1548         with transaction.atomic(using=router.db_for_write(self.model)):
1549             return self._changeform_view(request, object_id, form_url, extra_context)
1550 
1551     def _changeform_view(self, request, object_id, form_url, extra_context):
1552         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1553         if to_field and not self.to_field_allowed(request, to_field):
1554             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1555 
1556         model = self.model
1557         opts = model._meta
1558 
1559         if request.method == 'POST' and '_saveasnew' in request.POST:
1560             object_id = None
1561 
1562         add = object_id is None
1563 
1564         if add:
1565             if not self.has_add_permission(request):
1566                 raise PermissionDenied
1567             obj = None
1568 
1569         else:
1570             obj = self.get_object(request, unquote(object_id), to_field)
1571 
1572             if request.method == 'POST':
1573                 if not self.has_change_permission(request, obj):
1574                     raise PermissionDenied
1575             else:
1576                 if not self.has_view_or_change_permission(request, obj):
1577                     raise PermissionDenied
1578 
1579             if obj is None:
1580                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1581 
1582         fieldsets = self.get_fieldsets(request, obj)
1583         ModelForm = self.get_form(
1584             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1585         )
1586         if request.method == 'POST':
1587             form = ModelForm(request.POST, request.FILES, instance=obj)
1588             formsets, inline_instances = self._create_formsets(
1589                 request,
1590                 form.instance if add else obj,
1591                 change=not add,
1592             )
1593             form_validated = form.is_valid()
1594             if form_validated:
1595                 new_object = self.save_form(request, form, change=not add)
1596             else:
1597                 new_object = form.instance
1598             if all_valid(formsets) and form_validated:
1599                 self.save_model(request, new_object, form, not add)
1600                 self.save_related(request, form, formsets, not add)
1601                 change_message = self.construct_change_message(request, form, formsets, add)
1602                 if add:
1603                     self.log_addition(request, new_object, change_message)
1604                     return self.response_add(request, new_object)
1605                 else:
1606                     self.log_change(request, new_object, change_message)
1607                     return self.response_change(request, new_object)
1608             else:
1609                 form_validated = False
1610         else:
1611             if add:
1612                 initial = self.get_changeform_initial_data(request)
1613                 form = ModelForm(initial=initial)
1614                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1615             else:
1616                 form = ModelForm(instance=obj)
1617                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1618 
1619         if not add and not self.has_change_permission(request, obj):
1620             readonly_fields = flatten_fieldsets(fieldsets)
1621         else:
1622             readonly_fields = self.get_readonly_fields(request, obj)
1623         adminForm = helpers.AdminForm(
1624             form,
1625             list(fieldsets),
1626             # Clear prepopulated fields on a view-only form to avoid a crash.
1627             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1628             readonly_fields,
1629             model_admin=self)
1630         media = self.media + adminForm.media
1631 
1632         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1633         for inline_formset in inline_formsets:
1634             media = media + inline_formset.media
1635 
1636         if add:
1637             title = _('Add %s')
1638         elif self.has_change_permission(request, obj):
1639             title = _('Change %s')
1640         else:
1641             title = _('View %s')
1642         context = {
1643             **self.admin_site.each_context(request),
1644             'title': title % opts.verbose_name,
1645             'subtitle': str(obj) if obj else None,
1646             'adminform': adminForm,
1647             'object_id': object_id,
1648             'original': obj,
1649             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1650             'to_field': to_field,
1651             'media': media,
1652             'inline_admin_formsets': inline_formsets,
1653             'errors': helpers.AdminErrorList(form, formsets),
1654             'preserved_filters': self.get_preserved_filters(request),
1655         }
1656 
1657         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1658         # previously chosen to prevent the interface from getting confusing.
1659         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1660             context['show_save'] = False
1661             context['show_save_and_continue'] = False
1662             # Use the change template instead of the add template.
1663             add = False
1664 
1665         context.update(extra_context or {})
1666 
1667         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1668 
1669     def add_view(self, request, form_url='', extra_context=None):
1670         return self.changeform_view(request, None, form_url, extra_context)
1671 
1672     def change_view(self, request, object_id, form_url='', extra_context=None):
1673         return self.changeform_view(request, object_id, form_url, extra_context)
1674 
1675     def _get_edited_object_pks(self, request, prefix):
1676         """Return POST data values of list_editable primary keys."""
1677         pk_pattern = re.compile(
1678             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1679         )
1680         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1681 
1682     def _get_list_editable_queryset(self, request, prefix):
1683         """
1684         Based on POST data, return a queryset of the objects that were edited
1685         via list_editable.
1686         """
1687         object_pks = self._get_edited_object_pks(request, prefix)
1688         queryset = self.get_queryset(request)
1689         validate = queryset.model._meta.pk.to_python
1690         try:
1691             for pk in object_pks:
1692                 validate(pk)
1693         except ValidationError:
1694             # Disable the optimization if the POST data was tampered with.
1695             return queryset
1696         return queryset.filter(pk__in=object_pks)
1697 
1698     @csrf_protect_m
1699     def changelist_view(self, request, extra_context=None):
1700         """
1701         The 'change list' admin view for this model.
1702         """
1703         from django.contrib.admin.views.main import ERROR_FLAG
1704         opts = self.model._meta
1705         app_label = opts.app_label
1706         if not self.has_view_or_change_permission(request):
1707             raise PermissionDenied
1708 
1709         try:
1710             cl = self.get_changelist_instance(request)
1711         except IncorrectLookupParameters:
1712             # Wacky lookup parameters were given, so redirect to the main
1713             # changelist page, without parameters, and pass an 'invalid=1'
1714             # parameter via the query string. If wacky parameters were given
1715             # and the 'invalid=1' parameter was already in the query string,
1716             # something is screwed up with the database, so display an error
1717             # page.
1718             if ERROR_FLAG in request.GET:
1719                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1720                     'title': _('Database error'),
1721                 })
1722             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1723 
1724         # If the request was POSTed, this might be a bulk action or a bulk
1725         # edit. Try to look up an action or confirmation first, but if this
1726         # isn't an action the POST will fall through to the bulk edit check,
1727         # below.
1728         action_failed = False
1729         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1730 
1731         actions = self.get_actions(request)
1732         # Actions with no confirmation
1733         if (actions and request.method == 'POST' and
1734                 'index' in request.POST and '_save' not in request.POST):
1735             if selected:
1736                 response = self.response_action(request, queryset=cl.get_queryset(request))
1737                 if response:
1738                     return response
1739                 else:
1740                     action_failed = True
1741             else:
1742                 msg = _("Items must be selected in order to perform "
1743                         "actions on them. No items have been changed.")
1744                 self.message_user(request, msg, messages.WARNING)
1745                 action_failed = True
1746 
1747         # Actions with confirmation
1748         if (actions and request.method == 'POST' and
1749                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1750                 'index' not in request.POST and '_save' not in request.POST):
1751             if selected:
1752                 response = self.response_action(request, queryset=cl.get_queryset(request))
1753                 if response:
1754                     return response
1755                 else:
1756                     action_failed = True
1757 
1758         if action_failed:
1759             # Redirect back to the changelist page to avoid resubmitting the
1760             # form if the user refreshes the browser or uses the "No, take
1761             # me back" button on the action confirmation page.
1762             return HttpResponseRedirect(request.get_full_path())
1763 
1764         # If we're allowing changelist editing, we need to construct a formset
1765         # for the changelist given all the fields to be edited. Then we'll
1766         # use the formset to validate/process POSTed data.
1767         formset = cl.formset = None
1768 
1769         # Handle POSTed bulk-edit data.
1770         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1771             if not self.has_change_permission(request):
1772                 raise PermissionDenied
1773             FormSet = self.get_changelist_formset(request)
1774             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1775             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1776             if formset.is_valid():
1777                 changecount = 0
1778                 for form in formset.forms:
1779                     if form.has_changed():
1780                         obj = self.save_form(request, form, change=True)
1781                         self.save_model(request, obj, form, change=True)
1782                         self.save_related(request, form, formsets=[], change=True)
1783                         change_msg = self.construct_change_message(request, form, None)
1784                         self.log_change(request, obj, change_msg)
1785                         changecount += 1
1786 
1787                 if changecount:
1788                     msg = ngettext(
1789                         "%(count)s %(name)s was changed successfully.",
1790                         "%(count)s %(name)s were changed successfully.",
1791                         changecount
1792                     ) % {
1793                         'count': changecount,
1794                         'name': model_ngettext(opts, changecount),
1795                     }
1796                     self.message_user(request, msg, messages.SUCCESS)
1797 
1798                 return HttpResponseRedirect(request.get_full_path())
1799 
1800         # Handle GET -- construct a formset for display.
1801         elif cl.list_editable and self.has_change_permission(request):
1802             FormSet = self.get_changelist_formset(request)
1803             formset = cl.formset = FormSet(queryset=cl.result_list)
1804 
1805         # Build the list of media to be used by the formset.
1806         if formset:
1807             media = self.media + formset.media
1808         else:
1809             media = self.media
1810 
1811         # Build the action form and populate it with available actions.
1812         if actions:
1813             action_form = self.action_form(auto_id=None)
1814             action_form.fields['action'].choices = self.get_action_choices(request)
1815             media += action_form.media
1816         else:
1817             action_form = None
1818 
1819         selection_note_all = ngettext(
1820             '%(total_count)s selected',
1821             'All %(total_count)s selected',
1822             cl.result_count
1823         )
1824 
1825         context = {
1826             **self.admin_site.each_context(request),
1827             'module_name': str(opts.verbose_name_plural),
1828             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1829             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1830             'title': cl.title,
1831             'subtitle': None,
1832             'is_popup': cl.is_popup,
1833             'to_field': cl.to_field,
1834             'cl': cl,
1835             'media': media,
1836             'has_add_permission': self.has_add_permission(request),
1837             'opts': cl.opts,
1838             'action_form': action_form,
1839             'actions_on_top': self.actions_on_top,
1840             'actions_on_bottom': self.actions_on_bottom,
1841             'actions_selection_counter': self.actions_selection_counter,
1842             'preserved_filters': self.get_preserved_filters(request),
1843             **(extra_context or {}),
1844         }
1845 
1846         request.current_app = self.admin_site.name
1847 
1848         return TemplateResponse(request, self.change_list_template or [
1849             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1850             'admin/%s/change_list.html' % app_label,
1851             'admin/change_list.html'
1852         ], context)
1853 
1854     def get_deleted_objects(self, objs, request):
1855         """
1856         Hook for customizing the delete process for the delete view and the
1857         "delete selected" action.
1858         """
1859         return get_deleted_objects(objs, request, self.admin_site)
1860 
1861     @csrf_protect_m
1862     def delete_view(self, request, object_id, extra_context=None):
1863         with transaction.atomic(using=router.db_for_write(self.model)):
1864             return self._delete_view(request, object_id, extra_context)
1865 
1866     def _delete_view(self, request, object_id, extra_context):
1867         "The 'delete' admin view for this model."
1868         opts = self.model._meta
1869         app_label = opts.app_label
1870 
1871         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1872         if to_field and not self.to_field_allowed(request, to_field):
1873             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1874 
1875         obj = self.get_object(request, unquote(object_id), to_field)
1876 
1877         if not self.has_delete_permission(request, obj):
1878             raise PermissionDenied
1879 
1880         if obj is None:
1881             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1882 
1883         # Populate deleted_objects, a data structure of all related objects that
1884         # will also be deleted.
1885         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1886 
1887         if request.POST and not protected:  # The user has confirmed the deletion.
1888             if perms_needed:
1889                 raise PermissionDenied
1890             obj_display = str(obj)
1891             attr = str(to_field) if to_field else opts.pk.attname
1892             obj_id = obj.serializable_value(attr)
1893             self.log_deletion(request, obj, obj_display)
1894             self.delete_model(request, obj)
1895 
1896             return self.response_delete(request, obj_display, obj_id)
1897 
1898         object_name = str(opts.verbose_name)
1899 
1900         if perms_needed or protected:
1901             title = _("Cannot delete %(name)s") % {"name": object_name}
1902         else:
1903             title = _("Are you sure?")
1904 
1905         context = {
1906             **self.admin_site.each_context(request),
1907             'title': title,
1908             'subtitle': None,
1909             'object_name': object_name,
1910             'object': obj,
1911             'deleted_objects': deleted_objects,
1912             'model_count': dict(model_count).items(),
1913             'perms_lacking': perms_needed,
1914             'protected': protected,
1915             'opts': opts,
1916             'app_label': app_label,
1917             'preserved_filters': self.get_preserved_filters(request),
1918             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1919             'to_field': to_field,
1920             **(extra_context or {}),
1921         }
1922 
1923         return self.render_delete_form(request, context)
1924 
1925     def history_view(self, request, object_id, extra_context=None):
1926         "The 'history' admin view for this model."
1927         from django.contrib.admin.models import LogEntry
1928 
1929         # First check if the user can see this history.
1930         model = self.model
1931         obj = self.get_object(request, unquote(object_id))
1932         if obj is None:
1933             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1934 
1935         if not self.has_view_or_change_permission(request, obj):
1936             raise PermissionDenied
1937 
1938         # Then get the history for this object.
1939         opts = model._meta
1940         app_label = opts.app_label
1941         action_list = LogEntry.objects.filter(
1942             object_id=unquote(object_id),
1943             content_type=get_content_type_for_model(model)
1944         ).select_related().order_by('action_time')
1945 
1946         context = {
1947             **self.admin_site.each_context(request),
1948             'title': _('Change history: %s') % obj,
1949             'subtitle': None,
1950             'action_list': action_list,
1951             'module_name': str(capfirst(opts.verbose_name_plural)),
1952             'object': obj,
1953             'opts': opts,
1954             'preserved_filters': self.get_preserved_filters(request),
1955             **(extra_context or {}),
1956         }
1957 
1958         request.current_app = self.admin_site.name
1959 
1960         return TemplateResponse(request, self.object_history_template or [
1961             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1962             "admin/%s/object_history.html" % app_label,
1963             "admin/object_history.html"
1964         ], context)
1965 
1966     def get_formset_kwargs(self, request, obj, inline, prefix):
1967         formset_params = {
1968             'instance': obj,
1969             'prefix': prefix,
1970             'queryset': inline.get_queryset(request),
1971         }
1972         if request.method == 'POST':
1973             formset_params.update({
1974                 'data': request.POST.copy(),
1975                 'files': request.FILES,
1976                 'save_as_new': '_saveasnew' in request.POST
1977             })
1978         return formset_params
1979 
1980     def _create_formsets(self, request, obj, change):
1981         "Helper function to generate formsets for add/change_view."
1982         formsets = []
1983         inline_instances = []
1984         prefixes = {}
1985         get_formsets_args = [request]
1986         if change:
1987             get_formsets_args.append(obj)
1988         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1989             prefix = FormSet.get_default_prefix()
1990             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1991             if prefixes[prefix] != 1 or not prefix:
1992                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1993             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
1994             formset = FormSet(**formset_params)
1995 
1996             def user_deleted_form(request, obj, formset, index):
1997                 """Return whether or not the user deleted the form."""
1998                 return (
1999                     inline.has_delete_permission(request, obj) and
2000                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
2001                 )
2002 
2003             # Bypass validation of each view-only inline form (since the form's
2004             # data won't be in request.POST), unless the form was deleted.
2005             if not inline.has_change_permission(request, obj if change else None):
2006                 for index, form in enumerate(formset.initial_forms):
2007                     if user_deleted_form(request, obj, formset, index):
2008                         continue
2009                     form._errors = {}
2010                     form.cleaned_data = form.initial
2011             formsets.append(formset)
2012             inline_instances.append(inline)
2013         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 10:42:25.179 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>get_search_results</method>
<code>
994     def get_search_results(self, request, queryset, search_term):
995         """
996         Return a tuple containing a queryset to implement the search
997         and a boolean indicating if the results may contain duplicates.
998         """
999         # Apply keyword searches.
1000         def construct_search(field_name):
1001             if field_name.startswith('^'):
1002                 return "%s__istartswith" % field_name[1:]
1003             elif field_name.startswith('='):
1004                 return "%s__iexact" % field_name[1:]
1005             elif field_name.startswith('@'):
1006                 return "%s__search" % field_name[1:]
1007             # Use field_name if it includes a lookup.
1008             opts = queryset.model._meta
1009             lookup_fields = field_name.split(LOOKUP_SEP)
1010             # Go through the fields, following all relations.
1011             prev_field = None
1012             for path_part in lookup_fields:
1013                 if path_part == 'pk':
1014                     path_part = opts.pk.name
1015                 try:
1016                     field = opts.get_field(path_part)
1017                 except FieldDoesNotExist:
1018                     # Use valid query lookups.
1019                     if prev_field and prev_field.get_lookup(path_part):
1020                         return field_name
1021                 else:
1022                     prev_field = field
1023                     if hasattr(field, 'path_infos'):
1024                         # Update opts to follow the relation.
1025                         opts = field.path_infos[-1].to_opts
1026             # Otherwise, use the field with icontains.
1027             return "%s__icontains" % field_name
1028 
1029         may_have_duplicates = False
1030         search_fields = self.get_search_fields(request)
1031         if search_fields and search_term:
1032             orm_lookups = [construct_search(str(search_field))
1033                            for search_field in search_fields]
1034             for bit in smart_split(search_term):
1035                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1036                     bit = unescape_string_literal(bit)
1037                 or_queries = models.Q(
1038                     *((orm_lookup, bit) for orm_lookup in orm_lookups),
1039                     _connector=models.Q.OR,
1040                 )
1041                 queryset = queryset.filter(or_queries)
1042             may_have_duplicates |= any(
1043                 lookup_spawns_duplicates(self.opts, search_spec)
1044                 for search_spec in orm_lookups
1045             )
1046         return queryset, may_have_duplicates

</code><intended_behavior>The method `get_search_results` should be optimized to reduce the number of unnecessary JOIN operations generated when executing searches with multiple terms across related objects. Implementing a way to aggregate search conditions for related fields into a fewer number of more complex ORM queries that achieve the same search results but with less database overhead. Possibly introducing conditional logic that limits the depth or number of JOINs based on the `search_fields` configuration or the number of search terms. Ensuring that the solution preserves the flexibility of the Django admin search_fields, including the ability to specify different types of searches (e.g., starts with, exact match, contains) while enhancing performance. Retaining the functionality to return a tuple containing the modified queryset and a boolean indicating if the results may contain duplicates, without altering the expected outcomes of searches performed through the admin interface.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
550 class ModelAdmin(BaseModelAdmin):
551     """Encapsulate all admin options and functionality for a given model."""
552 
553     list_display = ('__str__',)
554     list_display_links = ()
555     list_filter = ()
556     list_select_related = False
557     list_per_page = 100
558     list_max_show_all = 200
559     list_editable = ()
560     search_fields = ()
561     search_help_text = None
562     date_hierarchy = None
563     save_as = False
564     save_as_continue = True
565     save_on_top = False
566     paginator = Paginator
567     preserve_filters = True
568     inlines = []
569 
570     # Custom templates (designed to be over-ridden in subclasses)
571     add_form_template = None
572     change_form_template = None
573     change_list_template = None
574     delete_confirmation_template = None
575     delete_selected_confirmation_template = None
576     object_history_template = None
577     popup_response_template = None
578 
579     # Actions
580     actions = []
581     action_form = helpers.ActionForm
582     actions_on_top = True
583     actions_on_bottom = False
584     actions_selection_counter = True
585     checks_class = ModelAdminChecks
586 
587     def __init__(self, model, admin_site):
588         self.model = model
589         self.opts = model._meta
590         self.admin_site = admin_site
591         super().__init__()
592 
593     def __str__(self):
594         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
595 
596     def __repr__(self):
597         return (
598             f'<{self.__class__.__qualname__}: model={self.model.__qualname__} '
599             f'site={self.admin_site!r}>'
600         )
601 
602     def get_inline_instances(self, request, obj=None):
603         inline_instances = []
604         for inline_class in self.get_inlines(request, obj):
605             inline = inline_class(self.model, self.admin_site)
606             if request:
607                 if not (inline.has_view_or_change_permission(request, obj) or
608                         inline.has_add_permission(request, obj) or
609                         inline.has_delete_permission(request, obj)):
610                     continue
611                 if not inline.has_add_permission(request, obj):
612                     inline.max_num = 0
613             inline_instances.append(inline)
614 
615         return inline_instances
616 
617     def get_urls(self):
618         from django.urls import path
619 
620         def wrap(view):
621             def wrapper(*args, **kwargs):
622                 return self.admin_site.admin_view(view)(*args, **kwargs)
623             wrapper.model_admin = self
624             return update_wrapper(wrapper, view)
625 
626         info = self.model._meta.app_label, self.model._meta.model_name
627 
628         return [
629             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
630             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
631             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
632             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
633             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
634             # For backwards compatibility (was the change url before 1.9)
635             path('<path:object_id>/', wrap(RedirectView.as_view(
636                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
637             ))),
638         ]
639 
640     @property
641     def urls(self):
642         return self.get_urls()
643 
644     @property
645     def media(self):
646         extra = '' if settings.DEBUG else '.min'
647         js = [
648             'vendor/jquery/jquery%s.js' % extra,
649             'jquery.init.js',
650             'core.js',
651             'admin/RelatedObjectLookups.js',
652             'actions.js',
653             'urlify.js',
654             'prepopulate.js',
655             'vendor/xregexp/xregexp%s.js' % extra,
656         ]
657         return forms.Media(js=['admin/js/%s' % url for url in js])
658 
659     def get_model_perms(self, request):
660         """
661         Return a dict of all perms for this model. This dict has the keys
662         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
663         for each of those actions.
664         """
665         return {
666             'add': self.has_add_permission(request),
667             'change': self.has_change_permission(request),
668             'delete': self.has_delete_permission(request),
669             'view': self.has_view_permission(request),
670         }
671 
672     def _get_form_for_get_fields(self, request, obj):
673         return self.get_form(request, obj, fields=None)
674 
675     def get_form(self, request, obj=None, change=False, **kwargs):
676         """
677         Return a Form class for use in the admin add view. This is used by
678         add_view and change_view.
679         """
680         if 'fields' in kwargs:
681             fields = kwargs.pop('fields')
682         else:
683             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
684         excluded = self.get_exclude(request, obj)
685         exclude = [] if excluded is None else list(excluded)
686         readonly_fields = self.get_readonly_fields(request, obj)
687         exclude.extend(readonly_fields)
688         # Exclude all fields if it's a change form and the user doesn't have
689         # the change permission.
690         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
691             exclude.extend(fields)
692         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
693             # Take the custom ModelForm's Meta.exclude into account only if the
694             # ModelAdmin doesn't define its own.
695             exclude.extend(self.form._meta.exclude)
696         # if exclude is an empty list we pass None to be consistent with the
697         # default on modelform_factory
698         exclude = exclude or None
699 
700         # Remove declared form fields which are in readonly_fields.
701         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
702         form = type(self.form.__name__, (self.form,), new_attrs)
703 
704         defaults = {
705             'form': form,
706             'fields': fields,
707             'exclude': exclude,
708             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
709             **kwargs,
710         }
711 
712         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
713             defaults['fields'] = forms.ALL_FIELDS
714 
715         try:
716             return modelform_factory(self.model, **defaults)
717         except FieldError as e:
718             raise FieldError(
719                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
720                 % (e, self.__class__.__name__)
721             )
722 
723     def get_changelist(self, request, **kwargs):
724         """
725         Return the ChangeList class for use on the changelist page.
726         """
727         from django.contrib.admin.views.main import ChangeList
728         return ChangeList
729 
730     def get_changelist_instance(self, request):
731         """
732         Return a `ChangeList` instance based on `request`. May raise
733         `IncorrectLookupParameters`.
734         """
735         list_display = self.get_list_display(request)
736         list_display_links = self.get_list_display_links(request, list_display)
737         # Add the action checkboxes if any actions are available.
738         if self.get_actions(request):
739             list_display = ['action_checkbox', *list_display]
740         sortable_by = self.get_sortable_by(request)
741         ChangeList = self.get_changelist(request)
742         return ChangeList(
743             request,
744             self.model,
745             list_display,
746             list_display_links,
747             self.get_list_filter(request),
748             self.date_hierarchy,
749             self.get_search_fields(request),
750             self.get_list_select_related(request),
751             self.list_per_page,
752             self.list_max_show_all,
753             self.list_editable,
754             self,
755             sortable_by,
756             self.search_help_text,
757         )
758 
759     def get_object(self, request, object_id, from_field=None):
760         """
761         Return an instance matching the field and value provided, the primary
762         key is used if no field is provided. Return ``None`` if no match is
763         found or the object_id fails validation.
764         """
765         queryset = self.get_queryset(request)
766         model = queryset.model
767         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
768         try:
769             object_id = field.to_python(object_id)
770             return queryset.get(**{field.name: object_id})
771         except (model.DoesNotExist, ValidationError, ValueError):
772             return None
773 
774     def get_changelist_form(self, request, **kwargs):
775         """
776         Return a Form class for use in the Formset on the changelist page.
777         """
778         defaults = {
779             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
780             **kwargs,
781         }
782         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
783             defaults['fields'] = forms.ALL_FIELDS
784 
785         return modelform_factory(self.model, **defaults)
786 
787     def get_changelist_formset(self, request, **kwargs):
788         """
789         Return a FormSet class for use on the changelist page if list_editable
790         is used.
791         """
792         defaults = {
793             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
794             **kwargs,
795         }
796         return modelformset_factory(
797             self.model, self.get_changelist_form(request), extra=0,
798             fields=self.list_editable, **defaults
799         )
800 
801     def get_formsets_with_inlines(self, request, obj=None):
802         """
803         Yield formsets and the corresponding inlines.
804         """
805         for inline in self.get_inline_instances(request, obj):
806             yield inline.get_formset(request, obj), inline
807 
808     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
809         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
810 
811     def log_addition(self, request, obj, message):
812         """
813         Log that an object has been successfully added.
814 
815         The default implementation creates an admin LogEntry object.
816         """
817         from django.contrib.admin.models import ADDITION, LogEntry
818         return LogEntry.objects.log_action(
819             user_id=request.user.pk,
820             content_type_id=get_content_type_for_model(obj).pk,
821             object_id=obj.pk,
822             object_repr=str(obj),
823             action_flag=ADDITION,
824             change_message=message,
825         )
826 
827     def log_change(self, request, obj, message):
828         """
829         Log that an object has been successfully changed.
830 
831         The default implementation creates an admin LogEntry object.
832         """
833         from django.contrib.admin.models import CHANGE, LogEntry
834         return LogEntry.objects.log_action(
835             user_id=request.user.pk,
836             content_type_id=get_content_type_for_model(obj).pk,
837             object_id=obj.pk,
838             object_repr=str(obj),
839             action_flag=CHANGE,
840             change_message=message,
841         )
842 
843     def log_deletion(self, request, obj, object_repr):
844         """
845         Log that an object will be deleted. Note that this method must be
846         called before the deletion.
847 
848         The default implementation creates an admin LogEntry object.
849         """
850         from django.contrib.admin.models import DELETION, LogEntry
851         return LogEntry.objects.log_action(
852             user_id=request.user.pk,
853             content_type_id=get_content_type_for_model(obj).pk,
854             object_id=obj.pk,
855             object_repr=object_repr,
856             action_flag=DELETION,
857         )
858 
859     @display(description=mark_safe('<input type="checkbox" id="action-toggle">'))
860     def action_checkbox(self, obj):
861         """
862         A list_display column containing a checkbox widget.
863         """
864         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
865 
866     @staticmethod
867     def _get_action_description(func, name):
868         return getattr(func, 'short_description', capfirst(name.replace('_', ' ')))
869 
870     def _get_base_actions(self):
871         """Return the list of actions, prior to any request-based filtering."""
872         actions = []
873         base_actions = (self.get_action(action) for action in self.actions or [])
874         # get_action might have returned None, so filter any of those out.
875         base_actions = [action for action in base_actions if action]
876         base_action_names = {name for _, name, _ in base_actions}
877 
878         # Gather actions from the admin site first
879         for (name, func) in self.admin_site.actions:
880             if name in base_action_names:
881                 continue
882             description = self._get_action_description(func, name)
883             actions.append((func, name, description))
884         # Add actions from this ModelAdmin.
885         actions.extend(base_actions)
886         return actions
887 
888     def _filter_actions_by_permissions(self, request, actions):
889         """Filter out any actions that the user doesn't have access to."""
890         filtered_actions = []
891         for action in actions:
892             callable = action[0]
893             if not hasattr(callable, 'allowed_permissions'):
894                 filtered_actions.append(action)
895                 continue
896             permission_checks = (
897                 getattr(self, 'has_%s_permission' % permission)
898                 for permission in callable.allowed_permissions
899             )
900             if any(has_permission(request) for has_permission in permission_checks):
901                 filtered_actions.append(action)
902         return filtered_actions
903 
904     def get_actions(self, request):
905         """
906         Return a dictionary mapping the names of all actions for this
907         ModelAdmin to a tuple of (callable, name, description) for each action.
908         """
909         # If self.actions is set to None that means actions are disabled on
910         # this page.
911         if self.actions is None or IS_POPUP_VAR in request.GET:
912             return {}
913         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
914         return {name: (func, name, desc) for func, name, desc in actions}
915 
916     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
917         """
918         Return a list of choices for use in a form object.  Each choice is a
919         tuple (name, description).
920         """
921         choices = [] + default_choices
922         for func, name, description in self.get_actions(request).values():
923             choice = (name, description % model_format_dict(self.opts))
924             choices.append(choice)
925         return choices
926 
927     def get_action(self, action):
928         """
929         Return a given action from a parameter, which can either be a callable,
930         or the name of a method on the ModelAdmin.  Return is a tuple of
931         (callable, name, description).
932         """
933         # If the action is a callable, just use it.
934         if callable(action):
935             func = action
936             action = action.__name__
937 
938         # Next, look for a method. Grab it off self.__class__ to get an unbound
939         # method instead of a bound one; this ensures that the calling
940         # conventions are the same for functions and methods.
941         elif hasattr(self.__class__, action):
942             func = getattr(self.__class__, action)
943 
944         # Finally, look for a named method on the admin site
945         else:
946             try:
947                 func = self.admin_site.get_action(action)
948             except KeyError:
949                 return None
950 
951         description = self._get_action_description(func, action)
952         return func, action, description
953 
954     def get_list_display(self, request):
955         """
956         Return a sequence containing the fields to be displayed on the
957         changelist.
958         """
959         return self.list_display
960 
961     def get_list_display_links(self, request, list_display):
962         """
963         Return a sequence containing the fields to be displayed as links
964         on the changelist. The list_display parameter is the list of fields
965         returned by get_list_display().
966         """
967         if self.list_display_links or self.list_display_links is None or not list_display:
968             return self.list_display_links
969         else:
970             # Use only the first item in list_display as link
971             return list(list_display)[:1]
972 
973     def get_list_filter(self, request):
974         """
975         Return a sequence containing the fields to be displayed as filters in
976         the right sidebar of the changelist page.
977         """
978         return self.list_filter
979 
980     def get_list_select_related(self, request):
981         """
982         Return a list of fields to add to the select_related() part of the
983         changelist items query.
984         """
985         return self.list_select_related
986 
987     def get_search_fields(self, request):
988         """
989         Return a sequence containing the fields to be searched whenever
990         somebody submits a search query.
991         """
992         return self.search_fields
993 
994     def get_search_results(self, request, queryset, search_term):
995         """
996         Return a tuple containing a queryset to implement the search
997         and a boolean indicating if the results may contain duplicates.
998         """
999         # Apply keyword searches.
1000         def construct_search(field_name):
1001             if field_name.startswith('^'):
1002                 return "%s__istartswith" % field_name[1:]
1003             elif field_name.startswith('='):
1004                 return "%s__iexact" % field_name[1:]
1005             elif field_name.startswith('@'):
1006                 return "%s__search" % field_name[1:]
1007             # Use field_name if it includes a lookup.
1008             opts = queryset.model._meta
1009             lookup_fields = field_name.split(LOOKUP_SEP)
1010             # Go through the fields, following all relations.
1011             prev_field = None
1012             for path_part in lookup_fields:
1013                 if path_part == 'pk':
1014                     path_part = opts.pk.name
1015                 try:
1016                     field = opts.get_field(path_part)
1017                 except FieldDoesNotExist:
1018                     # Use valid query lookups.
1019                     if prev_field and prev_field.get_lookup(path_part):
1020                         return field_name
1021                 else:
1022                     prev_field = field
1023                     if hasattr(field, 'path_infos'):
1024                         # Update opts to follow the relation.
1025                         opts = field.path_infos[-1].to_opts
1026             # Otherwise, use the field with icontains.
1027             return "%s__icontains" % field_name
1028 
1029         may_have_duplicates = False
1030         search_fields = self.get_search_fields(request)
1031         if search_fields and search_term:
1032             orm_lookups = [construct_search(str(search_field))
1033                            for search_field in search_fields]
1034             for bit in smart_split(search_term):
1035                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1036                     bit = unescape_string_literal(bit)
1037                 or_queries = models.Q(
1038                     *((orm_lookup, bit) for orm_lookup in orm_lookups),
1039                     _connector=models.Q.OR,
1040                 )
1041                 queryset = queryset.filter(or_queries)
1042             may_have_duplicates |= any(
1043                 lookup_spawns_duplicates(self.opts, search_spec)
1044                 for search_spec in orm_lookups
1045             )
1046         return queryset, may_have_duplicates
1047 
1048     def get_preserved_filters(self, request):
1049         """
1050         Return the preserved filters querystring.
1051         """
1052         match = request.resolver_match
1053         if self.preserve_filters and match:
1054             opts = self.model._meta
1055             current_url = '%s:%s' % (match.app_name, match.url_name)
1056             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1057             if current_url == changelist_url:
1058                 preserved_filters = request.GET.urlencode()
1059             else:
1060                 preserved_filters = request.GET.get('_changelist_filters')
1061 
1062             if preserved_filters:
1063                 return urlencode({'_changelist_filters': preserved_filters})
1064         return ''
1065 
1066     def construct_change_message(self, request, form, formsets, add=False):
1067         """
1068         Construct a JSON structure describing changes from a changed object.
1069         """
1070         return construct_change_message(form, formsets, add)
1071 
1072     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1073                      fail_silently=False):
1074         """
1075         Send a message to the user. The default implementation
1076         posts a message using the django.contrib.messages backend.
1077 
1078         Exposes almost the same API as messages.add_message(), but accepts the
1079         positional arguments in a different order to maintain backwards
1080         compatibility. For convenience, it accepts the `level` argument as
1081         a string rather than the usual level number.
1082         """
1083         if not isinstance(level, int):
1084             # attempt to get the level if passed a string
1085             try:
1086                 level = getattr(messages.constants, level.upper())
1087             except AttributeError:
1088                 levels = messages.constants.DEFAULT_TAGS.values()
1089                 levels_repr = ', '.join('`%s`' % level for level in levels)
1090                 raise ValueError(
1091                     'Bad message level string: `%s`. Possible values are: %s'
1092                     % (level, levels_repr)
1093                 )
1094 
1095         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1096 
1097     def save_form(self, request, form, change):
1098         """
1099         Given a ModelForm return an unsaved instance. ``change`` is True if
1100         the object is being changed, and False if it's being added.
1101         """
1102         return form.save(commit=False)
1103 
1104     def save_model(self, request, obj, form, change):
1105         """
1106         Given a model instance save it to the database.
1107         """
1108         obj.save()
1109 
1110     def delete_model(self, request, obj):
1111         """
1112         Given a model instance delete it from the database.
1113         """
1114         obj.delete()
1115 
1116     def delete_queryset(self, request, queryset):
1117         """Given a queryset, delete it from the database."""
1118         queryset.delete()
1119 
1120     def save_formset(self, request, form, formset, change):
1121         """
1122         Given an inline formset save it to the database.
1123         """
1124         formset.save()
1125 
1126     def save_related(self, request, form, formsets, change):
1127         """
1128         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1129         list of inline formsets and a boolean value based on whether the
1130         parent is being added or changed, save the related objects to the
1131         database. Note that at this point save_form() and save_model() have
1132         already been called.
1133         """
1134         form.save_m2m()
1135         for formset in formsets:
1136             self.save_formset(request, form, formset, change=change)
1137 
1138     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1139         opts = self.model._meta
1140         app_label = opts.app_label
1141         preserved_filters = self.get_preserved_filters(request)
1142         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1143         view_on_site_url = self.get_view_on_site_url(obj)
1144         has_editable_inline_admin_formsets = False
1145         for inline in context['inline_admin_formsets']:
1146             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1147                 has_editable_inline_admin_formsets = True
1148                 break
1149         context.update({
1150             'add': add,
1151             'change': change,
1152             'has_view_permission': self.has_view_permission(request, obj),
1153             'has_add_permission': self.has_add_permission(request),
1154             'has_change_permission': self.has_change_permission(request, obj),
1155             'has_delete_permission': self.has_delete_permission(request, obj),
1156             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1157             'has_file_field': context['adminform'].form.is_multipart() or any(
1158                 admin_formset.formset.is_multipart()
1159                 for admin_formset in context['inline_admin_formsets']
1160             ),
1161             'has_absolute_url': view_on_site_url is not None,
1162             'absolute_url': view_on_site_url,
1163             'form_url': form_url,
1164             'opts': opts,
1165             'content_type_id': get_content_type_for_model(self.model).pk,
1166             'save_as': self.save_as,
1167             'save_on_top': self.save_on_top,
1168             'to_field_var': TO_FIELD_VAR,
1169             'is_popup_var': IS_POPUP_VAR,
1170             'app_label': app_label,
1171         })
1172         if add and self.add_form_template is not None:
1173             form_template = self.add_form_template
1174         else:
1175             form_template = self.change_form_template
1176 
1177         request.current_app = self.admin_site.name
1178 
1179         return TemplateResponse(request, form_template or [
1180             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1181             "admin/%s/change_form.html" % app_label,
1182             "admin/change_form.html"
1183         ], context)
1184 
1185     def response_add(self, request, obj, post_url_continue=None):
1186         """
1187         Determine the HttpResponse for the add_view stage.
1188         """
1189         opts = obj._meta
1190         preserved_filters = self.get_preserved_filters(request)
1191         obj_url = reverse(
1192             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1193             args=(quote(obj.pk),),
1194             current_app=self.admin_site.name,
1195         )
1196         # Add a link to the object's change form if the user can edit the obj.
1197         if self.has_change_permission(request, obj):
1198             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1199         else:
1200             obj_repr = str(obj)
1201         msg_dict = {
1202             'name': opts.verbose_name,
1203             'obj': obj_repr,
1204         }
1205         # Here, we distinguish between different save types by checking for
1206         # the presence of keys in request.POST.
1207 
1208         if IS_POPUP_VAR in request.POST:
1209             to_field = request.POST.get(TO_FIELD_VAR)
1210             if to_field:
1211                 attr = str(to_field)
1212             else:
1213                 attr = obj._meta.pk.attname
1214             value = obj.serializable_value(attr)
1215             popup_response_data = json.dumps({
1216                 'value': str(value),
1217                 'obj': str(obj),
1218             })
1219             return TemplateResponse(request, self.popup_response_template or [
1220                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1221                 'admin/%s/popup_response.html' % opts.app_label,
1222                 'admin/popup_response.html',
1223             ], {
1224                 'popup_response_data': popup_response_data,
1225             })
1226 
1227         elif "_continue" in request.POST or (
1228                 # Redirecting after "Save as new".
1229                 "_saveasnew" in request.POST and self.save_as_continue and
1230                 self.has_change_permission(request, obj)
1231         ):
1232             msg = _('The {name} “{obj}” was added successfully.')
1233             if self.has_change_permission(request, obj):
1234                 msg += ' ' + _('You may edit it again below.')
1235             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1236             if post_url_continue is None:
1237                 post_url_continue = obj_url
1238             post_url_continue = add_preserved_filters(
1239                 {'preserved_filters': preserved_filters, 'opts': opts},
1240                 post_url_continue
1241             )
1242             return HttpResponseRedirect(post_url_continue)
1243 
1244         elif "_addanother" in request.POST:
1245             msg = format_html(
1246                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1247                 **msg_dict
1248             )
1249             self.message_user(request, msg, messages.SUCCESS)
1250             redirect_url = request.path
1251             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1252             return HttpResponseRedirect(redirect_url)
1253 
1254         else:
1255             msg = format_html(
1256                 _('The {name} “{obj}” was added successfully.'),
1257                 **msg_dict
1258             )
1259             self.message_user(request, msg, messages.SUCCESS)
1260             return self.response_post_save_add(request, obj)
1261 
1262     def response_change(self, request, obj):
1263         """
1264         Determine the HttpResponse for the change_view stage.
1265         """
1266 
1267         if IS_POPUP_VAR in request.POST:
1268             opts = obj._meta
1269             to_field = request.POST.get(TO_FIELD_VAR)
1270             attr = str(to_field) if to_field else opts.pk.attname
1271             value = request.resolver_match.kwargs['object_id']
1272             new_value = obj.serializable_value(attr)
1273             popup_response_data = json.dumps({
1274                 'action': 'change',
1275                 'value': str(value),
1276                 'obj': str(obj),
1277                 'new_value': str(new_value),
1278             })
1279             return TemplateResponse(request, self.popup_response_template or [
1280                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1281                 'admin/%s/popup_response.html' % opts.app_label,
1282                 'admin/popup_response.html',
1283             ], {
1284                 'popup_response_data': popup_response_data,
1285             })
1286 
1287         opts = self.model._meta
1288         preserved_filters = self.get_preserved_filters(request)
1289 
1290         msg_dict = {
1291             'name': opts.verbose_name,
1292             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1293         }
1294         if "_continue" in request.POST:
1295             msg = format_html(
1296                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1297                 **msg_dict
1298             )
1299             self.message_user(request, msg, messages.SUCCESS)
1300             redirect_url = request.path
1301             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1302             return HttpResponseRedirect(redirect_url)
1303 
1304         elif "_saveasnew" in request.POST:
1305             msg = format_html(
1306                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1307                 **msg_dict
1308             )
1309             self.message_user(request, msg, messages.SUCCESS)
1310             redirect_url = reverse('admin:%s_%s_change' %
1311                                    (opts.app_label, opts.model_name),
1312                                    args=(obj.pk,),
1313                                    current_app=self.admin_site.name)
1314             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1315             return HttpResponseRedirect(redirect_url)
1316 
1317         elif "_addanother" in request.POST:
1318             msg = format_html(
1319                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1320                 **msg_dict
1321             )
1322             self.message_user(request, msg, messages.SUCCESS)
1323             redirect_url = reverse('admin:%s_%s_add' %
1324                                    (opts.app_label, opts.model_name),
1325                                    current_app=self.admin_site.name)
1326             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1327             return HttpResponseRedirect(redirect_url)
1328 
1329         else:
1330             msg = format_html(
1331                 _('The {name} “{obj}” was changed successfully.'),
1332                 **msg_dict
1333             )
1334             self.message_user(request, msg, messages.SUCCESS)
1335             return self.response_post_save_change(request, obj)
1336 
1337     def _response_post_save(self, request, obj):
1338         opts = self.model._meta
1339         if self.has_view_or_change_permission(request):
1340             post_url = reverse('admin:%s_%s_changelist' %
1341                                (opts.app_label, opts.model_name),
1342                                current_app=self.admin_site.name)
1343             preserved_filters = self.get_preserved_filters(request)
1344             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1345         else:
1346             post_url = reverse('admin:index',
1347                                current_app=self.admin_site.name)
1348         return HttpResponseRedirect(post_url)
1349 
1350     def response_post_save_add(self, request, obj):
1351         """
1352         Figure out where to redirect after the 'Save' button has been pressed
1353         when adding a new object.
1354         """
1355         return self._response_post_save(request, obj)
1356 
1357     def response_post_save_change(self, request, obj):
1358         """
1359         Figure out where to redirect after the 'Save' button has been pressed
1360         when editing an existing object.
1361         """
1362         return self._response_post_save(request, obj)
1363 
1364     def response_action(self, request, queryset):
1365         """
1366         Handle an admin action. This is called if a request is POSTed to the
1367         changelist; it returns an HttpResponse if the action was handled, and
1368         None otherwise.
1369         """
1370 
1371         # There can be multiple action forms on the page (at the top
1372         # and bottom of the change list, for example). Get the action
1373         # whose button was pushed.
1374         try:
1375             action_index = int(request.POST.get('index', 0))
1376         except ValueError:
1377             action_index = 0
1378 
1379         # Construct the action form.
1380         data = request.POST.copy()
1381         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1382         data.pop("index", None)
1383 
1384         # Use the action whose button was pushed
1385         try:
1386             data.update({'action': data.getlist('action')[action_index]})
1387         except IndexError:
1388             # If we didn't get an action from the chosen form that's invalid
1389             # POST data, so by deleting action it'll fail the validation check
1390             # below. So no need to do anything here
1391             pass
1392 
1393         action_form = self.action_form(data, auto_id=None)
1394         action_form.fields['action'].choices = self.get_action_choices(request)
1395 
1396         # If the form's valid we can handle the action.
1397         if action_form.is_valid():
1398             action = action_form.cleaned_data['action']
1399             select_across = action_form.cleaned_data['select_across']
1400             func = self.get_actions(request)[action][0]
1401 
1402             # Get the list of selected PKs. If nothing's selected, we can't
1403             # perform an action on it, so bail. Except we want to perform
1404             # the action explicitly on all objects.
1405             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1406             if not selected and not select_across:
1407                 # Reminder that something needs to be selected or nothing will happen
1408                 msg = _("Items must be selected in order to perform "
1409                         "actions on them. No items have been changed.")
1410                 self.message_user(request, msg, messages.WARNING)
1411                 return None
1412 
1413             if not select_across:
1414                 # Perform the action only on the selected objects
1415                 queryset = queryset.filter(pk__in=selected)
1416 
1417             response = func(self, request, queryset)
1418 
1419             # Actions may return an HttpResponse-like object, which will be
1420             # used as the response from the POST. If not, we'll be a good
1421             # little HTTP citizen and redirect back to the changelist page.
1422             if isinstance(response, HttpResponseBase):
1423                 return response
1424             else:
1425                 return HttpResponseRedirect(request.get_full_path())
1426         else:
1427             msg = _("No action selected.")
1428             self.message_user(request, msg, messages.WARNING)
1429             return None
1430 
1431     def response_delete(self, request, obj_display, obj_id):
1432         """
1433         Determine the HttpResponse for the delete_view stage.
1434         """
1435         opts = self.model._meta
1436 
1437         if IS_POPUP_VAR in request.POST:
1438             popup_response_data = json.dumps({
1439                 'action': 'delete',
1440                 'value': str(obj_id),
1441             })
1442             return TemplateResponse(request, self.popup_response_template or [
1443                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1444                 'admin/%s/popup_response.html' % opts.app_label,
1445                 'admin/popup_response.html',
1446             ], {
1447                 'popup_response_data': popup_response_data,
1448             })
1449 
1450         self.message_user(
1451             request,
1452             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1453                 'name': opts.verbose_name,
1454                 'obj': obj_display,
1455             },
1456             messages.SUCCESS,
1457         )
1458 
1459         if self.has_change_permission(request, None):
1460             post_url = reverse(
1461                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1462                 current_app=self.admin_site.name,
1463             )
1464             preserved_filters = self.get_preserved_filters(request)
1465             post_url = add_preserved_filters(
1466                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1467             )
1468         else:
1469             post_url = reverse('admin:index', current_app=self.admin_site.name)
1470         return HttpResponseRedirect(post_url)
1471 
1472     def render_delete_form(self, request, context):
1473         opts = self.model._meta
1474         app_label = opts.app_label
1475 
1476         request.current_app = self.admin_site.name
1477         context.update(
1478             to_field_var=TO_FIELD_VAR,
1479             is_popup_var=IS_POPUP_VAR,
1480             media=self.media,
1481         )
1482 
1483         return TemplateResponse(
1484             request,
1485             self.delete_confirmation_template or [
1486                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1487                 "admin/{}/delete_confirmation.html".format(app_label),
1488                 "admin/delete_confirmation.html",
1489             ],
1490             context,
1491         )
1492 
1493     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1494         # Edit permissions on parent model are required for editable inlines.
1495         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1496         inline_admin_formsets = []
1497         for inline, formset in zip(inline_instances, formsets):
1498             fieldsets = list(inline.get_fieldsets(request, obj))
1499             readonly = list(inline.get_readonly_fields(request, obj))
1500             if can_edit_parent:
1501                 has_add_permission = inline.has_add_permission(request, obj)
1502                 has_change_permission = inline.has_change_permission(request, obj)
1503                 has_delete_permission = inline.has_delete_permission(request, obj)
1504             else:
1505                 # Disable all edit-permissions, and overide formset settings.
1506                 has_add_permission = has_change_permission = has_delete_permission = False
1507                 formset.extra = formset.max_num = 0
1508             has_view_permission = inline.has_view_permission(request, obj)
1509             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1510             inline_admin_formset = helpers.InlineAdminFormSet(
1511                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1512                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1513                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1514             )
1515             inline_admin_formsets.append(inline_admin_formset)
1516         return inline_admin_formsets
1517 
1518     def get_changeform_initial_data(self, request):
1519         """
1520         Get the initial form data from the request's GET params.
1521         """
1522         initial = dict(request.GET.items())
1523         for k in initial:
1524             try:
1525                 f = self.model._meta.get_field(k)
1526             except FieldDoesNotExist:
1527                 continue
1528             # We have to special-case M2Ms as a list of comma-separated PKs.
1529             if isinstance(f, models.ManyToManyField):
1530                 initial[k] = initial[k].split(",")
1531         return initial
1532 
1533     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1534         """
1535         Create a message informing the user that the object doesn't exist
1536         and return a redirect to the admin index page.
1537         """
1538         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1539             'name': opts.verbose_name,
1540             'key': unquote(object_id),
1541         }
1542         self.message_user(request, msg, messages.WARNING)
1543         url = reverse('admin:index', current_app=self.admin_site.name)
1544         return HttpResponseRedirect(url)
1545 
1546     @csrf_protect_m
1547     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1548         with transaction.atomic(using=router.db_for_write(self.model)):
1549             return self._changeform_view(request, object_id, form_url, extra_context)
1550 
1551     def _changeform_view(self, request, object_id, form_url, extra_context):
1552         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1553         if to_field and not self.to_field_allowed(request, to_field):
1554             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1555 
1556         model = self.model
1557         opts = model._meta
1558 
1559         if request.method == 'POST' and '_saveasnew' in request.POST:
1560             object_id = None
1561 
1562         add = object_id is None
1563 
1564         if add:
1565             if not self.has_add_permission(request):
1566                 raise PermissionDenied
1567             obj = None
1568 
1569         else:
1570             obj = self.get_object(request, unquote(object_id), to_field)
1571 
1572             if request.method == 'POST':
1573                 if not self.has_change_permission(request, obj):
1574                     raise PermissionDenied
1575             else:
1576                 if not self.has_view_or_change_permission(request, obj):
1577                     raise PermissionDenied
1578 
1579             if obj is None:
1580                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1581 
1582         fieldsets = self.get_fieldsets(request, obj)
1583         ModelForm = self.get_form(
1584             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1585         )
1586         if request.method == 'POST':
1587             form = ModelForm(request.POST, request.FILES, instance=obj)
1588             formsets, inline_instances = self._create_formsets(
1589                 request,
1590                 form.instance if add else obj,
1591                 change=not add,
1592             )
1593             form_validated = form.is_valid()
1594             if form_validated:
1595                 new_object = self.save_form(request, form, change=not add)
1596             else:
1597                 new_object = form.instance
1598             if all_valid(formsets) and form_validated:
1599                 self.save_model(request, new_object, form, not add)
1600                 self.save_related(request, form, formsets, not add)
1601                 change_message = self.construct_change_message(request, form, formsets, add)
1602                 if add:
1603                     self.log_addition(request, new_object, change_message)
1604                     return self.response_add(request, new_object)
1605                 else:
1606                     self.log_change(request, new_object, change_message)
1607                     return self.response_change(request, new_object)
1608             else:
1609                 form_validated = False
1610         else:
1611             if add:
1612                 initial = self.get_changeform_initial_data(request)
1613                 form = ModelForm(initial=initial)
1614                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1615             else:
1616                 form = ModelForm(instance=obj)
1617                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1618 
1619         if not add and not self.has_change_permission(request, obj):
1620             readonly_fields = flatten_fieldsets(fieldsets)
1621         else:
1622             readonly_fields = self.get_readonly_fields(request, obj)
1623         adminForm = helpers.AdminForm(
1624             form,
1625             list(fieldsets),
1626             # Clear prepopulated fields on a view-only form to avoid a crash.
1627             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1628             readonly_fields,
1629             model_admin=self)
1630         media = self.media + adminForm.media
1631 
1632         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1633         for inline_formset in inline_formsets:
1634             media = media + inline_formset.media
1635 
1636         if add:
1637             title = _('Add %s')
1638         elif self.has_change_permission(request, obj):
1639             title = _('Change %s')
1640         else:
1641             title = _('View %s')
1642         context = {
1643             **self.admin_site.each_context(request),
1644             'title': title % opts.verbose_name,
1645             'subtitle': str(obj) if obj else None,
1646             'adminform': adminForm,
1647             'object_id': object_id,
1648             'original': obj,
1649             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1650             'to_field': to_field,
1651             'media': media,
1652             'inline_admin_formsets': inline_formsets,
1653             'errors': helpers.AdminErrorList(form, formsets),
1654             'preserved_filters': self.get_preserved_filters(request),
1655         }
1656 
1657         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1658         # previously chosen to prevent the interface from getting confusing.
1659         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1660             context['show_save'] = False
1661             context['show_save_and_continue'] = False
1662             # Use the change template instead of the add template.
1663             add = False
1664 
1665         context.update(extra_context or {})
1666 
1667         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1668 
1669     def add_view(self, request, form_url='', extra_context=None):
1670         return self.changeform_view(request, None, form_url, extra_context)
1671 
1672     def change_view(self, request, object_id, form_url='', extra_context=None):
1673         return self.changeform_view(request, object_id, form_url, extra_context)
1674 
1675     def _get_edited_object_pks(self, request, prefix):
1676         """Return POST data values of list_editable primary keys."""
1677         pk_pattern = re.compile(
1678             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1679         )
1680         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1681 
1682     def _get_list_editable_queryset(self, request, prefix):
1683         """
1684         Based on POST data, return a queryset of the objects that were edited
1685         via list_editable.
1686         """
1687         object_pks = self._get_edited_object_pks(request, prefix)
1688         queryset = self.get_queryset(request)
1689         validate = queryset.model._meta.pk.to_python
1690         try:
1691             for pk in object_pks:
1692                 validate(pk)
1693         except ValidationError:
1694             # Disable the optimization if the POST data was tampered with.
1695             return queryset
1696         return queryset.filter(pk__in=object_pks)
1697 
1698     @csrf_protect_m
1699     def changelist_view(self, request, extra_context=None):
1700         """
1701         The 'change list' admin view for this model.
1702         """
1703         from django.contrib.admin.views.main import ERROR_FLAG
1704         opts = self.model._meta
1705         app_label = opts.app_label
1706         if not self.has_view_or_change_permission(request):
1707             raise PermissionDenied
1708 
1709         try:
1710             cl = self.get_changelist_instance(request)
1711         except IncorrectLookupParameters:
1712             # Wacky lookup parameters were given, so redirect to the main
1713             # changelist page, without parameters, and pass an 'invalid=1'
1714             # parameter via the query string. If wacky parameters were given
1715             # and the 'invalid=1' parameter was already in the query string,
1716             # something is screwed up with the database, so display an error
1717             # page.
1718             if ERROR_FLAG in request.GET:
1719                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1720                     'title': _('Database error'),
1721                 })
1722             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1723 
1724         # If the request was POSTed, this might be a bulk action or a bulk
1725         # edit. Try to look up an action or confirmation first, but if this
1726         # isn't an action the POST will fall through to the bulk edit check,
1727         # below.
1728         action_failed = False
1729         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1730 
1731         actions = self.get_actions(request)
1732         # Actions with no confirmation
1733         if (actions and request.method == 'POST' and
1734                 'index' in request.POST and '_save' not in request.POST):
1735             if selected:
1736                 response = self.response_action(request, queryset=cl.get_queryset(request))
1737                 if response:
1738                     return response
1739                 else:
1740                     action_failed = True
1741             else:
1742                 msg = _("Items must be selected in order to perform "
1743                         "actions on them. No items have been changed.")
1744                 self.message_user(request, msg, messages.WARNING)
1745                 action_failed = True
1746 
1747         # Actions with confirmation
1748         if (actions and request.method == 'POST' and
1749                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1750                 'index' not in request.POST and '_save' not in request.POST):
1751             if selected:
1752                 response = self.response_action(request, queryset=cl.get_queryset(request))
1753                 if response:
1754                     return response
1755                 else:
1756                     action_failed = True
1757 
1758         if action_failed:
1759             # Redirect back to the changelist page to avoid resubmitting the
1760             # form if the user refreshes the browser or uses the "No, take
1761             # me back" button on the action confirmation page.
1762             return HttpResponseRedirect(request.get_full_path())
1763 
1764         # If we're allowing changelist editing, we need to construct a formset
1765         # for the changelist given all the fields to be edited. Then we'll
1766         # use the formset to validate/process POSTed data.
1767         formset = cl.formset = None
1768 
1769         # Handle POSTed bulk-edit data.
1770         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1771             if not self.has_change_permission(request):
1772                 raise PermissionDenied
1773             FormSet = self.get_changelist_formset(request)
1774             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1775             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1776             if formset.is_valid():
1777                 changecount = 0
1778                 for form in formset.forms:
1779                     if form.has_changed():
1780                         obj = self.save_form(request, form, change=True)
1781                         self.save_model(request, obj, form, change=True)
1782                         self.save_related(request, form, formsets=[], change=True)
1783                         change_msg = self.construct_change_message(request, form, None)
1784                         self.log_change(request, obj, change_msg)
1785                         changecount += 1
1786 
1787                 if changecount:
1788                     msg = ngettext(
1789                         "%(count)s %(name)s was changed successfully.",
1790                         "%(count)s %(name)s were changed successfully.",
1791                         changecount
1792                     ) % {
1793                         'count': changecount,
1794                         'name': model_ngettext(opts, changecount),
1795                     }
1796                     self.message_user(request, msg, messages.SUCCESS)
1797 
1798                 return HttpResponseRedirect(request.get_full_path())
1799 
1800         # Handle GET -- construct a formset for display.
1801         elif cl.list_editable and self.has_change_permission(request):
1802             FormSet = self.get_changelist_formset(request)
1803             formset = cl.formset = FormSet(queryset=cl.result_list)
1804 
1805         # Build the list of media to be used by the formset.
1806         if formset:
1807             media = self.media + formset.media
1808         else:
1809             media = self.media
1810 
1811         # Build the action form and populate it with available actions.
1812         if actions:
1813             action_form = self.action_form(auto_id=None)
1814             action_form.fields['action'].choices = self.get_action_choices(request)
1815             media += action_form.media
1816         else:
1817             action_form = None
1818 
1819         selection_note_all = ngettext(
1820             '%(total_count)s selected',
1821             'All %(total_count)s selected',
1822             cl.result_count
1823         )
1824 
1825         context = {
1826             **self.admin_site.each_context(request),
1827             'module_name': str(opts.verbose_name_plural),
1828             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1829             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1830             'title': cl.title,
1831             'subtitle': None,
1832             'is_popup': cl.is_popup,
1833             'to_field': cl.to_field,
1834             'cl': cl,
1835             'media': media,
1836             'has_add_permission': self.has_add_permission(request),
1837             'opts': cl.opts,
1838             'action_form': action_form,
1839             'actions_on_top': self.actions_on_top,
1840             'actions_on_bottom': self.actions_on_bottom,
1841             'actions_selection_counter': self.actions_selection_counter,
1842             'preserved_filters': self.get_preserved_filters(request),
1843             **(extra_context or {}),
1844         }
1845 
1846         request.current_app = self.admin_site.name
1847 
1848         return TemplateResponse(request, self.change_list_template or [
1849             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1850             'admin/%s/change_list.html' % app_label,
1851             'admin/change_list.html'
1852         ], context)
1853 
1854     def get_deleted_objects(self, objs, request):
1855         """
1856         Hook for customizing the delete process for the delete view and the
1857         "delete selected" action.
1858         """
1859         return get_deleted_objects(objs, request, self.admin_site)
1860 
1861     @csrf_protect_m
1862     def delete_view(self, request, object_id, extra_context=None):
1863         with transaction.atomic(using=router.db_for_write(self.model)):
1864             return self._delete_view(request, object_id, extra_context)
1865 
1866     def _delete_view(self, request, object_id, extra_context):
1867         "The 'delete' admin view for this model."
1868         opts = self.model._meta
1869         app_label = opts.app_label
1870 
1871         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1872         if to_field and not self.to_field_allowed(request, to_field):
1873             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1874 
1875         obj = self.get_object(request, unquote(object_id), to_field)
1876 
1877         if not self.has_delete_permission(request, obj):
1878             raise PermissionDenied
1879 
1880         if obj is None:
1881             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1882 
1883         # Populate deleted_objects, a data structure of all related objects that
1884         # will also be deleted.
1885         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1886 
1887         if request.POST and not protected:  # The user has confirmed the deletion.
1888             if perms_needed:
1889                 raise PermissionDenied
1890             obj_display = str(obj)
1891             attr = str(to_field) if to_field else opts.pk.attname
1892             obj_id = obj.serializable_value(attr)
1893             self.log_deletion(request, obj, obj_display)
1894             self.delete_model(request, obj)
1895 
1896             return self.response_delete(request, obj_display, obj_id)
1897 
1898         object_name = str(opts.verbose_name)
1899 
1900         if perms_needed or protected:
1901             title = _("Cannot delete %(name)s") % {"name": object_name}
1902         else:
1903             title = _("Are you sure?")
1904 
1905         context = {
1906             **self.admin_site.each_context(request),
1907             'title': title,
1908             'subtitle': None,
1909             'object_name': object_name,
1910             'object': obj,
1911             'deleted_objects': deleted_objects,
1912             'model_count': dict(model_count).items(),
1913             'perms_lacking': perms_needed,
1914             'protected': protected,
1915             'opts': opts,
1916             'app_label': app_label,
1917             'preserved_filters': self.get_preserved_filters(request),
1918             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1919             'to_field': to_field,
1920             **(extra_context or {}),
1921         }
1922 
1923         return self.render_delete_form(request, context)
1924 
1925     def history_view(self, request, object_id, extra_context=None):
1926         "The 'history' admin view for this model."
1927         from django.contrib.admin.models import LogEntry
1928 
1929         # First check if the user can see this history.
1930         model = self.model
1931         obj = self.get_object(request, unquote(object_id))
1932         if obj is None:
1933             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1934 
1935         if not self.has_view_or_change_permission(request, obj):
1936             raise PermissionDenied
1937 
1938         # Then get the history for this object.
1939         opts = model._meta
1940         app_label = opts.app_label
1941         action_list = LogEntry.objects.filter(
1942             object_id=unquote(object_id),
1943             content_type=get_content_type_for_model(model)
1944         ).select_related().order_by('action_time')
1945 
1946         context = {
1947             **self.admin_site.each_context(request),
1948             'title': _('Change history: %s') % obj,
1949             'subtitle': None,
1950             'action_list': action_list,
1951             'module_name': str(capfirst(opts.verbose_name_plural)),
1952             'object': obj,
1953             'opts': opts,
1954             'preserved_filters': self.get_preserved_filters(request),
1955             **(extra_context or {}),
1956         }
1957 
1958         request.current_app = self.admin_site.name
1959 
1960         return TemplateResponse(request, self.object_history_template or [
1961             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1962             "admin/%s/object_history.html" % app_label,
1963             "admin/object_history.html"
1964         ], context)
1965 
1966     def get_formset_kwargs(self, request, obj, inline, prefix):
1967         formset_params = {
1968             'instance': obj,
1969             'prefix': prefix,
1970             'queryset': inline.get_queryset(request),
1971         }
1972         if request.method == 'POST':
1973             formset_params.update({
1974                 'data': request.POST.copy(),
1975                 'files': request.FILES,
1976                 'save_as_new': '_saveasnew' in request.POST
1977             })
1978         return formset_params
1979 
1980     def _create_formsets(self, request, obj, change):
1981         "Helper function to generate formsets for add/change_view."
1982         formsets = []
1983         inline_instances = []
1984         prefixes = {}
1985         get_formsets_args = [request]
1986         if change:
1987             get_formsets_args.append(obj)
1988         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1989             prefix = FormSet.get_default_prefix()
1990             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1991             if prefixes[prefix] != 1 or not prefix:
1992                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1993             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
1994             formset = FormSet(**formset_params)
1995 
1996             def user_deleted_form(request, obj, formset, index):
1997                 """Return whether or not the user deleted the form."""
1998                 return (
1999                     inline.has_delete_permission(request, obj) and
2000                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
2001                 )
2002 
2003             # Bypass validation of each view-only inline form (since the form's
2004             # data won't be in request.POST), unless the form was deleted.
2005             if not inline.has_change_permission(request, obj if change else None):
2006                 for index, form in enumerate(formset.initial_forms):
2007                     if user_deleted_form(request, obj, formset, index):
2008                         continue
2009                     form._errors = {}
2010                     form.cleaned_data = form.initial
2011             formsets.append(formset)
2012             inline_instances.append(inline)
2013         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 10:42:25.180 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 10:42:25.180 | INFO     | Search-only: skipping patch selection
2025-10-18 10:42:25.387 | INFO     | Task django__django-15022 completed successfully.
2025-10-18 10:42:25.388 | INFO     | No patch generated. You can try running ACR again.
