2025-10-18 18:40:22.223 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 18:40:26.422 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=375, output_tokens=13, cost=0.004140
2025-10-18 18:40:43.776 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=555, output_tokens=804, cost=0.029670
2025-10-18 18:40:45.049 | INFO     | registered non reproducing test 0
2025-10-18 18:41:02.119 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2190, output_tokens=806, cost=0.046080
2025-10-18 18:41:03.323 | INFO     | registered non reproducing test 1
2025-10-18 18:41:18.940 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2316, output_tokens=778, cost=0.046500
2025-10-18 18:41:20.129 | INFO     | registered non reproducing test 2
2025-10-18 18:41:20.129 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 18:41:20.135 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:41:29.504 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=676, output_tokens=439, cost=0.019930
2025-10-18 18:41:29.512 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:41:32.419 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=793, output_tokens=52, cost=0.009490
2025-10-18 18:41:32.420 | DEBUG    | Extracted a valid json.
2025-10-18 18:41:32.420 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"normpath\")",
        "search_code(\":download:\")",
        "search_class(\"Document\")",
        "search_class(\"StaticFile\")"
    ],
    "bug_locations": []
}
2025-10-18 18:41:32.460 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:41:32.461 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:41:47.644 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1426, output_tokens=709, cost=0.035530
2025-10-18 18:41:47.658 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:41:55.727 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2351, output_tokens=347, cost=0.033920
2025-10-18 18:41:55.735 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:42:02.404 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=701, output_tokens=242, cost=0.014270
2025-10-18 18:42:02.406 | DEBUG    | Extracted a valid json.
2025-10-18 18:42:02.406 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/builders/html/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should include or be modified to ensure that when handling file paths for resources like downloads or figures, all path references are normalized using os.path.normpath() (or a Sphinx equivalent function if it wraps path operations for cross-platform compatibility). Additionally, before treating any file as a duplicate, the code should verify whether the normalized paths actually point to the different resources. This process will prevent the issue where the same file is interpreted as multiple files when referenced in various ways."
        },
        {
            "file": "sphinx/environment/collectors/dependencies.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file, likely involved in tracking and managing file dependencies within the Sphinx build environment, should be modified to ensure that any comparisons or operations on file paths are conducted on normalized paths. This will aid in accurately tracking file dependencies and usage without falsely identifying the same file as multiple ones due to path differences."
        }
    ]
}
2025-10-18 18:42:02.413 | DEBUG    | Bug location extracted successfully: [<file>sphinx/builders/html/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.builders.html
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Several HTML builders.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import html
12 import os
13 import posixpath
14 import re
15 import sys
16 import warnings
17 from os import path
18 from typing import IO, Any, Dict, Iterable, Iterator, List, Set, Tuple
19 from urllib.parse import quote
20 
21 from docutils import nodes
22 from docutils.core import publish_parts
23 from docutils.frontend import OptionParser
24 from docutils.io import DocTreeInput, StringOutput
25 from docutils.nodes import Node
26 from docutils.utils import relative_path
27 
28 from sphinx import __display_version__, package_dir
29 from sphinx.application import Sphinx
30 from sphinx.builders import Builder
31 from sphinx.config import ENUM, Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index, IndexEntry
34 from sphinx.environment.adapters.asset import ImageAdapter
35 from sphinx.environment.adapters.indexentries import IndexEntries
36 from sphinx.environment.adapters.toctree import TocTree
37 from sphinx.errors import ConfigError, ThemeError
38 from sphinx.highlighting import PygmentsBridge
39 from sphinx.locale import _, __
40 from sphinx.search import js_index
41 from sphinx.theming import HTMLThemeFactory
42 from sphinx.util import logging, md5, progress_message, status_iterator
43 from sphinx.util.docutils import is_html5_writer_available, new_document
44 from sphinx.util.fileutil import copy_asset
45 from sphinx.util.i18n import format_date
46 from sphinx.util.inventory import InventoryFile
47 from sphinx.util.matching import DOTFILES, Matcher, patmatch
48 from sphinx.util.osutil import copyfile, ensuredir, os_path, relative_uri
49 from sphinx.util.tags import Tags
50 from sphinx.writers.html import HTMLTranslator, HTMLWriter
51 
52 if False:
53     # For type annotation
54     from typing import Type  # for python3.5.1
55 
56 
57 # HTML5 Writer is available or not
58 if is_html5_writer_available():
59     from sphinx.writers.html5 import HTML5Translator
60     html5_ready = True
61 else:
62     html5_ready = False
63 
64 #: the filename for the inventory of objects
65 INVENTORY_FILENAME = 'objects.inv'
66 
67 logger = logging.getLogger(__name__)
68 return_codes_re = re.compile('[\r\n]+')
69 
70 
71 def get_stable_hash(obj: Any) -> str:
72     """
73     Return a stable hash for a Python data structure.  We can't just use
74     the md5 of str(obj) since for example dictionary items are enumerated
75     in unpredictable order due to hash randomization in newer Pythons.
76     """
77     if isinstance(obj, dict):
78         return get_stable_hash(list(obj.items()))
79     elif isinstance(obj, (list, tuple)):
80         obj = sorted(get_stable_hash(o) for o in obj)
81     return md5(str(obj).encode()).hexdigest()
82 
83 
84 class Stylesheet(str):
85     """A metadata of stylesheet.
86 
87     To keep compatibility with old themes, an instance of stylesheet behaves as
88     its filename (str).
89     """
90 
91     attributes = None   # type: Dict[str, str]
92     filename = None     # type: str
93     priority = None     # type: int
94 
95     def __new__(cls, filename: str, *args: str, priority: int = 500, **attributes: Any
96                 ) -> "Stylesheet":
97         self = str.__new__(cls, filename)  # type: ignore
98         self.filename = filename
99         self.priority = priority
100         self.attributes = attributes
101         self.attributes.setdefault('rel', 'stylesheet')
102         self.attributes.setdefault('type', 'text/css')
103         if args:  # old style arguments (rel, title)
104             self.attributes['rel'] = args[0]
105             self.attributes['title'] = args[1]
106 
107         return self
108 
109 
110 class JavaScript(str):
111     """A metadata of javascript file.
112 
113     To keep compatibility with old themes, an instance of javascript behaves as
114     its filename (str).
115     """
116 
117     attributes = None   # type: Dict[str, str]
118     filename = None     # type: str
119     priority = None     # type: int
120 
121     def __new__(cls, filename: str, priority: int = 500, **attributes: str) -> "JavaScript":
122         self = str.__new__(cls, filename)  # type: ignore
123         self.filename = filename
124         self.priority = priority
125         self.attributes = attributes
126 
127         return self
128 
129 
130 class BuildInfo:
131     """buildinfo file manipulator.
132 
133     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.
134     This class is a manipulator for the file.
135     """
136 
137     @classmethod
138     def load(cls, f: IO) -> "BuildInfo":
139         try:
140             lines = f.readlines()
141             assert lines[0].rstrip() == '# Sphinx build info version 1'
142             assert lines[2].startswith('config: ')
143             assert lines[3].startswith('tags: ')
144 
145             build_info = BuildInfo()
146             build_info.config_hash = lines[2].split()[1].strip()
147             build_info.tags_hash = lines[3].split()[1].strip()
148             return build_info
149         except Exception as exc:
150             raise ValueError(__('build info file is broken: %r') % exc) from exc
151 
152     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA
153         self.config_hash = ''
154         self.tags_hash = ''
155 
156         if config:
157             values = {c.name: c.value for c in config.filter(config_categories)}
158             self.config_hash = get_stable_hash(values)
159 
160         if tags:
161             self.tags_hash = get_stable_hash(sorted(tags))
162 
163     def __eq__(self, other: "BuildInfo") -> bool:  # type: ignore
164         return (self.config_hash == other.config_hash and
165                 self.tags_hash == other.tags_hash)
166 
167     def dump(self, f: IO) -> None:
168         f.write('# Sphinx build info version 1\n'
169                 '# This file hashes the configuration used when building these files.'
170                 ' When it is not found, a full rebuild will be done.\n'
171                 'config: %s\n'
172                 'tags: %s\n' %
173                 (self.config_hash, self.tags_hash))
174 
175 
176 class StandaloneHTMLBuilder(Builder):
177     """
178     Builds standalone HTML docs.
179     """
180     name = 'html'
181     format = 'html'
182     epilog = __('The HTML pages are in %(outdir)s.')
183 
184     copysource = True
185     allow_parallel = True
186     out_suffix = '.html'
187     link_suffix = '.html'  # defaults to matching out_suffix
188     indexer_format = js_index  # type: Any
189     indexer_dumps_unicode = True
190     # create links to original images from images [True/False]
191     html_scaled_image_link = True
192     supported_image_types = ['image/svg+xml', 'image/png',
193                              'image/gif', 'image/jpeg']
194     supported_remote_images = True
195     supported_data_uri_images = True
196     searchindex_filename = 'searchindex.js'
197     add_permalinks = True
198     allow_sharp_as_current_path = True
199     embedded = False  # for things like HTML help or Qt help: suppresses sidebar
200     search = True  # for things like HTML help and Apple help: suppress search
201     use_index = False
202     download_support = True  # enable download role
203 
204     imgpath = None          # type: str
205     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA
206 
207     def __init__(self, app: Sphinx) -> None:
208         super().__init__(app)
209 
210         # CSS files
211         self.css_files = []  # type: List[Dict[str, str]]
212 
213         # JS files
214         self.script_files = []  # type: List[JavaScript]
215 
216     def init(self) -> None:
217         self.build_info = self.create_build_info()
218         # basename of images directory
219         self.imagedir = '_images'
220         # section numbers for headings in the currently visited document
221         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]
222         # currently written docname
223         self.current_docname = None  # type: str
224 
225         self.init_templates()
226         self.init_highlighter()
227         self.init_css_files()
228         self.init_js_files()
229 
230         html_file_suffix = self.get_builder_config('file_suffix', 'html')
231         if html_file_suffix is not None:
232             self.out_suffix = html_file_suffix
233 
234         html_link_suffix = self.get_builder_config('link_suffix', 'html')
235         if html_link_suffix is not None:
236             self.link_suffix = html_link_suffix
237         else:
238             self.link_suffix = self.out_suffix
239 
240         self.use_index = self.get_builder_config('use_index', 'html')
241 
242     def create_build_info(self) -> BuildInfo:
243         return BuildInfo(self.config, self.tags, ['html'])
244 
245     def _get_translations_js(self) -> str:
246         candidates = [path.join(dir, self.config.language,
247                                 'LC_MESSAGES', 'sphinx.js')
248                       for dir in self.config.locale_dirs] + \
249                      [path.join(package_dir, 'locale', self.config.language,
250                                 'LC_MESSAGES', 'sphinx.js'),
251                       path.join(sys.prefix, 'share/sphinx/locale',
252                                 self.config.language, 'sphinx.js')]
253 
254         for jsfile in candidates:
255             if path.isfile(jsfile):
256                 return jsfile
257         return None
258 
259     def get_theme_config(self) -> Tuple[str, Dict]:
260         return self.config.html_theme, self.config.html_theme_options
261 
262     def init_templates(self) -> None:
263         theme_factory = HTMLThemeFactory(self.app)
264         themename, themeoptions = self.get_theme_config()
265         self.theme = theme_factory.create(themename)
266         self.theme_options = themeoptions.copy()
267         self.create_template_bridge()
268         self.templates.init(self, self.theme)
269 
270     def init_highlighter(self) -> None:
271         # determine Pygments style and create the highlighter
272         if self.config.pygments_style is not None:
273             style = self.config.pygments_style
274         elif self.theme:
275             style = self.theme.get_config('theme', 'pygments_style', 'none')
276         else:
277             style = 'sphinx'
278         self.highlighter = PygmentsBridge('html', style)
279 
280         if self.theme:
281             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)
282         else:
283             dark_style = None
284 
285         if dark_style is not None:
286             self.dark_highlighter = PygmentsBridge('html', dark_style)
287             self.add_css_file('pygments_dark.css',
288                               media='(prefers-color-scheme: dark)',
289                               id='pygments_dark_css')
290         else:
291             self.dark_highlighter = None
292 
293     def init_css_files(self) -> None:
294         for filename, attrs in self.app.registry.css_files:
295             self.add_css_file(filename, **attrs)
296 
297         for filename, attrs in self.get_builder_config('css_files', 'html'):
298             attrs.setdefault('priority', 800)  # User's CSSs are loaded after extensions'
299             self.add_css_file(filename, **attrs)
300 
301     def add_css_file(self, filename: str, **kwargs: Any) -> None:
302         if '://' not in filename:
303             filename = posixpath.join('_static', filename)
304 
305         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore
306 
307     def init_js_files(self) -> None:
308         self.add_js_file('jquery.js', priority=200)
309         self.add_js_file('underscore.js', priority=200)
310         self.add_js_file('doctools.js', priority=200)
311 
312         for filename, attrs in self.app.registry.js_files:
313             self.add_js_file(filename, **attrs)
314 
315         for filename, attrs in self.get_builder_config('js_files', 'html'):
316             attrs.setdefault('priority', 800)  # User's JSs are loaded after extensions'
317             self.add_js_file(filename, **attrs)
318 
319         if self.config.language and self._get_translations_js():
320             self.add_js_file('translations.js')
321 
322     def add_js_file(self, filename: str, **kwargs: Any) -> None:
323         if filename and '://' not in filename:
324             filename = posixpath.join('_static', filename)
325 
326         self.script_files.append(JavaScript(filename, **kwargs))
327 
328     @property
329     def default_translator_class(self) -> "Type[nodes.NodeVisitor]":  # type: ignore
330         if not html5_ready or self.config.html4_writer:
331             return HTMLTranslator
332         else:
333             return HTML5Translator
334 
335     @property
336     def math_renderer_name(self) -> str:
337         name = self.get_builder_config('math_renderer', 'html')
338         if name is not None:
339             # use given name
340             return name
341         else:
342             # not given: choose a math_renderer from registered ones as possible
343             renderers = list(self.app.registry.html_inline_math_renderers)
344             if len(renderers) == 1:
345                 # only default math_renderer (mathjax) is registered
346                 return renderers[0]
347             elif len(renderers) == 2:
348                 # default and another math_renderer are registered; prior the another
349                 renderers.remove('mathjax')
350                 return renderers[0]
351             else:
352                 # many math_renderers are registered. can't choose automatically!
353                 return None
354 
355     def get_outdated_docs(self) -> Iterator[str]:
356         try:
357             with open(path.join(self.outdir, '.buildinfo')) as fp:
358                 buildinfo = BuildInfo.load(fp)
359 
360             if self.build_info != buildinfo:
361                 yield from self.env.found_docs
362                 return
363         except ValueError as exc:
364             logger.warning(__('Failed to read build info file: %r'), exc)
365         except OSError:
366             # ignore errors on reading
367             pass
368 
369         if self.templates:
370             template_mtime = self.templates.newest_template_mtime()
371         else:
372             template_mtime = 0
373         for docname in self.env.found_docs:
374             if docname not in self.env.all_docs:
375                 yield docname
376                 continue
377             targetname = self.get_outfilename(docname)
378             try:
379                 targetmtime = path.getmtime(targetname)
380             except Exception:
381                 targetmtime = 0
382             try:
383                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),
384                                template_mtime)
385                 if srcmtime > targetmtime:
386                     yield docname
387             except OSError:
388                 # source doesn't exist anymore
389                 pass
390 
391     def get_asset_paths(self) -> List[str]:
392         return self.config.html_extra_path + self.config.html_static_path
393 
394     def render_partial(self, node: Node) -> Dict[str, str]:
395         """Utility: Render a lone doctree node."""
396         if node is None:
397             return {'fragment': ''}
398         doc = new_document('<partial node>')
399         doc.append(node)
400 
401         writer = HTMLWriter(self)
402         return publish_parts(reader_name='doctree',
403                              writer=writer,
404                              source_class=DocTreeInput,
405                              settings_overrides={'output_encoding': 'unicode'},
406                              source=doc)
407 
408     def prepare_writing(self, docnames: Set[str]) -> None:
409         # create the search indexer
410         self.indexer = None
411         if self.search:
412             from sphinx.search import IndexBuilder
413             lang = self.config.html_search_language or self.config.language
414             if not lang:
415                 lang = 'en'
416             self.indexer = IndexBuilder(self.env, lang,
417                                         self.config.html_search_options,
418                                         self.config.html_search_scorer)
419             self.load_indexer(docnames)
420 
421         self.docwriter = HTMLWriter(self)
422         self.docsettings = OptionParser(
423             defaults=self.env.settings,
424             components=(self.docwriter,),
425             read_config_files=True).get_default_values()  # type: Any
426         self.docsettings.compact_lists = bool(self.config.html_compact_lists)
427 
428         # determine the additional indices to include
429         self.domain_indices = []
430         # html_domain_indices can be False/True or a list of index names
431         indices_config = self.config.html_domain_indices
432         if indices_config:
433             for domain_name in sorted(self.env.domains):
434                 domain = None  # type: Domain
435                 domain = self.env.domains[domain_name]
436                 for indexcls in domain.indices:
437                     indexname = '%s-%s' % (domain.name, indexcls.name)
438                     if isinstance(indices_config, list):
439                         if indexname not in indices_config:
440                             continue
441                     content, collapse = indexcls(domain).generate()
442                     if content:
443                         self.domain_indices.append(
444                             (indexname, indexcls, content, collapse))
445 
446         # format the "last updated on" string, only once is enough since it
447         # typically doesn't include the time of day
448         lufmt = self.config.html_last_updated_fmt
449         if lufmt is not None:
450             self.last_updated = format_date(lufmt or _('%b %d, %Y'),
451                                             language=self.config.language)
452         else:
453             self.last_updated = None
454 
455         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''
456         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''
457 
458         self.relations = self.env.collect_relations()
459 
460         rellinks = []  # type: List[Tuple[str, str, str, str]]
461         if self.use_index:
462             rellinks.append(('genindex', _('General Index'), 'I', _('index')))
463         for indexname, indexcls, content, collapse in self.domain_indices:
464             # if it has a short name
465             if indexcls.shortname:
466                 rellinks.append((indexname, indexcls.localname,
467                                  '', indexcls.shortname))
468 
469         # back up script_files and css_files to allow adding JS/CSS files to a specific page.
470         self._script_files = list(self.script_files)
471         self._css_files = list(self.css_files)
472 
473         if self.config.html_style is not None:
474             stylename = self.config.html_style
475         elif self.theme:
476             stylename = self.theme.get_config('theme', 'stylesheet')
477         else:
478             stylename = 'default.css'
479 
480         self.globalcontext = {
481             'embedded': self.embedded,
482             'project': self.config.project,
483             'release': return_codes_re.sub('', self.config.release),
484             'version': self.config.version,
485             'last_updated': self.last_updated,
486             'copyright': self.config.copyright,
487             'master_doc': self.config.master_doc,
488             'use_opensearch': self.config.html_use_opensearch,
489             'docstitle': self.config.html_title,
490             'shorttitle': self.config.html_short_title,
491             'show_copyright': self.config.html_show_copyright,
492             'show_sphinx': self.config.html_show_sphinx,
493             'has_source': self.config.html_copy_source,
494             'show_source': self.config.html_show_sourcelink,
495             'sourcelink_suffix': self.config.html_sourcelink_suffix,
496             'file_suffix': self.out_suffix,
497             'link_suffix': self.link_suffix,
498             'script_files': self.script_files,
499             'language': self.config.language,
500             'css_files': self.css_files,
501             'sphinx_version': __display_version__,
502             'style': stylename,
503             'rellinks': rellinks,
504             'builder': self.name,
505             'parents': [],
506             'logo': logo,
507             'favicon': favicon,
508             'html5_doctype': html5_ready and not self.config.html4_writer,
509         }
510         if self.theme:
511             self.globalcontext.update(
512                 ('theme_' + key, val) for (key, val) in
513                 self.theme.get_options(self.theme_options).items())
514         self.globalcontext.update(self.config.html_context)
515 
516     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:
517         """Collect items for the template context of a page."""
518         # find out relations
519         prev = next = None
520         parents = []
521         rellinks = self.globalcontext['rellinks'][:]
522         related = self.relations.get(docname)
523         titles = self.env.titles
524         if related and related[2]:
525             try:
526                 next = {
527                     'link': self.get_relative_uri(docname, related[2]),
528                     'title': self.render_partial(titles[related[2]])['title']
529                 }
530                 rellinks.append((related[2], next['title'], 'N', _('next')))
531             except KeyError:
532                 next = None
533         if related and related[1]:
534             try:
535                 prev = {
536                     'link': self.get_relative_uri(docname, related[1]),
537                     'title': self.render_partial(titles[related[1]])['title']
538                 }
539                 rellinks.append((related[1], prev['title'], 'P', _('previous')))
540             except KeyError:
541                 # the relation is (somehow) not in the TOC tree, handle
542                 # that gracefully
543                 prev = None
544         while related and related[0]:
545             try:
546                 parents.append(
547                     {'link': self.get_relative_uri(docname, related[0]),
548                      'title': self.render_partial(titles[related[0]])['title']})
549             except KeyError:
550                 pass
551             related = self.relations.get(related[0])
552         if parents:
553             # remove link to the master file; we have a generic
554             # "back to index" link already
555             parents.pop()
556         parents.reverse()
557 
558         # title rendered as HTML
559         title_node = self.env.longtitles.get(docname)
560         title = self.render_partial(title_node)['title'] if title_node else ''
561 
562         # Suffix for the document
563         source_suffix = self.env.doc2path(docname, False)[len(docname):]
564 
565         # the name for the copied source
566         if self.config.html_copy_source:
567             sourcename = docname + source_suffix
568             if source_suffix != self.config.html_sourcelink_suffix:
569                 sourcename += self.config.html_sourcelink_suffix
570         else:
571             sourcename = ''
572 
573         # metadata for the document
574         meta = self.env.metadata.get(docname)
575 
576         # local TOC and global TOC tree
577         self_toc = TocTree(self.env).get_toc_for(docname, self)
578         toc = self.render_partial(self_toc)['fragment']
579 
580         return {
581             'parents': parents,
582             'prev': prev,
583             'next': next,
584             'title': title,
585             'meta': meta,
586             'body': body,
587             'metatags': metatags,
588             'rellinks': rellinks,
589             'sourcename': sourcename,
590             'toc': toc,
591             # only display a TOC if there's more than one item to show
592             'display_toc': (self.env.toc_num_entries[docname] > 1),
593             'page_source_suffix': source_suffix,
594         }
595 
596     def write_doc(self, docname: str, doctree: nodes.document) -> None:
597         destination = StringOutput(encoding='utf-8')
598         doctree.settings = self.docsettings
599 
600         self.secnumbers = self.env.toc_secnumbers.get(docname, {})
601         self.fignumbers = self.env.toc_fignumbers.get(docname, {})
602         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')
603         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')
604         self.current_docname = docname
605         self.docwriter.write(doctree, destination)
606         self.docwriter.assemble_parts()
607         body = self.docwriter.parts['fragment']
608         metatags = self.docwriter.clean_meta
609 
610         ctx = self.get_doc_context(docname, body, metatags)
611         self.handle_page(docname, ctx, event_arg=doctree)
612 
613     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:
614         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)
615         self.post_process_images(doctree)
616         title_node = self.env.longtitles.get(docname)
617         title = self.render_partial(title_node)['title'] if title_node else ''
618         self.index_page(docname, doctree, title)
619 
620     def finish(self) -> None:
621         self.finish_tasks.add_task(self.gen_indices)
622         self.finish_tasks.add_task(self.gen_pages_from_extensions)
623         self.finish_tasks.add_task(self.gen_additional_pages)
624         self.finish_tasks.add_task(self.copy_image_files)
625         self.finish_tasks.add_task(self.copy_download_files)
626         self.finish_tasks.add_task(self.copy_static_files)
627         self.finish_tasks.add_task(self.copy_extra_files)
628         self.finish_tasks.add_task(self.write_buildinfo)
629 
630         # dump the search index
631         self.handle_finish()
632 
633     @progress_message(__('generating indices'))
634     def gen_indices(self) -> None:
635         # the global general index
636         if self.use_index:
637             self.write_genindex()
638 
639         # the global domain-specific indices
640         self.write_domain_indices()
641 
642     def gen_pages_from_extensions(self) -> None:
643         # pages from extensions
644         for pagelist in self.events.emit('html-collect-pages'):
645             for pagename, context, template in pagelist:
646                 self.handle_page(pagename, context, template)
647 
648     @progress_message(__('writing additional pages'))
649     def gen_additional_pages(self) -> None:
650         # additional pages from conf.py
651         for pagename, template in self.config.html_additional_pages.items():
652             logger.info(pagename + ' ', nonl=True)
653             self.handle_page(pagename, {}, template)
654 
655         # the search page
656         if self.search:
657             logger.info('search ', nonl=True)
658             self.handle_page('search', {}, 'search.html')
659 
660         # the opensearch xml file
661         if self.config.html_use_opensearch and self.search:
662             logger.info('opensearch ', nonl=True)
663             fn = path.join(self.outdir, '_static', 'opensearch.xml')
664             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)
665 
666     def write_genindex(self) -> None:
667         # the total count of lines for each index letter, used to distribute
668         # the entries into two columns
669         genindex = IndexEntries(self.env).create_index(self)
670         indexcounts = []
671         for _k, entries in genindex:
672             indexcounts.append(sum(1 + len(subitems)
673                                    for _, (_, subitems, _) in entries))
674 
675         genindexcontext = {
676             'genindexentries': genindex,
677             'genindexcounts': indexcounts,
678             'split_index': self.config.html_split_index,
679         }
680         logger.info('genindex ', nonl=True)
681 
682         if self.config.html_split_index:
683             self.handle_page('genindex', genindexcontext,
684                              'genindex-split.html')
685             self.handle_page('genindex-all', genindexcontext,
686                              'genindex.html')
687             for (key, entries), count in zip(genindex, indexcounts):
688                 ctx = {'key': key, 'entries': entries, 'count': count,
689                        'genindexentries': genindex}
690                 self.handle_page('genindex-' + key, ctx,
691                                  'genindex-single.html')
692         else:
693             self.handle_page('genindex', genindexcontext, 'genindex.html')
694 
695     def write_domain_indices(self) -> None:
696         for indexname, indexcls, content, collapse in self.domain_indices:
697             indexcontext = {
698                 'indextitle': indexcls.localname,
699                 'content': content,
700                 'collapse_index': collapse,
701             }
702             logger.info(indexname + ' ', nonl=True)
703             self.handle_page(indexname, indexcontext, 'domainindex.html')
704 
705     def copy_image_files(self) -> None:
706         if self.images:
707             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
708             ensuredir(path.join(self.outdir, self.imagedir))
709             for src in status_iterator(self.images, __('copying images... '), "brown",
710                                        len(self.images), self.app.verbosity,
711                                        stringify_func=stringify_func):
712                 dest = self.images[src]
713                 try:
714                     copyfile(path.join(self.srcdir, src),
715                              path.join(self.outdir, self.imagedir, dest))
716                 except Exception as err:
717                     logger.warning(__('cannot copy image file %r: %s'),
718                                    path.join(self.srcdir, src), err)
719 
720     def copy_download_files(self) -> None:
721         def to_relpath(f: str) -> str:
722             return relative_path(self.srcdir, f)
723 
724         # copy downloadable files
725         if self.env.dlfiles:
726             ensuredir(path.join(self.outdir, '_downloads'))
727             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),
728                                        "brown", len(self.env.dlfiles), self.app.verbosity,
729                                        stringify_func=to_relpath):
730                 try:
731                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])
732                     ensuredir(path.dirname(dest))
733                     copyfile(path.join(self.srcdir, src), dest)
734                 except OSError as err:
735                     logger.warning(__('cannot copy downloadable file %r: %s'),
736                                    path.join(self.srcdir, src), err)
737 
738     def create_pygments_style_file(self) -> None:
739         """create a style file for pygments."""
740         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:
741             f.write(self.highlighter.get_stylesheet())
742 
743         if self.dark_highlighter:
744             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:
745                 f.write(self.dark_highlighter.get_stylesheet())
746 
747     def copy_translation_js(self) -> None:
748         """Copy a JavaScript file for translations."""
749         if self.config.language is not None:
750             jsfile = self._get_translations_js()
751             if jsfile:
752                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))
753 
754     def copy_stemmer_js(self) -> None:
755         """Copy a JavaScript file for stemmer."""
756         if self.indexer is not None:
757             jsfile = self.indexer.get_js_stemmer_rawcode()
758             if jsfile:
759                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))
760 
761     def copy_theme_static_files(self, context: Dict) -> None:
762         def onerror(filename: str, error: Exception) -> None:
763             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
764                            filename, error)
765 
766         if self.theme:
767             for entry in self.theme.get_theme_dirs()[::-1]:
768                 copy_asset(path.join(entry, 'static'),
769                            path.join(self.outdir, '_static'),
770                            excluded=DOTFILES, context=context,
771                            renderer=self.templates, onerror=onerror)
772 
773     def copy_html_static_files(self, context: Dict) -> None:
774         def onerror(filename: str, error: Exception) -> None:
775             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
776                            filename, error)
777 
778         excluded = Matcher(self.config.exclude_patterns + ["**/.*"])
779         for entry in self.config.html_static_path:
780             copy_asset(path.join(self.confdir, entry),
781                        path.join(self.outdir, '_static'),
782                        excluded, context=context, renderer=self.templates, onerror=onerror)
783 
784     def copy_html_logo(self) -> None:
785         if self.config.html_logo:
786             copy_asset(path.join(self.confdir, self.config.html_logo),
787                        path.join(self.outdir, '_static'))
788 
789     def copy_html_favicon(self) -> None:
790         if self.config.html_favicon:
791             copy_asset(path.join(self.confdir, self.config.html_favicon),
792                        path.join(self.outdir, '_static'))
793 
794     def copy_static_files(self) -> None:
795         try:
796             with progress_message(__('copying static files')):
797                 ensuredir(path.join(self.outdir, '_static'))
798 
799                 # prepare context for templates
800                 context = self.globalcontext.copy()
801                 if self.indexer is not None:
802                     context.update(self.indexer.context_for_searchtool())
803 
804                 self.create_pygments_style_file()
805                 self.copy_translation_js()
806                 self.copy_stemmer_js()
807                 self.copy_theme_static_files(context)
808                 self.copy_html_static_files(context)
809                 self.copy_html_logo()
810                 self.copy_html_favicon()
811         except OSError as err:
812             logger.warning(__('cannot copy static file %r'), err)
813 
814     def copy_extra_files(self) -> None:
815         """copy html_extra_path files."""
816         try:
817             with progress_message(__('copying extra files')):
818                 excluded = Matcher(self.config.exclude_patterns)
819                 for extra_path in self.config.html_extra_path:
820                     entry = path.join(self.confdir, extra_path)
821                     copy_asset(entry, self.outdir, excluded)
822         except OSError as err:
823             logger.warning(__('cannot copy extra file %r'), err)
824 
825     def write_buildinfo(self) -> None:
826         try:
827             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:
828                 self.build_info.dump(fp)
829         except OSError as exc:
830             logger.warning(__('Failed to write build info file: %r'), exc)
831 
832     def cleanup(self) -> None:
833         # clean up theme stuff
834         if self.theme:
835             self.theme.cleanup()
836 
837     def post_process_images(self, doctree: Node) -> None:
838         """Pick the best candidate for an image and link down-scaled images to
839         their high res version.
840         """
841         Builder.post_process_images(self, doctree)
842 
843         if self.config.html_scaled_image_link and self.html_scaled_image_link:
844             for node in doctree.traverse(nodes.image):
845                 if not any((key in node) for key in ['scale', 'width', 'height']):
846                     # resizing options are not given. scaled image link is available
847                     # only for resized images.
848                     continue
849                 elif isinstance(node.parent, nodes.reference):
850                     # A image having hyperlink target
851                     continue
852                 elif 'no-scaled-link' in node['classes']:
853                     # scaled image link is disabled for this node
854                     continue
855 
856                 uri = node['uri']
857                 reference = nodes.reference('', '', internal=True)
858                 if uri in self.images:
859                     reference['refuri'] = posixpath.join(self.imgpath,
860                                                          self.images[uri])
861                 else:
862                     reference['refuri'] = uri
863                 node.replace_self(reference)
864                 reference.append(node)
865 
866     def load_indexer(self, docnames: Iterable[str]) -> None:
867         keep = set(self.env.all_docs) - set(docnames)
868         try:
869             searchindexfn = path.join(self.outdir, self.searchindex_filename)
870             if self.indexer_dumps_unicode:
871                 with open(searchindexfn, encoding='utf-8') as ft:
872                     self.indexer.load(ft, self.indexer_format)
873             else:
874                 with open(searchindexfn, 'rb') as fb:
875                     self.indexer.load(fb, self.indexer_format)
876         except (OSError, ValueError):
877             if keep:
878                 logger.warning(__('search index couldn\'t be loaded, but not all '
879                                   'documents will be built: the index will be '
880                                   'incomplete.'))
881         # delete all entries for files that will be rebuilt
882         self.indexer.prune(keep)
883 
884     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:
885         # only index pages with title
886         if self.indexer is not None and title:
887             filename = self.env.doc2path(pagename, base=None)
888             try:
889                 metadata = self.env.metadata.get(pagename, {})
890                 if 'nosearch' in metadata:
891                     self.indexer.feed(pagename, filename, '', new_document(''))
892                 else:
893                     self.indexer.feed(pagename, filename, title, doctree)
894             except TypeError:
895                 # fallback for old search-adapters
896                 self.indexer.feed(pagename, title, doctree)  # type: ignore
897                 indexer_name = self.indexer.__class__.__name__
898                 warnings.warn(
899                     'The %s.feed() method signature is deprecated. Update to '
900                     '%s.feed(docname, filename, title, doctree).' % (
901                         indexer_name, indexer_name),
902                     RemovedInSphinx40Warning, stacklevel=2)
903 
904     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:
905         if 'includehidden' not in kwargs:
906             kwargs['includehidden'] = False
907         if kwargs.get('maxdepth') == '':
908             kwargs.pop('maxdepth')
909         return self.render_partial(TocTree(self.env).get_toctree_for(
910             docname, self, collapse, **kwargs))['fragment']
911 
912     def get_outfilename(self, pagename: str) -> str:
913         return path.join(self.outdir, os_path(pagename) + self.out_suffix)
914 
915     def add_sidebars(self, pagename: str, ctx: Dict) -> None:
916         def has_wildcard(pattern: str) -> bool:
917             return any(char in pattern for char in '*?[')
918 
919         sidebars = None
920         matched = None
921         customsidebar = None
922 
923         # default sidebars settings for selected theme
924         if self.theme.name == 'alabaster':
925             # provide default settings for alabaster (for compatibility)
926             # Note: this will be removed before Sphinx-2.0
927             try:
928                 # get default sidebars settings from alabaster (if defined)
929                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')
930                 if theme_default_sidebars:
931                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
932             except Exception:
933                 # fallback to better default settings
934                 sidebars = ['about.html', 'navigation.html', 'relations.html',
935                             'searchbox.html', 'donate.html']
936         else:
937             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)
938             if theme_default_sidebars:
939                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
940 
941         # user sidebar settings
942         html_sidebars = self.get_builder_config('sidebars', 'html')
943         for pattern, patsidebars in html_sidebars.items():
944             if patmatch(pagename, pattern):
945                 if matched:
946                     if has_wildcard(pattern):
947                         # warn if both patterns contain wildcards
948                         if has_wildcard(matched):
949                             logger.warning(__('page %s matches two patterns in '
950                                               'html_sidebars: %r and %r'),
951                                            pagename, matched, pattern)
952                         # else the already matched pattern is more specific
953                         # than the present one, because it contains no wildcard
954                         continue
955                 matched = pattern
956                 sidebars = patsidebars
957 
958         if sidebars is None:
959             # keep defaults
960             pass
961 
962         ctx['sidebars'] = sidebars
963         ctx['customsidebar'] = customsidebar
964 
965     # --------- these are overwritten by the serialization builder
966 
967     def get_target_uri(self, docname: str, typ: str = None) -> str:
968         return quote(docname) + self.link_suffix
969 
970     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',
971                     outfilename: str = None, event_arg: Any = None) -> None:
972         ctx = self.globalcontext.copy()
973         # current_page_name is backwards compatibility
974         ctx['pagename'] = ctx['current_page_name'] = pagename
975         ctx['encoding'] = self.config.html_output_encoding
976         default_baseuri = self.get_target_uri(pagename)
977         # in the singlehtml builder, default_baseuri still contains an #anchor
978         # part, which relative_uri doesn't really like...
979         default_baseuri = default_baseuri.rsplit('#', 1)[0]
980 
981         if self.config.html_baseurl:
982             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,
983                                             pagename + self.out_suffix)
984         else:
985             ctx['pageurl'] = None
986 
987         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA
988             if resource and '://' in otheruri:
989                 # allow non-local resources given by scheme
990                 return otheruri
991             elif not resource:
992                 otheruri = self.get_target_uri(otheruri)
993             uri = relative_uri(baseuri, otheruri) or '#'
994             if uri == '#' and not self.allow_sharp_as_current_path:
995                 uri = baseuri
996             return uri
997         ctx['pathto'] = pathto
998 
999         def css_tag(css: Stylesheet) -> str:
1000             attrs = []
1001             for key in sorted(css.attributes):
1002                 value = css.attributes[key]
1003                 if value is not None:
1004                     attrs.append('%s="%s"' % (key, html.escape(value, True)))
1005             attrs.append('href="%s"' % pathto(css.filename, resource=True))
1006             return '<link %s />' % ' '.join(attrs)
1007         ctx['css_tag'] = css_tag
1008 
1009         def hasdoc(name: str) -> bool:
1010             if name in self.env.all_docs:
1011                 return True
1012             elif name == 'search' and self.search:
1013                 return True
1014             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):
1015                 return True
1016             return False
1017         ctx['hasdoc'] = hasdoc
1018 
1019         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)
1020         self.add_sidebars(pagename, ctx)
1021         ctx.update(addctx)
1022 
1023         # revert script_files and css_files
1024         self.script_files[:] = self._script_files
1025         self.css_files[:] = self.css_files
1026 
1027         self.update_page_context(pagename, templatename, ctx, event_arg)
1028         newtmpl = self.app.emit_firstresult('html-page-context', pagename,
1029                                             templatename, ctx, event_arg)
1030         if newtmpl:
1031             templatename = newtmpl
1032 
1033         # sort JS/CSS before rendering HTML
1034         ctx['script_files'].sort(key=lambda js: js.priority)
1035         ctx['css_files'].sort(key=lambda js: js.priority)
1036 
1037         try:
1038             output = self.templates.render(templatename, ctx)
1039         except UnicodeError:
1040             logger.warning(__("a Unicode error occurred when rendering the page %s. "
1041                               "Please make sure all config values that contain "
1042                               "non-ASCII content are Unicode strings."), pagename)
1043             return
1044         except Exception as exc:
1045             raise ThemeError(__("An error happened in rendering the page %s.\nReason: %r") %
1046                              (pagename, exc)) from exc
1047 
1048         if not outfilename:
1049             outfilename = self.get_outfilename(pagename)
1050         # outfilename's path is in general different from self.outdir
1051         ensuredir(path.dirname(outfilename))
1052         try:
1053             with open(outfilename, 'w', encoding=ctx['encoding'],
1054                       errors='xmlcharrefreplace') as f:
1055                 f.write(output)
1056         except OSError as err:
1057             logger.warning(__("error writing file %s: %s"), outfilename, err)
1058         if self.copysource and ctx.get('sourcename'):
1059             # copy the source file for the "show source" link
1060             source_name = path.join(self.outdir, '_sources',
1061                                     os_path(ctx['sourcename']))
1062             ensuredir(path.dirname(source_name))
1063             copyfile(self.env.doc2path(pagename), source_name)
1064 
1065     def update_page_context(self, pagename: str, templatename: str,
1066                             ctx: Dict, event_arg: Any) -> None:
1067         pass
1068 
1069     def handle_finish(self) -> None:
1070         if self.indexer:
1071             self.finish_tasks.add_task(self.dump_search_index)
1072         self.finish_tasks.add_task(self.dump_inventory)
1073 
1074     @progress_message(__('dumping object inventory'))
1075     def dump_inventory(self) -> None:
1076         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)
1077 
1078     def dump_search_index(self) -> None:
1079         with progress_message(__('dumping search index in %s') % self.indexer.label()):
1080             self.indexer.prune(self.env.all_docs)
1081             searchindexfn = path.join(self.outdir, self.searchindex_filename)
1082             # first write to a temporary file, so that if dumping fails,
1083             # the existing index won't be overwritten
1084             if self.indexer_dumps_unicode:
1085                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:
1086                     self.indexer.dump(ft, self.indexer_format)
1087             else:
1088                 with open(searchindexfn + '.tmp', 'wb') as fb:
1089                     self.indexer.dump(fb, self.indexer_format)
1090             os.replace(searchindexfn + '.tmp', searchindexfn)
1091 
1092 
1093 def convert_html_css_files(app: Sphinx, config: Config) -> None:
1094     """This converts string styled html_css_files to tuple styled one."""
1095     html_css_files = []  # type: List[Tuple[str, Dict]]
1096     for entry in config.html_css_files:
1097         if isinstance(entry, str):
1098             html_css_files.append((entry, {}))
1099         else:
1100             try:
1101                 filename, attrs = entry
1102                 html_css_files.append((filename, attrs))
1103             except Exception:
1104                 logger.warning(__('invalid css_file: %r, ignored'), entry)
1105                 continue
1106 
1107     config.html_css_files = html_css_files  # type: ignore
1108 
1109 
1110 def convert_html_js_files(app: Sphinx, config: Config) -> None:
1111     """This converts string styled html_js_files to tuple styled one."""
1112     html_js_files = []  # type: List[Tuple[str, Dict]]
1113     for entry in config.html_js_files:
1114         if isinstance(entry, str):
1115             html_js_files.append((entry, {}))
1116         else:
1117             try:
1118                 filename, attrs = entry
1119                 html_js_files.append((filename, attrs))
1120             except Exception:
1121                 logger.warning(__('invalid js_file: %r, ignored'), entry)
1122                 continue
1123 
1124     config.html_js_files = html_js_files  # type: ignore
1125 
1126 
1127 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,
1128                         context: Dict, doctree: Node) -> None:
1129     """Set up js_tag() template helper.
1130 
1131     .. note:: This set up function is added to keep compatibility with webhelper.
1132     """
1133     pathto = context.get('pathto')
1134 
1135     def js_tag(js: JavaScript) -> str:
1136         attrs = []
1137         body = ''
1138         if isinstance(js, JavaScript):
1139             for key in sorted(js.attributes):
1140                 value = js.attributes[key]
1141                 if value is not None:
1142                     if key == 'body':
1143                         body = value
1144                     else:
1145                         attrs.append('%s="%s"' % (key, html.escape(value, True)))
1146             if js.filename:
1147                 attrs.append('src="%s"' % pathto(js.filename, resource=True))
1148         else:
1149             # str value (old styled)
1150             attrs.append('src="%s"' % pathto(js, resource=True))
1151         return '<script %s>%s</script>' % (' '.join(attrs), body)
1152 
1153     context['js_tag'] = js_tag
1154 
1155 
1156 def validate_math_renderer(app: Sphinx) -> None:
1157     if app.builder.format != 'html':
1158         return
1159 
1160     name = app.builder.math_renderer_name  # type: ignore
1161     if name is None:
1162         raise ConfigError(__('Many math_renderers are registered. '
1163                              'But no math_renderer is selected.'))
1164     elif name not in app.registry.html_inline_math_renderers:
1165         raise ConfigError(__('Unknown math_renderer %r is given.') % name)
1166 
1167 
1168 def validate_html_extra_path(app: Sphinx, config: Config) -> None:
1169     """Check html_extra_paths setting."""
1170     for entry in config.html_extra_path[:]:
1171         extra_path = path.normpath(path.join(app.confdir, entry))
1172         if not path.exists(extra_path):
1173             logger.warning(__('html_extra_path entry %r does not exist'), entry)
1174             config.html_extra_path.remove(entry)
1175         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and
1176               path.commonpath([app.outdir, extra_path]) == app.outdir):
1177             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)
1178             config.html_extra_path.remove(entry)
1179 
1180 
1181 def validate_html_static_path(app: Sphinx, config: Config) -> None:
1182     """Check html_static_paths setting."""
1183     for entry in config.html_static_path[:]:
1184         static_path = path.normpath(path.join(app.confdir, entry))
1185         if not path.exists(static_path):
1186             logger.warning(__('html_static_path entry %r does not exist'), entry)
1187             config.html_static_path.remove(entry)
1188         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and
1189               path.commonpath([app.outdir, static_path]) == app.outdir):
1190             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)
1191             config.html_static_path.remove(entry)
1192 
1193 
1194 def validate_html_logo(app: Sphinx, config: Config) -> None:
1195     """Check html_logo setting."""
1196     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):
1197         logger.warning(__('logo file %r does not exist'), config.html_logo)
1198         config.html_logo = None  # type: ignore
1199 
1200 
1201 def validate_html_favicon(app: Sphinx, config: Config) -> None:
1202     """Check html_favicon setting."""
1203     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):
1204         logger.warning(__('favicon file %r does not exist'), config.html_favicon)
1205         config.html_favicon = None  # type: ignore
1206 
1207 
1208 # for compatibility
1209 import sphinxcontrib.serializinghtml  # NOQA
1210 
1211 import sphinx.builders.dirhtml  # NOQA
1212 import sphinx.builders.singlehtml  # NOQA
1213 
1214 
1215 def setup(app: Sphinx) -> Dict[str, Any]:
1216     # builders
1217     app.add_builder(StandaloneHTMLBuilder)
1218 
1219     # config values
1220     app.add_config_value('html_theme', 'alabaster', 'html')
1221     app.add_config_value('html_theme_path', [], 'html')
1222     app.add_config_value('html_theme_options', {}, 'html')
1223     app.add_config_value('html_title',
1224                          lambda self: _('%s %s documentation') % (self.project, self.release),
1225                          'html', [str])
1226     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')
1227     app.add_config_value('html_style', None, 'html', [str])
1228     app.add_config_value('html_logo', None, 'html', [str])
1229     app.add_config_value('html_favicon', None, 'html', [str])
1230     app.add_config_value('html_css_files', [], 'html')
1231     app.add_config_value('html_js_files', [], 'html')
1232     app.add_config_value('html_static_path', [], 'html')
1233     app.add_config_value('html_extra_path', [], 'html')
1234     app.add_config_value('html_last_updated_fmt', None, 'html', [str])
1235     app.add_config_value('html_sidebars', {}, 'html')
1236     app.add_config_value('html_additional_pages', {}, 'html')
1237     app.add_config_value('html_domain_indices', True, 'html', [list])
1238     app.add_config_value('html_add_permalinks', '¶', 'html')
1239     app.add_config_value('html_use_index', True, 'html')
1240     app.add_config_value('html_split_index', False, 'html')
1241     app.add_config_value('html_copy_source', True, 'html')
1242     app.add_config_value('html_show_sourcelink', True, 'html')
1243     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')
1244     app.add_config_value('html_use_opensearch', '', 'html')
1245     app.add_config_value('html_file_suffix', None, 'html', [str])
1246     app.add_config_value('html_link_suffix', None, 'html', [str])
1247     app.add_config_value('html_show_copyright', True, 'html')
1248     app.add_config_value('html_show_sphinx', True, 'html')
1249     app.add_config_value('html_context', {}, 'html')
1250     app.add_config_value('html_output_encoding', 'utf-8', 'html')
1251     app.add_config_value('html_compact_lists', True, 'html')
1252     app.add_config_value('html_secnumber_suffix', '. ', 'html')
1253     app.add_config_value('html_search_language', None, 'html', [str])
1254     app.add_config_value('html_search_options', {}, 'html')
1255     app.add_config_value('html_search_scorer', '', None)
1256     app.add_config_value('html_scaled_image_link', True, 'html')
1257     app.add_config_value('html_baseurl', '', 'html')
1258     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',
1259                          ENUM('table', 'inline'))
1260     app.add_config_value('html_math_renderer', None, 'env')
1261     app.add_config_value('html4_writer', False, 'html')
1262 
1263     # events
1264     app.add_event('html-collect-pages')
1265     app.add_event('html-page-context')
1266 
1267     # event handlers
1268     app.connect('config-inited', convert_html_css_files, priority=800)
1269     app.connect('config-inited', convert_html_js_files, priority=800)
1270     app.connect('config-inited', validate_html_extra_path, priority=800)
1271     app.connect('config-inited', validate_html_static_path, priority=800)
1272     app.connect('config-inited', validate_html_logo, priority=800)
1273     app.connect('config-inited', validate_html_favicon, priority=800)
1274     app.connect('builder-inited', validate_math_renderer)
1275     app.connect('html-page-context', setup_js_tag_helper)
1276 
1277     # load default math renderer
1278     app.setup_extension('sphinx.ext.mathjax')
1279 
1280     # load transforms for HTML builder
1281     app.setup_extension('sphinx.builders.html.transforms')
1282 
1283     return {
1284         'version': 'builtin',
1285         'parallel_read_safe': True,
1286         'parallel_write_safe': True,
1287     }

</code><intended_behavior>This file should include or be modified to ensure that when handling file paths for resources like downloads or figures, all path references are normalized using os.path.normpath() (or a Sphinx equivalent function if it wraps path operations for cross-platform compatibility). Additionally, before treating any file as a duplicate, the code should verify whether the normalized paths actually point to the different resources. This process will prevent the issue where the same file is interpreted as multiple files when referenced in various ways.</intended_behavior>, <file>sphinx/environment/collectors/dependencies.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.collectors.dependencies
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     The dependencies collector components for sphinx.environment.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import os
12 from os import path
13 from typing import Any, Dict, Set
14 
15 from docutils import nodes
16 from docutils.utils import relative_path
17 
18 from sphinx.application import Sphinx
19 from sphinx.environment import BuildEnvironment
20 from sphinx.environment.collectors import EnvironmentCollector
21 from sphinx.util.osutil import fs_encoding
22 
23 
24 class DependenciesCollector(EnvironmentCollector):
25     """dependencies collector for sphinx.environment."""
26 
27     def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -> None:
28         env.dependencies.pop(docname, None)
29 
30     def merge_other(self, app: Sphinx, env: BuildEnvironment,
31                     docnames: Set[str], other: BuildEnvironment) -> None:
32         for docname in docnames:
33             if docname in other.dependencies:
34                 env.dependencies[docname] = other.dependencies[docname]
35 
36     def process_doc(self, app: Sphinx, doctree: nodes.document) -> None:
37         """Process docutils-generated dependency info."""
38         cwd = os.getcwd()
39         frompath = path.join(path.normpath(app.srcdir), 'dummy')
40         deps = doctree.settings.record_dependencies
41         if not deps:
42             return
43         for dep in deps.list:
44             # the dependency path is relative to the working dir, so get
45             # one relative to the srcdir
46             if isinstance(dep, bytes):
47                 dep = dep.decode(fs_encoding)
48             relpath = relative_path(frompath,
49                                     path.normpath(path.join(cwd, dep)))
50             app.env.dependencies[app.env.docname].add(relpath)
51 
52 
53 def setup(app: Sphinx) -> Dict[str, Any]:
54     app.add_env_collector(DependenciesCollector)
55 
56     return {
57         'version': 'builtin',
58         'parallel_read_safe': True,
59         'parallel_write_safe': True,
60     }

</code><intended_behavior>This file, likely involved in tracking and managing file dependencies within the Sphinx build environment, should be modified to ensure that any comparisons or operations on file paths are conducted on normalized paths. This will aid in accurately tracking file dependencies and usage without falsely identifying the same file as multiple ones due to path differences.</intended_behavior>]
2025-10-18 18:42:02.413 | INFO     | Search completed. Bug locations: [<file>sphinx/builders/html/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.builders.html
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Several HTML builders.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import html
12 import os
13 import posixpath
14 import re
15 import sys
16 import warnings
17 from os import path
18 from typing import IO, Any, Dict, Iterable, Iterator, List, Set, Tuple
19 from urllib.parse import quote
20 
21 from docutils import nodes
22 from docutils.core import publish_parts
23 from docutils.frontend import OptionParser
24 from docutils.io import DocTreeInput, StringOutput
25 from docutils.nodes import Node
26 from docutils.utils import relative_path
27 
28 from sphinx import __display_version__, package_dir
29 from sphinx.application import Sphinx
30 from sphinx.builders import Builder
31 from sphinx.config import ENUM, Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index, IndexEntry
34 from sphinx.environment.adapters.asset import ImageAdapter
35 from sphinx.environment.adapters.indexentries import IndexEntries
36 from sphinx.environment.adapters.toctree import TocTree
37 from sphinx.errors import ConfigError, ThemeError
38 from sphinx.highlighting import PygmentsBridge
39 from sphinx.locale import _, __
40 from sphinx.search import js_index
41 from sphinx.theming import HTMLThemeFactory
42 from sphinx.util import logging, md5, progress_message, status_iterator
43 from sphinx.util.docutils import is_html5_writer_available, new_document
44 from sphinx.util.fileutil import copy_asset
45 from sphinx.util.i18n import format_date
46 from sphinx.util.inventory import InventoryFile
47 from sphinx.util.matching import DOTFILES, Matcher, patmatch
48 from sphinx.util.osutil import copyfile, ensuredir, os_path, relative_uri
49 from sphinx.util.tags import Tags
50 from sphinx.writers.html import HTMLTranslator, HTMLWriter
51 
52 if False:
53     # For type annotation
54     from typing import Type  # for python3.5.1
55 
56 
57 # HTML5 Writer is available or not
58 if is_html5_writer_available():
59     from sphinx.writers.html5 import HTML5Translator
60     html5_ready = True
61 else:
62     html5_ready = False
63 
64 #: the filename for the inventory of objects
65 INVENTORY_FILENAME = 'objects.inv'
66 
67 logger = logging.getLogger(__name__)
68 return_codes_re = re.compile('[\r\n]+')
69 
70 
71 def get_stable_hash(obj: Any) -> str:
72     """
73     Return a stable hash for a Python data structure.  We can't just use
74     the md5 of str(obj) since for example dictionary items are enumerated
75     in unpredictable order due to hash randomization in newer Pythons.
76     """
77     if isinstance(obj, dict):
78         return get_stable_hash(list(obj.items()))
79     elif isinstance(obj, (list, tuple)):
80         obj = sorted(get_stable_hash(o) for o in obj)
81     return md5(str(obj).encode()).hexdigest()
82 
83 
84 class Stylesheet(str):
85     """A metadata of stylesheet.
86 
87     To keep compatibility with old themes, an instance of stylesheet behaves as
88     its filename (str).
89     """
90 
91     attributes = None   # type: Dict[str, str]
92     filename = None     # type: str
93     priority = None     # type: int
94 
95     def __new__(cls, filename: str, *args: str, priority: int = 500, **attributes: Any
96                 ) -> "Stylesheet":
97         self = str.__new__(cls, filename)  # type: ignore
98         self.filename = filename
99         self.priority = priority
100         self.attributes = attributes
101         self.attributes.setdefault('rel', 'stylesheet')
102         self.attributes.setdefault('type', 'text/css')
103         if args:  # old style arguments (rel, title)
104             self.attributes['rel'] = args[0]
105             self.attributes['title'] = args[1]
106 
107         return self
108 
109 
110 class JavaScript(str):
111     """A metadata of javascript file.
112 
113     To keep compatibility with old themes, an instance of javascript behaves as
114     its filename (str).
115     """
116 
117     attributes = None   # type: Dict[str, str]
118     filename = None     # type: str
119     priority = None     # type: int
120 
121     def __new__(cls, filename: str, priority: int = 500, **attributes: str) -> "JavaScript":
122         self = str.__new__(cls, filename)  # type: ignore
123         self.filename = filename
124         self.priority = priority
125         self.attributes = attributes
126 
127         return self
128 
129 
130 class BuildInfo:
131     """buildinfo file manipulator.
132 
133     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.
134     This class is a manipulator for the file.
135     """
136 
137     @classmethod
138     def load(cls, f: IO) -> "BuildInfo":
139         try:
140             lines = f.readlines()
141             assert lines[0].rstrip() == '# Sphinx build info version 1'
142             assert lines[2].startswith('config: ')
143             assert lines[3].startswith('tags: ')
144 
145             build_info = BuildInfo()
146             build_info.config_hash = lines[2].split()[1].strip()
147             build_info.tags_hash = lines[3].split()[1].strip()
148             return build_info
149         except Exception as exc:
150             raise ValueError(__('build info file is broken: %r') % exc) from exc
151 
152     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA
153         self.config_hash = ''
154         self.tags_hash = ''
155 
156         if config:
157             values = {c.name: c.value for c in config.filter(config_categories)}
158             self.config_hash = get_stable_hash(values)
159 
160         if tags:
161             self.tags_hash = get_stable_hash(sorted(tags))
162 
163     def __eq__(self, other: "BuildInfo") -> bool:  # type: ignore
164         return (self.config_hash == other.config_hash and
165                 self.tags_hash == other.tags_hash)
166 
167     def dump(self, f: IO) -> None:
168         f.write('# Sphinx build info version 1\n'
169                 '# This file hashes the configuration used when building these files.'
170                 ' When it is not found, a full rebuild will be done.\n'
171                 'config: %s\n'
172                 'tags: %s\n' %
173                 (self.config_hash, self.tags_hash))
174 
175 
176 class StandaloneHTMLBuilder(Builder):
177     """
178     Builds standalone HTML docs.
179     """
180     name = 'html'
181     format = 'html'
182     epilog = __('The HTML pages are in %(outdir)s.')
183 
184     copysource = True
185     allow_parallel = True
186     out_suffix = '.html'
187     link_suffix = '.html'  # defaults to matching out_suffix
188     indexer_format = js_index  # type: Any
189     indexer_dumps_unicode = True
190     # create links to original images from images [True/False]
191     html_scaled_image_link = True
192     supported_image_types = ['image/svg+xml', 'image/png',
193                              'image/gif', 'image/jpeg']
194     supported_remote_images = True
195     supported_data_uri_images = True
196     searchindex_filename = 'searchindex.js'
197     add_permalinks = True
198     allow_sharp_as_current_path = True
199     embedded = False  # for things like HTML help or Qt help: suppresses sidebar
200     search = True  # for things like HTML help and Apple help: suppress search
201     use_index = False
202     download_support = True  # enable download role
203 
204     imgpath = None          # type: str
205     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA
206 
207     def __init__(self, app: Sphinx) -> None:
208         super().__init__(app)
209 
210         # CSS files
211         self.css_files = []  # type: List[Dict[str, str]]
212 
213         # JS files
214         self.script_files = []  # type: List[JavaScript]
215 
216     def init(self) -> None:
217         self.build_info = self.create_build_info()
218         # basename of images directory
219         self.imagedir = '_images'
220         # section numbers for headings in the currently visited document
221         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]
222         # currently written docname
223         self.current_docname = None  # type: str
224 
225         self.init_templates()
226         self.init_highlighter()
227         self.init_css_files()
228         self.init_js_files()
229 
230         html_file_suffix = self.get_builder_config('file_suffix', 'html')
231         if html_file_suffix is not None:
232             self.out_suffix = html_file_suffix
233 
234         html_link_suffix = self.get_builder_config('link_suffix', 'html')
235         if html_link_suffix is not None:
236             self.link_suffix = html_link_suffix
237         else:
238             self.link_suffix = self.out_suffix
239 
240         self.use_index = self.get_builder_config('use_index', 'html')
241 
242     def create_build_info(self) -> BuildInfo:
243         return BuildInfo(self.config, self.tags, ['html'])
244 
245     def _get_translations_js(self) -> str:
246         candidates = [path.join(dir, self.config.language,
247                                 'LC_MESSAGES', 'sphinx.js')
248                       for dir in self.config.locale_dirs] + \
249                      [path.join(package_dir, 'locale', self.config.language,
250                                 'LC_MESSAGES', 'sphinx.js'),
251                       path.join(sys.prefix, 'share/sphinx/locale',
252                                 self.config.language, 'sphinx.js')]
253 
254         for jsfile in candidates:
255             if path.isfile(jsfile):
256                 return jsfile
257         return None
258 
259     def get_theme_config(self) -> Tuple[str, Dict]:
260         return self.config.html_theme, self.config.html_theme_options
261 
262     def init_templates(self) -> None:
263         theme_factory = HTMLThemeFactory(self.app)
264         themename, themeoptions = self.get_theme_config()
265         self.theme = theme_factory.create(themename)
266         self.theme_options = themeoptions.copy()
267         self.create_template_bridge()
268         self.templates.init(self, self.theme)
269 
270     def init_highlighter(self) -> None:
271         # determine Pygments style and create the highlighter
272         if self.config.pygments_style is not None:
273             style = self.config.pygments_style
274         elif self.theme:
275             style = self.theme.get_config('theme', 'pygments_style', 'none')
276         else:
277             style = 'sphinx'
278         self.highlighter = PygmentsBridge('html', style)
279 
280         if self.theme:
281             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)
282         else:
283             dark_style = None
284 
285         if dark_style is not None:
286             self.dark_highlighter = PygmentsBridge('html', dark_style)
287             self.add_css_file('pygments_dark.css',
288                               media='(prefers-color-scheme: dark)',
289                               id='pygments_dark_css')
290         else:
291             self.dark_highlighter = None
292 
293     def init_css_files(self) -> None:
294         for filename, attrs in self.app.registry.css_files:
295             self.add_css_file(filename, **attrs)
296 
297         for filename, attrs in self.get_builder_config('css_files', 'html'):
298             attrs.setdefault('priority', 800)  # User's CSSs are loaded after extensions'
299             self.add_css_file(filename, **attrs)
300 
301     def add_css_file(self, filename: str, **kwargs: Any) -> None:
302         if '://' not in filename:
303             filename = posixpath.join('_static', filename)
304 
305         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore
306 
307     def init_js_files(self) -> None:
308         self.add_js_file('jquery.js', priority=200)
309         self.add_js_file('underscore.js', priority=200)
310         self.add_js_file('doctools.js', priority=200)
311 
312         for filename, attrs in self.app.registry.js_files:
313             self.add_js_file(filename, **attrs)
314 
315         for filename, attrs in self.get_builder_config('js_files', 'html'):
316             attrs.setdefault('priority', 800)  # User's JSs are loaded after extensions'
317             self.add_js_file(filename, **attrs)
318 
319         if self.config.language and self._get_translations_js():
320             self.add_js_file('translations.js')
321 
322     def add_js_file(self, filename: str, **kwargs: Any) -> None:
323         if filename and '://' not in filename:
324             filename = posixpath.join('_static', filename)
325 
326         self.script_files.append(JavaScript(filename, **kwargs))
327 
328     @property
329     def default_translator_class(self) -> "Type[nodes.NodeVisitor]":  # type: ignore
330         if not html5_ready or self.config.html4_writer:
331             return HTMLTranslator
332         else:
333             return HTML5Translator
334 
335     @property
336     def math_renderer_name(self) -> str:
337         name = self.get_builder_config('math_renderer', 'html')
338         if name is not None:
339             # use given name
340             return name
341         else:
342             # not given: choose a math_renderer from registered ones as possible
343             renderers = list(self.app.registry.html_inline_math_renderers)
344             if len(renderers) == 1:
345                 # only default math_renderer (mathjax) is registered
346                 return renderers[0]
347             elif len(renderers) == 2:
348                 # default and another math_renderer are registered; prior the another
349                 renderers.remove('mathjax')
350                 return renderers[0]
351             else:
352                 # many math_renderers are registered. can't choose automatically!
353                 return None
354 
355     def get_outdated_docs(self) -> Iterator[str]:
356         try:
357             with open(path.join(self.outdir, '.buildinfo')) as fp:
358                 buildinfo = BuildInfo.load(fp)
359 
360             if self.build_info != buildinfo:
361                 yield from self.env.found_docs
362                 return
363         except ValueError as exc:
364             logger.warning(__('Failed to read build info file: %r'), exc)
365         except OSError:
366             # ignore errors on reading
367             pass
368 
369         if self.templates:
370             template_mtime = self.templates.newest_template_mtime()
371         else:
372             template_mtime = 0
373         for docname in self.env.found_docs:
374             if docname not in self.env.all_docs:
375                 yield docname
376                 continue
377             targetname = self.get_outfilename(docname)
378             try:
379                 targetmtime = path.getmtime(targetname)
380             except Exception:
381                 targetmtime = 0
382             try:
383                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),
384                                template_mtime)
385                 if srcmtime > targetmtime:
386                     yield docname
387             except OSError:
388                 # source doesn't exist anymore
389                 pass
390 
391     def get_asset_paths(self) -> List[str]:
392         return self.config.html_extra_path + self.config.html_static_path
393 
394     def render_partial(self, node: Node) -> Dict[str, str]:
395         """Utility: Render a lone doctree node."""
396         if node is None:
397             return {'fragment': ''}
398         doc = new_document('<partial node>')
399         doc.append(node)
400 
401         writer = HTMLWriter(self)
402         return publish_parts(reader_name='doctree',
403                              writer=writer,
404                              source_class=DocTreeInput,
405                              settings_overrides={'output_encoding': 'unicode'},
406                              source=doc)
407 
408     def prepare_writing(self, docnames: Set[str]) -> None:
409         # create the search indexer
410         self.indexer = None
411         if self.search:
412             from sphinx.search import IndexBuilder
413             lang = self.config.html_search_language or self.config.language
414             if not lang:
415                 lang = 'en'
416             self.indexer = IndexBuilder(self.env, lang,
417                                         self.config.html_search_options,
418                                         self.config.html_search_scorer)
419             self.load_indexer(docnames)
420 
421         self.docwriter = HTMLWriter(self)
422         self.docsettings = OptionParser(
423             defaults=self.env.settings,
424             components=(self.docwriter,),
425             read_config_files=True).get_default_values()  # type: Any
426         self.docsettings.compact_lists = bool(self.config.html_compact_lists)
427 
428         # determine the additional indices to include
429         self.domain_indices = []
430         # html_domain_indices can be False/True or a list of index names
431         indices_config = self.config.html_domain_indices
432         if indices_config:
433             for domain_name in sorted(self.env.domains):
434                 domain = None  # type: Domain
435                 domain = self.env.domains[domain_name]
436                 for indexcls in domain.indices:
437                     indexname = '%s-%s' % (domain.name, indexcls.name)
438                     if isinstance(indices_config, list):
439                         if indexname not in indices_config:
440                             continue
441                     content, collapse = indexcls(domain).generate()
442                     if content:
443                         self.domain_indices.append(
444                             (indexname, indexcls, content, collapse))
445 
446         # format the "last updated on" string, only once is enough since it
447         # typically doesn't include the time of day
448         lufmt = self.config.html_last_updated_fmt
449         if lufmt is not None:
450             self.last_updated = format_date(lufmt or _('%b %d, %Y'),
451                                             language=self.config.language)
452         else:
453             self.last_updated = None
454 
455         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''
456         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''
457 
458         self.relations = self.env.collect_relations()
459 
460         rellinks = []  # type: List[Tuple[str, str, str, str]]
461         if self.use_index:
462             rellinks.append(('genindex', _('General Index'), 'I', _('index')))
463         for indexname, indexcls, content, collapse in self.domain_indices:
464             # if it has a short name
465             if indexcls.shortname:
466                 rellinks.append((indexname, indexcls.localname,
467                                  '', indexcls.shortname))
468 
469         # back up script_files and css_files to allow adding JS/CSS files to a specific page.
470         self._script_files = list(self.script_files)
471         self._css_files = list(self.css_files)
472 
473         if self.config.html_style is not None:
474             stylename = self.config.html_style
475         elif self.theme:
476             stylename = self.theme.get_config('theme', 'stylesheet')
477         else:
478             stylename = 'default.css'
479 
480         self.globalcontext = {
481             'embedded': self.embedded,
482             'project': self.config.project,
483             'release': return_codes_re.sub('', self.config.release),
484             'version': self.config.version,
485             'last_updated': self.last_updated,
486             'copyright': self.config.copyright,
487             'master_doc': self.config.master_doc,
488             'use_opensearch': self.config.html_use_opensearch,
489             'docstitle': self.config.html_title,
490             'shorttitle': self.config.html_short_title,
491             'show_copyright': self.config.html_show_copyright,
492             'show_sphinx': self.config.html_show_sphinx,
493             'has_source': self.config.html_copy_source,
494             'show_source': self.config.html_show_sourcelink,
495             'sourcelink_suffix': self.config.html_sourcelink_suffix,
496             'file_suffix': self.out_suffix,
497             'link_suffix': self.link_suffix,
498             'script_files': self.script_files,
499             'language': self.config.language,
500             'css_files': self.css_files,
501             'sphinx_version': __display_version__,
502             'style': stylename,
503             'rellinks': rellinks,
504             'builder': self.name,
505             'parents': [],
506             'logo': logo,
507             'favicon': favicon,
508             'html5_doctype': html5_ready and not self.config.html4_writer,
509         }
510         if self.theme:
511             self.globalcontext.update(
512                 ('theme_' + key, val) for (key, val) in
513                 self.theme.get_options(self.theme_options).items())
514         self.globalcontext.update(self.config.html_context)
515 
516     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:
517         """Collect items for the template context of a page."""
518         # find out relations
519         prev = next = None
520         parents = []
521         rellinks = self.globalcontext['rellinks'][:]
522         related = self.relations.get(docname)
523         titles = self.env.titles
524         if related and related[2]:
525             try:
526                 next = {
527                     'link': self.get_relative_uri(docname, related[2]),
528                     'title': self.render_partial(titles[related[2]])['title']
529                 }
530                 rellinks.append((related[2], next['title'], 'N', _('next')))
531             except KeyError:
532                 next = None
533         if related and related[1]:
534             try:
535                 prev = {
536                     'link': self.get_relative_uri(docname, related[1]),
537                     'title': self.render_partial(titles[related[1]])['title']
538                 }
539                 rellinks.append((related[1], prev['title'], 'P', _('previous')))
540             except KeyError:
541                 # the relation is (somehow) not in the TOC tree, handle
542                 # that gracefully
543                 prev = None
544         while related and related[0]:
545             try:
546                 parents.append(
547                     {'link': self.get_relative_uri(docname, related[0]),
548                      'title': self.render_partial(titles[related[0]])['title']})
549             except KeyError:
550                 pass
551             related = self.relations.get(related[0])
552         if parents:
553             # remove link to the master file; we have a generic
554             # "back to index" link already
555             parents.pop()
556         parents.reverse()
557 
558         # title rendered as HTML
559         title_node = self.env.longtitles.get(docname)
560         title = self.render_partial(title_node)['title'] if title_node else ''
561 
562         # Suffix for the document
563         source_suffix = self.env.doc2path(docname, False)[len(docname):]
564 
565         # the name for the copied source
566         if self.config.html_copy_source:
567             sourcename = docname + source_suffix
568             if source_suffix != self.config.html_sourcelink_suffix:
569                 sourcename += self.config.html_sourcelink_suffix
570         else:
571             sourcename = ''
572 
573         # metadata for the document
574         meta = self.env.metadata.get(docname)
575 
576         # local TOC and global TOC tree
577         self_toc = TocTree(self.env).get_toc_for(docname, self)
578         toc = self.render_partial(self_toc)['fragment']
579 
580         return {
581             'parents': parents,
582             'prev': prev,
583             'next': next,
584             'title': title,
585             'meta': meta,
586             'body': body,
587             'metatags': metatags,
588             'rellinks': rellinks,
589             'sourcename': sourcename,
590             'toc': toc,
591             # only display a TOC if there's more than one item to show
592             'display_toc': (self.env.toc_num_entries[docname] > 1),
593             'page_source_suffix': source_suffix,
594         }
595 
596     def write_doc(self, docname: str, doctree: nodes.document) -> None:
597         destination = StringOutput(encoding='utf-8')
598         doctree.settings = self.docsettings
599 
600         self.secnumbers = self.env.toc_secnumbers.get(docname, {})
601         self.fignumbers = self.env.toc_fignumbers.get(docname, {})
602         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')
603         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')
604         self.current_docname = docname
605         self.docwriter.write(doctree, destination)
606         self.docwriter.assemble_parts()
607         body = self.docwriter.parts['fragment']
608         metatags = self.docwriter.clean_meta
609 
610         ctx = self.get_doc_context(docname, body, metatags)
611         self.handle_page(docname, ctx, event_arg=doctree)
612 
613     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:
614         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)
615         self.post_process_images(doctree)
616         title_node = self.env.longtitles.get(docname)
617         title = self.render_partial(title_node)['title'] if title_node else ''
618         self.index_page(docname, doctree, title)
619 
620     def finish(self) -> None:
621         self.finish_tasks.add_task(self.gen_indices)
622         self.finish_tasks.add_task(self.gen_pages_from_extensions)
623         self.finish_tasks.add_task(self.gen_additional_pages)
624         self.finish_tasks.add_task(self.copy_image_files)
625         self.finish_tasks.add_task(self.copy_download_files)
626         self.finish_tasks.add_task(self.copy_static_files)
627         self.finish_tasks.add_task(self.copy_extra_files)
628         self.finish_tasks.add_task(self.write_buildinfo)
629 
630         # dump the search index
631         self.handle_finish()
632 
633     @progress_message(__('generating indices'))
634     def gen_indices(self) -> None:
635         # the global general index
636         if self.use_index:
637             self.write_genindex()
638 
639         # the global domain-specific indices
640         self.write_domain_indices()
641 
642     def gen_pages_from_extensions(self) -> None:
643         # pages from extensions
644         for pagelist in self.events.emit('html-collect-pages'):
645             for pagename, context, template in pagelist:
646                 self.handle_page(pagename, context, template)
647 
648     @progress_message(__('writing additional pages'))
649     def gen_additional_pages(self) -> None:
650         # additional pages from conf.py
651         for pagename, template in self.config.html_additional_pages.items():
652             logger.info(pagename + ' ', nonl=True)
653             self.handle_page(pagename, {}, template)
654 
655         # the search page
656         if self.search:
657             logger.info('search ', nonl=True)
658             self.handle_page('search', {}, 'search.html')
659 
660         # the opensearch xml file
661         if self.config.html_use_opensearch and self.search:
662             logger.info('opensearch ', nonl=True)
663             fn = path.join(self.outdir, '_static', 'opensearch.xml')
664             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)
665 
666     def write_genindex(self) -> None:
667         # the total count of lines for each index letter, used to distribute
668         # the entries into two columns
669         genindex = IndexEntries(self.env).create_index(self)
670         indexcounts = []
671         for _k, entries in genindex:
672             indexcounts.append(sum(1 + len(subitems)
673                                    for _, (_, subitems, _) in entries))
674 
675         genindexcontext = {
676             'genindexentries': genindex,
677             'genindexcounts': indexcounts,
678             'split_index': self.config.html_split_index,
679         }
680         logger.info('genindex ', nonl=True)
681 
682         if self.config.html_split_index:
683             self.handle_page('genindex', genindexcontext,
684                              'genindex-split.html')
685             self.handle_page('genindex-all', genindexcontext,
686                              'genindex.html')
687             for (key, entries), count in zip(genindex, indexcounts):
688                 ctx = {'key': key, 'entries': entries, 'count': count,
689                        'genindexentries': genindex}
690                 self.handle_page('genindex-' + key, ctx,
691                                  'genindex-single.html')
692         else:
693             self.handle_page('genindex', genindexcontext, 'genindex.html')
694 
695     def write_domain_indices(self) -> None:
696         for indexname, indexcls, content, collapse in self.domain_indices:
697             indexcontext = {
698                 'indextitle': indexcls.localname,
699                 'content': content,
700                 'collapse_index': collapse,
701             }
702             logger.info(indexname + ' ', nonl=True)
703             self.handle_page(indexname, indexcontext, 'domainindex.html')
704 
705     def copy_image_files(self) -> None:
706         if self.images:
707             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
708             ensuredir(path.join(self.outdir, self.imagedir))
709             for src in status_iterator(self.images, __('copying images... '), "brown",
710                                        len(self.images), self.app.verbosity,
711                                        stringify_func=stringify_func):
712                 dest = self.images[src]
713                 try:
714                     copyfile(path.join(self.srcdir, src),
715                              path.join(self.outdir, self.imagedir, dest))
716                 except Exception as err:
717                     logger.warning(__('cannot copy image file %r: %s'),
718                                    path.join(self.srcdir, src), err)
719 
720     def copy_download_files(self) -> None:
721         def to_relpath(f: str) -> str:
722             return relative_path(self.srcdir, f)
723 
724         # copy downloadable files
725         if self.env.dlfiles:
726             ensuredir(path.join(self.outdir, '_downloads'))
727             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),
728                                        "brown", len(self.env.dlfiles), self.app.verbosity,
729                                        stringify_func=to_relpath):
730                 try:
731                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])
732                     ensuredir(path.dirname(dest))
733                     copyfile(path.join(self.srcdir, src), dest)
734                 except OSError as err:
735                     logger.warning(__('cannot copy downloadable file %r: %s'),
736                                    path.join(self.srcdir, src), err)
737 
738     def create_pygments_style_file(self) -> None:
739         """create a style file for pygments."""
740         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:
741             f.write(self.highlighter.get_stylesheet())
742 
743         if self.dark_highlighter:
744             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:
745                 f.write(self.dark_highlighter.get_stylesheet())
746 
747     def copy_translation_js(self) -> None:
748         """Copy a JavaScript file for translations."""
749         if self.config.language is not None:
750             jsfile = self._get_translations_js()
751             if jsfile:
752                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))
753 
754     def copy_stemmer_js(self) -> None:
755         """Copy a JavaScript file for stemmer."""
756         if self.indexer is not None:
757             jsfile = self.indexer.get_js_stemmer_rawcode()
758             if jsfile:
759                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))
760 
761     def copy_theme_static_files(self, context: Dict) -> None:
762         def onerror(filename: str, error: Exception) -> None:
763             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
764                            filename, error)
765 
766         if self.theme:
767             for entry in self.theme.get_theme_dirs()[::-1]:
768                 copy_asset(path.join(entry, 'static'),
769                            path.join(self.outdir, '_static'),
770                            excluded=DOTFILES, context=context,
771                            renderer=self.templates, onerror=onerror)
772 
773     def copy_html_static_files(self, context: Dict) -> None:
774         def onerror(filename: str, error: Exception) -> None:
775             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
776                            filename, error)
777 
778         excluded = Matcher(self.config.exclude_patterns + ["**/.*"])
779         for entry in self.config.html_static_path:
780             copy_asset(path.join(self.confdir, entry),
781                        path.join(self.outdir, '_static'),
782                        excluded, context=context, renderer=self.templates, onerror=onerror)
783 
784     def copy_html_logo(self) -> None:
785         if self.config.html_logo:
786             copy_asset(path.join(self.confdir, self.config.html_logo),
787                        path.join(self.outdir, '_static'))
788 
789     def copy_html_favicon(self) -> None:
790         if self.config.html_favicon:
791             copy_asset(path.join(self.confdir, self.config.html_favicon),
792                        path.join(self.outdir, '_static'))
793 
794     def copy_static_files(self) -> None:
795         try:
796             with progress_message(__('copying static files')):
797                 ensuredir(path.join(self.outdir, '_static'))
798 
799                 # prepare context for templates
800                 context = self.globalcontext.copy()
801                 if self.indexer is not None:
802                     context.update(self.indexer.context_for_searchtool())
803 
804                 self.create_pygments_style_file()
805                 self.copy_translation_js()
806                 self.copy_stemmer_js()
807                 self.copy_theme_static_files(context)
808                 self.copy_html_static_files(context)
809                 self.copy_html_logo()
810                 self.copy_html_favicon()
811         except OSError as err:
812             logger.warning(__('cannot copy static file %r'), err)
813 
814     def copy_extra_files(self) -> None:
815         """copy html_extra_path files."""
816         try:
817             with progress_message(__('copying extra files')):
818                 excluded = Matcher(self.config.exclude_patterns)
819                 for extra_path in self.config.html_extra_path:
820                     entry = path.join(self.confdir, extra_path)
821                     copy_asset(entry, self.outdir, excluded)
822         except OSError as err:
823             logger.warning(__('cannot copy extra file %r'), err)
824 
825     def write_buildinfo(self) -> None:
826         try:
827             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:
828                 self.build_info.dump(fp)
829         except OSError as exc:
830             logger.warning(__('Failed to write build info file: %r'), exc)
831 
832     def cleanup(self) -> None:
833         # clean up theme stuff
834         if self.theme:
835             self.theme.cleanup()
836 
837     def post_process_images(self, doctree: Node) -> None:
838         """Pick the best candidate for an image and link down-scaled images to
839         their high res version.
840         """
841         Builder.post_process_images(self, doctree)
842 
843         if self.config.html_scaled_image_link and self.html_scaled_image_link:
844             for node in doctree.traverse(nodes.image):
845                 if not any((key in node) for key in ['scale', 'width', 'height']):
846                     # resizing options are not given. scaled image link is available
847                     # only for resized images.
848                     continue
849                 elif isinstance(node.parent, nodes.reference):
850                     # A image having hyperlink target
851                     continue
852                 elif 'no-scaled-link' in node['classes']:
853                     # scaled image link is disabled for this node
854                     continue
855 
856                 uri = node['uri']
857                 reference = nodes.reference('', '', internal=True)
858                 if uri in self.images:
859                     reference['refuri'] = posixpath.join(self.imgpath,
860                                                          self.images[uri])
861                 else:
862                     reference['refuri'] = uri
863                 node.replace_self(reference)
864                 reference.append(node)
865 
866     def load_indexer(self, docnames: Iterable[str]) -> None:
867         keep = set(self.env.all_docs) - set(docnames)
868         try:
869             searchindexfn = path.join(self.outdir, self.searchindex_filename)
870             if self.indexer_dumps_unicode:
871                 with open(searchindexfn, encoding='utf-8') as ft:
872                     self.indexer.load(ft, self.indexer_format)
873             else:
874                 with open(searchindexfn, 'rb') as fb:
875                     self.indexer.load(fb, self.indexer_format)
876         except (OSError, ValueError):
877             if keep:
878                 logger.warning(__('search index couldn\'t be loaded, but not all '
879                                   'documents will be built: the index will be '
880                                   'incomplete.'))
881         # delete all entries for files that will be rebuilt
882         self.indexer.prune(keep)
883 
884     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:
885         # only index pages with title
886         if self.indexer is not None and title:
887             filename = self.env.doc2path(pagename, base=None)
888             try:
889                 metadata = self.env.metadata.get(pagename, {})
890                 if 'nosearch' in metadata:
891                     self.indexer.feed(pagename, filename, '', new_document(''))
892                 else:
893                     self.indexer.feed(pagename, filename, title, doctree)
894             except TypeError:
895                 # fallback for old search-adapters
896                 self.indexer.feed(pagename, title, doctree)  # type: ignore
897                 indexer_name = self.indexer.__class__.__name__
898                 warnings.warn(
899                     'The %s.feed() method signature is deprecated. Update to '
900                     '%s.feed(docname, filename, title, doctree).' % (
901                         indexer_name, indexer_name),
902                     RemovedInSphinx40Warning, stacklevel=2)
903 
904     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:
905         if 'includehidden' not in kwargs:
906             kwargs['includehidden'] = False
907         if kwargs.get('maxdepth') == '':
908             kwargs.pop('maxdepth')
909         return self.render_partial(TocTree(self.env).get_toctree_for(
910             docname, self, collapse, **kwargs))['fragment']
911 
912     def get_outfilename(self, pagename: str) -> str:
913         return path.join(self.outdir, os_path(pagename) + self.out_suffix)
914 
915     def add_sidebars(self, pagename: str, ctx: Dict) -> None:
916         def has_wildcard(pattern: str) -> bool:
917             return any(char in pattern for char in '*?[')
918 
919         sidebars = None
920         matched = None
921         customsidebar = None
922 
923         # default sidebars settings for selected theme
924         if self.theme.name == 'alabaster':
925             # provide default settings for alabaster (for compatibility)
926             # Note: this will be removed before Sphinx-2.0
927             try:
928                 # get default sidebars settings from alabaster (if defined)
929                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')
930                 if theme_default_sidebars:
931                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
932             except Exception:
933                 # fallback to better default settings
934                 sidebars = ['about.html', 'navigation.html', 'relations.html',
935                             'searchbox.html', 'donate.html']
936         else:
937             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)
938             if theme_default_sidebars:
939                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
940 
941         # user sidebar settings
942         html_sidebars = self.get_builder_config('sidebars', 'html')
943         for pattern, patsidebars in html_sidebars.items():
944             if patmatch(pagename, pattern):
945                 if matched:
946                     if has_wildcard(pattern):
947                         # warn if both patterns contain wildcards
948                         if has_wildcard(matched):
949                             logger.warning(__('page %s matches two patterns in '
950                                               'html_sidebars: %r and %r'),
951                                            pagename, matched, pattern)
952                         # else the already matched pattern is more specific
953                         # than the present one, because it contains no wildcard
954                         continue
955                 matched = pattern
956                 sidebars = patsidebars
957 
958         if sidebars is None:
959             # keep defaults
960             pass
961 
962         ctx['sidebars'] = sidebars
963         ctx['customsidebar'] = customsidebar
964 
965     # --------- these are overwritten by the serialization builder
966 
967     def get_target_uri(self, docname: str, typ: str = None) -> str:
968         return quote(docname) + self.link_suffix
969 
970     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',
971                     outfilename: str = None, event_arg: Any = None) -> None:
972         ctx = self.globalcontext.copy()
973         # current_page_name is backwards compatibility
974         ctx['pagename'] = ctx['current_page_name'] = pagename
975         ctx['encoding'] = self.config.html_output_encoding
976         default_baseuri = self.get_target_uri(pagename)
977         # in the singlehtml builder, default_baseuri still contains an #anchor
978         # part, which relative_uri doesn't really like...
979         default_baseuri = default_baseuri.rsplit('#', 1)[0]
980 
981         if self.config.html_baseurl:
982             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,
983                                             pagename + self.out_suffix)
984         else:
985             ctx['pageurl'] = None
986 
987         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA
988             if resource and '://' in otheruri:
989                 # allow non-local resources given by scheme
990                 return otheruri
991             elif not resource:
992                 otheruri = self.get_target_uri(otheruri)
993             uri = relative_uri(baseuri, otheruri) or '#'
994             if uri == '#' and not self.allow_sharp_as_current_path:
995                 uri = baseuri
996             return uri
997         ctx['pathto'] = pathto
998 
999         def css_tag(css: Stylesheet) -> str:
1000             attrs = []
1001             for key in sorted(css.attributes):
1002                 value = css.attributes[key]
1003                 if value is not None:
1004                     attrs.append('%s="%s"' % (key, html.escape(value, True)))
1005             attrs.append('href="%s"' % pathto(css.filename, resource=True))
1006             return '<link %s />' % ' '.join(attrs)
1007         ctx['css_tag'] = css_tag
1008 
1009         def hasdoc(name: str) -> bool:
1010             if name in self.env.all_docs:
1011                 return True
1012             elif name == 'search' and self.search:
1013                 return True
1014             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):
1015                 return True
1016             return False
1017         ctx['hasdoc'] = hasdoc
1018 
1019         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)
1020         self.add_sidebars(pagename, ctx)
1021         ctx.update(addctx)
1022 
1023         # revert script_files and css_files
1024         self.script_files[:] = self._script_files
1025         self.css_files[:] = self.css_files
1026 
1027         self.update_page_context(pagename, templatename, ctx, event_arg)
1028         newtmpl = self.app.emit_firstresult('html-page-context', pagename,
1029                                             templatename, ctx, event_arg)
1030         if newtmpl:
1031             templatename = newtmpl
1032 
1033         # sort JS/CSS before rendering HTML
1034         ctx['script_files'].sort(key=lambda js: js.priority)
1035         ctx['css_files'].sort(key=lambda js: js.priority)
1036 
1037         try:
1038             output = self.templates.render(templatename, ctx)
1039         except UnicodeError:
1040             logger.warning(__("a Unicode error occurred when rendering the page %s. "
1041                               "Please make sure all config values that contain "
1042                               "non-ASCII content are Unicode strings."), pagename)
1043             return
1044         except Exception as exc:
1045             raise ThemeError(__("An error happened in rendering the page %s.\nReason: %r") %
1046                              (pagename, exc)) from exc
1047 
1048         if not outfilename:
1049             outfilename = self.get_outfilename(pagename)
1050         # outfilename's path is in general different from self.outdir
1051         ensuredir(path.dirname(outfilename))
1052         try:
1053             with open(outfilename, 'w', encoding=ctx['encoding'],
1054                       errors='xmlcharrefreplace') as f:
1055                 f.write(output)
1056         except OSError as err:
1057             logger.warning(__("error writing file %s: %s"), outfilename, err)
1058         if self.copysource and ctx.get('sourcename'):
1059             # copy the source file for the "show source" link
1060             source_name = path.join(self.outdir, '_sources',
1061                                     os_path(ctx['sourcename']))
1062             ensuredir(path.dirname(source_name))
1063             copyfile(self.env.doc2path(pagename), source_name)
1064 
1065     def update_page_context(self, pagename: str, templatename: str,
1066                             ctx: Dict, event_arg: Any) -> None:
1067         pass
1068 
1069     def handle_finish(self) -> None:
1070         if self.indexer:
1071             self.finish_tasks.add_task(self.dump_search_index)
1072         self.finish_tasks.add_task(self.dump_inventory)
1073 
1074     @progress_message(__('dumping object inventory'))
1075     def dump_inventory(self) -> None:
1076         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)
1077 
1078     def dump_search_index(self) -> None:
1079         with progress_message(__('dumping search index in %s') % self.indexer.label()):
1080             self.indexer.prune(self.env.all_docs)
1081             searchindexfn = path.join(self.outdir, self.searchindex_filename)
1082             # first write to a temporary file, so that if dumping fails,
1083             # the existing index won't be overwritten
1084             if self.indexer_dumps_unicode:
1085                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:
1086                     self.indexer.dump(ft, self.indexer_format)
1087             else:
1088                 with open(searchindexfn + '.tmp', 'wb') as fb:
1089                     self.indexer.dump(fb, self.indexer_format)
1090             os.replace(searchindexfn + '.tmp', searchindexfn)
1091 
1092 
1093 def convert_html_css_files(app: Sphinx, config: Config) -> None:
1094     """This converts string styled html_css_files to tuple styled one."""
1095     html_css_files = []  # type: List[Tuple[str, Dict]]
1096     for entry in config.html_css_files:
1097         if isinstance(entry, str):
1098             html_css_files.append((entry, {}))
1099         else:
1100             try:
1101                 filename, attrs = entry
1102                 html_css_files.append((filename, attrs))
1103             except Exception:
1104                 logger.warning(__('invalid css_file: %r, ignored'), entry)
1105                 continue
1106 
1107     config.html_css_files = html_css_files  # type: ignore
1108 
1109 
1110 def convert_html_js_files(app: Sphinx, config: Config) -> None:
1111     """This converts string styled html_js_files to tuple styled one."""
1112     html_js_files = []  # type: List[Tuple[str, Dict]]
1113     for entry in config.html_js_files:
1114         if isinstance(entry, str):
1115             html_js_files.append((entry, {}))
1116         else:
1117             try:
1118                 filename, attrs = entry
1119                 html_js_files.append((filename, attrs))
1120             except Exception:
1121                 logger.warning(__('invalid js_file: %r, ignored'), entry)
1122                 continue
1123 
1124     config.html_js_files = html_js_files  # type: ignore
1125 
1126 
1127 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,
1128                         context: Dict, doctree: Node) -> None:
1129     """Set up js_tag() template helper.
1130 
1131     .. note:: This set up function is added to keep compatibility with webhelper.
1132     """
1133     pathto = context.get('pathto')
1134 
1135     def js_tag(js: JavaScript) -> str:
1136         attrs = []
1137         body = ''
1138         if isinstance(js, JavaScript):
1139             for key in sorted(js.attributes):
1140                 value = js.attributes[key]
1141                 if value is not None:
1142                     if key == 'body':
1143                         body = value
1144                     else:
1145                         attrs.append('%s="%s"' % (key, html.escape(value, True)))
1146             if js.filename:
1147                 attrs.append('src="%s"' % pathto(js.filename, resource=True))
1148         else:
1149             # str value (old styled)
1150             attrs.append('src="%s"' % pathto(js, resource=True))
1151         return '<script %s>%s</script>' % (' '.join(attrs), body)
1152 
1153     context['js_tag'] = js_tag
1154 
1155 
1156 def validate_math_renderer(app: Sphinx) -> None:
1157     if app.builder.format != 'html':
1158         return
1159 
1160     name = app.builder.math_renderer_name  # type: ignore
1161     if name is None:
1162         raise ConfigError(__('Many math_renderers are registered. '
1163                              'But no math_renderer is selected.'))
1164     elif name not in app.registry.html_inline_math_renderers:
1165         raise ConfigError(__('Unknown math_renderer %r is given.') % name)
1166 
1167 
1168 def validate_html_extra_path(app: Sphinx, config: Config) -> None:
1169     """Check html_extra_paths setting."""
1170     for entry in config.html_extra_path[:]:
1171         extra_path = path.normpath(path.join(app.confdir, entry))
1172         if not path.exists(extra_path):
1173             logger.warning(__('html_extra_path entry %r does not exist'), entry)
1174             config.html_extra_path.remove(entry)
1175         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and
1176               path.commonpath([app.outdir, extra_path]) == app.outdir):
1177             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)
1178             config.html_extra_path.remove(entry)
1179 
1180 
1181 def validate_html_static_path(app: Sphinx, config: Config) -> None:
1182     """Check html_static_paths setting."""
1183     for entry in config.html_static_path[:]:
1184         static_path = path.normpath(path.join(app.confdir, entry))
1185         if not path.exists(static_path):
1186             logger.warning(__('html_static_path entry %r does not exist'), entry)
1187             config.html_static_path.remove(entry)
1188         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and
1189               path.commonpath([app.outdir, static_path]) == app.outdir):
1190             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)
1191             config.html_static_path.remove(entry)
1192 
1193 
1194 def validate_html_logo(app: Sphinx, config: Config) -> None:
1195     """Check html_logo setting."""
1196     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):
1197         logger.warning(__('logo file %r does not exist'), config.html_logo)
1198         config.html_logo = None  # type: ignore
1199 
1200 
1201 def validate_html_favicon(app: Sphinx, config: Config) -> None:
1202     """Check html_favicon setting."""
1203     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):
1204         logger.warning(__('favicon file %r does not exist'), config.html_favicon)
1205         config.html_favicon = None  # type: ignore
1206 
1207 
1208 # for compatibility
1209 import sphinxcontrib.serializinghtml  # NOQA
1210 
1211 import sphinx.builders.dirhtml  # NOQA
1212 import sphinx.builders.singlehtml  # NOQA
1213 
1214 
1215 def setup(app: Sphinx) -> Dict[str, Any]:
1216     # builders
1217     app.add_builder(StandaloneHTMLBuilder)
1218 
1219     # config values
1220     app.add_config_value('html_theme', 'alabaster', 'html')
1221     app.add_config_value('html_theme_path', [], 'html')
1222     app.add_config_value('html_theme_options', {}, 'html')
1223     app.add_config_value('html_title',
1224                          lambda self: _('%s %s documentation') % (self.project, self.release),
1225                          'html', [str])
1226     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')
1227     app.add_config_value('html_style', None, 'html', [str])
1228     app.add_config_value('html_logo', None, 'html', [str])
1229     app.add_config_value('html_favicon', None, 'html', [str])
1230     app.add_config_value('html_css_files', [], 'html')
1231     app.add_config_value('html_js_files', [], 'html')
1232     app.add_config_value('html_static_path', [], 'html')
1233     app.add_config_value('html_extra_path', [], 'html')
1234     app.add_config_value('html_last_updated_fmt', None, 'html', [str])
1235     app.add_config_value('html_sidebars', {}, 'html')
1236     app.add_config_value('html_additional_pages', {}, 'html')
1237     app.add_config_value('html_domain_indices', True, 'html', [list])
1238     app.add_config_value('html_add_permalinks', '¶', 'html')
1239     app.add_config_value('html_use_index', True, 'html')
1240     app.add_config_value('html_split_index', False, 'html')
1241     app.add_config_value('html_copy_source', True, 'html')
1242     app.add_config_value('html_show_sourcelink', True, 'html')
1243     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')
1244     app.add_config_value('html_use_opensearch', '', 'html')
1245     app.add_config_value('html_file_suffix', None, 'html', [str])
1246     app.add_config_value('html_link_suffix', None, 'html', [str])
1247     app.add_config_value('html_show_copyright', True, 'html')
1248     app.add_config_value('html_show_sphinx', True, 'html')
1249     app.add_config_value('html_context', {}, 'html')
1250     app.add_config_value('html_output_encoding', 'utf-8', 'html')
1251     app.add_config_value('html_compact_lists', True, 'html')
1252     app.add_config_value('html_secnumber_suffix', '. ', 'html')
1253     app.add_config_value('html_search_language', None, 'html', [str])
1254     app.add_config_value('html_search_options', {}, 'html')
1255     app.add_config_value('html_search_scorer', '', None)
1256     app.add_config_value('html_scaled_image_link', True, 'html')
1257     app.add_config_value('html_baseurl', '', 'html')
1258     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',
1259                          ENUM('table', 'inline'))
1260     app.add_config_value('html_math_renderer', None, 'env')
1261     app.add_config_value('html4_writer', False, 'html')
1262 
1263     # events
1264     app.add_event('html-collect-pages')
1265     app.add_event('html-page-context')
1266 
1267     # event handlers
1268     app.connect('config-inited', convert_html_css_files, priority=800)
1269     app.connect('config-inited', convert_html_js_files, priority=800)
1270     app.connect('config-inited', validate_html_extra_path, priority=800)
1271     app.connect('config-inited', validate_html_static_path, priority=800)
1272     app.connect('config-inited', validate_html_logo, priority=800)
1273     app.connect('config-inited', validate_html_favicon, priority=800)
1274     app.connect('builder-inited', validate_math_renderer)
1275     app.connect('html-page-context', setup_js_tag_helper)
1276 
1277     # load default math renderer
1278     app.setup_extension('sphinx.ext.mathjax')
1279 
1280     # load transforms for HTML builder
1281     app.setup_extension('sphinx.builders.html.transforms')
1282 
1283     return {
1284         'version': 'builtin',
1285         'parallel_read_safe': True,
1286         'parallel_write_safe': True,
1287     }

</code><intended_behavior>This file should include or be modified to ensure that when handling file paths for resources like downloads or figures, all path references are normalized using os.path.normpath() (or a Sphinx equivalent function if it wraps path operations for cross-platform compatibility). Additionally, before treating any file as a duplicate, the code should verify whether the normalized paths actually point to the different resources. This process will prevent the issue where the same file is interpreted as multiple files when referenced in various ways.</intended_behavior>, <file>sphinx/environment/collectors/dependencies.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.collectors.dependencies
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     The dependencies collector components for sphinx.environment.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import os
12 from os import path
13 from typing import Any, Dict, Set
14 
15 from docutils import nodes
16 from docutils.utils import relative_path
17 
18 from sphinx.application import Sphinx
19 from sphinx.environment import BuildEnvironment
20 from sphinx.environment.collectors import EnvironmentCollector
21 from sphinx.util.osutil import fs_encoding
22 
23 
24 class DependenciesCollector(EnvironmentCollector):
25     """dependencies collector for sphinx.environment."""
26 
27     def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -> None:
28         env.dependencies.pop(docname, None)
29 
30     def merge_other(self, app: Sphinx, env: BuildEnvironment,
31                     docnames: Set[str], other: BuildEnvironment) -> None:
32         for docname in docnames:
33             if docname in other.dependencies:
34                 env.dependencies[docname] = other.dependencies[docname]
35 
36     def process_doc(self, app: Sphinx, doctree: nodes.document) -> None:
37         """Process docutils-generated dependency info."""
38         cwd = os.getcwd()
39         frompath = path.join(path.normpath(app.srcdir), 'dummy')
40         deps = doctree.settings.record_dependencies
41         if not deps:
42             return
43         for dep in deps.list:
44             # the dependency path is relative to the working dir, so get
45             # one relative to the srcdir
46             if isinstance(dep, bytes):
47                 dep = dep.decode(fs_encoding)
48             relpath = relative_path(frompath,
49                                     path.normpath(path.join(cwd, dep)))
50             app.env.dependencies[app.env.docname].add(relpath)
51 
52 
53 def setup(app: Sphinx) -> Dict[str, Any]:
54     app.add_env_collector(DependenciesCollector)
55 
56     return {
57         'version': 'builtin',
58         'parallel_read_safe': True,
59         'parallel_write_safe': True,
60     }

</code><intended_behavior>This file, likely involved in tracking and managing file dependencies within the Sphinx build environment, should be modified to ensure that any comparisons or operations on file paths are conducted on normalized paths. This will aid in accurately tracking file dependencies and usage without falsely identifying the same file as multiple ones due to path differences.</intended_behavior>]
2025-10-18 18:42:02.413 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 18:42:02.413 | INFO     | Search-only: skipping patch selection
2025-10-18 18:42:02.491 | INFO     | Task sphinx-doc__sphinx-8697 completed successfully.
2025-10-18 18:42:02.492 | INFO     | No patch generated. You can try running ACR again.
