[
    {
        "rel_file_path": "sphinx/builders/html/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/builders/html/__init__.py",
        "start": 1,
        "end": 1287,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.builders.html\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Several HTML builders.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import html\n12 import os\n13 import posixpath\n14 import re\n15 import sys\n16 import warnings\n17 from os import path\n18 from typing import IO, Any, Dict, Iterable, Iterator, List, Set, Tuple\n19 from urllib.parse import quote\n20 \n21 from docutils import nodes\n22 from docutils.core import publish_parts\n23 from docutils.frontend import OptionParser\n24 from docutils.io import DocTreeInput, StringOutput\n25 from docutils.nodes import Node\n26 from docutils.utils import relative_path\n27 \n28 from sphinx import __display_version__, package_dir\n29 from sphinx.application import Sphinx\n30 from sphinx.builders import Builder\n31 from sphinx.config import ENUM, Config\n32 from sphinx.deprecation import RemovedInSphinx40Warning\n33 from sphinx.domains import Domain, Index, IndexEntry\n34 from sphinx.environment.adapters.asset import ImageAdapter\n35 from sphinx.environment.adapters.indexentries import IndexEntries\n36 from sphinx.environment.adapters.toctree import TocTree\n37 from sphinx.errors import ConfigError, ThemeError\n38 from sphinx.highlighting import PygmentsBridge\n39 from sphinx.locale import _, __\n40 from sphinx.search import js_index\n41 from sphinx.theming import HTMLThemeFactory\n42 from sphinx.util import logging, md5, progress_message, status_iterator\n43 from sphinx.util.docutils import is_html5_writer_available, new_document\n44 from sphinx.util.fileutil import copy_asset\n45 from sphinx.util.i18n import format_date\n46 from sphinx.util.inventory import InventoryFile\n47 from sphinx.util.matching import DOTFILES, Matcher, patmatch\n48 from sphinx.util.osutil import copyfile, ensuredir, os_path, relative_uri\n49 from sphinx.util.tags import Tags\n50 from sphinx.writers.html import HTMLTranslator, HTMLWriter\n51 \n52 if False:\n53     # For type annotation\n54     from typing import Type  # for python3.5.1\n55 \n56 \n57 # HTML5 Writer is available or not\n58 if is_html5_writer_available():\n59     from sphinx.writers.html5 import HTML5Translator\n60     html5_ready = True\n61 else:\n62     html5_ready = False\n63 \n64 #: the filename for the inventory of objects\n65 INVENTORY_FILENAME = 'objects.inv'\n66 \n67 logger = logging.getLogger(__name__)\n68 return_codes_re = re.compile('[\\r\\n]+')\n69 \n70 \n71 def get_stable_hash(obj: Any) -> str:\n72     \"\"\"\n73     Return a stable hash for a Python data structure.  We can't just use\n74     the md5 of str(obj) since for example dictionary items are enumerated\n75     in unpredictable order due to hash randomization in newer Pythons.\n76     \"\"\"\n77     if isinstance(obj, dict):\n78         return get_stable_hash(list(obj.items()))\n79     elif isinstance(obj, (list, tuple)):\n80         obj = sorted(get_stable_hash(o) for o in obj)\n81     return md5(str(obj).encode()).hexdigest()\n82 \n83 \n84 class Stylesheet(str):\n85     \"\"\"A metadata of stylesheet.\n86 \n87     To keep compatibility with old themes, an instance of stylesheet behaves as\n88     its filename (str).\n89     \"\"\"\n90 \n91     attributes = None   # type: Dict[str, str]\n92     filename = None     # type: str\n93     priority = None     # type: int\n94 \n95     def __new__(cls, filename: str, *args: str, priority: int = 500, **attributes: Any\n96                 ) -> \"Stylesheet\":\n97         self = str.__new__(cls, filename)  # type: ignore\n98         self.filename = filename\n99         self.priority = priority\n100         self.attributes = attributes\n101         self.attributes.setdefault('rel', 'stylesheet')\n102         self.attributes.setdefault('type', 'text/css')\n103         if args:  # old style arguments (rel, title)\n104             self.attributes['rel'] = args[0]\n105             self.attributes['title'] = args[1]\n106 \n107         return self\n108 \n109 \n110 class JavaScript(str):\n111     \"\"\"A metadata of javascript file.\n112 \n113     To keep compatibility with old themes, an instance of javascript behaves as\n114     its filename (str).\n115     \"\"\"\n116 \n117     attributes = None   # type: Dict[str, str]\n118     filename = None     # type: str\n119     priority = None     # type: int\n120 \n121     def __new__(cls, filename: str, priority: int = 500, **attributes: str) -> \"JavaScript\":\n122         self = str.__new__(cls, filename)  # type: ignore\n123         self.filename = filename\n124         self.priority = priority\n125         self.attributes = attributes\n126 \n127         return self\n128 \n129 \n130 class BuildInfo:\n131     \"\"\"buildinfo file manipulator.\n132 \n133     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.\n134     This class is a manipulator for the file.\n135     \"\"\"\n136 \n137     @classmethod\n138     def load(cls, f: IO) -> \"BuildInfo\":\n139         try:\n140             lines = f.readlines()\n141             assert lines[0].rstrip() == '# Sphinx build info version 1'\n142             assert lines[2].startswith('config: ')\n143             assert lines[3].startswith('tags: ')\n144 \n145             build_info = BuildInfo()\n146             build_info.config_hash = lines[2].split()[1].strip()\n147             build_info.tags_hash = lines[3].split()[1].strip()\n148             return build_info\n149         except Exception as exc:\n150             raise ValueError(__('build info file is broken: %r') % exc) from exc\n151 \n152     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA\n153         self.config_hash = ''\n154         self.tags_hash = ''\n155 \n156         if config:\n157             values = {c.name: c.value for c in config.filter(config_categories)}\n158             self.config_hash = get_stable_hash(values)\n159 \n160         if tags:\n161             self.tags_hash = get_stable_hash(sorted(tags))\n162 \n163     def __eq__(self, other: \"BuildInfo\") -> bool:  # type: ignore\n164         return (self.config_hash == other.config_hash and\n165                 self.tags_hash == other.tags_hash)\n166 \n167     def dump(self, f: IO) -> None:\n168         f.write('# Sphinx build info version 1\\n'\n169                 '# This file hashes the configuration used when building these files.'\n170                 ' When it is not found, a full rebuild will be done.\\n'\n171                 'config: %s\\n'\n172                 'tags: %s\\n' %\n173                 (self.config_hash, self.tags_hash))\n174 \n175 \n176 class StandaloneHTMLBuilder(Builder):\n177     \"\"\"\n178     Builds standalone HTML docs.\n179     \"\"\"\n180     name = 'html'\n181     format = 'html'\n182     epilog = __('The HTML pages are in %(outdir)s.')\n183 \n184     copysource = True\n185     allow_parallel = True\n186     out_suffix = '.html'\n187     link_suffix = '.html'  # defaults to matching out_suffix\n188     indexer_format = js_index  # type: Any\n189     indexer_dumps_unicode = True\n190     # create links to original images from images [True/False]\n191     html_scaled_image_link = True\n192     supported_image_types = ['image/svg+xml', 'image/png',\n193                              'image/gif', 'image/jpeg']\n194     supported_remote_images = True\n195     supported_data_uri_images = True\n196     searchindex_filename = 'searchindex.js'\n197     add_permalinks = True\n198     allow_sharp_as_current_path = True\n199     embedded = False  # for things like HTML help or Qt help: suppresses sidebar\n200     search = True  # for things like HTML help and Apple help: suppress search\n201     use_index = False\n202     download_support = True  # enable download role\n203 \n204     imgpath = None          # type: str\n205     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA\n206 \n207     def __init__(self, app: Sphinx) -> None:\n208         super().__init__(app)\n209 \n210         # CSS files\n211         self.css_files = []  # type: List[Dict[str, str]]\n212 \n213         # JS files\n214         self.script_files = []  # type: List[JavaScript]\n215 \n216     def init(self) -> None:\n217         self.build_info = self.create_build_info()\n218         # basename of images directory\n219         self.imagedir = '_images'\n220         # section numbers for headings in the currently visited document\n221         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]\n222         # currently written docname\n223         self.current_docname = None  # type: str\n224 \n225         self.init_templates()\n226         self.init_highlighter()\n227         self.init_css_files()\n228         self.init_js_files()\n229 \n230         html_file_suffix = self.get_builder_config('file_suffix', 'html')\n231         if html_file_suffix is not None:\n232             self.out_suffix = html_file_suffix\n233 \n234         html_link_suffix = self.get_builder_config('link_suffix', 'html')\n235         if html_link_suffix is not None:\n236             self.link_suffix = html_link_suffix\n237         else:\n238             self.link_suffix = self.out_suffix\n239 \n240         self.use_index = self.get_builder_config('use_index', 'html')\n241 \n242     def create_build_info(self) -> BuildInfo:\n243         return BuildInfo(self.config, self.tags, ['html'])\n244 \n245     def _get_translations_js(self) -> str:\n246         candidates = [path.join(dir, self.config.language,\n247                                 'LC_MESSAGES', 'sphinx.js')\n248                       for dir in self.config.locale_dirs] + \\\n249                      [path.join(package_dir, 'locale', self.config.language,\n250                                 'LC_MESSAGES', 'sphinx.js'),\n251                       path.join(sys.prefix, 'share/sphinx/locale',\n252                                 self.config.language, 'sphinx.js')]\n253 \n254         for jsfile in candidates:\n255             if path.isfile(jsfile):\n256                 return jsfile\n257         return None\n258 \n259     def get_theme_config(self) -> Tuple[str, Dict]:\n260         return self.config.html_theme, self.config.html_theme_options\n261 \n262     def init_templates(self) -> None:\n263         theme_factory = HTMLThemeFactory(self.app)\n264         themename, themeoptions = self.get_theme_config()\n265         self.theme = theme_factory.create(themename)\n266         self.theme_options = themeoptions.copy()\n267         self.create_template_bridge()\n268         self.templates.init(self, self.theme)\n269 \n270     def init_highlighter(self) -> None:\n271         # determine Pygments style and create the highlighter\n272         if self.config.pygments_style is not None:\n273             style = self.config.pygments_style\n274         elif self.theme:\n275             style = self.theme.get_config('theme', 'pygments_style', 'none')\n276         else:\n277             style = 'sphinx'\n278         self.highlighter = PygmentsBridge('html', style)\n279 \n280         if self.theme:\n281             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)\n282         else:\n283             dark_style = None\n284 \n285         if dark_style is not None:\n286             self.dark_highlighter = PygmentsBridge('html', dark_style)\n287             self.add_css_file('pygments_dark.css',\n288                               media='(prefers-color-scheme: dark)',\n289                               id='pygments_dark_css')\n290         else:\n291             self.dark_highlighter = None\n292 \n293     def init_css_files(self) -> None:\n294         for filename, attrs in self.app.registry.css_files:\n295             self.add_css_file(filename, **attrs)\n296 \n297         for filename, attrs in self.get_builder_config('css_files', 'html'):\n298             attrs.setdefault('priority', 800)  # User's CSSs are loaded after extensions'\n299             self.add_css_file(filename, **attrs)\n300 \n301     def add_css_file(self, filename: str, **kwargs: Any) -> None:\n302         if '://' not in filename:\n303             filename = posixpath.join('_static', filename)\n304 \n305         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore\n306 \n307     def init_js_files(self) -> None:\n308         self.add_js_file('jquery.js', priority=200)\n309         self.add_js_file('underscore.js', priority=200)\n310         self.add_js_file('doctools.js', priority=200)\n311 \n312         for filename, attrs in self.app.registry.js_files:\n313             self.add_js_file(filename, **attrs)\n314 \n315         for filename, attrs in self.get_builder_config('js_files', 'html'):\n316             attrs.setdefault('priority', 800)  # User's JSs are loaded after extensions'\n317             self.add_js_file(filename, **attrs)\n318 \n319         if self.config.language and self._get_translations_js():\n320             self.add_js_file('translations.js')\n321 \n322     def add_js_file(self, filename: str, **kwargs: Any) -> None:\n323         if filename and '://' not in filename:\n324             filename = posixpath.join('_static', filename)\n325 \n326         self.script_files.append(JavaScript(filename, **kwargs))\n327 \n328     @property\n329     def default_translator_class(self) -> \"Type[nodes.NodeVisitor]\":  # type: ignore\n330         if not html5_ready or self.config.html4_writer:\n331             return HTMLTranslator\n332         else:\n333             return HTML5Translator\n334 \n335     @property\n336     def math_renderer_name(self) -> str:\n337         name = self.get_builder_config('math_renderer', 'html')\n338         if name is not None:\n339             # use given name\n340             return name\n341         else:\n342             # not given: choose a math_renderer from registered ones as possible\n343             renderers = list(self.app.registry.html_inline_math_renderers)\n344             if len(renderers) == 1:\n345                 # only default math_renderer (mathjax) is registered\n346                 return renderers[0]\n347             elif len(renderers) == 2:\n348                 # default and another math_renderer are registered; prior the another\n349                 renderers.remove('mathjax')\n350                 return renderers[0]\n351             else:\n352                 # many math_renderers are registered. can't choose automatically!\n353                 return None\n354 \n355     def get_outdated_docs(self) -> Iterator[str]:\n356         try:\n357             with open(path.join(self.outdir, '.buildinfo')) as fp:\n358                 buildinfo = BuildInfo.load(fp)\n359 \n360             if self.build_info != buildinfo:\n361                 yield from self.env.found_docs\n362                 return\n363         except ValueError as exc:\n364             logger.warning(__('Failed to read build info file: %r'), exc)\n365         except OSError:\n366             # ignore errors on reading\n367             pass\n368 \n369         if self.templates:\n370             template_mtime = self.templates.newest_template_mtime()\n371         else:\n372             template_mtime = 0\n373         for docname in self.env.found_docs:\n374             if docname not in self.env.all_docs:\n375                 yield docname\n376                 continue\n377             targetname = self.get_outfilename(docname)\n378             try:\n379                 targetmtime = path.getmtime(targetname)\n380             except Exception:\n381                 targetmtime = 0\n382             try:\n383                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),\n384                                template_mtime)\n385                 if srcmtime > targetmtime:\n386                     yield docname\n387             except OSError:\n388                 # source doesn't exist anymore\n389                 pass\n390 \n391     def get_asset_paths(self) -> List[str]:\n392         return self.config.html_extra_path + self.config.html_static_path\n393 \n394     def render_partial(self, node: Node) -> Dict[str, str]:\n395         \"\"\"Utility: Render a lone doctree node.\"\"\"\n396         if node is None:\n397             return {'fragment': ''}\n398         doc = new_document('<partial node>')\n399         doc.append(node)\n400 \n401         writer = HTMLWriter(self)\n402         return publish_parts(reader_name='doctree',\n403                              writer=writer,\n404                              source_class=DocTreeInput,\n405                              settings_overrides={'output_encoding': 'unicode'},\n406                              source=doc)\n407 \n408     def prepare_writing(self, docnames: Set[str]) -> None:\n409         # create the search indexer\n410         self.indexer = None\n411         if self.search:\n412             from sphinx.search import IndexBuilder\n413             lang = self.config.html_search_language or self.config.language\n414             if not lang:\n415                 lang = 'en'\n416             self.indexer = IndexBuilder(self.env, lang,\n417                                         self.config.html_search_options,\n418                                         self.config.html_search_scorer)\n419             self.load_indexer(docnames)\n420 \n421         self.docwriter = HTMLWriter(self)\n422         self.docsettings = OptionParser(\n423             defaults=self.env.settings,\n424             components=(self.docwriter,),\n425             read_config_files=True).get_default_values()  # type: Any\n426         self.docsettings.compact_lists = bool(self.config.html_compact_lists)\n427 \n428         # determine the additional indices to include\n429         self.domain_indices = []\n430         # html_domain_indices can be False/True or a list of index names\n431         indices_config = self.config.html_domain_indices\n432         if indices_config:\n433             for domain_name in sorted(self.env.domains):\n434                 domain = None  # type: Domain\n435                 domain = self.env.domains[domain_name]\n436                 for indexcls in domain.indices:\n437                     indexname = '%s-%s' % (domain.name, indexcls.name)\n438                     if isinstance(indices_config, list):\n439                         if indexname not in indices_config:\n440                             continue\n441                     content, collapse = indexcls(domain).generate()\n442                     if content:\n443                         self.domain_indices.append(\n444                             (indexname, indexcls, content, collapse))\n445 \n446         # format the \"last updated on\" string, only once is enough since it\n447         # typically doesn't include the time of day\n448         lufmt = self.config.html_last_updated_fmt\n449         if lufmt is not None:\n450             self.last_updated = format_date(lufmt or _('%b %d, %Y'),\n451                                             language=self.config.language)\n452         else:\n453             self.last_updated = None\n454 \n455         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''\n456         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''\n457 \n458         self.relations = self.env.collect_relations()\n459 \n460         rellinks = []  # type: List[Tuple[str, str, str, str]]\n461         if self.use_index:\n462             rellinks.append(('genindex', _('General Index'), 'I', _('index')))\n463         for indexname, indexcls, content, collapse in self.domain_indices:\n464             # if it has a short name\n465             if indexcls.shortname:\n466                 rellinks.append((indexname, indexcls.localname,\n467                                  '', indexcls.shortname))\n468 \n469         # back up script_files and css_files to allow adding JS/CSS files to a specific page.\n470         self._script_files = list(self.script_files)\n471         self._css_files = list(self.css_files)\n472 \n473         if self.config.html_style is not None:\n474             stylename = self.config.html_style\n475         elif self.theme:\n476             stylename = self.theme.get_config('theme', 'stylesheet')\n477         else:\n478             stylename = 'default.css'\n479 \n480         self.globalcontext = {\n481             'embedded': self.embedded,\n482             'project': self.config.project,\n483             'release': return_codes_re.sub('', self.config.release),\n484             'version': self.config.version,\n485             'last_updated': self.last_updated,\n486             'copyright': self.config.copyright,\n487             'master_doc': self.config.master_doc,\n488             'use_opensearch': self.config.html_use_opensearch,\n489             'docstitle': self.config.html_title,\n490             'shorttitle': self.config.html_short_title,\n491             'show_copyright': self.config.html_show_copyright,\n492             'show_sphinx': self.config.html_show_sphinx,\n493             'has_source': self.config.html_copy_source,\n494             'show_source': self.config.html_show_sourcelink,\n495             'sourcelink_suffix': self.config.html_sourcelink_suffix,\n496             'file_suffix': self.out_suffix,\n497             'link_suffix': self.link_suffix,\n498             'script_files': self.script_files,\n499             'language': self.config.language,\n500             'css_files': self.css_files,\n501             'sphinx_version': __display_version__,\n502             'style': stylename,\n503             'rellinks': rellinks,\n504             'builder': self.name,\n505             'parents': [],\n506             'logo': logo,\n507             'favicon': favicon,\n508             'html5_doctype': html5_ready and not self.config.html4_writer,\n509         }\n510         if self.theme:\n511             self.globalcontext.update(\n512                 ('theme_' + key, val) for (key, val) in\n513                 self.theme.get_options(self.theme_options).items())\n514         self.globalcontext.update(self.config.html_context)\n515 \n516     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:\n517         \"\"\"Collect items for the template context of a page.\"\"\"\n518         # find out relations\n519         prev = next = None\n520         parents = []\n521         rellinks = self.globalcontext['rellinks'][:]\n522         related = self.relations.get(docname)\n523         titles = self.env.titles\n524         if related and related[2]:\n525             try:\n526                 next = {\n527                     'link': self.get_relative_uri(docname, related[2]),\n528                     'title': self.render_partial(titles[related[2]])['title']\n529                 }\n530                 rellinks.append((related[2], next['title'], 'N', _('next')))\n531             except KeyError:\n532                 next = None\n533         if related and related[1]:\n534             try:\n535                 prev = {\n536                     'link': self.get_relative_uri(docname, related[1]),\n537                     'title': self.render_partial(titles[related[1]])['title']\n538                 }\n539                 rellinks.append((related[1], prev['title'], 'P', _('previous')))\n540             except KeyError:\n541                 # the relation is (somehow) not in the TOC tree, handle\n542                 # that gracefully\n543                 prev = None\n544         while related and related[0]:\n545             try:\n546                 parents.append(\n547                     {'link': self.get_relative_uri(docname, related[0]),\n548                      'title': self.render_partial(titles[related[0]])['title']})\n549             except KeyError:\n550                 pass\n551             related = self.relations.get(related[0])\n552         if parents:\n553             # remove link to the master file; we have a generic\n554             # \"back to index\" link already\n555             parents.pop()\n556         parents.reverse()\n557 \n558         # title rendered as HTML\n559         title_node = self.env.longtitles.get(docname)\n560         title = self.render_partial(title_node)['title'] if title_node else ''\n561 \n562         # Suffix for the document\n563         source_suffix = self.env.doc2path(docname, False)[len(docname):]\n564 \n565         # the name for the copied source\n566         if self.config.html_copy_source:\n567             sourcename = docname + source_suffix\n568             if source_suffix != self.config.html_sourcelink_suffix:\n569                 sourcename += self.config.html_sourcelink_suffix\n570         else:\n571             sourcename = ''\n572 \n573         # metadata for the document\n574         meta = self.env.metadata.get(docname)\n575 \n576         # local TOC and global TOC tree\n577         self_toc = TocTree(self.env).get_toc_for(docname, self)\n578         toc = self.render_partial(self_toc)['fragment']\n579 \n580         return {\n581             'parents': parents,\n582             'prev': prev,\n583             'next': next,\n584             'title': title,\n585             'meta': meta,\n586             'body': body,\n587             'metatags': metatags,\n588             'rellinks': rellinks,\n589             'sourcename': sourcename,\n590             'toc': toc,\n591             # only display a TOC if there's more than one item to show\n592             'display_toc': (self.env.toc_num_entries[docname] > 1),\n593             'page_source_suffix': source_suffix,\n594         }\n595 \n596     def write_doc(self, docname: str, doctree: nodes.document) -> None:\n597         destination = StringOutput(encoding='utf-8')\n598         doctree.settings = self.docsettings\n599 \n600         self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n601         self.fignumbers = self.env.toc_fignumbers.get(docname, {})\n602         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')\n603         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')\n604         self.current_docname = docname\n605         self.docwriter.write(doctree, destination)\n606         self.docwriter.assemble_parts()\n607         body = self.docwriter.parts['fragment']\n608         metatags = self.docwriter.clean_meta\n609 \n610         ctx = self.get_doc_context(docname, body, metatags)\n611         self.handle_page(docname, ctx, event_arg=doctree)\n612 \n613     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n614         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)\n615         self.post_process_images(doctree)\n616         title_node = self.env.longtitles.get(docname)\n617         title = self.render_partial(title_node)['title'] if title_node else ''\n618         self.index_page(docname, doctree, title)\n619 \n620     def finish(self) -> None:\n621         self.finish_tasks.add_task(self.gen_indices)\n622         self.finish_tasks.add_task(self.gen_pages_from_extensions)\n623         self.finish_tasks.add_task(self.gen_additional_pages)\n624         self.finish_tasks.add_task(self.copy_image_files)\n625         self.finish_tasks.add_task(self.copy_download_files)\n626         self.finish_tasks.add_task(self.copy_static_files)\n627         self.finish_tasks.add_task(self.copy_extra_files)\n628         self.finish_tasks.add_task(self.write_buildinfo)\n629 \n630         # dump the search index\n631         self.handle_finish()\n632 \n633     @progress_message(__('generating indices'))\n634     def gen_indices(self) -> None:\n635         # the global general index\n636         if self.use_index:\n637             self.write_genindex()\n638 \n639         # the global domain-specific indices\n640         self.write_domain_indices()\n641 \n642     def gen_pages_from_extensions(self) -> None:\n643         # pages from extensions\n644         for pagelist in self.events.emit('html-collect-pages'):\n645             for pagename, context, template in pagelist:\n646                 self.handle_page(pagename, context, template)\n647 \n648     @progress_message(__('writing additional pages'))\n649     def gen_additional_pages(self) -> None:\n650         # additional pages from conf.py\n651         for pagename, template in self.config.html_additional_pages.items():\n652             logger.info(pagename + ' ', nonl=True)\n653             self.handle_page(pagename, {}, template)\n654 \n655         # the search page\n656         if self.search:\n657             logger.info('search ', nonl=True)\n658             self.handle_page('search', {}, 'search.html')\n659 \n660         # the opensearch xml file\n661         if self.config.html_use_opensearch and self.search:\n662             logger.info('opensearch ', nonl=True)\n663             fn = path.join(self.outdir, '_static', 'opensearch.xml')\n664             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)\n665 \n666     def write_genindex(self) -> None:\n667         # the total count of lines for each index letter, used to distribute\n668         # the entries into two columns\n669         genindex = IndexEntries(self.env).create_index(self)\n670         indexcounts = []\n671         for _k, entries in genindex:\n672             indexcounts.append(sum(1 + len(subitems)\n673                                    for _, (_, subitems, _) in entries))\n674 \n675         genindexcontext = {\n676             'genindexentries': genindex,\n677             'genindexcounts': indexcounts,\n678             'split_index': self.config.html_split_index,\n679         }\n680         logger.info('genindex ', nonl=True)\n681 \n682         if self.config.html_split_index:\n683             self.handle_page('genindex', genindexcontext,\n684                              'genindex-split.html')\n685             self.handle_page('genindex-all', genindexcontext,\n686                              'genindex.html')\n687             for (key, entries), count in zip(genindex, indexcounts):\n688                 ctx = {'key': key, 'entries': entries, 'count': count,\n689                        'genindexentries': genindex}\n690                 self.handle_page('genindex-' + key, ctx,\n691                                  'genindex-single.html')\n692         else:\n693             self.handle_page('genindex', genindexcontext, 'genindex.html')\n694 \n695     def write_domain_indices(self) -> None:\n696         for indexname, indexcls, content, collapse in self.domain_indices:\n697             indexcontext = {\n698                 'indextitle': indexcls.localname,\n699                 'content': content,\n700                 'collapse_index': collapse,\n701             }\n702             logger.info(indexname + ' ', nonl=True)\n703             self.handle_page(indexname, indexcontext, 'domainindex.html')\n704 \n705     def copy_image_files(self) -> None:\n706         if self.images:\n707             stringify_func = ImageAdapter(self.app.env).get_original_image_uri\n708             ensuredir(path.join(self.outdir, self.imagedir))\n709             for src in status_iterator(self.images, __('copying images... '), \"brown\",\n710                                        len(self.images), self.app.verbosity,\n711                                        stringify_func=stringify_func):\n712                 dest = self.images[src]\n713                 try:\n714                     copyfile(path.join(self.srcdir, src),\n715                              path.join(self.outdir, self.imagedir, dest))\n716                 except Exception as err:\n717                     logger.warning(__('cannot copy image file %r: %s'),\n718                                    path.join(self.srcdir, src), err)\n719 \n720     def copy_download_files(self) -> None:\n721         def to_relpath(f: str) -> str:\n722             return relative_path(self.srcdir, f)\n723 \n724         # copy downloadable files\n725         if self.env.dlfiles:\n726             ensuredir(path.join(self.outdir, '_downloads'))\n727             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),\n728                                        \"brown\", len(self.env.dlfiles), self.app.verbosity,\n729                                        stringify_func=to_relpath):\n730                 try:\n731                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])\n732                     ensuredir(path.dirname(dest))\n733                     copyfile(path.join(self.srcdir, src), dest)\n734                 except OSError as err:\n735                     logger.warning(__('cannot copy downloadable file %r: %s'),\n736                                    path.join(self.srcdir, src), err)\n737 \n738     def create_pygments_style_file(self) -> None:\n739         \"\"\"create a style file for pygments.\"\"\"\n740         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:\n741             f.write(self.highlighter.get_stylesheet())\n742 \n743         if self.dark_highlighter:\n744             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:\n745                 f.write(self.dark_highlighter.get_stylesheet())\n746 \n747     def copy_translation_js(self) -> None:\n748         \"\"\"Copy a JavaScript file for translations.\"\"\"\n749         if self.config.language is not None:\n750             jsfile = self._get_translations_js()\n751             if jsfile:\n752                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))\n753 \n754     def copy_stemmer_js(self) -> None:\n755         \"\"\"Copy a JavaScript file for stemmer.\"\"\"\n756         if self.indexer is not None:\n757             jsfile = self.indexer.get_js_stemmer_rawcode()\n758             if jsfile:\n759                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))\n760 \n761     def copy_theme_static_files(self, context: Dict) -> None:\n762         def onerror(filename: str, error: Exception) -> None:\n763             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),\n764                            filename, error)\n765 \n766         if self.theme:\n767             for entry in self.theme.get_theme_dirs()[::-1]:\n768                 copy_asset(path.join(entry, 'static'),\n769                            path.join(self.outdir, '_static'),\n770                            excluded=DOTFILES, context=context,\n771                            renderer=self.templates, onerror=onerror)\n772 \n773     def copy_html_static_files(self, context: Dict) -> None:\n774         def onerror(filename: str, error: Exception) -> None:\n775             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),\n776                            filename, error)\n777 \n778         excluded = Matcher(self.config.exclude_patterns + [\"**/.*\"])\n779         for entry in self.config.html_static_path:\n780             copy_asset(path.join(self.confdir, entry),\n781                        path.join(self.outdir, '_static'),\n782                        excluded, context=context, renderer=self.templates, onerror=onerror)\n783 \n784     def copy_html_logo(self) -> None:\n785         if self.config.html_logo:\n786             copy_asset(path.join(self.confdir, self.config.html_logo),\n787                        path.join(self.outdir, '_static'))\n788 \n789     def copy_html_favicon(self) -> None:\n790         if self.config.html_favicon:\n791             copy_asset(path.join(self.confdir, self.config.html_favicon),\n792                        path.join(self.outdir, '_static'))\n793 \n794     def copy_static_files(self) -> None:\n795         try:\n796             with progress_message(__('copying static files')):\n797                 ensuredir(path.join(self.outdir, '_static'))\n798 \n799                 # prepare context for templates\n800                 context = self.globalcontext.copy()\n801                 if self.indexer is not None:\n802                     context.update(self.indexer.context_for_searchtool())\n803 \n804                 self.create_pygments_style_file()\n805                 self.copy_translation_js()\n806                 self.copy_stemmer_js()\n807                 self.copy_theme_static_files(context)\n808                 self.copy_html_static_files(context)\n809                 self.copy_html_logo()\n810                 self.copy_html_favicon()\n811         except OSError as err:\n812             logger.warning(__('cannot copy static file %r'), err)\n813 \n814     def copy_extra_files(self) -> None:\n815         \"\"\"copy html_extra_path files.\"\"\"\n816         try:\n817             with progress_message(__('copying extra files')):\n818                 excluded = Matcher(self.config.exclude_patterns)\n819                 for extra_path in self.config.html_extra_path:\n820                     entry = path.join(self.confdir, extra_path)\n821                     copy_asset(entry, self.outdir, excluded)\n822         except OSError as err:\n823             logger.warning(__('cannot copy extra file %r'), err)\n824 \n825     def write_buildinfo(self) -> None:\n826         try:\n827             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:\n828                 self.build_info.dump(fp)\n829         except OSError as exc:\n830             logger.warning(__('Failed to write build info file: %r'), exc)\n831 \n832     def cleanup(self) -> None:\n833         # clean up theme stuff\n834         if self.theme:\n835             self.theme.cleanup()\n836 \n837     def post_process_images(self, doctree: Node) -> None:\n838         \"\"\"Pick the best candidate for an image and link down-scaled images to\n839         their high res version.\n840         \"\"\"\n841         Builder.post_process_images(self, doctree)\n842 \n843         if self.config.html_scaled_image_link and self.html_scaled_image_link:\n844             for node in doctree.traverse(nodes.image):\n845                 if not any((key in node) for key in ['scale', 'width', 'height']):\n846                     # resizing options are not given. scaled image link is available\n847                     # only for resized images.\n848                     continue\n849                 elif isinstance(node.parent, nodes.reference):\n850                     # A image having hyperlink target\n851                     continue\n852                 elif 'no-scaled-link' in node['classes']:\n853                     # scaled image link is disabled for this node\n854                     continue\n855 \n856                 uri = node['uri']\n857                 reference = nodes.reference('', '', internal=True)\n858                 if uri in self.images:\n859                     reference['refuri'] = posixpath.join(self.imgpath,\n860                                                          self.images[uri])\n861                 else:\n862                     reference['refuri'] = uri\n863                 node.replace_self(reference)\n864                 reference.append(node)\n865 \n866     def load_indexer(self, docnames: Iterable[str]) -> None:\n867         keep = set(self.env.all_docs) - set(docnames)\n868         try:\n869             searchindexfn = path.join(self.outdir, self.searchindex_filename)\n870             if self.indexer_dumps_unicode:\n871                 with open(searchindexfn, encoding='utf-8') as ft:\n872                     self.indexer.load(ft, self.indexer_format)\n873             else:\n874                 with open(searchindexfn, 'rb') as fb:\n875                     self.indexer.load(fb, self.indexer_format)\n876         except (OSError, ValueError):\n877             if keep:\n878                 logger.warning(__('search index couldn\\'t be loaded, but not all '\n879                                   'documents will be built: the index will be '\n880                                   'incomplete.'))\n881         # delete all entries for files that will be rebuilt\n882         self.indexer.prune(keep)\n883 \n884     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:\n885         # only index pages with title\n886         if self.indexer is not None and title:\n887             filename = self.env.doc2path(pagename, base=None)\n888             try:\n889                 metadata = self.env.metadata.get(pagename, {})\n890                 if 'nosearch' in metadata:\n891                     self.indexer.feed(pagename, filename, '', new_document(''))\n892                 else:\n893                     self.indexer.feed(pagename, filename, title, doctree)\n894             except TypeError:\n895                 # fallback for old search-adapters\n896                 self.indexer.feed(pagename, title, doctree)  # type: ignore\n897                 indexer_name = self.indexer.__class__.__name__\n898                 warnings.warn(\n899                     'The %s.feed() method signature is deprecated. Update to '\n900                     '%s.feed(docname, filename, title, doctree).' % (\n901                         indexer_name, indexer_name),\n902                     RemovedInSphinx40Warning, stacklevel=2)\n903 \n904     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:\n905         if 'includehidden' not in kwargs:\n906             kwargs['includehidden'] = False\n907         if kwargs.get('maxdepth') == '':\n908             kwargs.pop('maxdepth')\n909         return self.render_partial(TocTree(self.env).get_toctree_for(\n910             docname, self, collapse, **kwargs))['fragment']\n911 \n912     def get_outfilename(self, pagename: str) -> str:\n913         return path.join(self.outdir, os_path(pagename) + self.out_suffix)\n914 \n915     def add_sidebars(self, pagename: str, ctx: Dict) -> None:\n916         def has_wildcard(pattern: str) -> bool:\n917             return any(char in pattern for char in '*?[')\n918 \n919         sidebars = None\n920         matched = None\n921         customsidebar = None\n922 \n923         # default sidebars settings for selected theme\n924         if self.theme.name == 'alabaster':\n925             # provide default settings for alabaster (for compatibility)\n926             # Note: this will be removed before Sphinx-2.0\n927             try:\n928                 # get default sidebars settings from alabaster (if defined)\n929                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')\n930                 if theme_default_sidebars:\n931                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]\n932             except Exception:\n933                 # fallback to better default settings\n934                 sidebars = ['about.html', 'navigation.html', 'relations.html',\n935                             'searchbox.html', 'donate.html']\n936         else:\n937             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)\n938             if theme_default_sidebars:\n939                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]\n940 \n941         # user sidebar settings\n942         html_sidebars = self.get_builder_config('sidebars', 'html')\n943         for pattern, patsidebars in html_sidebars.items():\n944             if patmatch(pagename, pattern):\n945                 if matched:\n946                     if has_wildcard(pattern):\n947                         # warn if both patterns contain wildcards\n948                         if has_wildcard(matched):\n949                             logger.warning(__('page %s matches two patterns in '\n950                                               'html_sidebars: %r and %r'),\n951                                            pagename, matched, pattern)\n952                         # else the already matched pattern is more specific\n953                         # than the present one, because it contains no wildcard\n954                         continue\n955                 matched = pattern\n956                 sidebars = patsidebars\n957 \n958         if sidebars is None:\n959             # keep defaults\n960             pass\n961 \n962         ctx['sidebars'] = sidebars\n963         ctx['customsidebar'] = customsidebar\n964 \n965     # --------- these are overwritten by the serialization builder\n966 \n967     def get_target_uri(self, docname: str, typ: str = None) -> str:\n968         return quote(docname) + self.link_suffix\n969 \n970     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',\n971                     outfilename: str = None, event_arg: Any = None) -> None:\n972         ctx = self.globalcontext.copy()\n973         # current_page_name is backwards compatibility\n974         ctx['pagename'] = ctx['current_page_name'] = pagename\n975         ctx['encoding'] = self.config.html_output_encoding\n976         default_baseuri = self.get_target_uri(pagename)\n977         # in the singlehtml builder, default_baseuri still contains an #anchor\n978         # part, which relative_uri doesn't really like...\n979         default_baseuri = default_baseuri.rsplit('#', 1)[0]\n980 \n981         if self.config.html_baseurl:\n982             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,\n983                                             pagename + self.out_suffix)\n984         else:\n985             ctx['pageurl'] = None\n986 \n987         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA\n988             if resource and '://' in otheruri:\n989                 # allow non-local resources given by scheme\n990                 return otheruri\n991             elif not resource:\n992                 otheruri = self.get_target_uri(otheruri)\n993             uri = relative_uri(baseuri, otheruri) or '#'\n994             if uri == '#' and not self.allow_sharp_as_current_path:\n995                 uri = baseuri\n996             return uri\n997         ctx['pathto'] = pathto\n998 \n999         def css_tag(css: Stylesheet) -> str:\n1000             attrs = []\n1001             for key in sorted(css.attributes):\n1002                 value = css.attributes[key]\n1003                 if value is not None:\n1004                     attrs.append('%s=\"%s\"' % (key, html.escape(value, True)))\n1005             attrs.append('href=\"%s\"' % pathto(css.filename, resource=True))\n1006             return '<link %s />' % ' '.join(attrs)\n1007         ctx['css_tag'] = css_tag\n1008 \n1009         def hasdoc(name: str) -> bool:\n1010             if name in self.env.all_docs:\n1011                 return True\n1012             elif name == 'search' and self.search:\n1013                 return True\n1014             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):\n1015                 return True\n1016             return False\n1017         ctx['hasdoc'] = hasdoc\n1018 \n1019         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)\n1020         self.add_sidebars(pagename, ctx)\n1021         ctx.update(addctx)\n1022 \n1023         # revert script_files and css_files\n1024         self.script_files[:] = self._script_files\n1025         self.css_files[:] = self.css_files\n1026 \n1027         self.update_page_context(pagename, templatename, ctx, event_arg)\n1028         newtmpl = self.app.emit_firstresult('html-page-context', pagename,\n1029                                             templatename, ctx, event_arg)\n1030         if newtmpl:\n1031             templatename = newtmpl\n1032 \n1033         # sort JS/CSS before rendering HTML\n1034         ctx['script_files'].sort(key=lambda js: js.priority)\n1035         ctx['css_files'].sort(key=lambda js: js.priority)\n1036 \n1037         try:\n1038             output = self.templates.render(templatename, ctx)\n1039         except UnicodeError:\n1040             logger.warning(__(\"a Unicode error occurred when rendering the page %s. \"\n1041                               \"Please make sure all config values that contain \"\n1042                               \"non-ASCII content are Unicode strings.\"), pagename)\n1043             return\n1044         except Exception as exc:\n1045             raise ThemeError(__(\"An error happened in rendering the page %s.\\nReason: %r\") %\n1046                              (pagename, exc)) from exc\n1047 \n1048         if not outfilename:\n1049             outfilename = self.get_outfilename(pagename)\n1050         # outfilename's path is in general different from self.outdir\n1051         ensuredir(path.dirname(outfilename))\n1052         try:\n1053             with open(outfilename, 'w', encoding=ctx['encoding'],\n1054                       errors='xmlcharrefreplace') as f:\n1055                 f.write(output)\n1056         except OSError as err:\n1057             logger.warning(__(\"error writing file %s: %s\"), outfilename, err)\n1058         if self.copysource and ctx.get('sourcename'):\n1059             # copy the source file for the \"show source\" link\n1060             source_name = path.join(self.outdir, '_sources',\n1061                                     os_path(ctx['sourcename']))\n1062             ensuredir(path.dirname(source_name))\n1063             copyfile(self.env.doc2path(pagename), source_name)\n1064 \n1065     def update_page_context(self, pagename: str, templatename: str,\n1066                             ctx: Dict, event_arg: Any) -> None:\n1067         pass\n1068 \n1069     def handle_finish(self) -> None:\n1070         if self.indexer:\n1071             self.finish_tasks.add_task(self.dump_search_index)\n1072         self.finish_tasks.add_task(self.dump_inventory)\n1073 \n1074     @progress_message(__('dumping object inventory'))\n1075     def dump_inventory(self) -> None:\n1076         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)\n1077 \n1078     def dump_search_index(self) -> None:\n1079         with progress_message(__('dumping search index in %s') % self.indexer.label()):\n1080             self.indexer.prune(self.env.all_docs)\n1081             searchindexfn = path.join(self.outdir, self.searchindex_filename)\n1082             # first write to a temporary file, so that if dumping fails,\n1083             # the existing index won't be overwritten\n1084             if self.indexer_dumps_unicode:\n1085                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:\n1086                     self.indexer.dump(ft, self.indexer_format)\n1087             else:\n1088                 with open(searchindexfn + '.tmp', 'wb') as fb:\n1089                     self.indexer.dump(fb, self.indexer_format)\n1090             os.replace(searchindexfn + '.tmp', searchindexfn)\n1091 \n1092 \n1093 def convert_html_css_files(app: Sphinx, config: Config) -> None:\n1094     \"\"\"This converts string styled html_css_files to tuple styled one.\"\"\"\n1095     html_css_files = []  # type: List[Tuple[str, Dict]]\n1096     for entry in config.html_css_files:\n1097         if isinstance(entry, str):\n1098             html_css_files.append((entry, {}))\n1099         else:\n1100             try:\n1101                 filename, attrs = entry\n1102                 html_css_files.append((filename, attrs))\n1103             except Exception:\n1104                 logger.warning(__('invalid css_file: %r, ignored'), entry)\n1105                 continue\n1106 \n1107     config.html_css_files = html_css_files  # type: ignore\n1108 \n1109 \n1110 def convert_html_js_files(app: Sphinx, config: Config) -> None:\n1111     \"\"\"This converts string styled html_js_files to tuple styled one.\"\"\"\n1112     html_js_files = []  # type: List[Tuple[str, Dict]]\n1113     for entry in config.html_js_files:\n1114         if isinstance(entry, str):\n1115             html_js_files.append((entry, {}))\n1116         else:\n1117             try:\n1118                 filename, attrs = entry\n1119                 html_js_files.append((filename, attrs))\n1120             except Exception:\n1121                 logger.warning(__('invalid js_file: %r, ignored'), entry)\n1122                 continue\n1123 \n1124     config.html_js_files = html_js_files  # type: ignore\n1125 \n1126 \n1127 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,\n1128                         context: Dict, doctree: Node) -> None:\n1129     \"\"\"Set up js_tag() template helper.\n1130 \n1131     .. note:: This set up function is added to keep compatibility with webhelper.\n1132     \"\"\"\n1133     pathto = context.get('pathto')\n1134 \n1135     def js_tag(js: JavaScript) -> str:\n1136         attrs = []\n1137         body = ''\n1138         if isinstance(js, JavaScript):\n1139             for key in sorted(js.attributes):\n1140                 value = js.attributes[key]\n1141                 if value is not None:\n1142                     if key == 'body':\n1143                         body = value\n1144                     else:\n1145                         attrs.append('%s=\"%s\"' % (key, html.escape(value, True)))\n1146             if js.filename:\n1147                 attrs.append('src=\"%s\"' % pathto(js.filename, resource=True))\n1148         else:\n1149             # str value (old styled)\n1150             attrs.append('src=\"%s\"' % pathto(js, resource=True))\n1151         return '<script %s>%s</script>' % (' '.join(attrs), body)\n1152 \n1153     context['js_tag'] = js_tag\n1154 \n1155 \n1156 def validate_math_renderer(app: Sphinx) -> None:\n1157     if app.builder.format != 'html':\n1158         return\n1159 \n1160     name = app.builder.math_renderer_name  # type: ignore\n1161     if name is None:\n1162         raise ConfigError(__('Many math_renderers are registered. '\n1163                              'But no math_renderer is selected.'))\n1164     elif name not in app.registry.html_inline_math_renderers:\n1165         raise ConfigError(__('Unknown math_renderer %r is given.') % name)\n1166 \n1167 \n1168 def validate_html_extra_path(app: Sphinx, config: Config) -> None:\n1169     \"\"\"Check html_extra_paths setting.\"\"\"\n1170     for entry in config.html_extra_path[:]:\n1171         extra_path = path.normpath(path.join(app.confdir, entry))\n1172         if not path.exists(extra_path):\n1173             logger.warning(__('html_extra_path entry %r does not exist'), entry)\n1174             config.html_extra_path.remove(entry)\n1175         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and\n1176               path.commonpath([app.outdir, extra_path]) == app.outdir):\n1177             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)\n1178             config.html_extra_path.remove(entry)\n1179 \n1180 \n1181 def validate_html_static_path(app: Sphinx, config: Config) -> None:\n1182     \"\"\"Check html_static_paths setting.\"\"\"\n1183     for entry in config.html_static_path[:]:\n1184         static_path = path.normpath(path.join(app.confdir, entry))\n1185         if not path.exists(static_path):\n1186             logger.warning(__('html_static_path entry %r does not exist'), entry)\n1187             config.html_static_path.remove(entry)\n1188         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and\n1189               path.commonpath([app.outdir, static_path]) == app.outdir):\n1190             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)\n1191             config.html_static_path.remove(entry)\n1192 \n1193 \n1194 def validate_html_logo(app: Sphinx, config: Config) -> None:\n1195     \"\"\"Check html_logo setting.\"\"\"\n1196     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):\n1197         logger.warning(__('logo file %r does not exist'), config.html_logo)\n1198         config.html_logo = None  # type: ignore\n1199 \n1200 \n1201 def validate_html_favicon(app: Sphinx, config: Config) -> None:\n1202     \"\"\"Check html_favicon setting.\"\"\"\n1203     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):\n1204         logger.warning(__('favicon file %r does not exist'), config.html_favicon)\n1205         config.html_favicon = None  # type: ignore\n1206 \n1207 \n1208 # for compatibility\n1209 import sphinxcontrib.serializinghtml  # NOQA\n1210 \n1211 import sphinx.builders.dirhtml  # NOQA\n1212 import sphinx.builders.singlehtml  # NOQA\n1213 \n1214 \n1215 def setup(app: Sphinx) -> Dict[str, Any]:\n1216     # builders\n1217     app.add_builder(StandaloneHTMLBuilder)\n1218 \n1219     # config values\n1220     app.add_config_value('html_theme', 'alabaster', 'html')\n1221     app.add_config_value('html_theme_path', [], 'html')\n1222     app.add_config_value('html_theme_options', {}, 'html')\n1223     app.add_config_value('html_title',\n1224                          lambda self: _('%s %s documentation') % (self.project, self.release),\n1225                          'html', [str])\n1226     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')\n1227     app.add_config_value('html_style', None, 'html', [str])\n1228     app.add_config_value('html_logo', None, 'html', [str])\n1229     app.add_config_value('html_favicon', None, 'html', [str])\n1230     app.add_config_value('html_css_files', [], 'html')\n1231     app.add_config_value('html_js_files', [], 'html')\n1232     app.add_config_value('html_static_path', [], 'html')\n1233     app.add_config_value('html_extra_path', [], 'html')\n1234     app.add_config_value('html_last_updated_fmt', None, 'html', [str])\n1235     app.add_config_value('html_sidebars', {}, 'html')\n1236     app.add_config_value('html_additional_pages', {}, 'html')\n1237     app.add_config_value('html_domain_indices', True, 'html', [list])\n1238     app.add_config_value('html_add_permalinks', '\u00b6', 'html')\n1239     app.add_config_value('html_use_index', True, 'html')\n1240     app.add_config_value('html_split_index', False, 'html')\n1241     app.add_config_value('html_copy_source', True, 'html')\n1242     app.add_config_value('html_show_sourcelink', True, 'html')\n1243     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')\n1244     app.add_config_value('html_use_opensearch', '', 'html')\n1245     app.add_config_value('html_file_suffix', None, 'html', [str])\n1246     app.add_config_value('html_link_suffix', None, 'html', [str])\n1247     app.add_config_value('html_show_copyright', True, 'html')\n1248     app.add_config_value('html_show_sphinx', True, 'html')\n1249     app.add_config_value('html_context', {}, 'html')\n1250     app.add_config_value('html_output_encoding', 'utf-8', 'html')\n1251     app.add_config_value('html_compact_lists', True, 'html')\n1252     app.add_config_value('html_secnumber_suffix', '. ', 'html')\n1253     app.add_config_value('html_search_language', None, 'html', [str])\n1254     app.add_config_value('html_search_options', {}, 'html')\n1255     app.add_config_value('html_search_scorer', '', None)\n1256     app.add_config_value('html_scaled_image_link', True, 'html')\n1257     app.add_config_value('html_baseurl', '', 'html')\n1258     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',\n1259                          ENUM('table', 'inline'))\n1260     app.add_config_value('html_math_renderer', None, 'env')\n1261     app.add_config_value('html4_writer', False, 'html')\n1262 \n1263     # events\n1264     app.add_event('html-collect-pages')\n1265     app.add_event('html-page-context')\n1266 \n1267     # event handlers\n1268     app.connect('config-inited', convert_html_css_files, priority=800)\n1269     app.connect('config-inited', convert_html_js_files, priority=800)\n1270     app.connect('config-inited', validate_html_extra_path, priority=800)\n1271     app.connect('config-inited', validate_html_static_path, priority=800)\n1272     app.connect('config-inited', validate_html_logo, priority=800)\n1273     app.connect('config-inited', validate_html_favicon, priority=800)\n1274     app.connect('builder-inited', validate_math_renderer)\n1275     app.connect('html-page-context', setup_js_tag_helper)\n1276 \n1277     # load default math renderer\n1278     app.setup_extension('sphinx.ext.mathjax')\n1279 \n1280     # load transforms for HTML builder\n1281     app.setup_extension('sphinx.builders.html.transforms')\n1282 \n1283     return {\n1284         'version': 'builtin',\n1285         'parallel_read_safe': True,\n1286         'parallel_write_safe': True,\n1287     }\n",
        "intended_behavior": "This file should include or be modified to ensure that when handling file paths for resources like downloads or figures, all path references are normalized using os.path.normpath() (or a Sphinx equivalent function if it wraps path operations for cross-platform compatibility). Additionally, before treating any file as a duplicate, the code should verify whether the normalized paths actually point to the different resources. This process will prevent the issue where the same file is interpreted as multiple files when referenced in various ways."
    },
    {
        "rel_file_path": "sphinx/environment/collectors/dependencies.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/environment/collectors/dependencies.py",
        "start": 1,
        "end": 60,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.environment.collectors.dependencies\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     The dependencies collector components for sphinx.environment.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import os\n12 from os import path\n13 from typing import Any, Dict, Set\n14 \n15 from docutils import nodes\n16 from docutils.utils import relative_path\n17 \n18 from sphinx.application import Sphinx\n19 from sphinx.environment import BuildEnvironment\n20 from sphinx.environment.collectors import EnvironmentCollector\n21 from sphinx.util.osutil import fs_encoding\n22 \n23 \n24 class DependenciesCollector(EnvironmentCollector):\n25     \"\"\"dependencies collector for sphinx.environment.\"\"\"\n26 \n27     def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -> None:\n28         env.dependencies.pop(docname, None)\n29 \n30     def merge_other(self, app: Sphinx, env: BuildEnvironment,\n31                     docnames: Set[str], other: BuildEnvironment) -> None:\n32         for docname in docnames:\n33             if docname in other.dependencies:\n34                 env.dependencies[docname] = other.dependencies[docname]\n35 \n36     def process_doc(self, app: Sphinx, doctree: nodes.document) -> None:\n37         \"\"\"Process docutils-generated dependency info.\"\"\"\n38         cwd = os.getcwd()\n39         frompath = path.join(path.normpath(app.srcdir), 'dummy')\n40         deps = doctree.settings.record_dependencies\n41         if not deps:\n42             return\n43         for dep in deps.list:\n44             # the dependency path is relative to the working dir, so get\n45             # one relative to the srcdir\n46             if isinstance(dep, bytes):\n47                 dep = dep.decode(fs_encoding)\n48             relpath = relative_path(frompath,\n49                                     path.normpath(path.join(cwd, dep)))\n50             app.env.dependencies[app.env.docname].add(relpath)\n51 \n52 \n53 def setup(app: Sphinx) -> Dict[str, Any]:\n54     app.add_env_collector(DependenciesCollector)\n55 \n56     return {\n57         'version': 'builtin',\n58         'parallel_read_safe': True,\n59         'parallel_write_safe': True,\n60     }\n",
        "intended_behavior": "This file, likely involved in tracking and managing file dependencies within the Sphinx build environment, should be modified to ensure that any comparisons or operations on file paths are conducted on normalized paths. This will aid in accurately tracking file dependencies and usage without falsely identifying the same file as multiple ones due to path differences."
    }
]