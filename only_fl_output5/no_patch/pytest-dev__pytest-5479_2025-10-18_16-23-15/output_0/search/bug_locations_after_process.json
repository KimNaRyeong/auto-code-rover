[
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.6/src/_pytest/python_api.py",
        "start": 556,
        "end": 716,
        "class_name": null,
        "method_name": "raises",
        "code": "556 def raises(expected_exception, *args, **kwargs):\n557     r\"\"\"\n558     Assert that a code block/function call raises ``expected_exception``\n559     or raise a failure exception otherwise.\n560 \n561     :kwparam match: if specified, a string containing a regular expression,\n562         or a regular expression object, that is tested against the string\n563         representation of the exception using ``re.search``. To match a literal\n564         string that may contain `special characters`__, the pattern can\n565         first be escaped with ``re.escape``.\n566 \n567     __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n568 \n569     :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n570         if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n571 \n572     .. currentmodule:: _pytest._code\n573 \n574     Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n575     type::\n576 \n577         >>> with raises(ZeroDivisionError):\n578         ...    1/0\n579 \n580     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n581     above), or no exception at all, the check will fail instead.\n582 \n583     You can also use the keyword argument ``match`` to assert that the\n584     exception matches a text or regex::\n585 \n586         >>> with raises(ValueError, match='must be 0 or None'):\n587         ...     raise ValueError(\"value must be 0 or None\")\n588 \n589         >>> with raises(ValueError, match=r'must be \\d+$'):\n590         ...     raise ValueError(\"value must be 42\")\n591 \n592     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n593     details of the captured exception::\n594 \n595         >>> with raises(ValueError) as exc_info:\n596         ...     raise ValueError(\"value must be 42\")\n597         >>> assert exc_info.type is ValueError\n598         >>> assert exc_info.value.args[0] == \"value must be 42\"\n599 \n600     .. deprecated:: 4.1\n601 \n602         In the context manager form you may use the keyword argument\n603         ``message`` to specify a custom failure message that will be displayed\n604         in case the ``pytest.raises`` check fails. This has been deprecated as it\n605         is considered error prone as users often mean to use ``match`` instead.\n606         See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n607 \n608     .. note::\n609 \n610        When using ``pytest.raises`` as a context manager, it's worthwhile to\n611        note that normal context manager rules apply and that the exception\n612        raised *must* be the final line in the scope of the context manager.\n613        Lines of code after that, within the scope of the context manager will\n614        not be executed. For example::\n615 \n616            >>> value = 15\n617            >>> with raises(ValueError) as exc_info:\n618            ...     if value > 10:\n619            ...         raise ValueError(\"value must be <= 10\")\n620            ...     assert exc_info.type is ValueError  # this will not execute\n621 \n622        Instead, the following approach must be taken (note the difference in\n623        scope)::\n624 \n625            >>> with raises(ValueError) as exc_info:\n626            ...     if value > 10:\n627            ...         raise ValueError(\"value must be <= 10\")\n628            ...\n629            >>> assert exc_info.type is ValueError\n630 \n631     **Using with** ``pytest.mark.parametrize``\n632 \n633     When using :ref:`pytest.mark.parametrize ref`\n634     it is possible to parametrize tests such that\n635     some runs raise an exception and others do not.\n636 \n637     See :ref:`parametrizing_conditional_raising` for an example.\n638 \n639     **Legacy form**\n640 \n641     It is possible to specify a callable by passing a to-be-called lambda::\n642 \n643         >>> raises(ZeroDivisionError, lambda: 1/0)\n644         <ExceptionInfo ...>\n645 \n646     or you can specify an arbitrary callable with arguments::\n647 \n648         >>> def f(x): return 1/x\n649         ...\n650         >>> raises(ZeroDivisionError, f, 0)\n651         <ExceptionInfo ...>\n652         >>> raises(ZeroDivisionError, f, x=0)\n653         <ExceptionInfo ...>\n654 \n655     The form above is fully supported but discouraged for new code because the\n656     context manager form is regarded as more readable and less error-prone.\n657 \n658     .. note::\n659         Similar to caught exception objects in Python, explicitly clearing\n660         local references to returned ``ExceptionInfo`` objects can\n661         help the Python interpreter speed up its garbage collection.\n662 \n663         Clearing those references breaks a reference cycle\n664         (``ExceptionInfo`` --> caught exception --> frame stack raising\n665         the exception --> current frame stack --> local variables -->\n666         ``ExceptionInfo``) which makes Python keep all objects referenced\n667         from that cycle (including all local variables in the current\n668         frame) alive until the next cyclic garbage collection run. See the\n669         official Python ``try`` statement documentation for more detailed\n670         information.\n671 \n672     \"\"\"\n673     __tracebackhide__ = True\n674     for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n675         msg = (\n676             \"exceptions must be old-style classes or\"\n677             \" derived from BaseException, not %s\"\n678         )\n679         raise TypeError(msg % type(exc))\n680 \n681     message = \"DID NOT RAISE {}\".format(expected_exception)\n682     match_expr = None\n683 \n684     if not args:\n685         if \"message\" in kwargs:\n686             message = kwargs.pop(\"message\")\n687             warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n688         if \"match\" in kwargs:\n689             match_expr = kwargs.pop(\"match\")\n690         if kwargs:\n691             msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n692             msg += \", \".join(sorted(kwargs))\n693             raise TypeError(msg)\n694         return RaisesContext(expected_exception, message, match_expr)\n695     elif isinstance(args[0], str):\n696         warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n697         code, = args\n698         assert isinstance(code, str)\n699         frame = sys._getframe(1)\n700         loc = frame.f_locals.copy()\n701         loc.update(kwargs)\n702         # print \"raises frame scope: %r\" % frame.f_locals\n703         try:\n704             code = _pytest._code.Source(code).compile(_genframe=frame)\n705             exec(code, frame.f_globals, loc)\n706             # XXX didn't mean f_globals == f_locals something special?\n707             #     this is destroyed here ...\n708         except expected_exception:\n709             return _pytest._code.ExceptionInfo.from_current()\n710     else:\n711         func = args[0]\n712         try:\n713             func(*args[1:], **kwargs)\n714         except expected_exception:\n715             return _pytest._code.ExceptionInfo.from_current()\n716     fail(message)\n",
        "intended_behavior": "This method should be modified to ensure Unicode string compatibility, particularly when handling the match parameter under Python 2 environments. The modification must preserve the existing functionality for Python 3 users while introducing a reliable way to encode or decode Unicode exception messages before matching them against the pattern provided in the match parameter. A potential approach could involve conditionally encoding the exception message and the match pattern to a common encoding (e.g., 'utf-8') under Python 2 before attempting to match them. This ensures that the UnicodeEncodeError is avoided, and the function's existing functionality is preserved across different Python versions."
    }
]