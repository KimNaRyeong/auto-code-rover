[
    {
        "rel_file_path": "sphinx/environment/adapters/toctree.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/environment/adapters/toctree.py",
        "start": 1,
        "end": 336,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.environment.adapters.toctree\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Toctree adapter for sphinx.environment.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from typing import Any, Iterable, List\n12 from typing import cast\n13 \n14 from docutils import nodes\n15 from docutils.nodes import Element, Node\n16 \n17 from sphinx import addnodes\n18 from sphinx.locale import __\n19 from sphinx.util import url_re, logging\n20 from sphinx.util.matching import Matcher\n21 from sphinx.util.nodes import clean_astext, process_only_nodes\n22 \n23 if False:\n24     # For type annotation\n25     from sphinx.builders import Builder\n26     from sphinx.environment import BuildEnvironment\n27 \n28 \n29 logger = logging.getLogger(__name__)\n30 \n31 \n32 class TocTree:\n33     def __init__(self, env: \"BuildEnvironment\") -> None:\n34         self.env = env\n35 \n36     def note(self, docname: str, toctreenode: addnodes.toctree) -> None:\n37         \"\"\"Note a TOC tree directive in a document and gather information about\n38         file relations from it.\n39         \"\"\"\n40         if toctreenode['glob']:\n41             self.env.glob_toctrees.add(docname)\n42         if toctreenode.get('numbered'):\n43             self.env.numbered_toctrees.add(docname)\n44         includefiles = toctreenode['includefiles']\n45         for includefile in includefiles:\n46             # note that if the included file is rebuilt, this one must be\n47             # too (since the TOC of the included file could have changed)\n48             self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)\n49         self.env.toctree_includes.setdefault(docname, []).extend(includefiles)\n50 \n51     def resolve(self, docname: str, builder: \"Builder\", toctree: addnodes.toctree,\n52                 prune: bool = True, maxdepth: int = 0, titles_only: bool = False,\n53                 collapse: bool = False, includehidden: bool = False) -> Element:\n54         \"\"\"Resolve a *toctree* node into individual bullet lists with titles\n55         as items, returning None (if no containing titles are found) or\n56         a new node.\n57 \n58         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,\n59         to the value of the *maxdepth* option on the *toctree* node.\n60         If *titles_only* is True, only toplevel document titles will be in the\n61         resulting tree.\n62         If *collapse* is True, all branches not containing docname will\n63         be collapsed.\n64         \"\"\"\n65         if toctree.get('hidden', False) and not includehidden:\n66             return None\n67 \n68         # For reading the following two helper function, it is useful to keep\n69         # in mind the node structure of a toctree (using HTML-like node names\n70         # for brevity):\n71         #\n72         # <ul>\n73         #   <li>\n74         #     <p><a></p>\n75         #     <p><a></p>\n76         #     ...\n77         #     <ul>\n78         #       ...\n79         #     </ul>\n80         #   </li>\n81         # </ul>\n82         #\n83         # The transformation is made in two passes in order to avoid\n84         # interactions between marking and pruning the tree (see bug #1046).\n85 \n86         toctree_ancestors = self.get_toctree_ancestors(docname)\n87         excluded = Matcher(self.env.config.exclude_patterns)\n88 \n89         def _toctree_add_classes(node: Element, depth: int) -> None:\n90             \"\"\"Add 'toctree-l%d' and 'current' classes to the toctree.\"\"\"\n91             for subnode in node.children:\n92                 if isinstance(subnode, (addnodes.compact_paragraph,\n93                                         nodes.list_item)):\n94                     # for <p> and <li>, indicate the depth level and recurse\n95                     subnode['classes'].append('toctree-l%d' % (depth - 1))\n96                     _toctree_add_classes(subnode, depth)\n97                 elif isinstance(subnode, nodes.bullet_list):\n98                     # for <ul>, just recurse\n99                     _toctree_add_classes(subnode, depth + 1)\n100                 elif isinstance(subnode, nodes.reference):\n101                     # for <a>, identify which entries point to the current\n102                     # document and therefore may not be collapsed\n103                     if subnode['refuri'] == docname:\n104                         if not subnode['anchorname']:\n105                             # give the whole branch a 'current' class\n106                             # (useful for styling it differently)\n107                             branchnode = subnode  # type: Element\n108                             while branchnode:\n109                                 branchnode['classes'].append('current')\n110                                 branchnode = branchnode.parent\n111                         # mark the list_item as \"on current page\"\n112                         if subnode.parent.parent.get('iscurrent'):\n113                             # but only if it's not already done\n114                             return\n115                         while subnode:\n116                             subnode['iscurrent'] = True\n117                             subnode = subnode.parent\n118 \n119         def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],\n120                                   separate: bool = False, subtree: bool = False\n121                                   ) -> List[Element]:\n122             \"\"\"Return TOC entries for a toctree node.\"\"\"\n123             refs = [(e[0], e[1]) for e in toctreenode['entries']]\n124             entries = []  # type: List[Element]\n125             for (title, ref) in refs:\n126                 try:\n127                     refdoc = None\n128                     if url_re.match(ref):\n129                         if title is None:\n130                             title = ref\n131                         reference = nodes.reference('', '', internal=False,\n132                                                     refuri=ref, anchorname='',\n133                                                     *[nodes.Text(title)])\n134                         para = addnodes.compact_paragraph('', '', reference)\n135                         item = nodes.list_item('', para)\n136                         toc = nodes.bullet_list('', item)\n137                     elif ref == 'self':\n138                         # 'self' refers to the document from which this\n139                         # toctree originates\n140                         ref = toctreenode['parent']\n141                         if not title:\n142                             title = clean_astext(self.env.titles[ref])\n143                         reference = nodes.reference('', '', internal=True,\n144                                                     refuri=ref,\n145                                                     anchorname='',\n146                                                     *[nodes.Text(title)])\n147                         para = addnodes.compact_paragraph('', '', reference)\n148                         item = nodes.list_item('', para)\n149                         # don't show subitems\n150                         toc = nodes.bullet_list('', item)\n151                     else:\n152                         if ref in parents:\n153                             logger.warning(__('circular toctree references '\n154                                               'detected, ignoring: %s <- %s'),\n155                                            ref, ' <- '.join(parents),\n156                                            location=ref)\n157                             continue\n158                         refdoc = ref\n159                         toc = self.env.tocs[ref].deepcopy()\n160                         maxdepth = self.env.metadata[ref].get('tocdepth', 0)\n161                         if ref not in toctree_ancestors or (prune and maxdepth > 0):\n162                             self._toctree_prune(toc, 2, maxdepth, collapse)\n163                         process_only_nodes(toc, builder.tags)\n164                         if title and toc.children and len(toc.children) == 1:\n165                             child = toc.children[0]\n166                             for refnode in child.traverse(nodes.reference):\n167                                 if refnode['refuri'] == ref and \\\n168                                    not refnode['anchorname']:\n169                                     refnode.children = [nodes.Text(title)]\n170                     if not toc.children:\n171                         # empty toc means: no titles will show up in the toctree\n172                         logger.warning(__('toctree contains reference to document %r that '\n173                                           'doesn\\'t have a title: no link will be generated'),\n174                                        ref, location=toctreenode)\n175                 except KeyError:\n176                     # this is raised if the included file does not exist\n177                     if excluded(self.env.doc2path(ref, None)):\n178                         message = __('toctree contains reference to excluded document %r')\n179                     else:\n180                         message = __('toctree contains reference to nonexisting document %r')\n181 \n182                     logger.warning(message, ref, location=toctreenode)\n183                 else:\n184                     # if titles_only is given, only keep the main title and\n185                     # sub-toctrees\n186                     if titles_only:\n187                         # children of toc are:\n188                         # - list_item + compact_paragraph + (reference and subtoc)\n189                         # - only + subtoc\n190                         # - toctree\n191                         children = cast(Iterable[nodes.Element], toc)\n192 \n193                         # delete everything but the toplevel title(s)\n194                         # and toctrees\n195                         for toplevel in children:\n196                             # nodes with length 1 don't have any children anyway\n197                             if len(toplevel) > 1:\n198                                 subtrees = toplevel.traverse(addnodes.toctree)\n199                                 if subtrees:\n200                                     toplevel[1][:] = subtrees  # type: ignore\n201                                 else:\n202                                     toplevel.pop(1)\n203                     # resolve all sub-toctrees\n204                     for subtocnode in toc.traverse(addnodes.toctree):\n205                         if not (subtocnode.get('hidden', False) and\n206                                 not includehidden):\n207                             i = subtocnode.parent.index(subtocnode) + 1\n208                             for entry in _entries_from_toctree(\n209                                     subtocnode, [refdoc] + parents,\n210                                     subtree=True):\n211                                 subtocnode.parent.insert(i, entry)\n212                                 i += 1\n213                             subtocnode.parent.remove(subtocnode)\n214                     if separate:\n215                         entries.append(toc)\n216                     else:\n217                         children = cast(Iterable[nodes.Element], toc)\n218                         entries.extend(children)\n219             if not subtree and not separate:\n220                 ret = nodes.bullet_list()\n221                 ret += entries\n222                 return [ret]\n223             return entries\n224 \n225         maxdepth = maxdepth or toctree.get('maxdepth', -1)\n226         if not titles_only and toctree.get('titlesonly', False):\n227             titles_only = True\n228         if not includehidden and toctree.get('includehidden', False):\n229             includehidden = True\n230 \n231         # NOTE: previously, this was separate=True, but that leads to artificial\n232         # separation when two or more toctree entries form a logical unit, so\n233         # separating mode is no longer used -- it's kept here for history's sake\n234         tocentries = _entries_from_toctree(toctree, [], separate=False)\n235         if not tocentries:\n236             return None\n237 \n238         newnode = addnodes.compact_paragraph('', '')\n239         caption = toctree.attributes.get('caption')\n240         if caption:\n241             caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])\n242             caption_node.line = toctree.line\n243             caption_node.source = toctree.source\n244             caption_node.rawsource = toctree['rawcaption']\n245             if hasattr(toctree, 'uid'):\n246                 # move uid to caption_node to translate it\n247                 caption_node.uid = toctree.uid  # type: ignore\n248                 del toctree.uid  # type: ignore\n249             newnode += caption_node\n250         newnode.extend(tocentries)\n251         newnode['toctree'] = True\n252 \n253         # prune the tree to maxdepth, also set toc depth and current classes\n254         _toctree_add_classes(newnode, 1)\n255         self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)\n256 \n257         if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found\n258             return None\n259 \n260         # set the target paths in the toctrees (they are not known at TOC\n261         # generation time)\n262         for refnode in newnode.traverse(nodes.reference):\n263             if not url_re.match(refnode['refuri']):\n264                 refnode['refuri'] = builder.get_relative_uri(\n265                     docname, refnode['refuri']) + refnode['anchorname']\n266         return newnode\n267 \n268     def get_toctree_ancestors(self, docname: str) -> List[str]:\n269         parent = {}\n270         for p, children in self.env.toctree_includes.items():\n271             for child in children:\n272                 parent[child] = p\n273         ancestors = []  # type: List[str]\n274         d = docname\n275         while d in parent and d not in ancestors:\n276             ancestors.append(d)\n277             d = parent[d]\n278         return ancestors\n279 \n280     def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False\n281                        ) -> None:\n282         \"\"\"Utility: Cut a TOC at a specified depth.\"\"\"\n283         for subnode in node.children[:]:\n284             if isinstance(subnode, (addnodes.compact_paragraph,\n285                                     nodes.list_item)):\n286                 # for <p> and <li>, just recurse\n287                 self._toctree_prune(subnode, depth, maxdepth, collapse)\n288             elif isinstance(subnode, nodes.bullet_list):\n289                 # for <ul>, determine if the depth is too large or if the\n290                 # entry is to be collapsed\n291                 if maxdepth > 0 and depth > maxdepth:\n292                     subnode.parent.replace(subnode, [])\n293                 else:\n294                     # cull sub-entries whose parents aren't 'current'\n295                     if (collapse and depth > 1 and\n296                             'iscurrent' not in subnode.parent):\n297                         subnode.parent.remove(subnode)\n298                     else:\n299                         # recurse on visible children\n300                         self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)\n301 \n302     def get_toc_for(self, docname: str, builder: \"Builder\") -> Node:\n303         \"\"\"Return a TOC nodetree -- for use on the same page only!\"\"\"\n304         tocdepth = self.env.metadata[docname].get('tocdepth', 0)\n305         try:\n306             toc = self.env.tocs[docname].deepcopy()\n307             self._toctree_prune(toc, 2, tocdepth)\n308         except KeyError:\n309             # the document does not exist anymore: return a dummy node that\n310             # renders to nothing\n311             return nodes.paragraph()\n312         process_only_nodes(toc, builder.tags)\n313         for node in toc.traverse(nodes.reference):\n314             node['refuri'] = node['anchorname'] or '#'\n315         return toc\n316 \n317     def get_toctree_for(self, docname: str, builder: \"Builder\", collapse: bool,\n318                         **kwargs: Any) -> Element:\n319         \"\"\"Return the global TOC nodetree.\"\"\"\n320         doctree = self.env.get_doctree(self.env.config.master_doc)\n321         toctrees = []  # type: List[Element]\n322         if 'includehidden' not in kwargs:\n323             kwargs['includehidden'] = True\n324         if 'maxdepth' not in kwargs:\n325             kwargs['maxdepth'] = 0\n326         kwargs['collapse'] = collapse\n327         for toctreenode in doctree.traverse(addnodes.toctree):\n328             toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)\n329             if toctree:\n330                 toctrees.append(toctree)\n331         if not toctrees:\n332             return None\n333         result = toctrees[0]\n334         for toctree in toctrees[1:]:\n335             result.extend(toctree.children)\n336         return result\n",
        "intended_behavior": "This file should incorporate a mechanism to explicitly manage or warn about file extension preferences or conflicts when processing toctree directives. The logic should either allow for a configuration option specifying the order of preference for file extensions or, if such an option isn\u2019t set, log a warning when a potential conflict is detected (e.g., when both a.md and a.rst are present). This would help ensure that users are made aware of potential unexpected behaviors in documentation builds and can specify preferences to align Sphinx's behavior with their expectations."
    },
    {
        "rel_file_path": "sphinx/application.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/application.py",
        "start": 1059,
        "end": 1069,
        "class_name": null,
        "method_name": "add_source_parser",
        "code": "1059     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:\n1060         \"\"\"Register a parser class.\n1061 \n1062         .. versionadded:: 1.4\n1063         .. versionchanged:: 1.8\n1064            *suffix* argument is deprecated.  It only accepts *parser* argument.\n1065            Use :meth:`add_source_suffix` API to register suffix instead.\n1066         .. versionchanged:: 1.8\n1067            Add *override* keyword.\n1068         \"\"\"\n1069         self.registry.add_source_parser(*args, **kwargs)\n",
        "intended_behavior": "Within these files, particularly around the add_source_parser method, there should be an enhancement to handle and prioritize which parser to use when multiple extensions are applicable for the same filename. This might include improving the mechanism for registering source parsers to include priority settings or developing a new approach to parser selection that accommodates user-defined preferences. The goal is to create a predictable and transparent method that decides which file to include when there's a conflict between files of different extensions that could be processed by different parsers."
    },
    {
        "rel_file_path": "sphinx/application.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/application.py",
        "start": 1059,
        "end": 1069,
        "class_name": "Sphinx",
        "method_name": "add_source_parser",
        "code": "1059     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:\n1060         \"\"\"Register a parser class.\n1061 \n1062         .. versionadded:: 1.4\n1063         .. versionchanged:: 1.8\n1064            *suffix* argument is deprecated.  It only accepts *parser* argument.\n1065            Use :meth:`add_source_suffix` API to register suffix instead.\n1066         .. versionchanged:: 1.8\n1067            Add *override* keyword.\n1068         \"\"\"\n1069         self.registry.add_source_parser(*args, **kwargs)\n",
        "intended_behavior": "Within these files, particularly around the add_source_parser method, there should be an enhancement to handle and prioritize which parser to use when multiple extensions are applicable for the same filename. This might include improving the mechanism for registering source parsers to include priority settings or developing a new approach to parser selection that accommodates user-defined preferences. The goal is to create a predictable and transparent method that decides which file to include when there's a conflict between files of different extensions that could be processed by different parsers."
    },
    {
        "rel_file_path": "sphinx/registry.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/registry.py",
        "start": 260,
        "end": 269,
        "class_name": null,
        "method_name": "add_source_parser",
        "code": "260     def add_source_parser(self, parser: \"Type[Parser]\", **kwargs: Any) -> None:\n261         logger.debug('[app] adding search source_parser: %r', parser)\n262 \n263         # create a map from filetype to parser\n264         for filetype in parser.supported:\n265             if filetype in self.source_parsers and not kwargs.get('override'):\n266                 raise ExtensionError(__('source_parser for %r is already registered') %\n267                                      filetype)\n268             else:\n269                 self.source_parsers[filetype] = parser\n",
        "intended_behavior": "Within these files, particularly around the add_source_parser method, there should be an enhancement to handle and prioritize which parser to use when multiple extensions are applicable for the same filename. This might include improving the mechanism for registering source parsers to include priority settings or developing a new approach to parser selection that accommodates user-defined preferences. The goal is to create a predictable and transparent method that decides which file to include when there's a conflict between files of different extensions that could be processed by different parsers."
    },
    {
        "rel_file_path": "sphinx/registry.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/registry.py",
        "start": 260,
        "end": 269,
        "class_name": "SphinxComponentRegistry",
        "method_name": "add_source_parser",
        "code": "260     def add_source_parser(self, parser: \"Type[Parser]\", **kwargs: Any) -> None:\n261         logger.debug('[app] adding search source_parser: %r', parser)\n262 \n263         # create a map from filetype to parser\n264         for filetype in parser.supported:\n265             if filetype in self.source_parsers and not kwargs.get('override'):\n266                 raise ExtensionError(__('source_parser for %r is already registered') %\n267                                      filetype)\n268             else:\n269                 self.source_parsers[filetype] = parser\n",
        "intended_behavior": "Within these files, particularly around the add_source_parser method, there should be an enhancement to handle and prioritize which parser to use when multiple extensions are applicable for the same filename. This might include improving the mechanism for registering source parsers to include priority settings or developing a new approach to parser selection that accommodates user-defined preferences. The goal is to create a predictable and transparent method that decides which file to include when there's a conflict between files of different extensions that could be processed by different parsers."
    }
]